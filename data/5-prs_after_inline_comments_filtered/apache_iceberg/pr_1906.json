{"pr_number": 1906, "pr_title": "Migrate Procedures", "pr_createdAt": "2020-12-10T20:05:46Z", "pr_url": "https://github.com/apache/iceberg/pull/1906", "timeline": [{"oid": "9ee31fbb2f77ab2b86cf398a1d0ea5a698fc6567", "url": "https://github.com/apache/iceberg/commit/9ee31fbb2f77ab2b86cf398a1d0ea5a698fc6567", "message": "Adds Procedures for Migrate and And Snapshot\n\nAdds new procedures which take the same args as the Actions but can be accessed via\nSQL.", "committedDate": "2020-12-10T20:05:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2Mjk3Mg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540462972", "bodyText": "I'll one line this", "author": "RussellSpitzer", "createdAt": "2020-12-10T20:08:43Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/BaseProcedure.java", "diffHunk": "@@ -70,21 +78,23 @@ protected BaseProcedure(TableCatalog tableCatalog) {\n   }\n \n   protected Identifier toIdentifier(String identifierAsString, String argName) {\n-    Preconditions.checkArgument(identifierAsString != null && !identifierAsString.isEmpty(),\n-        \"Cannot handle an empty identifier for argument %s\", argName);\n-\n-    CatalogAndIdentifier catalogAndIdentifier = Spark3Util.catalogAndIdentifier(\n-        \"identifier for arg \" + argName, spark, identifierAsString, tableCatalog);\n-\n-    CatalogPlugin catalog = catalogAndIdentifier.catalog();\n-    Identifier identifier = catalogAndIdentifier.identifier();\n+    CatalogAndIdentifier catalogAndIdentifier = toCatalogAndIdentifer(identifierAsString, argName, tableCatalog);\n \n     Preconditions.checkArgument(\n-        catalog.equals(tableCatalog),\n+        catalogAndIdentifier.catalog().equals(tableCatalog),\n         \"Cannot run procedure in catalog '%s': '%s' is a table in catalog '%s'\",\n-        tableCatalog.name(), identifierAsString, catalog.name());\n+        tableCatalog.name(), identifierAsString, catalogAndIdentifier.catalog().name());\n+\n+    return catalogAndIdentifier.identifier();\n+  }\n+\n+  protected CatalogAndIdentifier toCatalogAndIdentifer(String identifierAsString, String argName,\n+                                                       CatalogPlugin catalog) {\n+    Preconditions.checkArgument(identifierAsString != null && !identifierAsString.isEmpty(),\n+        \"Cannot handle an empty identifier for argument %s\", argName);\n \n-    return identifier;\n+    return Spark3Util.catalogAndIdentifier(", "originalCommit": "9ee31fbb2f77ab2b86cf398a1d0ea5a698fc6567", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NDA3Mg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540464072", "bodyText": "To keep the following to 1 line per entry", "author": "RussellSpitzer", "createdAt": "2020-12-10T20:10:39Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataType;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final DataType MAP = DataTypes.createMapType(DataTypes.StringType, DataTypes.StringType);", "originalCommit": "9ee31fbb2f77ab2b86cf398a1d0ea5a698fc6567", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NjU1NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540466555", "bodyText": "Calling scala from java", "author": "RussellSpitzer", "createdAt": "2020-12-10T20:14:43Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotProcedure.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataType;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotProcedure extends BaseProcedure {\n+  private static final DataType MAP = DataTypes.createMapType(DataTypes.StringType, DataTypes.StringType);\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"snapshot_source\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private SnapshotProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<SnapshotProcedure>() {\n+      @Override\n+      protected SnapshotProcedure doBuild() {\n+        return new SnapshotProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String source = args.getString(0);\n+    String dest = args.getString(1);\n+\n+    String snapshotLocation = args.isNullAt(2) ? null : args.getString(2);\n+\n+    Map<String, String> options = new HashMap<>();\n+    if (!args.isNullAt(3)) {\n+      args.getMap(3).foreach(DataTypes.StringType, DataTypes.StringType,", "originalCommit": "9ee31fbb2f77ab2b86cf398a1d0ea5a698fc6567", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NzQwNw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540577407", "bodyText": "Yeah, maybe we should rely on Scala conversions and then do all the logic in Java? I'm not sure what impact this may have on compatibility, but I'd rather not break because Scala changes something.", "author": "rdblue", "createdAt": "2020-12-10T23:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NjU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5NzMyOA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540597328", "bodyText": "This is a little difficult because it's the Scala method on InternalRow which doesn't really return a map, it returns \"catalyst.util.MapData\", so it's not a real map and the method we are using is\n  def foreach(keyType: DataType, valueType: DataType, f: (Any, Any) => Unit): Unit = {\nI thought about writing another method to convert MapData to Java maps but that also seems brittle. I think the safest thing to do here is use the Scala Method for MapData.foreach", "author": "RussellSpitzer", "createdAt": "2020-12-11T00:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NjU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYwNjA2MA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540606060", "bodyText": "Sounds reasonable to me.", "author": "rdblue", "createdAt": "2020-12-11T00:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NjU1NQ=="}], "type": "inlineReview"}, {"oid": "9de4fc6aee6f7f62697ffd15e41ed80a799878c6", "url": "https://github.com/apache/iceberg/commit/9de4fc6aee6f7f62697ffd15e41ed80a799878c6", "message": "Minor Cleanup", "committedDate": "2020-12-10T20:16:11Z", "type": "commit"}, {"oid": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "url": "https://github.com/apache/iceberg/commit/3de93e32df8261a241e842d499e86fba9ad9fc9f", "message": "Make grammer consistent", "committedDate": "2020-12-10T20:23:53Z", "type": "commit"}, {"oid": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "url": "https://github.com/apache/iceberg/commit/3de93e32df8261a241e842d499e86fba9ad9fc9f", "message": "Make grammer consistent", "committedDate": "2020-12-10T20:23:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxMzczNA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540513734", "bodyText": "nit: how common is it to be in BaseProcedure? Not a strong opinion, just asking.", "author": "aokolnychyi", "createdAt": "2020-12-10T21:35:22Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/BaseProcedure.java", "diffHunk": "@@ -37,9 +37,13 @@\n import org.apache.spark.sql.connector.iceberg.catalog.Procedure;\n import org.apache.spark.sql.execution.CacheManager;\n import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation;\n+import org.apache.spark.sql.types.DataType;\n+import org.apache.spark.sql.types.DataTypes;\n import scala.Option;\n \n abstract class BaseProcedure implements Procedure {\n+  protected static final DataType STRING_MAP = DataTypes.createMapType(DataTypes.StringType, DataTypes.StringType);", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyMzY0MQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540523641", "bodyText": "2 Procedures at the moment \ud83e\udd37 so not that common, but more than once", "author": "RussellSpitzer", "createdAt": "2020-12-10T21:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxMzczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwMjA0MQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540802041", "bodyText": "Let's keep it.", "author": "aokolnychyi", "createdAt": "2020-12-11T09:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxMzczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyMjU5NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540522595", "bodyText": "Should we make it migrated_files_count to match other procedures?", "author": "aokolnychyi", "createdAt": "2020-12-10T21:50:52Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyMzAxMA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540523010", "bodyText": "nit: let's import ProcedureBuilder directly to match other procedures.", "author": "aokolnychyi", "createdAt": "2020-12-10T21:51:39Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNDAyMw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540524023", "bodyText": "nit: MigrateTableProcedure?", "author": "aokolnychyi", "createdAt": "2020-12-10T21:53:34Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNDEyNA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540524124", "bodyText": "I am afraid this description will not show properly in the SQL plan. Let's make it MigrateTableProcedure as in other procedures.", "author": "aokolnychyi", "createdAt": "2020-12-10T21:53:47Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateProcedure>() {\n+      @Override\n+      protected MigrateProcedure doBuild() {\n+        return new MigrateProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    Map<String, String> options = new HashMap<>();\n+    if (!args.isNullAt(1)) {\n+      args.getMap(1).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    String tableName = args.getString(0);\n+    CatalogAndIdentifier tableIdent = toCatalogAndIdentifer(tableName, PARAMETERS[0].name(), tableCatalog());\n+    CreateAction action =  new Spark3MigrateAction(spark(), tableIdent.catalog(), tableIdent.identifier());\n+\n+    long numFiles = action.withProperties(options).execute();\n+    return new InternalRow[] {newInternalRow(numFiles)};\n+  }\n+\n+  @Override\n+  public String description() {", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMjQyMQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540532421", "bodyText": "ah yeah, sorry", "author": "RussellSpitzer", "createdAt": "2020-12-10T22:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NjQ0Mw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540576443", "bodyText": "The SQL plan uses description? I would expect description to be documentation and for the plan to use a method like planString. Not something we need to fix here.", "author": "rdblue", "createdAt": "2020-12-10T23:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNDEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NjE2Ng==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540846166", "bodyText": "Sounds like something we can address while adding support for describing procedures.", "author": "aokolnychyi", "createdAt": "2020-12-11T10:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNDEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNDM1MQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540524351", "bodyText": "nit: extra space", "author": "aokolnychyi", "createdAt": "2020-12-10T21:54:12Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateProcedure>() {\n+      @Override\n+      protected MigrateProcedure doBuild() {\n+        return new MigrateProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    Map<String, String> options = new HashMap<>();\n+    if (!args.isNullAt(1)) {\n+      args.getMap(1).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    String tableName = args.getString(0);\n+    CatalogAndIdentifier tableIdent = toCatalogAndIdentifer(tableName, PARAMETERS[0].name(), tableCatalog());\n+    CreateAction action =  new Spark3MigrateAction(spark(), tableIdent.catalog(), tableIdent.identifier());", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyOTA0OA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540529048", "bodyText": "typo? toCatalogAndIdentifer -> toCatalogAndIdentifier?", "author": "aokolnychyi", "createdAt": "2020-12-10T22:02:02Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/BaseProcedure.java", "diffHunk": "@@ -70,21 +82,22 @@ protected BaseProcedure(TableCatalog tableCatalog) {\n   }\n \n   protected Identifier toIdentifier(String identifierAsString, String argName) {\n-    Preconditions.checkArgument(identifierAsString != null && !identifierAsString.isEmpty(),\n-        \"Cannot handle an empty identifier for argument %s\", argName);\n-\n-    CatalogAndIdentifier catalogAndIdentifier = Spark3Util.catalogAndIdentifier(\n-        \"identifier for arg \" + argName, spark, identifierAsString, tableCatalog);\n-\n-    CatalogPlugin catalog = catalogAndIdentifier.catalog();\n-    Identifier identifier = catalogAndIdentifier.identifier();\n+    CatalogAndIdentifier catalogAndIdentifier = toCatalogAndIdentifer(identifierAsString, argName, tableCatalog);\n \n     Preconditions.checkArgument(\n-        catalog.equals(tableCatalog),\n+        catalogAndIdentifier.catalog().equals(tableCatalog),\n         \"Cannot run procedure in catalog '%s': '%s' is a table in catalog '%s'\",\n-        tableCatalog.name(), identifierAsString, catalog.name());\n+        tableCatalog.name(), identifierAsString, catalogAndIdentifier.catalog().name());\n+\n+    return catalogAndIdentifier.identifier();\n+  }\n+\n+  protected CatalogAndIdentifier toCatalogAndIdentifer(String identifierAsString, String argName,", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMjczNw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540532737", "bodyText": "ah yeah, let me fix that", "author": "RussellSpitzer", "createdAt": "2020-12-10T22:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyOTA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyOTM2NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540529365", "bodyText": "nit: Maps.newHashMap()?", "author": "aokolnychyi", "createdAt": "2020-12-10T22:02:34Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateProcedure>() {\n+      @Override\n+      protected MigrateProcedure doBuild() {\n+        return new MigrateProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    Map<String, String> options = new HashMap<>();", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMDQ1Nw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540530457", "bodyText": "Should it be table_properties or just properties? There will be a difference between options and properties in Spark 3.1.0.", "author": "aokolnychyi", "createdAt": "2020-12-10T22:04:31Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NDUzOQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540574539", "bodyText": "I like simpler, as long as it is clear. And I agree that we should not use options because of the specific meaning with datasource tables. properties is fine with me.", "author": "rdblue", "createdAt": "2020-12-10T23:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMzU0Ng==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540533546", "bodyText": "I find it a bit misleading that we don't process arguments in the order they are defined.\nHow about this?\n    String identAsString = args.getString(0);\n    CatalogAndIdentifier catalogAndIdent = toCatalogAndIdentifer(identAsString, PARAMETERS[0].name(), tableCatalog());\n\n    Map<String, String> tableProps = Maps.newHashMap();\n    MapData providedProps = args.getMap(1);\n    if (providedProps != null) {\n      providedProps.foreach(DataTypes.StringType, DataTypes.StringType,\n          (k, v) -> {\n            tableProps.put(k.toString(), v.toString());\n            return BoxedUnit.UNIT;\n          });\n    }", "author": "aokolnychyi", "createdAt": "2020-12-10T22:09:59Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateProcedure>() {\n+      @Override\n+      protected MigrateProcedure doBuild() {\n+        return new MigrateProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    Map<String, String> options = new HashMap<>();\n+    if (!args.isNullAt(1)) {\n+      args.getMap(1).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    String tableName = args.getString(0);", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMzcxNQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540533715", "bodyText": "nit: numMigratedFiles?", "author": "aokolnychyi", "createdAt": "2020-12-10T22:10:15Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateProcedure>() {\n+      @Override\n+      protected MigrateProcedure doBuild() {\n+        return new MigrateProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    Map<String, String> options = new HashMap<>();\n+    if (!args.isNullAt(1)) {\n+      args.getMap(1).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    String tableName = args.getString(0);\n+    CatalogAndIdentifier tableIdent = toCatalogAndIdentifer(tableName, PARAMETERS[0].name(), tableCatalog());\n+    CreateAction action =  new Spark3MigrateAction(spark(), tableIdent.catalog(), tableIdent.identifier());\n+\n+    long numFiles = action.withProperties(options).execute();", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMzk1Mg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540533952", "bodyText": "nit: options -> tableProps?", "author": "aokolnychyi", "createdAt": "2020-12-10T22:10:41Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateProcedure>() {\n+      @Override\n+      protected MigrateProcedure doBuild() {\n+        return new MigrateProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    Map<String, String> options = new HashMap<>();", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNDYzNg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540534636", "bodyText": "What about source_table, table, table_location, table_properties? cc @RussellSpitzer @rdblue", "author": "aokolnychyi", "createdAt": "2020-12-10T22:11:48Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotProcedure.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"snapshot_source\", DataTypes.StringType),", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNDg5Mg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540534892", "bodyText": "We may add dest prefix if we want to but I am not sure.", "author": "aokolnychyi", "createdAt": "2020-12-10T22:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NTA3OQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540575079", "bodyText": "I really like source and dest here :/", "author": "RussellSpitzer", "createdAt": "2020-12-10T23:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NjkwNg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540576906", "bodyText": "+1 to those argument names. I'd be okay with just properties and location, but I'm fine with the table_ prefix as well. (It should also match what we do for migrate.)", "author": "rdblue", "createdAt": "2020-12-10T23:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNDYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYwNTQ3NA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540605474", "bodyText": "I think @RussellSpitzer and I commented at the same time so I didn't see his comment. I think it would be fine to use source_table and dest_table.\nI just don't think that including the procedure name in the argument names is helpful. So rather than snapshot_source I would use source_table.", "author": "rdblue", "createdAt": "2020-12-11T00:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNDYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNTIyNA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540535224", "bodyText": "imported_data_files_count?", "author": "aokolnychyi", "createdAt": "2020-12-10T22:12:43Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotProcedure.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"snapshot_source\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNTUxMg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540535512", "bodyText": "Same comments as for migrate.", "author": "aokolnychyi", "createdAt": "2020-12-10T22:13:14Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotProcedure.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"snapshot_source\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private SnapshotProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<SnapshotProcedure>() {\n+      @Override\n+      protected SnapshotProcedure doBuild() {\n+        return new SnapshotProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String source = args.getString(0);\n+    String dest = args.getString(1);\n+\n+    String snapshotLocation = args.isNullAt(2) ? null : args.getString(2);\n+\n+    Map<String, String> options = Maps.newHashMap();\n+    if (!args.isNullAt(3)) {\n+      args.getMap(3).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    CatalogAndIdentifier sourceIdent = toCatalogAndIdentifer(source, PARAMETERS[0].name(), tableCatalog());", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNTY4Mw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540535683", "bodyText": "same comments as for migrate.", "author": "aokolnychyi", "createdAt": "2020-12-10T22:13:32Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotProcedure.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"snapshot_source\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private SnapshotProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<SnapshotProcedure>() {\n+      @Override\n+      protected SnapshotProcedure doBuild() {\n+        return new SnapshotProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String source = args.getString(0);\n+    String dest = args.getString(1);\n+\n+    String snapshotLocation = args.isNullAt(2) ? null : args.getString(2);\n+\n+    Map<String, String> options = Maps.newHashMap();\n+    if (!args.isNullAt(3)) {\n+      args.getMap(3).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    CatalogAndIdentifier sourceIdent = toCatalogAndIdentifer(source, PARAMETERS[0].name(), tableCatalog());\n+    CatalogAndIdentifier destIdent = toCatalogAndIdentifer(dest, PARAMETERS[1].name(), tableCatalog());\n+\n+    Preconditions.checkArgument(sourceIdent != destIdent || sourceIdent.catalog() != destIdent.catalog(),\n+        \"Cannot create a snapshot with the same name as the source of the snapshot.\");\n+    SnapshotAction action =  new Spark3SnapshotAction(spark(), sourceIdent.catalog(), sourceIdent.identifier(),\n+        destIdent.catalog(), destIdent.identifier());\n+\n+    long numFiles;", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNTg2NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540535865", "bodyText": "SnapshotTableProcedure?", "author": "aokolnychyi", "createdAt": "2020-12-10T22:13:53Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotProcedure.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotProcedure extends BaseProcedure {", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNjA2MA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540536060", "bodyText": "same here. SnapshotTableProcedure?", "author": "aokolnychyi", "createdAt": "2020-12-10T22:14:11Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotProcedure.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"snapshot_source\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private SnapshotProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<SnapshotProcedure>() {\n+      @Override\n+      protected SnapshotProcedure doBuild() {\n+        return new SnapshotProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String source = args.getString(0);\n+    String dest = args.getString(1);\n+\n+    String snapshotLocation = args.isNullAt(2) ? null : args.getString(2);\n+\n+    Map<String, String> options = Maps.newHashMap();\n+    if (!args.isNullAt(3)) {\n+      args.getMap(3).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    CatalogAndIdentifier sourceIdent = toCatalogAndIdentifer(source, PARAMETERS[0].name(), tableCatalog());\n+    CatalogAndIdentifier destIdent = toCatalogAndIdentifer(dest, PARAMETERS[1].name(), tableCatalog());\n+\n+    Preconditions.checkArgument(sourceIdent != destIdent || sourceIdent.catalog() != destIdent.catalog(),\n+        \"Cannot create a snapshot with the same name as the source of the snapshot.\");\n+    SnapshotAction action =  new Spark3SnapshotAction(spark(), sourceIdent.catalog(), sourceIdent.identifier(),\n+        destIdent.catalog(), destIdent.identifier());\n+\n+    long numFiles;\n+    if (snapshotLocation != null) {\n+      numFiles = action.withLocation(snapshotLocation).withProperties(options).execute();\n+    } else {\n+      numFiles = action.withProperties(options).execute();\n+    }\n+\n+    return new InternalRow[] {newInternalRow(numFiles)};\n+  }\n+\n+  @Override\n+  public String description() {\n+    return \"Creates an Iceberg table from a Spark Table. The Created table will be isolated from the original table\" +", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NDgwMw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540564803", "bodyText": "There's a scalarSql method for when a SQL command produces one row with one value. That will assert that there is only one row and one column, which may be easier.", "author": "rdblue", "createdAt": "2020-12-10T23:03:41Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NjYyMA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540566620", "bodyText": "Since the location is set, should this validate that the migrated table's location matches the one passed here?", "author": "rdblue", "createdAt": "2020-12-10T23:06:12Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testMigrateWithOptions() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2Njg1Mw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540566853", "bodyText": "Other tests drop the table if exists rather than using IF NOT EXISTS. I think that's a better pattern because if the table already exists, it probably violates the assumptions of this test.", "author": "rdblue", "createdAt": "2020-12-10T23:06:42Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testMigrateWithOptions() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s', map('foo', 'bar'))\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYzMjUwOA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540632508", "bodyText": "ah yeah I only had that because I ran a test and canceled while it was running, I should have removed it", "author": "RussellSpitzer", "createdAt": "2020-12-11T01:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2Njg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NzI4MQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540567281", "bodyText": "\"migrated\" -> \"added\"?", "author": "rdblue", "createdAt": "2020-12-10T23:07:23Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testMigrateWithOptions() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s', map('foo', 'bar'))\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NzY0NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540567645", "bodyText": "Since the source table has a known location, I think this should validate that the snapshot table uses a different one.", "author": "rdblue", "createdAt": "2020-12-10T23:08:05Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testMigrateWithOptions() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s', map('foo', 'bar'))\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTIzOQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540571239", "bodyText": "Nit: I don't think we need to keep adding these checks since it tests the resolver, not the procedure.", "author": "rdblue", "createdAt": "2020-12-10T23:16:24Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testMigrateWithOptions() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s', map('foo', 'bar'))\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\n+        \"CALL %s.system.snapshot( snapshot_source => '%s', table => '%s', table_options => map('foo','bar'))\",\n+        catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithAlternateLocation() throws IOException {\n+    Assume.assumeTrue(\"No Snapshoting with Alternate locations with Hadoop Catalogs\", !catalogName.contains(\"hadoop\"));\n+    String location = temp.newFolder().toString();\n+    String snapshotLocation = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\n+        \"CALL %s.system.snapshot( snapshot_source => '%s', table => '%s', table_location => '%s')\",\n+        catalogName, sourceName, tableName, snapshotLocation).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    String storageLocation = validationCatalog.loadTable(tableIdent).location();\n+    Assert.assertEquals(\"Snapshot should be made at specified location\", snapshotLocation, storageLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testInvalidSnapshotsCases() {\n+    AssertHelpers.assertThrows(\"Should not allow mixed args\",\n+        AnalysisException.class, \"Named and positional arguments cannot be mixed\",\n+        () -> sql(\"CALL %s.system.snapshot('n', table => 't')\", catalogName));", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1ODYyNg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540658626", "bodyText": "Sure I can remove these", "author": "RussellSpitzer", "createdAt": "2020-12-11T03:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTQ1MA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540571450", "bodyText": "Similarly, this isn't the procedure name.", "author": "rdblue", "createdAt": "2020-12-10T23:16:49Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testMigrateWithOptions() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s', map('foo', 'bar'))\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\n+        \"CALL %s.system.snapshot( snapshot_source => '%s', table => '%s', table_options => map('foo','bar'))\",\n+        catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithAlternateLocation() throws IOException {\n+    Assume.assumeTrue(\"No Snapshoting with Alternate locations with Hadoop Catalogs\", !catalogName.contains(\"hadoop\"));\n+    String location = temp.newFolder().toString();\n+    String snapshotLocation = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\n+        \"CALL %s.system.snapshot( snapshot_source => '%s', table => '%s', table_location => '%s')\",\n+        catalogName, sourceName, tableName, snapshotLocation).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    String storageLocation = validationCatalog.loadTable(tableIdent).location();\n+    Assert.assertEquals(\"Snapshot should be made at specified location\", snapshotLocation, storageLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testInvalidSnapshotsCases() {\n+    AssertHelpers.assertThrows(\"Should not allow mixed args\",\n+        AnalysisException.class, \"Named and positional arguments cannot be mixed\",\n+        () -> sql(\"CALL %s.system.snapshot('n', table => 't')\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should not resolve procedures in arbitrary namespaces\",\n+        NoSuchProcedureException.class, \"not found\",\n+        () -> sql(\"CALL %s.custom.snapshot('n', 't')\", catalogName));", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MTg4Mw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540571883", "bodyText": "This can only validate one case, where either source or dest is empty. I think this should be split into empty source and empty dest cases.", "author": "rdblue", "createdAt": "2020-12-10T23:17:47Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestCreateProcedures(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testMigrate() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"DROP TABLE IF EXISTS %s_BACKUP_\", tableName);\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s')\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testMigrateWithOptions() throws IOException {\n+    Assume.assumeTrue(catalogName.equals(\"spark_catalog\"));\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", tableName, location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+    Object[] result = sql(\"CALL %s.system.migrate('%s', map('foo', 'bar'))\", catalogName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\n+        \"CALL %s.system.snapshot( snapshot_source => '%s', table => '%s', table_options => map('foo','bar'))\",\n+        catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    Map<String, String> props = validationCatalog.loadTable(tableIdent).properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithAlternateLocation() throws IOException {\n+    Assume.assumeTrue(\"No Snapshoting with Alternate locations with Hadoop Catalogs\", !catalogName.contains(\"hadoop\"));\n+    String location = temp.newFolder().toString();\n+    String snapshotLocation = temp.newFolder().toString();\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\n+        \"CALL %s.system.snapshot( snapshot_source => '%s', table => '%s', table_location => '%s')\",\n+        catalogName, sourceName, tableName, snapshotLocation).get(0);\n+\n+    Assert.assertEquals(\"Should have migrated one file\", 1L, result[0]);\n+\n+    String storageLocation = validationCatalog.loadTable(tableIdent).location();\n+    Assert.assertEquals(\"Snapshot should be made at specified location\", snapshotLocation, storageLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testInvalidSnapshotsCases() {\n+    AssertHelpers.assertThrows(\"Should not allow mixed args\",\n+        AnalysisException.class, \"Named and positional arguments cannot be mixed\",\n+        () -> sql(\"CALL %s.system.snapshot('n', table => 't')\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should not resolve procedures in arbitrary namespaces\",\n+        NoSuchProcedureException.class, \"not found\",\n+        () -> sql(\"CALL %s.custom.snapshot('n', 't')\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should reject calls without all required args\",\n+        AnalysisException.class, \"Missing required parameters\",\n+        () -> sql(\"CALL %s.system.snapshot('foo')\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should reject calls with invalid arg types\",\n+        AnalysisException.class, \"Wrong arg type\",\n+        () -> sql(\"CALL %s.system.snapshot('n', 't', map('foo', 'bar'))\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should reject calls with empty table identifier\",\n+        IllegalArgumentException.class, \"Cannot handle an empty identifier\",\n+        () -> sql(\"CALL %s.system.snapshot('', '')\", catalogName));", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MjY5OQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540572699", "bodyText": "I like how the other procedures are tested in a suite named after the procedure, like TestRemoveOrphanFilesProcedure. I don't see much value in a suite for both migrate and snapshot together and it isn't obvious where these tests live. Could you split this into TestMigrateProcedure and TestSnapshotProcedure?", "author": "rdblue", "createdAt": "2020-12-10T23:19:26Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestCreateProcedures.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchProcedureException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestCreateProcedures extends SparkExtensionsTestBase {", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NTg2NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540575865", "bodyText": "What is the rationale for creating actions directly instead of going through Actions?", "author": "rdblue", "createdAt": "2020-12-10T23:26:44Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateProcedure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_options\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"num_datafiles_included\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateProcedure>() {\n+      @Override\n+      protected MigrateProcedure doBuild() {\n+        return new MigrateProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    Map<String, String> options = new HashMap<>();\n+    if (!args.isNullAt(1)) {\n+      args.getMap(1).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    String tableName = args.getString(0);\n+    CatalogAndIdentifier tableIdent = toCatalogAndIdentifer(tableName, PARAMETERS[0].name(), tableCatalog());\n+    CreateAction action =  new Spark3MigrateAction(spark(), tableIdent.catalog(), tableIdent.identifier());", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY2MzA1Nw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540663057", "bodyText": "We have to do this for the default catalog switch. The Actions api uses our normal catalogAndIdentifier method which defaults to using the CatalogManager currentCatalog for the default catalog", "author": "RussellSpitzer", "createdAt": "2020-12-11T03:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NTg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3ODU0NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540578545", "bodyText": "Hm. I would prefer not to make these public, but I see that this needs the identifier that has already been parsed to do the custom catalog validation. Should be fine for now, but we should keep this in mind for when we fix the Actions API.", "author": "rdblue", "createdAt": "2020-12-10T23:33:14Z", "path": "spark3/src/main/java/org/apache/iceberg/actions/Spark3MigrateAction.java", "diffHunk": "@@ -46,11 +46,11 @@\n  * previously referred to a non-iceberg table will refer to the newly migrated iceberg\n  * table.\n  */\n-class Spark3MigrateAction extends Spark3CreateAction {\n+public class Spark3MigrateAction extends Spark3CreateAction {", "originalCommit": "3de93e32df8261a241e842d499e86fba9ad9fc9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1NzE5OQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540657199", "bodyText": "I think we should really have all of these spark implementations of actions in a \"spark\" package so we don't have to public everything.", "author": "RussellSpitzer", "createdAt": "2020-12-11T03:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3ODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5MjYzNg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540792636", "bodyText": "This is another point to fix in actions before we release 0.11.", "author": "aokolnychyi", "createdAt": "2020-12-11T09:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3ODU0NQ=="}], "type": "inlineReview"}, {"oid": "d265b1527cdbab753aa4deccf63d649a085a5b4e", "url": "https://github.com/apache/iceberg/commit/d265b1527cdbab753aa4deccf63d649a085a5b4e", "message": "Reviewer comments/Migrate location fix", "committedDate": "2020-12-11T03:03:38Z", "type": "commit"}, {"oid": "40b19eee15a0cacaa9e18233e398ff9f9deccd69", "url": "https://github.com/apache/iceberg/commit/40b19eee15a0cacaa9e18233e398ff9f9deccd69", "message": "Split Migrate and Snapshot Procedure Tests", "committedDate": "2020-12-11T03:15:31Z", "type": "commit"}, {"oid": "97c2251656df1eaebd06ec886ec31d979b20b576", "url": "https://github.com/apache/iceberg/commit/97c2251656df1eaebd06ec886ec31d979b20b576", "message": "Fix Table Creation Deletion in Tests", "committedDate": "2020-12-11T04:36:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NDY2NA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540794664", "bodyText": "nit: this could fit on one line, right?", "author": "aokolnychyi", "createdAt": "2020-12-11T09:07:09Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestSnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestSnapshotTableProcedure extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestSnapshotTableProcedure(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NDk2NA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540794964", "bodyText": "nit: scalarSql method should be used", "author": "aokolnychyi", "createdAt": "2020-12-11T09:07:33Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestSnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestSnapshotTableProcedure extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestSnapshotTableProcedure(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NTY2NQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540795665", "bodyText": "nit: this should fit on one line", "author": "aokolnychyi", "createdAt": "2020-12-11T09:08:45Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestSnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestSnapshotTableProcedure extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestSnapshotTableProcedure(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result[0]);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NTc4OA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540795788", "bodyText": "nit: withProperties?", "author": "aokolnychyi", "createdAt": "2020-12-11T09:08:59Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestSnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestSnapshotTableProcedure extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestSnapshotTableProcedure(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result[0]);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5Njc4MA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540796780", "bodyText": "nit: scalarSql", "author": "aokolnychyi", "createdAt": "2020-12-11T09:10:33Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestSnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestSnapshotTableProcedure extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestSnapshotTableProcedure(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result[0]);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object result = scalarSql(\n+        \"CALL %s.system.snapshot(source_table => '%s', table => '%s', properties => map('foo','bar'))\",\n+        catalogName, sourceName, tableName);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    Map<String, String> props = createdTable.properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithAlternateLocation() throws IOException {\n+    Assume.assumeTrue(\"No Snapshoting with Alternate locations with Hadoop Catalogs\", !catalogName.contains(\"hadoop\"));\n+    String location = temp.newFolder().toString();\n+    String snapshotLocation = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NzAwOQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540797009", "bodyText": "nit: should fit on one line", "author": "aokolnychyi", "createdAt": "2020-12-11T09:10:58Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestSnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestSnapshotTableProcedure extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestSnapshotTableProcedure(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result[0]);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object result = scalarSql(\n+        \"CALL %s.system.snapshot(source_table => '%s', table => '%s', properties => map('foo','bar'))\",\n+        catalogName, sourceName, tableName);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    Map<String, String> props = createdTable.properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithAlternateLocation() throws IOException {\n+    Assume.assumeTrue(\"No Snapshoting with Alternate locations with Hadoop Catalogs\", !catalogName.contains(\"hadoop\"));\n+    String location = temp.newFolder().toString();\n+    String snapshotLocation = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NzgwNQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540797805", "bodyText": "Should we also add a test where we get a map where keys or values are not strings?", "author": "aokolnychyi", "createdAt": "2020-12-11T09:12:08Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestSnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.spark.sql.AnalysisException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+public class TestSnapshotTableProcedure extends SparkExtensionsTestBase {\n+  private static final String sourceName = \"spark_catalog.default.source\";\n+  // Currently we can only Snapshot only out of the Spark Session Catalog\n+\n+  public TestSnapshotTableProcedure(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+    sql(\"DROP TABLE IF EXISTS %S\", sourceName);\n+  }\n+\n+  @Test\n+  public void testSnapshot() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\"CALL %s.system.snapshot('%s', '%s')\", catalogName, sourceName, tableName).get(0);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result[0]);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithOptions() throws IOException {\n+    String location = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object result = scalarSql(\n+        \"CALL %s.system.snapshot(source_table => '%s', table => '%s', properties => map('foo','bar'))\",\n+        catalogName, sourceName, tableName);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result);\n+\n+    Table createdTable = validationCatalog.loadTable(tableIdent);\n+\n+    String tableLocation = createdTable.location();\n+    Assert.assertNotEquals(\"Table should not have the original location\", location, tableLocation);\n+\n+    Map<String, String> props = createdTable.properties();\n+    Assert.assertEquals(\"Should have extra property set\", \"bar\", props.get(\"foo\"));\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testSnapshotWithAlternateLocation() throws IOException {\n+    Assume.assumeTrue(\"No Snapshoting with Alternate locations with Hadoop Catalogs\", !catalogName.contains(\"hadoop\"));\n+    String location = temp.newFolder().toString();\n+    String snapshotLocation = temp.newFolder().toString();\n+    sql(\"CREATE TABLE %s (id bigint NOT NULL, data string) USING parquet LOCATION '%s'\", sourceName,\n+        location);\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", sourceName);\n+    Object[] result = sql(\n+        \"CALL %s.system.snapshot(source_table => '%s', table => '%s', table_location => '%s')\",\n+        catalogName, sourceName, tableName, snapshotLocation).get(0);\n+\n+    Assert.assertEquals(\"Should have added one file\", 1L, result[0]);\n+\n+    String storageLocation = validationCatalog.loadTable(tableIdent).location();\n+    Assert.assertEquals(\"Snapshot should be made at specified location\", snapshotLocation, storageLocation);\n+\n+    sql(\"INSERT INTO TABLE %s VALUES (1, 'a')\", tableName);\n+\n+    assertEquals(\"Should have expected rows\",\n+        ImmutableList.of(row(1L, \"a\"), row(1L, \"a\")),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testInvalidSnapshotsCases() {\n+    AssertHelpers.assertThrows(\"Should reject calls without all required args\",\n+        AnalysisException.class, \"Missing required parameters\",\n+        () -> sql(\"CALL %s.system.snapshot('foo')\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should reject calls with invalid arg types\",\n+        AnalysisException.class, \"Wrong arg type\",\n+        () -> sql(\"CALL %s.system.snapshot('n', 't', map('foo', 'bar'))\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should reject calls with empty table identifier\",\n+        IllegalArgumentException.class, \"Cannot handle an empty identifier\",\n+        () -> sql(\"CALL %s.system.snapshot('', 'dest')\", catalogName));\n+\n+    AssertHelpers.assertThrows(\"Should reject calls with empty table identifier\",", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5OTU3Mg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540799572", "bodyText": "If I understand correctly, this should be possible now?", "author": "aokolnychyi", "createdAt": "2020-12-11T09:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk3MDQ2OA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540970468", "bodyText": "Almost everything apparently validly casts to a string, at least everything our parser allows here. This would be easier I think if we changed the parser to accept all possible expressions. I think for now the best I can do is an unbalanced map?", "author": "RussellSpitzer", "createdAt": "2020-12-11T14:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAxMzY4Ng==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r541013686", "bodyText": "Let's ignore this for now then.", "author": "aokolnychyi", "createdAt": "2020-12-11T15:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NzgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5ODcxMw==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540798713", "bodyText": "I think there is a typo: toCatalogAdnIdentifier ->  toCatalogAndIdentifier", "author": "aokolnychyi", "createdAt": "2020-12-11T09:13:38Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/BaseProcedure.java", "diffHunk": "@@ -70,21 +82,22 @@ protected BaseProcedure(TableCatalog tableCatalog) {\n   }\n \n   protected Identifier toIdentifier(String identifierAsString, String argName) {\n-    Preconditions.checkArgument(identifierAsString != null && !identifierAsString.isEmpty(),\n-        \"Cannot handle an empty identifier for argument %s\", argName);\n-\n-    CatalogAndIdentifier catalogAndIdentifier = Spark3Util.catalogAndIdentifier(\n-        \"identifier for arg \" + argName, spark, identifierAsString, tableCatalog);\n-\n-    CatalogPlugin catalog = catalogAndIdentifier.catalog();\n-    Identifier identifier = catalogAndIdentifier.identifier();\n+    CatalogAndIdentifier catalogAndIdentifier = toCatalogAdnIdentifier(identifierAsString, argName, tableCatalog);\n \n     Preconditions.checkArgument(\n-        catalog.equals(tableCatalog),\n+        catalogAndIdentifier.catalog().equals(tableCatalog),\n         \"Cannot run procedure in catalog '%s': '%s' is a table in catalog '%s'\",\n-        tableCatalog.name(), identifierAsString, catalog.name());\n+        tableCatalog.name(), identifierAsString, catalogAndIdentifier.catalog().name());\n+\n+    return catalogAndIdentifier.identifier();\n+  }\n+\n+  protected CatalogAndIdentifier toCatalogAdnIdentifier(String identifierAsString, String argName,", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk3MTc5NA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540971794", "bodyText": "fix!", "author": "RussellSpitzer", "createdAt": "2020-12-11T14:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5ODcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5ODkwNg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540798906", "bodyText": "+1", "author": "aokolnychyi", "createdAt": "2020-12-11T09:13:59Z", "path": "spark3/src/main/java/org/apache/iceberg/actions/Spark3MigrateAction.java", "diffHunk": "@@ -122,6 +122,8 @@ public Long execute() {\n     properties.put(TableCatalog.PROP_PROVIDER, \"iceberg\");\n     properties.put(\"migrated\", \"true\");\n     properties.putAll(additionalProperties());\n+    properties.putIfAbsent(LOCATION, sourceTableLocation());", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwMTc5MQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540801791", "bodyText": "I'd actually add some empty lines to separate logical blocks similar to what you have in snapshot.\n    Map<String, String> properties = Maps.newHashMap();\n\n    properties.putAll(JavaConverters.mapAsJavaMapConverter(v1SourceTable().properties()).asJava());\n    EXCLUDED_PROPERTIES.forEach(properties::remove);\n\n    properties.put(TableCatalog.PROP_PROVIDER, \"iceberg\");\n    properties.put(\"migrated\", \"true\");\n    properties.putAll(additionalProperties());\n    properties.putIfAbsent(LOCATION, sourceTableLocation());\n\n    return properties;", "author": "aokolnychyi", "createdAt": "2020-12-11T09:18:22Z", "path": "spark3/src/main/java/org/apache/iceberg/actions/Spark3MigrateAction.java", "diffHunk": "@@ -122,6 +122,8 @@ public Long execute() {\n     properties.put(TableCatalog.PROP_PROVIDER, \"iceberg\");\n     properties.put(\"migrated\", \"true\");\n     properties.putAll(additionalProperties());\n+    properties.putIfAbsent(LOCATION, sourceTableLocation());\n+", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1NDg2Ng==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540854866", "bodyText": "I find naming here a bit inconsistent with other procedures. What about this?\nString identAsString = args.getString(0);\nCatalogAndIdentifier catalogAndIdent = toCatalogAndIdentifer(identAsString, PARAMETERS[0].name(), tableCatalog());", "author": "aokolnychyi", "createdAt": "2020-12-11T10:42:42Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/MigrateTableProcedure.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.CreateAction;\n+import org.apache.iceberg.actions.Spark3MigrateAction;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.iceberg.spark.procedures.SparkProcedures.ProcedureBuilder;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class MigrateTableProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"properties\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"migrated_files_count\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private MigrateTableProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<MigrateTableProcedure>() {\n+      @Override\n+      protected MigrateTableProcedure doBuild() {\n+        return new MigrateTableProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String tableName = args.getString(0);", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1NjQxNA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540856414", "bodyText": "Should it be just location as we just use properties?", "author": "aokolnychyi", "createdAt": "2020-12-11T10:45:20Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotTableProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"source_table\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1Njk2NA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540856964", "bodyText": "I am okay without dest prefix but if anyone feels strongly, I am ok to add.", "author": "aokolnychyi", "createdAt": "2020-12-11T10:46:18Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotTableProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"source_table\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1NzcyMg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540857722", "bodyText": "Think the name should match whatever we do in migrate. What about imported_files_count?", "author": "aokolnychyi", "createdAt": "2020-12-11T10:47:35Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotTableProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"source_table\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"properties\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"imported_datafiles_count\", DataTypes.LongType, false, Metadata.empty())", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1Nzk4NA==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540857984", "bodyText": "nit: extra space", "author": "aokolnychyi", "createdAt": "2020-12-11T10:48:02Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotTableProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"source_table\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"properties\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"imported_datafiles_count\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private SnapshotTableProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<SnapshotTableProcedure>() {\n+      @Override\n+      protected SnapshotTableProcedure doBuild() {\n+        return new SnapshotTableProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String source = args.getString(0);\n+    CatalogAndIdentifier sourceIdent = toCatalogAdnIdentifier(source, PARAMETERS[0].name(), tableCatalog());\n+\n+    String dest = args.getString(1);\n+    CatalogAndIdentifier destIdent = toCatalogAdnIdentifier(dest, PARAMETERS[1].name(), tableCatalog());\n+\n+    String snapshotLocation = args.isNullAt(2) ? null : args.getString(2);\n+\n+    Map<String, String> options = Maps.newHashMap();\n+    if (!args.isNullAt(3)) {\n+      args.getMap(3).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    Preconditions.checkArgument(sourceIdent != destIdent || sourceIdent.catalog() != destIdent.catalog(),\n+        \"Cannot create a snapshot with the same name as the source of the snapshot.\");\n+    SnapshotAction action =  new Spark3SnapshotAction(spark(), sourceIdent.catalog(), sourceIdent.identifier(),", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTEwNQ==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540859105", "bodyText": "nit: tableProps?", "author": "aokolnychyi", "createdAt": "2020-12-11T10:49:53Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotTableProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"source_table\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"properties\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"imported_datafiles_count\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private SnapshotTableProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<SnapshotTableProcedure>() {\n+      @Override\n+      protected SnapshotTableProcedure doBuild() {\n+        return new SnapshotTableProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String source = args.getString(0);\n+    CatalogAndIdentifier sourceIdent = toCatalogAdnIdentifier(source, PARAMETERS[0].name(), tableCatalog());\n+\n+    String dest = args.getString(1);\n+    CatalogAndIdentifier destIdent = toCatalogAdnIdentifier(dest, PARAMETERS[1].name(), tableCatalog());\n+\n+    String snapshotLocation = args.isNullAt(2) ? null : args.getString(2);\n+\n+    Map<String, String> options = Maps.newHashMap();", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDEyNg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540860126", "bodyText": "I'd separate assigning the snapshot location like this:\n    if (snapshotLocation != null) {\n      action.withLocation(snapshotLocation);\n    }\n\n    long numImportedFiles = action.withProperties(tableProps).execute();\n    return new InternalRow[] {newInternalRow(numImportedFiles)};", "author": "aokolnychyi", "createdAt": "2020-12-11T10:51:37Z", "path": "spark3/src/main/java/org/apache/iceberg/spark/procedures/SnapshotTableProcedure.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.procedures;\n+\n+import java.util.Map;\n+import org.apache.iceberg.actions.SnapshotAction;\n+import org.apache.iceberg.actions.Spark3SnapshotAction;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.spark.Spark3Util.CatalogAndIdentifier;\n+import org.apache.spark.sql.catalyst.InternalRow;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.apache.spark.sql.connector.iceberg.catalog.ProcedureParameter;\n+import org.apache.spark.sql.types.DataTypes;\n+import org.apache.spark.sql.types.Metadata;\n+import org.apache.spark.sql.types.StructField;\n+import org.apache.spark.sql.types.StructType;\n+import scala.runtime.BoxedUnit;\n+\n+class SnapshotTableProcedure extends BaseProcedure {\n+  private static final ProcedureParameter[] PARAMETERS = new ProcedureParameter[]{\n+      ProcedureParameter.required(\"source_table\", DataTypes.StringType),\n+      ProcedureParameter.required(\"table\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"table_location\", DataTypes.StringType),\n+      ProcedureParameter.optional(\"properties\", STRING_MAP)\n+  };\n+\n+  private static final StructType OUTPUT_TYPE = new StructType(new StructField[]{\n+      new StructField(\"imported_datafiles_count\", DataTypes.LongType, false, Metadata.empty())\n+  });\n+\n+  private SnapshotTableProcedure(TableCatalog tableCatalog) {\n+    super(tableCatalog);\n+  }\n+\n+  public static SparkProcedures.ProcedureBuilder builder() {\n+    return new BaseProcedure.Builder<SnapshotTableProcedure>() {\n+      @Override\n+      protected SnapshotTableProcedure doBuild() {\n+        return new SnapshotTableProcedure(tableCatalog());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public ProcedureParameter[] parameters() {\n+    return PARAMETERS;\n+  }\n+\n+  @Override\n+  public StructType outputType() {\n+    return OUTPUT_TYPE;\n+  }\n+\n+  @Override\n+  public InternalRow[] call(InternalRow args) {\n+    String source = args.getString(0);\n+    CatalogAndIdentifier sourceIdent = toCatalogAdnIdentifier(source, PARAMETERS[0].name(), tableCatalog());\n+\n+    String dest = args.getString(1);\n+    CatalogAndIdentifier destIdent = toCatalogAdnIdentifier(dest, PARAMETERS[1].name(), tableCatalog());\n+\n+    String snapshotLocation = args.isNullAt(2) ? null : args.getString(2);\n+\n+    Map<String, String> options = Maps.newHashMap();\n+    if (!args.isNullAt(3)) {\n+      args.getMap(3).foreach(DataTypes.StringType, DataTypes.StringType,\n+          (k, v) -> {\n+            options.put(k.toString(), v.toString());\n+            return BoxedUnit.UNIT;\n+          });\n+    }\n+\n+    Preconditions.checkArgument(sourceIdent != destIdent || sourceIdent.catalog() != destIdent.catalog(),\n+        \"Cannot create a snapshot with the same name as the source of the snapshot.\");\n+    SnapshotAction action =  new Spark3SnapshotAction(spark(), sourceIdent.catalog(), sourceIdent.identifier(),\n+        destIdent.catalog(), destIdent.identifier());\n+\n+    long importedDataFiles;", "originalCommit": "97c2251656df1eaebd06ec886ec31d979b20b576", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDI5Mg==", "url": "https://github.com/apache/iceberg/pull/1906#discussion_r540860292", "bodyText": "I think this will match the other procedures more.", "author": "aokolnychyi", "createdAt": "2020-12-11T10:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MDEyNg=="}], "type": "inlineReview"}, {"oid": "38d7f6de7502cc0d1635d3d26633a67844a2bab8", "url": "https://github.com/apache/iceberg/commit/38d7f6de7502cc0d1635d3d26633a67844a2bab8", "message": "More reviewer comments", "committedDate": "2020-12-11T14:40:25Z", "type": "commit"}]}