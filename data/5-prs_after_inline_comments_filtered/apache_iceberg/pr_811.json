{"pr_number": 811, "pr_title": "NameMapping: reassign already mapped names for new columns", "pr_createdAt": "2020-02-19T00:44:46Z", "pr_url": "https://github.com/apache/iceberg/pull/811", "timeline": [{"oid": "9078aec94c1da3e249c302e975385c97a16e99e0", "url": "https://github.com/apache/iceberg/commit/9078aec94c1da3e249c302e975385c97a16e99e0", "message": "NameMapping: reassign already mapped names for new columns.", "committedDate": "2020-02-18T23:51:21Z", "type": "commit"}, {"oid": "d459b3a26d2592c5952a5912ecc5ae47b78173c1", "url": "https://github.com/apache/iceberg/commit/d459b3a26d2592c5952a5912ecc5ae47b78173c1", "message": "Fix column rename.", "committedDate": "2020-02-19T00:38:22Z", "type": "commit"}, {"oid": "2e3c42da84ceef2011efdb573bb5b4443ecf4b72", "url": "https://github.com/apache/iceberg/commit/2e3c42da84ceef2011efdb573bb5b4443ecf4b72", "message": "Add another test case.", "committedDate": "2020-02-19T00:43:27Z", "type": "commit"}, {"oid": "df424ab6c21531be5ac86ad4beaa929570b5e553", "url": "https://github.com/apache/iceberg/commit/df424ab6c21531be5ac86ad4beaa929570b5e553", "message": "Fix unused imports.", "committedDate": "2020-02-19T00:51:28Z", "type": "commit"}, {"oid": "2108753a2a1e5afdb31dcac9c0a8959b9c0e966c", "url": "https://github.com/apache/iceberg/commit/2108753a2a1e5afdb31dcac9c0a8959b9c0e966c", "message": "Fix typo.", "committedDate": "2020-02-19T01:00:42Z", "type": "commit"}, {"oid": "68d12d6852d6fb9dc70882dea122ec943d4d99a1", "url": "https://github.com/apache/iceberg/commit/68d12d6852d6fb9dc70882dea122ec943d4d99a1", "message": "Remove failing test.", "committedDate": "2020-02-19T01:01:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAyMzk2OQ==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r381023969", "bodyText": "This test is no longer valid because there change that caused an exception while updating the mapping is now supported. Since there aren't changes that cause a failure and there isn't a good way to inject an implementation that fails, I'm just removing this test.", "author": "rdblue", "createdAt": "2020-02-19T01:03:03Z", "path": "core/src/test/java/org/apache/iceberg/mapping/TestMappingUpdates.java", "diffHunk": "@@ -216,34 +216,4 @@ public void testRenameComplexFieldMappingUpdate() {\n             ))),\n         pointUpdated.asMappedFields());\n   }\n-\n-  @Test\n-  public void testMappingUpdateFailureSkipsMappingUpdate() {", "originalCommit": "68d12d6852d6fb9dc70882dea122ec943d4d99a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA2NTM3MQ==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r381065371", "bodyText": "Why we don't want to remove deleted entry in mapping?", "author": "chenjunjiedada", "createdAt": "2020-02-19T03:57:44Z", "path": "core/src/test/java/org/apache/iceberg/TestSchemaAndMappingUpdate.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.iceberg.mapping.MappedField;\n+import org.apache.iceberg.mapping.MappedFields;\n+import org.apache.iceberg.mapping.MappingUtil;\n+import org.apache.iceberg.mapping.NameMapping;\n+import org.apache.iceberg.mapping.NameMappingParser;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSchemaAndMappingUpdate extends TableTestBase {\n+  @Test\n+  public void testAddPrimitiveColumn() {\n+    NameMapping mapping = MappingUtil.create(table.schema());\n+    String mappingJson = NameMappingParser.toJson(mapping);\n+\n+    table.updateProperties()\n+        .set(TableProperties.DEFAULT_NAME_MAPPING, mappingJson)\n+        .commit();\n+\n+    table.updateSchema()\n+        .addColumn(\"count\", Types.LongType.get())\n+        .commit();\n+\n+    String updatedJson = table.properties().get(TableProperties.DEFAULT_NAME_MAPPING);\n+    NameMapping updated = NameMappingParser.fromJson(updatedJson);\n+\n+    validateUnchanged(mapping, updated);\n+\n+    MappedField newMapping = updated.find(\"count\");\n+    Assert.assertNotNull(\"Mapping for new column should be added\", newMapping);\n+    Assert.assertEquals(\"Mapping should use the assigned field ID\",\n+        (Integer) table.schema().findField(\"count\").fieldId(), updated.find(\"count\").id());\n+    Assert.assertNull(\"Should not contain a nested mapping\", updated.find(\"count\").nestedMapping());\n+  }\n+\n+  @Test\n+  public void testAddStructColumn() {\n+    NameMapping mapping = MappingUtil.create(table.schema());\n+    String mappingJson = NameMappingParser.toJson(mapping);\n+\n+    table.updateProperties()\n+        .set(TableProperties.DEFAULT_NAME_MAPPING, mappingJson)\n+        .commit();\n+\n+    table.updateSchema()\n+        .addColumn(\"location\", Types.StructType.of(\n+            Types.NestedField.optional(1, \"lat\", Types.DoubleType.get()),\n+            Types.NestedField.optional(2, \"long\", Types.DoubleType.get())))\n+        .commit();\n+\n+    String updatedJson = table.properties().get(TableProperties.DEFAULT_NAME_MAPPING);\n+    NameMapping updated = NameMappingParser.fromJson(updatedJson);\n+\n+    validateUnchanged(mapping, updated);\n+\n+    MappedField newMapping = updated.find(\"location\");\n+    Assert.assertNotNull(\"Mapping for new column should be added\", newMapping);\n+\n+    Assert.assertEquals(\"Mapping should use the assigned field ID\",\n+        (Integer) table.schema().findField(\"location\").fieldId(), updated.find(\"location\").id());\n+    Assert.assertNotNull(\"Should contain a nested mapping\", updated.find(\"location\").nestedMapping());\n+\n+    Assert.assertEquals(\"Mapping should use the assigned field ID\",\n+        (Integer) table.schema().findField(\"location.lat\").fieldId(), updated.find(\"location.lat\").id());\n+    Assert.assertNull(\"Should not contain a nested mapping\", updated.find(\"location.lat\").nestedMapping());\n+\n+    Assert.assertEquals(\"Mapping should use the assigned field ID\",\n+        (Integer) table.schema().findField(\"location.long\").fieldId(), updated.find(\"location.long\").id());\n+    Assert.assertNull(\"Should not contain a nested mapping\", updated.find(\"location.long\").nestedMapping());\n+  }\n+\n+  @Test\n+  public void testRenameColumn() {\n+    NameMapping mapping = MappingUtil.create(table.schema());\n+    String mappingJson = NameMappingParser.toJson(mapping);\n+\n+    table.updateProperties()\n+        .set(TableProperties.DEFAULT_NAME_MAPPING, mappingJson)\n+        .commit();\n+\n+    table.updateSchema()\n+        .renameColumn(\"id\", \"object_id\")\n+        .commit();\n+\n+    String updatedJson = table.properties().get(TableProperties.DEFAULT_NAME_MAPPING);\n+    NameMapping updated = NameMappingParser.fromJson(updatedJson);\n+\n+    int idColumnId = table.schema().findField(\"object_id\").fieldId();\n+    validateUnchanged(\n+        Iterables.filter(mapping.asMappedFields().fields(), field -> !Objects.equals(idColumnId, field.id())),\n+        updated);\n+\n+    MappedField updatedMapping = updated.find(idColumnId);\n+    Assert.assertNotNull(\"Mapping for id column should exist\", updatedMapping);\n+    Assert.assertEquals(\"Should add the new column name to the existing mapping\",\n+        MappedField.of(idColumnId, ImmutableList.of(\"id\", \"object_id\")),\n+        updatedMapping);\n+  }\n+\n+  @Test\n+  public void testDeleteColumn() {\n+    NameMapping mapping = MappingUtil.create(table.schema());\n+    String mappingJson = NameMappingParser.toJson(mapping);\n+\n+    table.updateProperties()\n+        .set(TableProperties.DEFAULT_NAME_MAPPING, mappingJson)\n+        .commit();\n+\n+    table.updateSchema()\n+        .deleteColumn(\"id\")\n+        .commit();\n+\n+    String updatedJson = table.properties().get(TableProperties.DEFAULT_NAME_MAPPING);\n+    NameMapping updated = NameMappingParser.fromJson(updatedJson);\n+\n+    // should not change the mapping", "originalCommit": "68d12d6852d6fb9dc70882dea122ec943d4d99a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNDQ1Mw==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r382134453", "bodyText": "Deleting the entry would remove information that may be valuable: the association of a now-deleted ID with a set of names. That can be used in some mapping cases.\nFor example, we use mappings from JSON records in Kafka into Iceberg data. If a user drops a column, the incoming data is dropped as well. Using the mapping to drop data gives us more flexibility in how to handle un-mapped data. We move un-mapped fields to a string-map called other_properties, but you could also detect that there is un-mapped data coming in and update a metric or decide to pause until the mapping is updated.", "author": "rdblue", "createdAt": "2020-02-20T17:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTA2NTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2Njk5NA==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r381766994", "bodyText": "is this null check redundant?", "author": "rdsr", "createdAt": "2020-02-20T05:23:51Z", "path": "core/src/main/java/org/apache/iceberg/mapping/MappingUtil.java", "diffHunk": "@@ -91,7 +92,14 @@ public MappedFields mapping(NameMapping mapping, MappedFields result) {\n \n     @Override\n     public MappedFields fields(MappedFields fields, List<MappedField> fieldResults) {\n-      return MappedFields.of(fieldResults);\n+      ImmutableMap.Builder<String, Integer> builder = ImmutableMap.builder();\n+      fieldResults.stream()\n+          .map(MappedField::id).filter(Objects::nonNull)", "originalCommit": "68d12d6852d6fb9dc70882dea122ec943d4d99a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzMjAxOQ==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r382132019", "bodyText": "No, what's happening here is that we have a set of changes to the schema by ID. We want the changes that apply just to this struct in the schema, so that we don't reassign names that changed in other structs.\nTo get the changes that apply to this mapping level, we use ids from the existing mappings. A a mapping may not have an id, indicating that we have not yet mapped an incoming name, but that the name exists in an associated name-based schema. Filtering to non-null ids gets rid of those fields. Then we look up the ids for this mapping in the list of changes, filter out unchanged fields where the result of the lookup is null, and apply the results.", "author": "rdblue", "createdAt": "2020-02-20T16:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2Njk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNzY0MA==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r382137640", "bodyText": "I guess you could argue that changes.get(null) should be null, but it seems strange to me to look up null in a map. You're right that we could probably remove it. Do you think we should?", "author": "rdblue", "createdAt": "2020-02-20T17:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2Njk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxNzI2OA==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r381817268", "bodyText": "Do you see issues  if a mappedField ends up having no names assigned?", "author": "rdsr", "createdAt": "2020-02-20T07:10:00Z", "path": "core/src/main/java/org/apache/iceberg/mapping/MappingUtil.java", "diffHunk": "@@ -114,18 +122,45 @@ private MappedFields addNewFields(MappedFields mapping, int parentId) {\n         return mapping;\n       }\n \n-      List<MappedField> fields = Lists.newArrayList();\n-      if (mapping != null) {\n-        fields.addAll(mapping.fields());\n-      }\n-\n+      List<MappedField> newFields = Lists.newArrayList();\n       for (Types.NestedField add : fieldsToAdd) {\n         MappedFields nestedMapping = TypeUtil.visit(add.type(), CreateMapping.INSTANCE);\n-        fields.add(MappedField.of(add.fieldId(), add.name(), nestedMapping));\n+        newFields.add(MappedField.of(add.fieldId(), add.name(), nestedMapping));\n+      }\n+\n+      if (mapping == null || mapping.fields().isEmpty()) {\n+        return MappedFields.of(newFields);\n+      }\n+\n+      ImmutableMap.Builder<String, Integer> builder = ImmutableMap.builder();\n+      fieldsToAdd.stream().forEach(field -> builder.put(field.name(), field.fieldId()));\n+      Map<String, Integer> assignments = builder.build();\n+\n+      // create a copy of fields that can be updated (append new fields, replace existing for reassignment)\n+      List<MappedField> fields = Lists.newArrayList();\n+      for (MappedField field : mapping.fields()) {\n+        fields.add(removeReassignedNames(field, assignments));\n       }\n \n+      fields.addAll(newFields);\n+\n       return MappedFields.of(fields);\n     }\n+\n+    private static MappedField removeReassignedNames(MappedField field, Map<String, Integer> assignments) {\n+      MappedField newField = field;\n+      for (String name : field.names()) {\n+        Integer assignedId = assignments.get(name);\n+        if (assignedId != null && !Objects.equals(assignedId, field.id())) {\n+          newField = removeName(field, name);\n+        }\n+      }\n+      return newField;\n+    }\n+\n+    private static MappedField removeName(MappedField field, String name) {", "originalCommit": "68d12d6852d6fb9dc70882dea122ec943d4d99a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxODA4Mw==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r381818083", "bodyText": "testDeleteAndAddColumnReassign highlights this problem where  a mappedField can end up being empty\n[ {\n  \"field-id\" : 1,\n  \"names\" : [ ]\n}, {\n  \"field-id\" : 2,\n  \"names\" : [ \"data\" ]\n}, {\n  \"field-id\" : 3,\n  \"names\" : [ \"id\" ]\n} ]", "author": "rdsr", "createdAt": "2020-02-20T07:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxNzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0MDM5OQ==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r382140399", "bodyText": "Unlike the case where we have names without an ID, I think we could remove these. But I'm reluctant to because it throws away information -- that the field is known to the mapping, but doesn't have any names. That can be used to detect that a field was replaced if you wanted to. I don't have a concrete use case for it, but I think I'm leaning toward keeping it in case.", "author": "rdblue", "createdAt": "2020-02-20T17:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxNzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3OTYzMg==", "url": "https://github.com/apache/iceberg/pull/811#discussion_r382279632", "bodyText": "Sounds good.", "author": "rdsr", "createdAt": "2020-02-20T21:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxNzI2OA=="}], "type": "inlineReview"}]}