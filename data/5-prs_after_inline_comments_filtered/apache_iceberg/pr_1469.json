{"pr_number": 1469, "pr_title": "Add position delete validation that data files have not been deleted", "pr_createdAt": "2020-09-17T01:02:32Z", "pr_url": "https://github.com/apache/iceberg/pull/1469", "timeline": [{"oid": "d1a5890eca9515d35087ea3588738ddbd2174010", "url": "https://github.com/apache/iceberg/commit/d1a5890eca9515d35087ea3588738ddbd2174010", "message": "Fix Spark tests.", "committedDate": "2020-10-02T20:31:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NDY4MA==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499694680", "bodyText": "What should be our long-term strategy for handling case sensitivity in APIs like this? The current way is not consistent and we use default values in a lot of cases. There are two methods in this API that accept expressions. Does it mean that each of them will have an extra parameter? Will it make sense to expose a method in a parent class/interface that would configure case sensitivity for all methods?", "author": "aokolnychyi", "createdAt": "2020-10-05T15:41:59Z", "path": "api/src/main/java/org/apache/iceberg/OverwriteFiles.java", "diffHunk": "@@ -87,6 +87,36 @@\n    */\n   OverwriteFiles validateAddedFilesMatchOverwriteFilter();\n \n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  OverwriteFiles validateFromSnapshot(long snapshotId);\n+\n+  /**\n+   * Enables validation that files added concurrently do not conflict with this commit's operation.\n+   * <p>\n+   * This method should be called when the table is queried to determine which files to delete/append.\n+   * If a concurrent operation commits a new file after the data was read and that file might\n+   * contain rows matching the specified conflict detection filter, the overwrite operation\n+   * will detect this during retries and fail.\n+   * <p>\n+   * Calling this method with a correct conflict detection filter is required to maintain\n+   * serializable isolation for eager update/delete operations. Otherwise, the isolation level\n+   * will be snapshot isolation.\n+   * <p>\n+   * Validation applies to files added to the table since the snapshot passed to {@link #validateFromSnapshot(long)}.\n+   *\n+   * @param conflictDetectionFilter an expression on rows in the table\n+   * @param isCaseSensitive whether conflict detection filter evaluation should be case sensitive\n+   * @return this for method chaining\n+   */\n+  OverwriteFiles validateNoConflictingAppends(Expression conflictDetectionFilter, boolean isCaseSensitive);", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMjk4Mw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499732983", "bodyText": "Good catch. I think we should have a caseSensitive(boolean) method that is called separately. That should be configured once per operation, not for each validation option.", "author": "rdblue", "createdAt": "2020-10-05T16:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0NTY1MQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499945651", "bodyText": "Added caseSensitive(boolean).", "author": "rdblue", "createdAt": "2020-10-06T00:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5Nzc2Mw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499697763", "bodyText": "Should we document what happens if the user calls validateNoConflictingAppends without this one? Will we validate each snapshot in the table?", "author": "aokolnychyi", "createdAt": "2020-10-05T15:46:36Z", "path": "api/src/main/java/org/apache/iceberg/OverwriteFiles.java", "diffHunk": "@@ -87,6 +87,36 @@\n    */\n   OverwriteFiles validateAddedFilesMatchOverwriteFilter();\n \n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  OverwriteFiles validateFromSnapshot(long snapshotId);", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMTg2NQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499731865", "bodyText": "Yes, it would apply to the entire table history and fail if a snapshot is missing.", "author": "rdblue", "createdAt": "2020-10-05T16:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5Nzc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0NjMxNQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499946315", "bodyText": "Added \"If the from snapshot is not set, all ancestor snapshots through the table's initial snapshot are validated.\"", "author": "rdblue", "createdAt": "2020-10-06T00:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5Nzc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5ODQwMA==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499698400", "bodyText": "Here as well.", "author": "aokolnychyi", "createdAt": "2020-10-05T15:47:34Z", "path": "api/src/main/java/org/apache/iceberg/RowDelta.java", "diffHunk": "@@ -44,4 +46,61 @@\n    * @return this for method chaining\n    */\n   RowDelta addDeletes(DeleteFile deletes);\n+\n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMTIzNQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499701235", "bodyText": "Can currentSnapshot be null if we start on an empty table?", "author": "aokolnychyi", "createdAt": "2020-10-05T15:51:43Z", "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMzYyMw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499713623", "bodyText": "I think we validate this one level above.", "author": "aokolnychyi", "createdAt": "2020-10-05T16:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMTM1OQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499731359", "bodyText": "Yes, we do.", "author": "rdblue", "createdAt": "2020-10-05T16:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0NjkxNQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499946915", "bodyText": "I'm adding an additional check since this can return early instead of failing if the caller forgets to do this.", "author": "rdblue", "createdAt": "2020-10-06T00:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMjY5OQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499702699", "bodyText": "Not something we have to address in this PR but I've created #1547 recently. I think we should ignore rewrite snapshots during this validation.", "author": "aokolnychyi", "createdAt": "2020-10-05T15:53:57Z", "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyODkyMg==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499728922", "bodyText": "Actually, we already have this extra logic while validating deletes, so may make sense to add in this PR if not too much trouble.", "author": "aokolnychyi", "createdAt": "2020-10-05T16:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMjY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0ODkxOA==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499948918", "bodyText": "This was fairly easy to implement, but I had to change a test: https://github.com/apache/iceberg/blob/master/core/src/test/java/org/apache/iceberg/TestOverwriteWithValidation.java#L404-L406", "author": "rdblue", "createdAt": "2020-10-06T00:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwMjY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwNjg4Mw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499706883", "bodyText": "Do we switch to ManifestGroup instead of Snapshot$addedFiles to avoid caching added files in memory?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:00:04Z", "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);\n+      for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n+        if (manifest.snapshotId() == (long) currentSnapshotId) {\n+          manifests.add(manifest);\n+        }\n+      }\n+\n+      currentSnapshotId = currentSnapshot.parentId();\n+    }\n+\n+    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMjg0Mw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499722843", "bodyText": "I see that we use Snapshot$deletedFiles for row deltas. Why?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwNjg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0OTU5Mg==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499949592", "bodyText": "The biggest concern was correctness.\nThis was matching manifests without checking the manifest's partition spec. So the same evaluator was used for all file partitions regardless of whether it was correct. Using ManifestGroup avoids that problem. Note that it isn't a problem for the delete validation because we have a concrete set of files that must exist.\nThis will also have some benefit by not caching. That's a good motivation to change the implementation of the delete checks as well.", "author": "rdblue", "createdAt": "2020-10-06T00:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwNjg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwODI5Mw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499708293", "bodyText": "Do we expect the number of manifests to be small enough so that we won't have to parallelize this?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:02:03Z", "path": "core/src/main/java/org/apache/iceberg/MergingSnapshotProducer.java", "diffHunk": "@@ -202,6 +207,58 @@ private ManifestFile copyManifest(ManifestFile manifest) {\n         current.formatVersion(), toCopy, current.specsById(), newManifestPath, snapshotId(), appendedManifestsSummary);\n   }\n \n+  /**\n+   * Validates that no files matching a filter have been added to the table since a starting snapshot.\n+   *\n+   * @param base table metadata to validate\n+   * @param startingSnapshotId id of the snapshot current at the start of the operation\n+   * @param conflictDetectionFilter an expression used to find new conflicting data files\n+   * @param caseSensitive whether expression evaluation should be case sensitive\n+   */\n+  protected void validateAddedDataFiles(TableMetadata base, Long startingSnapshotId,\n+                                        Expression conflictDetectionFilter, boolean caseSensitive) {\n+    List<ManifestFile> manifests = Lists.newArrayList();\n+    Set<Long> newSnapshots = Sets.newHashSet();\n+\n+    Long currentSnapshotId = base.currentSnapshot().snapshotId();\n+    while (currentSnapshotId != null && !currentSnapshotId.equals(startingSnapshotId)) {\n+      Snapshot currentSnapshot = ops.current().snapshot(currentSnapshotId);\n+\n+      ValidationException.check(currentSnapshot != null,\n+          \"Cannot determine history between starting snapshot %s and current %s\",\n+          startingSnapshotId, currentSnapshotId);\n+\n+      newSnapshots.add(currentSnapshotId);\n+      for (ManifestFile manifest : currentSnapshot.dataManifests()) {\n+        if (manifest.snapshotId() == (long) currentSnapshotId) {\n+          manifests.add(manifest);\n+        }\n+      }\n+\n+      currentSnapshotId = currentSnapshot.parentId();\n+    }\n+\n+    ManifestGroup conflictGroup = new ManifestGroup(ops.io(), manifests, ImmutableList.of())\n+        .caseSensitive(caseSensitive)\n+        .filterManifestEntries(entry -> newSnapshots.contains(entry.snapshotId()))\n+        .filterData(conflictDetectionFilter)\n+        .specsById(base.specsById())\n+        .ignoreDeleted()\n+        .ignoreExisting();", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwOTIzMw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499709233", "bodyText": "It probably should be small if we ignore rewrite snapshots that may include metadata rewrites.", "author": "aokolnychyi", "createdAt": "2020-10-05T16:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwODI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMTExMw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499731113", "bodyText": "You're right, we can ignore rewrite snapshots. That would be helpful.", "author": "rdblue", "createdAt": "2020-10-05T16:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwODI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0OTcwOA==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499949708", "bodyText": "Yes, the number of changes should be small, especially if we ignore rewrites.", "author": "rdblue", "createdAt": "2020-10-06T00:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcwODI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjExMw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499712113", "bodyText": "We mean Transaction in Iceberg here?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:08:09Z", "path": "api/src/main/java/org/apache/iceberg/RowDelta.java", "diffHunk": "@@ -44,4 +46,61 @@\n    * @return this for method chaining\n    */\n   RowDelta addDeletes(DeleteFile deletes);\n+\n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  RowDelta validateFromSnapshot(long snapshotId);\n+\n+  /**\n+   * Add data file paths that must not be removed by conflicting commits for this RowDelta to succeed.\n+   * <p>\n+   * If any path has been removed by a conflicting commit in the table since the snapshot passed to\n+   * {@link #validateFromSnapshot(long)}, the operation will fail with a\n+   * {@link org.apache.iceberg.exceptions.ValidationException}.\n+   * <p>\n+   * By default, this validation checks only rewrite and overwrite commits. To apply validation to delete commits, call\n+   * {@link #validateDeletedFiles()}.\n+   *\n+   * @param referencedFiles file paths that are referenced by a position delete file\n+   * @return this for method chaining\n+   */\n+  RowDelta validateDataFilesExist(Iterable<? extends CharSequence> referencedFiles);\n+\n+  /**\n+   * Enable validation that referenced data files passed to {@link #validateDataFilesExist(Iterable)} have not been\n+   * removed by a delete operation.\n+   * <p>\n+   * If a data file has a row deleted using a position delete file, rewriting or overwriting the data file concurrently", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMzg4OQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499723889", "bodyText": "Wait, this is for UPDATE.", "author": "aokolnychyi", "createdAt": "2020-10-05T16:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNDM2MQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499734361", "bodyText": "Yes, we mean a single-table transaction. Presto doesn't use INSERT OVERWRITE and recommends implementing an overwrite using a transaction with DELETE FROM and INSERT INTO. This allows Presto to validate the deleted files because they are actually overwritten, but appear in metadata to be deletes.", "author": "rdblue", "createdAt": "2020-10-05T16:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjkzMQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499712931", "bodyText": "eager?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:09:27Z", "path": "api/src/main/java/org/apache/iceberg/RowDelta.java", "diffHunk": "@@ -44,4 +46,61 @@\n    * @return this for method chaining\n    */\n   RowDelta addDeletes(DeleteFile deletes);\n+\n+  /**\n+   * Set the snapshot ID used in any reads for this operation.\n+   * <p>\n+   * Validations will check changes after this snapshot ID.\n+   *\n+   * @param snapshotId a snapshot ID\n+   * @return this for method chaining\n+   */\n+  RowDelta validateFromSnapshot(long snapshotId);\n+\n+  /**\n+   * Add data file paths that must not be removed by conflicting commits for this RowDelta to succeed.\n+   * <p>\n+   * If any path has been removed by a conflicting commit in the table since the snapshot passed to\n+   * {@link #validateFromSnapshot(long)}, the operation will fail with a\n+   * {@link org.apache.iceberg.exceptions.ValidationException}.\n+   * <p>\n+   * By default, this validation checks only rewrite and overwrite commits. To apply validation to delete commits, call\n+   * {@link #validateDeletedFiles()}.\n+   *\n+   * @param referencedFiles file paths that are referenced by a position delete file\n+   * @return this for method chaining\n+   */\n+  RowDelta validateDataFilesExist(Iterable<? extends CharSequence> referencedFiles);\n+\n+  /**\n+   * Enable validation that referenced data files passed to {@link #validateDataFilesExist(Iterable)} have not been\n+   * removed by a delete operation.\n+   * <p>\n+   * If a data file has a row deleted using a position delete file, rewriting or overwriting the data file concurrently\n+   * would un-delete the row. Deleting the data file is normally allowed, but a delete may be part of a transaction\n+   * that reads and re-appends a row. This method is used to validate deletes for the transaction case.\n+   *\n+   * @return this for method chaining\n+   */\n+  RowDelta validateDeletedFiles();\n+\n+  /**\n+   * Enables validation that files added concurrently do not conflict with this commit's operation.\n+   * <p>\n+   * This method should be called when the table is queried to determine which files to delete/append.\n+   * If a concurrent operation commits a new file after the data was read and that file might\n+   * contain rows matching the specified conflict detection filter, the overwrite operation\n+   * will detect this during retries and fail.\n+   * <p>\n+   * Calling this method with a correct conflict detection filter is required to maintain\n+   * serializable isolation for eager update/delete operations. Otherwise, the isolation level", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMDcxMA==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499730710", "bodyText": "No, I'll fix it.", "author": "rdblue", "createdAt": "2020-10-05T16:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMzc4MA==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499733780", "bodyText": "Shouldn't it be merge-on-read in RowDelta?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1MDA0OQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499950049", "bodyText": "Merge on read is implied by using RowDelta, so I'm removing this and ending the sentence at \"serializable isolation\".", "author": "rdblue", "createdAt": "2020-10-06T00:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxMjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNDIzNg==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499714236", "bodyText": "Is this public on purpose?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:11:32Z", "path": "core/src/main/java/org/apache/iceberg/BaseRowDelta.java", "diffHunk": "@@ -45,4 +62,80 @@ public RowDelta addDeletes(DeleteFile deletes) {\n     add(deletes);\n     return this;\n   }\n+\n+  @Override\n+  public RowDelta validateFromSnapshot(long snapshotId) {\n+    this.startingSnapshotId = snapshotId;\n+    return this;\n+  }\n+\n+  @Override\n+  public RowDelta validateDeletedFiles() {\n+    return validateDeletedFiles(true);\n+  }\n+\n+  public RowDelta validateDeletedFiles(boolean shouldValidate) {", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMDU2NQ==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499730565", "bodyText": "No. I was debating whether to add it to the public API, so it was initially public. But I decided to keep the public API minimal for now. We can always add it later. That's why I kept it here.", "author": "rdblue", "createdAt": "2020-10-05T16:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNDIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1MDIwNw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499950207", "bodyText": "I'm just going to remove this. We get warnings if it is private.", "author": "rdblue", "createdAt": "2020-10-06T00:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNDIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxOTM0MA==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499719340", "bodyText": "Do we expect only file names in this API? Would it make sense to accept DataFIles in the future? So that we can filter out manifests based on the partition info as we do in ManifestFilterManager?", "author": "aokolnychyi", "createdAt": "2020-10-05T16:19:35Z", "path": "core/src/main/java/org/apache/iceberg/BaseRowDelta.java", "diffHunk": "@@ -45,4 +62,80 @@ public RowDelta addDeletes(DeleteFile deletes) {\n     add(deletes);\n     return this;\n   }\n+\n+  @Override\n+  public RowDelta validateFromSnapshot(long snapshotId) {\n+    this.startingSnapshotId = snapshotId;\n+    return this;\n+  }\n+\n+  @Override\n+  public RowDelta validateDeletedFiles() {\n+    return validateDeletedFiles(true);\n+  }\n+\n+  public RowDelta validateDeletedFiles(boolean shouldValidate) {\n+    this.validateDeletes = shouldValidate;\n+    return this;\n+  }\n+\n+  @Override\n+  public RowDelta validateDataFilesExist(Iterable<? extends CharSequence> referencedFiles) {", "originalCommit": "7a6c371b00fa8661cc4f268090f9ef690b12db4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczODcwNw==", "url": "https://github.com/apache/iceberg/pull/1469#discussion_r499738707", "bodyText": "We can support both if we need to later.\nMy expectation is that we won't have the DataFile information to pass back in many cases. A simple example is DELETE FROM. That would be implemented with a scan that also projects _file and _pos, then writes the results into delete files in parallel tasks. It would be some work to pass additional DataFile fields to the writer just so we could pass more information back in metadata. It could be worth it, but I think it is reasonable to start with the simpler option.", "author": "rdblue", "createdAt": "2020-10-05T16:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxOTM0MA=="}], "type": "inlineReview"}, {"oid": "19e66f23bfff839f4b5b447057c50eb0b5737b92", "url": "https://github.com/apache/iceberg/commit/19e66f23bfff839f4b5b447057c50eb0b5737b92", "message": "Add position delete validation that data files have not been deleted.", "committedDate": "2020-10-06T01:04:24Z", "type": "commit"}, {"oid": "c4c04c7c4ca7ed51dae87541c7a59bd352e550b5", "url": "https://github.com/apache/iceberg/commit/c4c04c7c4ca7ed51dae87541c7a59bd352e550b5", "message": "Fix checkstyle.", "committedDate": "2020-10-06T01:04:24Z", "type": "commit"}, {"oid": "feda7fa43ae96391ba7cd965539d88c162277771", "url": "https://github.com/apache/iceberg/commit/feda7fa43ae96391ba7cd965539d88c162277771", "message": "Current work.", "committedDate": "2020-10-06T01:04:24Z", "type": "commit"}, {"oid": "2d375c03058667ae60b91f70f20c8ad893694e75", "url": "https://github.com/apache/iceberg/commit/2d375c03058667ae60b91f70f20c8ad893694e75", "message": "Fix Spark tests.", "committedDate": "2020-10-06T01:04:53Z", "type": "commit"}, {"oid": "77afad94c8f555295b66ccf06785efdeefe185f1", "url": "https://github.com/apache/iceberg/commit/77afad94c8f555295b66ccf06785efdeefe185f1", "message": "Fix checkstyle.", "committedDate": "2020-10-06T01:04:53Z", "type": "commit"}, {"oid": "037ad66fa39d938367245207a91daf1f8f817c1d", "url": "https://github.com/apache/iceberg/commit/037ad66fa39d938367245207a91daf1f8f817c1d", "message": "Add validateDeletedFiles to check delete operations.", "committedDate": "2020-10-06T01:04:53Z", "type": "commit"}, {"oid": "d87e1d7dbca904bb03d48ededbcebcc83a3c77c9", "url": "https://github.com/apache/iceberg/commit/d87e1d7dbca904bb03d48ededbcebcc83a3c77c9", "message": "Implement added file conflict validation.", "committedDate": "2020-10-06T01:04:53Z", "type": "commit"}, {"oid": "1e8efdaec1c3a95fa223027f925d868cafa3fdd7", "url": "https://github.com/apache/iceberg/commit/1e8efdaec1c3a95fa223027f925d868cafa3fdd7", "message": "Remove unused io.", "committedDate": "2020-10-06T01:04:53Z", "type": "commit"}, {"oid": "bc74cf73014399bcf9857aa21fb4a9fed4867404", "url": "https://github.com/apache/iceberg/commit/bc74cf73014399bcf9857aa21fb4a9fed4867404", "message": "Fix issues caught by the review.", "committedDate": "2020-10-06T01:04:53Z", "type": "commit"}, {"oid": "bc74cf73014399bcf9857aa21fb4a9fed4867404", "url": "https://github.com/apache/iceberg/commit/bc74cf73014399bcf9857aa21fb4a9fed4867404", "message": "Fix issues caught by the review.", "committedDate": "2020-10-06T01:04:53Z", "type": "forcePushed"}, {"oid": "ef5941004118d2caac865d381069b681afb365e4", "url": "https://github.com/apache/iceberg/commit/ef5941004118d2caac865d381069b681afb365e4", "message": "Use ManifestGroup to validate required data files.", "committedDate": "2020-10-06T01:28:56Z", "type": "commit"}, {"oid": "97c52221d735e218356745f3f9d86a4b708245eb", "url": "https://github.com/apache/iceberg/commit/97c52221d735e218356745f3f9d86a4b708245eb", "message": "Fix unused imports.", "committedDate": "2020-10-06T02:40:24Z", "type": "commit"}, {"oid": "d552ce4d88fbef8348e9e9d78714aec436b4056e", "url": "https://github.com/apache/iceberg/commit/d552ce4d88fbef8348e9e9d78714aec436b4056e", "message": "Fix Guava import in TestRowDelta.", "committedDate": "2020-10-06T16:37:35Z", "type": "commit"}]}