{"pr_number": 1836, "pr_title": "Core: Add data and delete writers in FileAppenderFactory.", "pr_createdAt": "2020-11-26T15:16:36Z", "pr_url": "https://github.com/apache/iceberg/pull/1836", "timeline": [{"oid": "609049e1e9a05d3fa76baca3fdd13b9f0a1dce99", "url": "https://github.com/apache/iceberg/commit/609049e1e9a05d3fa76baca3fdd13b9f0a1dce99", "message": "Core: Add data and delete writers in FileAppenderFactory.", "committedDate": "2020-11-26T15:14:40Z", "type": "commit"}, {"oid": "c1a124772f4e48fd38ea8b81a316464712057b09", "url": "https://github.com/apache/iceberg/commit/c1a124772f4e48fd38ea8b81a316464712057b09", "message": "Minor fixes", "committedDate": "2020-11-27T05:34:28Z", "type": "commit"}, {"oid": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "url": "https://github.com/apache/iceberg/commit/d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "message": "Fix broken unit tests.", "committedDate": "2020-11-27T08:10:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NDQ3OA==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r531474478", "bodyText": "@rdblue   Here I use the parquet writer which is built from <path, pos, row> schema, rather than the writer built from row schema.\nI tried to hide all the <path, pos, row> write logic inside the Parquet#buildPositionWriter, but failed to make it work.  I passed a function to this builder by creating a  parquet writer built by rowSchema, and construct a PositionDeleteStructWriter with a path string writer,  a pos long writer and the  row struct writer,   it does not work because the currentPath for here has been messed up.   Still figuring out how to make this work in a graceful way...", "author": "openinx", "createdAt": "2020-11-27T09:18:32Z", "path": "flink/src/main/java/org/apache/iceberg/flink/sink/FlinkAppenderFactory.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink.sink;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.io.UncheckedIOException;\n+import java.util.Map;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.StringData;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.MetricsConfig;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.StructLike;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.deletes.EqualityDeleteWriter;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.flink.FlinkSchemaUtil;\n+import org.apache.iceberg.flink.data.FlinkAvroWriter;\n+import org.apache.iceberg.flink.data.FlinkOrcWriter;\n+import org.apache.iceberg.flink.data.FlinkParquetWriters;\n+import org.apache.iceberg.io.DataWriter;\n+import org.apache.iceberg.io.DeleteSchemaUtil;\n+import org.apache.iceberg.io.FileAppender;\n+import org.apache.iceberg.io.FileAppenderFactory;\n+import org.apache.iceberg.io.OutputFile;\n+import org.apache.iceberg.orc.ORC;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.parquet.ParquetValueWriters;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public class FlinkAppenderFactory implements FileAppenderFactory<RowData>, Serializable {\n+  private final Schema schema;\n+  private final RowType flinkSchema;\n+  private final Map<String, String> props;\n+  private final PartitionSpec spec;\n+  private final int[] equalityFieldIds;\n+  private final Schema eqDeleteRowSchema;\n+  private final Schema posDeleteRowSchema;\n+\n+  private RowType eqDeleteFlinkSchema = null;\n+  private RowType posDeleteFlinkSchema = null;\n+\n+  public FlinkAppenderFactory(Schema schema, RowType flinkSchema, Map<String, String> props, PartitionSpec spec) {\n+    this(schema, flinkSchema, props, spec, null, schema, null);\n+  }\n+\n+  public FlinkAppenderFactory(Schema schema, RowType flinkSchema, Map<String, String> props,\n+                              PartitionSpec spec, int[] equalityFieldIds,\n+                              Schema eqDeleteRowSchema, Schema posDeleteRowSchema) {\n+    this.schema = schema;\n+    this.flinkSchema = flinkSchema;\n+    this.props = props;\n+    this.spec = spec;\n+    this.equalityFieldIds = equalityFieldIds;\n+    this.eqDeleteRowSchema = eqDeleteRowSchema;\n+    this.posDeleteRowSchema = posDeleteRowSchema;\n+  }\n+\n+  private RowType lazyEqDeleteFlinkSchema() {\n+    if (eqDeleteFlinkSchema == null) {\n+      Preconditions.checkNotNull(eqDeleteRowSchema, \"Equality delete row schema shouldn't be null\");\n+      this.eqDeleteFlinkSchema = FlinkSchemaUtil.convert(eqDeleteRowSchema);\n+    }\n+    return eqDeleteFlinkSchema;\n+  }\n+\n+  private RowType lazyPosDeleteFlinkSchema() {\n+    if (posDeleteFlinkSchema == null) {\n+      Preconditions.checkNotNull(posDeleteRowSchema, \"Pos-delete row schema shouldn't be null\");\n+      this.posDeleteFlinkSchema = FlinkSchemaUtil.convert(posDeleteRowSchema);\n+    }\n+    return this.posDeleteFlinkSchema;\n+  }\n+\n+  @Override\n+  public FileAppender<RowData> newAppender(OutputFile outputFile, FileFormat format) {\n+    MetricsConfig metricsConfig = MetricsConfig.fromProperties(props);\n+    try {\n+      switch (format) {\n+        case AVRO:\n+          return Avro.write(outputFile)\n+              .createWriterFunc(ignore -> new FlinkAvroWriter(flinkSchema))\n+              .setAll(props)\n+              .schema(schema)\n+              .overwrite()\n+              .build();\n+\n+        case ORC:\n+          return ORC.write(outputFile)\n+              .createWriterFunc((iSchema, typDesc) -> FlinkOrcWriter.buildWriter(flinkSchema, iSchema))\n+              .setAll(props)\n+              .schema(schema)\n+              .overwrite()\n+              .build();\n+\n+        case PARQUET:\n+          return Parquet.write(outputFile)\n+              .createWriterFunc(msgType -> FlinkParquetWriters.buildWriter(flinkSchema, msgType))\n+              .setAll(props)\n+              .metricsConfig(metricsConfig)\n+              .schema(schema)\n+              .overwrite()\n+              .build();\n+\n+        default:\n+          throw new UnsupportedOperationException(\"Cannot write unknown file format: \" + format);\n+      }\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  @Override\n+  public DataWriter<RowData> newDataWriter(EncryptedOutputFile file, FileFormat format, StructLike partition) {\n+    return new DataWriter<>(\n+        newAppender(file.encryptingOutputFile(), format), format,\n+        file.encryptingOutputFile().location(), spec, partition, file.keyMetadata());\n+  }\n+\n+  @Override\n+  public EqualityDeleteWriter<RowData> newEqDeleteWriter(EncryptedOutputFile outputFile, FileFormat format,\n+                                                         StructLike partition) {\n+    MetricsConfig metricsConfig = MetricsConfig.fromProperties(props);\n+    try {\n+      switch (format) {\n+        case AVRO:\n+          return Avro.writeDeletes(outputFile.encryptingOutputFile())\n+              .createWriterFunc(ignore -> new FlinkAvroWriter(lazyEqDeleteFlinkSchema()))\n+              .withPartition(partition)\n+              .overwrite()\n+              .setAll(props)\n+              .rowSchema(eqDeleteRowSchema)\n+              .withSpec(spec)\n+              .withKeyMetadata(outputFile.keyMetadata())\n+              .equalityFieldIds(equalityFieldIds)\n+              .buildEqualityWriter();\n+\n+        case PARQUET:\n+          return Parquet.writeDeletes(outputFile.encryptingOutputFile())\n+              .createWriterFunc(msgType -> FlinkParquetWriters.buildWriter(lazyEqDeleteFlinkSchema(), msgType))\n+              .withPartition(partition)\n+              .overwrite()\n+              .setAll(props)\n+              .metricsConfig(metricsConfig)\n+              .rowSchema(eqDeleteRowSchema)\n+              .withSpec(spec)\n+              .withKeyMetadata(outputFile.keyMetadata())\n+              .equalityFieldIds(equalityFieldIds)\n+              .buildEqualityWriter();\n+\n+        default:\n+          throw new UnsupportedOperationException(\"Cannot write unknown file format: \" + format);\n+      }\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  @Override\n+  public PositionDeleteWriter<RowData> newPosDeleteWriter(EncryptedOutputFile outputFile, FileFormat format,\n+                                                          StructLike partition) {\n+    MetricsConfig metricsConfig = MetricsConfig.fromProperties(props);\n+    try {\n+      switch (format) {\n+        case AVRO:\n+          return Avro.writeDeletes(outputFile.encryptingOutputFile())\n+              .createWriterFunc(ignore -> new FlinkAvroWriter(lazyPosDeleteFlinkSchema()))\n+              .withPartition(partition)\n+              .overwrite()\n+              .setAll(props)\n+              .rowSchema(posDeleteRowSchema)\n+              .withSpec(spec)\n+              .withKeyMetadata(outputFile.keyMetadata())\n+              .buildPositionWriter();\n+\n+        case PARQUET:\n+          RowType flinkPosDeleteSchema = FlinkSchemaUtil.convert(DeleteSchemaUtil.posDeleteSchema(posDeleteRowSchema));", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1MTg5Mg==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532151892", "bodyText": "Let me provide more details, assume that we want to build a pos delete writer with row schema <id long, data string>.\nThe straightforward way is to build a struct writer like this:\n    PositionDeleteStructWriter\n               |\n               |---------->  StringWriter (file_path field)\n               |---------->  LongWriter   (pos       field)\n               |\n               |\n               |---------->  StructWriter (row  field)\n                                 |----------> LongWriter    (id   field)\n                                 |----------> StringWriter  (data field)\n\nThe question is how to build the PositionDeleteStructWriter, if we just provide a function to create the row field's StructWriter for flink, and then concat the <StringWriter, LongWriter, StructWriter> to PositionDeleteStructWriter constructor,\nthen the problem is:  the leaf node ColumnWriter will have an incorrect ColumnDescriptor:\n     PositionDeleteStructWriter\n               |\n               |---------->  StringWriter {<file_path>,type,maxRep,maxDef}\n               |---------->  LongWriter   {<pos>,type,maxRep,maxDef}\n               |\n               |\n               |---------->  StructWriter \n                                 |----------> LongWriter    {<id>, type, maxRep, maxDef}\n                                 |----------> StringWriter  {<data>,type, maxRep, maxDef}\nIn fact, for this example, the correct ColumnWriter should be:\n     PositionDeleteStructWriter\n               |\n               |---------->  StringWriter {<file_path>,type,maxRep,maxDef}\n               |---------->  LongWriter   {<pos>,type,maxRep,maxDef}\n               |\n               |\n               |---------->  StructWriter \n                                 |----------> LongWriter    {<row,id>, type, maxRep, maxDef}\n                                 |----------> StringWriter  {<row,data>,type, maxRep, maxDef}", "author": "openinx", "createdAt": "2020-11-29T04:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NDQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1MzcwMw==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532153703", "bodyText": "In my mind, there are two ways to solve the problem, the first one is the current version: Just use the completed scheme which has included the file_path field and pos field to build the flink/spark struct writer, tradeoff\nis exposing few details to upper, such as we need to convert the CharSequence to flink's StringData before we write the file_path value (see the ParquetValueWriters.PathPosAccessor).  The current version is easy to implement.\nAnother way is: call the row schema's createWriterFunc in parquet visitor when building the whole struct writer by traversing the columns. In that visitor, we could add the row prefix to the fieldNames and finally the ColumnDescriptor won't be messed up.\nThat seems to be more complex when compared to the first version. The good thing is hiding all the constructing details inside the builder.\nIMO, I'd prefer to use the current version because the FlinkAppenderFactory and SparkAppenderFactory has already hidden the details for upper layer. People won't likely to write their own AppenderFactory, even if they want to write their own it will be easy when following the current flink/spark appender factory.", "author": "openinx", "createdAt": "2020-11-29T04:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NDQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI2NTk4MQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532265981", "bodyText": "Sorry, I also hit the column descriptor problem when I tried to update this. I have it working for Avro, but not for Parquet. I should have commented with the results of my work so you didn't try it as well.\nI agree with you that this would be really difficult to solve and it is probably not worth it. We'll just have to go with the existing solution for Parquet until we get a better Parquet API that can load columns by ID rather than by path.", "author": "rdblue", "createdAt": "2020-11-29T21:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NDQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU2NTg5NA==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532565894", "bodyText": "we get a better Parquet API that can load columns by ID rather than by path.\n\nSounds like it's the correct direction to solve this issue, will that need much work to accomplish (I'm not quite sure).\nBTW,  do you have other concern about this patch ?", "author": "openinx", "createdAt": "2020-11-30T12:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NDQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MDc2Mw==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532940763", "bodyText": "I'm reviewing it now. I just wanted to comment yesterday to let you know about the Parquet problem.\nFor the amount of work in Parquet, it shouldn't be too difficult for just this, but we need to support field IDs more generally over there and that is going to be a big project with all of the little things that need to be done.", "author": "rdblue", "createdAt": "2020-11-30T22:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ3NDQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMDk1Nw==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532930957", "bodyText": "Could this be the default implementation of newDataWriter? It looks the same across all of the implementations.", "author": "rdblue", "createdAt": "2020-11-30T21:59:27Z", "path": "data/src/main/java/org/apache/iceberg/data/GenericAppenderFactory.java", "diffHunk": "@@ -95,4 +115,88 @@ public GenericAppenderFactory setAll(Map<String, String> properties) {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  @Override\n+  public org.apache.iceberg.io.DataWriter<Record> newDataWriter(EncryptedOutputFile file, FileFormat format,\n+                                                                StructLike partition) {\n+    return new org.apache.iceberg.io.DataWriter<>(\n+        newAppender(file.encryptingOutputFile(), format), format,\n+        file.encryptingOutputFile().location(), spec, partition, file.keyMetadata());\n+  }", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwNDk5OA==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533104998", "bodyText": "I did not move it to be an default implementation for newDataWriter  because the DataWriter construction will need the the partition spec.  It's not friendly to expose an extra method spec() in FileAppenderFactory ( so that those subclass could pass the correct spec object to DataWriter).", "author": "openinx", "createdAt": "2020-12-01T06:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczMTc5NQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533731795", "bodyText": "Sounds good, thanks for explaining it to me.", "author": "rdblue", "createdAt": "2020-12-01T21:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMDk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzMTM5Mw==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532931393", "bodyText": "I think it should be \"unsupported\" rather than \"unknown\" because ORC is known, but not supported.", "author": "rdblue", "createdAt": "2020-11-30T22:00:17Z", "path": "data/src/main/java/org/apache/iceberg/data/GenericAppenderFactory.java", "diffHunk": "@@ -95,4 +115,88 @@ public GenericAppenderFactory setAll(Map<String, String> properties) {\n       throw new UncheckedIOException(e);\n     }\n   }\n+\n+  @Override\n+  public org.apache.iceberg.io.DataWriter<Record> newDataWriter(EncryptedOutputFile file, FileFormat format,\n+                                                                StructLike partition) {\n+    return new org.apache.iceberg.io.DataWriter<>(\n+        newAppender(file.encryptingOutputFile(), format), format,\n+        file.encryptingOutputFile().location(), spec, partition, file.keyMetadata());\n+  }\n+\n+  @Override\n+  public EqualityDeleteWriter<Record> newEqDeleteWriter(EncryptedOutputFile file, FileFormat format,\n+                                                        StructLike partition) {\n+    MetricsConfig metricsConfig = MetricsConfig.fromProperties(config);\n+    try {\n+      switch (format) {\n+        case AVRO:\n+          return Avro.writeDeletes(file.encryptingOutputFile())\n+              .createWriterFunc(DataWriter::create)\n+              .withPartition(partition)\n+              .overwrite()\n+              .setAll(config)\n+              .rowSchema(eqDeleteRowSchema)\n+              .withSpec(spec)\n+              .withKeyMetadata(file.keyMetadata())\n+              .equalityFieldIds(equalityFieldIds)\n+              .buildEqualityWriter();\n+\n+        case PARQUET:\n+          return Parquet.writeDeletes(file.encryptingOutputFile())\n+              .createWriterFunc(GenericParquetWriter::buildWriter)\n+              .withPartition(partition)\n+              .overwrite()\n+              .setAll(config)\n+              .metricsConfig(metricsConfig)\n+              .rowSchema(eqDeleteRowSchema)\n+              .withSpec(spec)\n+              .withKeyMetadata(file.keyMetadata())\n+              .equalityFieldIds(equalityFieldIds)\n+              .buildEqualityWriter();\n+\n+        default:\n+          throw new UnsupportedOperationException(\"Cannot write unknown file format: \" + format);\n+      }\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  @Override\n+  public PositionDeleteWriter<Record> newPosDeleteWriter(EncryptedOutputFile file, FileFormat format,\n+                                                         StructLike partition) {\n+    MetricsConfig metricsConfig = MetricsConfig.fromProperties(config);\n+    try {\n+      switch (format) {\n+        case AVRO:\n+          return Avro.writeDeletes(file.encryptingOutputFile())\n+              .createWriterFunc(DataWriter::create)\n+              .withPartition(partition)\n+              .overwrite()\n+              .setAll(config)\n+              .rowSchema(posDeleteRowSchema)\n+              .withSpec(spec)\n+              .withKeyMetadata(file.keyMetadata())\n+              .buildPositionWriter();\n+\n+        case PARQUET:\n+          return Parquet.writeDeletes(file.encryptingOutputFile())\n+              .createWriterFunc(GenericParquetWriter::buildWriter)\n+              .withPartition(partition)\n+              .overwrite()\n+              .setAll(config)\n+              .metricsConfig(metricsConfig)\n+              .rowSchema(posDeleteRowSchema)\n+              .withSpec(spec)\n+              .withKeyMetadata(file.keyMetadata())\n+              .buildPositionWriter();\n+\n+        default:\n+          throw new UnsupportedOperationException(\"Cannot write unknown file format: \" + format);", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNTA0Nw==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532935047", "bodyText": "Why not set eqDeleteRowSchema to null since equalityFieldIds is null?", "author": "rdblue", "createdAt": "2020-11-30T22:07:44Z", "path": "data/src/main/java/org/apache/iceberg/data/GenericAppenderFactory.java", "diffHunk": "@@ -42,10 +47,25 @@\n public class GenericAppenderFactory implements FileAppenderFactory<Record> {\n \n   private final Schema schema;\n+  private final PartitionSpec spec;\n+  private final int[] equalityFieldIds;\n+  private final Schema eqDeleteRowSchema;\n+  private final Schema posDeleteRowSchema;\n   private final Map<String, String> config = Maps.newHashMap();\n \n-  public GenericAppenderFactory(Schema schema) {\n+  public GenericAppenderFactory(Schema schema, PartitionSpec spec) {\n+    this(schema, spec, null, schema, null);", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEwMDA0NQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533100045", "bodyText": "OK, it's more reasonable to set the eqDeleteRowSchema to be null when equalityFieldIds is null.", "author": "openinx", "createdAt": "2020-12-01T06:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNTA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNTUyOQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532935529", "bodyText": "Could we keep the constructor this was using before so we don't need to change any tests that only use newAppender? There are 4 files just here that don't appear like they need to change just to add the spec that won't be used.", "author": "rdblue", "createdAt": "2020-11-30T22:08:50Z", "path": "data/src/test/java/org/apache/iceberg/data/GenericAppenderHelper.java", "diffHunk": "@@ -73,13 +74,12 @@ public DataFile writeFile(StructLike partition, List<Record> records) throws IOE\n     Preconditions.checkNotNull(table, \"table not set\");\n     File file = tmp.newFile();\n     Assert.assertTrue(file.delete());\n-    return appendToLocalFile(table, file, fileFormat, partition, records);\n+    return appendToLocalFile(table, file, fileFormat, partition, records, table.spec());\n   }\n \n-  private static DataFile appendToLocalFile(\n-      Table table, File file, FileFormat format, StructLike partition, List<Record> records)\n-      throws IOException {\n-    FileAppender<Record> appender = new GenericAppenderFactory(table.schema()).newAppender(\n+  private static DataFile appendToLocalFile(Table table, File file, FileFormat format, StructLike partition,\n+                                            List<Record> records, PartitionSpec spec) throws IOException {\n+    FileAppender<Record> appender = new GenericAppenderFactory(table.schema(), spec).newAppender(", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0ODcxNg==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532948716", "bodyText": "I think I've counted at least 10 files that would not need to change if we kept the original constructor.", "author": "rdblue", "createdAt": "2020-11-30T22:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkzNTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0NzQ5NA==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532947494", "bodyText": "I'd rather not add this to the build method. Nothing distinguishes it from other options, so I think we should add transformations as configuration methods, like we do for equalityFieldIds.\nI'm also thinking that it would be good to have a more light-weight way to add these transforms. Rather than an additional accessor that has two abstract methods, why not just register functions? It could look like this:\n  Avro.writeDeletes(outFile)\n      ...\n      .transformPaths(StringData::fromString)\n      .buildPositionWriter();\nThat way it's easier to use a method reference rather than creating a class. And nothing actually needs to transform pos yet, so we can just leave that out.", "author": "rdblue", "createdAt": "2020-11-30T22:34:11Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/Parquet.java", "diffHunk": "@@ -379,42 +378,40 @@ public DeleteWriteBuilder equalityFieldIds(int... fieldIds) {\n           appenderBuilder.build(), FileFormat.PARQUET, location, spec, partition, keyMetadata, equalityFieldIds);\n     }\n \n-\n-    public <T> PositionDeleteWriter<T> buildPositionWriter() throws IOException {\n+    public <T> PositionDeleteWriter<T> buildPositionWriter(ParquetValueWriters.PathPosAccessor<?, ?> accessor)", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyOTY1OQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533129659", "bodyText": "I like the idea about registering a light-weight function to convert the CharSequence to StringData.", "author": "openinx", "createdAt": "2020-12-01T07:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0NzQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MTIyMQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532951221", "bodyText": "I think this could just be table.schema(). No need to go through the spec to get the table schema.", "author": "rdblue", "createdAt": "2020-11-30T22:42:15Z", "path": "core/src/test/java/org/apache/iceberg/io/TestAppenderFactory.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.deletes.EqualityDeleteWriter;\n+import org.apache.iceberg.deletes.PositionDelete;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public abstract class TestAppenderFactory<T> extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+  private final boolean partitioned;\n+\n+  private PartitionKey partition = null;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}, Partitioned={1}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\", false},\n+        new Object[] {\"avro\", true},\n+        new Object[] {\"parquet\", false},\n+        new Object[] {\"parquet\", true}\n+    };\n+  }\n+\n+\n+  public TestAppenderFactory(String fileFormat, boolean partitioned) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+    this.partitioned = partitioned;\n+  }\n+\n+  @Before\n+  public void setupTable() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete()); // created by table create\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+\n+    if (partitioned) {\n+      this.table = create(SCHEMA, SPEC);\n+    } else {\n+      this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    }\n+    this.partition = createPartitionKey();\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  protected abstract FileAppenderFactory<T> createAppenderFactory(List<Integer> equalityFieldIds,\n+                                                                  Schema eqDeleteSchema,\n+                                                                  Schema posDeleteRowSchema);\n+\n+  protected abstract T createRow(Integer id, String data);\n+\n+  protected abstract StructLikeSet expectedRowSet(Iterable<T> records) throws IOException;\n+\n+  protected abstract StructLikeSet actualRowSet(String... columns) throws IOException;\n+\n+  private OutputFileFactory createFileFactory() {\n+    return new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+  }\n+\n+  private PartitionKey createPartitionKey() {\n+    if (table.spec().isUnpartitioned()) {\n+      return null;\n+    }\n+\n+    Record record = GenericRecord.create(table.spec().schema()).copy(ImmutableMap.of(\"data\", \"aaa\"));", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MjAxMQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532952011", "bodyText": "If the data here is bbb instead of ccc on purpose, then could you add a comment that this is testing that just id is used for comparison?", "author": "rdblue", "createdAt": "2020-11-30T22:44:06Z", "path": "core/src/test/java/org/apache/iceberg/io/TestAppenderFactory.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.deletes.EqualityDeleteWriter;\n+import org.apache.iceberg.deletes.PositionDelete;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public abstract class TestAppenderFactory<T> extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+  private final boolean partitioned;\n+\n+  private PartitionKey partition = null;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}, Partitioned={1}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\", false},\n+        new Object[] {\"avro\", true},\n+        new Object[] {\"parquet\", false},\n+        new Object[] {\"parquet\", true}\n+    };\n+  }\n+\n+\n+  public TestAppenderFactory(String fileFormat, boolean partitioned) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+    this.partitioned = partitioned;\n+  }\n+\n+  @Before\n+  public void setupTable() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete()); // created by table create\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+\n+    if (partitioned) {\n+      this.table = create(SCHEMA, SPEC);\n+    } else {\n+      this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    }\n+    this.partition = createPartitionKey();\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  protected abstract FileAppenderFactory<T> createAppenderFactory(List<Integer> equalityFieldIds,\n+                                                                  Schema eqDeleteSchema,\n+                                                                  Schema posDeleteRowSchema);\n+\n+  protected abstract T createRow(Integer id, String data);\n+\n+  protected abstract StructLikeSet expectedRowSet(Iterable<T> records) throws IOException;\n+\n+  protected abstract StructLikeSet actualRowSet(String... columns) throws IOException;\n+\n+  private OutputFileFactory createFileFactory() {\n+    return new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+  }\n+\n+  private PartitionKey createPartitionKey() {\n+    if (table.spec().isUnpartitioned()) {\n+      return null;\n+    }\n+\n+    Record record = GenericRecord.create(table.spec().schema()).copy(ImmutableMap.of(\"data\", \"aaa\"));\n+\n+    PartitionKey partitionKey = new PartitionKey(table.spec(), table.schema());\n+    partitionKey.partition(record);\n+\n+    return partitionKey;\n+  }\n+\n+  private List<T> testRowSet() {\n+    return Lists.newArrayList(\n+        createRow(1, \"aaa\"),\n+        createRow(2, \"bbb\"),\n+        createRow(3, \"ccc\"),\n+        createRow(4, \"ddd\"),\n+        createRow(5, \"eee\")\n+    );\n+  }\n+\n+  private DataFile prepareDataFile(List<T> rowSet, FileAppenderFactory<T> appenderFactory,\n+                                   OutputFileFactory outputFileFactory) throws IOException {\n+    DataWriter<T> writer = appenderFactory.newDataWriter(outputFileFactory.newOutputFile(), format, partition);\n+    try (DataWriter<T> closeableWriter = writer) {\n+      for (T row : rowSet) {\n+        closeableWriter.add(row);\n+      }\n+    }\n+\n+    return writer.toDataFile();\n+  }\n+\n+  @Test\n+  public void testDataWriter() throws IOException {\n+    FileAppenderFactory<T> appenderFactory = createAppenderFactory(null, null, null);\n+    OutputFileFactory outputFileFactory = createFileFactory();\n+\n+    List<T> rowSet = testRowSet();\n+    DataFile dataFile = prepareDataFile(rowSet, appenderFactory, outputFileFactory);\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .commit();\n+\n+    Assert.assertEquals(\"Should have the expected records.\", expectedRowSet(rowSet), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testEqDeleteWriter() throws IOException {\n+    List<Integer> equalityFieldIds = Lists.newArrayList(table.schema().findField(\"id\").fieldId());\n+    FileAppenderFactory<T> appenderFactory = createAppenderFactory(equalityFieldIds,\n+        table.schema().select(\"id\"), null);\n+    OutputFileFactory outputFileFactory = createFileFactory();\n+\n+    List<T> rowSet = testRowSet();\n+    DataFile dataFile = prepareDataFile(rowSet, appenderFactory, outputFileFactory);\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .commit();\n+\n+    List<T> deletes = Lists.newArrayList(\n+        createRow(1, \"aaa\"),\n+        createRow(3, \"bbb\"),", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MzE5NQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532953195", "bodyText": "Instead of reading from the table, I would rather see a test that the equality delete file contains the expected row data. In this case, it should not contain the data column. I would like to see that checked. And it would be good to add a case where the whole original row is written to the file.", "author": "rdblue", "createdAt": "2020-11-30T22:46:44Z", "path": "core/src/test/java/org/apache/iceberg/io/TestAppenderFactory.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.deletes.EqualityDeleteWriter;\n+import org.apache.iceberg.deletes.PositionDelete;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public abstract class TestAppenderFactory<T> extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+  private final boolean partitioned;\n+\n+  private PartitionKey partition = null;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}, Partitioned={1}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\", false},\n+        new Object[] {\"avro\", true},\n+        new Object[] {\"parquet\", false},\n+        new Object[] {\"parquet\", true}\n+    };\n+  }\n+\n+\n+  public TestAppenderFactory(String fileFormat, boolean partitioned) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+    this.partitioned = partitioned;\n+  }\n+\n+  @Before\n+  public void setupTable() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete()); // created by table create\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+\n+    if (partitioned) {\n+      this.table = create(SCHEMA, SPEC);\n+    } else {\n+      this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    }\n+    this.partition = createPartitionKey();\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  protected abstract FileAppenderFactory<T> createAppenderFactory(List<Integer> equalityFieldIds,\n+                                                                  Schema eqDeleteSchema,\n+                                                                  Schema posDeleteRowSchema);\n+\n+  protected abstract T createRow(Integer id, String data);\n+\n+  protected abstract StructLikeSet expectedRowSet(Iterable<T> records) throws IOException;\n+\n+  protected abstract StructLikeSet actualRowSet(String... columns) throws IOException;\n+\n+  private OutputFileFactory createFileFactory() {\n+    return new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+  }\n+\n+  private PartitionKey createPartitionKey() {\n+    if (table.spec().isUnpartitioned()) {\n+      return null;\n+    }\n+\n+    Record record = GenericRecord.create(table.spec().schema()).copy(ImmutableMap.of(\"data\", \"aaa\"));\n+\n+    PartitionKey partitionKey = new PartitionKey(table.spec(), table.schema());\n+    partitionKey.partition(record);\n+\n+    return partitionKey;\n+  }\n+\n+  private List<T> testRowSet() {\n+    return Lists.newArrayList(\n+        createRow(1, \"aaa\"),\n+        createRow(2, \"bbb\"),\n+        createRow(3, \"ccc\"),\n+        createRow(4, \"ddd\"),\n+        createRow(5, \"eee\")\n+    );\n+  }\n+\n+  private DataFile prepareDataFile(List<T> rowSet, FileAppenderFactory<T> appenderFactory,\n+                                   OutputFileFactory outputFileFactory) throws IOException {\n+    DataWriter<T> writer = appenderFactory.newDataWriter(outputFileFactory.newOutputFile(), format, partition);\n+    try (DataWriter<T> closeableWriter = writer) {\n+      for (T row : rowSet) {\n+        closeableWriter.add(row);\n+      }\n+    }\n+\n+    return writer.toDataFile();\n+  }\n+\n+  @Test\n+  public void testDataWriter() throws IOException {\n+    FileAppenderFactory<T> appenderFactory = createAppenderFactory(null, null, null);\n+    OutputFileFactory outputFileFactory = createFileFactory();\n+\n+    List<T> rowSet = testRowSet();\n+    DataFile dataFile = prepareDataFile(rowSet, appenderFactory, outputFileFactory);\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .commit();\n+\n+    Assert.assertEquals(\"Should have the expected records.\", expectedRowSet(rowSet), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testEqDeleteWriter() throws IOException {\n+    List<Integer> equalityFieldIds = Lists.newArrayList(table.schema().findField(\"id\").fieldId());\n+    FileAppenderFactory<T> appenderFactory = createAppenderFactory(equalityFieldIds,\n+        table.schema().select(\"id\"), null);\n+    OutputFileFactory outputFileFactory = createFileFactory();\n+\n+    List<T> rowSet = testRowSet();\n+    DataFile dataFile = prepareDataFile(rowSet, appenderFactory, outputFileFactory);\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .commit();\n+\n+    List<T> deletes = Lists.newArrayList(\n+        createRow(1, \"aaa\"),\n+        createRow(3, \"bbb\"),\n+        createRow(5, \"ccc\")\n+    );\n+    EqualityDeleteWriter<T> eqDeleteWriter =\n+        appenderFactory.newEqDeleteWriter(outputFileFactory.newOutputFile(), format, partition);\n+    try (EqualityDeleteWriter<T> closeableWriter = eqDeleteWriter) {\n+      closeableWriter.deleteAll(deletes);\n+    }\n+\n+    table.newRowDelta()\n+        .addDeletes(eqDeleteWriter.toDeleteFile())\n+        .commit();\n+\n+    List<T> expected = Lists.newArrayList(\n+        createRow(2, \"bbb\"),\n+        createRow(4, \"ddd\")\n+    );\n+    Assert.assertEquals(\"Should have the expected records\", expectedRowSet(expected), actualRowSet(\"*\"));", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MzU2OA==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r532953568", "bodyText": "Similar to above, I think this should check that only the path and position columns are written to the file and that they are the expected values. The test below should check that the row column is present and set correctly for each row.", "author": "rdblue", "createdAt": "2020-11-30T22:47:36Z", "path": "core/src/test/java/org/apache/iceberg/io/TestAppenderFactory.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.deletes.EqualityDeleteWriter;\n+import org.apache.iceberg.deletes.PositionDelete;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public abstract class TestAppenderFactory<T> extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+  private final boolean partitioned;\n+\n+  private PartitionKey partition = null;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}, Partitioned={1}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\", false},\n+        new Object[] {\"avro\", true},\n+        new Object[] {\"parquet\", false},\n+        new Object[] {\"parquet\", true}\n+    };\n+  }\n+\n+\n+  public TestAppenderFactory(String fileFormat, boolean partitioned) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+    this.partitioned = partitioned;\n+  }\n+\n+  @Before\n+  public void setupTable() throws Exception {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete()); // created by table create\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+\n+    if (partitioned) {\n+      this.table = create(SCHEMA, SPEC);\n+    } else {\n+      this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    }\n+    this.partition = createPartitionKey();\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  protected abstract FileAppenderFactory<T> createAppenderFactory(List<Integer> equalityFieldIds,\n+                                                                  Schema eqDeleteSchema,\n+                                                                  Schema posDeleteRowSchema);\n+\n+  protected abstract T createRow(Integer id, String data);\n+\n+  protected abstract StructLikeSet expectedRowSet(Iterable<T> records) throws IOException;\n+\n+  protected abstract StructLikeSet actualRowSet(String... columns) throws IOException;\n+\n+  private OutputFileFactory createFileFactory() {\n+    return new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+  }\n+\n+  private PartitionKey createPartitionKey() {\n+    if (table.spec().isUnpartitioned()) {\n+      return null;\n+    }\n+\n+    Record record = GenericRecord.create(table.spec().schema()).copy(ImmutableMap.of(\"data\", \"aaa\"));\n+\n+    PartitionKey partitionKey = new PartitionKey(table.spec(), table.schema());\n+    partitionKey.partition(record);\n+\n+    return partitionKey;\n+  }\n+\n+  private List<T> testRowSet() {\n+    return Lists.newArrayList(\n+        createRow(1, \"aaa\"),\n+        createRow(2, \"bbb\"),\n+        createRow(3, \"ccc\"),\n+        createRow(4, \"ddd\"),\n+        createRow(5, \"eee\")\n+    );\n+  }\n+\n+  private DataFile prepareDataFile(List<T> rowSet, FileAppenderFactory<T> appenderFactory,\n+                                   OutputFileFactory outputFileFactory) throws IOException {\n+    DataWriter<T> writer = appenderFactory.newDataWriter(outputFileFactory.newOutputFile(), format, partition);\n+    try (DataWriter<T> closeableWriter = writer) {\n+      for (T row : rowSet) {\n+        closeableWriter.add(row);\n+      }\n+    }\n+\n+    return writer.toDataFile();\n+  }\n+\n+  @Test\n+  public void testDataWriter() throws IOException {\n+    FileAppenderFactory<T> appenderFactory = createAppenderFactory(null, null, null);\n+    OutputFileFactory outputFileFactory = createFileFactory();\n+\n+    List<T> rowSet = testRowSet();\n+    DataFile dataFile = prepareDataFile(rowSet, appenderFactory, outputFileFactory);\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .commit();\n+\n+    Assert.assertEquals(\"Should have the expected records.\", expectedRowSet(rowSet), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testEqDeleteWriter() throws IOException {\n+    List<Integer> equalityFieldIds = Lists.newArrayList(table.schema().findField(\"id\").fieldId());\n+    FileAppenderFactory<T> appenderFactory = createAppenderFactory(equalityFieldIds,\n+        table.schema().select(\"id\"), null);\n+    OutputFileFactory outputFileFactory = createFileFactory();\n+\n+    List<T> rowSet = testRowSet();\n+    DataFile dataFile = prepareDataFile(rowSet, appenderFactory, outputFileFactory);\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .commit();\n+\n+    List<T> deletes = Lists.newArrayList(\n+        createRow(1, \"aaa\"),\n+        createRow(3, \"bbb\"),\n+        createRow(5, \"ccc\")\n+    );\n+    EqualityDeleteWriter<T> eqDeleteWriter =\n+        appenderFactory.newEqDeleteWriter(outputFileFactory.newOutputFile(), format, partition);\n+    try (EqualityDeleteWriter<T> closeableWriter = eqDeleteWriter) {\n+      closeableWriter.deleteAll(deletes);\n+    }\n+\n+    table.newRowDelta()\n+        .addDeletes(eqDeleteWriter.toDeleteFile())\n+        .commit();\n+\n+    List<T> expected = Lists.newArrayList(\n+        createRow(2, \"bbb\"),\n+        createRow(4, \"ddd\")\n+    );\n+    Assert.assertEquals(\"Should have the expected records\", expectedRowSet(expected), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testPosDeleteWriter() throws IOException {\n+    // Initialize FileAppenderFactory without pos-delete row schema.\n+    FileAppenderFactory<T> appenderFactory = createAppenderFactory(null, null, null);\n+    OutputFileFactory outputFileFactory = createFileFactory();\n+\n+    List<T> rowSet = testRowSet();\n+    DataFile dataFile = prepareDataFile(rowSet, appenderFactory, outputFileFactory);\n+\n+    List<Pair<CharSequence, Long>> deletes = Lists.newArrayList(\n+        Pair.of(dataFile.path(), 0L),\n+        Pair.of(dataFile.path(), 2L),\n+        Pair.of(dataFile.path(), 4L)\n+    );\n+\n+    PositionDeleteWriter<T> eqDeleteWriter =\n+        appenderFactory.newPosDeleteWriter(outputFileFactory.newOutputFile(), format, partition);\n+    try (PositionDeleteWriter<T> closeableWriter = eqDeleteWriter) {\n+      for (Pair<CharSequence, Long> delete : deletes) {\n+        closeableWriter.delete(delete.first(), delete.second());\n+      }\n+    }\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .addDeletes(eqDeleteWriter.toDeleteFile())\n+        .validateDataFilesExist(eqDeleteWriter.referencedDataFiles())\n+        .validateDeletedFiles()\n+        .commit();\n+\n+    List<T> expected = Lists.newArrayList(\n+        createRow(2, \"bbb\"),\n+        createRow(4, \"ddd\")\n+    );\n+    Assert.assertEquals(\"Should have the expected records\", expectedRowSet(expected), actualRowSet(\"*\"));", "originalCommit": "d6cebc65cb8b2e9ede9feb37dd54cdcc880ab45c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8006b63bb4f2539d4afc7e0c4ede4d56b2295979", "url": "https://github.com/apache/iceberg/commit/8006b63bb4f2539d4afc7e0c4ede4d56b2295979", "message": "Address comment", "committedDate": "2020-12-01T06:57:42Z", "type": "commit"}, {"oid": "b26898d4746294bdec0d0bfce18060d864171c61", "url": "https://github.com/apache/iceberg/commit/b26898d4746294bdec0d0bfce18060d864171c61", "message": "Minor changes", "committedDate": "2020-12-01T07:44:27Z", "type": "commit"}, {"oid": "8e423fb34d02da49e78a9750b6204f6ce23cead2", "url": "https://github.com/apache/iceberg/commit/8e423fb34d02da49e78a9750b6204f6ce23cead2", "message": "Align the exception messages", "committedDate": "2020-12-01T07:59:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEzOTg1MA==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533139850", "bodyText": "Here I use the constructor that has spec argument because I believe we will use the DataWriter to append records once we switch to the RollingFileWriter. https://github.com/apache/iceberg/pull/1818/files#diff-fc9a9fd84d24c607fd85e053b08a559f56dd2dd2a46f1341c528e7a0269f873cR263.", "author": "openinx", "createdAt": "2020-12-01T08:06:40Z", "path": "spark/src/main/java/org/apache/iceberg/spark/source/RowDataRewriter.java", "diffHunk": "@@ -98,7 +98,7 @@ public RowDataRewriter(Table table, PartitionSpec spec, boolean caseSensitive,\n         task, schema, schema, nameMapping, io.value(), encryptionManager.value(), caseSensitive);\n \n     StructType structType = SparkSchemaUtil.convert(schema);\n-    SparkAppenderFactory appenderFactory = new SparkAppenderFactory(properties, schema, structType);\n+    SparkAppenderFactory appenderFactory = new SparkAppenderFactory(properties, schema, structType, spec);", "originalCommit": "8e423fb34d02da49e78a9750b6204f6ce23cead2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b2b04bd45bafa5ea794fd35366e819afc45b574", "url": "https://github.com/apache/iceberg/commit/4b2b04bd45bafa5ea794fd35366e819afc45b574", "message": "Make the pathPosSchema to be private", "committedDate": "2020-12-01T08:16:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczNzIwMw==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533737203", "bodyText": "Nit: I think it would be better to use Function.identity().", "author": "rdblue", "createdAt": "2020-12-01T21:36:59Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/Parquet.java", "diffHunk": "@@ -281,6 +280,7 @@ public static DeleteWriteBuilder writeDeletes(OutputFile file) {\n     private StructLike partition = null;\n     private EncryptionKeyMetadata keyMetadata = null;\n     private int[] equalityFieldIds = null;\n+    private Function<CharSequence, ?> pathTransformFunc = t -> t;", "originalCommit": "4b2b04bd45bafa5ea794fd35366e819afc45b574", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczNzY1NQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533737655", "bodyText": "Does this line need to change? I'm fine removing the empty line, but I think throws can still fit on the previous line.", "author": "rdblue", "createdAt": "2020-12-01T21:37:56Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/Parquet.java", "diffHunk": "@@ -379,37 +384,31 @@ public DeleteWriteBuilder equalityFieldIds(int... fieldIds) {\n           appenderBuilder.build(), FileFormat.PARQUET, location, spec, partition, keyMetadata, equalityFieldIds);\n     }\n \n-\n-    public <T> PositionDeleteWriter<T> buildPositionWriter() throws IOException {\n+    public <T> PositionDeleteWriter<T> buildPositionWriter()\n+        throws IOException {", "originalCommit": "4b2b04bd45bafa5ea794fd35366e819afc45b574", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0MTYyMg==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533841622", "bodyText": "I can revert it.", "author": "openinx", "createdAt": "2020-12-02T01:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczNzY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczODM0NQ==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533738345", "bodyText": "Shouldn't this pass pathTransformFunc as well?", "author": "rdblue", "createdAt": "2020-12-01T21:39:16Z", "path": "parquet/src/main/java/org/apache/iceberg/parquet/Parquet.java", "diffHunk": "@@ -379,37 +384,31 @@ public DeleteWriteBuilder equalityFieldIds(int... fieldIds) {\n           appenderBuilder.build(), FileFormat.PARQUET, location, spec, partition, keyMetadata, equalityFieldIds);\n     }\n \n-\n-    public <T> PositionDeleteWriter<T> buildPositionWriter() throws IOException {\n+    public <T> PositionDeleteWriter<T> buildPositionWriter()\n+        throws IOException {\n       Preconditions.checkState(equalityFieldIds == null, \"Cannot create position delete file using delete field ids\");\n \n       meta(\"delete-type\", \"position\");\n \n       if (rowSchema != null && createWriterFunc != null) {\n         // the appender uses the row schema wrapped with position fields\n-        appenderBuilder.schema(new org.apache.iceberg.Schema(\n-            MetadataColumns.DELETE_FILE_PATH,\n-            MetadataColumns.DELETE_FILE_POS,\n-            NestedField.optional(\n-                MetadataColumns.DELETE_FILE_ROW_FIELD_ID, \"row\", rowSchema.asStruct(),\n-                MetadataColumns.DELETE_FILE_ROW_DOC)));\n+        appenderBuilder.schema(DeleteSchemaUtil.posDeleteSchema(rowSchema));\n \n         appenderBuilder.createWriterFunc(parquetSchema -> {\n           ParquetValueWriter<?> writer = createWriterFunc.apply(parquetSchema);\n           if (writer instanceof StructWriter) {\n-            return new PositionDeleteStructWriter<T>((StructWriter<?>) writer);\n+            return new PositionDeleteStructWriter<T>((StructWriter<?>) writer, pathTransformFunc);\n           } else {\n             throw new UnsupportedOperationException(\"Cannot wrap writer for position deletes: \" + writer.getClass());\n           }\n         });\n \n       } else {\n-        appenderBuilder.schema(new org.apache.iceberg.Schema(\n-            MetadataColumns.DELETE_FILE_PATH,\n-            MetadataColumns.DELETE_FILE_POS));\n+        appenderBuilder.schema(DeleteSchemaUtil.pathPosSchema());\n \n         appenderBuilder.createWriterFunc(parquetSchema ->\n-            new PositionDeleteStructWriter<T>((StructWriter<?>) GenericParquetWriter.buildWriter(parquetSchema)));\n+            new PositionDeleteStructWriter<T>((StructWriter<?>) GenericParquetWriter.buildWriter(parquetSchema),\n+                t -> t));", "originalCommit": "4b2b04bd45bafa5ea794fd35366e819afc45b574", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0MTIwNA==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533841204", "bodyText": "We shouldn't pass pathTransformFunc here, because in this path we will use GenericParquetWriter (Rather than FlinkParquetWriter or SparkParquetWriter) to write the PositionDelete,  if convert the path CharSequence to StringData,  the GenericParquetWriter could not find the correct writer to write values.", "author": "openinx", "createdAt": "2020-12-02T01:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczODM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0MTM4Mw==", "url": "https://github.com/apache/iceberg/pull/1836#discussion_r533841383", "bodyText": "It's good to use Function.identity() here.", "author": "openinx", "createdAt": "2020-12-02T01:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzczODM0NQ=="}], "type": "inlineReview"}, {"oid": "e6a8169000cbb740e3e7a19ae8e843f605e642ed", "url": "https://github.com/apache/iceberg/commit/e6a8169000cbb740e3e7a19ae8e843f605e642ed", "message": "Address nit issues.", "committedDate": "2020-12-02T01:51:09Z", "type": "commit"}]}