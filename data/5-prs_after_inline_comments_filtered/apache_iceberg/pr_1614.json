{"pr_number": 1614, "pr_title": "Core: ensure sort order and specs exist in v2 when parsing table metadata", "pr_createdAt": "2020-10-14T22:46:08Z", "pr_url": "https://github.com/apache/iceberg/pull/1614", "timeline": [{"oid": "6e7f8aa792da9f34a7584cd43284cc0f9ce310d6", "url": "https://github.com/apache/iceberg/commit/6e7f8aa792da9f34a7584cd43284cc0f9ce310d6", "message": "Core: ensure sort order and specs exist in v2 when parsing table metadata (#1419)", "committedDate": "2020-10-14T22:34:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NzM3OA==", "url": "https://github.com/apache/iceberg/pull/1614#discussion_r513647378", "bodyText": "I think the test files should be in src/test/resources so that ClassLoader.getResource can be used to read. That is usually a better way to find fixtures because it avoids assuming the current working directory of the build.", "author": "rdblue", "createdAt": "2020-10-28T17:51:04Z", "path": "core/src/test/java/org/apache/iceberg/TestTableMetadata.java", "diffHunk": "@@ -446,68 +448,48 @@ public void testVersionValidation() {\n \n   @Test\n   public void testParserVersionValidation() throws Exception {\n-    String supportedVersion = toJsonWithVersion(\n-        TableMetadata.newTableMetadata(TEST_SCHEMA, SPEC_5, TEST_LOCATION, ImmutableMap.of()),\n-        TableMetadata.SUPPORTED_TABLE_FORMAT_VERSION);\n-    TableMetadata parsed = TableMetadataParser.fromJson(\n-        ops.io(), null, JsonUtil.mapper().readValue(supportedVersion, JsonNode.class));\n-    Assert.assertNotNull(\"Should successfully read supported metadata version\", parsed);\n-\n-    String unsupportedVersion = toJsonWithVersion(\n-        TableMetadata.newTableMetadata(TEST_SCHEMA, SPEC_5, TEST_LOCATION, ImmutableMap.of()),\n-        TableMetadata.SUPPORTED_TABLE_FORMAT_VERSION + 1);\n+    String supportedVersion1 = readTableMetadataInputFile(\"TableMetadataV1Valid.json\");\n+    TableMetadata parsed1 = TableMetadataParser.fromJson(\n+        ops.io(), null, JsonUtil.mapper().readValue(supportedVersion1, JsonNode.class));\n+    Assert.assertNotNull(\"Should successfully read supported metadata version\", parsed1);\n+\n+    String supportedVersion2 = readTableMetadataInputFile(\"TableMetadataV2Valid.json\");\n+    TableMetadata parsed2 = TableMetadataParser.fromJson(\n+        ops.io(), null, JsonUtil.mapper().readValue(supportedVersion2, JsonNode.class));\n+    Assert.assertNotNull(\"Should successfully read supported metadata version\", parsed2);\n+\n+    String unsupportedVersion = readTableMetadataInputFile(\"TableMetadataUnsupportedVersion.json\");\n     AssertHelpers.assertThrows(\"Should not read unsupported metadata\",\n         IllegalArgumentException.class, \"Cannot read unsupported version\",\n         () -> TableMetadataParser.fromJson(\n-            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class)));\n+            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class))\n+    );\n   }\n \n-  public static String toJsonWithVersion(TableMetadata metadata, int version) {\n-    StringWriter writer = new StringWriter();\n-    try {\n-      JsonGenerator generator = JsonUtil.factory().createGenerator(writer);\n-\n-      generator.writeStartObject(); // start table metadata object\n-\n-      generator.writeNumberField(FORMAT_VERSION, version);\n-      generator.writeStringField(TABLE_UUID, metadata.uuid());\n-      generator.writeStringField(LOCATION, metadata.location());\n-      generator.writeNumberField(LAST_UPDATED_MILLIS, metadata.lastUpdatedMillis());\n-      if (version > 1) {\n-        generator.writeNumberField(TableMetadataParser.LAST_SEQUENCE_NUMBER, metadata.lastSequenceNumber());\n-      }\n-      generator.writeNumberField(LAST_COLUMN_ID, metadata.lastColumnId());\n \n-      generator.writeFieldName(SCHEMA);\n-      SchemaParser.toJson(metadata.schema(), generator);\n-\n-      // mimic an old writer by writing only partition-spec and not the default ID or spec list\n-      generator.writeFieldName(PARTITION_SPEC);\n-      PartitionSpecParser.toJsonFields(metadata.spec(), generator);\n-\n-      generator.writeObjectFieldStart(PROPERTIES);\n-      for (Map.Entry<String, String> keyValue : metadata.properties().entrySet()) {\n-        generator.writeStringField(keyValue.getKey(), keyValue.getValue());\n-      }\n-      generator.writeEndObject();\n-\n-      generator.writeNumberField(CURRENT_SNAPSHOT_ID,\n-          metadata.currentSnapshot() != null ? metadata.currentSnapshot().snapshotId() : -1);\n-\n-      generator.writeArrayFieldStart(SNAPSHOTS);\n-      for (Snapshot snapshot : metadata.snapshots()) {\n-        SnapshotParser.toJson(snapshot, generator);\n-      }\n-      generator.writeEndArray();\n-      // skip the snapshot log\n+  @Test\n+  public void testParserV2PartitionSpecsValidation() throws Exception {\n+    String unsupportedVersion = readTableMetadataInputFile(\"TableMetadataV2MissingPartitionSpecs.json\");\n+    AssertHelpers.assertThrows(\"Should reject v2 metadata without partition specs\",\n+        IllegalArgumentException.class, \"partition-specs must exist in format v2\",\n+        () -> TableMetadataParser.fromJson(\n+            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class))\n+    );\n+  }\n \n-      generator.writeEndObject(); // end table metadata object\n+  @Test\n+  public void testParserV2SortOrderValidation() throws Exception {\n+    String unsupportedVersion = readTableMetadataInputFile(\"TableMetadataV2MissingSortOrder.json\");\n+    AssertHelpers.assertThrows(\"Should reject v2 metadata without sort order\",\n+        IllegalArgumentException.class, \"sort-orders must exist in format v2\",\n+        () -> TableMetadataParser.fromJson(\n+            ops.io(), null, JsonUtil.mapper().readValue(unsupportedVersion, JsonNode.class))\n+    );\n+  }\n \n-      generator.flush();\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(String.format(\"Failed to write json for: %s\", metadata), e);\n-    }\n-    return writer.toString();\n+  private String readTableMetadataInputFile(String fileName) throws IOException {\n+    Path path = Paths.get(new File(\"\").getAbsolutePath(), \"src/test/testfiles\", fileName);", "originalCommit": "6e7f8aa792da9f34a7584cd43284cc0f9ce310d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxNjUyNw==", "url": "https://github.com/apache/iceberg/pull/1614#discussion_r513816527", "bodyText": "Thank you for the review! Using ClassLoader.getResource is definitely cleaner. Updated.", "author": "yyanyy", "createdAt": "2020-10-28T23:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NzM3OA=="}], "type": "inlineReview"}, {"oid": "8c9ac066f0b5eae1eb5c25f70def302fc2d7e391", "url": "https://github.com/apache/iceberg/commit/8c9ac066f0b5eae1eb5c25f70def302fc2d7e391", "message": "use resources folder for test files instead", "committedDate": "2020-10-28T23:13:23Z", "type": "commit"}]}