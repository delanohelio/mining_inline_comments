{"pr_number": 1475, "pr_title": "Fix REPLACE TABLE by preserving existing field IDs", "pr_createdAt": "2020-09-18T01:06:56Z", "pr_url": "https://github.com/apache/iceberg/pull/1475", "timeline": [{"oid": "372601db81868f40f505b9de7978733e47f0f638", "url": "https://github.com/apache/iceberg/commit/372601db81868f40f505b9de7978733e47f0f638", "message": "Fix REPLACE TABLE transactions by preserving existing field IDs.", "committedDate": "2020-09-18T00:54:44Z", "type": "commit"}, {"oid": "9728825013844188eea8ec3d3924810b1596667b", "url": "https://github.com/apache/iceberg/commit/9728825013844188eea8ec3d3924810b1596667b", "message": "Fix checkstyle in AssignFreshIds.", "committedDate": "2020-09-18T17:04:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcwNzcxMA==", "url": "https://github.com/apache/iceberg/pull/1475#discussion_r493707710", "bodyText": "I don't think it matters but it seems the computations for nextSpecId and nextOrderId are a bit different now. Previously, if partition spec list was empty, we used  INITIAL_SPEC_ID and if sort order list was empty, we used INITIAL_SORT_ORDER_ID . Now we are going to use INITIAL_SPEC_ID + 1 in that case.", "author": "aokolnychyi", "createdAt": "2020-09-23T15:57:25Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -622,32 +622,26 @@ public TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec update\n     ValidationException.check(formatVersion > 1 || PartitionSpec.hasSequentialIds(updatedPartitionSpec),\n         \"Spec does not use sequential IDs that are required in v1: %s\", updatedPartitionSpec);\n \n-    AtomicInteger nextLastColumnId = new AtomicInteger(0);\n-    Schema freshSchema = TypeUtil.assignFreshIds(updatedSchema, nextLastColumnId::incrementAndGet);\n+    AtomicInteger newLastColumnId = new AtomicInteger(lastColumnId);\n+    Schema freshSchema = TypeUtil.assignFreshIds(updatedSchema, schema, newLastColumnId::incrementAndGet);\n \n-    int nextSpecId = TableMetadata.INITIAL_SPEC_ID;\n-    for (Integer specId : specsById.keySet()) {\n-      if (nextSpecId <= specId) {\n-        nextSpecId = specId + 1;\n-      }\n-    }\n+    // determine the next spec id\n+    OptionalInt maxSpecId = specs.stream().mapToInt(PartitionSpec::specId).max();\n+    int nextSpecId = maxSpecId.orElse(TableMetadata.INITIAL_SPEC_ID) + 1;", "originalCommit": "9728825013844188eea8ec3d3924810b1596667b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcyNDAzNA==", "url": "https://github.com/apache/iceberg/pull/1475#discussion_r493724034", "bodyText": "Yes, this simplifies the logic a bit and avoids using spec id 0.", "author": "rdblue", "createdAt": "2020-09-23T16:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcwNzcxMA=="}], "type": "inlineReview"}]}