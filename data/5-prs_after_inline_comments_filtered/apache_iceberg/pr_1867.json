{"pr_number": 1867, "pr_title": "Core: Add RollingEqDeleteWriter.", "pr_createdAt": "2020-12-03T14:03:04Z", "pr_url": "https://github.com/apache/iceberg/pull/1867", "timeline": [{"oid": "416a84f1f6e691657f75f35b93a30028b97b3a54", "url": "https://github.com/apache/iceberg/commit/416a84f1f6e691657f75f35b93a30028b97b3a54", "message": "Core: Add RollingEqDeleteWriter.", "committedDate": "2020-12-03T13:59:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc3NDY3Nw==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r535774677", "bodyText": "Just curious, is there a use case for wanting data/delete files after aborting the writer?", "author": "yyanyy", "createdAt": "2020-12-04T01:45:39Z", "path": "data/src/test/java/org/apache/iceberg/io/TestBaseTaskWriter.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.RowDelta;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.data.GenericAppenderFactory;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.IcebergGenerics;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestBaseTaskWriter extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+  private final GenericRecord gRecord = GenericRecord.create(SCHEMA);\n+\n+  private OutputFileFactory fileFactory = null;\n+  private FileAppenderFactory<Record> appenderFactory = null;\n+\n+  @Parameterized.Parameters(name = \"FileFormat = {0}\")\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        {\"avro\"},\n+        {\"parquet\"}\n+    };\n+  }\n+\n+  public TestBaseTaskWriter(String fileFormat) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+  }\n+\n+  @Before\n+  public void setupTable() throws IOException {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete()); // created by table create\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+\n+    this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    this.fileFactory = new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+\n+    int firstFieldId = table.schema().findField(\"id\").fieldId();\n+    int secondFieldId = table.schema().findField(\"data\").fieldId();\n+    this.appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        new int[] {firstFieldId, secondFieldId}, table.schema(), null);\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  private Record createRecord(Integer id, String data) {\n+    return gRecord.copy(\"id\", id, \"data\", data);\n+  }\n+\n+  @Test\n+  public void testWriteZeroRecord() throws IOException {\n+    try (TestTaskWriter writer = createTaskWriter(128 * 1024 * 1024)) {\n+      writer.close();\n+\n+      WriteResult result = writer.complete();\n+      Assert.assertEquals(0, result.dataFiles().length);\n+      Assert.assertEquals(0, result.deleteFiles().length);\n+\n+      writer.close();\n+      result = writer.complete();\n+      Assert.assertEquals(0, result.dataFiles().length);\n+      Assert.assertEquals(0, result.deleteFiles().length);\n+    }\n+  }\n+\n+  @Test\n+  public void testAbort() throws IOException {\n+    List<Record> records = Lists.newArrayList();\n+    for (int i = 0; i < 2000; i++) {\n+      records.add(createRecord(i, \"aaa\"));\n+    }\n+\n+    WriteResult result;\n+    try (TestTaskWriter taskWriter = createTaskWriter(4)) {\n+      for (Record record : records) {\n+        taskWriter.write(record);\n+        taskWriter.delete(record);\n+      }\n+\n+      // Close the current opened files.\n+      taskWriter.close();\n+\n+      // Assert the current data file count.\n+      List<Path> files = Files.list(Paths.get(tableDir.getPath(), \"data\"))\n+          .filter(p -> !p.toString().endsWith(\".crc\"))\n+          .collect(Collectors.toList());\n+      Assert.assertEquals(\"Should have 4 files but the files are: \" + files, 4, files.size());\n+\n+      // Abort to clean all delete files and data files.\n+      taskWriter.abort();\n+\n+      // Complete again to get all results.\n+      result = taskWriter.complete();\n+    }\n+    Assert.assertEquals(2, result.deleteFiles().length);", "originalCommit": "416a84f1f6e691657f75f35b93a30028b97b3a54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyOTkxNA==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r535829914", "bodyText": "In real user case, there should be no one calling complete  after abort.  Here I just want to call complete to  get all the delete and data files (The complete is the only API to get those files), for asserting purpose.", "author": "openinx", "createdAt": "2020-12-04T04:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc3NDY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMTMwNA==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r536431304", "bodyText": "I guess my question would be if we actually want to leave this behavior as is, since it seems like gathering the files after the process getting aborted and files deleted would be not super useful except for testing?", "author": "yyanyy", "createdAt": "2020-12-04T22:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc3NDY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMjUzNA==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r536922534", "bodyText": "I think I agree with Yan here. The data file count assertion above ensures that there are only 4 files. So when the writer aborts, we can use the same logic to check that there are now 0 files instead of asserting that each file individually doesn't exist (below). That would be better because it doesn't seem correct for result.dataFiles() to return anything after an abort.", "author": "rdblue", "createdAt": "2020-12-06T00:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc3NDY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIxODQ5NA==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r537218494", "bodyText": "OK,  I got your points.  I agree It's better to use the files to check the existence after abort. The behavior about getting completed files after abort is not expected.\nThanks @yyanyy and @rdblue .", "author": "openinx", "createdAt": "2020-12-07T04:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc3NDY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMzAxNw==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r536923017", "bodyText": "Until support is added to handle delete files, I think it would make sense to add a precondition to check that there are no delete files here.", "author": "rdblue", "createdAt": "2020-12-06T00:42:30Z", "path": "flink/src/main/java/org/apache/iceberg/flink/sink/IcebergStreamWriter.java", "diffHunk": "@@ -62,7 +62,7 @@ public void open() {\n   @Override\n   public void prepareSnapshotPreBarrier(long checkpointId) throws Exception {\n     // close all open files and emit files to downstream committer operator\n-    for (DataFile dataFile : writer.complete()) {\n+    for (DataFile dataFile : writer.complete().dataFiles()) {", "originalCommit": "416a84f1f6e691657f75f35b93a30028b97b3a54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMzU3MA==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r536923570", "bodyText": "Actually, it looks like this change happened in quite a few places. What do you think about returning DataFile[] from a new dataFiles() method and doing the precondition check for 0 delete files in that method?\nThen we could update all of the places that call complete().dataFiles() to just dataFiles() and ensure that the check is done whenever dataFiles() is called to get the result rather than complete.", "author": "rdblue", "createdAt": "2020-12-06T00:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMzAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIyNDQ5Ng==", "url": "https://github.com/apache/iceberg/pull/1867#discussion_r537224496", "bodyText": "I like the idea about introducing a new dataFiles in TaskWriter rather than precondition check everywhere.", "author": "openinx", "createdAt": "2020-12-07T04:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMzAxNw=="}], "type": "inlineReview"}, {"oid": "323573a5f23fa15a87abf0ce2232f466abb47f4e", "url": "https://github.com/apache/iceberg/commit/323573a5f23fa15a87abf0ce2232f466abb47f4e", "message": "Avoid calling complete after abort.", "committedDate": "2020-12-07T04:08:42Z", "type": "commit"}, {"oid": "7c53cd329fbe834826986847427232c0124fd0ab", "url": "https://github.com/apache/iceberg/commit/7c53cd329fbe834826986847427232c0124fd0ab", "message": "Addressing comments.", "committedDate": "2020-12-07T04:32:55Z", "type": "commit"}]}