{"pr_number": 845, "pr_title": "Add persistent IDs to partition fields", "pr_createdAt": "2020-03-16T08:11:45Z", "pr_url": "https://github.com/apache/iceberg/pull/845", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MDk2MA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r402890960", "bodyText": "Do we want to use TypeUtil::NextID?", "author": "chenjunjiedada", "createdAt": "2020-04-03T09:52:26Z", "path": "api/src/main/java/org/apache/iceberg/PartitionSpec.java", "diffHunk": "@@ -58,14 +58,16 @@\n   private transient volatile ListMultimap<Integer, PartitionField> fieldsBySourceId = null;\n   private transient volatile Class<?>[] lazyJavaClasses = null;\n   private transient volatile List<PartitionField> fieldList = null;\n+  private final int lastAssignedFieldId;", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4ODM3OQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403188379", "bodyText": "This is tracking something different. Here, this is the highest ID assigned to any partition, so that the next ID assigned will be unique.", "author": "rdblue", "createdAt": "2020-04-03T17:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NTI1Mg==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r402895252", "bodyText": "Do we need to check fieldId is larger than 1000?", "author": "chenjunjiedada", "createdAt": "2020-04-03T09:59:32Z", "path": "api/src/main/java/org/apache/iceberg/PartitionField.java", "diffHunk": "@@ -28,11 +28,13 @@\n  */\n public class PartitionField implements Serializable {\n   private final int sourceId;\n+  private final int fieldId;\n   private final String name;\n   private final Transform<?, ?> transform;\n \n-  PartitionField(int sourceId, String name, Transform<?, ?> transform) {\n+  PartitionField(int sourceId, int fieldId, String name, Transform<?, ?> transform) {\n     this.sourceId = sourceId;\n+    this.fieldId = fieldId;", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4NjQ5Mg==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403186492", "bodyText": "I don't think so. That is a convention that we use, but not strictly required by the spec.", "author": "rdblue", "createdAt": "2020-04-03T17:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NTI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyNTI5Mw==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r402925293", "bodyText": "Can we add a unit test that has two manifests with the different specs of the same source field, and then check whether the partition field ids of manifest entries are different?", "author": "chenjunjiedada", "createdAt": "2020-04-03T10:57:51Z", "path": "core/src/test/java/org/apache/iceberg/TestMergeAppend.java", "diffHunk": "@@ -395,6 +396,47 @@ public void testChangedPartitionSpec() {\n         initialManifest, pending.manifests().get(1));\n   }\n \n+  @Test\n+  public void testUpdatePartitionSpecFieldIds() {\n+    TableMetadata base = readMetadata();\n+\n+    // build the new spec using the table's schema, which uses fresh IDs\n+    PartitionSpec newSpec = PartitionSpec.builderFor(base.schema())", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI5ODkyOA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r405298928", "bodyText": "Done. Thanks.", "author": "jun-he", "createdAt": "2020-04-08T06:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyNTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0Nzc1NA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r402947754", "bodyText": "How about the forward compatibility? Is it possible that an old reader reads the new spec? then it still parses the new spec field id start from 1000?", "author": "chenjunjiedada", "createdAt": "2020-04-03T11:45:21Z", "path": "core/src/main/java/org/apache/iceberg/PartitionSpecParser.java", "diffHunk": "@@ -147,7 +156,12 @@ private static void buildFromJsonFields(PartitionSpec.Builder builder, JsonNode\n       String transform = JsonUtil.getString(TRANSFORM, element);\n       int sourceId = JsonUtil.getInt(SOURCE_ID, element);\n \n-      builder.add(sourceId, name, transform);\n+      // partition field ids are missing in old PartitionSpec, they always auto-increment from PARTITION_DATA_ID_START\n+      if (!hasFieldId) {", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1NzkxNg==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403257916", "bodyText": "For forward-compatibility, I think that this should detect breaking changes to specs and throw an exception.\nIf IDs are removed by an older writer, then the IDs will be reassigned. That means that IDs must be assigned starting at 1000 and should have no gaps. If there are IDs, this should validate that assumption by checking that the field actually has the ID that is expected.\nWe should make a similar change on the write path: for each field, check that it's field ID is what would be assigned if it were removed by an older writer. That will prevent newer writers from creating specs that will break.", "author": "rdblue", "createdAt": "2020-04-03T19:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0Nzc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3MDAwNA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403270004", "bodyText": "Instead of making these changes here, I think that this should be verified in TableMetadata. That would accomplish the same thing, but make it easier to check the table version.", "author": "rdblue", "createdAt": "2020-04-03T19:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0Nzc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4NzMyMg==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403187322", "bodyText": "Nit: schemas use the format 1000: ts_day. That would be a bit cleaner than two sets of parens.", "author": "rdblue", "createdAt": "2020-04-03T17:45:30Z", "path": "api/src/main/java/org/apache/iceberg/PartitionField.java", "diffHunk": "@@ -60,7 +69,7 @@ public String name() {\n \n   @Override\n   public String toString() {\n-    return name + \": \" + transform + \"(\" + sourceId + \")\";\n+    return name + \" (\" + fieldId + \"): \" + transform + \"(\" + sourceId + \")\";", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDI4NA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406620284", "bodyText": "\ud83d\udc4c", "author": "jun-he", "createdAt": "2020-04-10T06:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4NzMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMDk2OQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403220969", "bodyText": "We tend to prefer using AtomicInteger instead of an int field. That way it is more clear because the calls are incrementAndGet or getAndIncrement. That would also avoid the need to start at PARTITION_DATA_ID_START - 1. You could use the constant to initialize and assign using getAndIncrement.", "author": "rdblue", "createdAt": "2020-04-03T18:24:22Z", "path": "api/src/main/java/org/apache/iceberg/PartitionSpec.java", "diffHunk": "@@ -307,11 +312,16 @@ public static Builder builderFor(Schema schema) {\n     private final Set<String> partitionNames = Sets.newHashSet();\n     private Map<Integer, PartitionField> timeFields = Maps.newHashMap();\n     private int specId = 0;\n+    private int lastAssignedFieldId = PARTITION_DATA_ID_START - 1;", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNDI1OA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r405304258", "bodyText": "I think we still have to use PARTITION_DATA_ID_START - 1 to handle the case that there is no assigned field Id. Or we can update this field as nextFieldId and then set it from PARTITION_DATA_ID_START.", "author": "jun-he", "createdAt": "2020-04-08T07:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMDk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMTk2NA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403221964", "bodyText": "Why rename this to append? What about addWithoutId or just overload add?", "author": "rdblue", "createdAt": "2020-04-03T18:25:29Z", "path": "api/src/main/java/org/apache/iceberg/PartitionSpec.java", "diffHunk": "@@ -437,24 +447,30 @@ public Builder truncate(String sourceName, int width, String targetName) {\n       checkAndAddPartitionName(targetName);\n       Types.NestedField sourceColumn = findSourceColumn(sourceName);\n       fields.add(new PartitionField(\n-          sourceColumn.fieldId(), targetName, Transforms.truncate(sourceColumn.type(), width)));\n+          sourceColumn.fieldId(), nextFieldId(), targetName, Transforms.truncate(sourceColumn.type(), width)));\n       return this;\n     }\n \n     public Builder truncate(String sourceName, int width) {\n       return truncate(sourceName, width, sourceName + \"_trunc\");\n     }\n \n-    Builder add(int sourceId, String name, String transform) {\n+    // add a partition field with an auto-increment partition field id starting from PARTITION_DATA_ID_START\n+    Builder append(int sourceId, String name, String transform) {", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNDgyMw==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r405304823", "bodyText": "Sure, change it back to add.", "author": "jun-he", "createdAt": "2020-04-08T07:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMTk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjc1Ng==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403232756", "bodyText": "I think it would be easier to follow and would result in a better error message if we put this logic inside the elements loop.\nHow about adding a counter for field IDs that are present and after the loop throwing an exception if the counter is not equal to the number of fields? Then each field would be handled independently (using has(FIELD_ID)).\nI like the idea of a check here that states there were missing field IDs.", "author": "rdblue", "createdAt": "2020-04-03T18:38:13Z", "path": "core/src/main/java/org/apache/iceberg/PartitionSpecParser.java", "diffHunk": "@@ -138,6 +140,13 @@ private static void buildFromJsonFields(PartitionSpec.Builder builder, JsonNode\n         \"Cannot parse partition spec fields, not an array: %s\", json);\n \n     Iterator<JsonNode> elements = json.elements();\n+\n+    boolean hasFieldId = false;\n+    if (elements.hasNext() && elements.next().has(FIELD_ID)) {\n+      hasFieldId = true;\n+    }\n+    elements = json.elements();", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzMjI2OQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406632269", "bodyText": "\ud83d\udc4c", "author": "jun-he", "createdAt": "2020-04-10T07:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMjc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2MjMxOQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403262319", "bodyText": "We typically validate arguments before assignments, to keep the code easier to read and maintain. Can you move the precondition above this section? Also, error messages should use sentence case so capitalize Specs. If you're referring to a variable name, then consider describing what it is instead (Partition specs instead of specs).", "author": "rdblue", "createdAt": "2020-04-03T19:26:44Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -204,8 +205,11 @@ public String toString() {\n     this.lastUpdatedMillis = lastUpdatedMillis;\n     this.lastColumnId = lastColumnId;\n     this.schema = schema;\n-    this.specs = specs;\n     this.defaultSpecId = defaultSpecId;\n+\n+    Preconditions.checkArgument(specs != null && !specs.isEmpty(), \"specs cannot be null or empty\");\n+    this.specs = specs;", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NzEyNQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403267125", "bodyText": "Spec field IDs don't need to be refreshed. freshSpec is used for two things:\n\nIf schema IDs are reassigned, then it rebuilds the spec to with the new schema\nIt sets the spec's ID to the one assigned in this method", "author": "rdblue", "createdAt": "2020-04-03T19:33:17Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -350,7 +354,8 @@ public TableMetadata updateSchema(Schema newSchema, int newLastColumnId) {\n         currentSnapshotId, snapshots, snapshotLog, addPreviousFile(file, lastUpdatedMillis));\n   }\n \n-  public TableMetadata updatePartitionSpec(PartitionSpec newPartitionSpec) {\n+  // newPartitionSpec's partition field IDs should have already been refreshed", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwOTEzNQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r405309135", "bodyText": "This comment is about the input parameter PartitionSpec newPartitionSpec, whose field ids has to be recomputed so that freshSpec does not need to take care of that extra work.\nUpdated this comment to make it clear.", "author": "jun-he", "createdAt": "2020-04-08T07:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NzEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2OTIzNQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403269235", "bodyText": "These should still be public like the other methods. Instead of making them private, they should sanity check the spec:\n\nFor a v1 table, field IDs should be assigned from 1000 and should have no gaps\nFor a v2 table or newer, all fields should have IDs", "author": "rdblue", "createdAt": "2020-04-03T19:36:01Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -350,7 +354,8 @@ public TableMetadata updateSchema(Schema newSchema, int newLastColumnId) {\n         currentSnapshotId, snapshots, snapshotLog, addPreviousFile(file, lastUpdatedMillis));\n   }\n \n-  public TableMetadata updatePartitionSpec(PartitionSpec newPartitionSpec) {\n+  // newPartitionSpec's partition field IDs should have already been refreshed\n+  TableMetadata updatePartitionSpec(PartitionSpec newPartitionSpec) {", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NjI3Mg==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406646272", "bodyText": "As this check and field ID change will be in the same PR,  do we still need to check if all fields should have IDs in newPartitionSpec?  When the check is called, the PartitionSpec must have a field ID, right?", "author": "jun-he", "createdAt": "2020-04-10T07:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg5MDQ1Nw==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406890457", "bodyText": "You're right. We just need to check that ids are sequential and starting at 1,000 if the table version is v1.", "author": "rdblue", "createdAt": "2020-04-10T18:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2OTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3NTAyNQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r403275025", "bodyText": "Can we remove the new interface and methods from this PR?\nI don't think this is needed for this PR, and I'd like to minimize the number of changes. In addition, I don't think we want to move to a model where users create a new spec and apply it to a table. I think we instead want to evolve the partition spec of a table. So this API will probably be different when we release that feature.", "author": "rdblue", "createdAt": "2020-04-03T19:43:10Z", "path": "api/src/main/java/org/apache/iceberg/UpdatePartitionSpec.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+\n+/**\n+ * API for partition spec evolution.\n+ * <p>\n+ * When committing, these changes will be applied to the current table metadata. Commit conflicts\n+ * will not be resolved and will result in a {@link CommitFailedException}.\n+ */\n+public interface UpdatePartitionSpec extends PendingUpdate<PartitionSpec> {", "originalCommit": "6d804af9f2250d05010c33a41de69da1bdb32404", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyOTI2Ng==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406629266", "bodyText": "I agree that it is better to move the update to a new PR, which addresses #281.\nThe main reason I put it here is to have additional unit tests to make sure it works as expected.\nAdditionally, I think we may support the table partition spec evolution in two ways\ntable.updatePartitionSpec()\n  .update(spec)\n  .commit();\n\ntable.updatePartitionSpec().newSpec(schema)\n  .identity(...)\n  .bucket(...)\n  ...\n  .commit();\n\nThe first approach may be used if clients want to define a spec and manage it by their codes, e.g. use defined spec object in multiple places.", "author": "jun-he", "createdAt": "2020-04-10T06:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3NTAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4NTIzOQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406885239", "bodyText": "For tests, you can use TableMetadata and commit directly:\nTableOperations ops = table.operations();\nTableMetadata base = ops.current()\nTableMetadata updated = base.updatePartitionSpec(newSpec);\nops.commit(base, updated);", "author": "rdblue", "createdAt": "2020-04-10T18:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3NTAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMTU0MA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r408601540", "bodyText": "\ud83d\udc4c", "author": "jun-he", "createdAt": "2020-04-15T06:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3NTAyNQ=="}], "type": "inlineReview"}, {"oid": "b702aff7da850d01bb7e965024ce81f61908ed65", "url": "https://github.com/apache/iceberg/commit/b702aff7da850d01bb7e965024ce81f61908ed65", "message": "Add persistent IDs to partition fields", "committedDate": "2020-04-10T07:20:00Z", "type": "commit"}, {"oid": "89d0fc62ccd9ee6e6ec51e297aed236d99addf63", "url": "https://github.com/apache/iceberg/commit/89d0fc62ccd9ee6e6ec51e297aed236d99addf63", "message": "add some unit tests", "committedDate": "2020-04-10T07:34:41Z", "type": "commit"}, {"oid": "fdbd57d168a72275139dbc29a6345e3c1406b698", "url": "https://github.com/apache/iceberg/commit/fdbd57d168a72275139dbc29a6345e3c1406b698", "message": "add additional unit tests", "committedDate": "2020-04-10T07:34:41Z", "type": "commit"}, {"oid": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "url": "https://github.com/apache/iceberg/commit/cd75cbdb05461fe1051ba635a1cf389da61d5417", "message": "address the comments", "committedDate": "2020-04-10T07:59:00Z", "type": "commit"}, {"oid": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "url": "https://github.com/apache/iceberg/commit/cd75cbdb05461fe1051ba635a1cf389da61d5417", "message": "address the comments", "committedDate": "2020-04-10T07:59:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4NDI0NA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406884244", "bodyText": "Nit: unnecessary newline.", "author": "rdblue", "createdAt": "2020-04-10T18:27:30Z", "path": "api/src/main/java/org/apache/iceberg/Transaction.java", "diffHunk": "@@ -40,6 +40,14 @@\n    */\n   UpdateSchema updateSchema();\n \n+", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4NTgxMg==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406885812", "bodyText": "Nit: we like to avoid abbreviations that aren't readable. Saving a few chars isn't worth trading readability.", "author": "rdblue", "createdAt": "2020-04-10T18:31:27Z", "path": "core/src/main/java/org/apache/iceberg/PartitionSpecParser.java", "diffHunk": "@@ -138,6 +140,7 @@ private static void buildFromJsonFields(PartitionSpec.Builder builder, JsonNode\n         \"Cannot parse partition spec fields, not an array: %s\", json);\n \n     Iterator<JsonNode> elements = json.elements();\n+    int fieldIdCnt = 0;", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4NjI3OA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406886278", "bodyText": "How about \"Cannot parse spec with missing field IDs: %s missing of %s fields\"?", "author": "rdblue", "createdAt": "2020-04-10T18:32:30Z", "path": "core/src/main/java/org/apache/iceberg/PartitionSpecParser.java", "diffHunk": "@@ -147,7 +150,17 @@ private static void buildFromJsonFields(PartitionSpec.Builder builder, JsonNode\n       String transform = JsonUtil.getString(TRANSFORM, element);\n       int sourceId = JsonUtil.getInt(SOURCE_ID, element);\n \n-      builder.add(sourceId, name, transform);\n+      // partition field ids are missing in old PartitionSpec, they always auto-increment from PARTITION_DATA_ID_START\n+      if (element.has(FIELD_ID)) {\n+        builder.add(sourceId, JsonUtil.getInt(FIELD_ID, element), name, transform);\n+        fieldIdCnt++;\n+      }  else {\n+        builder.add(sourceId, name, transform);\n+      }\n     }\n+\n+    Preconditions.checkArgument(fieldIdCnt == 0 || fieldIdCnt == json.size(),\n+        \"Parsed an invalid PartitionSpec Json. Some of its fields (%s/%s) miss field IDs.\",", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4NzQ0NQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406887445", "bodyText": "Can you revert these unnecessary changes? The order of assignments changed and there's an extra newline. These non-functional changes can cause git conflicts, so we try to avoid them.", "author": "rdblue", "createdAt": "2020-04-10T18:35:18Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -208,8 +210,9 @@ public String toString() {\n     this.lastUpdatedMillis = lastUpdatedMillis;\n     this.lastColumnId = lastColumnId;\n     this.schema = schema;\n-    this.specs = specs;\n     this.defaultSpecId = defaultSpecId;\n+    this.specs = specs;\n+", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4Nzc5NQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406887795", "bodyText": "Why is this no longer public?", "author": "rdblue", "createdAt": "2020-04-10T18:36:08Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -487,8 +491,9 @@ public TableMetadata removeSnapshotLogEntries(Set<Long> snapshotIds) {\n         currentSnapshotId, snapshots, newSnapshotLog, addPreviousFile(file, lastUpdatedMillis));\n   }\n \n-  public TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec updatedPartitionSpec,\n-                                        Map<String, String> updatedProperties) {\n+  // updatedPartitionSpec's partition field IDs should have already been refreshed\n+  TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec updatedPartitionSpec,", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MDc1Mw==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r408580753", "bodyText": "@rdblue  thanks for the comment.\nI am thinking to expose those functionalities (PartitionSpecUpdate or buildReplacement) over Table and UpdatePartitionSpec public interface. So we can limit their access to be package/default level.\nI will change them back to public in the PR and we may limit their access in the partition spec evolution PR.", "author": "jun-he", "createdAt": "2020-04-15T04:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4Nzc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4OTIyMw==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406889223", "bodyText": "#903 added formatVersion to metadata, so now we can add a validation here when the table is v1 that the spec IDs are assigned as expected:\nValidationException.check(formatVersion > 1 || hasSequentialIds(spec),\n    \"Spec does not use sequential IDs that are required in v1: %s\", spec);", "author": "rdblue", "createdAt": "2020-04-10T18:39:39Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -352,6 +355,7 @@ public TableMetadata updateSchema(Schema newSchema, int newLastColumnId) {\n         currentSnapshotId, snapshots, snapshotLog, addPreviousFile(file, lastUpdatedMillis));\n   }\n \n+  // Input newPartitionSpec's partition field IDs should have already been recomputed", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4OTQ3NA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406889474", "bodyText": "We should add a validation for format v1 here as well.", "author": "rdblue", "createdAt": "2020-04-10T18:40:08Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -487,8 +491,9 @@ public TableMetadata removeSnapshotLogEntries(Set<Long> snapshotIds) {\n         currentSnapshotId, snapshots, newSnapshotLog, addPreviousFile(file, lastUpdatedMillis));\n   }\n \n-  public TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec updatedPartitionSpec,\n-                                        Map<String, String> updatedProperties) {\n+  // updatedPartitionSpec's partition field IDs should have already been refreshed\n+  TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec updatedPartitionSpec,\n+                                 Map<String, String> updatedProperties) {", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4OTgxNA==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r406889814", "bodyText": "As I mentioned earlier, I think this should continue using the updatePartitionSpec method so that we can add a public API for this in a separate commit.", "author": "rdblue", "createdAt": "2020-04-10T18:40:58Z", "path": "core/src/test/java/org/apache/iceberg/TestMergeAppend.java", "diffHunk": "@@ -373,10 +374,10 @@ public void testChangedPartitionSpec() {\n         .bucket(\"id\", 4)\n         .build();\n \n-    // commit the new partition spec to the table manually\n-    table.ops().commit(base, base.updatePartitionSpec(newSpec));\n+    // commit the new partition spec to the table\n+    table.updatePartitionSpec().update(newSpec).commit();", "originalCommit": "cd75cbdb05461fe1051ba635a1cf389da61d5417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxODg3Mg==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r408618872", "bodyText": "\ud83d\udc4c", "author": "jun-he", "createdAt": "2020-04-15T06:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4OTgxNA=="}], "type": "inlineReview"}, {"oid": "9a176d2d2a7120597da91a6afde66cae3e2f097d", "url": "https://github.com/apache/iceberg/commit/9a176d2d2a7120597da91a6afde66cae3e2f097d", "message": "address the comments", "committedDate": "2020-04-15T05:23:55Z", "type": "commit"}, {"oid": "c5b2221ce3b811dcf4494cca57f7ad4aae46cd36", "url": "https://github.com/apache/iceberg/commit/c5b2221ce3b811dcf4494cca57f7ad4aae46cd36", "message": "Refactor the code and remove partition spec evolution logic", "committedDate": "2020-04-15T06:55:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEwMjc0MQ==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r409102741", "bodyText": "Nit: unnecessary newline.", "author": "rdblue", "createdAt": "2020-04-15T20:06:48Z", "path": "core/src/test/java/org/apache/iceberg/TestMergeAppend.java", "diffHunk": "@@ -648,4 +649,98 @@ public void testInvalidAppendManifest() throws IOException {\n             .appendManifest(manifestWithDeletedFiles)\n             .commit());\n   }\n+", "originalCommit": "c5b2221ce3b811dcf4494cca57f7ad4aae46cd36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwOTYzMw==", "url": "https://github.com/apache/iceberg/pull/845#discussion_r409209633", "bodyText": "Thanks. Will remove it in #922.", "author": "jun-he", "createdAt": "2020-04-16T00:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEwMjc0MQ=="}], "type": "inlineReview"}]}