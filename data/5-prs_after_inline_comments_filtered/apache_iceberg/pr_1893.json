{"pr_number": 1893, "pr_title": "Flink: Support filter pushdown in IcebergTableSource", "pr_createdAt": "2020-12-09T02:33:58Z", "pr_url": "https://github.com/apache/iceberg/pull/1893", "timeline": [{"oid": "7daffa6ccf6b7889faa7ef8c14193d9de206786c", "url": "https://github.com/apache/iceberg/commit/7daffa6ccf6b7889faa7ef8c14193d9de206786c", "message": "fix some issues, and add some test case", "committedDate": "2021-01-16T11:39:23Z", "type": "forcePushed"}, {"oid": "d33aa4981701d5ee5cea2995de2dfe2775e9ffff", "url": "https://github.com/apache/iceberg/commit/d33aa4981701d5ee5cea2995de2dfe2775e9ffff", "message": "fix some issues, and add some test case", "committedDate": "2021-01-16T14:15:19Z", "type": "forcePushed"}, {"oid": "217d05955b5719813d72c00aea8cf6e11eda38a9", "url": "https://github.com/apache/iceberg/commit/217d05955b5719813d72c00aea8cf6e11eda38a9", "message": "fix some issues, and add some test case", "committedDate": "2021-01-16T14:33:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDU4NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558990584", "bodyText": "These casts are unnecessary.", "author": "rdblue", "createdAt": "2021-01-16T18:13:27Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Pair<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Pair.of(\"field1\", 1),\n+      Pair.of(\"field2\", 2L),\n+      Pair.of(\"field3\", 3F),\n+      Pair.of(\"field4\", 4D),\n+      Pair.of(\"field5\", \"iceberg\"),\n+      Pair.of(\"field6\", true),\n+      Pair.of(\"field7\", new byte[] {'a', 'b'}),\n+      Pair.of(\"field8\", BigDecimal.valueOf(10.12)),\n+      Pair.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Pair.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Pair.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Pair.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10.12), BigDecimal.valueOf(10.12));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    for (Pair<String, Object> pair : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.equal(pair.first(), pair.second());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(pair.first()).isEqual(Expressions.lit(pair.second()))));\n+      Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+      assertPredicatesMatch(expected, actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(pair.second()).isEqual(Expressions.$(pair.first()))));\n+      Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+      assertPredicatesMatch(expected, actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.isNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    assertPredicatesMatch(expected, actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+    assertPredicatesMatch(expected, actual1.get());\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    for (Pair<String, Object> pair : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.notEqual(pair.first(), pair.second());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(pair.first()).isNotEqual(Expressions.lit(pair.second()))));\n+      Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+      assertPredicatesMatch(expected, actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(pair.second()).isNotEqual(Expressions.$(pair.first()))));\n+      Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+      assertPredicatesMatch(expected, actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testNotEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.notNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isNotEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    assertPredicatesMatch(expected, actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isNotEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+    assertPredicatesMatch(expected, actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreater(Expressions.lit(1))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    assertPredicatesMatch(expected, actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLess(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+    assertPredicatesMatch(expected, actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreaterOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    assertPredicatesMatch(expected, actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLessOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+    assertPredicatesMatch(expected, actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLess(Expressions.lit(1))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    assertPredicatesMatch(expected, actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreater(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+    assertPredicatesMatch(expected, actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLessOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    assertPredicatesMatch(expected, actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreaterOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(\"Conversion should succeed\", actual1.isPresent());\n+    assertPredicatesMatch(expected, actual1.get());\n+  }\n+\n+  @Test\n+  public void testIsNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.isNull(\"field1\");\n+    assertPredicatesMatch(expected, actual.get());\n+  }\n+\n+  @Test\n+  public void testIsNotNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNotNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.notNull(\"field1\");\n+    assertPredicatesMatch(expected, actual.get());\n+  }\n+\n+  @Test\n+  public void testAnd() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).and(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    And and = (And) actual.get();\n+    And expected = (And) org.apache.iceberg.expressions.Expressions.and(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    assertPredicatesMatch(expected.left(), and.left());\n+    assertPredicatesMatch(expected.right(), and.right());\n+  }\n+\n+  @Test\n+  public void testOr() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).or(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    Or or = (Or) actual.get();\n+    Or expected = (Or) org.apache.iceberg.expressions.Expressions.or(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    assertPredicatesMatch(expected.left(), or.left());\n+    assertPredicatesMatch(expected.right(), or.right());\n+  }\n+\n+  @Test\n+  public void testNot() {\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.NOT, Expressions.$(\"field1\").isEqual(Expressions.lit(1))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n+    Not not = (Not) actual.get();\n+    Not expected = (Not) org.apache.iceberg.expressions.Expressions.not(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1));\n+\n+    Assert.assertEquals(\"Predicate operation should match\", expected.op(), not.op());\n+    assertPredicatesMatch((UnboundPredicate<?>) expected.child(), (UnboundPredicate<?>) not.child());", "originalCommit": "217d05955b5719813d72c00aea8cf6e11eda38a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MTI5Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558991293", "bodyText": "Style: this line should wrap arguments, not the method call. Can you change these cases to this style?\n    Assert.assertArrayEquals(\"Should produce the expected record\",\n        new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));", "author": "rdblue", "createdAt": "2021-01-16T18:15:39Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +92,584 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n-    Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n+    Assert.assertTrue(\"Explain should contain LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected records\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    Assert.assertEquals(\"Should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"Should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n-    expectedList.add(new Object[] {1, \"a\"});\n-    expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedList.add(new Object[] {2, \"b\", 20.0});\n+    expectedList.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected records\", expectedList.toArray(), resultExceed.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should have 1 record\", 1, mixedResult.size());\n+    Assert.assertArrayEquals(\"Should produce the expected records\",\n+        new Object[] {1, \"iceberg\", 10.0}, mixedResult.get(0));\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualNull() {\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlEqualNull);\n+    Assert.assertEquals(\"Should have 0 record\", 0, result.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLeft.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLeft.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\", 20.0});\n+    expectedNE.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedNE.toArray(), resultNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqualNull() {\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultNE = sql(sqlNotEqualNull);\n+    Assert.assertEquals(\"Should have 0 records\", 0, resultNE.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'iceberg' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"iceberg\\\"\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultAnd.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expected = \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"iceberg\\\")\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expected, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainOr.contains(expectedFilter));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedOR.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedOR.toArray(), resultOr.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\", 20.0});\n+    expectedGT.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGT.toArray(), resultGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanNull() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE data > null \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainGT.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanLiteralOnLeft() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE 3 > id \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 3\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedGT.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGT.toArray(), resultGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\", 20.0});\n+    expectedGTE.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGTE.toArray(), resultGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualNull() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE data >= null \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainGTE.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualLiteralOnLeft() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE 2 >= id \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedGTE.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGTE.toArray(), resultGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLT.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanNull() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE data < null \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainLT.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanLiteralOnLeft() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE 2 < id \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultLT.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLTE.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualNull() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE data <= null \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainLTE.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualLiteralOnLeft() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE 3 <= id  \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 3\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultLTE.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"id\\\") == 2)\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainIN.contains(expectedFilter));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultIN.size());\n+\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedIN.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedIN.toArray(), resultIN.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownInNull() {\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE data IN ('iceberg',NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainInNull.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlInNull);\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotIn() {\n+    String sqlNotIn = String.format(\"SELECT * FROM %s WHERE id NOT IN (3,2) \", TABLE_NAME);\n+    String explainNotIn = getTableEnv().explainSql(sqlNotIn);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 3,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotIn.contains(expectedFilter));\n+\n+    List<Object[]> resultNotIn = sql(sqlNotIn);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNotIn.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultNotIn.get(0));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expectedScan = \"(ref(name=\\\"id\\\") != 3 and ref(name=\\\"id\\\") != 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedScan, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotInNull() {\n+    String sqlNotInNull = String.format(\"SELECT * FROM %s WHERE id NOT IN (1,2,NULL) \", TABLE_NAME);\n+    String explainNotInNull = getTableEnv().explainSql(sqlNotInNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNotInNull.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultGT = sql(sqlNotInNull);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNotNull() {\n+    String sqlNotNull = String.format(\"SELECT * FROM %s WHERE data IS NOT NULL\", TABLE_NAME);\n+    String explainNotNull = getTableEnv().explainSql(sqlNotNull);\n+    String expectedFilter = \"not_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNotNull = sql(sqlNotNull);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultNotNull.size());\n+\n+    List<Object[]> expected = Lists.newArrayList();\n+    expected.add(new Object[] {1, \"iceberg\", 10.0});\n+    expected.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expected.toArray(), resultNotNull.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNull() {\n+    String sqlNull = String.format(\"SELECT * FROM %s WHERE data IS  NULL\", TABLE_NAME);\n+    String explainNull = getTableEnv().explainSql(sqlNull);\n+    String expectedFilter = \"is_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNull = sql(sqlNull);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNull.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultNull.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNot() {\n+    String sqlNot = String.format(\"SELECT * FROM %s WHERE NOT (id = 1 OR id = 2 ) \", TABLE_NAME);\n+    String explainNot = getTableEnv().explainSql(sqlNot);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNot.contains(expectedFilter));\n+\n+    List<Object[]> resultNot = sql(sqlNot);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNot.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultNot.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    expectedFilter = \"(ref(name=\\\"id\\\") != 1 and ref(name=\\\"id\\\") != 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownBetween() {\n+    String sqlBetween = String.format(\"SELECT * FROM %s WHERE id BETWEEN 1 AND 2 \", TABLE_NAME);\n+    String explainBetween = getTableEnv().explainSql(sqlBetween);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 1,ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultBetween = sql(sqlBetween);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultBetween.size());\n+\n+    List<Object[]> expectedBetween = Lists.newArrayList();\n+    expectedBetween.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedBetween.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedBetween.toArray(), resultBetween.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expected = \"(ref(name=\\\"id\\\") >= 1 and ref(name=\\\"id\\\") <= 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expected, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotBetween() {\n+    String sqlNotBetween = String.format(\"SELECT * FROM %s WHERE id  NOT BETWEEN 2 AND 3 \", TABLE_NAME);\n+    String explainNotBetween = getTableEnv().explainSql(sqlNotBetween);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") < 2 or ref(name=\\\"id\\\") > 3)\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultNotBetween = sql(sqlNotBetween);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNotBetween.size());\n+    Assert.assertArrayEquals(\"the not between Should produce the expected record\", resultNotBetween.get(0),\n+        new Object[] {1, \"iceberg\", 10.0});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLike() {\n+    String sqlLike = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE 'ice%' \";\n+    String explainLike = getTableEnv().explainSql(sqlLike);\n+    String expectedFilter = \"ref(name=\\\"data\\\") startsWith \\\"\\\"ice\\\"\\\"\";\n+    Assert.assertTrue(\"the like sql Explain should contain the push down filter\", explainLike.contains(expectedFilter));\n+\n+    sqlLike = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE 'ice%%' \";\n+    List<Object[]> resultLike = sql(sqlLike);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert.assertArrayEquals(\"The like result should produce the expected record\",\n+        new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterNotPushDownLike() {\n+    String sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%i' \";\n+    String explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%%i' \";\n+    List<Object[]> resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 0, resultLike.size());\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%i%' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%%i%%' \";\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%ice%g' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%%ice%%g' \";\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%%' \";\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultLike.size());\n+    List<Object[]> expectedRecords = Lists.newArrayList();\n+    expectedRecords.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedRecords.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedRecords.toArray(), resultLike.toArray());\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE 'iceber_' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));", "originalCommit": "217d05955b5719813d72c00aea8cf6e11eda38a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MTQ4NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558991485", "bodyText": "By the way, these aren't blockers, but it is good to fix them as long as there are other things that need to be fixed, like the unparameterized use of parameterized types.", "author": "rdblue", "createdAt": "2021-01-16T18:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MTI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MTQzNg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r559171436", "bodyText": "I updated all", "author": "zhangjun0x01", "createdAt": "2021-01-17T12:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5NTkxMw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558995913", "bodyText": "I think this is missing a case for i%g. It has a case for %ice%g, but I think it should test both.", "author": "rdblue", "createdAt": "2021-01-16T18:30:01Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +92,584 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n-    Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n+    Assert.assertTrue(\"Explain should contain LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected records\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    Assert.assertEquals(\"Should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"Should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n-    expectedList.add(new Object[] {1, \"a\"});\n-    expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedList.add(new Object[] {2, \"b\", 20.0});\n+    expectedList.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected records\", expectedList.toArray(), resultExceed.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should have 1 record\", 1, mixedResult.size());\n+    Assert.assertArrayEquals(\"Should produce the expected records\",\n+        new Object[] {1, \"iceberg\", 10.0}, mixedResult.get(0));\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualNull() {\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlEqualNull);\n+    Assert.assertEquals(\"Should have 0 record\", 0, result.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLeft.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLeft.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\", 20.0});\n+    expectedNE.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedNE.toArray(), resultNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqualNull() {\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultNE = sql(sqlNotEqualNull);\n+    Assert.assertEquals(\"Should have 0 records\", 0, resultNE.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'iceberg' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"iceberg\\\"\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultAnd.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expected = \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"iceberg\\\")\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expected, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainOr.contains(expectedFilter));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedOR.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedOR.toArray(), resultOr.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\", 20.0});\n+    expectedGT.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGT.toArray(), resultGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanNull() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE data > null \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainGT.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanLiteralOnLeft() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE 3 > id \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 3\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedGT.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGT.toArray(), resultGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\", 20.0});\n+    expectedGTE.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGTE.toArray(), resultGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualNull() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE data >= null \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainGTE.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualLiteralOnLeft() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE 2 >= id \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedGTE.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGTE.toArray(), resultGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLT.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanNull() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE data < null \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainLT.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanLiteralOnLeft() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE 2 < id \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultLT.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLTE.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualNull() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE data <= null \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainLTE.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualLiteralOnLeft() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE 3 <= id  \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 3\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultLTE.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"id\\\") == 2)\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainIN.contains(expectedFilter));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultIN.size());\n+\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedIN.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedIN.toArray(), resultIN.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownInNull() {\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE data IN ('iceberg',NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainInNull.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlInNull);\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotIn() {\n+    String sqlNotIn = String.format(\"SELECT * FROM %s WHERE id NOT IN (3,2) \", TABLE_NAME);\n+    String explainNotIn = getTableEnv().explainSql(sqlNotIn);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 3,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotIn.contains(expectedFilter));\n+\n+    List<Object[]> resultNotIn = sql(sqlNotIn);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNotIn.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultNotIn.get(0));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expectedScan = \"(ref(name=\\\"id\\\") != 3 and ref(name=\\\"id\\\") != 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedScan, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotInNull() {\n+    String sqlNotInNull = String.format(\"SELECT * FROM %s WHERE id NOT IN (1,2,NULL) \", TABLE_NAME);\n+    String explainNotInNull = getTableEnv().explainSql(sqlNotInNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNotInNull.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultGT = sql(sqlNotInNull);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNotNull() {\n+    String sqlNotNull = String.format(\"SELECT * FROM %s WHERE data IS NOT NULL\", TABLE_NAME);\n+    String explainNotNull = getTableEnv().explainSql(sqlNotNull);\n+    String expectedFilter = \"not_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNotNull = sql(sqlNotNull);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultNotNull.size());\n+\n+    List<Object[]> expected = Lists.newArrayList();\n+    expected.add(new Object[] {1, \"iceberg\", 10.0});\n+    expected.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expected.toArray(), resultNotNull.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNull() {\n+    String sqlNull = String.format(\"SELECT * FROM %s WHERE data IS  NULL\", TABLE_NAME);\n+    String explainNull = getTableEnv().explainSql(sqlNull);\n+    String expectedFilter = \"is_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNull = sql(sqlNull);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNull.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultNull.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNot() {\n+    String sqlNot = String.format(\"SELECT * FROM %s WHERE NOT (id = 1 OR id = 2 ) \", TABLE_NAME);\n+    String explainNot = getTableEnv().explainSql(sqlNot);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNot.contains(expectedFilter));\n+\n+    List<Object[]> resultNot = sql(sqlNot);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNot.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultNot.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    expectedFilter = \"(ref(name=\\\"id\\\") != 1 and ref(name=\\\"id\\\") != 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownBetween() {\n+    String sqlBetween = String.format(\"SELECT * FROM %s WHERE id BETWEEN 1 AND 2 \", TABLE_NAME);\n+    String explainBetween = getTableEnv().explainSql(sqlBetween);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 1,ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultBetween = sql(sqlBetween);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultBetween.size());\n+\n+    List<Object[]> expectedBetween = Lists.newArrayList();\n+    expectedBetween.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedBetween.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedBetween.toArray(), resultBetween.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expected = \"(ref(name=\\\"id\\\") >= 1 and ref(name=\\\"id\\\") <= 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expected, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotBetween() {\n+    String sqlNotBetween = String.format(\"SELECT * FROM %s WHERE id  NOT BETWEEN 2 AND 3 \", TABLE_NAME);\n+    String explainNotBetween = getTableEnv().explainSql(sqlNotBetween);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") < 2 or ref(name=\\\"id\\\") > 3)\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultNotBetween = sql(sqlNotBetween);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNotBetween.size());\n+    Assert.assertArrayEquals(\"the not between Should produce the expected record\", resultNotBetween.get(0),\n+        new Object[] {1, \"iceberg\", 10.0});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLike() {\n+    String sqlLike = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE 'ice%' \";\n+    String explainLike = getTableEnv().explainSql(sqlLike);\n+    String expectedFilter = \"ref(name=\\\"data\\\") startsWith \\\"\\\"ice\\\"\\\"\";\n+    Assert.assertTrue(\"the like sql Explain should contain the push down filter\", explainLike.contains(expectedFilter));\n+\n+    sqlLike = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE 'ice%%' \";\n+    List<Object[]> resultLike = sql(sqlLike);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert.assertArrayEquals(\"The like result should produce the expected record\",\n+        new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterNotPushDownLike() {", "originalCommit": "217d05955b5719813d72c00aea8cf6e11eda38a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTE3MTYyOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r559171629", "bodyText": "I add the test case", "author": "zhangjun0x01", "createdAt": "2021-01-17T12:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5NTkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwMTk5NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r559001995", "bodyText": "I don't see the function DOUBLE documented in Flink's built-in functions. I think what you want is to use CAST instead: CAST('NaN' AS DOUBLE).", "author": "rdblue", "createdAt": "2021-01-16T18:47:52Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +92,584 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n-    Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n+    Assert.assertTrue(\"Explain should contain LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected records\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    Assert.assertEquals(\"Should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"Should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n-    expectedList.add(new Object[] {1, \"a\"});\n-    expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedList.add(new Object[] {2, \"b\", 20.0});\n+    expectedList.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected records\", expectedList.toArray(), resultExceed.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should have 1 record\", 1, mixedResult.size());\n+    Assert.assertArrayEquals(\"Should produce the expected records\",\n+        new Object[] {1, \"iceberg\", 10.0}, mixedResult.get(0));\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualNull() {\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlEqualNull);\n+    Assert.assertEquals(\"Should have 0 record\", 0, result.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLeft.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLeft.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\", 20.0});\n+    expectedNE.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedNE.toArray(), resultNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqualNull() {\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultNE = sql(sqlNotEqualNull);\n+    Assert.assertEquals(\"Should have 0 records\", 0, resultNE.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'iceberg' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"iceberg\\\"\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultAnd.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expected = \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"iceberg\\\")\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expected, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainOr.contains(expectedFilter));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedOR.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedOR.toArray(), resultOr.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\", 20.0});\n+    expectedGT.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGT.toArray(), resultGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanNull() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE data > null \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainGT.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanLiteralOnLeft() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE 3 > id \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 3\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedGT.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGT.toArray(), resultGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\", 20.0});\n+    expectedGTE.add(new Object[] {3, null, 30.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGTE.toArray(), resultGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualNull() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE data >= null \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainGTE.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualLiteralOnLeft() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE 2 >= id \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedGTE.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedGTE.toArray(), resultGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLT.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanNull() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE data < null \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainLT.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanLiteralOnLeft() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE 2 < id \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultLT.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 1\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLTE.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualNull() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE data <= null \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\", explainLTE.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualLiteralOnLeft() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE 3 <= id  \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 3\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultLTE.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"id\\\") == 2)\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainIN.contains(expectedFilter));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultIN.size());\n+\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedIN.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedIN.toArray(), resultIN.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownInNull() {\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE data IN ('iceberg',NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainInNull.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlInNull);\n+    Assert.assertEquals(\"Should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, result.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotIn() {\n+    String sqlNotIn = String.format(\"SELECT * FROM %s WHERE id NOT IN (3,2) \", TABLE_NAME);\n+    String explainNotIn = getTableEnv().explainSql(sqlNotIn);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 3,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotIn.contains(expectedFilter));\n+\n+    List<Object[]> resultNotIn = sql(sqlNotIn);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNotIn.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultNotIn.get(0));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expectedScan = \"(ref(name=\\\"id\\\") != 3 and ref(name=\\\"id\\\") != 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedScan, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotInNull() {\n+    String sqlNotInNull = String.format(\"SELECT * FROM %s WHERE id NOT IN (1,2,NULL) \", TABLE_NAME);\n+    String explainNotInNull = getTableEnv().explainSql(sqlNotInNull);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNotInNull.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultGT = sql(sqlNotInNull);\n+    Assert.assertEquals(\"Should have 0 record\", 0, resultGT.size());\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNotNull() {\n+    String sqlNotNull = String.format(\"SELECT * FROM %s WHERE data IS NOT NULL\", TABLE_NAME);\n+    String explainNotNull = getTableEnv().explainSql(sqlNotNull);\n+    String expectedFilter = \"not_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNotNull = sql(sqlNotNull);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultNotNull.size());\n+\n+    List<Object[]> expected = Lists.newArrayList();\n+    expected.add(new Object[] {1, \"iceberg\", 10.0});\n+    expected.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expected.toArray(), resultNotNull.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNull() {\n+    String sqlNull = String.format(\"SELECT * FROM %s WHERE data IS  NULL\", TABLE_NAME);\n+    String explainNull = getTableEnv().explainSql(sqlNull);\n+    String expectedFilter = \"is_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNull = sql(sqlNull);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNull.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultNull.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNot() {\n+    String sqlNot = String.format(\"SELECT * FROM %s WHERE NOT (id = 1 OR id = 2 ) \", TABLE_NAME);\n+    String explainNot = getTableEnv().explainSql(sqlNot);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNot.contains(expectedFilter));\n+\n+    List<Object[]> resultNot = sql(sqlNot);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNot.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", new Object[] {3, null, 30.0}, resultNot.get(0));\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    expectedFilter = \"(ref(name=\\\"id\\\") != 1 and ref(name=\\\"id\\\") != 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownBetween() {\n+    String sqlBetween = String.format(\"SELECT * FROM %s WHERE id BETWEEN 1 AND 2 \", TABLE_NAME);\n+    String explainBetween = getTableEnv().explainSql(sqlBetween);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 1,ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultBetween = sql(sqlBetween);\n+    Assert.assertEquals(\"Should have 2 record\", 2, resultBetween.size());\n+\n+    List<Object[]> expectedBetween = Lists.newArrayList();\n+    expectedBetween.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedBetween.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedBetween.toArray(), resultBetween.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    String expected = \"(ref(name=\\\"id\\\") >= 1 and ref(name=\\\"id\\\") <= 2)\";\n+    Assert.assertEquals(\"Should contain the push down filter\", expected, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotBetween() {\n+    String sqlNotBetween = String.format(\"SELECT * FROM %s WHERE id  NOT BETWEEN 2 AND 3 \", TABLE_NAME);\n+    String explainNotBetween = getTableEnv().explainSql(sqlNotBetween);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") < 2 or ref(name=\\\"id\\\") > 3)\";\n+    Assert.assertTrue(\"Explain should contain the push down filter\", explainNotBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultNotBetween = sql(sqlNotBetween);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultNotBetween.size());\n+    Assert.assertArrayEquals(\"the not between Should produce the expected record\", resultNotBetween.get(0),\n+        new Object[] {1, \"iceberg\", 10.0});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLike() {\n+    String sqlLike = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE 'ice%' \";\n+    String explainLike = getTableEnv().explainSql(sqlLike);\n+    String expectedFilter = \"ref(name=\\\"data\\\") startsWith \\\"\\\"ice\\\"\\\"\";\n+    Assert.assertTrue(\"the like sql Explain should contain the push down filter\", explainLike.contains(expectedFilter));\n+\n+    sqlLike = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE 'ice%%' \";\n+    List<Object[]> resultLike = sql(sqlLike);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert.assertArrayEquals(\"The like result should produce the expected record\",\n+        new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should contain the push down filter\", expectedFilter, lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterNotPushDownLike() {\n+    String sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%i' \";\n+    String explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%%i' \";\n+    List<Object[]> resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 0, resultLike.size());\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%i%' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%%i%%' \";\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%ice%g' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%%ice%%g' \";\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE '%%' \";\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 2 records\", 2, resultLike.size());\n+    List<Object[]> expectedRecords = Lists.newArrayList();\n+    expectedRecords.add(new Object[] {1, \"iceberg\", 10.0});\n+    expectedRecords.add(new Object[] {2, \"b\", 20.0});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", expectedRecords.toArray(), resultLike.toArray());\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+\n+    sqlNoPushDown = \"SELECT * FROM  \" + TABLE_NAME + \"  WHERE data LIKE 'iceber_' \";\n+    explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+    resultLike = sql(sqlNoPushDown);\n+    Assert.assertEquals(\"Should have 1 record\", 1, resultLike.size());\n+    Assert\n+        .assertArrayEquals(\"Should produce the expected record\", new Object[] {1, \"iceberg\", 10.0}, resultLike.get(0));\n+    Assert.assertEquals(\"Should not push down a filter\", Expressions.alwaysTrue(), lastScanEvent.filter());\n+  }\n+\n+  @Test\n+  public void testFilterPushDown2Literal() {\n+    String sql2Literal = String.format(\"SELECT * FROM %s WHERE 1 > 0 \", TABLE_NAME);\n+    String explain2Literal = getTableEnv().explainSql(sql2Literal);\n+    Assert.assertFalse(\"Explain should not contain FilterPushDown\",\n+        explain2Literal.contains(expectedFilterPushDownExplain));\n+    Assert.assertNull(\"Should not push down a filter\", lastScanEvent);\n+  }\n+\n+  /**\n+   * NaN is not supported by flink now, so we add the test case to assert the parse error, when we upgrade the flink\n+   * that supports NaN, we will delele the method, and add some test case to test NaN.\n+   */\n+  @Test\n+  public void testSqlParseError() {\n+    String sqlParseErrorEqual = String.format(\"SELECT * FROM %s WHERE d = DOUBLE('NaN') \", TABLE_NAME);", "originalCommit": "217d05955b5719813d72c00aea8cf6e11eda38a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4981f606c3870f425a76c2cb5a78caced7dadd9e", "url": "https://github.com/apache/iceberg/commit/4981f606c3870f425a76c2cb5a78caced7dadd9e", "message": "add filter push down", "committedDate": "2021-01-17T02:45:56Z", "type": "commit"}, {"oid": "f2e493ab197e457faf46160f60022d69ac935eab", "url": "https://github.com/apache/iceberg/commit/f2e493ab197e457faf46160f60022d69ac935eab", "message": "fix some issue", "committedDate": "2021-01-17T02:45:56Z", "type": "commit"}, {"oid": "fbb0f3b09985b7acda4f68aef51bb4f5a776a2c8", "url": "https://github.com/apache/iceberg/commit/fbb0f3b09985b7acda4f68aef51bb4f5a776a2c8", "message": "update  Expression to Optional", "committedDate": "2021-01-17T02:45:56Z", "type": "commit"}, {"oid": "5a573f28aab03c949533d1fc8a9086d6d797730c", "url": "https://github.com/apache/iceberg/commit/5a573f28aab03c949533d1fc8a9086d6d797730c", "message": "fix some bugs and add test case", "committedDate": "2021-01-17T02:45:57Z", "type": "commit"}, {"oid": "f94ebaaa3269bab96fe805e78642b8e68740ec2d", "url": "https://github.com/apache/iceberg/commit/f94ebaaa3269bab96fe805e78642b8e68740ec2d", "message": "fix some issues", "committedDate": "2021-01-17T02:45:57Z", "type": "commit"}, {"oid": "c8bd0d921b1b7dcfa3ce7ecb32c7b0b82733cf24", "url": "https://github.com/apache/iceberg/commit/c8bd0d921b1b7dcfa3ce7ecb32c7b0b82733cf24", "message": "do not format sql when args length is 0", "committedDate": "2021-01-17T02:45:57Z", "type": "commit"}, {"oid": "28980d1195880bb34ecdef14d1acf4218902463d", "url": "https://github.com/apache/iceberg/commit/28980d1195880bb34ecdef14d1acf4218902463d", "message": "fix some issues", "committedDate": "2021-01-17T02:45:57Z", "type": "commit"}, {"oid": "d8c39aaf0ef68a57f4ca9ec0845ce15dbfed67e2", "url": "https://github.com/apache/iceberg/commit/d8c39aaf0ef68a57f4ca9ec0845ce15dbfed67e2", "message": "fix  issues", "committedDate": "2021-01-17T02:45:57Z", "type": "commit"}, {"oid": "38f9593d1c82d6ff2abea97339d5add534db348b", "url": "https://github.com/apache/iceberg/commit/38f9593d1c82d6ff2abea97339d5add534db348b", "message": "fix some issues", "committedDate": "2021-01-17T02:45:57Z", "type": "commit"}, {"oid": "f6e70282f8c1a9853bf66c7f3d545d84dfd21d58", "url": "https://github.com/apache/iceberg/commit/f6e70282f8c1a9853bf66c7f3d545d84dfd21d58", "message": "fix some issues, and add some test case", "committedDate": "2021-01-17T02:45:57Z", "type": "commit"}, {"oid": "c93eaa7347475e26e33897584e47e2974abefd30", "url": "https://github.com/apache/iceberg/commit/c93eaa7347475e26e33897584e47e2974abefd30", "message": "refactor TestFlinkTableSource and fix some issues", "committedDate": "2021-01-17T02:45:57Z", "type": "forcePushed"}, {"oid": "138fa467c543f70d76a37874d6182e3331c14701", "url": "https://github.com/apache/iceberg/commit/138fa467c543f70d76a37874d6182e3331c14701", "message": "refactor TestFlinkTableSource and fix some issues", "committedDate": "2021-01-17T04:24:10Z", "type": "commit"}, {"oid": "138fa467c543f70d76a37874d6182e3331c14701", "url": "https://github.com/apache/iceberg/commit/138fa467c543f70d76a37874d6182e3331c14701", "message": "refactor TestFlinkTableSource and fix some issues", "committedDate": "2021-01-17T04:24:10Z", "type": "forcePushed"}, {"oid": "e05b6e98528ed626dd9b44144e4dd12d58d86260", "url": "https://github.com/apache/iceberg/commit/e05b6e98528ed626dd9b44144e4dd12d58d86260", "message": "add filter push down", "committedDate": "2020-12-10T05:33:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3NTg5Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544775897", "bodyText": "I'm not familiar with flink, I wonder if it should be a valid use case here and in other places that we return null; should we throw instead?", "author": "yyanyy", "createdAt": "2020-12-17T03:01:07Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Expression convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return null;", "originalCommit": "e05b6e98528ed626dd9b44144e4dd12d58d86260", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyNjUyNw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544826527", "bodyText": "iceberg support the following Expressions:\nhttps://iceberg.apache.org/api/#expressions\nFor some expressions supported by flink but not supported by iceberg, I did not convert them, because they cannot be used for iceberg table scan", "author": "zhangjun0x01", "createdAt": "2020-12-17T05:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3NTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg1MjYwOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544852609", "bodyText": "If it is an unsupported expression, there is no need to do filter push down, I think we should not throw a exception", "author": "zhangjun0x01", "createdAt": "2020-12-17T06:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3NTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NTUzNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r545365534", "bodyText": "I see. Do we want to return Optional<Expression> here then? In this case it signals that the returned value could be null, so when we add the converted expression to the list we can decide to not add nulls, so that we don't have to do null check when calling toString?", "author": "yyanyy", "createdAt": "2020-12-17T19:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3NTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU1NzQ4MQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r545557481", "bodyText": "thanks for your suggestion,I update it to Optional.\nand I add a not push down test case which return a Optional.empty()", "author": "zhangjun0x01", "createdAt": "2020-12-18T03:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3NTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3Njk3NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544776974", "bodyText": "Nit: I think these are input values, not expressions", "author": "yyanyy", "createdAt": "2020-12-17T03:04:31Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Expression convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return null;\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Expressions.isNull(isNullFilter.getName());\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Expressions.notNull(notNullExpression.getName());\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> expressions = values.stream().filter(", "originalCommit": "e05b6e98528ed626dd9b44144e4dd12d58d86260", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3NzM3Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544777373", "bodyText": "Nit: no need to have ? true : false", "author": "yyanyy", "createdAt": "2020-12-17T03:05:41Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Expression convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return null;\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Expressions.isNull(isNullFilter.getName());\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Expressions.notNull(notNullExpression.getName());\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> expressions = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Expressions.in(field.getName(), expressions);\n+\n+        case NOT:\n+          Expression child = convert(call.getResolvedChildren().get(0));\n+          if (child != null) {\n+            return Expressions.not(child);\n+          }\n+\n+          return null;\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  private static Expression convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                   CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Expression left = convert(args.get(0));\n+    Expression right = convert(args.get(1));\n+    if (left != null && right != null) {\n+      return function.apply(left, right);\n+    }\n+\n+    return null;\n+\n+  }\n+\n+  private static Expression convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                        CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(1);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(0);\n+    }\n+\n+    String name = fieldReferenceExpression.getName();\n+    Class clazz = valueLiteralExpression.getOutputDataType().getConversionClass();\n+    return function.apply(name, valueLiteralExpression.getValueAs(clazz).get());\n+  }\n+\n+  private static boolean literalOnRight(List<ResolvedExpression> args) {\n+    return args.get(0) instanceof FieldReferenceExpression && args.get(1) instanceof ValueLiteralExpression ? true :", "originalCommit": "e05b6e98528ed626dd9b44144e4dd12d58d86260", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3OTI5Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544779297", "bodyText": "Seems that this is mapping flink operations to iceberg operations in the following switch statement? If that's the case we probably don't really need it, and could directly switch based on the input flinkExpression. getFunctionDefinition()?\nAlso, there's a recent change that requires rewriting NaN in equals/notEquals to isNaN/notNaN as Iceberg's equals no longer accepts NaN as literal, so we will have to rewrite here as well. Here is a similar change done in spark filters.", "author": "yyanyy", "createdAt": "2020-12-17T03:11:37Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap", "originalCommit": "e05b6e98528ed626dd9b44144e4dd12d58d86260", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgyOTkxOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544829918", "bodyText": "Seems that this is mapping flink operations to iceberg operations in the following switch statement? If that's the case we probably don't really need it, and could directly switch based on the input flinkExpression. getFunctionDefinition()?\n\nflinkExpression.getFunctionDefinition()  return a implement class of FunctionDefinition,which cannot be used directly in switch,so we add a mapping,similar to SparkFilters", "author": "zhangjun0x01", "createdAt": "2020-12-17T05:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3OTI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3OTgwNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544779804", "bodyText": "I think returning null in the filters class will cause NPE here as well", "author": "yyanyy", "createdAt": "2020-12-17T03:13:00Z", "path": "flink/src/main/java/org/apache/iceberg/flink/IcebergTableSource.java", "diffHunk": "@@ -112,6 +119,11 @@ public String explainSource() {\n       explain += String.format(\", LimitPushDown : %d\", limit);\n     }\n \n+    if (filters != null) {\n+      explain += String.format(\", FilterPushDown,the filters :%s\",\n+          filters.stream().map(filter -> filter.toString()).collect(Collectors.joining(\",\")));", "originalCommit": "e05b6e98528ed626dd9b44144e4dd12d58d86260", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4NDI4Ng==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551984286", "bodyText": "nit:  it's more simple to rewrite this as:\n explain += String.format(\", FilterPushDown,the filters :%s\", Joiner.on(\",\").join(filters));", "author": "openinx", "createdAt": "2021-01-05T14:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3OTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc3OTkzMw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r544779933", "bodyText": "Nit: @Override?", "author": "yyanyy", "createdAt": "2020-12-17T03:13:27Z", "path": "flink/src/main/java/org/apache/iceberg/flink/IcebergTableSource.java", "diffHunk": "@@ -122,6 +134,21 @@ public boolean isLimitPushedDown() {\n \n   @Override\n   public TableSource<RowData> applyLimit(long newLimit) {\n-    return new IcebergTableSource(loader, schema, properties, projectedFields, true, newLimit);\n+    return new IcebergTableSource(loader, schema, properties, projectedFields, true, newLimit, filters);\n+  }\n+\n+  public TableSource<RowData> applyPredicate(List<Expression> predicates) {", "originalCommit": "e05b6e98528ed626dd9b44144e4dd12d58d86260", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f7cbf527f6fa9558c7f0f1cec7f7df97f6aae36", "url": "https://github.com/apache/iceberg/commit/7f7cbf527f6fa9558c7f0f1cec7f7df97f6aae36", "message": "fix some issue", "committedDate": "2020-12-17T06:50:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NzYyMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r545367622", "bodyText": "I think we may want to rewrite NOT_EQUALS to notNaN as well as notEquals in Iceberg also doesn't accept NaN as literal; I think SparkFilters doesn't do that because there's no NotEqualTo filter in Spark.", "author": "yyanyy", "createdAt": "2020-12-17T20:01:37Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Expression convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return null;\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Expressions.isNull(isNullFilter.getName());\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Expressions.notNull(notNullExpression.getName());\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Expressions.in(field.getName(), inputValues);\n+\n+        case NOT:\n+          Expression child = convert(call.getResolvedChildren().get(0));\n+          if (child != null) {\n+            return Expressions.not(child);\n+          }\n+\n+          return null;\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  private static Expression convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                   CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Expression left = convert(args.get(0));\n+    Expression right = convert(args.get(1));\n+    if (left != null && right != null) {\n+      return function.apply(left, right);\n+    }\n+\n+    return null;\n+  }\n+\n+  private static Expression convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                        CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(1);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(0);\n+    }\n+\n+    String name = fieldReferenceExpression.getName();\n+    Class clazz = valueLiteralExpression.getOutputDataType().getConversionClass();\n+    Object value = valueLiteralExpression.getValueAs(clazz).get();\n+\n+    BuiltInFunctionDefinition functionDefinition = (BuiltInFunctionDefinition) call.getFunctionDefinition();\n+    if (functionDefinition.equals(BuiltInFunctionDefinitions.EQUALS)) {", "originalCommit": "7f7cbf527f6fa9558c7f0f1cec7f7df97f6aae36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "658b61d752ff517debf9e5ea5ebb110a5aaf8d94", "url": "https://github.com/apache/iceberg/commit/658b61d752ff517debf9e5ea5ebb110a5aaf8d94", "message": "update  Expression to Optional", "committedDate": "2020-12-18T03:53:08Z", "type": "forcePushed"}, {"oid": "629c5afea86e90ac2c72fd8220d12a2543581b25", "url": "https://github.com/apache/iceberg/commit/629c5afea86e90ac2c72fd8220d12a2543581b25", "message": "update  Expression to Optional", "committedDate": "2020-12-18T04:06:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNzIwOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546027209", "bodyText": "My IDE warns that this is a suspicious call because it gets a FunctionDefinition from a map keyed by BuiltInFunctionDefinition. To fix it, I think the map should be Map<FunctionDefinition, Operation>.", "author": "rdblue", "createdAt": "2020-12-18T18:55:04Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNzI3Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546027273", "bodyText": "Nit: extra newline.", "author": "rdblue", "createdAt": "2020-12-18T18:55:11Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyODc5Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546028797", "bodyText": "How does FieldReferenceExpression.getName() reference nested fields?", "author": "rdblue", "createdAt": "2020-12-18T18:58:11Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ4MDAzNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546480034", "bodyText": "I tested it, for example, we have a table,the flink ddl is like this\uff1a\nCREATE TABLE iceberg_nested_test (\n             id VARCHAR,\n             title VARCHAR,\n             properties ROW(`foo` VARCHAR)\n) WITH (\n     'connector'='iceberg'\n);\n\nif the query sql is select * from iceberg_nested_test where properties is null ,it supports filter push down in flink, and the name is properties,if the sql is select * from iceberg_nested_test where properties.foo is null,it do not supports filter push down in flink,the code will do not enter the IcebergTableSource#applyPredicate method", "author": "zhangjun0x01", "createdAt": "2020-12-21T02:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyODc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5MzI3NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546893274", "bodyText": "Okay, sounds fine that Flink doesn't currently support predicate pushdown on nested fields. @openinx, any plans to change this?", "author": "rdblue", "createdAt": "2020-12-21T19:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyODc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk3NzYxOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547977619", "bodyText": "Yes , flink does not support nested field push down now.  Will need to file issue to address it in apache flink repo.", "author": "openinx", "createdAt": "2020-12-23T14:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyODc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4NjM1OA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r548786358", "bodyText": "I create a flink issue to track this https://issues.apache.org/jira/browse/FLINK-20767", "author": "zhangjun0x01", "createdAt": "2020-12-25T03:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyODc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyOTkzNg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546029936", "bodyText": "Class is parameterized, so this should be Class<?>", "author": "rdblue", "createdAt": "2020-12-18T18:59:34Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                                  CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(1);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(0);\n+    }\n+\n+    String name = fieldReferenceExpression.getName();\n+    Class clazz = valueLiteralExpression.getOutputDataType().getConversionClass();", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTQ5Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546031497", "bodyText": "ValueLiteralExpression allows the value to be null, in which case get here will throw an exception. How is this avoided? Does the parser reject col = null expressions?\n@openinx may be able to help here, too.", "author": "rdblue", "createdAt": "2020-12-18T19:01:47Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                                  CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(1);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(0);\n+    }\n+\n+    String name = fieldReferenceExpression.getName();\n+    Class clazz = valueLiteralExpression.getOutputDataType().getConversionClass();\n+    Object value = valueLiteralExpression.getValueAs(clazz).get();", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTk1Ng==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546031956", "bodyText": "Actually, a few lines down there is an assertion that the value isn't null. This looks like a bug to me.", "author": "rdblue", "createdAt": "2020-12-18T19:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ4NzI1NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546487254", "bodyText": "I tested it ,if the sql is select * from mytable where data = null ,it do not supports filter push down in flink,and we do not can get any data.\nif the sql is select * from mytable where data is null, it is normal ,and It will enter the IS_NULL branch of switch", "author": "zhangjun0x01", "createdAt": "2020-12-21T03:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5MjkzMw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546892933", "bodyText": "I think it would be good to fix this case rather than making the assumption that Flink won't push the = null filter. Handling null will be good for maintainability.", "author": "rdblue", "createdAt": "2020-12-21T19:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2Njk1NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547966955", "bodyText": "I agreed with @rdblue  that handling null in this function rather than assuming flink won't push down the null.", "author": "openinx", "createdAt": "2020-12-23T13:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMTQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzMjgyNw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546032827", "bodyText": "I think it would be cleaner to have a method to extract the column name and literal value as a pair, rather than passing the function to create an expression in here. Handling the expression type in the caller, but then also handling it here doesn't provide very good separation of concerns.", "author": "rdblue", "createdAt": "2020-12-18T19:04:35Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                                  CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(1);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(0);\n+    }\n+\n+    String name = fieldReferenceExpression.getName();\n+    Class clazz = valueLiteralExpression.getOutputDataType().getConversionClass();\n+    Object value = valueLiteralExpression.getValueAs(clazz).get();\n+\n+    BuiltInFunctionDefinition functionDefinition = (BuiltInFunctionDefinition) call.getFunctionDefinition();\n+    if (functionDefinition.equals(BuiltInFunctionDefinitions.EQUALS) &&\n+        functionDefinition.equals(BuiltInFunctionDefinitions.NOT_EQUALS)) {\n+      Preconditions.checkNotNull(value, \"Expression is always false : %s\", call);\n+      if (NaNUtil.isNaN(value)) {\n+        return Optional.of(Expressions.isNaN(name));\n+      } else {\n+        return Optional.of(function.apply(name, value));\n+      }\n+    }", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNDg0MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546034840", "bodyText": "This should not discard anything that is not a ValueLiteralExpression. Instead, if there is a non-literal this should either throw IllegalArgumentException or return Optional.empty to signal that the expression cannot be converted.", "author": "rdblue", "createdAt": "2020-12-18T19:08:53Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNjcyNg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546036726", "bodyText": "I think this should be converted to List<ValueLiteralExpression> to simplify value conversion.", "author": "rdblue", "createdAt": "2020-12-18T19:11:41Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4MjAxMQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r548782011", "bodyText": "the IN,BETWEEN,NOT_BETWEEN will be auto convert in flink  ,so we will not enter the IN block,\nshould we delete IN branch ?", "author": "zhangjun0x01", "createdAt": "2020-12-25T02:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNjcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMTAwNw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551221007", "bodyText": "If we're sure that flink won't enter the IN block, then I think we should remove this block. Pls add a comment saying IN will convert to multiple OR.", "author": "openinx", "createdAt": "2021-01-04T10:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNjcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5NzAyMQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551697021", "bodyText": "I remove IN block and add some comments", "author": "zhangjun0x01", "createdAt": "2021-01-05T03:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MDIzNQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546040235", "bodyText": "Null values can't be ignored. This should either return Optional.empty or throw IllegalArgumentException if there is a null value.", "author": "rdblue", "createdAt": "2020-12-18T19:14:41Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MjkyOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546042929", "bodyText": "There are several calls to getResolvedChildren().get(0). I think that should be converted to a method that validates there is only one child and also validates the type:\n  private <T extends ResolvedExpression> Optional<T> getOnlyChild(CallExpression call, Class<T> expectedChildClass) {\n    List<ResolvedExpression> children = call.getResolvedChildren();\n    if (children.size() != 1) {\n      return Optional.empty();\n    }\n\n    ResolvedExpression child = children.get(0);\n    if (!expectedChildClass.isInstance(child)) {\n      return Optional.empty();\n    }\n\n    return Optional.of(expectedChildClass.cast(child));\n  }", "author": "rdblue", "createdAt": "2020-12-18T19:19:47Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0MzUzNg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546043536", "bodyText": "This can be child.map(Expressions::not).", "author": "rdblue", "createdAt": "2020-12-18T19:21:02Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0NjIwMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546046202", "bodyText": "The literal value needs to be converted to Iceberg's internal representation before being passed to create an expression. Flink will return LocalDate, LocalTime, LocalDateTime, etc. just in the getValueAs method. And it isn't clear whether the value stored in the literal is the correct representation for other types as well.\n@openinx, could you help recommend how to do the conversion here?", "author": "rdblue", "createdAt": "2020-12-18T19:24:41Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                                  CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(1);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(0);\n+    }\n+\n+    String name = fieldReferenceExpression.getName();\n+    Class clazz = valueLiteralExpression.getOutputDataType().getConversionClass();\n+    Object value = valueLiteralExpression.getValueAs(clazz).get();\n+\n+    BuiltInFunctionDefinition functionDefinition = (BuiltInFunctionDefinition) call.getFunctionDefinition();\n+    if (functionDefinition.equals(BuiltInFunctionDefinitions.EQUALS) &&\n+        functionDefinition.equals(BuiltInFunctionDefinitions.NOT_EQUALS)) {\n+      Preconditions.checkNotNull(value, \"Expression is always false : %s\", call);\n+      if (NaNUtil.isNaN(value)) {\n+        return Optional.of(Expressions.isNaN(name));\n+      } else {\n+        return Optional.of(function.apply(name, value));\n+      }\n+    }\n+\n+    return Optional.of(function.apply(name, value));", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0Njk5NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546046995", "bodyText": "Tests should be broken into individual methods that are each a test case. To share code, use @Before and @After and different test suites.", "author": "rdblue", "createdAt": "2020-12-18T19:26:16Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -102,4 +105,154 @@ public void testLimitPushDown() {\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testFilterPushDown() {", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0OTUyOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546049529", "bodyText": "Can you also add a test case that listens for a ScanEvent and validates that the expression was correctly passed to Iceberg?", "author": "rdblue", "createdAt": "2020-12-18T19:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0Njk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc3NjgzOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r548776839", "bodyText": "I add a listener to validate the pushdown for filter in TestFlinkTableSource", "author": "zhangjun0x01", "createdAt": "2020-12-25T01:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0Njk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0ODc0Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r546048747", "bodyText": "This class needs an extensive test suite that checks the conversion from expected Flink expressions, not just a test for the source.\nThe conversion needs to cover at least these cases:\n\nEquals with null\nNot equals with null\nIn with null\nNot in with null\nEquals with NaN\nNot equals with NaN\nIn with NaN\nNot in with NaN\nAll inequalities with null\nAll inequalities with NaN\nAll expressions with a non-null and non-Nan value (preferably one string and one numeric)\nEach data type that is supposed by Iceberg/Flink", "author": "rdblue", "createdAt": "2020-12-18T19:29:45Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzY3Mzc5NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547673794", "bodyText": "I look up the  flink doc and the source code,  and tested it \uff0cit seems that NaN and  Infinity are not supported by flink now .\nthe data type is supported by flink : here", "author": "zhangjun0x01", "createdAt": "2020-12-23T05:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0ODc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2MjUwNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547962504", "bodyText": "Q:  is it possible that we have two literals in both left and right side ? For example,  someone may write the SQL: SELECT * FROM test where 1 > 0,  then we could not think that the left MUST be a field and the right MUST be a value in this else block.\nWe have done the similar work in our own branch before,  you could see the PR: https://github.com/generic-datalake/iceberg-poc/pull/2/files#diff-86160616589acf1dd526b10b73418a46fe60f9e5e5ab6946a4ea3c8f019542f5R123", "author": "openinx", "createdAt": "2020-12-23T13:37:34Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                                  CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2Nzg4OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547967889", "bodyText": "I think it's better to add an unit tests to address this case.", "author": "openinx", "createdAt": "2020-12-23T13:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2MjUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA2NzI2OA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r548067268", "bodyText": "I agree. It is best to validate both child types in each case and only convert if they match what is expected.", "author": "rdblue", "createdAt": "2020-12-23T17:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2MjUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4MDU3OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r548780579", "bodyText": "I add the test case literal on right, literal on left ,2 literals", "author": "zhangjun0x01", "createdAt": "2020-12-25T02:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2MjUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk2NDIwMw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547964203", "bodyText": "Is this sentence correct  ?    should transform the && to || ?", "author": "openinx", "createdAt": "2020-12-23T13:41:54Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {\n+          return convertLogicExpression(Expressions::or, call);\n+        }\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                                  CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    FieldReferenceExpression fieldReferenceExpression;\n+    ValueLiteralExpression valueLiteralExpression;\n+    if (literalOnRight(args)) {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(0);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(1);\n+    } else {\n+      fieldReferenceExpression = (FieldReferenceExpression) args.get(1);\n+      valueLiteralExpression = (ValueLiteralExpression) args.get(0);\n+    }\n+\n+    String name = fieldReferenceExpression.getName();\n+    Class clazz = valueLiteralExpression.getOutputDataType().getConversionClass();\n+    Object value = valueLiteralExpression.getValueAs(clazz).get();\n+\n+    BuiltInFunctionDefinition functionDefinition = (BuiltInFunctionDefinition) call.getFunctionDefinition();\n+    if (functionDefinition.equals(BuiltInFunctionDefinitions.EQUALS) &&", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk3NjY5MQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547976691", "bodyText": "Q:  the call.getResolvedChildren().get(0) MUST be a FieldReferenceExpression ?   I would recommend to use the similar  toReference method to check whether it's indeed a FieldReferenceExpression,  that's more safe.", "author": "openinx", "createdAt": "2020-12-23T14:10:35Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk3OTM2MQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547979361", "bodyText": "Pls check its class type before casting to FieldReferenceExpression directly.  It's more safe to cast if we're sure that it's indeed the expected class.", "author": "openinx", "createdAt": "2020-12-23T14:16:31Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4MjU3NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547982574", "bodyText": "nit:  the { and } could be removed .", "author": "openinx", "createdAt": "2020-12-23T14:23:41Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4MjYzMQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547982631", "bodyText": "ditto", "author": "openinx", "createdAt": "2020-12-23T14:23:47Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .build();\n+\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          FieldReferenceExpression isNullFilter = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.isNull(isNullFilter.getName()));\n+\n+        case NOT_NULL:\n+          FieldReferenceExpression notNullExpression = (FieldReferenceExpression) call.getResolvedChildren().get(0);\n+          return Optional.of(Expressions.notNull(notNullExpression.getName()));\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return convertComparisonExpression(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return convertComparisonExpression(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          FieldReferenceExpression field = (FieldReferenceExpression) args.get(0);\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(\n+              expression -> {\n+                if (expression instanceof ValueLiteralExpression) {\n+                  return !((ValueLiteralExpression) flinkExpression).isNull();\n+                }\n+\n+                return false;\n+              }\n+          ).map(expression -> {\n+            ValueLiteralExpression valueLiteralExpression = (ValueLiteralExpression) expression;\n+            return valueLiteralExpression.getValueAs(valueLiteralExpression.getOutputDataType().getConversionClass())\n+                .get();\n+          }).collect(Collectors.toList());\n+          return Optional.of(Expressions.in(field.getName(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(call.getResolvedChildren().get(0));\n+          if (child.isPresent()) {\n+            return Optional.of(Expressions.not(child.get()));\n+          }\n+\n+          return Optional.empty();\n+\n+        case AND: {\n+          return convertLogicExpression(Expressions::and, call);\n+        }\n+\n+        case OR: {", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4MzcyNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547983724", "bodyText": "The flink's LIKE, BETWEEN, NOT_BETWEEN could also be pushed down, pls see https://github.com/generic-datalake/iceberg-poc/pull/2/files#diff-86160616589acf1dd526b10b73418a46fe60f9e5e5ab6946a4ea3c8f019542f5R78-R80.", "author": "openinx", "createdAt": "2020-12-23T14:26:02Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinition;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Map<BuiltInFunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<BuiltInFunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc3ODY4OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r548778689", "bodyText": "I tested that ,I found BETWEEN, NOT_BETWEEN,IN expression will be auto convert.\nthe BETWEEN will be convert to (GT_EQ AND LT_EQ),\nthe NOT_BETWEEN will be convert to (LT_EQ OR GT_EQ),\nthe IN will be convert to OR,\nin IcebergTableSource#applyPredicate method ,We won't get BETWEEN,NOT_BETWEEN,IN expressions,so I do not add BETWEEN,NOT_BETWEEN in FlinkFilters, and do not add test case in TestFlinkFilters.but add test  case in TestFlinkTableSource to valiate the convert.\nfor example , we have a sql SELECT * FROM table WHERE id BETWEEN 1 AND 2,the filter expression will be id >= 1 AND id <= 2 , the test case is here", "author": "zhangjun0x01", "createdAt": "2020-12-25T02:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4MzcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwOTIwNQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551209205", "bodyText": "OK,  make sense to me !", "author": "openinx", "createdAt": "2021-01-04T09:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4MzcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk4NTc5Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r547985792", "bodyText": "I will suggest to have a more strict assertion to validate the pushed  filter's internal information, see https://github.com/generic-datalake/iceberg-poc/pull/2/files#diff-5d18d1ff127d1dc70a9a15bbe941f2b6f9d28b3015924f601ac1f722914099dbR96", "author": "openinx", "createdAt": "2020-12-23T14:30:22Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -102,4 +105,154 @@ public void testLimitPushDown() {\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testFilterPushDown() {\n+    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b'),(3,CAST(null AS VARCHAR))\", TABLE_NAME);\n+\n+    String expectedExplain = \"FilterPushDown\";\n+\n+    // not push down\n+    String sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%a%' \";\n+    String explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    assertFalse(\"explain should not contains FilterPushDown\", explainNoPushDown.contains(expectedExplain));\n+\n+    // equal\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    assertTrue(\"explain should contains FilterPushDown\", explain.contains(expectedExplain));", "originalCommit": "629c5afea86e90ac2c72fd8220d12a2543581b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eed220acffd423c949888ff8a1c9115ecb42c809", "url": "https://github.com/apache/iceberg/commit/eed220acffd423c949888ff8a1c9115ecb42c809", "message": "fix some bugs and add test case", "committedDate": "2020-12-25T01:46:35Z", "type": "forcePushed"}, {"oid": "d23ce45cf0b1e500ac1a21a5b1d1d63352ff9cfd", "url": "https://github.com/apache/iceberg/commit/d23ce45cf0b1e500ac1a21a5b1d1d63352ff9cfd", "message": "fix some bugs and add test case", "committedDate": "2020-12-25T01:53:51Z", "type": "forcePushed"}, {"oid": "1af16c70cc73eede503fce30737e8a49a1622c4d", "url": "https://github.com/apache/iceberg/commit/1af16c70cc73eede503fce30737e8a49a1622c4d", "message": "fix some bugs and add test case", "committedDate": "2020-12-25T02:08:42Z", "type": "forcePushed"}, {"oid": "847b62f6648d83092e367e682984f38dccf0cfc9", "url": "https://github.com/apache/iceberg/commit/847b62f6648d83092e367e682984f38dccf0cfc9", "message": "fix some bugs and add test case", "committedDate": "2020-12-30T03:00:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwMTA3Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551201072", "bodyText": "Here we could remove the flinkExpression == null and just keep the\n    if (!(flinkExpression instanceof CallExpression)) {\n      return Optional.empty();\n    }\nBecause null will always meet the !(flinkExpression instanceof CallExpression) condition.", "author": "openinx", "createdAt": "2021-01-04T09:28:40Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+import static org.apache.iceberg.expressions.Expressions.isNaN;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (flinkExpression == null || !(flinkExpression instanceof CallExpression)) {", "originalCommit": "847b62f6648d83092e367e682984f38dccf0cfc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwNjYwOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551206609", "bodyText": "How about changing this to check whether the explainBetween contains a more detailed string FilterPushDown,the filters :ref(name=\"id\") >= 1,ref(name=\"id\") <= 2]]], fields=[id, data]) ?   explainBetween.contains(\"FilterPushDown\") is not so accurate for me.", "author": "openinx", "createdAt": "2021-01-04T09:39:10Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +95,328 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n     Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, mixedResult.size());\n+    assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    assertTrue(\"explain should contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id = 1\", FlinkUtil.describe(lastScanEvent.filter()));\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    assertFalse(\"explain should not contains FilterPushDown\", explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    assertTrue(\"explain should contains FilterPushDown\", explainLeft.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id = 1\", FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    assertTrue(\"explain should contains FilterPushDown\", explainNE.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    assertEquals(\"should have 2 record\", 2, resultNE.size());\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id != 1\", FlinkUtil.describe(lastScanEvent.filter()));\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'a' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    assertTrue(\"explain should contains FilterPushDown\", explainAnd.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    assertEquals(\"should have 1 record\", 1, resultAnd.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultAnd.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"(id = 1 AND data = 'a')\",\n+        FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    assertTrue(\"explain should contains FilterPushDown\", explainOr.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultOr = sql(sqlOr);\n+    assertEquals(\"should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"a\"});\n+    expectedOR.add(new Object[] {2, \"b\"});\n+    assertArrayEquals(\"Should produce the expected record\", resultOr.toArray(), expectedOR.toArray());\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"(id = 1 OR data = 'b')\",\n+        FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    assertTrue(\"explain should contains FilterPushDown\", explainGT.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    assertEquals(\"should have 2 record\", 2, resultGT.size());\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    expectedGT.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id > 1\", FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    assertTrue(\"explain should contains FilterPushDown\", explainGTE.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    expectedGTE.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id >= 2\", FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    assertTrue(\"explain should contains FilterPushDown\", explainLT.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultLT = sql(sqlLT);\n+    assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id < 2\", FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    assertTrue(\"explain should contains FilterPushDown\", explainLTE.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id <= 1\", FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    assertTrue(\"explain should contains FilterPushDown\", explainIN.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    assertEquals(\"should have 2 records\", 2, resultIN.size());\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"a\"});\n+    expectedIN.add(new Object[] {2, \"b\"});\n+    assertArrayEquals(\"Should produce the expected record\", resultIN.toArray(), expectedIN.toArray());\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"(id = 1 OR id = 2)\",\n+        FlinkUtil.describe(lastScanEvent.filter()));\n+\n+    // in with null will not push down\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE id IN (1,2,NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    assertFalse(\"explain should not contains FilterPushDown\", explainInNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotIn() {\n+    String sqlNotIn = String.format(\"SELECT * FROM %s WHERE id NOT IN (3,2) \", TABLE_NAME);\n+    String explainNotIn = getTableEnv().explainSql(sqlNotIn);\n+    assertTrue(\"explain should contains FilterPushDown\", explainNotIn.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultNotIn = sql(sqlNotIn);\n+    assertEquals(\"should have 1 record\", 1, resultNotIn.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultNotIn.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"(id != 3 AND id != 2)\",\n+        FlinkUtil.describe(lastScanEvent.filter()));\n+\n+    String sqlNotInNull = String.format(\"SELECT * FROM %s WHERE id NOT IN (1,2,NULL) \", TABLE_NAME);\n+    String explainNotInNull = getTableEnv().explainSql(sqlNotInNull);\n+    assertFalse(\"explain should not contains FilterPushDown\", explainNotInNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNotNull() {\n+    String sqlNotNull = String.format(\"SELECT * FROM %s WHERE data IS NOT NULL\", TABLE_NAME);\n+    String explainNotNull = getTableEnv().explainSql(sqlNotNull);\n+    assertTrue(\"explain should contains FilterPushDown\", explainNotNull.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultNotNull = sql(sqlNotNull);\n+    assertEquals(\"should have 2 record\", 2, resultNotNull.size());\n+    List<Object[]> expected = Lists.newArrayList();\n+    expected.add(new Object[] {1, \"a\"});\n+    expected.add(new Object[] {2, \"b\"});\n+    assertArrayEquals(\"Should produce the expected record\", resultNotNull.toArray(), expected.toArray());\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"data IS NOT NULL\",\n+        FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNull() {\n+    String sqlNull = String.format(\"SELECT * FROM %s WHERE data IS  NULL\", TABLE_NAME);\n+    String explainNull = getTableEnv().explainSql(sqlNull);\n+    assertTrue(\"explain should contains FilterPushDown\", explainNull.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultNull = sql(sqlNull);\n+    assertEquals(\"should have 1 record\", 1, resultNull.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultNull.get(0), new Object[] {3, null});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    assertEquals(\"Should push down expected filter\", \"data IS NULL\", FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNot() {\n+    String sqlNot = String.format(\"SELECT * FROM %s WHERE NOT id = 1 \", TABLE_NAME);\n+    String explainNot = getTableEnv().explainSql(sqlNot);\n+    assertTrue(\"explain should contains FilterPushDown\", explainNot.contains(expectedFilterPushDownExplain));\n+    List<Object[]> resultNot = sql(sqlNot);\n+    assertEquals(\"should have 2 record\", 2, resultNot.size());\n+    List<Object[]> expectedNot = Lists.newArrayList();\n+    expectedNot.add(new Object[] {2, \"b\"});\n+    expectedNot.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected record\", resultNot.toArray(), expectedNot.toArray());\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id != 1\", FlinkUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownBetween() {\n+    String sqlBetween = String.format(\"SELECT * FROM %s WHERE id BETWEEN 1 AND 2 \", TABLE_NAME);\n+    String explainBetween = getTableEnv().explainSql(sqlBetween);\n+    assertTrue(\"explain should contains FilterPushDown\", explainBetween.contains(expectedFilterPushDownExplain));", "originalCommit": "847b62f6648d83092e367e682984f38dccf0cfc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5NjIzOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551696238", "bodyText": "I add the more detail string in IN,BETWEEN,NO_BETWEEN test case", "author": "zhangjun0x01", "createdAt": "2021-01-05T03:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIwNjYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxMjU0Ng==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551212546", "bodyText": "getOnlyChild ?  the method name is confusing.   How about using singleton ?", "author": "openinx", "createdAt": "2021-01-04T09:50:35Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+import static org.apache.iceberg.expressions.Expressions.isNaN;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (flinkExpression == null || !(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(getOnlyChild(call, FieldReferenceExpression.class).orElse(null));", "originalCommit": "847b62f6648d83092e367e682984f38dccf0cfc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxODI1MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551218250", "bodyText": "Pls consider the two cases:\nCase.1 :   a < 1; \nCase.2:    1 < a;\nHere we  convertBinaryExpress will parse the tuple2 as <a, 1>.  and the function will be  lessThan.  While in the actual the case.2 is totally different with case.1 because its meaning is :  a is greaterThan 1 .\nThat's why we introduced a reversed function in here,  for example,  the greaterThan's revered function is lessThan,  the lessThan's reversed function is greaterThan.   If the case 1 < a then we should call the reversed function here.", "author": "openinx", "createdAt": "2021-01-04T10:01:37Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+import static org.apache.iceberg.expressions.Expressions.isNaN;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (flinkExpression == null || !(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(getOnlyChild(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(getOnlyChild(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, call);\n+\n+        case IN:\n+          List<ResolvedExpression> args = call.getResolvedChildren();\n+          Optional<String> fieldName = toReference(args.get(0));\n+          List<ResolvedExpression> values = args.subList(1, args.size());\n+\n+          List<Object> inputValues = values.stream().filter(expression -> {\n+            if (expression instanceof ValueLiteralExpression) {\n+              return !((ValueLiteralExpression) expression).isNull();\n+            }\n+\n+            return false;\n+          }).map(expression -> {\n+            Optional<Object> value = toLiteral(expression);\n+            return value.get();\n+          }).collect(Collectors.toList());\n+\n+          return Optional.of(Expressions.in(fieldName.get(), inputValues));\n+\n+        case NOT:\n+          Optional<Expression> child = convert(getOnlyChild(call, CallExpression.class).orElse(null));\n+          return child.map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> getOnlyChild(CallExpression call,\n+                                                                         Class<T> expectedChildClass) {\n+    List<ResolvedExpression> children = call.getResolvedChildren();\n+    if (children.size() != 1) {\n+      return Optional.empty();\n+    }\n+\n+    ResolvedExpression child = children.get(0);\n+    if (!expectedChildClass.isInstance(child)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(expectedChildClass.cast(child));\n+  }\n+\n+  private static Optional<Expression> convertLike(CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String pattern = tuple2.f1.toString();\n+    Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n+\n+    // exclude special char of LIKE\n+    // '_' is the wildcard of the SQL LIKE\n+    if (!pattern.contains(\"_\") && matcher.matches()) {\n+      return Optional.of(Expressions.startsWith(tuple2.f0, matcher.group(1)));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(BiFunction<String, Object, Expression> function,\n+                                                                  CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 != null) {\n+      return Optional.of(function.apply(tuple2.f0, tuple2.f1));", "originalCommit": "847b62f6648d83092e367e682984f38dccf0cfc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY5Njc4OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551696789", "bodyText": "I add the reversedFunction in lessThan,lessThanOrEqual,greaterThan,greaterThanOrEqual.\nand add the test case", "author": "zhangjun0x01", "createdAt": "2021-01-05T03:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxODI1MA=="}], "type": "inlineReview"}, {"oid": "5a6eac589182db4e2d2a2a73721548275a5776fc", "url": "https://github.com/apache/iceberg/commit/5a6eac589182db4e2d2a2a73721548275a5776fc", "message": "fix some issues", "committedDate": "2021-01-05T03:20:49Z", "type": "forcePushed"}, {"oid": "470882f163072d771880961d0a79ccc58cfa4d90", "url": "https://github.com/apache/iceberg/commit/470882f163072d771880961d0a79ccc58cfa4d90", "message": "fix some issues", "committedDate": "2021-01-05T03:55:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg0MDUzOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551840539", "bodyText": "I'd prefer to have a basic args check here ( rather than introducing another similar sql(String query, Object... args) method:\nString query = args.length > 0 ? String.format(sql, args) : sql:\nTableResult tableResult = getTableEnv().executeSql(query);", "author": "openinx", "createdAt": "2021-01-05T10:20:17Z", "path": "flink/src/test/java/org/apache/iceberg/flink/FlinkTestBase.java", "diffHunk": "@@ -72,8 +72,21 @@ protected TableEnvironment getTableEnv() {\n     return tEnv;\n   }\n \n+  /**\n+   * if we have a sql with '%' , for example :  SELECT * FROM mytable WHERE data LIKE 'a%'. the format operation will\n+   * throw an exception, so we add a sql method to execute the original sql\n+   *\n+   * @param query the sql\n+   * @param args  the args to format sql\n+   * @return the formated sql\n+   */\n   protected List<Object[]> sql(String query, Object... args) {\n-    TableResult tableResult = getTableEnv().executeSql(String.format(query, args));\n+    String sql = String.format(query, args);\n+    return sql(sql);\n+  }\n+\n+  protected List<Object[]> sql(String sql) {\n+    TableResult tableResult = getTableEnv().executeSql(sql);", "originalCommit": "470882f163072d771880961d0a79ccc58cfa4d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg1OTA0Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551859042", "bodyText": "I update it", "author": "zhangjun0x01", "createdAt": "2021-01-05T10:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg0MDUzOQ=="}], "type": "inlineReview"}, {"oid": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "url": "https://github.com/apache/iceberg/commit/1cf9b39191cc289a175f747ebce38b6138efdbe8", "message": "do not format sql when args length is 0", "committedDate": "2021-01-05T11:14:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg4OTMyMA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551889320", "bodyText": "the BETWEEN, NOT_BETWEEN,IN expression will be auto convert by flink\n\n-> The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically.\n\nso we do not add the convert here\n\n-> so we do not add the conversion here.\n\nbe convert to\n\n-> be converted to", "author": "openinx", "createdAt": "2021-01-05T12:00:33Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+import static org.apache.iceberg.expressions.Expressions.isNaN;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * the BETWEEN, NOT_BETWEEN,IN expression will be auto convert by flink. the BETWEEN will be convert to (GT_EQ AND", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTUxMQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551899511", "bodyText": "I think there's a bug here.   Assume the case:  a != NaN,   the handleNaN will return an iceberg expression:  Expressions.isNaN(name).  That's incorrect ?", "author": "openinx", "createdAt": "2021-01-05T12:23:47Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+import static org.apache.iceberg.expressions.Expressions.isNaN;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * the BETWEEN, NOT_BETWEEN,IN expression will be auto convert by flink. the BETWEEN will be convert to (GT_EQ AND\n+   * LT_EQ), the NOT_BETWEEN will be convert to (LT_EQ OR GT_EQ), the IN will be convert to OR, so we do not add the\n+   * convert here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, call);", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTc0MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551899740", "bodyText": "Pls add an unit test for this if possible.", "author": "openinx", "createdAt": "2021-01-05T12:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3OTcyMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552379722", "bodyText": "I think there's a bug here. Assume the case: a != NaN, the handleNaN will return an iceberg expression: Expressions.isNaN(name). That's incorrect ?\n\nIt was my negligence, forgot to deal with !=\uff0cI updated it", "author": "zhangjun0x01", "createdAt": "2021-01-06T05:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4OTAzNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552389034", "bodyText": "Pls add an unit test for this if possible.\n\nwe can construct NaN type by float('NaN') in spark and hive sql,\nbut I lookup the flink doc,It does not seem to support Infinity an NaN now", "author": "zhangjun0x01", "createdAt": "2021-01-06T06:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTg5OTUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDY5MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551900690", "bodyText": "Will the flink convert the NOT_EQ to be NOT ( EQ ) ?  If sure, then we don't have to handle the NOT_EQ ?", "author": "openinx", "createdAt": "2021-01-05T12:26:12Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+import static org.apache.iceberg.expressions.Expressions.isNaN;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * the BETWEEN, NOT_BETWEEN,IN expression will be auto convert by flink. the BETWEEN will be convert to (GT_EQ AND\n+   * LT_EQ), the NOT_BETWEEN will be convert to (LT_EQ OR GT_EQ), the IN will be convert to OR, so we do not add the\n+   * convert here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, call);\n+\n+        case NOT_EQ:", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3ODk2Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552378963", "bodyText": "I tested that,flink do not convert NOT_EQ to NOT", "author": "zhangjun0x01", "createdAt": "2021-01-06T05:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1MDY4NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553150684", "bodyText": "OK,  then we have to keep the NOT_EQ here.", "author": "openinx", "createdAt": "2021-01-07T07:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMDY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMzI4MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551903280", "bodyText": "It's good to move this class to test packages, I saw nobody from production files would call this.", "author": "openinx", "createdAt": "2021-01-05T12:31:57Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkUtil.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.expressions.BoundPredicate;\n+import org.apache.iceberg.expressions.ExpressionVisitors;\n+import org.apache.iceberg.expressions.Literal;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+\n+public class FlinkUtil {", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwOTIyMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552009222", "bodyText": "Sounds like it should be renamed as FlinkFiltersUtil", "author": "openinx", "createdAt": "2021-01-05T15:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMzI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM3ODc3MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552378770", "bodyText": "I copyed the  code from the spark module, in spark, there are production files call this method.\nIn Flink, this class does only have methods related to filters. I think some methods related to flink util can be added to this class in the future. So I do not add the class in test packages,what do you think?", "author": "zhangjun0x01", "createdAt": "2021-01-06T05:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMzI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1MzE4MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553153180", "bodyText": "The DescribeExpressionVisitor  is not actually format the flink filters to string,   instead it's formatting the iceberg's Expression to string.  So even if we want to introduce a flink utility ,  it's not a good idea to put the iceberg's visitor in this class.", "author": "openinx", "createdAt": "2021-01-07T07:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMzI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1NDI5Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553154292", "bodyText": "I'd prefer to abstract the common methods from flink and spark to a common utility.   How about introducing a ExpressionsUtil under package org.apache.iceberg.expressions ?  In that way, we could remove the Spark3Util#describe methods.", "author": "openinx", "createdAt": "2021-01-07T07:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTkwMzI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4MDYxMw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551980613", "bodyText": "It's better to use ImmutableList.of()  as the default filters because of the comment here, though there's large probability that when isFilterPushedDown() returns true the filters should always be non-nullable.", "author": "openinx", "createdAt": "2021-01-05T14:52:53Z", "path": "flink/src/main/java/org/apache/iceberg/flink/IcebergTableSource.java", "diffHunk": "@@ -33,33 +37,37 @@\n import org.apache.flink.table.types.DataType;\n import org.apache.flink.table.utils.TableConnectorUtils;\n import org.apache.iceberg.flink.source.FlinkSource;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n \n /**\n  * Flink Iceberg table source.\n- * TODO: Implement {@link FilterableTableSource}\n  */\n public class IcebergTableSource\n-    implements StreamTableSource<RowData>, ProjectableTableSource<RowData>, LimitableTableSource<RowData> {\n+    implements StreamTableSource<RowData>, ProjectableTableSource<RowData>, FilterableTableSource<RowData>,\n+    LimitableTableSource<RowData> {\n \n   private final TableLoader loader;\n   private final TableSchema schema;\n   private final Map<String, String> properties;\n   private final int[] projectedFields;\n   private final boolean isLimitPushDown;\n   private final long limit;\n+  private final List<org.apache.iceberg.expressions.Expression> filters;\n \n   public IcebergTableSource(TableLoader loader, TableSchema schema, Map<String, String> properties) {\n-    this(loader, schema, properties, null, false, -1);\n+    this(loader, schema, properties, null, false, -1, null);", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk4Njk4OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551986989", "bodyText": "nit: how about rewrite those as:\n    List<org.apache.iceberg.expressions.Expression> expressions = Lists.newArrayList();\n    for (Expression predicate : predicates) {\n      FlinkFilters.convert(predicate).ifPresent(expressions::add);\n    }", "author": "openinx", "createdAt": "2021-01-05T15:02:48Z", "path": "flink/src/main/java/org/apache/iceberg/flink/IcebergTableSource.java", "diffHunk": "@@ -122,6 +135,24 @@ public boolean isLimitPushedDown() {\n \n   @Override\n   public TableSource<RowData> applyLimit(long newLimit) {\n-    return new IcebergTableSource(loader, schema, properties, projectedFields, true, newLimit);\n+    return new IcebergTableSource(loader, schema, properties, projectedFields, true, newLimit, filters);\n+  }\n+\n+  @Override\n+  public TableSource<RowData> applyPredicate(List<Expression> predicates) {\n+    List<org.apache.iceberg.expressions.Expression> expressions = Lists.newArrayList();\n+    for (Expression predicate : predicates) {\n+      Optional<org.apache.iceberg.expressions.Expression> expression = FlinkFilters.convert(predicate);\n+      if (expression.isPresent()) {\n+        expressions.add(expression.get());\n+      }\n+    }", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTk5MjI5MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r551992290", "bodyText": "It's good to have a assert the optional is present before get  its value:\n    Optional<org.apache.iceberg.expressions.Expression> expression = FlinkFilters.convert(expr);\n    Assert.assertTrue(expression.isPresent());", "author": "openinx", "createdAt": "2021-01-05T15:11:01Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Test;\n+\n+import static org.apache.flink.table.api.Expressions.$;\n+import static org.apache.flink.table.api.Expressions.lit;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(10))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_TIME_ZONE())\n+      .field(\"field13\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, new byte[] {'a', 'b'});\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+\n+    matchLiteral(\"field13\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isEqual(Expressions.lit(1)))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isEqual(Expressions.$(\"field1\")))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.notEqual(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isNotEqual(Expressions.lit(1)))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isNotEqual(Expressions.$(\"field1\")))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testGreaterThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThan(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreater(Expressions.lit(1)))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLess(Expressions.$(\"field1\")))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testGreaterThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThanOrEqual(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreaterOrEqual(Expressions.lit(1)))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLessOrEqual(Expressions.$(\"field1\")))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testLessThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThan(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLess(Expressions.lit(1)))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreater(Expressions.$(\"field1\")))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testLessThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThanOrEqual(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLessOrEqual(Expressions.lit(1)))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreaterOrEqual(Expressions.$(\"field1\")))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testIsNull() {\n+    Expression expr = resolve($(\"field1\").isNull());\n+    UnboundPredicate actual = (UnboundPredicate) FlinkFilters.convert(expr).get();\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.isNull(\"field1\");\n+    assertPredicatesMatch(expected, actual);\n+  }\n+\n+  @Test\n+  public void testIsNotNull() {\n+    Expression expr = resolve($(\"field1\").isNotNull());\n+    UnboundPredicate actual = (UnboundPredicate) FlinkFilters.convert(expr).get();\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.notNull(\"field1\");\n+    assertPredicatesMatch(expected, actual);\n+  }\n+\n+  @Test\n+  public void testAnd() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isEqual(lit(1)).and(Expressions.$(\"field2\").isEqual(lit(2L))));\n+    And actual = (And) FlinkFilters.convert(expr).get();\n+    And expected = (And) org.apache.iceberg.expressions.Expressions.and(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    assertEquals(expected.op(), actual.op());\n+    assertEquals(expected.left().op(), actual.left().op());\n+    assertEquals(expected.right().op(), actual.right().op());\n+  }\n+\n+  @Test\n+  public void testOr() {\n+    Expression expr = resolve($(\"field1\").isEqual(lit(1)).or($(\"field2\").isEqual(lit(2L))));\n+    Or actual = (Or) FlinkFilters.convert(expr).get();\n+    Or expected = (Or) org.apache.iceberg.expressions.Expressions.or(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    assertEquals(expected.op(), actual.op());\n+    assertEquals(expected.left().op(), actual.left().op());\n+    assertEquals(expected.right().op(), actual.right().op());\n+  }\n+\n+  @Test\n+  public void testNot() {\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.NOT, $(\"field1\").isEqual(lit(1))));\n+    Not actual = (Not) FlinkFilters.convert(expr).get();\n+    Not expected = (Not) org.apache.iceberg.expressions.Expressions.not(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1));\n+\n+    assertEquals(expected.op(), actual.op());\n+    assertPredicatesMatch((UnboundPredicate) expected.child(), (UnboundPredicate) actual.child());\n+  }\n+\n+  @Test\n+  public void testLike() {\n+    UnboundPredicate expected = org.apache.iceberg.expressions.Expressions.startsWith(\"field5\", \"abc\");\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.LIKE, $(\"field5\"), lit(\"abc%\")));\n+    assertPredicatesMatch(expected, (UnboundPredicate) FlinkFilters.convert(expr).get());\n+  }\n+\n+  private void matchLiteral(String fieldName, Object flinkLiteral, Object icebergLiteral) {\n+    Expression expr = resolve(Expressions.$(fieldName).isEqual(Expressions.lit(flinkLiteral)));\n+    org.apache.iceberg.expressions.Expression actual = FlinkFilters.convert(expr).get();", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMjc1OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552002759", "bodyText": "Pls add NaN cases for both equals and notEquals .", "author": "openinx", "createdAt": "2021-01-05T15:27:07Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Test;\n+\n+import static org.apache.flink.table.api.Expressions.$;\n+import static org.apache.flink.table.api.Expressions.lit;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(10))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_TIME_ZONE())\n+      .field(\"field13\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, new byte[] {'a', 'b'});\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+\n+    matchLiteral(\"field13\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isEqual(Expressions.lit(1)))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isEqual(Expressions.$(\"field1\")))).get();\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4ODgwMA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552388800", "bodyText": "I add the test case", "author": "zhangjun0x01", "createdAt": "2021-01-06T06:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMjc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMzM1MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552003350", "bodyText": "Nit: better to check ifPresent before get the value from Optional.", "author": "openinx", "createdAt": "2021-01-05T15:28:01Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Test;\n+\n+import static org.apache.flink.table.api.Expressions.$;\n+import static org.apache.flink.table.api.Expressions.lit;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(10))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_TIME_ZONE())\n+      .field(\"field13\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, new byte[] {'a', 'b'});\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+\n+    matchLiteral(\"field13\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isEqual(Expressions.lit(1)))).get();", "originalCommit": "1cf9b39191cc289a175f747ebce38b6138efdbe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MDY3Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r552380672", "bodyText": "I changed all get to orElse(null), my initial thought was that in this specified case, the result should not return null, so I did not add judgment", "author": "zhangjun0x01", "createdAt": "2021-01-06T05:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjAwMzM1MA=="}], "type": "inlineReview"}, {"oid": "f9cc573c9604c59ad6d98f63fb94edd1fd46fa47", "url": "https://github.com/apache/iceberg/commit/f9cc573c9604c59ad6d98f63fb94edd1fd46fa47", "message": "fix some issues", "committedDate": "2021-01-06T06:09:34Z", "type": "forcePushed"}, {"oid": "f96e8a3e86dce66300a996b3e5ea76916e426816", "url": "https://github.com/apache/iceberg/commit/f96e8a3e86dce66300a996b3e5ea76916e426816", "message": "fix some issues", "committedDate": "2021-01-06T06:22:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEzNDY1NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553134655", "bodyText": "This key-value pairs could be removed , right ?", "author": "openinx", "createdAt": "2021-01-07T06:34:19Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzEzNjc3Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553136772", "bodyText": "Nit:  It's better to rename it as parseFieldAndLiteral ?   The method is not actually convert expressions from flink expr to iceberg expr ?", "author": "openinx", "createdAt": "2021-01-07T06:41:23Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, Expressions::isNaN, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, Expressions::notNaN, call);\n+\n+        case NOT:\n+          Optional<Expression> child = convert(singleton(call, CallExpression.class).orElse(null));\n+          return child.map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> singleton(CallExpression call,\n+                                                                      Class<T> expectedChildClass) {\n+    List<ResolvedExpression> children = call.getResolvedChildren();\n+    if (children.size() != 1) {\n+      return Optional.empty();\n+    }\n+\n+    ResolvedExpression child = children.get(0);\n+    if (!expectedChildClass.isInstance(child)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(expectedChildClass.cast(child));\n+  }\n+\n+  private static Optional<Expression> convertLike(CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String pattern = tuple2.f1.toString();\n+    Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n+\n+    // exclude special char of LIKE\n+    // '_' is the wildcard of the SQL LIKE\n+    if (!pattern.contains(\"_\") && matcher.matches()) {\n+      return Optional.of(Expressions.startsWith(tuple2.f0, matcher.group(1)));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(\n+      BiFunction<String, Object, Expression> function, BiFunction<String, Object, Expression> reversedFunction,\n+      CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 != null) {\n+      if (literalOnRight(call.getResolvedChildren())) {\n+        return Optional.of(function.apply(tuple2.f0, tuple2.f1));\n+      } else {\n+        return Optional.of(reversedFunction.apply(tuple2.f0, tuple2.f1));\n+      }\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static Optional<String> toReference(org.apache.flink.table.expressions.Expression expression) {\n+    return expression instanceof FieldReferenceExpression ?\n+        Optional.of(((FieldReferenceExpression) expression).getName()) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Object> toLiteral(org.apache.flink.table.expressions.Expression expression) {\n+    // Not support null literal\n+    return expression instanceof ValueLiteralExpression ?\n+        convertLiteral((ValueLiteralExpression) expression) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Expression> handleNaN(BiFunction<String, Object, Expression> function,\n+                                                Function<String, Expression> functionNaN,\n+                                                CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String name = tuple2.f0;\n+    Object value = tuple2.f1;\n+\n+    if (NaNUtil.isNaN(value)) {\n+      return Optional.of(functionNaN.apply(name));\n+    } else {\n+      return Optional.of(function.apply(name, value));\n+    }\n+  }\n+\n+  private static Optional<Object> convertLiteral(ValueLiteralExpression expression) {\n+    Optional<?> value = expression.getValueAs(expression.getOutputDataType().getLogicalType().getDefaultConversion());\n+    return value.map(o -> {\n+      if (o instanceof LocalDateTime) {\n+        return DateTimeUtil.microsFromTimestamp((LocalDateTime) o);\n+      } else if (o instanceof Instant) {\n+        return DateTimeUtil.microsFromInstant((Instant) o);\n+      } else if (o instanceof LocalTime) {\n+        return DateTimeUtil.microsFromTime((LocalTime) o);\n+      } else if (o instanceof LocalDate) {\n+        return DateTimeUtil.daysFromDate((LocalDate) o);\n+      }\n+\n+      return o;\n+    });\n+  }\n+\n+  private static boolean literalOnRight(List<ResolvedExpression> args) {\n+    return args.get(0) instanceof FieldReferenceExpression && args.get(1) instanceof ValueLiteralExpression;\n+  }\n+\n+  private static Tuple2<String, Object> convertBinaryExpress(CallExpression call) {", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0NzIzNQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553147235", "bodyText": "For the flink's Binary data type,  its default java type is  byte[],  while the iceberg's BinaryLiteral  will use ByteBuffer.    So we will need to convert it to ByteBuffer ?", "author": "openinx", "createdAt": "2021-01-07T07:14:16Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, Expressions::isNaN, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, Expressions::notNaN, call);\n+\n+        case NOT:\n+          Optional<Expression> child = convert(singleton(call, CallExpression.class).orElse(null));\n+          return child.map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> singleton(CallExpression call,\n+                                                                      Class<T> expectedChildClass) {\n+    List<ResolvedExpression> children = call.getResolvedChildren();\n+    if (children.size() != 1) {\n+      return Optional.empty();\n+    }\n+\n+    ResolvedExpression child = children.get(0);\n+    if (!expectedChildClass.isInstance(child)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(expectedChildClass.cast(child));\n+  }\n+\n+  private static Optional<Expression> convertLike(CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String pattern = tuple2.f1.toString();\n+    Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n+\n+    // exclude special char of LIKE\n+    // '_' is the wildcard of the SQL LIKE\n+    if (!pattern.contains(\"_\") && matcher.matches()) {\n+      return Optional.of(Expressions.startsWith(tuple2.f0, matcher.group(1)));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(\n+      BiFunction<String, Object, Expression> function, BiFunction<String, Object, Expression> reversedFunction,\n+      CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 != null) {\n+      if (literalOnRight(call.getResolvedChildren())) {\n+        return Optional.of(function.apply(tuple2.f0, tuple2.f1));\n+      } else {\n+        return Optional.of(reversedFunction.apply(tuple2.f0, tuple2.f1));\n+      }\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static Optional<String> toReference(org.apache.flink.table.expressions.Expression expression) {\n+    return expression instanceof FieldReferenceExpression ?\n+        Optional.of(((FieldReferenceExpression) expression).getName()) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Object> toLiteral(org.apache.flink.table.expressions.Expression expression) {\n+    // Not support null literal\n+    return expression instanceof ValueLiteralExpression ?\n+        convertLiteral((ValueLiteralExpression) expression) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Expression> handleNaN(BiFunction<String, Object, Expression> function,\n+                                                Function<String, Expression> functionNaN,\n+                                                CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String name = tuple2.f0;\n+    Object value = tuple2.f1;\n+\n+    if (NaNUtil.isNaN(value)) {\n+      return Optional.of(functionNaN.apply(name));\n+    } else {\n+      return Optional.of(function.apply(name, value));\n+    }\n+  }\n+\n+  private static Optional<Object> convertLiteral(ValueLiteralExpression expression) {\n+    Optional<?> value = expression.getValueAs(expression.getOutputDataType().getLogicalType().getDefaultConversion());\n+    return value.map(o -> {\n+      if (o instanceof LocalDateTime) {", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0NzUxNQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553147515", "bodyText": "Pls see the iceberg expression literal types here : https://github.com/apache/iceberg/blob/master/api/src/main/java/org/apache/iceberg/types/Type.java#L30", "author": "openinx", "createdAt": "2021-01-07T07:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0NzIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0OTc0Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553149743", "bodyText": "If the literal type of flink is BINARY or VARBINARY,   then its java data type is  byte[],  while in iceberg we will use ByteBuffer to do the literal comparison.  So I think we need to convert it to ByteBuffer by ByteBuffer.wrap((byte[])o) .  Otherwise the iceberg literal comparing will throw a cast failure .\nPls see the java data type for iceberg type  here: https://github.com/apache/iceberg/blob/master/api/src/main/java/org/apache/iceberg/types/Type.java#L30\nBy the way,  I think you unit tests here https://github.com/apache/iceberg/pull/1893/files#diff-5d18d1ff127d1dc70a9a15bbe941f2b6f9d28b3015924f601ac1f722914099dbR81 is incorrect.", "author": "openinx", "createdAt": "2021-01-07T07:21:34Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IN, Operation.IN)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, Expressions::isNaN, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, Expressions::notNaN, call);\n+\n+        case NOT:\n+          Optional<Expression> child = convert(singleton(call, CallExpression.class).orElse(null));\n+          return child.map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> singleton(CallExpression call,\n+                                                                      Class<T> expectedChildClass) {\n+    List<ResolvedExpression> children = call.getResolvedChildren();\n+    if (children.size() != 1) {\n+      return Optional.empty();\n+    }\n+\n+    ResolvedExpression child = children.get(0);\n+    if (!expectedChildClass.isInstance(child)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(expectedChildClass.cast(child));\n+  }\n+\n+  private static Optional<Expression> convertLike(CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String pattern = tuple2.f1.toString();\n+    Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n+\n+    // exclude special char of LIKE\n+    // '_' is the wildcard of the SQL LIKE\n+    if (!pattern.contains(\"_\") && matcher.matches()) {\n+      return Optional.of(Expressions.startsWith(tuple2.f0, matcher.group(1)));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(\n+      BiFunction<String, Object, Expression> function, BiFunction<String, Object, Expression> reversedFunction,\n+      CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 != null) {\n+      if (literalOnRight(call.getResolvedChildren())) {\n+        return Optional.of(function.apply(tuple2.f0, tuple2.f1));\n+      } else {\n+        return Optional.of(reversedFunction.apply(tuple2.f0, tuple2.f1));\n+      }\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static Optional<String> toReference(org.apache.flink.table.expressions.Expression expression) {\n+    return expression instanceof FieldReferenceExpression ?\n+        Optional.of(((FieldReferenceExpression) expression).getName()) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Object> toLiteral(org.apache.flink.table.expressions.Expression expression) {\n+    // Not support null literal\n+    return expression instanceof ValueLiteralExpression ?\n+        convertLiteral((ValueLiteralExpression) expression) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Expression> handleNaN(BiFunction<String, Object, Expression> function,\n+                                                Function<String, Expression> functionNaN,\n+                                                CallExpression call) {\n+    Tuple2<String, Object> tuple2 = convertBinaryExpress(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String name = tuple2.f0;\n+    Object value = tuple2.f1;\n+\n+    if (NaNUtil.isNaN(value)) {\n+      return Optional.of(functionNaN.apply(name));\n+    } else {\n+      return Optional.of(function.apply(name, value));\n+    }\n+  }\n+\n+  private static Optional<Object> convertLiteral(ValueLiteralExpression expression) {\n+    Optional<?> value = expression.getValueAs(expression.getOutputDataType().getLogicalType().getDefaultConversion());\n+    return value.map(o -> {\n+      if (o instanceof LocalDateTime) {\n+        return DateTimeUtil.microsFromTimestamp((LocalDateTime) o);\n+      } else if (o instanceof Instant) {\n+        return DateTimeUtil.microsFromInstant((Instant) o);\n+      } else if (o instanceof LocalTime) {\n+        return DateTimeUtil.microsFromTime((LocalTime) o);\n+      } else if (o instanceof LocalDate) {\n+        return DateTimeUtil.daysFromDate((LocalDate) o);", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcyNDMyMQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553724321", "bodyText": "I  checkout the code ,I found that iceberg already do the convertion, (here) ,so I did not add the conversion here.", "author": "zhangjun0x01", "createdAt": "2021-01-08T03:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0OTc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzk4MDI5OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553980299", "bodyText": "OK,  that make sense.", "author": "openinx", "createdAt": "2021-01-08T14:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE0OTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1ODgwOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553158808", "bodyText": "In this matchLiteral testing method,  we will provide both flink's java data type and iceberg's java data type ( for asserting).   I think it's not a good way to test those literals because if people don't quite understand what's the specific java data type that iceberg type is mapping,   then he may provide the wrong iceberg's java type to assert.  The BINARY type is an example.", "author": "openinx", "createdAt": "2021-01-07T07:46:54Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.flink.table.api.Expressions.$;\n+import static org.apache.flink.table.api.Expressions.lit;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(10))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_TIME_ZONE())\n+      .field(\"field13\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MDIyMQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553160221", "bodyText": "I think the correct way to validate the flink-iceberg type mapping is:  for each data type,  providing a EQUAL expression and then use the FlinkFilters convert it to iceberg filters,  finally call the BoundLiteralPredicate#test to see the EQUALS return the expected true,  if yes, then the data type mapping MUST be correct.", "author": "openinx", "createdAt": "2021-01-07T07:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1ODgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcxMTQ4NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553711485", "bodyText": "I updated it", "author": "zhangjun0x01", "createdAt": "2021-01-08T02:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE1ODgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MTE4OA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553161188", "bodyText": "It's good to have test cases for all other data types except Integer.  I guess we may need few abstraction so that the test code won't duplicate too many.", "author": "openinx", "createdAt": "2021-01-07T07:53:23Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.flink.table.api.Expressions.$;\n+import static org.apache.flink.table.api.Expressions.lit;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(10))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_TIME_ZONE())\n+      .field(\"field13\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, new byte[] {'a', 'b'});\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+\n+    matchLiteral(\"field13\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1);\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isEqual(Expressions.lit(1)))).orElse(null);\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isEqual(Expressions.$(\"field1\")))).orElse(null);\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.isNaN(\"field3\");\n+\n+    org.apache.iceberg.expressions.Expression actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isEqual(Expressions.lit(Float.NaN)))).orElse(null);\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual);\n+\n+    org.apache.iceberg.expressions.Expression actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isEqual(Expressions.$(\"field3\")))).orElse(null);\n+    assertPredicatesMatch(expected, (UnboundPredicate) actual1);\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.notEqual(\"field1\", 1);", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcxMTA0MQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553711041", "bodyText": "I added all type test for testNotEquals  and testEquals", "author": "zhangjun0x01", "createdAt": "2021-01-08T02:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MTE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MzUxOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553163519", "bodyText": "Asserting that the explain contains FilterPushDown does not have much meaning because all explained string will contains that word ( see the IcebergTableSource#explainSource ).   The key part to assert is the last part:\nString.format(\", FilterPushDown,the filters :%s\", Joiner.on(\",\").join(filters));\nI mean we need to assert  Joiner.on(\",\").join(filters) part ( for all the following cases).", "author": "openinx", "createdAt": "2021-01-07T07:59:04Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +95,396 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n     Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, mixedResult.size());\n+    assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcxMDQxOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553710419", "bodyText": "I updated all", "author": "zhangjun0x01", "createdAt": "2021-01-08T02:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MzUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2NTY0Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553165643", "bodyText": "Nit:  we could just use the assertEquals for two lists, don't have to convert it to array and then use assertArrayEquals ?", "author": "openinx", "createdAt": "2021-01-07T08:04:31Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +95,396 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n     Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, mixedResult.size());\n+    assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    assertTrue(\"explain should contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcxMDM3Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553710377", "bodyText": "I has tested that , if we use assertEquals for two lists,it will be failed, so I convert the list to array.", "author": "zhangjun0x01", "createdAt": "2021-01-08T02:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2NTY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2NjA4Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r553166082", "bodyText": "nit: If we use the static imported assertEquals before then we don't use Assert.assertEquals here ?  Make them to be unified.", "author": "openinx", "createdAt": "2021-01-07T08:05:35Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +95,396 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n     Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, mixedResult.size());\n+    assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    assertTrue(\"explain should contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"Should push down expected filter\", \"id = 1\", FlinkUtil.describe(lastScanEvent.filter()));", "originalCommit": "f96e8a3e86dce66300a996b3e5ea76916e426816", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "246144b8b131fc0329205805a0c9840dc7d6495e", "url": "https://github.com/apache/iceberg/commit/246144b8b131fc0329205805a0c9840dc7d6495e", "message": "fix  issues", "committedDate": "2021-01-08T02:41:46Z", "type": "forcePushed"}, {"oid": "c3b928c314f03a76a6e3c3448adab27dfa8c567f", "url": "https://github.com/apache/iceberg/commit/c3b928c314f03a76a6e3c3448adab27dfa8c567f", "message": "fix  issues", "committedDate": "2021-01-08T03:34:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk3Nzc1MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556977750", "bodyText": "I don't think that Expression needs to be fully-qualified.", "author": "rdblue", "createdAt": "2021-01-14T01:04:19Z", "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionsUtil.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.expressions;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class ExpressionsUtil {\n+  private ExpressionsUtil() {\n+  }\n+\n+  public static String describe(org.apache.iceberg.expressions.Expression expr) {", "originalCommit": "c3b928c314f03a76a6e3c3448adab27dfa8c567f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk3Nzg5Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556977893", "bodyText": "Could you also add Javadoc to this method?", "author": "rdblue", "createdAt": "2021-01-14T01:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk3Nzc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk3ODM1MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556978350", "bodyText": "Nit: \"convert\" should be capitalized because it begins a sentence.", "author": "rdblue", "createdAt": "2021-01-14T01:06:17Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.", "originalCommit": "c3b928c314f03a76a6e3c3448adab27dfa8c567f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk3ODYxOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556978618", "bodyText": "Nits: missing a space in the list and the next sentence isn't capitalized.", "author": "rdblue", "createdAt": "2021-01-14T01:07:12Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically. the BETWEEN will be converted to", "originalCommit": "c3b928c314f03a76a6e3c3448adab27dfa8c567f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4MzQ5NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556983495", "bodyText": "I don't think that this should pass null to toReference. It works because toReference does an instanceof check, but it isn't obvious that null is expected there.\nI think it would be better to use flatMap to run toReference if the FieldReferenceExpression is defined.", "author": "rdblue", "createdAt": "2021-01-14T01:22:09Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));", "originalCommit": "c3b928c314f03a76a6e3c3448adab27dfa8c567f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk5MTE5OA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556991198", "bodyText": "Actually, since the type is already known there is no need to use toReference at all. This can call name directly:\n          return onlyChildAs(call, FieldReferenceExpression.class)\n              .map(FieldReferenceExpression::getName)\n              .map(Expressions::isNull);", "author": "rdblue", "createdAt": "2021-01-14T01:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4MzQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4NTEzOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556985138", "bodyText": "I don't think that this method name is enough to see what's going on from reading it. How about a name like childAs or onlyChildAs? That makes it clear that the call's child will be returned and that there should be only one.", "author": "rdblue", "createdAt": "2021-01-14T01:27:27Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, Expressions::isNaN, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, Expressions::notNaN, call);\n+\n+        case NOT:\n+          Optional<Expression> child = convert(singleton(call, CallExpression.class).orElse(null));\n+          return child.map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> singleton(CallExpression call,", "originalCommit": "c3b928c314f03a76a6e3c3448adab27dfa8c567f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4NTc5NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556985794", "bodyText": "If this is going to access children from this list directly using get(1) then it should also check that there are exactly 2 children.", "author": "rdblue", "createdAt": "2021-01-14T01:29:09Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * convert flink expression to iceberg expression.\n+   * <p>\n+   * The BETWEEN, NOT_BETWEEN,IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, Expressions::isNaN, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, Expressions::notNaN, call);\n+\n+        case NOT:\n+          Optional<Expression> child = convert(singleton(call, CallExpression.class).orElse(null));\n+          return child.map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> singleton(CallExpression call,\n+                                                                      Class<T> expectedChildClass) {\n+    List<ResolvedExpression> children = call.getResolvedChildren();\n+    if (children.size() != 1) {\n+      return Optional.empty();\n+    }\n+\n+    ResolvedExpression child = children.get(0);\n+    if (!expectedChildClass.isInstance(child)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(expectedChildClass.cast(child));\n+  }\n+\n+  private static Optional<Expression> convertLike(CallExpression call) {\n+    Tuple2<String, Object> tuple2 = parseFieldAndLiteral(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String pattern = tuple2.f1.toString();\n+    Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n+\n+    // exclude special char of LIKE\n+    // '_' is the wildcard of the SQL LIKE\n+    if (!pattern.contains(\"_\") && matcher.matches()) {\n+      return Optional.of(Expressions.startsWith(tuple2.f0, matcher.group(1)));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();", "originalCommit": "c3b928c314f03a76a6e3c3448adab27dfa8c567f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk5NjIxOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556996219", "bodyText": "If we enter this method, it means that it is a legal logic expression,  if we add a judgment, it is indeed safer", "author": "zhangjun0x01", "createdAt": "2021-01-14T02:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4NTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk5MjI4Ng==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r556992286", "bodyText": "Similar to above, this shouldn't use orElse(null):\n          return onlyChildAs(call, CallExpression.class).flatMap(FlinkFilters::convert).map(Expressions::not);", "author": "rdblue", "createdAt": "2021-01-14T01:49:27Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * Convert flink expression to iceberg expression.\n+   * <p>\n+   * the BETWEEN, NOT_BETWEEN, IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, Expressions::isNaN, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, Expressions::notNaN, call);\n+\n+        case NOT:\n+          Optional<Expression> child = convert(singleton(call, CallExpression.class).orElse(null));", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAwMDIxMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557000212", "bodyText": "I think that this class can be cleaned up by rewriting this method. I think this was intended to make reuse easier, but rewriting this allows removing several methods (literalOnRight, convertComparisonExpression, handleNaN, toReference, and toLiteral), gets rid of the strange method contract where Tuple2 and null are used, and also ensures that instanceof checks are done in just one place, rather than with multiple calls to literalOnRight.\nHere's what I rewrote it to:\n  private static Optional<Expression> convertFieldAndLiteral(BiFunction<String, Object, Expression> expr,\n                                                             CallExpression call) {\n    return convertFieldAndLiteral(expr, expr, call);\n  }\n\n  private static Optional<Expression> convertFieldAndLiteral(\n      BiFunction<String, Object, Expression> convertLR, BiFunction<String, Object, Expression> convertRL,\n      CallExpression call) {\n    List<ResolvedExpression> args = call.getResolvedChildren();\n    if (args.size() != 2) {\n      return Optional.empty();\n    }\n\n    org.apache.flink.table.expressions.Expression left = args.get(0);\n    org.apache.flink.table.expressions.Expression right = args.get(1);\n\n    if (left instanceof FieldReferenceExpression && right instanceof ValueLiteralExpression) {\n      String name = ((FieldReferenceExpression) left).getName();\n      Object lit = convertLiteral((ValueLiteralExpression) right);\n      return Optional.of(convertLR.apply(name, lit));\n\n    } else if (left instanceof ValueLiteralExpression && right instanceof FieldReferenceExpression) {\n      Object lit = convertLiteral((ValueLiteralExpression) left);\n      String name = ((FieldReferenceExpression) right).getName();\n      return Optional.of(convertRL.apply(name, lit));\n    }\n\n    return Optional.empty();\n  }\nThe comparison cases in the switch statement can then call this directly:\n      switch (op) {\n        case LT:\n          return convertFieldAndLiteral(Expressions::lessThan, Expressions::greaterThan, call);\n\n        case LT_EQ:\n          return convertFieldAndLiteral(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n\n        case GT:\n          return convertFieldAndLiteral(Expressions::greaterThan, Expressions::lessThan, call);\n\n        case GT_EQ:\n          return convertFieldAndLiteral(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n\n        case EQ:\n          return convertFieldAndLiteral((ref, lit) -> {\n            if (NaNUtil.isNaN(lit)) {\n              return Expressions.isNaN(ref);\n            } else {\n              return Expressions.equal(ref, lit);\n            }\n          }, call);\n\n        case NOT_EQ:\n          return convertFieldAndLiteral((ref, lit) -> {\n            if (NaNUtil.isNaN(lit)) {\n              return Expressions.notNaN(ref);\n            } else {\n              return Expressions.notEqual(ref, lit);\n            }\n          }, call);\nThe only problem is that convertLike can't call this. But that's okay because I don't think the reversed form of LIKE is actually supported anyway (\"a%\" LIKE col is not allowed, right?).\nSo I also rewrote convertLike:\n  private static Optional<Expression> convertLike(CallExpression call) {\n    List<ResolvedExpression> args = call.getResolvedChildren();\n    if (args.size() != 2) {\n      return Optional.empty();\n    }\n\n    org.apache.flink.table.expressions.Expression left = args.get(0);\n    org.apache.flink.table.expressions.Expression right = args.get(1);\n\n    if (left instanceof FieldReferenceExpression && right instanceof ValueLiteralExpression) {\n      String name = ((FieldReferenceExpression) left).getName();\n      return convertLiteral((ValueLiteralExpression) right).flatMap(lit -> {\n        if (lit instanceof String) {\n          String pattern = (String) lit;\n          Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n          // exclude special char of LIKE\n          // '_' is the wildcard of the SQL LIKE\n          if (!pattern.contains(\"_\") && matcher.matches()) {\n            return Optional.of(Expressions.startsWith(name, matcher.group(1)));\n          }\n        }\n\n        return Optional.empty();\n      });\n    }\n\n    return Optional.empty();\n  }", "author": "rdblue", "createdAt": "2021-01-14T02:15:36Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * Convert flink expression to iceberg expression.\n+   * <p>\n+   * the BETWEEN, NOT_BETWEEN, IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          Optional<String> name = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return name.map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          Optional<String> nameNotNull = toReference(singleton(call, FieldReferenceExpression.class).orElse(null));\n+          return nameNotNull.map(Expressions::notNull);\n+\n+        case LT:\n+          return convertComparisonExpression(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertComparisonExpression(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertComparisonExpression(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertComparisonExpression(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return handleNaN(Expressions::equal, Expressions::isNaN, call);\n+\n+        case NOT_EQ:\n+          return handleNaN(Expressions::notEqual, Expressions::notNaN, call);\n+\n+        case NOT:\n+          Optional<Expression> child = convert(singleton(call, CallExpression.class).orElse(null));\n+          return child.map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> singleton(CallExpression call,\n+                                                                      Class<T> expectedChildClass) {\n+    List<ResolvedExpression> children = call.getResolvedChildren();\n+    if (children.size() != 1) {\n+      return Optional.empty();\n+    }\n+\n+    ResolvedExpression child = children.get(0);\n+    if (!expectedChildClass.isInstance(child)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(expectedChildClass.cast(child));\n+  }\n+\n+  private static Optional<Expression> convertLike(CallExpression call) {\n+    Tuple2<String, Object> tuple2 = parseFieldAndLiteral(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String pattern = tuple2.f1.toString();\n+    Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n+\n+    // exclude special char of LIKE\n+    // '_' is the wildcard of the SQL LIKE\n+    if (!pattern.contains(\"_\") && matcher.matches()) {\n+      return Optional.of(Expressions.startsWith(tuple2.f0, matcher.group(1)));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertComparisonExpression(\n+      BiFunction<String, Object, Expression> function, BiFunction<String, Object, Expression> reversedFunction,\n+      CallExpression call) {\n+    Tuple2<String, Object> tuple2 = parseFieldAndLiteral(call);\n+    if (tuple2 != null) {\n+      if (literalOnRight(call.getResolvedChildren())) {\n+        return Optional.of(function.apply(tuple2.f0, tuple2.f1));\n+      } else {\n+        return Optional.of(reversedFunction.apply(tuple2.f0, tuple2.f1));\n+      }\n+    } else {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static Optional<String> toReference(org.apache.flink.table.expressions.Expression expression) {\n+    return expression instanceof FieldReferenceExpression ?\n+        Optional.of(((FieldReferenceExpression) expression).getName()) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Object> toLiteral(org.apache.flink.table.expressions.Expression expression) {\n+    // Not support null literal\n+    return expression instanceof ValueLiteralExpression ?\n+        convertLiteral((ValueLiteralExpression) expression) :\n+        Optional.empty();\n+  }\n+\n+  private static Optional<Expression> handleNaN(BiFunction<String, Object, Expression> function,\n+                                                Function<String, Expression> functionNaN,\n+                                                CallExpression call) {\n+    Tuple2<String, Object> tuple2 = parseFieldAndLiteral(call);\n+    if (tuple2 == null) {\n+      return Optional.empty();\n+    }\n+\n+    String name = tuple2.f0;\n+    Object value = tuple2.f1;\n+\n+    if (NaNUtil.isNaN(value)) {\n+      return Optional.of(functionNaN.apply(name));\n+    } else {\n+      return Optional.of(function.apply(name, value));\n+    }\n+  }\n+\n+  private static Optional<Object> convertLiteral(ValueLiteralExpression expression) {\n+    Optional<?> value = expression.getValueAs(expression.getOutputDataType().getLogicalType().getDefaultConversion());\n+    return value.map(o -> {\n+      if (o instanceof LocalDateTime) {\n+        return DateTimeUtil.microsFromTimestamp((LocalDateTime) o);\n+      } else if (o instanceof Instant) {\n+        return DateTimeUtil.microsFromInstant((Instant) o);\n+      } else if (o instanceof LocalTime) {\n+        return DateTimeUtil.microsFromTime((LocalTime) o);\n+      } else if (o instanceof LocalDate) {\n+        return DateTimeUtil.daysFromDate((LocalDate) o);\n+      }\n+\n+      return o;\n+    });\n+  }\n+\n+  private static boolean literalOnRight(List<ResolvedExpression> args) {\n+    return args.get(0) instanceof FieldReferenceExpression && args.get(1) instanceof ValueLiteralExpression;\n+  }\n+\n+  private static Tuple2<String, Object> parseFieldAndLiteral(CallExpression call) {", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAwMDkwOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557000909", "bodyText": "@zhangjun0x01, I've posted my rewrite of this class here so you don't have to apply all the changes: https://gist.github.com/rdblue/486bd03df873a2094305025920f94498", "author": "rdblue", "createdAt": "2021-01-14T02:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAwMDIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAwMTI5NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557001295", "bodyText": "Expressions should not be plural. It should be ExpressionUtil instead.", "author": "rdblue", "createdAt": "2021-01-14T02:18:34Z", "path": "api/src/main/java/org/apache/iceberg/expressions/ExpressionsUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.expressions;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class ExpressionsUtil {", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNjAyMA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557016020", "bodyText": "Please remove these imports. The project's style is to use Assert.assertEquals and not import static methods in general. This also caused a lot of unnecessary changes.", "author": "rdblue", "createdAt": "2021-01-14T03:10:16Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -19,26 +19,36 @@\n \n package org.apache.iceberg.flink;\n \n-\n import java.util.List;\n import org.apache.flink.table.api.SqlParserException;\n import org.apache.iceberg.AssertHelpers;\n import org.apache.iceberg.FileFormat;\n import org.apache.iceberg.catalog.Namespace;\n+import org.apache.iceberg.events.Listeners;\n+import org.apache.iceberg.events.ScanEvent;\n+import org.apache.iceberg.expressions.ExpressionsUtil;\n import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n import org.junit.After;\n-import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n \n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNjA1OA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557016058", "bodyText": "I don't think this line needed to change.", "author": "rdblue", "createdAt": "2021-01-14T03:10:25Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +95,436 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n-    Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNjg4Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557016887", "bodyText": "It looks like describe was moved just for tests. I don't think that was needed. If you need to produce a string from an expression, why not just use toString? That's what other assertions use, like the one for explainExpected above.\nCan you try reverting the describe change?", "author": "rdblue", "createdAt": "2021-01-14T03:13:28Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -75,32 +95,436 @@ public void clean() {\n \n   @Test\n   public void testLimitPushDown() {\n-    sql(\"INSERT INTO %s  VALUES (1,'a'),(2,'b')\", TABLE_NAME);\n-\n     String querySql = String.format(\"SELECT * FROM %s LIMIT 1\", TABLE_NAME);\n     String explain = getTableEnv().explainSql(querySql);\n     String expectedExplain = \"LimitPushDown : 1\";\n-    Assert.assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n+    assertTrue(\"explain should contains LimitPushDown\", explain.contains(expectedExplain));\n     List<Object[]> result = sql(querySql);\n-    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected records\", result.get(0), new Object[] {1, \"a\"});\n \n     AssertHelpers.assertThrows(\"Invalid limit number: -1 \", SqlParserException.class,\n         () -> sql(\"SELECT * FROM %s LIMIT -1\", TABLE_NAME));\n \n-    Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n+    assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n-    Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n+    expectedList.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n-    Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n-    Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+    assertEquals(\"should have 1 record\", 1, mixedResult.size());\n+    assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n+  }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String explainExpected = \"FilterPushDown,the filters :ref(name=\\\"id\\\") == 1]]], fields=[id, data])\";\n+    assertTrue(\"explain should contains FilterPushDown\", explain.contains(explainExpected));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    assertEquals(\"should have 1 record\", 1, result.size());\n+    assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    assertEquals(\"Should push down expected filter\", \"id = 1\", ExpressionsUtil.describe(lastScanEvent.filter()));\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    assertFalse(\"explain should not contains FilterPushDown\", explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String explainExpected = \"FilterPushDown,the filters :ref(name=\\\"id\\\") == 1]]], fields=[id, data])\";\n+    assertTrue(\"explain should contains FilterPushDown\", explainLeft.contains(explainExpected));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    assertEquals(\"Should push down expected filter\", \"id = 1\", ExpressionsUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String explainExpected = \"FilterPushDown,the filters :ref(name=\\\"id\\\") != 1]]], fields=[id, data])\";\n+    assertTrue(\"explain should contains FilterPushDown\", explainNE.contains(explainExpected));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    assertEquals(\"should have 2 record\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    assertEquals(\"Should push down expected filter\", \"id != 1\", ExpressionsUtil.describe(lastScanEvent.filter()));\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'a' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String explainExpected =\n+        \"FilterPushDown,the filters :ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"a\\\"]]], fields=[id, data])\";\n+    assertTrue(\"explain should contains FilterPushDown\", explainAnd.contains(explainExpected));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    assertEquals(\"should have 1 record\", 1, resultAnd.size());\n+    assertArrayEquals(\"Should produce the expected record\", resultAnd.get(0), new Object[] {1, \"a\"});\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    assertEquals(\"Should push down expected filter\", \"(id = 1 AND data = 'a')\",\n+        ExpressionsUtil.describe(lastScanEvent.filter()));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String explainExpected =\n+        \"FilterPushDown,the filters :(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")]]], fields=[id, data])\";\n+    assertTrue(\"explain should contains FilterPushDown\", explainOr.contains(explainExpected));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    assertEquals(\"should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"a\"});\n+    expectedOR.add(new Object[] {2, \"b\"});\n+    assertArrayEquals(\"Should produce the expected record\", resultOr.toArray(), expectedOR.toArray());\n+\n+    assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    assertEquals(\"Should push down expected filter\", \"(id = 1 OR data = 'b')\",\n+        ExpressionsUtil.describe(lastScanEvent.filter()));", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNzI5NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557017294", "bodyText": "Can you please remove the static imports?", "author": "rdblue", "createdAt": "2021-01-14T03:14:52Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Test;\n+\n+import static org.apache.flink.table.api.Expressions.$;\n+import static org.apache.flink.table.api.Expressions.lit;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNzUxMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557017512", "bodyText": "Is there a more descriptive name than LIST? What are these used for?", "author": "rdblue", "createdAt": "2021-01-14T03:15:33Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Test;\n+\n+import static org.apache.flink.table.api.Expressions.$;\n+import static org.apache.flink.table.api.Expressions.lit;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  private static final List<Tuple2<String, Object>> LIST = ImmutableList.of(", "originalCommit": "0331d4923f15d6af157d27aa704cd2c3d9c5596c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "url": "https://github.com/apache/iceberg/commit/9417e9d241b873918dcbdfb4e8c17c5b30aed027", "message": "fix some issues", "committedDate": "2021-01-14T07:36:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzNjAwNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557536004", "bodyText": "Why not use lit.map instead of putting the if here?", "author": "rdblue", "createdAt": "2021-01-14T16:42:51Z", "path": "flink/src/main/java/org/apache/iceberg/flink/FlinkFilters.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.flink.table.functions.FunctionDefinition;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expression.Operation;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.apache.iceberg.util.NaNUtil;\n+\n+public class FlinkFilters {\n+  private FlinkFilters() {\n+  }\n+\n+  private static final Pattern STARTS_WITH_PATTERN = Pattern.compile(\"([^%]+)%\");\n+\n+  private static final Map<FunctionDefinition, Operation> FILTERS = ImmutableMap\n+      .<FunctionDefinition, Operation>builder()\n+      .put(BuiltInFunctionDefinitions.EQUALS, Operation.EQ)\n+      .put(BuiltInFunctionDefinitions.NOT_EQUALS, Operation.NOT_EQ)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN, Operation.GT)\n+      .put(BuiltInFunctionDefinitions.GREATER_THAN_OR_EQUAL, Operation.GT_EQ)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN, Operation.LT)\n+      .put(BuiltInFunctionDefinitions.LESS_THAN_OR_EQUAL, Operation.LT_EQ)\n+      .put(BuiltInFunctionDefinitions.IS_NULL, Operation.IS_NULL)\n+      .put(BuiltInFunctionDefinitions.IS_NOT_NULL, Operation.NOT_NULL)\n+      .put(BuiltInFunctionDefinitions.AND, Operation.AND)\n+      .put(BuiltInFunctionDefinitions.OR, Operation.OR)\n+      .put(BuiltInFunctionDefinitions.NOT, Operation.NOT)\n+      .put(BuiltInFunctionDefinitions.LIKE, Operation.STARTS_WITH)\n+      .build();\n+\n+  /**\n+   * Convert flink expression to iceberg expression.\n+   * <p>\n+   * the BETWEEN, NOT_BETWEEN, IN expression will be converted by flink automatically. the BETWEEN will be converted to\n+   * (GT_EQ AND LT_EQ), the NOT_BETWEEN will be converted to (LT_EQ OR GT_EQ), the IN will be converted to OR, so we do\n+   * not add the conversion here\n+   *\n+   * @param flinkExpression the flink expression\n+   * @return the iceberg expression\n+   */\n+  public static Optional<Expression> convert(org.apache.flink.table.expressions.Expression flinkExpression) {\n+    if (!(flinkExpression instanceof CallExpression)) {\n+      return Optional.empty();\n+    }\n+\n+    CallExpression call = (CallExpression) flinkExpression;\n+    Operation op = FILTERS.get(call.getFunctionDefinition());\n+    if (op != null) {\n+      switch (op) {\n+        case IS_NULL:\n+          return onlyChildAs(call, FieldReferenceExpression.class)\n+              .map(FieldReferenceExpression::getName)\n+              .map(Expressions::isNull);\n+\n+        case NOT_NULL:\n+          return onlyChildAs(call, FieldReferenceExpression.class)\n+              .map(FieldReferenceExpression::getName)\n+              .map(Expressions::notNull);\n+\n+        case LT:\n+          return convertFieldAndLiteral(Expressions::lessThan, Expressions::greaterThan, call);\n+\n+        case LT_EQ:\n+          return convertFieldAndLiteral(Expressions::lessThanOrEqual, Expressions::greaterThanOrEqual, call);\n+\n+        case GT:\n+          return convertFieldAndLiteral(Expressions::greaterThan, Expressions::lessThan, call);\n+\n+        case GT_EQ:\n+          return convertFieldAndLiteral(Expressions::greaterThanOrEqual, Expressions::lessThanOrEqual, call);\n+\n+        case EQ:\n+          return convertFieldAndLiteral((ref, lit) -> {\n+            if (NaNUtil.isNaN(lit)) {\n+              return Expressions.isNaN(ref);\n+            } else {\n+              return Expressions.equal(ref, lit);\n+            }\n+          }, call);\n+\n+        case NOT_EQ:\n+          return convertFieldAndLiteral((ref, lit) -> {\n+            if (NaNUtil.isNaN(lit)) {\n+              return Expressions.notNaN(ref);\n+            } else {\n+              return Expressions.notEqual(ref, lit);\n+            }\n+          }, call);\n+\n+        case NOT:\n+          return onlyChildAs(call, CallExpression.class).flatMap(FlinkFilters::convert).map(Expressions::not);\n+\n+        case AND:\n+          return convertLogicExpression(Expressions::and, call);\n+\n+        case OR:\n+          return convertLogicExpression(Expressions::or, call);\n+\n+        case STARTS_WITH:\n+          return convertLike(call);\n+      }\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static <T extends ResolvedExpression> Optional<T> onlyChildAs(CallExpression call,\n+                                                                        Class<T> expectedChildClass) {\n+    List<ResolvedExpression> children = call.getResolvedChildren();\n+    if (children.size() != 1) {\n+      return Optional.empty();\n+    }\n+\n+    ResolvedExpression child = children.get(0);\n+    if (!expectedChildClass.isInstance(child)) {\n+      return Optional.empty();\n+    }\n+\n+    return Optional.of(expectedChildClass.cast(child));\n+  }\n+\n+  private static Optional<Expression> convertLike(CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    if (args.size() != 2) {\n+      return Optional.empty();\n+    }\n+\n+    org.apache.flink.table.expressions.Expression left = args.get(0);\n+    org.apache.flink.table.expressions.Expression right = args.get(1);\n+\n+    if (left instanceof FieldReferenceExpression && right instanceof ValueLiteralExpression) {\n+      String name = ((FieldReferenceExpression) left).getName();\n+      return convertLiteral((ValueLiteralExpression) right).flatMap(lit -> {\n+        if (lit instanceof String) {\n+          String pattern = (String) lit;\n+          Matcher matcher = STARTS_WITH_PATTERN.matcher(pattern);\n+          // exclude special char of LIKE\n+          // '_' is the wildcard of the SQL LIKE\n+          if (!pattern.contains(\"_\") && matcher.matches()) {\n+            return Optional.of(Expressions.startsWith(name, matcher.group(1)));\n+          }\n+        }\n+\n+        return Optional.empty();\n+      });\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Expression> convertLogicExpression(BiFunction<Expression, Expression, Expression> function,\n+                                                             CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    if (args == null || args.size() != 2) {\n+      return Optional.empty();\n+    }\n+\n+    Optional<Expression> left = convert(args.get(0));\n+    Optional<Expression> right = convert(args.get(1));\n+    if (left.isPresent() && right.isPresent()) {\n+      return Optional.of(function.apply(left.get(), right.get()));\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Object> convertLiteral(ValueLiteralExpression expression) {\n+    Optional<?> value = expression.getValueAs(expression.getOutputDataType().getLogicalType().getDefaultConversion());\n+    return value.map(o -> {\n+      if (o instanceof LocalDateTime) {\n+        return DateTimeUtil.microsFromTimestamp((LocalDateTime) o);\n+      } else if (o instanceof Instant) {\n+        return DateTimeUtil.microsFromInstant((Instant) o);\n+      } else if (o instanceof LocalTime) {\n+        return DateTimeUtil.microsFromTime((LocalTime) o);\n+      } else if (o instanceof LocalDate) {\n+        return DateTimeUtil.daysFromDate((LocalDate) o);\n+      }\n+\n+      return o;\n+    });\n+  }\n+\n+  private static Optional<Expression> convertFieldAndLiteral(BiFunction<String, Object, Expression> expr,\n+                                                             CallExpression call) {\n+    return convertFieldAndLiteral(expr, expr, call);\n+  }\n+\n+  private static Optional<Expression> convertFieldAndLiteral(\n+      BiFunction<String, Object, Expression> convertLR, BiFunction<String, Object, Expression> convertRL,\n+      CallExpression call) {\n+    List<ResolvedExpression> args = call.getResolvedChildren();\n+    if (args.size() != 2) {\n+      return Optional.empty();\n+    }\n+\n+    org.apache.flink.table.expressions.Expression left = args.get(0);\n+    org.apache.flink.table.expressions.Expression right = args.get(1);\n+\n+    if (left instanceof FieldReferenceExpression && right instanceof ValueLiteralExpression) {\n+      String name = ((FieldReferenceExpression) left).getName();\n+      Optional<Object> lit = convertLiteral((ValueLiteralExpression) right);\n+      if (lit.isPresent()) {\n+        return Optional.of(convertLR.apply(name, lit.get()));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg0MjQ5NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558842494", "bodyText": "Optional#map method required a Function param, but this method provide a BiFunction param,so I use if to do the judgment", "author": "zhangjun0x01", "createdAt": "2021-01-16T11:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzNjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzNzgyNA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557537824", "bodyText": "Nit: typos in this message. Can you change the string to \", FilterPushDown: %s\"? Also, the joiner should be a static final constant and should use \", \" to separate the filters.", "author": "rdblue", "createdAt": "2021-01-14T16:45:18Z", "path": "flink/src/main/java/org/apache/iceberg/flink/IcebergTableSource.java", "diffHunk": "@@ -112,6 +120,10 @@ public String explainSource() {\n       explain += String.format(\", LimitPushDown : %d\", limit);\n     }\n \n+    if (isFilterPushedDown()) {\n+      explain += String.format(\", FilterPushDown,the filters :%s\", Joiner.on(\",\").join(filters));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MjQ3NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557542475", "bodyText": "@openinx, is this guaranteed to only be called on a source that has not had predicates pushed? This ignores the existing predicates in this source. Maybe we should add a precondition to check that assumption.\nI think it is safe either way because this doesn't remove any predicates from the list. From reading the Javadoc, I think that will result in all predicates running in Flink also.", "author": "rdblue", "createdAt": "2021-01-14T16:51:33Z", "path": "flink/src/main/java/org/apache/iceberg/flink/IcebergTableSource.java", "diffHunk": "@@ -122,6 +134,21 @@ public boolean isLimitPushedDown() {\n \n   @Override\n   public TableSource<RowData> applyLimit(long newLimit) {\n-    return new IcebergTableSource(loader, schema, properties, projectedFields, true, newLimit);\n+    return new IcebergTableSource(loader, schema, properties, projectedFields, true, newLimit, filters);\n+  }\n+\n+  @Override\n+  public TableSource<RowData> applyPredicate(List<Expression> predicates) {\n+    List<org.apache.iceberg.expressions.Expression> expressions = Lists.newArrayList();\n+    for (Expression predicate : predicates) {\n+      FlinkFilters.convert(predicate).ifPresent(expressions::add);\n+    }\n+\n+    return new IcebergTableSource(loader, schema, properties, projectedFields, isLimitPushDown, limit, expressions);", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MzAzNg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557543036", "bodyText": "Why was this change needed?", "author": "rdblue", "createdAt": "2021-01-14T16:52:21Z", "path": "flink/src/test/java/org/apache/iceberg/flink/FlinkTestBase.java", "diffHunk": "@@ -73,15 +73,15 @@ protected TableEnvironment getTableEnv() {\n   }\n \n   protected static TableResult exec(TableEnvironment env, String query, Object... args) {\n-    return env.executeSql(String.format(query, args));\n+    return env.executeSql(args.length > 0 ? String.format(query, args) : query);", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwMjY2Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557802667", "bodyText": "if the sql contains % , for example LIKE  'a%', the String.format method will throws an excpetion, so I do the change.", "author": "zhangjun0x01", "createdAt": "2021-01-15T01:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MzAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNTYwOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557815608", "bodyText": "You can use %% in a format string to produce a literal %.\nI think it would be better not to change this file, if it isn't necessary.", "author": "rdblue", "createdAt": "2021-01-15T02:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MzAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzg4MDAyMw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557880023", "bodyText": "ok,I will reverting it", "author": "zhangjun0x01", "createdAt": "2021-01-15T06:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MzAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MzQ1Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557543457", "bodyText": "I think that this change is correct, but I don't see why it was necessary in this commit. Wouldn't all of the tests run the same way without modifying this file at all?", "author": "rdblue", "createdAt": "2021-01-14T16:52:57Z", "path": "flink/src/test/java/org/apache/iceberg/flink/FlinkTestBase.java", "diffHunk": "@@ -73,15 +73,15 @@ protected TableEnvironment getTableEnv() {\n   }\n \n   protected static TableResult exec(TableEnvironment env, String query, Object... args) {\n-    return env.executeSql(String.format(query, args));\n+    return env.executeSql(args.length > 0 ? String.format(query, args) : query);\n   }\n \n   protected TableResult exec(String query, Object... args) {\n     return exec(getTableEnv(), query, args);\n   }\n \n   protected List<Object[]> sql(String query, Object... args) {\n-    TableResult tableResult = exec(String.format(query, args));\n+    TableResult tableResult = exec(query, args);", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwNDA4OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557804089", "bodyText": "the LIKE sql in test case will call this method, I think it is maybe a small mistake, so I update it   to pass the original parameters query, args, in the final method exec(TableEnvironment env, String query, Object... args) to do the format", "author": "zhangjun0x01", "createdAt": "2021-01-15T01:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MzQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyODcyOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558228728", "bodyText": "I remove the  return env.executeSql(args.length > 0 ? String.format(query, args) : query); from exec method, but if we retain the String.format in sql(String query, Object... args) method ,the sql will still be formatted twice\uff0ceven though we use the %% , the sql also is formated failed", "author": "zhangjun0x01", "createdAt": "2021-01-15T10:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU0MzQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1MTYxOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557551619", "bodyText": "Assertions should have context so that when one fails it is clear what went wrong. In this case, the assertion is testing that converting succeeded. So this should be Assert.assertTrue(\"Conversion should succeed\", actual.isPresent())", "author": "rdblue", "createdAt": "2021-01-14T17:04:39Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Tuple2.of(\"field1\", 1),\n+      Tuple2.of(\"field2\", 2L),\n+      Tuple2.of(\"field3\", 3F),\n+      Tuple2.of(\"field4\", 4D),\n+      Tuple2.of(\"field5\", \"iceberg\"),\n+      Tuple2.of(\"field6\", true),\n+      Tuple2.of(\"field7\", new byte[] {'a', 'b'}),\n+      Tuple2.of(\"field8\", BigDecimal.valueOf(10)),\n+      Tuple2.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Tuple2.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Tuple2.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Tuple2.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.equal(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.isNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.notEqual(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isNotEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isNotEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testNotEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.notNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isNotEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isNotEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreater(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLess(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreaterOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLessOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLess(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreater(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLessOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreaterOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testIsNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.isNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testIsNotNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNotNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.notNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testAnd() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).and(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    And and = (And) actual.get();\n+    And expected = (And) org.apache.iceberg.expressions.Expressions.and(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), and.op());\n+    Assert.assertEquals(expected.left().op(), and.left().op());\n+    Assert.assertEquals(expected.right().op(), and.right().op());\n+  }\n+\n+  @Test\n+  public void testOr() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).or(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Or or = (Or) actual.get();\n+    Or expected = (Or) org.apache.iceberg.expressions.Expressions.or(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), or.op());\n+    Assert.assertEquals(expected.left().op(), or.left().op());\n+    Assert.assertEquals(expected.right().op(), or.right().op());\n+  }\n+\n+  @Test\n+  public void testNot() {\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.NOT, Expressions.$(\"field1\").isEqual(Expressions.lit(1))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Not not = (Not) actual.get();\n+    Not expected = (Not) org.apache.iceberg.expressions.Expressions.not(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1));\n+\n+    Assert.assertEquals(expected.op(), not.op());\n+    assertPredicatesMatch((UnboundPredicate<?>) expected.child(), (UnboundPredicate<?>) not.child());\n+  }\n+\n+  @Test\n+  public void testLike() {\n+    UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.startsWith(\"field5\", \"abc\");\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.LIKE, Expressions.$(\"field5\"), Expressions.lit(\"abc%\")));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  private void matchLiteral(String fieldName, Object flinkLiteral, Object icebergLiteral) {\n+    Expression expr = resolve(Expressions.$(fieldName).isEqual(Expressions.lit(flinkLiteral)));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1MTg5Ng==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557551896", "bodyText": "BoundLiteralPredicate is a parameterized type, so it should have parameters here.", "author": "rdblue", "createdAt": "2021-01-14T17:05:04Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Tuple2.of(\"field1\", 1),\n+      Tuple2.of(\"field2\", 2L),\n+      Tuple2.of(\"field3\", 3F),\n+      Tuple2.of(\"field4\", 4D),\n+      Tuple2.of(\"field5\", \"iceberg\"),\n+      Tuple2.of(\"field6\", true),\n+      Tuple2.of(\"field7\", new byte[] {'a', 'b'}),\n+      Tuple2.of(\"field8\", BigDecimal.valueOf(10)),\n+      Tuple2.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Tuple2.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Tuple2.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Tuple2.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.equal(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.isNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.notEqual(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isNotEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isNotEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testNotEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.notNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isNotEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isNotEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreater(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLess(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreaterOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLessOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLess(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreater(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLessOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreaterOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testIsNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.isNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testIsNotNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNotNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.notNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testAnd() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).and(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    And and = (And) actual.get();\n+    And expected = (And) org.apache.iceberg.expressions.Expressions.and(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), and.op());\n+    Assert.assertEquals(expected.left().op(), and.left().op());\n+    Assert.assertEquals(expected.right().op(), and.right().op());\n+  }\n+\n+  @Test\n+  public void testOr() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).or(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Or or = (Or) actual.get();\n+    Or expected = (Or) org.apache.iceberg.expressions.Expressions.or(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), or.op());\n+    Assert.assertEquals(expected.left().op(), or.left().op());\n+    Assert.assertEquals(expected.right().op(), or.right().op());\n+  }\n+\n+  @Test\n+  public void testNot() {\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.NOT, Expressions.$(\"field1\").isEqual(Expressions.lit(1))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Not not = (Not) actual.get();\n+    Not expected = (Not) org.apache.iceberg.expressions.Expressions.not(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1));\n+\n+    Assert.assertEquals(expected.op(), not.op());\n+    assertPredicatesMatch((UnboundPredicate<?>) expected.child(), (UnboundPredicate<?>) not.child());\n+  }\n+\n+  @Test\n+  public void testLike() {\n+    UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.startsWith(\"field5\", \"abc\");\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.LIKE, Expressions.$(\"field5\"), Expressions.lit(\"abc%\")));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  private void matchLiteral(String fieldName, Object flinkLiteral, Object icebergLiteral) {\n+    Expression expr = resolve(Expressions.$(fieldName).isEqual(Expressions.lit(flinkLiteral)));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+\n+    BoundLiteralPredicate predicate =", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODIyNTE4NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558225185", "bodyText": "yes, BoundLiteralPredicate is a parameterized type, but I define the param icebergLiteral as Object type used to accept various types of values,if we change BoundLiteralPredicate to BoundLiteralPredicate<?> , the predicate.test method will throw an exception: Cannot resolve method 'test(java.lang.Object)'", "author": "zhangjun0x01", "createdAt": "2021-01-15T10:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1MTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDQ3NQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558990475", "bodyText": "To solve that problem, you can parameterize the method, like this:\n  @SuppressWarnings(\"unchecked\")\n  private <T> void matchLiteral(String fieldName, Object flinkLiteral, T icebergLiteral) {\n    Expression expr = resolve(Expressions.$(fieldName).isEqual(Expressions.lit(flinkLiteral)));\n    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n    Assert.assertTrue(\"Conversion should succeed\", actual.isPresent());\n\n    BoundLiteralPredicate<T> predicate = (BoundLiteralPredicate<T>)\n        ((UnboundPredicate<T>) actual.get()).bind(FlinkSchemaUtil.convert(TABLE_SCHEMA).asStruct(), false);\n    Assert.assertTrue(predicate.test(icebergLiteral));\n  }", "author": "rdblue", "createdAt": "2021-01-16T18:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1MTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1Mzg2Ng==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557553866", "bodyText": "These assertions also need context strings to identify which part of the predicate is tested, like \"Predicate operation should match\"", "author": "rdblue", "createdAt": "2021-01-14T17:07:57Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Tuple2.of(\"field1\", 1),\n+      Tuple2.of(\"field2\", 2L),\n+      Tuple2.of(\"field3\", 3F),\n+      Tuple2.of(\"field4\", 4D),\n+      Tuple2.of(\"field5\", \"iceberg\"),\n+      Tuple2.of(\"field6\", true),\n+      Tuple2.of(\"field7\", new byte[] {'a', 'b'}),\n+      Tuple2.of(\"field8\", BigDecimal.valueOf(10)),\n+      Tuple2.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Tuple2.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Tuple2.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Tuple2.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.equal(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.isNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.notEqual(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isNotEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isNotEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testNotEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.notNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isNotEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isNotEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreater(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLess(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreaterOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLessOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLess(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreater(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLessOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreaterOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testIsNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.isNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testIsNotNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNotNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.notNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testAnd() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).and(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    And and = (And) actual.get();\n+    And expected = (And) org.apache.iceberg.expressions.Expressions.and(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), and.op());\n+    Assert.assertEquals(expected.left().op(), and.left().op());\n+    Assert.assertEquals(expected.right().op(), and.right().op());\n+  }\n+\n+  @Test\n+  public void testOr() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).or(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Or or = (Or) actual.get();\n+    Or expected = (Or) org.apache.iceberg.expressions.Expressions.or(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), or.op());\n+    Assert.assertEquals(expected.left().op(), or.left().op());\n+    Assert.assertEquals(expected.right().op(), or.right().op());\n+  }\n+\n+  @Test\n+  public void testNot() {\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.NOT, Expressions.$(\"field1\").isEqual(Expressions.lit(1))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Not not = (Not) actual.get();\n+    Not expected = (Not) org.apache.iceberg.expressions.Expressions.not(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1));\n+\n+    Assert.assertEquals(expected.op(), not.op());\n+    assertPredicatesMatch((UnboundPredicate<?>) expected.child(), (UnboundPredicate<?>) not.child());\n+  }\n+\n+  @Test\n+  public void testLike() {\n+    UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.startsWith(\"field5\", \"abc\");\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.LIKE, Expressions.$(\"field5\"), Expressions.lit(\"abc%\")));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  private void matchLiteral(String fieldName, Object flinkLiteral, Object icebergLiteral) {\n+    Expression expr = resolve(Expressions.$(fieldName).isEqual(Expressions.lit(flinkLiteral)));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+\n+    BoundLiteralPredicate predicate =\n+        (BoundLiteralPredicate<?>) ((UnboundPredicate<?>) actual.get())\n+            .bind(FlinkSchemaUtil.convert(TABLE_SCHEMA).asStruct(), false);\n+    Assert.assertTrue(predicate.test(icebergLiteral));\n+  }\n+\n+  private static Expression resolve(Expression originalExpression) {\n+    return originalExpression.accept(new ApiExpressionDefaultVisitor<Expression>() {\n+      @Override\n+      public Expression visit(UnresolvedReferenceExpression unresolvedReference) {\n+        String name = unresolvedReference.getName();\n+        Optional<TableColumn> field = TABLE_SCHEMA.getTableColumn(name);\n+        if (field.isPresent()) {\n+          int index = TABLE_SCHEMA.getTableColumns().indexOf(field.get());\n+          return new FieldReferenceExpression(name, field.get().getType(), 0, index);\n+        } else {\n+          return null;\n+        }\n+      }\n+\n+      @Override\n+      public Expression visit(UnresolvedCallExpression unresolvedCall) {\n+        List<ResolvedExpression> children =\n+            unresolvedCall.getChildren().stream().map(e -> (ResolvedExpression) e.accept(this))\n+                .collect(Collectors.toList());\n+        return new CallExpression(unresolvedCall.getFunctionDefinition(), children, DataTypes.STRING());\n+      }\n+\n+      @Override\n+      public Expression visit(ValueLiteralExpression valueLiteral) {\n+        return valueLiteral;\n+      }\n+\n+      @Override\n+      protected Expression defaultMethod(Expression expression) {\n+        throw new UnsupportedOperationException(String.format(\"unsupported expression: %s\", expression));\n+      }\n+    });\n+  }\n+\n+  private void assertPredicatesMatch(UnboundPredicate<?> expected, UnboundPredicate<?> actual) {\n+    Assert.assertEquals(expected.op(), actual.op());\n+    Assert.assertEquals(expected.literal(), actual.literal());\n+    Assert.assertEquals(expected.ref().name(), actual.ref().name());", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1NDgwOQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557554809", "bodyText": "valueOf creates a decimal with a scale of 0, but the type's scale is 2. Can you create a big decimal that matches the type?", "author": "rdblue", "createdAt": "2021-01-14T17:09:17Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Tuple2.of(\"field1\", 1),\n+      Tuple2.of(\"field2\", 2L),\n+      Tuple2.of(\"field3\", 3F),\n+      Tuple2.of(\"field4\", 4D),\n+      Tuple2.of(\"field5\", \"iceberg\"),\n+      Tuple2.of(\"field6\", true),\n+      Tuple2.of(\"field7\", new byte[] {'a', 'b'}),\n+      Tuple2.of(\"field8\", BigDecimal.valueOf(10)),\n+      Tuple2.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Tuple2.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Tuple2.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Tuple2.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1NTM0Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557555343", "bodyText": "Could you update this to use the Iceberg Pair class instead?", "author": "rdblue", "createdAt": "2021-01-14T17:10:07Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1NjQ5MQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557556491", "bodyText": "It would be better to check the cast instead of failing tests with ClassCastException if the wrong class is returned. Could you update assertPredicatesMatch to accept actual as an Expression and add an instanceof assertion in that method?", "author": "rdblue", "createdAt": "2021-01-14T17:11:53Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Tuple2.of(\"field1\", 1),\n+      Tuple2.of(\"field2\", 2L),\n+      Tuple2.of(\"field3\", 3F),\n+      Tuple2.of(\"field4\", 4D),\n+      Tuple2.of(\"field5\", \"iceberg\"),\n+      Tuple2.of(\"field6\", true),\n+      Tuple2.of(\"field7\", new byte[] {'a', 'b'}),\n+      Tuple2.of(\"field8\", BigDecimal.valueOf(10)),\n+      Tuple2.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Tuple2.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Tuple2.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Tuple2.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.equal(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1ODk0NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557558944", "bodyText": "I think these should use assertPredicatesMatch instead of just checking the operation.", "author": "rdblue", "createdAt": "2021-01-14T17:15:45Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Tuple2.of(\"field1\", 1),\n+      Tuple2.of(\"field2\", 2L),\n+      Tuple2.of(\"field3\", 3F),\n+      Tuple2.of(\"field4\", 4D),\n+      Tuple2.of(\"field5\", \"iceberg\"),\n+      Tuple2.of(\"field6\", true),\n+      Tuple2.of(\"field7\", new byte[] {'a', 'b'}),\n+      Tuple2.of(\"field8\", BigDecimal.valueOf(10)),\n+      Tuple2.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Tuple2.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Tuple2.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Tuple2.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.equal(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.isNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.notEqual(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isNotEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isNotEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testNotEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.notNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isNotEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isNotEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreater(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLess(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreaterOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLessOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLess(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreater(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLessOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreaterOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testIsNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.isNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testIsNotNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNotNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.notNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testAnd() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).and(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    And and = (And) actual.get();\n+    And expected = (And) org.apache.iceberg.expressions.Expressions.and(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), and.op());\n+    Assert.assertEquals(expected.left().op(), and.left().op());\n+    Assert.assertEquals(expected.right().op(), and.right().op());\n+  }\n+\n+  @Test\n+  public void testOr() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).or(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Or or = (Or) actual.get();\n+    Or expected = (Or) org.apache.iceberg.expressions.Expressions.or(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), or.op());\n+    Assert.assertEquals(expected.left().op(), or.left().op());", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MDE4Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557560182", "bodyText": "This suite also needs negative tests for LIKE with different wildcard locations:\n\nThe pattern is \"%abc\"\nThe pattern is \"%abc%\"\nThe pattern is \"abc%d\"\nThe pattern is \"%\"", "author": "rdblue", "createdAt": "2021-01-14T17:17:33Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkFilters.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.flink;\n+\n+import java.math.BigDecimal;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.api.Expressions;\n+import org.apache.flink.table.api.TableColumn;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.expressions.ApiExpressionUtils;\n+import org.apache.flink.table.expressions.CallExpression;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.FieldReferenceExpression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.expressions.UnresolvedCallExpression;\n+import org.apache.flink.table.expressions.UnresolvedReferenceExpression;\n+import org.apache.flink.table.expressions.ValueLiteralExpression;\n+import org.apache.flink.table.expressions.utils.ApiExpressionDefaultVisitor;\n+import org.apache.flink.table.functions.BuiltInFunctionDefinitions;\n+import org.apache.iceberg.expressions.And;\n+import org.apache.iceberg.expressions.BoundLiteralPredicate;\n+import org.apache.iceberg.expressions.Not;\n+import org.apache.iceberg.expressions.Or;\n+import org.apache.iceberg.expressions.UnboundPredicate;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.util.DateTimeUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestFlinkFilters {\n+\n+  private static final TableSchema TABLE_SCHEMA = TableSchema.builder()\n+      .field(\"field1\", DataTypes.INT())\n+      .field(\"field2\", DataTypes.BIGINT())\n+      .field(\"field3\", DataTypes.FLOAT())\n+      .field(\"field4\", DataTypes.DOUBLE())\n+      .field(\"field5\", DataTypes.STRING())\n+      .field(\"field6\", DataTypes.BOOLEAN())\n+      .field(\"field7\", DataTypes.BINARY(2))\n+      .field(\"field8\", DataTypes.DECIMAL(10, 2))\n+      .field(\"field9\", DataTypes.DATE())\n+      .field(\"field10\", DataTypes.TIME())\n+      .field(\"field11\", DataTypes.TIMESTAMP())\n+      .field(\"field12\", DataTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE())\n+      .build();\n+\n+  // A map list of fields and values used to verify the conversion of flink expression to iceberg expression\n+  private static final List<Tuple2<String, Object>> FIELD_VALUE_LIST = ImmutableList.of(\n+      Tuple2.of(\"field1\", 1),\n+      Tuple2.of(\"field2\", 2L),\n+      Tuple2.of(\"field3\", 3F),\n+      Tuple2.of(\"field4\", 4D),\n+      Tuple2.of(\"field5\", \"iceberg\"),\n+      Tuple2.of(\"field6\", true),\n+      Tuple2.of(\"field7\", new byte[] {'a', 'b'}),\n+      Tuple2.of(\"field8\", BigDecimal.valueOf(10)),\n+      Tuple2.of(\"field9\", DateTimeUtil.daysFromDate(LocalDate.now())),\n+      Tuple2.of(\"field10\", DateTimeUtil.microsFromTime(LocalTime.now())),\n+      Tuple2.of(\"field11\", DateTimeUtil.microsFromTimestamp(LocalDateTime.now())),\n+      Tuple2.of(\"field12\", DateTimeUtil.microsFromInstant(Instant.now()))\n+  );\n+\n+  @Test\n+  public void testFlinkDataTypeEqual() {\n+    matchLiteral(\"field1\", 1, 1);\n+    matchLiteral(\"field2\", 10L, 10L);\n+    matchLiteral(\"field3\", 1.2F, 1.2F);\n+    matchLiteral(\"field4\", 3.4D, 3.4D);\n+    matchLiteral(\"field5\", \"abcd\", \"abcd\");\n+    matchLiteral(\"field6\", true, true);\n+    matchLiteral(\"field7\", new byte[] {'a', 'b'}, ByteBuffer.wrap(new byte[] {'a', 'b'}));\n+    matchLiteral(\"field8\", BigDecimal.valueOf(10), BigDecimal.valueOf(10));\n+\n+    LocalDate date = LocalDate.parse(\"2020-12-23\");\n+    matchLiteral(\"field9\", date, DateTimeUtil.daysFromDate(date));\n+\n+    LocalTime time = LocalTime.parse(\"12:13:14\");\n+    matchLiteral(\"field10\", time, DateTimeUtil.microsFromTime(time));\n+\n+    LocalDateTime dateTime = LocalDateTime.parse(\"2020-12-23T12:13:14\");\n+    matchLiteral(\"field11\", dateTime, DateTimeUtil.microsFromTimestamp(dateTime));\n+\n+    Instant instant = Instant.parse(\"2020-12-23T12:13:14.00Z\");\n+    matchLiteral(\"field12\", instant, DateTimeUtil.microsFromInstant(instant));\n+  }\n+\n+  @Test\n+  public void testEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.equal(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.isNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testNotEquals() {\n+    for (Tuple2<String, Object> tuple2 : FIELD_VALUE_LIST) {\n+      UnboundPredicate<?> expected = org.apache.iceberg.expressions.Expressions.notEqual(tuple2.f0, tuple2.f1);\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual =\n+          FlinkFilters.convert(resolve(Expressions.$(tuple2.f0).isNotEqual(Expressions.lit(tuple2.f1))));\n+      Assert.assertTrue(actual.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+      Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+          FlinkFilters.convert(resolve(Expressions.lit(tuple2.f1).isNotEqual(Expressions.$(tuple2.f0))));\n+      Assert.assertTrue(actual1.isPresent());\n+      assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+    }\n+  }\n+\n+  @Test\n+  public void testNotEqualsNaN() {\n+    UnboundPredicate<Float> expected = org.apache.iceberg.expressions.Expressions.notNaN(\"field3\");\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field3\").isNotEqual(Expressions.lit(Float.NaN))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(Float.NaN).isNotEqual(Expressions.$(\"field3\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreater(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLess(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testGreaterThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.greaterThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isGreaterOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isLessOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThan() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThan(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLess(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreater(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testLessThanEquals() {\n+    UnboundPredicate<Integer> expected = org.apache.iceberg.expressions.Expressions.lessThanOrEqual(\"field1\", 1);\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual =\n+        FlinkFilters.convert(resolve(Expressions.$(\"field1\").isLessOrEqual(Expressions.lit(1))));\n+    Assert.assertTrue(actual.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+\n+    Optional<org.apache.iceberg.expressions.Expression> actual1 =\n+        FlinkFilters.convert(resolve(Expressions.lit(1).isGreaterOrEqual(Expressions.$(\"field1\"))));\n+    Assert.assertTrue(actual1.isPresent());\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual1.get());\n+  }\n+\n+  @Test\n+  public void testIsNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.isNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testIsNotNull() {\n+    Expression expr = resolve(Expressions.$(\"field1\").isNotNull());\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    UnboundPredicate<Object> expected = org.apache.iceberg.expressions.Expressions.notNull(\"field1\");\n+    assertPredicatesMatch(expected, (UnboundPredicate<?>) actual.get());\n+  }\n+\n+  @Test\n+  public void testAnd() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).and(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    And and = (And) actual.get();\n+    And expected = (And) org.apache.iceberg.expressions.Expressions.and(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), and.op());\n+    Assert.assertEquals(expected.left().op(), and.left().op());\n+    Assert.assertEquals(expected.right().op(), and.right().op());\n+  }\n+\n+  @Test\n+  public void testOr() {\n+    Expression expr = resolve(\n+        Expressions.$(\"field1\").isEqual(Expressions.lit(1)).or(Expressions.$(\"field2\").isEqual(Expressions.lit(2L))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Or or = (Or) actual.get();\n+    Or expected = (Or) org.apache.iceberg.expressions.Expressions.or(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1),\n+        org.apache.iceberg.expressions.Expressions.equal(\"field2\", 2L));\n+\n+    Assert.assertEquals(expected.op(), or.op());\n+    Assert.assertEquals(expected.left().op(), or.left().op());\n+    Assert.assertEquals(expected.right().op(), or.right().op());\n+  }\n+\n+  @Test\n+  public void testNot() {\n+    Expression expr = resolve(ApiExpressionUtils.unresolvedCall(\n+        BuiltInFunctionDefinitions.NOT, Expressions.$(\"field1\").isEqual(Expressions.lit(1))));\n+    Optional<org.apache.iceberg.expressions.Expression> actual = FlinkFilters.convert(expr);\n+    Assert.assertTrue(actual.isPresent());\n+    Not not = (Not) actual.get();\n+    Not expected = (Not) org.apache.iceberg.expressions.Expressions.not(\n+        org.apache.iceberg.expressions.Expressions.equal(\"field1\", 1));\n+\n+    Assert.assertEquals(expected.op(), not.op());\n+    assertPredicatesMatch((UnboundPredicate<?>) expected.child(), (UnboundPredicate<?>) not.child());\n+  }\n+\n+  @Test\n+  public void testLike() {", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNTc1Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557815753", "bodyText": "Also, could you test the wildcard behavior with _?", "author": "rdblue", "createdAt": "2021-01-15T02:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MDE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg0MTk4Mg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558841982", "bodyText": "I add the test case (link) ,and add the sql test case (link)", "author": "zhangjun0x01", "createdAt": "2021-01-16T11:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MDE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MDg0OQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557560849", "bodyText": "Typo: should be \"should not contain\"", "author": "rdblue", "createdAt": "2021-01-14T17:18:26Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MTI4Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557561287", "bodyText": "Thank you, these assertions look better now.", "author": "rdblue", "createdAt": "2021-01-14T17:19:08Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MTg1Mw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557561853", "bodyText": "This should also test that the scan event had no filter if a scan event was created.", "author": "rdblue", "createdAt": "2021-01-14T17:19:59Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MjgzMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557562832", "bodyText": "This should also check the scan event.", "author": "rdblue", "createdAt": "2021-01-14T17:21:32Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MzEwNg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557563106", "bodyText": "Nit: this newline isn't needed.", "author": "rdblue", "createdAt": "2021-01-14T17:21:57Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'a' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"a\\\"\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultAnd.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert\n+        .assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"a\\\")\",", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNDMwMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557814302", "bodyText": "If we put it in one line, it will exceed the max limit of checkstyle, I extract the expected filter to a single string.", "author": "zhangjun0x01", "createdAt": "2021-01-15T01:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNTg5MA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557815890", "bodyText": "Please wrap the line at the start of the expected string instead.", "author": "rdblue", "createdAt": "2021-01-15T02:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MzY3NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557563674", "bodyText": "The expected value comes first so that assertion failures show the right labels. If this failed, the actual filter would be shown as the expected filter.", "author": "rdblue", "createdAt": "2021-01-14T17:22:50Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg0MTg1Nw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558841857", "bodyText": "I updated all", "author": "zhangjun0x01", "createdAt": "2021-01-16T11:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2MzY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2NDc4Ng==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557564786", "bodyText": "Needs to check the scan event.", "author": "rdblue", "createdAt": "2021-01-14T17:24:37Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'a' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"a\\\"\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultAnd.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert\n+        .assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"a\\\")\",\n+            lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainOr.contains(expectedFilter));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"a\"});\n+    expectedOR.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultOr.toArray(), expectedOR.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    expectedGT.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanLiteralOnLeft() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE 3 > id \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {1, \"a\"});\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    expectedGTE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualLiteralOnLeft() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE 2 >= id \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {1, \"a\"});\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanLiteralOnLeft() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE 2 < id \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualLiteralOnLeft() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE 3 <= id  \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"id\\\") == 2)\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainIN.contains(expectedFilter));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultIN.size());\n+\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"a\"});\n+    expectedIN.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultIN.toArray(), expectedIN.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // in with null will not push down\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE id IN (1,2,NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainInNull.contains(expectedFilterPushDownExplain));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2NDkyMg==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557564922", "bodyText": "Needs to check the scan event.", "author": "rdblue", "createdAt": "2021-01-14T17:24:51Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'a' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"a\\\"\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultAnd.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert\n+        .assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"a\\\")\",\n+            lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainOr.contains(expectedFilter));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"a\"});\n+    expectedOR.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultOr.toArray(), expectedOR.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    expectedGT.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanLiteralOnLeft() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE 3 > id \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {1, \"a\"});\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    expectedGTE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualLiteralOnLeft() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE 2 >= id \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {1, \"a\"});\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanLiteralOnLeft() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE 2 < id \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualLiteralOnLeft() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE 3 <= id  \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"id\\\") == 2)\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainIN.contains(expectedFilter));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultIN.size());\n+\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"a\"});\n+    expectedIN.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultIN.toArray(), expectedIN.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // in with null will not push down\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE id IN (1,2,NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainInNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotIn() {\n+    String sqlNotIn = String.format(\"SELECT * FROM %s WHERE id NOT IN (3,2) \", TABLE_NAME);\n+    String explainNotIn = getTableEnv().explainSql(sqlNotIn);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 3,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNotIn.contains(expectedFilter));\n+\n+    List<Object[]> resultNotIn = sql(sqlNotIn);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultNotIn.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNotIn.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") != 3 and ref(name=\\\"id\\\") != 2)\",\n+        lastScanEvent.filter().toString());\n+\n+    String sqlNotInNull = String.format(\"SELECT * FROM %s WHERE id NOT IN (1,2,NULL) \", TABLE_NAME);\n+    String explainNotInNull = getTableEnv().explainSql(sqlNotInNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainNotInNull.contains(expectedFilterPushDownExplain));", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2NjM1NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557566354", "bodyText": "It looks like Flink is rewriting the expression to notEq. Is there a test case where the not is passed to Iceberg? Maybe using a complex expression like not(or(eq(\"id\", 1), eq(\"id\", 2)))", "author": "rdblue", "createdAt": "2021-01-14T17:27:03Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'a' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"a\\\"\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultAnd.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert\n+        .assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"a\\\")\",\n+            lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainOr.contains(expectedFilter));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"a\"});\n+    expectedOR.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultOr.toArray(), expectedOR.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    expectedGT.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanLiteralOnLeft() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE 3 > id \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {1, \"a\"});\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    expectedGTE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualLiteralOnLeft() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE 2 >= id \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {1, \"a\"});\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanLiteralOnLeft() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE 2 < id \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualLiteralOnLeft() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE 3 <= id  \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"id\\\") == 2)\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainIN.contains(expectedFilter));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultIN.size());\n+\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"a\"});\n+    expectedIN.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultIN.toArray(), expectedIN.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // in with null will not push down\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE id IN (1,2,NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainInNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotIn() {\n+    String sqlNotIn = String.format(\"SELECT * FROM %s WHERE id NOT IN (3,2) \", TABLE_NAME);\n+    String explainNotIn = getTableEnv().explainSql(sqlNotIn);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 3,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNotIn.contains(expectedFilter));\n+\n+    List<Object[]> resultNotIn = sql(sqlNotIn);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultNotIn.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNotIn.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") != 3 and ref(name=\\\"id\\\") != 2)\",\n+        lastScanEvent.filter().toString());\n+\n+    String sqlNotInNull = String.format(\"SELECT * FROM %s WHERE id NOT IN (1,2,NULL) \", TABLE_NAME);\n+    String explainNotInNull = getTableEnv().explainSql(sqlNotInNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainNotInNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNotNull() {\n+    String sqlNotNull = String.format(\"SELECT * FROM %s WHERE data IS NOT NULL\", TABLE_NAME);\n+    String explainNotNull = getTableEnv().explainSql(sqlNotNull);\n+    String expectedFilter = \"not_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNotNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNotNull = sql(sqlNotNull);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNotNull.size());\n+\n+    List<Object[]> expected = Lists.newArrayList();\n+    expected.add(new Object[] {1, \"a\"});\n+    expected.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNotNull.toArray(), expected.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNull() {\n+    String sqlNull = String.format(\"SELECT * FROM %s WHERE data IS  NULL\", TABLE_NAME);\n+    String explainNull = getTableEnv().explainSql(sqlNull);\n+    String expectedFilter = \"is_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNull = sql(sqlNull);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultNull.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNull.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNot() {", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODg0MTgwMA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r558841800", "bodyText": "I update it", "author": "zhangjun0x01", "createdAt": "2021-01-16T11:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2NjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2OTQ2NA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557569464", "bodyText": "@zhangjun0x01, I think this suite also needs to test the behavior of a few more cases to ensure that the assumptions about Flink's parser hold. Even if these result in parser errors, those are good tests to have to validate that if Flink ever does support parsing the expressions, Iceberg will do the right thing.\n\ndouble_col = NaN\ndouble_col <> NaN\nAll inequalities with NaN, like double_col < NaN\nAll inequalities with null, like data < null", "author": "rdblue", "createdAt": "2021-01-14T17:31:36Z", "path": "flink/src/test/java/org/apache/iceberg/flink/TestFlinkTableSource.java", "diffHunk": "@@ -90,17 +103,418 @@ public void testLimitPushDown() {\n \n     Assert.assertEquals(\"should have 0 record\", 0, sql(\"SELECT * FROM %s LIMIT 0\", TABLE_NAME).size());\n \n-    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 3\", TABLE_NAME);\n+    String sqlLimitExceed = String.format(\"SELECT * FROM %s LIMIT 4\", TABLE_NAME);\n     List<Object[]> resultExceed = sql(sqlLimitExceed);\n-    Assert.assertEquals(\"should have 2 record\", 2, resultExceed.size());\n+    Assert.assertEquals(\"should have 3 record\", 3, resultExceed.size());\n     List<Object[]> expectedList = Lists.newArrayList();\n     expectedList.add(new Object[] {1, \"a\"});\n     expectedList.add(new Object[] {2, \"b\"});\n+    expectedList.add(new Object[] {3, null});\n     Assert.assertArrayEquals(\"Should produce the expected records\", resultExceed.toArray(), expectedList.toArray());\n \n     String sqlMixed = String.format(\"SELECT * FROM %s WHERE id = 1 LIMIT 2\", TABLE_NAME);\n     List<Object[]> mixedResult = sql(sqlMixed);\n     Assert.assertEquals(\"should have 1 record\", 1, mixedResult.size());\n     Assert.assertArrayEquals(\"Should produce the expected records\", mixedResult.get(0), new Object[] {1, \"a\"});\n   }\n+\n+  @Test\n+  public void testNoFilterPushDown() {\n+    String sql = String.format(\"SELECT * FROM %s \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sql);\n+    Assert.assertFalse(\"explain should no contains FilterPushDown\", explain.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqual() {\n+    String sqlLiteralRight = String.format(\"SELECT * FROM %s WHERE id = 1 \", TABLE_NAME);\n+    String explain = getTableEnv().explainSql(sqlLiteralRight);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explain.contains(expectedFilter));\n+\n+    List<Object[]> result = sql(sqlLiteralRight);\n+    Assert.assertEquals(\"should have 1 record\", 1, result.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", result.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // filter not push down\n+    String sqlEqualNull = String.format(\"SELECT * FROM %s WHERE data = NULL \", TABLE_NAME);\n+    String explainEqualNull = getTableEnv().explainSql(sqlEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainEqualNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownEqualLiteralOnLeft() {\n+    String sqlLiteralLeft = String.format(\"SELECT * FROM %s WHERE 1 = id \", TABLE_NAME);\n+    String explainLeft = getTableEnv().explainSql(sqlLiteralLeft);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLeft.contains(expectedFilter));\n+\n+    List<Object[]> resultLeft = sql(sqlLiteralLeft);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLeft.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLeft.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNoEqual() {\n+    String sqlNE = String.format(\"SELECT * FROM %s WHERE id <> 1 \", TABLE_NAME);\n+    String explainNE = getTableEnv().explainSql(sqlNE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNE.contains(expectedFilter));\n+\n+    List<Object[]> resultNE = sql(sqlNE);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNE.size());\n+\n+    List<Object[]> expectedNE = Lists.newArrayList();\n+    expectedNE.add(new Object[] {2, \"b\"});\n+    expectedNE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNE.toArray(), expectedNE.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    String sqlNotEqualNull = String.format(\"SELECT * FROM %s WHERE data <> NULL \", TABLE_NAME);\n+    String explainNotEqualNull = getTableEnv().explainSql(sqlNotEqualNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\", explainNotEqualNull.contains(\n+        expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownAnd() {\n+    String sqlAnd = String.format(\"SELECT * FROM %s WHERE id = 1 AND data = 'a' \", TABLE_NAME);\n+    String explainAnd = getTableEnv().explainSql(sqlAnd);\n+    String expectedFilter = \"ref(name=\\\"id\\\") == 1,ref(name=\\\"data\\\") == \\\"a\\\"\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainAnd.contains(expectedFilter));\n+\n+    List<Object[]> resultAnd = sql(sqlAnd);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultAnd.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultAnd.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert\n+        .assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") == 1 and ref(name=\\\"data\\\") == \\\"a\\\")\",\n+            lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownOr() {\n+    String sqlOr = String.format(\"SELECT * FROM %s WHERE id = 1 OR data = 'b' \", TABLE_NAME);\n+    String explainOr = getTableEnv().explainSql(sqlOr);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"data\\\") == \\\"b\\\")\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainOr.contains(expectedFilter));\n+\n+    List<Object[]> resultOr = sql(sqlOr);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultOr.size());\n+\n+    List<Object[]> expectedOR = Lists.newArrayList();\n+    expectedOR.add(new Object[] {1, \"a\"});\n+    expectedOR.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultOr.toArray(), expectedOR.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThan() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE id > 1 \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    expectedGT.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanLiteralOnLeft() {\n+    String sqlGT = String.format(\"SELECT * FROM %s WHERE 3 > id \", TABLE_NAME);\n+    String explainGT = getTableEnv().explainSql(sqlGT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGT.contains(expectedFilter));\n+\n+    List<Object[]> resultGT = sql(sqlGT);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultGT.size());\n+\n+    List<Object[]> expectedGT = Lists.newArrayList();\n+    expectedGT.add(new Object[] {1, \"a\"});\n+    expectedGT.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGT.toArray(), expectedGT.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqual() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE id >= 2 \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    expectedGTE.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownGreaterThanEqualLiteralOnLeft() {\n+    String sqlGTE = String.format(\"SELECT * FROM %s WHERE 2 >= id \", TABLE_NAME);\n+    String explainGTE = getTableEnv().explainSql(sqlGTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainGTE.contains(expectedFilter));\n+\n+    List<Object[]> resultGTE = sql(sqlGTE);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultGTE.size());\n+\n+    List<Object[]> expectedGTE = Lists.newArrayList();\n+    expectedGTE.add(new Object[] {1, \"a\"});\n+    expectedGTE.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultGTE.toArray(), expectedGTE.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThan() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE id < 2 \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") < 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanLiteralOnLeft() {\n+    String sqlLT = String.format(\"SELECT * FROM %s WHERE 2 < id \", TABLE_NAME);\n+    String explainLT = getTableEnv().explainSql(sqlLT);\n+    String expectedFilter = \"ref(name=\\\"id\\\") > 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLT.contains(expectedFilter));\n+\n+    List<Object[]> resultLT = sql(sqlLT);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLT.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLT.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqual() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE id <= 1 \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") <= 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLessThanEqualLiteralOnLeft() {\n+    String sqlLTE = String.format(\"SELECT * FROM %s WHERE 3 <= id  \", TABLE_NAME);\n+    String explainLTE = getTableEnv().explainSql(sqlLTE);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 3\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainLTE.contains(expectedFilter));\n+\n+    List<Object[]> resultLTE = sql(sqlLTE);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLTE.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultLTE.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIn() {\n+    String sqlIN = String.format(\"SELECT * FROM %s WHERE id IN (1,2) \", TABLE_NAME);\n+    String explainIN = getTableEnv().explainSql(sqlIN);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") == 1 or ref(name=\\\"id\\\") == 2)\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainIN.contains(expectedFilter));\n+    List<Object[]> resultIN = sql(sqlIN);\n+    Assert.assertEquals(\"should have 2 records\", 2, resultIN.size());\n+\n+    List<Object[]> expectedIN = Lists.newArrayList();\n+    expectedIN.add(new Object[] {1, \"a\"});\n+    expectedIN.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultIN.toArray(), expectedIN.toArray());\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // in with null will not push down\n+    String sqlInNull = String.format(\"SELECT * FROM %s WHERE id IN (1,2,NULL) \", TABLE_NAME);\n+    String explainInNull = getTableEnv().explainSql(sqlInNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainInNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotIn() {\n+    String sqlNotIn = String.format(\"SELECT * FROM %s WHERE id NOT IN (3,2) \", TABLE_NAME);\n+    String explainNotIn = getTableEnv().explainSql(sqlNotIn);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 3,ref(name=\\\"id\\\") != 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNotIn.contains(expectedFilter));\n+\n+    List<Object[]> resultNotIn = sql(sqlNotIn);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultNotIn.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNotIn.get(0), new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") != 3 and ref(name=\\\"id\\\") != 2)\",\n+        lastScanEvent.filter().toString());\n+\n+    String sqlNotInNull = String.format(\"SELECT * FROM %s WHERE id NOT IN (1,2,NULL) \", TABLE_NAME);\n+    String explainNotInNull = getTableEnv().explainSql(sqlNotInNull);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainNotInNull.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNotNull() {\n+    String sqlNotNull = String.format(\"SELECT * FROM %s WHERE data IS NOT NULL\", TABLE_NAME);\n+    String explainNotNull = getTableEnv().explainSql(sqlNotNull);\n+    String expectedFilter = \"not_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNotNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNotNull = sql(sqlNotNull);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNotNull.size());\n+\n+    List<Object[]> expected = Lists.newArrayList();\n+    expected.add(new Object[] {1, \"a\"});\n+    expected.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNotNull.toArray(), expected.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownIsNull() {\n+    String sqlNull = String.format(\"SELECT * FROM %s WHERE data IS  NULL\", TABLE_NAME);\n+    String explainNull = getTableEnv().explainSql(sqlNull);\n+    String expectedFilter = \"is_null(ref(name=\\\"data\\\"))\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNull.contains(expectedFilter));\n+\n+    List<Object[]> resultNull = sql(sqlNull);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultNull.size());\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNull.get(0), new Object[] {3, null});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNot() {\n+    String sqlNot = String.format(\"SELECT * FROM %s WHERE NOT id = 1 \", TABLE_NAME);\n+    String explainNot = getTableEnv().explainSql(sqlNot);\n+    String expectedFilter = \"ref(name=\\\"id\\\") != 1\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNot.contains(expectedFilter));\n+\n+    List<Object[]> resultNot = sql(sqlNot);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultNot.size());\n+\n+    List<Object[]> expectedNot = Lists.newArrayList();\n+    expectedNot.add(new Object[] {2, \"b\"});\n+    expectedNot.add(new Object[] {3, null});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultNot.toArray(), expectedNot.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownBetween() {\n+    String sqlBetween = String.format(\"SELECT * FROM %s WHERE id BETWEEN 1 AND 2 \", TABLE_NAME);\n+    String explainBetween = getTableEnv().explainSql(sqlBetween);\n+    String expectedFilter = \"ref(name=\\\"id\\\") >= 1,ref(name=\\\"id\\\") <= 2\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultBetween = sql(sqlBetween);\n+    Assert.assertEquals(\"should have 2 record\", 2, resultBetween.size());\n+\n+    List<Object[]> expectedBetween = Lists.newArrayList();\n+    expectedBetween.add(new Object[] {1, \"a\"});\n+    expectedBetween.add(new Object[] {2, \"b\"});\n+    Assert.assertArrayEquals(\"Should produce the expected record\", resultBetween.toArray(), expectedBetween.toArray());\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", \"(ref(name=\\\"id\\\") >= 1 and ref(name=\\\"id\\\") <= 2)\",\n+        lastScanEvent.filter().toString());\n+  }\n+\n+  @Test\n+  public void testFilterPushDownNotBetween() {\n+    String sqlNotBetween = String.format(\"SELECT * FROM %s WHERE id  NOT BETWEEN 2 AND 3 \", TABLE_NAME);\n+    String explainNotBetween = getTableEnv().explainSql(sqlNotBetween);\n+    String expectedFilter = \"(ref(name=\\\"id\\\") < 2 or ref(name=\\\"id\\\") > 3)\";\n+    Assert.assertTrue(\"explain should contains the push down filter\", explainNotBetween.contains(expectedFilter));\n+\n+    List<Object[]> resultNotBetween = sql(sqlNotBetween);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultNotBetween.size());\n+    Assert.assertArrayEquals(\"the not between should produce the expected record\", resultNotBetween.get(0),\n+        new Object[] {1, \"a\"});\n+\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+  }\n+\n+  @Test\n+  public void testFilterPushDownLike() {\n+    String sqlLike = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE 'a%' \";\n+    String explainLike = getTableEnv().explainSql(sqlLike);\n+    String expectedFilter = \"ref(name=\\\"data\\\") startsWith \\\"\\\"a\\\"\\\"\";\n+    Assert\n+        .assertTrue(\"the like sql explain should contains the push down filter\", explainLike.contains(expectedFilter));\n+\n+    List<Object[]> resultLike = sql(sqlLike);\n+    Assert.assertEquals(\"should have 1 record\", 1, resultLike.size());\n+    Assert.assertArrayEquals(\"the like result should produce the expected record\", resultLike.get(0),\n+        new Object[] {1, \"a\"});\n+    Assert.assertEquals(\"Should create only one scan\", 1, scanEventCount);\n+    Assert.assertEquals(\"should contains the push down filter\", lastScanEvent.filter().toString(), expectedFilter);\n+\n+    // not push down\n+    String sqlNoPushDown = \"SELECT * FROM \" + TABLE_NAME + \" WHERE data LIKE '%a%' \";\n+    String explainNoPushDown = getTableEnv().explainSql(sqlNoPushDown);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explainNoPushDown.contains(expectedFilterPushDownExplain));\n+  }\n+\n+  @Test\n+  public void testFilterPushDown2Literal() {\n+    String sql2Literal = String.format(\"SELECT * FROM %s WHERE 1 > 0 \", TABLE_NAME);\n+    String explain2Literal = getTableEnv().explainSql(sql2Literal);\n+    Assert.assertFalse(\"explain should not contains FilterPushDown\",\n+        explain2Literal.contains(expectedFilterPushDownExplain));\n+  }", "originalCommit": "9417e9d241b873918dcbdfb4e8c17c5b30aed027", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgwODEzNQ==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557808135", "bodyText": "We can add the test case All inequalities with null, like data < null.\nin spark and hive,we can use sql select float('NaN') to get a NaN ,but the NaN and Infinity are not supported by flink now (doc), we can add a TODO in the class to do the test in the futher", "author": "zhangjun0x01", "createdAt": "2021-01-15T01:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2OTQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNjUyOA==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557816528", "bodyText": "Yes, if those are not supported, then we should have tests that assert a parse error. We want the tests to start failing if we update to a version that does support NaN in the parser and it is used in an expression.", "author": "rdblue", "createdAt": "2021-01-15T02:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2OTQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzg0MTgyNw==", "url": "https://github.com/apache/iceberg/pull/1893#discussion_r557841827", "bodyText": "yes,I will add the test case to assert parse error, when we upgrade to a version of flink that supports NaN, we will not forget to modify these test cases that fail.", "author": "zhangjun0x01", "createdAt": "2021-01-15T03:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU2OTQ2NA=="}], "type": "inlineReview"}, {"oid": "edad5ee6f8c8e458de5c3a497876b6bf37d800e5", "url": "https://github.com/apache/iceberg/commit/edad5ee6f8c8e458de5c3a497876b6bf37d800e5", "message": "fix some issues, and add some test case", "committedDate": "2021-01-16T11:12:34Z", "type": "forcePushed"}]}