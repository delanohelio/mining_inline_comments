{"pr_number": 3039, "pr_title": "Migrate serial publications", "pr_createdAt": "2020-01-07T15:21:04Z", "pr_url": "https://github.com/kitodo/kitodo-production/pull/3039", "timeline": [{"oid": "9fe7dee8e1f216ede1f9e1df9cdaaa075eb8e918", "url": "https://github.com/kitodo/kitodo-production/commit/9fe7dee8e1f216ede1f9e1df9cdaaa075eb8e918", "message": "Fix bugs and code style", "committedDate": "2020-01-07T15:26:17Z", "type": "forcePushed"}, {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "url": "https://github.com/kitodo/kitodo-production/commit/037955c6c5b8329e4eed5e196935580b5c1d4ba6", "message": "Fix bugs and code style", "committedDate": "2020-01-08T07:19:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3OTQwNg==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364679406", "bodyText": "Missing Javadoc", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:02:35Z", "path": "Kitodo/src/main/java/org/kitodo/production/forms/MigrationForm.java", "diffHunk": "@@ -132,6 +133,11 @@ public void showAggregatedProcesses() {\n         processListRendered = true;\n     }\n ", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MDc1Mg==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364680752", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    URI yearFile = FileService.this.createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));\n          \n          \n            \n                    URI yearFile = createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:06:02Z", "path": "Kitodo/src/main/java/org/kitodo/production/services/file/FileService.java", "diffHunk": "@@ -547,6 +547,20 @@ public void moveFile(URI sourceUri, URI targetUri) throws IOException {\n         fileManagementModule.move(sourceUri, targetUri);\n     }\n \n+    /**\n+     * Process owns anchor XML.\n+     *\n+     * @param process\n+     *            whose metadata file path to use\n+     * @return whether an anchor file was found\n+     * @throws IOException\n+     *             if Io failed\n+     */\n+    public boolean processOwnsAnchorXML(Process process) throws IOException {\n+        URI yearFile = FileService.this.createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MDgyNw==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364680827", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return FileService.this.fileExist(yearFile);\n          \n          \n            \n                    return fileExist(yearFile);", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:06:14Z", "path": "Kitodo/src/main/java/org/kitodo/production/services/file/FileService.java", "diffHunk": "@@ -547,6 +547,20 @@ public void moveFile(URI sourceUri, URI targetUri) throws IOException {\n         fileManagementModule.move(sourceUri, targetUri);\n     }\n \n+    /**\n+     * Process owns anchor XML.\n+     *\n+     * @param process\n+     *            whose metadata file path to use\n+     * @return whether an anchor file was found\n+     * @throws IOException\n+     *             if Io failed\n+     */\n+    public boolean processOwnsAnchorXML(Process process) throws IOException {\n+        URI yearFile = FileService.this.createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));\n+        return FileService.this.fileExist(yearFile);", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjY5NQ==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364682695", "bodyText": "Parent Processes have already been created? Really? When?", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:11:15Z", "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2MTYxMg==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r365161612", "bodyText": "If they were added to this map, they were created beforehand. It happens in line 169, which calls createParentProcess() itself.", "author": "matthias-ronge", "createdAt": "2020-01-10T10:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4ODI0Ng==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364688246", "bodyText": "Its not only in Database but in elasticsearch and Object level.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {\n          \n          \n            \n                private static void linkParentProcessWithChildProcess(Process parentProcess, Process childProcess) throws DataException {", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:25:53Z", "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.\n+     */\n+    private Map<String, List<Integer>> parentProcesses = new HashMap<>();\n+\n+    /**\n+     * List of all processes to migrate.\n+     */\n+    private List<Integer> processesList;\n+\n+    /**\n+     * All processes belong to a project.\n+     */\n+    private Collection<Project> projects;\n+\n+    /**\n+     * The progress, for the progress bar.\n+     */\n+    private int progress = 0;\n+\n+    public HierarchyMigrationTask(Collection<Project> projects) {\n+        super(projects.stream().map(Project::getTitle).collect(Collectors.joining(\", \")));\n+        this.projects = projects;\n+    }\n+\n+    /**\n+     * Clone constructor. Provides the ability to restart the task if it was\n+     * previously interrupted.\n+     *\n+     * @param source\n+     *            terminated thread\n+     */\n+    private HierarchyMigrationTask(HierarchyMigrationTask source) {\n+        super(source);\n+        this.processesList = source.processesList;\n+        this.projects = source.projects;\n+        this.progress = source.progress;\n+    }\n+\n+    /**\n+     * Defines the display name of the task in the task manager.\n+     */\n+    @Override\n+    public String getDisplayName() {\n+        return Helper.getTranslation(\"HierarchyMigrationTask\");\n+    }\n+\n+    /**\n+     * The {@code run()} method is called when the thread starts. It initializes\n+     * the process list (if this has not already been done), processes it and\n+     * updates the progress display in the screen output.\n+     */\n+    @Override\n+    public void run() {\n+        try {\n+            if (Objects.isNull(processesList)) {\n+                processesList = projects.parallelStream().flatMap(project -> project.getProcesses().parallelStream())\n+                        .map(Process::getId).collect(Collectors.toList());\n+            }\n+\n+            while (progress < processesList.size()) {\n+                Process process = processService.getById(processesList.get(progress));\n+                if (fileService.processOwnsAnchorXML(process) && !fileService.processOwnsYearXML(process)) {\n+                    setWorkDetail(process.getTitle());\n+                    migrate(process);\n+                }\n+                super.setProgress(++progress / processesList.size());\n+                if (Thread.currentThread().isInterrupted()) {\n+                    return;\n+                }\n+            }\n+        } catch (IOException | DAOException | ProcessGenerationException | DataException e) {\n+            setException(e);\n+        }\n+    }\n+\n+    /**\n+     * This function does the actual work and migrates exactly one process.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void migrate(Process process) throws IOException, ProcessGenerationException, DataException, DAOException {\n+        logger.info(\"Starting to convert process {} (ID {})...\", process.getTitle(), process.getId());\n+        long begin = System.nanoTime();\n+        migrateMetadataFiles(process);\n+        Optional<String> parentId = getParentRecordId(process);\n+        if (parentId.isPresent()) {\n+            if (parentProcesses.containsKey(parentId.get())) {\n+                linkProcessInParent(process, parentProcesses.get(parentId.get()));\n+            } else {\n+                parentProcesses.put(parentId.get(), createParentProcess(process));\n+            }\n+            renameAnchorFile(process);\n+        } else {\n+            logger.warn(\"Process {} (ID {}): Parent has no identifier! Cannot create parent process.\",\n+                process.getTitle(), process.getId());\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Converting {} took {} ms.\", process.getTitle(),\n+                TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin));\n+        }\n+    }\n+\n+    /**\n+     * The metadata file and the anchor file are converted to the new internal\n+     * format using XSLT.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void migrateMetadataFiles(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        dataEditorService.readData(metadataFilePath);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        dataEditorService.readData(anchorFilePath);\n+    }\n+\n+    /**\n+     * Reads the parent record identifier from the anchor file.\n+     */\n+    private static Optional<String> getParentRecordId(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        Workpiece anchorWorkpiece = metsService.loadWorkpiece(anchorFilePath);\n+        Optional<String> parentRecordId = anchorWorkpiece.getRootElement().getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CatalogIDDigital\"))\n+                .filter(MetadataEntry.class::isInstance).map(MetadataEntry.class::cast).map(MetadataEntry::getValue)\n+                .findFirst();\n+        return parentRecordId;\n+    }\n+\n+    /**\n+     * Creates a new parent process. The process is created in the database, the\n+     * process folder is created on the file system and the METS file is\n+     * written. The METS file of the child process is migrated and a link\n+     * between the processes is written in the database.\n+     *\n+     * @param childProcess\n+     *            process to migrate\n+     * @return a data object with the ID of the created parent process and the\n+     *         current number of the child process\n+     */\n+    private List<Integer> createParentProcess(Process childProcess)\n+            throws ProcessGenerationException, IOException, DataException {\n+\n+        processGenerator.generateProcess(childProcess.getTemplate().getId(), childProcess.getProject().getId());\n+        Process parentProcess = processGenerator.getGeneratedProcess();\n+        processService.save(parentProcess);\n+        fileService.createProcessLocation(parentProcess);\n+        createParentMetsFile(childProcess);\n+        ArrayList<Integer> parentData = new ArrayList<>();\n+        parentData.add(parentProcess.getId());\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        parentData.add(convertChildMetsFile(metadataFilePath));\n+        linkInDatabase(parentProcess, childProcess);\n+        return parentData;\n+    }\n+\n+    /**\n+     * Links parent process and child process in the database. The processes are\n+     * saved.\n+     *\n+     * @param parentProcess\n+     *            parent process to link\n+     * @param childProcess\n+     *            child process to link\n+     */\n+    private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE2MzI1OA==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r365163258", "bodyText": "What I wanted to say is that the link is created at the database level (object, Elasticsearch, is synonymous) in contrast to METS pointer link. Link parent process with child process is not clear, which of the two links is created here.", "author": "matthias-ronge", "createdAt": "2020-01-10T10:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4ODI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTE0Nw==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364691147", "bodyText": "You are mixing up purposes of integers in the List.\nWhy not using the process ID as a key instead of the String?\nShouldn't the list of childs also be found in the Database?", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:32:38Z", "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3MDY1Ng==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r365170656", "bodyText": "I need several integers to do this job. These integer values are saved in the list for each parent process.\nI do not use the ID as a key, because in further child processes I can only find the string as the parent, but not the ID. So with the ID as a key, I cannot check whether it has already created the parent or not. This is basically what the map is for.\nThe list of children can be found in the database and is not necessary here. The list contains the current number of the children, not their object ID.", "author": "matthias-ronge", "createdAt": "2020-01-10T10:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4NDExOQ==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r365784119", "bodyText": "\"because in further child processes I can only find the string as the parent\"  What does that mean? The string of the ID? Or what string?\nIs it correct, that the list always only contains two entries? parentID and number of processes? maybe use a Map?", "author": "Kathrin-Huber", "createdAt": "2020-01-13T12:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2OTU2Ng==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r365869566", "bodyText": "The string is the PPN of the superior unit (the journal, or the multi-volume works as its whole). It is found in the anchor.xml file as CatalogIDDigital. This is used to identify the shared parent of several processes. First, this string is read from the file. Then the migration looks if this string is in the map. If yes, then the parent process has been created (there was already another child for this parent before). If not, a parent process is created and written into the map.\nThe number of integers in the list is always one greater as the number of issues already found for the parent, because first there is the parent record number. So it is two after one child, but more after more children.\nAn example: In this example, there are only two hierarchies of processes, a journal with PPN 1234567X with 5 processes, and a multi-volume work with PPN 123456790 and three processes. We do not rely on that these processes are found in a specific order, they will show up to the migration process in unpredictable order.\n\nThe migration finds a hierarchial process (database no. 22) and reads parent PPN 1234567X from the anchor file, and CurrentNo 2 from the meta.xml file. The map is empty. So it creates a new process as parent process. That process gets database number 46. Then it writes the following entry into the map: \"1234567X\" \u2192 <46, 2>. It adds a link in the logical tree from the parent to the child no. 22.\nThen it finds a hierarchical process (database no. 35) and reads parent PPN 1234567X from the anchor file, and CurrentNo 3 from the meta.xml file. There is an entry for string 1234567X in the map, so there is already a parent for this and no new process is created. It loads parent process 46 from the database and adds a link in the logical tree from the parent to the child no. 35 after the first link, because it knows (from the int list) that the first link is current no. 2 and this is current no. 3 and must therefore be added after the first link. Then it updates the map entry to look like this: \"1234567X\" \u2192 <46, 2, 3>\nThen it finds a hierarchical process (database no. 19) and reads parent PPN 23456790 from the anchor file, and CurrentNo 3 from the meta.xml file. There is no entry for string 23456790 in the map, so it creates a new process as parent process. That process gets database number 47. Then it writes the following entry into the map: \"23456790\" \u2192 <47, 3>. It adds a link in the logical tree from the parent to the child no. 19.\nThen it finds a hierarchical process (database no. 17) and reads parent PPN 23456790 from the anchor file, and CurrentNo 1 from the meta.xml file. There is an entry for string 23456790 in the map, so there is already a parent for this and no new process is created. It loads parent process 47 from the database and adds a link in the logical tree from the parent to the child no. 17 before the first link, because it knows (from the int list) that the first link is current no. 3 and this is current no. 1 and must therefore be added before the first link. Then it updates the map entry to look like this: \"23456790\" \u2192 <47, 1, 3>\nThen it finds a hierarchical process (database no. 45) and reads parent PPN 1234567X from the anchor file, and CurrentNo 5 from the meta.xml file. There is an entry for string 1234567X in the map, so there is already a parent for this and no new process is created. It loads parent process 46 from the database and adds a link in the logical tree from the parent to the child no. 45 after the two other links, because it knows (from the int list) that the first link is current no. 2 and the second link is current no. 3 and this is current no. 5 and must therefore be added after the two links. Then it updates the map entry to look like this: \"1234567X\" \u2192 <46, 2, 3, 5>\nThen it finds a hierarchical process (database no. 18) and reads parent PPN 23456790 from the anchor file, and CurrentNo 2 from the meta.xml file. There is an entry for string 23456790 in the map, so there is already a parent for this and no new process is created. It loads parent process 47 from the database and adds a link in the logical tree from the parent to the child no. 18 in between the first and second link, because it knows from the int list that the first link is current no. 1 and the second link is current no. 3 and this is current no. 2 and must therefore be added between the two links. Then it updates the map entry to look like this: \"23456790\" \u2192 <47, 1, 2, 3>. The multi-volume works has now a parent process with links to all of its children in their correct order. However, the algorithm does not know that there is not any more children for this parent, there could still be more. We don\u2019t know at this point.\nThen it finds a hierarchical process (database no. 40) and reads parent PPN 1234567X from the anchor file, and CurrentNo 4 from the meta.xml file. There is an entry for string 1234567X in the map, so there is already a parent for this and no new process is created. It loads parent process 46 from the database and adds a link in the logical tree from the parent to the child no. 40 between the second and third link, because it knows from the int list that the second link is current no. 3 and the third link is current no. 5 and this is current no. 4 and must therefore be added between the second and third link. Then it updates the map entry to look like this: \"1234567X\" \u2192 <46, 2, 3, 4, 5>\nThen it finds a hierarchical process (database no. 14) and reads parent PPN 1234567X from the anchor file, and CurrentNo 1 from the meta.xml file. There is an entry for string 1234567X in the map, which looks like this: \"1234567X\" \u2192 <46, 2, 3, 4, 5>. Should be clear now which process to load and where to add the link. Then the journal also has a parent process with all issues linked in their correct order.\n\nMaybe a question is why I store the record ID of the parent process, and not the process object. This is because it is possible that there are several thousand parent processes (depanding of the size of installation to migrate) and so Java has the chance to garbage-collect all other parent processes meanwhile. Otherwise it could be that the Tomcat runs out of free memory during migration, which should not happen. That is the reason for this decision.", "author": "matthias-ronge", "createdAt": "2020-01-13T15:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTc5Mg==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364691792", "bodyText": "What does currentNO stands for in the metadata?\nPlease give a more explicit description", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:34:21Z", "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.\n+     */\n+    private Map<String, List<Integer>> parentProcesses = new HashMap<>();\n+\n+    /**\n+     * List of all processes to migrate.\n+     */\n+    private List<Integer> processesList;\n+\n+    /**\n+     * All processes belong to a project.\n+     */\n+    private Collection<Project> projects;\n+\n+    /**\n+     * The progress, for the progress bar.\n+     */\n+    private int progress = 0;\n+\n+    public HierarchyMigrationTask(Collection<Project> projects) {\n+        super(projects.stream().map(Project::getTitle).collect(Collectors.joining(\", \")));\n+        this.projects = projects;\n+    }\n+\n+    /**\n+     * Clone constructor. Provides the ability to restart the task if it was\n+     * previously interrupted.\n+     *\n+     * @param source\n+     *            terminated thread\n+     */\n+    private HierarchyMigrationTask(HierarchyMigrationTask source) {\n+        super(source);\n+        this.processesList = source.processesList;\n+        this.projects = source.projects;\n+        this.progress = source.progress;\n+    }\n+\n+    /**\n+     * Defines the display name of the task in the task manager.\n+     */\n+    @Override\n+    public String getDisplayName() {\n+        return Helper.getTranslation(\"HierarchyMigrationTask\");\n+    }\n+\n+    /**\n+     * The {@code run()} method is called when the thread starts. It initializes\n+     * the process list (if this has not already been done), processes it and\n+     * updates the progress display in the screen output.\n+     */\n+    @Override\n+    public void run() {\n+        try {\n+            if (Objects.isNull(processesList)) {\n+                processesList = projects.parallelStream().flatMap(project -> project.getProcesses().parallelStream())\n+                        .map(Process::getId).collect(Collectors.toList());\n+            }\n+\n+            while (progress < processesList.size()) {\n+                Process process = processService.getById(processesList.get(progress));\n+                if (fileService.processOwnsAnchorXML(process) && !fileService.processOwnsYearXML(process)) {\n+                    setWorkDetail(process.getTitle());\n+                    migrate(process);\n+                }\n+                super.setProgress(++progress / processesList.size());\n+                if (Thread.currentThread().isInterrupted()) {\n+                    return;\n+                }\n+            }\n+        } catch (IOException | DAOException | ProcessGenerationException | DataException e) {\n+            setException(e);\n+        }\n+    }\n+\n+    /**\n+     * This function does the actual work and migrates exactly one process.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void migrate(Process process) throws IOException, ProcessGenerationException, DataException, DAOException {\n+        logger.info(\"Starting to convert process {} (ID {})...\", process.getTitle(), process.getId());\n+        long begin = System.nanoTime();\n+        migrateMetadataFiles(process);\n+        Optional<String> parentId = getParentRecordId(process);\n+        if (parentId.isPresent()) {\n+            if (parentProcesses.containsKey(parentId.get())) {\n+                linkProcessInParent(process, parentProcesses.get(parentId.get()));\n+            } else {\n+                parentProcesses.put(parentId.get(), createParentProcess(process));\n+            }\n+            renameAnchorFile(process);\n+        } else {\n+            logger.warn(\"Process {} (ID {}): Parent has no identifier! Cannot create parent process.\",\n+                process.getTitle(), process.getId());\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Converting {} took {} ms.\", process.getTitle(),\n+                TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin));\n+        }\n+    }\n+\n+    /**\n+     * The metadata file and the anchor file are converted to the new internal\n+     * format using XSLT.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void migrateMetadataFiles(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        dataEditorService.readData(metadataFilePath);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        dataEditorService.readData(anchorFilePath);\n+    }\n+\n+    /**\n+     * Reads the parent record identifier from the anchor file.\n+     */\n+    private static Optional<String> getParentRecordId(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        Workpiece anchorWorkpiece = metsService.loadWorkpiece(anchorFilePath);\n+        Optional<String> parentRecordId = anchorWorkpiece.getRootElement().getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CatalogIDDigital\"))\n+                .filter(MetadataEntry.class::isInstance).map(MetadataEntry.class::cast).map(MetadataEntry::getValue)\n+                .findFirst();\n+        return parentRecordId;\n+    }\n+\n+    /**\n+     * Creates a new parent process. The process is created in the database, the\n+     * process folder is created on the file system and the METS file is\n+     * written. The METS file of the child process is migrated and a link\n+     * between the processes is written in the database.\n+     *\n+     * @param childProcess\n+     *            process to migrate\n+     * @return a data object with the ID of the created parent process and the\n+     *         current number of the child process\n+     */\n+    private List<Integer> createParentProcess(Process childProcess)\n+            throws ProcessGenerationException, IOException, DataException {\n+\n+        processGenerator.generateProcess(childProcess.getTemplate().getId(), childProcess.getProject().getId());\n+        Process parentProcess = processGenerator.getGeneratedProcess();\n+        processService.save(parentProcess);\n+        fileService.createProcessLocation(parentProcess);\n+        createParentMetsFile(childProcess);\n+        ArrayList<Integer> parentData = new ArrayList<>();\n+        parentData.add(parentProcess.getId());\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        parentData.add(convertChildMetsFile(metadataFilePath));\n+        linkInDatabase(parentProcess, childProcess);\n+        return parentData;\n+    }\n+\n+    /**\n+     * Links parent process and child process in the database. The processes are\n+     * saved.\n+     *\n+     * @param parentProcess\n+     *            parent process to link\n+     * @param childProcess\n+     *            child process to link\n+     */\n+    private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {\n+        parentProcess.getChildren().add(childProcess);\n+        childProcess.setParent(parentProcess);\n+        processService.save(childProcess);\n+    }\n+\n+    /**\n+     * Generates the METS file for the parent process from the process anchor\n+     * file.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void createParentMetsFile(Process process) throws IOException {\n+        URI metadataFileUri = fileService.getMetadataFilePath(process);\n+        URI anchorFileUri = fileService.createAnchorFile(metadataFileUri);\n+        Workpiece workpiece = metsService.loadWorkpiece(anchorFileUri);\n+        LinkedMetsResource link = workpiece.getRootElement().getChildren().get(0).getLink();\n+        link.setLoctype(\"Kitodo.Production\");\n+        link.setUri(processService.getProcessURI(process));\n+        URI parentMetadataFileUri = fileService.getMetadataFilePath(processGenerator.getGeneratedProcess(), false,\n+            false);\n+        metsService.saveWorkpiece(workpiece, parentMetadataFileUri);\n+    }\n+\n+    /**\n+     * Changes the METS file of the child process.\n+     *\n+     * @param metadataFilePath\n+     *            URI of the metadata file\n+     * @return the current number, may be {@code null}\n+     */\n+    private static Integer convertChildMetsFile(URI metadataFilePath) throws IOException {\n+        Workpiece workpiece = metsService.loadWorkpiece(metadataFilePath);\n+        IncludedStructuralElement childStructureRoot = workpiece.getRootElement().getChildren().get(0);\n+        workpiece.setRootElement(childStructureRoot);\n+        metsService.saveWorkpiece(workpiece, metadataFilePath);\n+        return getCurrentNo(childStructureRoot);\n+    }\n+\n+    /**\n+     * Extracts the CurrentNo from the metadata.", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NDkxMQ==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r365174911", "bodyText": "The current number is an integer sorting criterion, which specifies the order of the subordinate units within their superordinate entirety. In case of journal issues, this can be the same as the issue number if the issue number continues to be counted at the turn of the year. In the case of multi-volume works, this number can correspond to the part number, or (for lexica, for example) it is counted up according to the alphabetical order of the volumes, supplementary volumes are counted on afterwards (thus, in the order in which the books are usually placed on a shelf).", "author": "matthias-ronge", "createdAt": "2020-01-10T10:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODkwMQ==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364698901", "bodyText": "Is kitodo still working with this renamed anchor file?\n@henning-gerhardt  what do you think?", "author": "Kathrin-Huber", "createdAt": "2020-01-09T11:52:18Z", "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.\n+     */\n+    private Map<String, List<Integer>> parentProcesses = new HashMap<>();\n+\n+    /**\n+     * List of all processes to migrate.\n+     */\n+    private List<Integer> processesList;\n+\n+    /**\n+     * All processes belong to a project.\n+     */\n+    private Collection<Project> projects;\n+\n+    /**\n+     * The progress, for the progress bar.\n+     */\n+    private int progress = 0;\n+\n+    public HierarchyMigrationTask(Collection<Project> projects) {\n+        super(projects.stream().map(Project::getTitle).collect(Collectors.joining(\", \")));\n+        this.projects = projects;\n+    }\n+\n+    /**\n+     * Clone constructor. Provides the ability to restart the task if it was\n+     * previously interrupted.\n+     *\n+     * @param source\n+     *            terminated thread\n+     */\n+    private HierarchyMigrationTask(HierarchyMigrationTask source) {\n+        super(source);\n+        this.processesList = source.processesList;\n+        this.projects = source.projects;\n+        this.progress = source.progress;\n+    }\n+\n+    /**\n+     * Defines the display name of the task in the task manager.\n+     */\n+    @Override\n+    public String getDisplayName() {\n+        return Helper.getTranslation(\"HierarchyMigrationTask\");\n+    }\n+\n+    /**\n+     * The {@code run()} method is called when the thread starts. It initializes\n+     * the process list (if this has not already been done), processes it and\n+     * updates the progress display in the screen output.\n+     */\n+    @Override\n+    public void run() {\n+        try {\n+            if (Objects.isNull(processesList)) {\n+                processesList = projects.parallelStream().flatMap(project -> project.getProcesses().parallelStream())\n+                        .map(Process::getId).collect(Collectors.toList());\n+            }\n+\n+            while (progress < processesList.size()) {\n+                Process process = processService.getById(processesList.get(progress));\n+                if (fileService.processOwnsAnchorXML(process) && !fileService.processOwnsYearXML(process)) {\n+                    setWorkDetail(process.getTitle());\n+                    migrate(process);\n+                }\n+                super.setProgress(++progress / processesList.size());\n+                if (Thread.currentThread().isInterrupted()) {\n+                    return;\n+                }\n+            }\n+        } catch (IOException | DAOException | ProcessGenerationException | DataException e) {\n+            setException(e);\n+        }\n+    }\n+\n+    /**\n+     * This function does the actual work and migrates exactly one process.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void migrate(Process process) throws IOException, ProcessGenerationException, DataException, DAOException {\n+        logger.info(\"Starting to convert process {} (ID {})...\", process.getTitle(), process.getId());\n+        long begin = System.nanoTime();\n+        migrateMetadataFiles(process);\n+        Optional<String> parentId = getParentRecordId(process);\n+        if (parentId.isPresent()) {\n+            if (parentProcesses.containsKey(parentId.get())) {\n+                linkProcessInParent(process, parentProcesses.get(parentId.get()));\n+            } else {\n+                parentProcesses.put(parentId.get(), createParentProcess(process));\n+            }\n+            renameAnchorFile(process);\n+        } else {\n+            logger.warn(\"Process {} (ID {}): Parent has no identifier! Cannot create parent process.\",\n+                process.getTitle(), process.getId());\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Converting {} took {} ms.\", process.getTitle(),\n+                TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin));\n+        }\n+    }\n+\n+    /**\n+     * The metadata file and the anchor file are converted to the new internal\n+     * format using XSLT.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void migrateMetadataFiles(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        dataEditorService.readData(metadataFilePath);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        dataEditorService.readData(anchorFilePath);\n+    }\n+\n+    /**\n+     * Reads the parent record identifier from the anchor file.\n+     */\n+    private static Optional<String> getParentRecordId(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        Workpiece anchorWorkpiece = metsService.loadWorkpiece(anchorFilePath);\n+        Optional<String> parentRecordId = anchorWorkpiece.getRootElement().getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CatalogIDDigital\"))\n+                .filter(MetadataEntry.class::isInstance).map(MetadataEntry.class::cast).map(MetadataEntry::getValue)\n+                .findFirst();\n+        return parentRecordId;\n+    }\n+\n+    /**\n+     * Creates a new parent process. The process is created in the database, the\n+     * process folder is created on the file system and the METS file is\n+     * written. The METS file of the child process is migrated and a link\n+     * between the processes is written in the database.\n+     *\n+     * @param childProcess\n+     *            process to migrate\n+     * @return a data object with the ID of the created parent process and the\n+     *         current number of the child process\n+     */\n+    private List<Integer> createParentProcess(Process childProcess)\n+            throws ProcessGenerationException, IOException, DataException {\n+\n+        processGenerator.generateProcess(childProcess.getTemplate().getId(), childProcess.getProject().getId());\n+        Process parentProcess = processGenerator.getGeneratedProcess();\n+        processService.save(parentProcess);\n+        fileService.createProcessLocation(parentProcess);\n+        createParentMetsFile(childProcess);\n+        ArrayList<Integer> parentData = new ArrayList<>();\n+        parentData.add(parentProcess.getId());\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        parentData.add(convertChildMetsFile(metadataFilePath));\n+        linkInDatabase(parentProcess, childProcess);\n+        return parentData;\n+    }\n+\n+    /**\n+     * Links parent process and child process in the database. The processes are\n+     * saved.\n+     *\n+     * @param parentProcess\n+     *            parent process to link\n+     * @param childProcess\n+     *            child process to link\n+     */\n+    private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {\n+        parentProcess.getChildren().add(childProcess);\n+        childProcess.setParent(parentProcess);\n+        processService.save(childProcess);\n+    }\n+\n+    /**\n+     * Generates the METS file for the parent process from the process anchor\n+     * file.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void createParentMetsFile(Process process) throws IOException {\n+        URI metadataFileUri = fileService.getMetadataFilePath(process);\n+        URI anchorFileUri = fileService.createAnchorFile(metadataFileUri);\n+        Workpiece workpiece = metsService.loadWorkpiece(anchorFileUri);\n+        LinkedMetsResource link = workpiece.getRootElement().getChildren().get(0).getLink();\n+        link.setLoctype(\"Kitodo.Production\");\n+        link.setUri(processService.getProcessURI(process));\n+        URI parentMetadataFileUri = fileService.getMetadataFilePath(processGenerator.getGeneratedProcess(), false,\n+            false);\n+        metsService.saveWorkpiece(workpiece, parentMetadataFileUri);\n+    }\n+\n+    /**\n+     * Changes the METS file of the child process.\n+     *\n+     * @param metadataFilePath\n+     *            URI of the metadata file\n+     * @return the current number, may be {@code null}\n+     */\n+    private static Integer convertChildMetsFile(URI metadataFilePath) throws IOException {\n+        Workpiece workpiece = metsService.loadWorkpiece(metadataFilePath);\n+        IncludedStructuralElement childStructureRoot = workpiece.getRootElement().getChildren().get(0);\n+        workpiece.setRootElement(childStructureRoot);\n+        metsService.saveWorkpiece(workpiece, metadataFilePath);\n+        return getCurrentNo(childStructureRoot);\n+    }\n+\n+    /**\n+     * Extracts the CurrentNo from the metadata.\n+     *\n+     * @param includedStructualElement\n+     *            outline element with metadata\n+     * @return the CurrentNo, or {@code null}\n+     */\n+    private static Integer getCurrentNo(IncludedStructuralElement includedStructualElement) {\n+        Integer currentNo = includedStructualElement.getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CurrentNo\")).filter(MetadataEntry.class::isInstance)\n+                .map(MetadataEntry.class::cast).map(MetadataEntry::getValue).map(Integer::valueOf).findFirst()\n+                .orElse(null);\n+        return currentNo;\n+    }\n+\n+    /**\n+     * Links a child process in an existing parent process.\n+     *\n+     * @param childProcess\n+     *            child process to link\n+     * @param parentData\n+     *            a data object with the ID of the parent process and the\n+     *            current numbers of the child processes already linked with the\n+     *            parent\n+     */\n+    private static void linkProcessInParent(Process childProcess, List<Integer> parentData)\n+            throws IOException, DAOException, DataException {\n+\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        Integer currentNo = convertChildMetsFile(metadataFilePath);\n+        Process parentProcess = processService.getById(parentData.get(0));\n+        int insertionPosition = calculateInsertionPosition(parentData, currentNo);\n+        MetadataEditor.addLink(parentProcess, Integer.toString(insertionPosition), childProcess.getId());\n+        parentData.add(insertionPosition + 1, currentNo);\n+        linkInDatabase(parentProcess, childProcess);\n+    }\n+\n+    /**\n+     * Calculates the point at which the child process must be inserted in the\n+     * parent hierarchy.\n+     *\n+     * @param parentData\n+     *            a data object with the ID of the parent process (here unused)\n+     *            and the current numbers of the child processes already linked\n+     *            with the parent, which may be {@code null}\n+     * @param currentNo\n+     *            the current number of the child process to link, may be\n+     *            {@code null}\n+     * @return the insertion position\n+     */\n+    private static int calculateInsertionPosition(List<Integer> parentData, Integer currentNo) {\n+        int currentNumber = Objects.isNull(currentNo) ? Integer.MIN_VALUE : currentNo;\n+        int insertionPosition = 0;\n+        for (int index = 1; index < parentData.size(); index++) {\n+            int comparee = Objects.isNull(parentData.get(index)) ? Integer.MIN_VALUE : parentData.get(index);\n+            if (currentNumber >= comparee) {\n+                insertionPosition++;\n+            } else {\n+                break;\n+            }\n+        }\n+        return insertionPosition;\n+    }\n+\n+    /**\n+     * Renames the anchor file. It is clear that this has been migrated.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void renameAnchorFile(Process process) throws IOException {\n+        URI anchorFile = fileService.createAnchorFile(fileService.getMetadataFilePath(process));\n+        fileService.renameFile(anchorFile, \"meta_anchor.migrated\");", "originalCommit": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcyOTAxNA==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364729014", "bodyText": "I don't understand why this file is still existing after migration and why it get a new name. Maybe @matthias-ronge should explain this in more detail. Maybe direct in German between @Kathrin-Huber and me.", "author": "henning-gerhardt", "createdAt": "2020-01-09T13:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NzIwNQ==", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r365177205", "bodyText": "Simple, I\u2018m not deleting the file for safety\u2018s sake if anything goes wrong, but I\u2018m renaming it so that the migration cannot be accidentally repeated (principle of idempotence). I had followed the same procedure for the newspaper process migration. In principle, the file could also be deleted, but then there is no going back if something went wrong during the migration. So, consider this file as a backup, similar to backup file rotation.", "author": "matthias-ronge", "createdAt": "2020-01-10T10:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODkwMQ=="}], "type": "inlineReview"}, {"oid": "9701bf91fa92b8f7c911c27458624d1a5592782d", "url": "https://github.com/kitodo/kitodo-production/commit/9701bf91fa92b8f7c911c27458624d1a5592782d", "message": "Implement migration of serial processes", "committedDate": "2020-01-10T09:59:08Z", "type": "commit"}, {"oid": "0ed36d3df1391ddc9a7dcd1486694428eb0848bd", "url": "https://github.com/kitodo/kitodo-production/commit/0ed36d3df1391ddc9a7dcd1486694428eb0848bd", "message": "Fix bugs and code style", "committedDate": "2020-01-10T09:59:09Z", "type": "commit"}, {"oid": "bb4cb1449ce733688d54821e44e891269af971b0", "url": "https://github.com/kitodo/kitodo-production/commit/bb4cb1449ce733688d54821e44e891269af971b0", "message": "Use lowercase", "committedDate": "2020-01-10T10:04:13Z", "type": "commit"}, {"oid": "c1d890e2662d45c4dd66e71cbd81caa14855464c", "url": "https://github.com/kitodo/kitodo-production/commit/c1d890e2662d45c4dd66e71cbd81caa14855464c", "message": "Apply suggested changes", "committedDate": "2020-01-10T10:44:05Z", "type": "commit"}, {"oid": "e38c0c0973314982b87a1c23daf9232874540130", "url": "https://github.com/kitodo/kitodo-production/commit/e38c0c0973314982b87a1c23daf9232874540130", "message": "Improve Javadoc", "committedDate": "2020-01-10T10:44:15Z", "type": "forcePushed"}, {"oid": "2ce164113a995b629ba8ace9237782a7ed0215b0", "url": "https://github.com/kitodo/kitodo-production/commit/2ce164113a995b629ba8ace9237782a7ed0215b0", "message": "Improve Javadoc", "committedDate": "2020-01-10T10:53:14Z", "type": "commit"}, {"oid": "2ce164113a995b629ba8ace9237782a7ed0215b0", "url": "https://github.com/kitodo/kitodo-production/commit/2ce164113a995b629ba8ace9237782a7ed0215b0", "message": "Improve Javadoc", "committedDate": "2020-01-10T10:53:14Z", "type": "forcePushed"}, {"oid": "1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "url": "https://github.com/kitodo/kitodo-production/commit/1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "message": "Use lowercase: consistent naming of task threads", "committedDate": "2020-01-10T11:17:25Z", "type": "commit"}, {"oid": "1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "url": "https://github.com/kitodo/kitodo-production/commit/1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "message": "Use lowercase: consistent naming of task threads", "committedDate": "2020-01-10T11:17:25Z", "type": "forcePushed"}]}