{"pr_number": 4692, "pr_title": "Issue 4691: Honor delegation token expiration during appends ", "pr_createdAt": "2020-04-15T06:10:02Z", "pr_url": "https://github.com/pravega/pravega/pull/4692", "timeline": [{"oid": "3649cc42163e5f28796c3cfbed58d5fd54ddb53b", "url": "https://github.com/pravega/pravega/commit/3649cc42163e5f28796c3cfbed58d5fd54ddb53b", "message": "Move classes related to security in ...auth package to ...security package\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-15T05:20:18Z", "type": "commit"}, {"oid": "74a065223111ec85a4aa9bce6cbf8bf4e55f0296", "url": "https://github.com/pravega/pravega/commit/74a065223111ec85a4aa9bce6cbf8bf4e55f0296", "message": "Extract out Jwt utility functions so that it can be reused elsewhere\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-15T06:03:02Z", "type": "commit"}, {"oid": "3d715cbfe994ebe8305d032c0d41cab3ce912872", "url": "https://github.com/pravega/pravega/commit/3d715cbfe994ebe8305d032c0d41cab3ce912872", "message": "Refactor to move to appropriate module and package\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-15T06:04:47Z", "type": "commit"}, {"oid": "5686388eb0a02b447c96f39b3efcd0420870c9c3", "url": "https://github.com/pravega/pravega/commit/5686388eb0a02b447c96f39b3efcd0420870c9c3", "message": "Fix for the core issue\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-15T06:05:23Z", "type": "commit"}, {"oid": "0ca1d4fca561ae0557e228ca6e896b7f600080d1", "url": "https://github.com/pravega/pravega/commit/0ca1d4fca561ae0557e228ca6e896b7f600080d1", "message": "Fix for Gson version conflicts\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-15T07:28:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc4OTI4Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408789287", "bodyText": "if connection pooling is enabled then all the sessions will be terminated. We should send a WireCommands.AuthTokenCheckFailed .", "author": "shrids", "createdAt": "2020-04-15T12:03:17Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -142,6 +146,30 @@ public void setupAppend(SetupAppend setupAppend) {\n                 tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n                         AuthHandler.Permissions.READ_UPDATE);\n+\n+                final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+                if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+                    if (durationToExpiry.isNegative()) {\n+                        log.debug(\"Token has already expired\");\n+                        throw new TokenExpiredException(\"Token already expired\");\n+                    } else {\n+                        Futures.delayedTask(() -> {\n+                            if (writerStates.containsKey(Pair.of(newSegment, writer))) {\n+                                // Closing the connection will result in client authenticating with Controller again\n+                                // and retrying.\n+                                log.debug(\"Closing client connection due to token expiry\");\n+                                try {\n+                                    this.connection.close();", "originalCommit": "0ca1d4fca561ae0557e228ca6e896b7f600080d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyMDg0MA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408920840", "bodyText": "Sure, I've made the change in the latest commits that I just pushed.", "author": "ravisharda", "createdAt": "2020-04-15T15:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc4OTI4Nw=="}], "type": "inlineReview"}, {"oid": "ef50e3fc7b8eb99eae1c6badde82253165634072", "url": "https://github.com/pravega/pravega/commit/ef50e3fc7b8eb99eae1c6badde82253165634072", "message": "Send token expiry notification to client instead of closing the connection\nas suggested in a review comment.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-15T15:10:58Z", "type": "commit"}, {"oid": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "url": "https://github.com/pravega/pravega/commit/b485b1770c32b01b1eafd433d10dff668c6e6ee5", "message": "Add tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-15T15:11:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0MzA0MA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408943040", "bodyText": "Revert this", "author": "andreipaduroiu", "createdAt": "2020-04-15T15:42:04Z", "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "diffHunk": "@@ -205,6 +153,7 @@ public boolean populateToken(String token) {\n         } else {\n             return this.delegationToken.compareAndSet(currentToken, new DelegationToken(token, extractExpirationTime(token)));\n         }\n+", "originalCommit": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTg4OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409271888", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-04-16T04:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0MzA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NDgyNA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408944824", "bodyText": "\"Unable to parse JWT body for expiration time: {}\"", "author": "andreipaduroiu", "createdAt": "2020-04-15T15:44:34Z", "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.security;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JwtUtils {\n+\n+    /**\n+     * The regex pattern for extracting \"exp\" field from the JWT.\n+     *\n+     * Examples:\n+     *    Input:- {\"sub\":\"subject\",\"aud\":\"segmentstore\",\"iat\":1569837384,\"exp\":1569837434}, output:- \"exp\":1569837434\n+     *    Input:- {\"sub\": \"subject\",\"aud\": \"segmentstore\",\"iat\": 1569837384,\"exp\": 1569837434}, output:- \"exp\": 1569837434\n+     */\n+    private static final Pattern JWT_EXPIRATION_PATTERN = Pattern.compile(\"\\\"exp\\\":\\\\s?(\\\\d+)\");\n+\n+    public static Long extractExpirationTime(String token) {\n+        if (token == null || token.trim().equals(\"\")) {\n+            return null;\n+        }\n+        String[] tokenParts = token.split(\"\\\\.\");\n+\n+        //A JWT token has 3 parts: the header, the body and the signature.\n+        if (tokenParts == null || tokenParts.length != 3) {\n+            return null;\n+        }\n+\n+        // The second part of the JWT token is the body, which contains the expiration time if present.\n+        String encodedBody = tokenParts[1];\n+        String decodedJsonBody = new String(Base64.getDecoder().decode(encodedBody));\n+\n+        return parseExpirationTime(decodedJsonBody);\n+    }\n+\n+    public static Duration durationToExpiry(String token) {\n+        Long expirationTime = extractExpirationTime(token);\n+        if (expirationTime == null) {\n+            return null;\n+        } else {\n+            return Duration.between(Instant.now(), Instant.ofEpochSecond(expirationTime));\n+        }\n+    }\n+\n+    public static Long parseExpirationTime(String jwtBody) {\n+        Long result = null;\n+        if (jwtBody != null && !jwtBody.trim().equals(\"\")) {\n+            Matcher matcher = JWT_EXPIRATION_PATTERN.matcher(jwtBody);\n+            if (matcher.find()) {\n+                // Should look like this, if a proper match is found: \"exp\": 1569837434\n+                String matchedString = matcher.group();\n+\n+                // JwtUtils\n+\n+                String[] expiryTimeFieldParts = matchedString.split(\":\");\n+                if (expiryTimeFieldParts != null && expiryTimeFieldParts.length == 2) {\n+                    try {\n+                        result = Long.parseLong(expiryTimeFieldParts[1].trim());\n+                    } catch (NumberFormatException e) {\n+                        // ignore\n+                        log.warn(\"Encountered this exception when parsing JWT body for expiration time: {}\", e.getMessage());", "originalCommit": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjExMA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272110", "bodyText": "Yeah, I had missed that - had thought of changing it later. I have fixed it now.", "author": "ravisharda", "createdAt": "2020-04-16T04:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTQ0Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408945446", "bodyText": "Include segment and writer id in the message. Both here and everywhere else you log or throw something.", "author": "andreipaduroiu", "createdAt": "2020-04-15T15:45:27Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    void setupTokenExpiryTask(SetupAppend setupAppend, String newSegment, UUID writer) {\n+        final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+            if (durationToExpiry.isNegative()) {\n+                log.debug(\"Token has already expired\");", "originalCommit": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjI3Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272276", "bodyText": "Sure, I've made this change.", "author": "ravisharda", "createdAt": "2020-04-16T04:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NjQxNg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408946416", "bodyText": "Better message", "author": "andreipaduroiu", "createdAt": "2020-04-15T15:46:48Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    void setupTokenExpiryTask(SetupAppend setupAppend, String newSegment, UUID writer) {\n+        final Duration durationToExpiry = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        if (durationToExpiry != null) { // Can be null if token had no expiry set (for internal communications)\n+            if (durationToExpiry.isNegative()) {\n+                log.debug(\"Token has already expired\");\n+                throw new TokenExpiredException(\"Token already expired\");\n+            } else {\n+                Futures.delayedTask(() -> {\n+                    if (writerStates.containsKey(Pair.of(newSegment, writer))) {\n+                        try {\n+                            log.debug(\"Informing the client about token expiry\");\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    \"Token expired\",\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        } catch (RuntimeException e) {\n+                            log.warn(\"Encountered an exception\", e);", "originalCommit": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjQ0Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272446", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-04-16T04:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NjQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NzU5OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408947598", "bodyText": "Please do not create random executors. There are already executors created in the Segment Store process; use one of them. Or otherwise try to rework your code to not require an executor.", "author": "andreipaduroiu", "createdAt": "2020-04-15T15:48:32Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -90,6 +92,10 @@\n \n     private FileModificationMonitor tlsCertFileModificationMonitor; // used only if tls reload is enabled\n \n+    // Used for running token expiry handling tasks.\n+    private final ScheduledExecutorService tokenExpiryHandlerExecutor =", "originalCommit": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTYxMw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411855613", "bodyText": "Ok. I have modified the code to use a preexisting executor that is passed from the ServiceStarter.", "author": "ravisharda", "createdAt": "2020-04-21T04:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NzU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzM5OQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417133399", "bodyText": "On second thought, I realized that it'd be better to run the token expiry tasks on a separate executor spinning up lower priority threads, just so that these tasks don't end up overwhelming the core executor. So, I have now modified the code again.\nPlease take a look again and see what you think.", "author": "ravisharda", "createdAt": "2020-04-29T07:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NzU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODAxMA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408948010", "bodyText": "This is the wrong way to shut down an executor. See ExecutorServiceHelpers.shutdown. But anyway, see my comment above.", "author": "andreipaduroiu", "createdAt": "2020-04-15T15:49:02Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -280,5 +286,8 @@ public void close() {\n         if (tlsCertFileModificationMonitor != null) {\n             tlsCertFileModificationMonitor.stopMonitoring();\n         }\n+        if (tokenExpiryHandlerExecutor != null) {\n+            tokenExpiryHandlerExecutor.shutdownNow();", "originalCommit": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjUxMQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272511", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2020-04-16T04:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODQxNw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r408948417", "bodyText": "Javadoc for this class and all its methods.", "author": "andreipaduroiu", "createdAt": "2020-04-15T15:49:36Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtTestUtils.java", "diffHunk": "@@ -7,20 +7,24 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.client.security.auth;\n+package io.pravega.test.common;\n \n import com.google.gson.Gson;\n \n import java.util.Base64;\n \n public class JwtTestUtils {\n \n-    static String createJwtBody(JwtBody jwt) {\n+    public static String createJwtBody(JwtBody jwt) {", "originalCommit": "b485b1770c32b01b1eafd433d10dff668c6e6ee5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjU1MQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r409272551", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-04-16T04:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODQxNw=="}], "type": "inlineReview"}, {"oid": "a01149f8448837c7da8e20c5a65bebb001653b8e", "url": "https://github.com/pravega/pravega/commit/a01149f8448837c7da8e20c5a65bebb001653b8e", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-16T04:13:32Z", "type": "commit"}, {"oid": "a32dd3114d4a02a3c4132d4995db73769d8e1fc0", "url": "https://github.com/pravega/pravega/commit/a32dd3114d4a02a3c4132d4995db73769d8e1fc0", "message": "Add some tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-16T08:02:36Z", "type": "commit"}, {"oid": "8bc9b98ecb1fa18349412a443477f0b28a74ff26", "url": "https://github.com/pravega/pravega/commit/8bc9b98ecb1fa18349412a443477f0b28a74ff26", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-16T17:37:46Z", "type": "commit"}, {"oid": "cc044f9877968750faf33b42cad25c337e8e4071", "url": "https://github.com/pravega/pravega/commit/cc044f9877968750faf33b42cad25c337e8e4071", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-16T17:40:11Z", "type": "commit"}, {"oid": "5272fde4a2bc6211eaccf0834f900c880094eb6b", "url": "https://github.com/pravega/pravega/commit/5272fde4a2bc6211eaccf0834f900c880094eb6b", "message": "Add tests and some minor formatting changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-17T02:12:08Z", "type": "commit"}, {"oid": "0b5b7f308e0641c6d3d371b1bb164c1ad8c44bc6", "url": "https://github.com/pravega/pravega/commit/0b5b7f308e0641c6d3d371b1bb164c1ad8c44bc6", "message": "Add tests and other minor changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-17T04:54:07Z", "type": "commit"}, {"oid": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318", "url": "https://github.com/pravega/pravega/commit/a7ed19e5012291a4f7b31bfea5ade4b1eba91318", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-17T04:55:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411862502", "bodyText": "Can we avoid sending this if the connection is closed? A connection closing should ensure all the pending tasks are cancelled.", "author": "shrids", "createdAt": "2020-04-21T04:37:13Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "originalCommit": "a7ed19e5012291a4f7b31bfea5ade4b1eba91318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3ODEzMA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411878130", "bodyText": "The ServerConnection interface doesn't seem to have a way to check if the connection is closed. My understanding is that if the connection is closed, sending a message over it will result in an exception being thrown, which we are catching and ignoring here.\nWhat do you say? Am I missing something else?", "author": "ravisharda", "createdAt": "2020-04-21T05:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMjI2Mg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411912262", "bodyText": "The connection can be closed externally or due to connection.close() invoked by the appendProcessor. This would lead to these delayed tasks being unnecessarily executed.", "author": "shrids", "createdAt": "2020-04-21T06:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2OTYzMQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r412869631", "bodyText": "I've now introduced an isClosed() method to the connection, so that we the task checks for it before trying to send the token expiry notification. This makes it a bit more efficient. However, the core issue remains: whether/when/how do we cancel the task?", "author": "ravisharda", "createdAt": "2020-04-22T10:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MjUwMg=="}], "type": "inlineReview"}, {"oid": "2183a08a79bc15a6fc4c5b9e902dbf78ff4f17dd", "url": "https://github.com/pravega/pravega/commit/2183a08a79bc15a6fc4c5b9e902dbf78ff4f17dd", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-21T04:40:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMzYwMA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r411913600", "bodyText": "I think we should have a lower log level here.", "author": "shrids", "createdAt": "2020-04-21T06:44:21Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,57 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.debug(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                        writerId, segment, requestId),\n+                                WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "originalCommit": "2183a08a79bc15a6fc4c5b9e902dbf78ff4f17dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NzkyNA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r412867924", "bodyText": "Sure, that sounds good. I've reduced the log level.", "author": "ravisharda", "createdAt": "2020-04-22T10:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMzYwMA=="}], "type": "inlineReview"}, {"oid": "5157f9814afbc63d910bd8dd157ae132d9687afe", "url": "https://github.com/pravega/pravega/commit/5157f9814afbc63d910bd8dd157ae132d9687afe", "message": "Miscellaneous changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-21T06:46:23Z", "type": "commit"}, {"oid": "33e02fc06963444df8980d27702aa18abd8188ef", "url": "https://github.com/pravega/pravega/commit/33e02fc06963444df8980d27702aa18abd8188ef", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-22T05:35:09Z", "type": "commit"}, {"oid": "6ae7504b0b790f649c5e5ce8e0a4285bc75d364d", "url": "https://github.com/pravega/pravega/commit/6ae7504b0b790f649c5e5ce8e0a4285bc75d364d", "message": "Introduce a method for checking whether the connection is closed.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-22T10:32:27Z", "type": "commit"}, {"oid": "6e33b47e8acb3b787623bd2eb7ab3df0d6bc227c", "url": "https://github.com/pravega/pravega/commit/6e33b47e8acb3b787623bd2eb7ab3df0d6bc227c", "message": "Merge branch 'honor-tokenexpiry-upon-writes' of https://github.com/ravisharda/pravega into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-22T10:32:58Z", "type": "commit"}, {"oid": "bf4d86f136270ef11c0040d3e293c4a3eb9e4c85", "url": "https://github.com/pravega/pravega/commit/bf4d86f136270ef11c0040d3e293c4a3eb9e4c85", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-27T10:56:20Z", "type": "commit"}, {"oid": "1b8576bca639525205f27471acbd466b6e259758", "url": "https://github.com/pravega/pravega/commit/1b8576bca639525205f27471acbd466b6e259758", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-27T12:25:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NTEzOA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416165138", "bodyText": "This should not be creating threads on a per connection basis. This is going to need to be provided by the caller.", "author": "tkaitchuck", "createdAt": "2020-04-27T21:34:34Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -108,7 +113,9 @@ public static AppendProcessorBuilder defaultBuilder() {\n                 .nextRequestProcessor(new FailingRequestProcessor())\n                 .statsRecorder(SegmentStatsRecorder.noOp())\n                 .connectionTracker(new ConnectionTracker())\n-                .replyWithStackTraceOnError(false);\n+                .replyWithStackTraceOnError(false)\n+                .tokenExpiryHandlerExecutor(ExecutorServiceHelpers.newScheduledThreadPool(2,", "originalCommit": "1b8576bca639525205f27471acbd466b6e259758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwOTE2Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416209167", "bodyText": "Also:\n\nThis executor has a weird name.\nIt is never shut down.", "author": "andreipaduroiu", "createdAt": "2020-04-27T23:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NTEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNDcyMw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417134723", "bodyText": "Even though the preexisting defaultBuilder() method where this executor was added was only meant for testing, it was inappropriate. So, I've removed it altogether in the latest push.", "author": "ravisharda", "createdAt": "2020-04-29T08:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NTEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416166269", "bodyText": "This sends a message over the connection and then leaves it open, so appends can continue to occur if the client simply ignores the message.", "author": "tkaitchuck", "createdAt": "2020-04-27T21:36:27Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),", "originalCommit": "1b8576bca639525205f27471acbd466b6e259758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTc2MQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417141761", "bodyText": "Yes, that is right. We are depending on the client to meet its contract related to token expiry, reauthenticate with the controller and invoke the segment store with the new token. One way to forcefully ensure that would have been to close the connection, but that'd be too expensive I suppose. What do you say?", "author": "ravisharda", "createdAt": "2020-04-29T08:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1MjYxMA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417952610", "bodyText": "I can maintain a flag in the WriteState such that when the token expires, the task will set it to true. Then, I can check the flag on each append. However, that can introduce additional performance cost for each append. I believe the current solution is adequate and provides a good balance of security and performance.", "author": "ravisharda", "createdAt": "2020-04-30T11:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMzkwMw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r421003903", "bodyText": "This is a question of authentication. You can't rely on the client, that saying \"We enforce authorization by asking nicely\". The connection needs to be closed.", "author": "tkaitchuck", "createdAt": "2020-05-06T18:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1NTE0Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r421955147", "bodyText": "If connection pooling is enabled then closing the connection would cause all the clients using this connection to see a connection drop. But since it is a question of authentication the other clients would see a connection drop and would re-establish a connection with the SSS.", "author": "shrids", "createdAt": "2020-05-08T05:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1Mzc5MA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422053790", "bodyText": "I've modified the code to close the connection, as suggested.", "author": "ravisharda", "createdAt": "2020-05-08T09:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjQ3OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416166478", "bodyText": "I think this is a warn level event", "author": "tkaitchuck", "createdAt": "2020-04-27T21:36:48Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                            writerId, segment, requestId),\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.debug(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "originalCommit": "1b8576bca639525205f27471acbd466b6e259758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzMxMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417137312", "bodyText": "Yeah, the log level was changed from warn to debug previously, as the exception would also occur if the task ran after the connection was closed. Now that the main portion of the task is only run if the connection is not already closed, it'd be appropriate to change this back to warn level. I've made this change in the latest push.", "author": "ravisharda", "createdAt": "2020-04-29T08:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NjQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NzU3Mg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416167572", "bodyText": "why this change?", "author": "tkaitchuck", "createdAt": "2020-04-27T21:38:44Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -199,13 +217,10 @@ public void initChannel(SocketChannel ch) {\n                          new AppendDecoder(),\n                          lsh);\n \n-                 lsh.setRequestProcessor(new AppendProcessor(store,\n-                         lsh,\n-                         connectionTracker,\n-                         new PravegaRequestProcessor(store, tableStore, lsh, statsRecorder, tableStatsRecorder, tokenVerifier, replyWithStackTraceOnError),\n-                         statsRecorder,\n-                         tokenVerifier,\n-                         replyWithStackTraceOnError));\n+                 lsh.setRequestProcessor(new AppendProcessor(store, lsh, connectionTracker,", "originalCommit": "1b8576bca639525205f27471acbd466b6e259758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzUxOQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417137519", "bodyText": "Yeah, this is unnecessary. I've reverted it.", "author": "ravisharda", "createdAt": "2020-04-29T08:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2NzU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwNzc2MA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416207760", "bodyText": "This is an expensive string parse. Can you just look up exp and get the number that succeeds it?", "author": "andreipaduroiu", "createdAt": "2020-04-27T23:03:40Z", "path": "common/src/main/java/io/pravega/common/security/JwtUtils.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.security;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Base64;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility methods for JSON Web Tokens (JWT).\n+ */\n+@Slf4j\n+public class JwtUtils {\n+\n+    /**\n+     * The regex pattern for extracting \"exp\" field from the JWT.\n+     *\n+     * Examples:\n+     *    Input:- {\"sub\":\"subject\",\"aud\":\"segmentstore\",\"iat\":1569837384,\"exp\":1569837434}, output:- \"exp\":1569837434\n+     *    Input:- {\"sub\": \"subject\",\"aud\": \"segmentstore\",\"iat\": 1569837384,\"exp\": 1569837434}, output:- \"exp\": 1569837434\n+     */\n+    private static final Pattern JWT_EXPIRATION_PATTERN = Pattern.compile(\"\\\"exp\\\":\\\\s?(\\\\d+)\");\n+\n+    /**\n+     * Extracts expiration time from the specified JWT token.\n+     *\n+     * @param jsonWebToken the JWT to extract the expiration time from\n+     * @return the the expiration time (in seconds). Returns null if\n+     *         a) the specified token is blank, or\n+     *         b) the specified token is of invalid format, or\n+     *         c) expiration time is missing from the token, or\n+     *         d) expiration time is not a number.\n+     */\n+    public static Long extractExpirationTime(String jsonWebToken) {\n+        if (jsonWebToken == null || jsonWebToken.trim().equals(\"\")) {\n+            return null;\n+        }\n+        String[] tokenParts = jsonWebToken.split(\"\\\\.\");", "originalCommit": "1b8576bca639525205f27471acbd466b6e259758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2MjEzNg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422062136", "bodyText": "Actually, we do look up the expiry string (for example: \"exp\": 1569837434) in another method parseExpirationTime(), after first extracting the JWT body and decoding it here.", "author": "ravisharda", "createdAt": "2020-05-08T10:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwNzc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyNTgzMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425225832", "bodyText": "This PR now doesn't use this method anymore. It continues to be used elsewhere.", "author": "ravisharda", "createdAt": "2020-05-14T15:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwNzc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwODY3Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416208677", "bodyText": "RuntimeException extends Exception. Please catch Exception.", "author": "andreipaduroiu", "createdAt": "2020-04-27T23:05:55Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +175,59 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.send(new WireCommands.AuthTokenCheckFailed(setupAppend.getRequestId(),\n+                                    String.format(\"Token sent by writer %s for segment %s in request %s has expired\",\n+                                            writerId, segment, requestId),\n+                                    WireCommands.AuthTokenCheckFailed.ErrorCode.TOKEN_EXPIRED));\n+                        }\n+                    } catch (RuntimeException e) {", "originalCommit": "1b8576bca639525205f27471acbd466b6e259758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwOTYxMw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417109613", "bodyText": "I want to be specific here, as the intention is only to catch any runtime exceptions.", "author": "ravisharda", "createdAt": "2020-04-29T07:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwODY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwOTQxMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r416209412", "bodyText": "Who manages this executor?", "author": "andreipaduroiu", "createdAt": "2020-04-27T23:07:36Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -105,7 +110,17 @@\n     @VisibleForTesting\n     public PravegaConnectionListener(boolean enableTls, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore) {\n         this(enableTls, false, \"localhost\", port, streamSegmentStore, tableStore, SegmentStatsRecorder.noOp(), TableSegmentStatsRecorder.noOp(),\n-                new PassingTokenVerifier(), null, null, true);\n+                new PassingTokenVerifier(), null, null, true,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));", "originalCommit": "1b8576bca639525205f27471acbd466b6e259758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MzA3Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417143076", "bodyText": "Even though the preexisting defaultBuilder() method where this executor was added, was only meant for testing, it was inappropriate to add the executor here. So, I've removed it altogether in the latest push. Please review the revised code.", "author": "ravisharda", "createdAt": "2020-04-29T08:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIwOTQxMg=="}], "type": "inlineReview"}, {"oid": "09775fe9daec18a1d47e7fcc4af8563e46dea169", "url": "https://github.com/pravega/pravega/commit/09775fe9daec18a1d47e7fcc4af8563e46dea169", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-04-29T07:35:07Z", "type": "commit"}, {"oid": "cc1565c452202e5ec756f1a701bc6aa4ce42c9ca", "url": "https://github.com/pravega/pravega/commit/cc1565c452202e5ec756f1a701bc6aa4ce42c9ca", "message": "Merge branch 'honor-tokenexpiry-upon-writes' of https://github.com/ravisharda/pravega into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-29T07:35:38Z", "type": "commit"}, {"oid": "948799327d98405f60952b7eba26007c18d7a2c7", "url": "https://github.com/pravega/pravega/commit/948799327d98405f60952b7eba26007c18d7a2c7", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-30T03:18:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc3NjQ5Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r417776497", "bodyText": "Default priority can be java.lang.Thread#NORM_PRIORITY", "author": "shrids", "createdAt": "2020-04-30T06:11:43Z", "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "diffHunk": "@@ -66,6 +66,17 @@ public void uncaughtException(Thread t, Throwable e) {\n      * @return a thread factory\n      */\n     public static ThreadFactory getThreadFactory(String groupName) {\n+        return getThreadFactory(groupName, null);", "originalCommit": "948799327d98405f60952b7eba26007c18d7a2c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1Mzg4Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422053887", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-05-08T09:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc3NjQ5Nw=="}], "type": "inlineReview"}, {"oid": "1d657c000e14ee4b96cd763b6b92646b117a1de3", "url": "https://github.com/pravega/pravega/commit/1d657c000e14ee4b96cd763b6b92646b117a1de3", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-04-30T06:17:50Z", "type": "commit"}, {"oid": "2add1554ebb592d435bd184012246e68e7703a82", "url": "https://github.com/pravega/pravega/commit/2add1554ebb592d435bd184012246e68e7703a82", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-05-04T11:29:44Z", "type": "commit"}, {"oid": "2fa9502051fb03716beb222246a2a12da9419de9", "url": "https://github.com/pravega/pravega/commit/2fa9502051fb03716beb222246a2a12da9419de9", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-05-08T06:07:38Z", "type": "commit"}, {"oid": "6e2c7ffd55d99efa000d457214156b40d315e35b", "url": "https://github.com/pravega/pravega/commit/6e2c7ffd55d99efa000d457214156b40d315e35b", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-08T09:50:06Z", "type": "commit"}, {"oid": "2c964260a602b5fba01486a6013efdcd3dbc0d33", "url": "https://github.com/pravega/pravega/commit/2c964260a602b5fba01486a6013efdcd3dbc0d33", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-08T10:13:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDczMw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422064733", "bodyText": "can we remove this redundant null check? The user would invoke newScheduledThreadPool(int size, String poolName) if the priority is default.", "author": "shrids", "createdAt": "2020-05-08T10:19:03Z", "path": "common/src/main/java/io/pravega/common/concurrent/ExecutorServiceHelpers.java", "diffHunk": "@@ -86,8 +100,24 @@ public Thread newThread(Runnable r) {\n      * @return A new executor service.\n      */\n     public static ScheduledExecutorService newScheduledThreadPool(int size, String poolName) {\n+        return newScheduledThreadPool(size, poolName, Thread.NORM_PRIORITY);\n+    }\n+\n+    /**\n+     * Creates a new ScheduledExecutorService that will use daemon threads with specified priority and names.\n+     *\n+     * @param size The number of threads in the threadpool\n+     * @param poolName The name of the pool (this will be printed in logs)\n+     * @param threadPriority The priority to be assigned to the threads\n+     * @return A new executor service.\n+     */\n+    public static ScheduledExecutorService newScheduledThreadPool(int size, String poolName, Integer threadPriority) {\n+\n+        ThreadFactory threadFactory =", "originalCommit": "2c964260a602b5fba01486a6013efdcd3dbc0d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA3MDA3MA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422070070", "bodyText": "Yeah, but since it is a public method, we can't assume that's always true. Besides, having the check makes the intention explicit.", "author": "ravisharda", "createdAt": "2020-05-08T10:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA2NDczMw=="}], "type": "inlineReview"}, {"oid": "19570c74fa3403b0752b8fb56f1082e52de34d94", "url": "https://github.com/pravega/pravega/commit/19570c74fa3403b0752b8fb56f1082e52de34d94", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-08T10:55:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDM2NQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422090365", "bodyText": "We can improve/remove the warn message here since we are closing the connection and not informing the writer via a Wirecommand.", "author": "shrids", "createdAt": "2020-05-08T11:25:50Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",", "originalCommit": "19570c74fa3403b0752b8fb56f1082e52de34d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNDc3NQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424514775", "bodyText": "We don't need to catch the exception anymore after we modified the code here to close the connection, so I've removed the code.", "author": "ravisharda", "createdAt": "2020-05-13T15:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDg1Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422090856", "bodyText": "we do not need this check since we are closing the connection.", "author": "shrids", "createdAt": "2020-05-08T11:27:09Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {", "originalCommit": "19570c74fa3403b0752b8fb56f1082e52de34d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3MDA3NQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424170075", "bodyText": "IMO, this check is still useful because this task is a background task and the connection might already have closed out-of-band.", "author": "ravisharda", "createdAt": "2020-05-13T04:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMzc0OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425223748", "bodyText": "I've moved this check inside close itself, and have removed it here.", "author": "ravisharda", "createdAt": "2020-05-14T15:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MDg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MTU5Mg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422091592", "bodyText": "I did not understand the need to catch an exception for connection.close()?\n(if it is required, then this pattern should be replicated at all connection.close() invocation instances. )", "author": "shrids", "createdAt": "2020-05-08T11:29:07Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {", "originalCommit": "19570c74fa3403b0752b8fb56f1082e52de34d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNTYzMw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424515633", "bodyText": "We don't need to catch the exception anymore after we modified the code here to close the connection, so I've removed the code.", "author": "ravisharda", "createdAt": "2020-05-13T15:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5MTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422094862", "bodyText": "Would the TokenVerifierImpl#verifyToken verify if the duration is negative? If not, we could move the check there to ensure expired tokens are not allowed.", "author": "shrids", "createdAt": "2020-05-08T11:37:10Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +172,56 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(SetupAppend setupAppend) {\n+        String segment = setupAppend.getSegment();\n+        UUID writerId = setupAppend.getWriterId();\n+        long requestId = setupAppend.getRequestId();\n+\n+        Duration expiryDuration = this.durationToExpiry(setupAppend);\n+\n+        if (expiryDuration == null) {\n+            return CompletableFuture.completedFuture(null);\n+        } else {\n+            return Futures.delayedTask(() -> {\n+                if (isSetupAppendCompleted(segment, writerId)) {\n+                    try {\n+                        log.trace(\"Informing writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                        if (!connection.isClosed()) {\n+                            connection.close();\n+                        }\n+                    } catch (RuntimeException e) {\n+                        // Log and ignore\n+                        log.warn(\"Unable to inform writer {} that sent request {}, about token expiry for segment {}\",\n+                                writerId, requestId, segment);\n+                    }\n+                }\n+                return null;\n+            }, expiryDuration, this.tokenExpiryHandlerExecutor);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    Duration durationToExpiry(SetupAppend setupAppend) {\n+        final Duration duration = JwtUtils.durationToExpiry(setupAppend.getDelegationToken());\n+\n+        // Note that duration can be null, say if token had no expiry set (for internal communications).\n+\n+        if (duration != null && duration.isNegative()) {", "originalCommit": "19570c74fa3403b0752b8fb56f1082e52de34d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwOTg3Mw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424209873", "bodyText": "Yes, that check is for finding out if the token has already expired.", "author": "ravisharda", "createdAt": "2020-05-13T06:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NzAxOA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424867018", "bodyText": "TokenVerifierImpl#verifyToken is already checking for TokenExpired. Hence this check seems redundant.", "author": "shrids", "createdAt": "2020-05-14T04:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyNDAzMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425224032", "bodyText": "I've now removed it.", "author": "ravisharda", "createdAt": "2020-05-14T15:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA5NDg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3OTIxNw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422379217", "bodyText": "In this code path, this executor does not look like it will ever be shutdown. That is a thread leak.", "author": "tkaitchuck", "createdAt": "2020-05-08T21:16:15Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaConnectionListener.java", "diffHunk": "@@ -105,7 +110,17 @@\n     @VisibleForTesting\n     public PravegaConnectionListener(boolean enableTls, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore) {\n         this(enableTls, false, \"localhost\", port, streamSegmentStore, tableStore, SegmentStatsRecorder.noOp(), TableSegmentStatsRecorder.noOp(),\n-                new PassingTokenVerifier(), null, null, true);\n+                new PassingTokenVerifier(), null, null, true,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));\n+    }\n+\n+    public PravegaConnectionListener(boolean enableTls, boolean enableTlsReload, String host, int port, StreamSegmentStore streamSegmentStore, TableStore tableStore,\n+                                     SegmentStatsRecorder statsRecorder, TableSegmentStatsRecorder tableStatsRecorder,\n+                                     DelegationTokenVerifier tokenVerifier, String certFile, String keyFile,\n+                                     boolean replyWithStackTraceOnError) {\n+        this(enableTls, enableTlsReload, host, port, streamSegmentStore, tableStore, statsRecorder, tableStatsRecorder,\n+                tokenVerifier, certFile, keyFile, replyWithStackTraceOnError,\n+                ExecutorServiceHelpers.newScheduledThreadPool(1, \"test-token-expiry-handler\"));", "originalCommit": "19570c74fa3403b0752b8fb56f1082e52de34d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxNzIwNg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424517206", "bodyText": "That constructor was being used in unit tests. I've modified it to inject the executor from outside, and have modified the tests.", "author": "ravisharda", "createdAt": "2020-05-13T15:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM3OTIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4MTkyNQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422381925", "bodyText": "This is such a small amount of json, and it doesn't even have nesting. Rather than dealing with dependency managment of Gson can we just use a Format template?", "author": "tkaitchuck", "createdAt": "2020-05-08T21:22:35Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/JwtBody.java", "diffHunk": "@@ -20,7 +20,7 @@\n @Builder\n @Getter\n @Setter\n-class JwtBody {\n+public class JwtBody {", "originalCommit": "19570c74fa3403b0752b8fb56f1082e52de34d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxODA2OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424518068", "bodyText": "This is an existing piece of code and I think we should explore seeing if that'd make sense and do the change separately of this PR.", "author": "ravisharda", "createdAt": "2020-05-13T15:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4MTkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4Mjk3Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r422382976", "bodyText": "This doesn't appear to be used anywhere.", "author": "tkaitchuck", "createdAt": "2020-05-08T21:25:09Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -66,13 +66,15 @@\n public class ServiceBuilder implements AutoCloseable {\n     //region Members\n \n-    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(30);\n+    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(45);\n     private final SegmentStoreMetrics.ThreadPool threadPoolMetrics;\n     private final SegmentToContainerMapper segmentToContainerMapper;\n     private final ServiceBuilderConfig serviceBuilderConfig;\n     @Getter(AccessLevel.PROTECTED)\n     private final ScheduledExecutorService coreExecutor;\n     private final ScheduledExecutorService storageExecutor;\n+    @Getter(AccessLevel.PUBLIC)\n+    private final ScheduledExecutorService lowPriorityExecutor;", "originalCommit": "19570c74fa3403b0752b8fb56f1082e52de34d94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxODcwNQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424518705", "bodyText": "We were using it in ServiceStarter. Now, we also use it elsewhere as you can see in the latest push.", "author": "ravisharda", "createdAt": "2020-05-13T15:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM4Mjk3Ng=="}], "type": "inlineReview"}, {"oid": "330376d8889e2f0c5a2c278baa166634cd64d2f8", "url": "https://github.com/pravega/pravega/commit/330376d8889e2f0c5a2c278baa166634cd64d2f8", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-05-13T04:17:41Z", "type": "commit"}, {"oid": "bdd1b91dc2634453ac46ab3a328f8fea0d430844", "url": "https://github.com/pravega/pravega/commit/bdd1b91dc2634453ac46ab3a328f8fea0d430844", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-13T11:35:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDI4NA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r424860284", "bodyText": "can we ensure close() is invoked only once? i.e\nif (isClosed.compareAndSet(false, true) ) {\n   Channel ch = ...\n}", "author": "shrids", "createdAt": "2020-05-14T04:11:37Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/ServerConnectionInboundHandler.java", "diffHunk": "@@ -84,6 +87,12 @@ public void close() {\n             // wait for all messages to be sent before closing the channel.\n             ch.eventLoop().execute(() -> ch.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE));\n         }\n+        isClosed.compareAndSet(false, true);", "originalCommit": "bdd1b91dc2634453ac46ab3a328f8fea0d430844", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MDA1NQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425070055", "bodyText": "Ok, I've moved the check as suggested.", "author": "ravisharda", "createdAt": "2020-05-14T11:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDI4NA=="}], "type": "inlineReview"}, {"oid": "8ea88352da66f936b555a3dc69d97348fa339b4e", "url": "https://github.com/pravega/pravega/commit/8ea88352da66f936b555a3dc69d97348fa339b4e", "message": "Make token verifier return JsonWebToken\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-14T11:35:14Z", "type": "commit"}, {"oid": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "url": "https://github.com/pravega/pravega/commit/1e2b17c28f73e2c46016475600b21ff2eaca23d2", "message": "Remove redundant delegation token expiry check in AppendProcessor\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-14T15:21:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2MzI2MA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425563260", "bodyText": "+1", "author": "shrids", "createdAt": "2020-05-15T04:44:57Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/delegationtoken/DelegationTokenVerifier.java", "diffHunk": "@@ -33,7 +34,8 @@\n      * @throws InvalidClaimException  if the {@code token} does not contain the claim representing\n      *                                {@code expectedLevel} of access\n      * @throws TokenException         if any other failure condition is encountered\n+     * @return JsonWebToken           a non-null value if token was parsed and verified successfully, otherwise null.\n      */\n-    void verifyToken(String resource, String token, AuthHandler.Permissions expectedLevel)\n+    JsonWebToken verifyToken(String resource, String token, AuthHandler.Permissions expectedLevel)", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2NDY0OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425564648", "bodyText": "Should this be bumped to ERROR log level ?", "author": "shrids", "createdAt": "2020-05-15T04:51:19Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -328,8 +361,7 @@ private void handleException(UUID writerId, long requestId, String segment, long\n             connection.close();\n         } else if (u instanceof TokenExpiredException) {\n             log.warn(requestId, \"Token expired for writer {} on segment {}.\", writerId, segment, u);", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzAzMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133032", "bodyText": "ERROR would be too harsh here, as things continue to function normally.", "author": "ravisharda", "createdAt": "2020-05-16T08:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU2NDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NTM4Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r425955387", "bodyText": "Should this have a defensive copy?", "author": "tkaitchuck", "createdAt": "2020-05-15T17:46:39Z", "path": "shared/security/src/main/java/io/pravega/shared/security/token/JsonWebToken.java", "diffHunk": "@@ -107,6 +104,19 @@ public JsonWebToken(@NonNull String subject, @NonNull String audience, @NonNull\n         this.permissionsByResource = resourcePermissionClaims;\n     }\n \n+    public JsonWebToken(@NonNull String subject, @NonNull String audience, @NonNull byte[] signingKey,\n+                        Date expiry, Map<String, Object> resourcePermissionClaims) {\n+        this.subject = subject;\n+        this.audience = audience;\n+        this.signingKey = signingKey.clone();\n+        if (expiry != null) {\n+            this.expirationTime = Date.from(expiry.toInstant());\n+        } else {\n+            this.expirationTime = null;\n+        }\n+        this.permissionsByResource = resourcePermissionClaims;", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjU4NA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426132584", "bodyText": "The class is used internally. I had to make a defensive copy of expiration time and bytes to satisfy Spotbugs.", "author": "ravisharda", "createdAt": "2020-05-16T08:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwNzM3NQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426007375", "bodyText": "Why do you return a future when you don't use it?", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:33:18Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -167,6 +173,33 @@ public void setupAppend(SetupAppend setupAppend) {\n                 });\n     }\n \n+    @VisibleForTesting\n+    CompletableFuture<Void> setupTokenExpiryTask(@NonNull SetupAppend setupAppend, @NonNull JsonWebToken token) {", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMDA1OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426110058", "bodyText": "A couple of tests use the future to wait for task completion before making the assertion.", "author": "ravisharda", "createdAt": "2020-05-16T02:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwNzM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODMyOQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426008329", "bodyText": "Please do everything you can to avoid sleeping arbitrary amounts of time in unit tests. This just adds unnecessary delays.", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:35:22Z", "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/AppendProcessorTest.java", "diffHunk": "@@ -124,6 +136,101 @@ public void testAppend() {\n         verifyNoMoreInteractions(store);\n \n         verify(mockedRecorder).recordAppend(eq(streamSegmentName), eq(8L), eq(1), any());\n+        assertTrue(processor.isSetupAppendCompleted(setupAppendCommand.getSegment(), setupAppendCommand.getWriterId()));\n+    }\n+\n+    @Test\n+    public void testSetupAppendClosesConnectionIfTokenHasExpired() {\n+        String streamSegmentName = \"scope/stream/0.#epoch.0\";\n+        UUID clientId = UUID.randomUUID();\n+        byte[] data = new byte[] { 1, 2, 3, 4, 6, 7, 8, 9 };\n+        StreamSegmentStore store = mock(StreamSegmentStore.class);\n+        ServerConnection connection = mock(ServerConnection.class);\n+        ConnectionTracker tracker = mock(ConnectionTracker.class);\n+        val mockedRecorder = Mockito.mock(SegmentStatsRecorder.class);\n+\n+        AppendProcessor processor = AppendProcessor.defaultBuilder()\n+                .store(store)\n+                .connection(connection)\n+                .connectionTracker(tracker)\n+                .statsRecorder(mockedRecorder)\n+                .tokenVerifier(new TokenVerifierImpl(\"secret\"))\n+                .build();\n+\n+        setupGetAttributes(streamSegmentName, clientId, store);\n+        val ac = interceptAppend(store, streamSegmentName, updateEventNumber(clientId, data.length), CompletableFuture.completedFuture((long) data.length));\n+\n+        Date expiryDate = Date.from(Instant.now().minusSeconds(100));\n+        JsonWebToken token = new JsonWebToken(\"subject\", \"audience\", \"secret\".getBytes(), expiryDate, null);\n+\n+        SetupAppend setupAppend = new SetupAppend(1, clientId, streamSegmentName, token.toCompactString());\n+        processor.setupAppend(setupAppend);\n+        verify(connection).close();\n+    }\n+\n+    @Test\n+    public void testSetupTokenExpiryTaskClosesConnectionIfTokenHasExpired() throws InterruptedException {\n+        // Arrange\n+        String streamSegmentName = \"scope/stream/0.#epoch.0\";\n+        UUID clientId = UUID.randomUUID();\n+\n+        StreamSegmentStore mockStore = mock(StreamSegmentStore.class);\n+        ServerConnection mockConnection = mock(ServerConnection.class);\n+\n+        @Cleanup(\"shutdown\")\n+        ScheduledExecutorService executor = new InlineExecutor();\n+        AppendProcessor processor = AppendProcessor.defaultBuilder()\n+                .store(mockStore)\n+                .connection(mockConnection)\n+                .tokenExpiryHandlerExecutor(executor)\n+                .build();\n+\n+        // Spy the actual Append Processor, so that we can have some of the methods return stubbed values.\n+        AppendProcessor mockProcessor = spy(processor);\n+        doReturn(true).when(mockProcessor).isSetupAppendCompleted(streamSegmentName, clientId);\n+        // doReturn(Duration.ofMillis(20)).when(mockProcessor);\n+\n+        JsonWebToken token = new JsonWebToken(\"subject\", \"audience\", \"secret\".getBytes(),\n+                Date.from(Instant.now().plusMillis(100)), null);\n+        SetupAppend setupAppend = new SetupAppend(1, clientId, streamSegmentName, token.toCompactString());\n+\n+        Thread.sleep(100);", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMjY4Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426132686", "bodyText": "Yeah, I agree with you fully. This was supposed to be a stop-gap, until I found a better solution, but I pushed the change by mistake. In any case, the solution turned out to be quite simple, and I have pushed the change in the latest commit.", "author": "ravisharda", "createdAt": "2020-05-16T08:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODUxMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426008512", "bodyText": "Why?", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:35:48Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -66,13 +66,15 @@\n public class ServiceBuilder implements AutoCloseable {\n     //region Members\n \n-    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(30);\n+    private static final Duration SHUTDOWN_TIMEOUT = Duration.ofSeconds(45);", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMTQ2MQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426111461", "bodyText": "This is to give some allowance as we will also be closing the new lowPriorityExecutor in addition to the two preexisting executors coreExecutor and storageExecutor. I just made a simplistic assumption here that if we give two executors 30 seconds, then we should give three of them 45.", "author": "ravisharda", "createdAt": "2020-05-16T03:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODgyNA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426008824", "bodyText": "What does 2 mean here? Above you use Thread.NORM_PRIORITY. Is there another constant you can use?", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:36:40Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -122,8 +124,10 @@ private ServiceBuilder(ServiceBuilderConfig serviceBuilderConfig, ServiceConfig\n \n         // Setup Thread Pools.\n         String instancePrefix = getInstanceIdPrefix(serviceConfig);\n-        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\");\n-        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\");\n+        this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\", Thread.NORM_PRIORITY);\n+        this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\", Thread.NORM_PRIORITY);\n+        this.lowPriorityExecutor =", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTA5Ng==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426009096", "bodyText": "Also do not hardcode the number of threads. Please add an entry in ServiceConfig, default it to 10, so that we may change it at any time if we encounter problems.", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE2MzExMQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426163111", "bodyText": "Sure, done.", "author": "ravisharda", "createdAt": "2020-05-16T15:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwODgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTc1OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426009758", "bodyText": "Undo", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:38:48Z", "path": "test/integration/src/test/java/io/pravega/test/integration/ReaderGroupTest.java", "diffHunk": "@@ -67,7 +67,7 @@ public void run() {\n         }\n     }\n \n-    @Test(timeout = 20000)\n+    @Test//(timeout = 20000)", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzA2OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133068", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2020-05-16T08:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAwOTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDQ3Mw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010473", "bodyText": "This is probably going to hurt someone at one point if they don't know they work with this. If the return value is null, and they want to cancel it, they'll hit a nullptr exception. You'll need to return a no-op future for this.", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:40:23Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzEzNw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133137", "bodyText": "Sure, I've modified the code return a dummy scheduled future.", "author": "ravisharda", "createdAt": "2020-05-16T08:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDY4OA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010688", "bodyText": "Does this return value match the contract of Executor.shutdownNow?", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:40:52Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzEwMw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133103", "bodyText": "Yes. I've modified the code to return an empty list.", "author": "ravisharda", "createdAt": "2020-05-16T08:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDgwMg==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010802", "bodyText": "Should return true if you invoked shutdown", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:41:08Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE1OTU1Mw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426159553", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2020-05-16T14:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDkxOQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010919", "bodyText": "Should return true if terminated.", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:41:24Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzE0Mw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133143", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-05-16T08:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDk4Nw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426010987", "bodyText": "same comment as above.", "author": "andreipaduroiu", "createdAt": "2020-05-15T19:41:34Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.test.common;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+/**\n+ * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * placeholder for unused scheduled executor in tests.\n+ */\n+public class NoOpScheduledExecutor implements ScheduledExecutorService {\n+\n+    private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n+\n+    public static NoOpScheduledExecutor get() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n+        return null;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n+        return false;\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> callable) {\n+        return null;", "originalCommit": "1e2b17c28f73e2c46016475600b21ff2eaca23d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEzMzIxNw==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426133217", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2020-05-16T08:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxMDk4Nw=="}], "type": "inlineReview"}, {"oid": "ecb991f21cde480eff4babb45fd0a88a5dc78f0e", "url": "https://github.com/pravega/pravega/commit/ecb991f21cde480eff4babb45fd0a88a5dc78f0e", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-16T08:23:13Z", "type": "commit"}, {"oid": "dbf90e6649ddec2c7a18a10a5225412a8c77537b", "url": "https://github.com/pravega/pravega/commit/dbf90e6649ddec2c7a18a10a5225412a8c77537b", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-16T15:19:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTkzMQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426771931", "bodyText": "Why can't you use Thread.MIN_PRIORITY?", "author": "andreipaduroiu", "createdAt": "2020-05-18T17:04:25Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/store/ServiceBuilder.java", "diffHunk": "@@ -126,8 +126,8 @@ private ServiceBuilder(ServiceBuilderConfig serviceBuilderConfig, ServiceConfig\n         String instancePrefix = getInstanceIdPrefix(serviceConfig);\n         this.coreExecutor = executorBuilder.apply(serviceConfig.getCoreThreadPoolSize(), instancePrefix + \"core\", Thread.NORM_PRIORITY);\n         this.storageExecutor = executorBuilder.apply(serviceConfig.getStorageThreadPoolSize(), instancePrefix + \"storage-io\", Thread.NORM_PRIORITY);\n-        this.lowPriorityExecutor =\n-                executorBuilder.apply(10, instancePrefix + \"low-priority-cleanup\", 2);\n+        this.lowPriorityExecutor = executorBuilder.apply(serviceConfig.getLowPriorityThreadPoolSize(),\n+                instancePrefix + \"low-priority-cleanup\", 2);", "originalCommit": "dbf90e6649ddec2c7a18a10a5225412a8c77537b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5NTI5NA==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426795294", "bodyText": "Sure, done.", "author": "ravisharda", "createdAt": "2020-05-18T17:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3MTkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3Mjg0OQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426772849", "bodyText": "Hmm.. I wonder how come checkstyle didn't catch this. We shouldn't define more than one class/interface per file.\nYou should move this as a static nested class inside the NoOpScheduledExecutor class.", "author": "andreipaduroiu", "createdAt": "2020-05-18T17:06:06Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/NoOpScheduledExecutor.java", "diffHunk": "@@ -9,110 +9,173 @@\n  */\n package io.pravega.test.common;\n \n+import lombok.EqualsAndHashCode;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Delayed;\n import java.util.concurrent.Future;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /**\n- * A fake implementation of ScheduledExecutorService that does nothing. An INSTANCE of this class may be used as a\n+ * A fake implementation of ScheduledExecutorService that does nothing. An instance of this class may be used as a\n  * placeholder for unused scheduled executor in tests.\n  */\n public class NoOpScheduledExecutor implements ScheduledExecutorService {\n \n     private static final NoOpScheduledExecutor INSTANCE = new NoOpScheduledExecutor();\n \n+    private AtomicBoolean isShutDown = new AtomicBoolean(false);\n+\n     public static NoOpScheduledExecutor get() {\n         return INSTANCE;\n     }\n \n     @Override\n     public ScheduledFuture<?> schedule(Runnable runnable, long l, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public <V> ScheduledFuture<V> schedule(Callable<V> callable, long l, TimeUnit timeUnit) {\n-        return null;\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public ScheduledFuture<?> scheduleAtFixedRate(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public ScheduledFuture<?> scheduleWithFixedDelay(Runnable runnable, long l, long l1, TimeUnit timeUnit) {\n-        return null;\n+        return new DummyScheduledFuture(0);\n     }\n \n     @Override\n     public void shutdown() {\n-\n+        isShutDown.set(true);\n     }\n \n     @Override\n     public List<Runnable> shutdownNow() {\n-        return null;\n+        isShutDown.set(true);\n+        return new ArrayList<>();\n     }\n \n     @Override\n     public boolean isShutdown() {\n-        return false;\n+        return isShutDown.get();\n     }\n \n     @Override\n     public boolean isTerminated() {\n-        return false;\n+        return isShutDown.get();\n     }\n \n     @Override\n-    public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {\n-        return false;\n+    public boolean awaitTermination(long l, TimeUnit timeUnit) {\n+        return isShutDown.get();\n     }\n \n     @Override\n     public <T> Future<T> submit(Callable<T> callable) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n     public <T> Future<T> submit(Runnable runnable, T t) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n     public Future<?> submit(Runnable runnable) {\n-        return null;\n+        return CompletableFuture.completedFuture(null);\n     }\n \n     @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) throws InterruptedException {\n-        return null;\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection) {\n+        return new ArrayList<>();\n     }\n \n     @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) throws InterruptedException {\n-        return null;\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) {\n+        return new ArrayList<>();\n     }\n \n     @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> collection) throws InterruptedException, ExecutionException {\n-        return null;\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection) {\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {\n-        return null;\n+    public <T> T invokeAny(Collection<? extends Callable<T>> collection, long l, TimeUnit timeUnit) {\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public void execute(Runnable runnable) {\n+    }\n+}\n+\n+@EqualsAndHashCode // Required to keep Spotbugs satisfied (owing to code in `compareTo()`).\n+@RequiredArgsConstructor\n+class DummyScheduledFuture implements ScheduledFuture<Integer> {", "originalCommit": "dbf90e6649ddec2c7a18a10a5225412a8c77537b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc5NTUzOQ==", "url": "https://github.com/pravega/pravega/pull/4692#discussion_r426795539", "bodyText": "Yeah, that sounds good. Done.", "author": "ravisharda", "createdAt": "2020-05-18T17:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc3Mjg0OQ=="}], "type": "inlineReview"}, {"oid": "42a0947ef325bff565379dfa785d3f35fe88e856", "url": "https://github.com/pravega/pravega/commit/42a0947ef325bff565379dfa785d3f35fe88e856", "message": "Merge branch 'master' into honor-tokenexpiry-upon-writes", "committedDate": "2020-05-18T17:06:18Z", "type": "commit"}, {"oid": "27a922cdae977a81c102d52076261787ac61c918", "url": "https://github.com/pravega/pravega/commit/27a922cdae977a81c102d52076261787ac61c918", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-05-18T17:46:43Z", "type": "commit"}]}