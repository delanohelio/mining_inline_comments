{"pr_number": 5413, "pr_title": "Issue 4903: More robust garbage collection", "pr_createdAt": "2020-12-09T07:24:22Z", "pr_url": "https://github.com/pravega/pravega/pull/5413", "timeline": [{"oid": "ece091149046cd5142060a30c1cdeb6c6fe1902a", "url": "https://github.com/pravega/pravega/commit/ece091149046cd5142060a30c1cdeb6c6fe1902a", "message": "Issue 4903: (SLTS) Mark the chunk metadata as 'deleted' instead of directly deleting it.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-09T05:45:43Z", "type": "commit"}, {"oid": "207d75175235455b22c74ee206e0b2774b0b7a7b", "url": "https://github.com/pravega/pravega/commit/207d75175235455b22c74ee206e0b2774b0b7a7b", "message": "ssue 4903: (SLTS) Separate out chunk garbage collection.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-09T06:34:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzUzNA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539483534", "bodyText": "This sounds like a great utility in common. Mind if you add it there?", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:03:21Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorage.java", "diffHunk": "@@ -662,14 +634,21 @@ public boolean supportsTruncation() {\n \n     @Override\n     public void close() {\n+        close(\"metadataStore\", this.metadataStore);\n+        close(\"garbageCollector\", this.garbageCollector);\n+        this.closed.set(true);\n+    }\n+\n+    private void close(String message, AutoCloseable toClose) {", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzgxNg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539483816", "bodyText": "Let's not pollute the logs with so many messages. Make the \"Closing\" one debug.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:03:42Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorage.java", "diffHunk": "@@ -662,14 +634,21 @@ public boolean supportsTruncation() {\n \n     @Override\n     public void close() {\n+        close(\"metadataStore\", this.metadataStore);\n+        close(\"garbageCollector\", this.garbageCollector);\n+        this.closed.set(true);\n+    }\n+\n+    private void close(String message, AutoCloseable toClose) {\n         try {\n-            if (null != this.metadataStore) {\n-                this.metadataStore.close();\n+            log.info(\"{} Closing {}\", logPrefix, message);\n+            if (null != toClose) {\n+                toClose.close();\n             }\n+            log.info(\"{} Closed {}\", logPrefix, message);", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4NzYyMQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542787621", "bodyText": "done", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4NDY4Mw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539484683", "bodyText": "Why async on this tiny one? If you don't have debug enabled, this won't even do anything?\nPlease try to reduce the number of Async calls, especially if the code you execute is very simple.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:04:51Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorage.java", "diffHunk": "@@ -178,7 +174,9 @@ public ChunkedSegmentStorage(int containerId, ChunkStorage chunkStorage, ChunkMe\n \n         // Now bootstrap\n         log.debug(\"{} STORAGE BOOT: Started.\", logPrefix);\n-        return this.systemJournal.bootstrap(epoch).thenRunAsync(() -> log.debug(\"{} STORAGE BOOT: Ended.\", logPrefix), executor);\n+        return this.systemJournal.bootstrap(epoch)\n+                .thenRunAsync(() -> garbageCollector.initialize())\n+                .thenRunAsync(() -> log.debug(\"{} STORAGE BOOT: Ended.\", logPrefix), executor);", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODE0Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541778147", "bodyText": "Fixed", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4NDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4NzcwNA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539487704", "bodyText": "Why isn't this a Duration? Then you don't have to worry about converting to seconds, millis, or whatever", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:08:56Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageConfig.java", "diffHunk": "@@ -124,6 +128,19 @@\n     @Getter\n     final private int lateWarningThresholdInMillis;\n \n+    /**\n+     * Minimum delay in seconds between when garbage chunks are marked for deletion and actually deleted.\n+     */\n+    @Getter\n+    final private int garbageCollectionFrequencyInSeconds;", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODIwOQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541778209", "bodyText": "fixed", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4NzcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4ODAwNg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539488006", "bodyText": "Validate these settings here.\nMake sure they're not negative (or too big).", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:09:20Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageConfig.java", "diffHunk": "@@ -142,6 +159,8 @@\n         long defaultMaxLength = properties.getLong(DEFAULT_ROLLOVER_SIZE);\n         this.defaultRollingPolicy = new SegmentRollingPolicy(defaultMaxLength);\n         this.lateWarningThresholdInMillis = properties.getInt(SELF_CHECK_LATE_WARNING_THRESHOLD);\n+        this.garbageCollectionFrequencyInSeconds = properties.getInt(GARBAGE_COLLECTION_DELAY);", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4OTY1Mw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539489653", "bodyText": "See, this is exactly why keeping that property as a Duration is a good thing.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:11:33Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxODY2Ng==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542818666", "bodyText": "done.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4OTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4OTczNQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539489735", "bodyText": "Null checks", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:11:39Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MDg4OQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539490889", "bodyText": "Make this class extend from AbstractThreadPoolService and follow that pattern. See StorageWriter.java for an example.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:13:07Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxOTAxNw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542819017", "bodyText": "done.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MTMzNw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539491337", "bodyText": "There is no need for this pattern here. Please get rid of CompletableFuture.completedFuture().thenCompose", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:13:45Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg0NDI5NA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542844294", "bodyText": "outdated. But new code doesn't have it.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T22:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MTY0OA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539491648", "bodyText": "This will double-log the exception. Remove the second {}.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:14:12Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxOTQ4NQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542819485", "bodyText": "ok.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MjQxOQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539492419", "bodyText": "How will garbage collection work across failover? This time won't persist in that case.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:15:12Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MjgwOA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539492808", "bodyText": "Why is this a CompletableFuture? Change this method to not return this.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:15:41Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxOTY3MQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542819671", "bodyText": "made void", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MzI2MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539493260", "bodyText": "Properly document the behavior of this method if it's suspended, background ,etc.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:16:20Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MzM5OQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539493399", "bodyText": "Log it. (Debug)", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:16:32Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        if (suspended.get() && isBackground) {\n+            return CompletableFuture.completedFuture(null);", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxOTk4OA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542819988", "bodyText": "done.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MzM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NDE3Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539494177", "bodyText": "I don't know how you are planning to unit test this, but I would take a constructor that provides a Supplier<Long> getTimeMillis which I can use in my tests. Then your default constructor can pass System::currentTimeMillis to that arg.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:17:29Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        if (suspended.get() && isBackground) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+        val currentTime = System.currentTimeMillis();", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyMDg2MQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542820861", "bodyText": "done.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NDE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NTQ0Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539495447", "bodyText": "Why is garbageChunks a Map? Are you expecting to insert duplicates (that would smell like a bug).\nI suggest you add a sorted list or something, sort by time, and then in this list you only need to loop through those items that need deletion (i.e, do not do an O(n) lookup every time).", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:19:09Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        if (suspended.get() && isBackground) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+        val currentTime = System.currentTimeMillis();\n+        val chunksToDelete = new ArrayList<String>();\n+        int count = 0;\n+        for (val entry : garbageChunks.entrySet()) {", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyMDI1OA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542820258", "bodyText": "changed to priority queue", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NTQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NjE0MQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539496141", "bodyText": "If you do a sorted list, you may even be able to compress this whole block into a stream() with limit and filter.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:19:57Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        if (suspended.get() && isBackground) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+        val currentTime = System.currentTimeMillis();\n+        val chunksToDelete = new ArrayList<String>();\n+        int count = 0;\n+        for (val entry : garbageChunks.entrySet()) {\n+            if (canDelete(entry.getValue(), currentTime)) {\n+                chunksToDelete.add(entry.getKey());\n+                // Throttle how many chunks are deleted at once.\n+                if (++count >= maxItems) {", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg0NTAzNA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542845034", "bodyText": "out dated . But new code has different structure.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T22:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NjE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5Njg3MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539496870", "bodyText": "Which executor are you running this on? Most likely it will go onto ForkJoinPool.commonPool() if you don't explicitly pass one.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:20:58Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        if (suspended.get() && isBackground) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+        val currentTime = System.currentTimeMillis();\n+        val chunksToDelete = new ArrayList<String>();\n+        int count = 0;\n+        for (val entry : garbageChunks.entrySet()) {\n+            if (canDelete(entry.getValue(), currentTime)) {\n+                chunksToDelete.add(entry.getKey());\n+                // Throttle how many chunks are deleted at once.\n+                if (++count >= maxItems) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (val chunkToDelete : chunksToDelete) {\n+            val txn = chunkedSegmentStorage.getMetadataStore().beginTransaction(false, chunkToDelete);\n+            val future =\n+                    txn.get(chunkToDelete)\n+                    .thenComposeAsync( metadata -> {\n+                            val chunkMetadata = (ChunkMetadata) metadata;\n+                            // Check whether the chunk is marked as inactive\n+                            if (!chunkMetadata.isActive()) {\n+                                return chunkedSegmentStorage.getChunkStorage().openWrite(chunkToDelete)\n+                                        .thenComposeAsync(chunkedSegmentStorage.getChunkStorage()::delete, chunkedSegmentStorage.getExecutor())\n+                                        .thenRunAsync(() -> {\n+                                            garbageChunks.remove(chunkToDelete);\n+                                            txn.delete(chunkToDelete);\n+                                            log.debug(\"{} deleteGarbage - deleted chunk={}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                        }, chunkedSegmentStorage.getExecutor())\n+                                        .thenComposeAsync(v -> txn.commit(), chunkedSegmentStorage.getExecutor())\n+                                        .exceptionally(e -> {\n+                                            val ex = Exceptions.unwrap(e);\n+                                            if (ex instanceof ChunkNotFoundException) {\n+                                                log.debug(\"{} deleteGarbage - Could not delete garbage chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                            } else {\n+                                                log.warn(\"{} deleteGarbage - Could not delete garbage chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                            }\n+                                            return null;\n+                                        });\n+                            } else {\n+                                log.info(\"{} deleteGarbage - Chunk is not marked as garbage{}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                return CompletableFuture.completedFuture(null);\n+                            }\n+                        })\n+                    .whenCompleteAsync((v, ex) -> {", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyMDQ5Mg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542820492", "bodyText": "fixed.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5Njg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NzY5MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539497690", "bodyText": "In this close, you should probably wait for your run future to complete as well. The contract for close is that when it exits, any activities started by this instance will have ended.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:22:09Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ */\n+@Slf4j\n+public class GarbageCollector implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final ConcurrentHashMap<String, Long> garbageChunks = new ConcurrentHashMap<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    private final long delayInMillis;\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        this.chunkedSegmentStorage = chunkedSegmentStorage;\n+        this.config = config;\n+        this.delayInMillis = Duration.ofSeconds(config.getGarbageCollectionFrequencyInSeconds()).toMillis();\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        loopFuture = run();\n+    }\n+\n+    public CompletableFuture<Void> run() {\n+        return Futures.loop(\n+                () -> !closed.get(),\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()),\n+                                chunkedSegmentStorage.getExecutor())\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run {}.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }), chunkedSegmentStorage.getExecutor());\n+    }\n+\n+    /**\n+     * Sets whether backgound claenup is suspended or not.\n+     * @param value\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    CompletableFuture<Void> addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+        chunksToDelete.forEach(chunkToDelete -> garbageChunks.put(chunkToDelete, currentTime));\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        if (suspended.get() && isBackground) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+        val currentTime = System.currentTimeMillis();\n+        val chunksToDelete = new ArrayList<String>();\n+        int count = 0;\n+        for (val entry : garbageChunks.entrySet()) {\n+            if (canDelete(entry.getValue(), currentTime)) {\n+                chunksToDelete.add(entry.getKey());\n+                // Throttle how many chunks are deleted at once.\n+                if (++count >= maxItems) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (val chunkToDelete : chunksToDelete) {\n+            val txn = chunkedSegmentStorage.getMetadataStore().beginTransaction(false, chunkToDelete);\n+            val future =\n+                    txn.get(chunkToDelete)\n+                    .thenComposeAsync( metadata -> {\n+                            val chunkMetadata = (ChunkMetadata) metadata;\n+                            // Check whether the chunk is marked as inactive\n+                            if (!chunkMetadata.isActive()) {\n+                                return chunkedSegmentStorage.getChunkStorage().openWrite(chunkToDelete)\n+                                        .thenComposeAsync(chunkedSegmentStorage.getChunkStorage()::delete, chunkedSegmentStorage.getExecutor())\n+                                        .thenRunAsync(() -> {\n+                                            garbageChunks.remove(chunkToDelete);\n+                                            txn.delete(chunkToDelete);\n+                                            log.debug(\"{} deleteGarbage - deleted chunk={}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                        }, chunkedSegmentStorage.getExecutor())\n+                                        .thenComposeAsync(v -> txn.commit(), chunkedSegmentStorage.getExecutor())\n+                                        .exceptionally(e -> {\n+                                            val ex = Exceptions.unwrap(e);\n+                                            if (ex instanceof ChunkNotFoundException) {\n+                                                log.debug(\"{} deleteGarbage - Could not delete garbage chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                            } else {\n+                                                log.warn(\"{} deleteGarbage - Could not delete garbage chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                            }\n+                                            return null;\n+                                        });\n+                            } else {\n+                                log.info(\"{} deleteGarbage - Chunk is not marked as garbage{}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                return CompletableFuture.completedFuture(null);\n+                            }\n+                        })\n+                    .whenCompleteAsync((v, ex) -> {\n+                        txn.close();\n+                    });\n+                    futures.add(future);\n+        }\n+        return Futures.allOf(futures);\n+    }\n+\n+    /**\n+     * Marks given chunk as not garbage.\n+     *\n+     * @param chunkName Name of the chunk.\n+     */\n+    void removeFromGarbage(String chunkName) {\n+        garbageChunks.remove(chunkName);\n+    }\n+\n+    boolean canDelete(long time, long currentTime) {\n+        return delayInMillis < (currentTime - time);\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+        closed.set(true);", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMDA0MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539500040", "bodyText": "I would not be making these public. Please make sure that any setFlag/getFlag method is private to the class(es) they are defined in and you expose proper methods to set them. Nobody likes to deal with flags and masks.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:25:26Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/metadata/Constants.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.metadata;\n+\n+/**\n+ * Class that defines various constants.\n+ */\n+public final class Constants {", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxNjg4Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542816887", "bodyText": "need to use in two package.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMDA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMDU4MQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539500581", "bodyText": "Add @Cleanup to all the objects here that implement AutoCloseable", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:26:11Z", "path": "segmentstore/storage/src/test/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageMockTests.java", "diffHunk": "@@ -326,13 +326,16 @@ public void testIOExceptionDuringWrite() throws Exception {\n     public void testFileNotFoundExceptionDuringGarbageCollection() throws Exception {\n         String testSegmentName = \"test\";\n         SegmentRollingPolicy policy = new SegmentRollingPolicy(2); // Force rollover after every 2 byte.\n-        val config = ChunkedSegmentStorageConfig.DEFAULT_CONFIG.toBuilder().defaultRollingPolicy(policy).build();\n+        val config = ChunkedSegmentStorageConfig.DEFAULT_CONFIG.toBuilder()\n+                .garbageCollectionFrequencyInSeconds(0)\n+                .build();\n \n         BaseMetadataStore spyMetadataStore = spy(new InMemoryMetadataStore(executorService()));", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4ODgxOA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542788818", "bodyText": "done", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMDU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMDk5MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539500990", "bodyText": "Does this mean that your test takes 8s or more to run?", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:26:43Z", "path": "segmentstore/storage/src/test/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageMockTests.java", "diffHunk": "@@ -345,20 +348,26 @@ public void testFileNotFoundExceptionDuringGarbageCollection() throws Exception\n         doThrow(exceptionToThrow).when(spyChunkStorage).doDelete(any());\n \n         chunkedSegmentStorage.delete(h1, null).get();\n+        Assert.assertEquals(5, chunkedSegmentStorage.getGarbageCollector().getGarbageChunks().size());\n+        chunkedSegmentStorage.getGarbageCollector().deleteGarbage(false, 100).get();\n         verify(spyChunkStorage, times(5)).doDelete(any());\n     }\n \n     @Test\n     public void testExceptionDuringGarbageCollection() throws Exception {\n         String testSegmentName = \"test\";\n         SegmentRollingPolicy policy = new SegmentRollingPolicy(2); // Force rollover after every 2 byte.\n-        val config = ChunkedSegmentStorageConfig.DEFAULT_CONFIG.toBuilder().defaultRollingPolicy(policy).build();\n+        val config = ChunkedSegmentStorageConfig.DEFAULT_CONFIG.toBuilder()\n+                .defaultRollingPolicy(policy)\n+                .garbageCollectionFrequencyInSeconds(0)", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2OTY4Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539569687", "bodyText": "No. It is the other way round i want 0 delay.", "author": "sachin-j-joshi", "createdAt": "2020-12-09T19:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMDk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxNjQwMg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542816402", "bodyText": "outdated.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMDk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMTM1MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r539501350", "bodyText": "Commented out code. Delete or reinstate.", "author": "andreipaduroiu", "createdAt": "2020-12-09T17:27:12Z", "path": "segmentstore/storage/src/test/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageTests.java", "diffHunk": "@@ -1785,15 +1788,20 @@ public void testTruncateWithFailover() throws Exception {\n         // Make sure to open segment with new instance before writing garbage to old instance.\n         hWrite = newTestContext.chunkedSegmentStorage.openWrite(testSegmentName).get();\n         newTestContext.chunkedSegmentStorage.truncate(hWrite, offset, null).get();\n+        newTestContext.chunkedSegmentStorage.getGarbageCollector().setSuspended(true);\n+        newTestContext.chunkedSegmentStorage.getGarbageCollector().deleteGarbage(false, 100).get();\n         //checkDataRead(testSegmentName, testContext, offset, 0);\n         TestUtils.checkSegmentBounds(newTestContext.metadataStore, testSegmentName, offset, offset);\n \n         AssertExtensions.assertFutureThrows(\"openWrite() allowed after fencing\",\n                 oldTestCotext.chunkedSegmentStorage.openWrite(testSegmentName),\n                 ex -> ex instanceof StorageNotPrimaryException);\n+        /*", "originalCommit": "207d75175235455b22c74ee206e0b2774b0b7a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgxMzYxMg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542813612", "bodyText": "fixed.", "author": "sachin-j-joshi", "createdAt": "2020-12-14T21:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwMTM1MA=="}], "type": "inlineReview"}, {"oid": "3c4ddb347bb5193d00fd9afe2c43703fd6b2d13f", "url": "https://github.com/pravega/pravega/commit/3c4ddb347bb5193d00fd9afe2c43703fd6b2d13f", "message": "Issue 4903: (SLTS) Separate out chunk garbage collection.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-10T16:08:05Z", "type": "commit"}, {"oid": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "url": "https://github.com/pravega/pravega/commit/85088f1862ecd36a10c967d992ac88a11f99c7c3", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4903-improve-garbage-collection-2\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>\n\n# Conflicts:\n#\tsegmentstore/storage/src/test/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageTests.java", "committedDate": "2020-12-10T17:50:45Z", "type": "commit"}, {"oid": "f80c3afd332d0d31e730c5ef0fa58441be791f7d", "url": "https://github.com/pravega/pravega/commit/f80c3afd332d0d31e730c5ef0fa58441be791f7d", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4903-improve-garbage-collection-2", "committedDate": "2020-12-11T19:09:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NDAzNQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541164035", "bodyText": "Logging this at the end of garbageCollector.initialize() would have the same effect without doing another computation stage.", "author": "RaulGracia", "createdAt": "2020-12-11T19:00:32Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorage.java", "diffHunk": "@@ -178,7 +174,9 @@ public ChunkedSegmentStorage(int containerId, ChunkStorage chunkStorage, ChunkMe\n \n         // Now bootstrap\n         log.debug(\"{} STORAGE BOOT: Started.\", logPrefix);\n-        return this.systemJournal.bootstrap(epoch).thenRunAsync(() -> log.debug(\"{} STORAGE BOOT: Ended.\", logPrefix), executor);\n+        return this.systemJournal.bootstrap(epoch)\n+                .thenRun(() -> garbageCollector.initialize())\n+                .thenRun(() -> log.debug(\"{} STORAGE BOOT: Ended.\", logPrefix));", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NTk3OQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541775979", "bodyText": "There could be other things added to initialization sequence or reshuffled.  I know at least one more thing will come in soon  - background defragmentation of segments.\nThis way the log it is always last.", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NzQxMg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541167412", "bodyText": "Do we need this?", "author": "RaulGracia", "createdAt": "2020-12-11T19:03:42Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorage.java", "diffHunk": "@@ -254,6 +252,8 @@ public void initialize(long containerEpoch) {\n                                 .thenComposeAsync(chunkInfo -> {\n                                     Preconditions.checkState(chunkInfo != null, \"chunkInfo for last chunk must not be null.\");\n                                     Preconditions.checkState(lastChunk != null, \"last chunk metadata must not be null.\");\n+                                    // Mark chunk as \"not garbage\" if present.\n+                                    //garbageCollector.removeFromGarbage(lastChunkName);", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NzQ3MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541777470", "bodyText": "fixed", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NzQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE3MzkyOQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541173929", "bodyText": "Nit: Maybe parallelism instead of concurrency?", "author": "RaulGracia", "createdAt": "2020-12-11T19:08:56Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageConfig.java", "diffHunk": "@@ -36,6 +38,11 @@\n     public static final Property<Boolean> INLINE_DEFRAG_ENABLED = Property.named(\"defrag.inline.enable\", true);\n     public static final Property<Long> DEFAULT_ROLLOVER_SIZE = Property.named(\"metadata.rollover.size.bytes.max\", SegmentRollingPolicy.MAX_CHUNK_LENGTH);\n     public static final Property<Integer> SELF_CHECK_LATE_WARNING_THRESHOLD = Property.named(\"self.check.late\", 100);\n+    public static final Property<Integer> GARBAGE_COLLECTION_DELAY = Property.named(\"garbage.collection.delay.seconds\", 60);\n+    public static final Property<Integer> GARBAGE_COLLECTION_CONCURRENCY = Property.named(\"garbage.collection.concurrency\", 10);", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NjM3Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541776377", "bodyText": "We need a name that captures throttling aspect.\nrenamed it to garbage.collection.concurrency.max", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE3MzkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU0ODU1Ng==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541548556", "bodyText": "Rather than just advising, maybe you could a test to verify that this is not larger than half of the storage pool size or something along these lines. Then, you can decide whether to throw in this case (so, do not allow large thread pools for garbage collection) or log it as a warning.", "author": "RaulGracia", "createdAt": "2020-12-12T10:21:31Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/ChunkedSegmentStorageConfig.java", "diffHunk": "@@ -124,6 +135,32 @@\n     @Getter\n     final private int lateWarningThresholdInMillis;\n \n+    /**\n+     * Minimum delay in seconds between when garbage chunks are marked for deletion and actually deleted.\n+     */\n+    @Getter\n+    final private Duration garbageCollectionDelay;\n+\n+    /**\n+     * Number of chunks deleted concurrently.\n+     * This number should be small enough so that it does interfere foreground requests.", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Nzc5Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541777797", "bodyText": "Storage GC is new . I don't know what is a good number here. We'll have to measure and get a sense for it.", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU0ODU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2OTk3NQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r543469975", "bodyText": "Is not a matter of measuring: for instance, we know that this number cannot be larger than the number of threads in the storage pool, right? Or it cannot be 0 or negative, right? So, at least we could validate for these values. Optimizing is another topic, but this is about preventing to input plain wrong numbers here.", "author": "RaulGracia", "createdAt": "2020-12-15T15:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU0ODU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MDg1MQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541550851", "bodyText": "Please, create 2 Git issues to keep track of these problems in the future and add them to the comments.\nAlso, the \"scans all records\" part sounds scary in terms of efficiency, we need to think of a better approach to do that.", "author": "RaulGracia", "createdAt": "2020-12-12T10:37:09Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * 1. Various SLTS operations requesting deletes\n+ * 2. Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).\n+ * 3. Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented).", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTA0Ng==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541551046", "bodyText": "We discussed that this is a bug, as you are not incrementing the size of the queue inside the loop, right?", "author": "RaulGracia", "createdAt": "2020-12-12T10:38:38Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * 1. Various SLTS operations requesting deletes\n+ * 2. Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).\n+ * 3. Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented).\n+ *\n+ * The background task throttles itself in two ways.\n+ * 1. It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground SLTS tasks.\n+ * 2. It limits the number of items in the queue.\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     * This queue needs to be lock free, hence ConcurrentLinkedQueue.\n+     */\n+    @Getter\n+    private final ConcurrentLinkedQueue<GarbageChunkInfo> garbageChunks = new ConcurrentLinkedQueue<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on ConcurrentLinkedQueue.\n+     */\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        super(\"io.pravega.segmentstore.storage.chunklayer.GarbageCollector\", (ScheduledExecutorService) chunkedSegmentStorage.getExecutor());\n+        this.chunkedSegmentStorage = Preconditions.checkNotNull(chunkedSegmentStorage, \"chunkedSegmentStorage\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;\n+    }\n+\n+    /**\n+     * Main execution of the Service. When this Future completes, the service auto-shuts down.\n+     *\n+     * @return A CompletableFuture that, when completed, indicates the service is terminated. If the Future completed\n+     * exceptionally, the Service will shut down with failure, otherwise it will terminate normally.\n+     */\n+    @Override\n+    protected CompletableFuture<Void> doRun() {\n+        loopFuture = Futures.loop(\n+                this::canRun,\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync( v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()), executor)\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }, executor),\n+                executor);\n+        return loopFuture;\n+    }\n+\n+    private boolean canRun() {\n+        return isRunning() && getStopException() == null && !closed.get();\n+    }\n+\n+    /**\n+     * Sets whether background cleanup is suspended or not.\n+     *\n+     * @param value Boolean indicating whether to suspend background processing or not.\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    void addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+\n+        if (queueSize.get() < config.getGarbageCollectionMaxQueueSize()) {\n+            chunksToDelete.forEach(chunkToDelete -> garbageChunks.add(new GarbageChunkInfo(chunkToDelete, currentTime)));\n+            queueSize.incrementAndGet();", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MjU3Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541552577", "bodyText": "Please, add a test for the enforcement of queue size limits of Garbage Collector, as the fact that no test is failing due to this makes me feel that it needs better coverage.", "author": "RaulGracia", "createdAt": "2020-12-12T10:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NjY5OA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541776698", "bodyText": "yes it was a silly mistake and tests didn't catch it :(\nAdded new tests.", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTI1Mg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541551252", "bodyText": "This is dangerous and can flood all the Segment Store logs, leading to lose logs due to their sheer size and/or making debug much harder. Please, add a single log line with the length of chunksToDelete if you want.", "author": "RaulGracia", "createdAt": "2020-12-12T10:40:02Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * 1. Various SLTS operations requesting deletes\n+ * 2. Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).\n+ * 3. Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented).\n+ *\n+ * The background task throttles itself in two ways.\n+ * 1. It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground SLTS tasks.\n+ * 2. It limits the number of items in the queue.\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     * This queue needs to be lock free, hence ConcurrentLinkedQueue.\n+     */\n+    @Getter\n+    private final ConcurrentLinkedQueue<GarbageChunkInfo> garbageChunks = new ConcurrentLinkedQueue<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on ConcurrentLinkedQueue.\n+     */\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        super(\"io.pravega.segmentstore.storage.chunklayer.GarbageCollector\", (ScheduledExecutorService) chunkedSegmentStorage.getExecutor());\n+        this.chunkedSegmentStorage = Preconditions.checkNotNull(chunkedSegmentStorage, \"chunkedSegmentStorage\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;\n+    }\n+\n+    /**\n+     * Main execution of the Service. When this Future completes, the service auto-shuts down.\n+     *\n+     * @return A CompletableFuture that, when completed, indicates the service is terminated. If the Future completed\n+     * exceptionally, the Service will shut down with failure, otherwise it will terminate normally.\n+     */\n+    @Override\n+    protected CompletableFuture<Void> doRun() {\n+        loopFuture = Futures.loop(\n+                this::canRun,\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync( v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()), executor)\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }, executor),\n+                executor);\n+        return loopFuture;\n+    }\n+\n+    private boolean canRun() {\n+        return isRunning() && getStopException() == null && !closed.get();\n+    }\n+\n+    /**\n+     * Sets whether background cleanup is suspended or not.\n+     *\n+     * @param value Boolean indicating whether to suspend background processing or not.\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    void addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+\n+        if (queueSize.get() < config.getGarbageCollectionMaxQueueSize()) {\n+            chunksToDelete.forEach(chunkToDelete -> garbageChunks.add(new GarbageChunkInfo(chunkToDelete, currentTime)));\n+            queueSize.incrementAndGet();\n+        } else {\n+            for (val chunkToDelete : chunksToDelete) {\n+                log.warn(\"{} deleteGarbage - Queue full. Could not delete garbage. chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODcwMA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541778700", "bodyText": "ok . made it a debug.", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTg1Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541551857", "bodyText": "We discussed that this could lead to another problem: if the chunk is deleted and then something fails, the metadata will continue reflecting that the chunk is there and needs deletion. The same chunk will be picked, which has been deleted from storage, and the deletion will fail, skipping again the deletion in metadata. So this could lead to an infinite loop. Please, either modify this logic to handle the metadata deletion first (so in the worst case if there is a failure after that we would leave one orphan chunk to delete), or handle the case in which the chunk deletion succeeds bu there is an exception just after that, so we can eventually delete it from metadata too and avoid the infinite retries on that chunk.", "author": "RaulGracia", "createdAt": "2020-12-12T10:44:05Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * 1. Various SLTS operations requesting deletes\n+ * 2. Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).\n+ * 3. Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented).\n+ *\n+ * The background task throttles itself in two ways.\n+ * 1. It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground SLTS tasks.\n+ * 2. It limits the number of items in the queue.\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     * This queue needs to be lock free, hence ConcurrentLinkedQueue.\n+     */\n+    @Getter\n+    private final ConcurrentLinkedQueue<GarbageChunkInfo> garbageChunks = new ConcurrentLinkedQueue<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on ConcurrentLinkedQueue.\n+     */\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        super(\"io.pravega.segmentstore.storage.chunklayer.GarbageCollector\", (ScheduledExecutorService) chunkedSegmentStorage.getExecutor());\n+        this.chunkedSegmentStorage = Preconditions.checkNotNull(chunkedSegmentStorage, \"chunkedSegmentStorage\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;\n+    }\n+\n+    /**\n+     * Main execution of the Service. When this Future completes, the service auto-shuts down.\n+     *\n+     * @return A CompletableFuture that, when completed, indicates the service is terminated. If the Future completed\n+     * exceptionally, the Service will shut down with failure, otherwise it will terminate normally.\n+     */\n+    @Override\n+    protected CompletableFuture<Void> doRun() {\n+        loopFuture = Futures.loop(\n+                this::canRun,\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync( v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()), executor)\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }, executor),\n+                executor);\n+        return loopFuture;\n+    }\n+\n+    private boolean canRun() {\n+        return isRunning() && getStopException() == null && !closed.get();\n+    }\n+\n+    /**\n+     * Sets whether background cleanup is suspended or not.\n+     *\n+     * @param value Boolean indicating whether to suspend background processing or not.\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    void addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+\n+        if (queueSize.get() < config.getGarbageCollectionMaxQueueSize()) {\n+            chunksToDelete.forEach(chunkToDelete -> garbageChunks.add(new GarbageChunkInfo(chunkToDelete, currentTime)));\n+            queueSize.incrementAndGet();\n+        } else {\n+            for (val chunkToDelete : chunksToDelete) {\n+                log.warn(\"{} deleteGarbage - Queue full. Could not delete garbage. chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * This method retrieves a few eligible chunks for deletion at a time.\n+     * The chunk is deleted only if the metadata for it does not exist or is marked inactive.\n+     * If there are any errors then failed chunk is enqueued back.\n+     * If suspended or there are no items then it \"sleeps\" for time specified by configuration.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        // Sleep if suspended.\n+        if (suspended.get() && isBackground) {\n+            log.info(\"{} deleteGarbage - suspended - sleeping for {}.\", chunkedSegmentStorage.getLogPrefix(), config.getGarbageCollectionDelay());\n+            return Futures.delayedFuture(config.getGarbageCollectionSleep(), executor);\n+        }\n+\n+        // Find chunks to delete.\n+        val currentTime = System.currentTimeMillis();\n+        val chunksToDelete = new ArrayList<GarbageChunkInfo>();\n+        int count = 0;\n+        val iterator = garbageChunks.iterator();\n+        while (iterator.hasNext()) {\n+            GarbageChunkInfo info = iterator.next();\n+            if (info == null || count >= maxItems) {\n+                break;\n+            }\n+            if (canDelete(info.getDeletedTime(), currentTime)) {\n+                queueSize.decrementAndGet();\n+                chunksToDelete.add(info);\n+                iterator.remove();\n+                count++;\n+            }\n+        }\n+\n+        // Sleep if no chunks to delete.\n+        if (count == 0) {\n+            log.debug(\"{} deleteGarbage - no work - sleeping for {}.\", chunkedSegmentStorage.getLogPrefix(), config.getGarbageCollectionDelay());\n+            return Futures.delayedFuture(config.getGarbageCollectionSleep(), executor);\n+        }\n+\n+        // For each chunk delete if the chunk is not present at all in the metadata or is present but marked as inactive.\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (val infoToDelete : chunksToDelete) {\n+            val chunkToDelete = infoToDelete.name;\n+            val txn = chunkedSegmentStorage.getMetadataStore().beginTransaction(false, chunkToDelete);\n+            val future =\n+                    txn.get(infoToDelete.name)\n+                    .thenComposeAsync( metadata -> {\n+                            val chunkMetadata = (ChunkMetadata) metadata;\n+                            // Delete if the chunk is not present at all in the metadata or is present but marked as inactive.\n+                            boolean shouldDelete = (null == chunkMetadata) ? true : !chunkMetadata.isActive();\n+                            // Check whether the chunk is marked as inactive\n+                            if (shouldDelete) {\n+                                return chunkedSegmentStorage.getChunkStorage().openWrite(chunkToDelete)\n+                                        .thenComposeAsync(chunkedSegmentStorage.getChunkStorage()::delete, executor)", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MjQ2Ng==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541552466", "bodyText": "Also, the fact that we haven't found this problem in the test cases of this PR makes me feel that more effort is necessary on testing the potential scenarios that could happen to the garbage collector (fail in chunk deletion but not in metadata, the other way raound, etc.).", "author": "RaulGracia", "createdAt": "2020-12-12T10:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODI2NQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541778265", "bodyText": "added tests", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MjI4NA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541552284", "bodyText": "If we have, let's say, an IOError on that chunk that is persistent, does it mean that we will try to garbage collect it forever?", "author": "RaulGracia", "createdAt": "2020-12-12T10:46:56Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * 1. Various SLTS operations requesting deletes\n+ * 2. Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).\n+ * 3. Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented).\n+ *\n+ * The background task throttles itself in two ways.\n+ * 1. It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground SLTS tasks.\n+ * 2. It limits the number of items in the queue.\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     * This queue needs to be lock free, hence ConcurrentLinkedQueue.\n+     */\n+    @Getter\n+    private final ConcurrentLinkedQueue<GarbageChunkInfo> garbageChunks = new ConcurrentLinkedQueue<>();\n+\n+    private final ChunkedSegmentStorage chunkedSegmentStorage;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on ConcurrentLinkedQueue.\n+     */\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param chunkedSegmentStorage Instance of {@link ChunkedSegmentStorage}.\n+     * @param config Configuration to use.\n+     */\n+    public GarbageCollector(ChunkedSegmentStorage chunkedSegmentStorage, ChunkedSegmentStorageConfig config) {\n+        super(\"io.pravega.segmentstore.storage.chunklayer.GarbageCollector\", (ScheduledExecutorService) chunkedSegmentStorage.getExecutor());\n+        this.chunkedSegmentStorage = Preconditions.checkNotNull(chunkedSegmentStorage, \"chunkedSegmentStorage\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;\n+    }\n+\n+    /**\n+     * Main execution of the Service. When this Future completes, the service auto-shuts down.\n+     *\n+     * @return A CompletableFuture that, when completed, indicates the service is terminated. If the Future completed\n+     * exceptionally, the Service will shut down with failure, otherwise it will terminate normally.\n+     */\n+    @Override\n+    protected CompletableFuture<Void> doRun() {\n+        loopFuture = Futures.loop(\n+                this::canRun,\n+                () -> CompletableFuture.completedFuture(null)\n+                        .thenComposeAsync( v -> deleteGarbage(true, config.getGarbageCollectionConcurrency()), executor)\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{} Error during run.\", chunkedSegmentStorage.getLogPrefix(), ex);\n+                            }\n+                            return null;\n+                        }, executor),\n+                executor);\n+        return loopFuture;\n+    }\n+\n+    private boolean canRun() {\n+        return isRunning() && getStopException() == null && !closed.get();\n+    }\n+\n+    /**\n+     * Sets whether background cleanup is suspended or not.\n+     *\n+     * @param value Boolean indicating whether to suspend background processing or not.\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * collect the garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    void addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = System.currentTimeMillis();\n+\n+        if (queueSize.get() < config.getGarbageCollectionMaxQueueSize()) {\n+            chunksToDelete.forEach(chunkToDelete -> garbageChunks.add(new GarbageChunkInfo(chunkToDelete, currentTime)));\n+            queueSize.incrementAndGet();\n+        } else {\n+            for (val chunkToDelete : chunksToDelete) {\n+                log.warn(\"{} deleteGarbage - Queue full. Could not delete garbage. chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * This method retrieves a few eligible chunks for deletion at a time.\n+     * The chunk is deleted only if the metadata for it does not exist or is marked inactive.\n+     * If there are any errors then failed chunk is enqueued back.\n+     * If suspended or there are no items then it \"sleeps\" for time specified by configuration.\n+     *\n+     * @param isBackground True if the caller is backgound task else False if called explicitly.\n+     * @param maxItems Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Void> deleteGarbage(boolean isBackground, int maxItems) {\n+        // Sleep if suspended.\n+        if (suspended.get() && isBackground) {\n+            log.info(\"{} deleteGarbage - suspended - sleeping for {}.\", chunkedSegmentStorage.getLogPrefix(), config.getGarbageCollectionDelay());\n+            return Futures.delayedFuture(config.getGarbageCollectionSleep(), executor);\n+        }\n+\n+        // Find chunks to delete.\n+        val currentTime = System.currentTimeMillis();\n+        val chunksToDelete = new ArrayList<GarbageChunkInfo>();\n+        int count = 0;\n+        val iterator = garbageChunks.iterator();\n+        while (iterator.hasNext()) {\n+            GarbageChunkInfo info = iterator.next();\n+            if (info == null || count >= maxItems) {\n+                break;\n+            }\n+            if (canDelete(info.getDeletedTime(), currentTime)) {\n+                queueSize.decrementAndGet();\n+                chunksToDelete.add(info);\n+                iterator.remove();\n+                count++;\n+            }\n+        }\n+\n+        // Sleep if no chunks to delete.\n+        if (count == 0) {\n+            log.debug(\"{} deleteGarbage - no work - sleeping for {}.\", chunkedSegmentStorage.getLogPrefix(), config.getGarbageCollectionDelay());\n+            return Futures.delayedFuture(config.getGarbageCollectionSleep(), executor);\n+        }\n+\n+        // For each chunk delete if the chunk is not present at all in the metadata or is present but marked as inactive.\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (val infoToDelete : chunksToDelete) {\n+            val chunkToDelete = infoToDelete.name;\n+            val txn = chunkedSegmentStorage.getMetadataStore().beginTransaction(false, chunkToDelete);\n+            val future =\n+                    txn.get(infoToDelete.name)\n+                    .thenComposeAsync( metadata -> {\n+                            val chunkMetadata = (ChunkMetadata) metadata;\n+                            // Delete if the chunk is not present at all in the metadata or is present but marked as inactive.\n+                            boolean shouldDelete = (null == chunkMetadata) ? true : !chunkMetadata.isActive();\n+                            // Check whether the chunk is marked as inactive\n+                            if (shouldDelete) {\n+                                return chunkedSegmentStorage.getChunkStorage().openWrite(chunkToDelete)\n+                                        .thenComposeAsync(chunkedSegmentStorage.getChunkStorage()::delete, executor)\n+                                        .thenRunAsync(() -> {\n+                                            if (null != metadata) {\n+                                                txn.delete(chunkToDelete);\n+                                            }\n+                                            log.debug(\"{} deleteGarbage - deleted chunk={}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                        }, executor)\n+                                        .thenComposeAsync(v -> txn.commit(), executor)\n+                                        .handleAsync((v, e) -> {\n+                                            if (e != null) {\n+                                                val ex = Exceptions.unwrap(e);\n+                                                if (ex instanceof ChunkNotFoundException) {\n+                                                    // Ignore - nothing to do here.\n+                                                    log.debug(\"{} deleteGarbage - Could not delete garbage chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                                } else {\n+                                                    log.warn(\"{} deleteGarbage - Could not delete garbage chunk {}.\", chunkedSegmentStorage.getLogPrefix(), chunkToDelete);\n+                                                    // Queue it back.\n+                                                    addToGarbage(Collections.singleton(chunkToDelete));", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODMyNA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541778324", "bodyText": "yes.", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MjI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODUyNA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541778524", "bodyText": "If attempt to delete failed then we should retry. Added limit.", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1MjI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1Mjk5Nw==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541552997", "bodyText": "The name and description of this class is too generic. Please, refactor its name to its actual scope, like StorageConstants or ChunkedStorageConstants or something of the sort. Note that if we lookup for \"Constants\" in the IDE, it will take us more effort to understand what this class is used for, as the name itself is not helping.", "author": "RaulGracia", "createdAt": "2020-12-12T10:51:50Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/metadata/Constants.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.metadata;\n+\n+/**\n+ * Class that defines various constants.\n+ */\n+final class Constants {", "originalCommit": "85088f1862ecd36a10c967d992ac88a11f99c7c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3ODM5NQ==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r541778395", "bodyText": "done.", "author": "sachin-j-joshi", "createdAt": "2020-12-12T20:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU1Mjk5Nw=="}], "type": "inlineReview"}, {"oid": "b150f5b49781b32e386669a062cde66cf0b749fc", "url": "https://github.com/pravega/pravega/commit/b150f5b49781b32e386669a062cde66cf0b749fc", "message": "Issue 4903: (SLTS) Use DelayQueue.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-12T20:29:42Z", "type": "commit"}, {"oid": "37ff7cb3d4f55fc0628b58bd83b66880c7faadb6", "url": "https://github.com/pravega/pravega/commit/37ff7cb3d4f55fc0628b58bd83b66880c7faadb6", "message": "Issue 4903: (SLTS) Code cleanup.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-12T20:44:49Z", "type": "commit"}, {"oid": "36673b04af930de0ee9dbea91105e40c1f641b4e", "url": "https://github.com/pravega/pravega/commit/36673b04af930de0ee9dbea91105e40c1f641b4e", "message": "Issue 4903: (SLTS) Code cleanup.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-13T23:50:54Z", "type": "commit"}, {"oid": "656bd07e83949db8e186818d945a395ee601b72d", "url": "https://github.com/pravega/pravega/commit/656bd07e83949db8e186818d945a395ee601b72d", "message": "Issue 4903: (SLTS) Limit number of attempts to delete.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-14T20:53:12Z", "type": "commit"}, {"oid": "0ebaa9a05e6180979ad28dbec2cd5529e07a66bb", "url": "https://github.com/pravega/pravega/commit/0ebaa9a05e6180979ad28dbec2cd5529e07a66bb", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4903-improve-garbage-collection-2", "committedDate": "2020-12-14T22:25:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3NDIwOA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r542574208", "bodyText": "This seems a expensive operation (submit a new task to the pool) just for a log line, don't you think? Perhaps we can put this log in deleteGarbage and keep the pool queue shorter.", "author": "RaulGracia", "createdAt": "2020-12-14T17:36:13Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadataStore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * <ol>\n+ * <li>Various ChunkedSegmentStorage operations requesting deletes.</li>\n+ * <li>Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).</li>\n+ * <li>Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented)</li>\n+ * </ol>\n+ *\n+ * The background task throttles itself in two ways.\n+ * <ol>\n+ * <li>It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground Storage calls. </li>\n+ * <li>It limits the number of items in the queue.</li>\n+ * </ol>\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final DelayQueue<GarbageChunkInfo> garbageChunks = new DelayQueue<>();\n+\n+    private final ChunkStorage chunkStorage;\n+\n+    private final ChunkMetadataStore metadataStore;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on DelayQueue.\n+     */\n+    @Getter\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    @Getter\n+    private final AtomicLong iterationId = new AtomicLong();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    private final Supplier<Long> currentTimeSupplier;\n+\n+    private final Supplier<CompletableFuture<Void>> delaySupplier;\n+\n+    private final ScheduledExecutorService storageExecutor;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param executorService     ScheduledExecutorService to use.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService executorService\n+                            ) {\n+        this(containerId, chunkStorage, metadataStore, config, executorService,\n+                System::currentTimeMillis,\n+                () -> Futures.delayedFuture(config.getGarbageCollectionSleep(), executorService));\n+    }\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param storageExecutor     ScheduledExecutorService to use for storage operations.\n+     * @param currentTimeSupplier Function that supplies current time.\n+     * @param delaySupplier       Function that supplies delay future.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService storageExecutor,\n+                            Supplier<Long> currentTimeSupplier,\n+                            Supplier<CompletableFuture<Void>> delaySupplier) {\n+        super(String.format(\"GarbageCollector[%d]\", containerId), ExecutorServiceHelpers.newScheduledThreadPool(1, \"storage-gc\"));\n+        this.chunkStorage = Preconditions.checkNotNull(chunkStorage, \"chunkStorage\");\n+        this.metadataStore = Preconditions.checkNotNull(metadataStore, \"metadataStore\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+        this.currentTimeSupplier = Preconditions.checkNotNull(currentTimeSupplier, \"currentTimeSupplier\");\n+        this.delaySupplier = Preconditions.checkNotNull(delaySupplier, \"delaySupplier\");\n+        this.storageExecutor = Preconditions.checkNotNull(storageExecutor, \"storageExecutor\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;\n+    }\n+\n+    /**\n+     * Main execution of the Service. When this Future completes, the service auto-shuts down.\n+     *\n+     * @return A CompletableFuture that, when completed, indicates the service is terminated. If the Future completed\n+     * exceptionally, the Service will shut down with failure, otherwise it will terminate normally.\n+     */\n+    @Override\n+    protected CompletableFuture<Void> doRun() {\n+        loopFuture = Futures.loop(\n+                this::canRun,\n+                () -> delaySupplier.get()\n+                        .thenRunAsync(() -> {\n+                            log.info(\"{}: Iteration {} started.\", traceObjectId, iterationId.get());", "originalCommit": "36673b04af930de0ee9dbea91105e40c1f641b4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4MDc1Mg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r543480752", "bodyText": "Nit: Please, move this parenthesis to the end of previous line.", "author": "RaulGracia", "createdAt": "2020-12-15T16:11:53Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadataStore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * <ol>\n+ * <li>Various ChunkedSegmentStorage operations requesting deletes.</li>\n+ * <li>Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).</li>\n+ * <li>Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented)</li>\n+ * </ol>\n+ *\n+ * The background task throttles itself in two ways.\n+ * <ol>\n+ * <li>It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground Storage calls. </li>\n+ * <li>It limits the number of items in the queue.</li>\n+ * </ol>\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final DelayQueue<GarbageChunkInfo> garbageChunks = new DelayQueue<>();\n+\n+    private final ChunkStorage chunkStorage;\n+\n+    private final ChunkMetadataStore metadataStore;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on DelayQueue.\n+     */\n+    @Getter\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    @Getter\n+    private final AtomicLong iterationId = new AtomicLong();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    private final Supplier<Long> currentTimeSupplier;\n+\n+    private final Supplier<CompletableFuture<Void>> delaySupplier;\n+\n+    private final ScheduledExecutorService storageExecutor;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param executorService     ScheduledExecutorService to use.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService executorService\n+                            ) {", "originalCommit": "0ebaa9a05e6180979ad28dbec2cd5529e07a66bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5MzM0Ng==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r543493346", "bodyText": "Is this the expected value to return?", "author": "RaulGracia", "createdAt": "2020-12-15T16:27:25Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadataStore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * <ol>\n+ * <li>Various ChunkedSegmentStorage operations requesting deletes.</li>\n+ * <li>Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).</li>\n+ * <li>Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented)</li>\n+ * </ol>\n+ *\n+ * The background task throttles itself in two ways.\n+ * <ol>\n+ * <li>It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground Storage calls. </li>\n+ * <li>It limits the number of items in the queue.</li>\n+ * </ol>\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final DelayQueue<GarbageChunkInfo> garbageChunks = new DelayQueue<>();\n+\n+    private final ChunkStorage chunkStorage;\n+\n+    private final ChunkMetadataStore metadataStore;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on DelayQueue.\n+     */\n+    @Getter\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    @Getter\n+    private final AtomicLong iterationId = new AtomicLong();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    private final Supplier<Long> currentTimeSupplier;\n+\n+    private final Supplier<CompletableFuture<Void>> delaySupplier;\n+\n+    private final ScheduledExecutorService storageExecutor;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param executorService     ScheduledExecutorService to use.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService executorService\n+                            ) {\n+        this(containerId, chunkStorage, metadataStore, config, executorService,\n+                System::currentTimeMillis,\n+                () -> Futures.delayedFuture(config.getGarbageCollectionSleep(), executorService));\n+    }\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param storageExecutor     ScheduledExecutorService to use for storage operations.\n+     * @param currentTimeSupplier Function that supplies current time.\n+     * @param delaySupplier       Function that supplies delay future.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService storageExecutor,\n+                            Supplier<Long> currentTimeSupplier,\n+                            Supplier<CompletableFuture<Void>> delaySupplier) {\n+        super(String.format(\"GarbageCollector[%d]\", containerId), ExecutorServiceHelpers.newScheduledThreadPool(1, \"storage-gc\"));\n+        this.chunkStorage = Preconditions.checkNotNull(chunkStorage, \"chunkStorage\");\n+        this.metadataStore = Preconditions.checkNotNull(metadataStore, \"metadataStore\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+        this.currentTimeSupplier = Preconditions.checkNotNull(currentTimeSupplier, \"currentTimeSupplier\");\n+        this.delaySupplier = Preconditions.checkNotNull(delaySupplier, \"delaySupplier\");\n+        this.storageExecutor = Preconditions.checkNotNull(storageExecutor, \"storageExecutor\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;", "originalCommit": "0ebaa9a05e6180979ad28dbec2cd5529e07a66bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5NjE1MA==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r543496150", "bodyText": "If there are any errors then failed chunk is enqueued back.\n\nTo describe the actual behavior, we would need to add up to a max number of attempts, right?", "author": "RaulGracia", "createdAt": "2020-12-15T16:30:53Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadataStore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * <ol>\n+ * <li>Various ChunkedSegmentStorage operations requesting deletes.</li>\n+ * <li>Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).</li>\n+ * <li>Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented)</li>\n+ * </ol>\n+ *\n+ * The background task throttles itself in two ways.\n+ * <ol>\n+ * <li>It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground Storage calls. </li>\n+ * <li>It limits the number of items in the queue.</li>\n+ * </ol>\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final DelayQueue<GarbageChunkInfo> garbageChunks = new DelayQueue<>();\n+\n+    private final ChunkStorage chunkStorage;\n+\n+    private final ChunkMetadataStore metadataStore;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on DelayQueue.\n+     */\n+    @Getter\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    @Getter\n+    private final AtomicLong iterationId = new AtomicLong();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    private final Supplier<Long> currentTimeSupplier;\n+\n+    private final Supplier<CompletableFuture<Void>> delaySupplier;\n+\n+    private final ScheduledExecutorService storageExecutor;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param executorService     ScheduledExecutorService to use.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService executorService\n+                            ) {\n+        this(containerId, chunkStorage, metadataStore, config, executorService,\n+                System::currentTimeMillis,\n+                () -> Futures.delayedFuture(config.getGarbageCollectionSleep(), executorService));\n+    }\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param storageExecutor     ScheduledExecutorService to use for storage operations.\n+     * @param currentTimeSupplier Function that supplies current time.\n+     * @param delaySupplier       Function that supplies delay future.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService storageExecutor,\n+                            Supplier<Long> currentTimeSupplier,\n+                            Supplier<CompletableFuture<Void>> delaySupplier) {\n+        super(String.format(\"GarbageCollector[%d]\", containerId), ExecutorServiceHelpers.newScheduledThreadPool(1, \"storage-gc\"));\n+        this.chunkStorage = Preconditions.checkNotNull(chunkStorage, \"chunkStorage\");\n+        this.metadataStore = Preconditions.checkNotNull(metadataStore, \"metadataStore\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+        this.currentTimeSupplier = Preconditions.checkNotNull(currentTimeSupplier, \"currentTimeSupplier\");\n+        this.delaySupplier = Preconditions.checkNotNull(delaySupplier, \"delaySupplier\");\n+        this.storageExecutor = Preconditions.checkNotNull(storageExecutor, \"storageExecutor\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;\n+    }\n+\n+    /**\n+     * Main execution of the Service. When this Future completes, the service auto-shuts down.\n+     *\n+     * @return A CompletableFuture that, when completed, indicates the service is terminated. If the Future completed\n+     * exceptionally, the Service will shut down with failure, otherwise it will terminate normally.\n+     */\n+    @Override\n+    protected CompletableFuture<Void> doRun() {\n+        loopFuture = Futures.loop(\n+                this::canRun,\n+                () -> delaySupplier.get()\n+                        .thenRunAsync(() -> {\n+                            log.info(\"{}: Iteration {} started.\", traceObjectId, iterationId.get());\n+                        }, executor)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionMaxConcurrency()), executor)\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{}: Error during doRun.\", traceObjectId, ex);\n+                            }\n+                            log.info(\"{}: Iteration {} ended.\", traceObjectId, iterationId.getAndIncrement());\n+                            return null;\n+                        }, executor),\n+                executor);\n+        return loopFuture;\n+    }\n+\n+    private boolean canRun() {\n+        return isRunning() && getStopException() == null && !closed.get();\n+    }\n+\n+    /**\n+     * Sets whether background cleanup is suspended or not.\n+     *\n+     * @param value Boolean indicating whether to suspend background processing or not.\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * Adds given chunks to list of garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    void addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = currentTimeSupplier.get();\n+\n+        chunksToDelete.forEach(chunkToDelete -> addToGarbage(chunkToDelete, currentTime + config.getGarbageCollectionDelay().toMillis(), 0));\n+\n+        if (queueSize.get() >= config.getGarbageCollectionMaxQueueSize()) {\n+            log.warn(\"{}: deleteGarbage - Queue full. Could not delete garbage. Chunks skipped\", traceObjectId);\n+        }\n+    }\n+\n+    /**\n+     * Adds given chunk to list of garbage chunks.\n+     *\n+     * @param chunkToDelete Name of the chunk to delete.\n+     * @param startTime Start time.\n+     * @param attempts Number of attempts to delete this chunk so far.\n+     */\n+    void addToGarbage(String chunkToDelete, long startTime, int attempts) {\n+        if (queueSize.get() < config.getGarbageCollectionMaxQueueSize()) {\n+            garbageChunks.add(new GarbageChunkInfo(chunkToDelete, startTime, attempts));\n+            queueSize.incrementAndGet();\n+        } else {\n+            log.debug(\"{}: deleteGarbage - Queue full. Could not delete garbage. chunk {}.\", traceObjectId, chunkToDelete);\n+        }\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * This method retrieves a few eligible chunks for deletion at a time.\n+     * The chunk is deleted only if the metadata for it does not exist or is marked inactive.\n+     * If there are any errors then failed chunk is enqueued back.", "originalCommit": "0ebaa9a05e6180979ad28dbec2cd5529e07a66bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMzM3Mg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r543503372", "bodyText": "Maybe is a personal impression, but in general I feel that the code is heavily influenced by logging. There are many if/else branches, computation stages/futures, etc. that exist just to add debug logs. I don't know if this is related to the need of explicitly stating what the program is doing at any time, as there are scenarios that we are unsure of its behavior. If this is the case, maybe we could remove logging by adding more tests and splitting large code blocks into smaller functions that can be heavily tested. Maybe this would give us more certainty and this, in turn, would help us to remove some of the log lines in the PR. But, even in the case that we decide to do not do that now, I wonder if so much logging would be counterproductive, as logs will grow significantly, making them harder to manage.", "author": "RaulGracia", "createdAt": "2020-12-15T16:39:53Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/chunklayer/GarbageCollector.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.storage.chunklayer;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.AbstractThreadPoolService;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.concurrent.Services;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadata;\n+import io.pravega.segmentstore.storage.metadata.ChunkMetadataStore;\n+import lombok.Data;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.DelayQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Implements simple garbage collector for cleaning up the deleted chunks.\n+ * The garbage collector maintains a in memory queue of chunks to delete which is drained by a background task.\n+ * This queue is populated by following\n+ * <ol>\n+ * <li>Various ChunkedSegmentStorage operations requesting deletes.</li>\n+ * <li>Background task that scans all records to find undeleted chunks inside metadata (not yet implemented).</li>\n+ * <li>Background task that scans all LTS to find unaccounted chunks that are deemed garbage (not yet implemented)</li>\n+ * </ol>\n+ *\n+ * The background task throttles itself in two ways.\n+ * <ol>\n+ * <li>It limits number of concurrent deletes at a time, so that it doesn't interfere with foreground Storage calls. </li>\n+ * <li>It limits the number of items in the queue.</li>\n+ * </ol>\n+ */\n+@Slf4j\n+public class GarbageCollector extends AbstractThreadPoolService implements AutoCloseable {\n+    /**\n+     * Set of garbage chunks.\n+     */\n+    @Getter\n+    private final DelayQueue<GarbageChunkInfo> garbageChunks = new DelayQueue<>();\n+\n+    private final ChunkStorage chunkStorage;\n+\n+    private final ChunkMetadataStore metadataStore;\n+\n+    private final ChunkedSegmentStorageConfig config;\n+\n+    private final AtomicBoolean closed = new AtomicBoolean();\n+\n+    private final AtomicBoolean suspended = new AtomicBoolean();\n+\n+    /**\n+     * Keeps track of queue size.\n+     * Size is an expensive operation on DelayQueue.\n+     */\n+    @Getter\n+    private final AtomicInteger queueSize = new AtomicInteger();\n+\n+    @Getter\n+    private final AtomicLong iterationId = new AtomicLong();\n+\n+    private CompletableFuture<Void> loopFuture;\n+\n+    private final Supplier<Long> currentTimeSupplier;\n+\n+    private final Supplier<CompletableFuture<Void>> delaySupplier;\n+\n+    private final ScheduledExecutorService storageExecutor;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param executorService     ScheduledExecutorService to use.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService executorService\n+                            ) {\n+        this(containerId, chunkStorage, metadataStore, config, executorService,\n+                System::currentTimeMillis,\n+                () -> Futures.delayedFuture(config.getGarbageCollectionSleep(), executorService));\n+    }\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param containerId         Container id of the owner container.\n+     * @param chunkStorage        ChunkStorage instance to use for writing all logs.\n+     * @param metadataStore       ChunkMetadataStore for owner container.\n+     * @param config              Configuration options for this ChunkedSegmentStorage instance.\n+     * @param storageExecutor     ScheduledExecutorService to use for storage operations.\n+     * @param currentTimeSupplier Function that supplies current time.\n+     * @param delaySupplier       Function that supplies delay future.\n+     */\n+    public GarbageCollector(int containerId, ChunkStorage chunkStorage,\n+                            ChunkMetadataStore metadataStore,\n+                            ChunkedSegmentStorageConfig config,\n+                            ScheduledExecutorService storageExecutor,\n+                            Supplier<Long> currentTimeSupplier,\n+                            Supplier<CompletableFuture<Void>> delaySupplier) {\n+        super(String.format(\"GarbageCollector[%d]\", containerId), ExecutorServiceHelpers.newScheduledThreadPool(1, \"storage-gc\"));\n+        this.chunkStorage = Preconditions.checkNotNull(chunkStorage, \"chunkStorage\");\n+        this.metadataStore = Preconditions.checkNotNull(metadataStore, \"metadataStore\");\n+        this.config = Preconditions.checkNotNull(config, \"config\");\n+        this.currentTimeSupplier = Preconditions.checkNotNull(currentTimeSupplier, \"currentTimeSupplier\");\n+        this.delaySupplier = Preconditions.checkNotNull(delaySupplier, \"delaySupplier\");\n+        this.storageExecutor = Preconditions.checkNotNull(storageExecutor, \"storageExecutor\");\n+    }\n+\n+    /**\n+     * Initializes this instance.\n+     */\n+    public void initialize() {\n+        Services.startAsync(this, this.executor);\n+    }\n+\n+    /**\n+     * Gets a value indicating how much to wait for the service to shut down, before failing it.\n+     *\n+     * @return The Duration.\n+     */\n+    @Override\n+    protected Duration getShutdownTimeout() {\n+        return null;\n+    }\n+\n+    /**\n+     * Main execution of the Service. When this Future completes, the service auto-shuts down.\n+     *\n+     * @return A CompletableFuture that, when completed, indicates the service is terminated. If the Future completed\n+     * exceptionally, the Service will shut down with failure, otherwise it will terminate normally.\n+     */\n+    @Override\n+    protected CompletableFuture<Void> doRun() {\n+        loopFuture = Futures.loop(\n+                this::canRun,\n+                () -> delaySupplier.get()\n+                        .thenRunAsync(() -> {\n+                            log.info(\"{}: Iteration {} started.\", traceObjectId, iterationId.get());\n+                        }, executor)\n+                        .thenComposeAsync(v -> deleteGarbage(true, config.getGarbageCollectionMaxConcurrency()), executor)\n+                        .handleAsync((v, ex) -> {\n+                            if (null != ex) {\n+                                log.error(\"{}: Error during doRun.\", traceObjectId, ex);\n+                            }\n+                            log.info(\"{}: Iteration {} ended.\", traceObjectId, iterationId.getAndIncrement());\n+                            return null;\n+                        }, executor),\n+                executor);\n+        return loopFuture;\n+    }\n+\n+    private boolean canRun() {\n+        return isRunning() && getStopException() == null && !closed.get();\n+    }\n+\n+    /**\n+     * Sets whether background cleanup is suspended or not.\n+     *\n+     * @param value Boolean indicating whether to suspend background processing or not.\n+     */\n+    void setSuspended(boolean value) {\n+        suspended.set(value);\n+    }\n+\n+    /**\n+     * Adds given chunks to list of garbage chunks.\n+     *\n+     * @param chunksToDelete List of chunks to delete.\n+     */\n+    void addToGarbage(Collection<String> chunksToDelete) {\n+        val currentTime = currentTimeSupplier.get();\n+\n+        chunksToDelete.forEach(chunkToDelete -> addToGarbage(chunkToDelete, currentTime + config.getGarbageCollectionDelay().toMillis(), 0));\n+\n+        if (queueSize.get() >= config.getGarbageCollectionMaxQueueSize()) {\n+            log.warn(\"{}: deleteGarbage - Queue full. Could not delete garbage. Chunks skipped\", traceObjectId);\n+        }\n+    }\n+\n+    /**\n+     * Adds given chunk to list of garbage chunks.\n+     *\n+     * @param chunkToDelete Name of the chunk to delete.\n+     * @param startTime Start time.\n+     * @param attempts Number of attempts to delete this chunk so far.\n+     */\n+    void addToGarbage(String chunkToDelete, long startTime, int attempts) {\n+        if (queueSize.get() < config.getGarbageCollectionMaxQueueSize()) {\n+            garbageChunks.add(new GarbageChunkInfo(chunkToDelete, startTime, attempts));\n+            queueSize.incrementAndGet();\n+        } else {\n+            log.debug(\"{}: deleteGarbage - Queue full. Could not delete garbage. chunk {}.\", traceObjectId, chunkToDelete);\n+        }\n+    }\n+\n+    /**\n+     * Delete the garbage chunks.\n+     *\n+     * This method retrieves a few eligible chunks for deletion at a time.\n+     * The chunk is deleted only if the metadata for it does not exist or is marked inactive.\n+     * If there are any errors then failed chunk is enqueued back.\n+     * If suspended or there are no items then it \"sleeps\" for time specified by configuration.\n+     *\n+     * @param isBackground True if the caller is background task else False if called explicitly.\n+     * @param maxItems     Maximum number of items to delete at a time.\n+     * @return CompletableFuture which is completed when garbage is deleted.\n+     */\n+    CompletableFuture<Boolean> deleteGarbage(boolean isBackground, int maxItems) {\n+        log.debug(\"{}: deleteGarbage - started.\", traceObjectId);\n+        // Sleep if suspended.\n+        if (suspended.get() && isBackground) {\n+            log.info(\"{}: deleteGarbage - suspended - sleeping for {}.\", traceObjectId, config.getGarbageCollectionDelay());\n+            return CompletableFuture.completedFuture(false);\n+        }\n+\n+        // Find chunks to delete.\n+        val chunksToDelete = new ArrayList<GarbageChunkInfo>();\n+        int count = 0;\n+        try {\n+            // Block until you have at least one item.\n+            GarbageChunkInfo info = garbageChunks.take();\n+            log.trace(\"{}: deleteGarbage - retrieved {}\", traceObjectId, info);\n+            while (null != info ) {\n+                queueSize.decrementAndGet();\n+                chunksToDelete.add(info);\n+\n+                count++;\n+                if (count >= maxItems) {\n+                    break;\n+                }\n+                // Do not block\n+                info = garbageChunks.poll();\n+                log.trace(\"{}: deleteGarbage - retrieved {}\", traceObjectId, info);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new CompletionException(e);\n+        }\n+\n+        // Sleep if no chunks to delete.\n+        if (count == 0) {\n+            log.debug(\"{}: deleteGarbage - no work - sleeping for {}.\", traceObjectId, config.getGarbageCollectionDelay());\n+            return CompletableFuture.completedFuture(false);\n+        }\n+\n+        // For each chunk delete if the chunk is not present at all in the metadata or is present but marked as inactive.\n+        ArrayList<CompletableFuture<Void>> futures = new ArrayList<>();\n+        for (val infoToDelete : chunksToDelete) {\n+            val chunkToDelete = infoToDelete.name;\n+            val failed = new AtomicBoolean();\n+            val txn = metadataStore.beginTransaction(false, chunkToDelete);\n+            val future =\n+                    txn.get(infoToDelete.name)\n+                            .thenComposeAsync(metadata -> {\n+                                val chunkMetadata = (ChunkMetadata) metadata;\n+                                // Delete if the chunk is not present at all in the metadata or is present but marked as inactive.\n+                                val shouldDeleteChunk = null == chunkMetadata || !chunkMetadata.isActive();\n+                                val shouldDeleteMetadata = new AtomicBoolean(null != metadata && !chunkMetadata.isActive());\n+\n+                                // Delete chunk from storage.\n+                                if (shouldDeleteChunk) {\n+                                    return chunkStorage.openWrite(chunkToDelete)\n+                                            .thenComposeAsync(chunkStorage::delete, storageExecutor)\n+                                            .handleAsync((v, e) -> {\n+                                                if (e != null) {\n+                                                    val ex = Exceptions.unwrap(e);\n+                                                    if (ex instanceof ChunkNotFoundException) {\n+                                                        // Ignore - nothing to do here.\n+                                                        log.debug(\"{}: deleteGarbage - Could not delete garbage chunk={}.\", traceObjectId, chunkToDelete);", "originalCommit": "0ebaa9a05e6180979ad28dbec2cd5529e07a66bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwMDAyNg==", "url": "https://github.com/pravega/pravega/pull/5413#discussion_r543600026", "bodyText": "There are 5 info level logs which I find important\nlog.info (\"{}: Iteration {} started.\", traceObjectId, iterationId.get());\nlog.info(\"{}: Iteration {} ended.\", traceObjectId, iterationId.getAndIncrement());\nlog.info(\"{}: deleteGarbage - suspended - sleeping for {}.\", traceObjectId, config.getGarbageCollectionDelay());\nlog.info(\"{}: deleteGarbage - Chunk is not marked as garbage chunk={}.\", traceObjectId, chunkToDelete);\nlog.info(\"{}: deleteGarbage - could not delete after max attempts chunk={}.\", traceObjectId, chunkToDelete);\n\nFollowing are important to know what went wrong\nlog.warn(\"{}: deleteGarbage - Queue full. Could not delete garbage. Chunks skipped\", traceObjectId);\nlog.warn(\"{}: deleteGarbage - Could not delete garbage chunk={}.\", traceObjectId, chunkToDelete);\n                                                        \n\nfollowing are unusual circumstances that need to be recorded\nlog.error(\"{}: Error during doRun.\", traceObjectId, ex);\nlog.error(String.format(\"%s deleteGarbage - Could not delete metadata for garbage chunk=%s.\",\n                                                            traceObjectId, chunkToDelete), e);\nlog.error(String.format(\"%s deleteGarbage - Could not find garbage chunk=%s.\",\n                                            traceObjectId, chunkToDelete), ex);\n\nPerhaps last two above could be info or warn.\nOther logs are for debug purpose and as such they need to show details of what happened ....\nwe'll tweak this as we go along ..some of them will become trace as we gain more run time with this code.", "author": "sachin-j-joshi", "createdAt": "2020-12-15T18:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMzM3Mg=="}], "type": "inlineReview"}, {"oid": "5bcc09b625ed897c8254fc492deb06e1e5c9a83f", "url": "https://github.com/pravega/pravega/commit/5bcc09b625ed897c8254fc492deb06e1e5c9a83f", "message": "Merge branch 'master' of https://github.com/pravega/pravega into issue-4903-improve-garbage-collection-2", "committedDate": "2020-12-15T18:37:45Z", "type": "commit"}, {"oid": "542af21c7cdfba98b2637774ded7e7caa078e4ae", "url": "https://github.com/pravega/pravega/commit/542af21c7cdfba98b2637774ded7e7caa078e4ae", "message": "Issue 4903: (SLTS) cleanup.\n\nSigned-off-by: Sachin Joshi <sachin.joshi@emc.com>", "committedDate": "2020-12-15T20:46:16Z", "type": "commit"}, {"oid": "e559419403aad3e9dd7df3d3d91a6bc26c1aa5d2", "url": "https://github.com/pravega/pravega/commit/e559419403aad3e9dd7df3d3d91a6bc26c1aa5d2", "message": "Merge branch 'master' into issue-4903-improve-garbage-collection-2", "committedDate": "2020-12-16T22:13:55Z", "type": "commit"}]}