{"pr_number": 5406, "pr_title": "Issue 5403: (SegmentStore) Reducing number of Storage reads from SegmentAttributeBTreeIndex", "pr_createdAt": "2020-12-07T22:36:00Z", "pr_url": "https://github.com/pravega/pravega/pull/5406", "timeline": [{"oid": "c87395b2016272cdba5d675b7daa9522c3611ac2", "url": "https://github.com/pravega/pravega/commit/c87395b2016272cdba5d675b7daa9522c3611ac2", "message": "Piggybacking.\n\nNeed to fix unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-05T00:32:28Z", "type": "commit"}, {"oid": "f19536a5e2341b0e8d8b69cba1a374c7a235afde", "url": "https://github.com/pravega/pravega/commit/f19536a5e2341b0e8d8b69cba1a374c7a235afde", "message": "Merge remote-tracking branch 'origin/master' into issue-5401-piggybacks", "committedDate": "2020-12-07T22:21:25Z", "type": "commit"}, {"oid": "6f34f5abe8a5f7270e71864b03a648760a46df74", "url": "https://github.com/pravega/pravega/commit/6f34f5abe8a5f7270e71864b03a648760a46df74", "message": "Reducing the number of Storage reads for SegmentAttributeBTreeIndex.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-07T22:30:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkxNjkxMw==", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537916913", "bodyText": "Let's add a debug/warn log here so we can keep track of such cases.", "author": "sachin-j-joshi", "createdAt": "2020-12-07T23:35:41Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -502,15 +515,63 @@ private long deserializeValue(ByteArraySegment value) {\n                         \"Attribute Index Segment has not been created yet. Cannot read %d byte(s) from offset (%d).\",\n                         length, offset)));\n             }\n-        } else {\n-            byte[] buffer = new byte[length];\n-            return this.storage.read(handle, offset, buffer, 0, length, timeout)\n-                               .thenApplyAsync(bytesRead -> {\n-                                   Preconditions.checkArgument(length == bytesRead, \"Unexpected number of bytes read.\");\n-                                   storeInCache(offset, buffer);\n-                                   return new ByteArraySegment(buffer);\n-                               }, this.executor);\n         }\n+\n+        return readPageFromStorage(handle, offset, length, timeout);\n+    }\n+\n+    /**\n+     * Reads a BTreeIndex page from Storage and inserts its into the cache (no cache lookups are performed).\n+     * Handles read concurrency on the same page by piggybacking on existing running reads on that page (identified by\n+     * page offset). If more than one concurrent request is issued for the same page, only one will be sent to Storage,\n+     * and subsequent ones will be attached to the original one.\n+     *\n+     * @param handle  {@link SegmentHandle} to read from.\n+     * @param offset  Page offset.\n+     * @param length  Page length.\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that will contain the result.\n+     */\n+    @VisibleForTesting\n+    CompletableFuture<ByteArraySegment> readPageFromStorage(SegmentHandle handle, long offset, int length, Duration timeout) {\n+        PendingRead pr;\n+        synchronized (this.pendingReads) {\n+            pr = this.pendingReads.get(offset);\n+            if (pr == null) {\n+                // Nobody else waiting for this offset. Register ourselves.\n+                pr = new PendingRead(offset, length);\n+                pr.completion.whenComplete((r, ex) -> {\n+                    // Cleanup.\n+                    synchronized (this.pendingReads) {\n+                        this.pendingReads.remove(offset);\n+                    }\n+                });\n+                this.pendingReads.put(offset, pr);\n+            } else if (pr.length < length) {\n+                // Somehow the previous request wanted to read less than us. This shouldn't be the case, yet it is\n+                // a situation we should handle. In his case, we will not be recording the PendingRead.\n+                pr = new PendingRead(offset, length);", "originalCommit": "6f34f5abe8a5f7270e71864b03a648760a46df74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyODUwMQ==", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537928501", "bodyText": "What happens when page is evicted ?\nI think here when page is evicted from cache we need to remove that offset from pendingReads , otherwise next time we need to reload the page again we'll have a stale completed future from the last time and we won't really read anything - leaving cache with missing data.", "author": "sachin-j-joshi", "createdAt": "2020-12-08T00:02:47Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/attributes/SegmentAttributeBTreeIndex.java", "diffHunk": "@@ -502,15 +515,63 @@ private long deserializeValue(ByteArraySegment value) {\n                         \"Attribute Index Segment has not been created yet. Cannot read %d byte(s) from offset (%d).\",\n                         length, offset)));\n             }\n-        } else {\n-            byte[] buffer = new byte[length];\n-            return this.storage.read(handle, offset, buffer, 0, length, timeout)\n-                               .thenApplyAsync(bytesRead -> {\n-                                   Preconditions.checkArgument(length == bytesRead, \"Unexpected number of bytes read.\");\n-                                   storeInCache(offset, buffer);\n-                                   return new ByteArraySegment(buffer);\n-                               }, this.executor);\n         }\n+\n+        return readPageFromStorage(handle, offset, length, timeout);\n+    }\n+\n+    /**\n+     * Reads a BTreeIndex page from Storage and inserts its into the cache (no cache lookups are performed).\n+     * Handles read concurrency on the same page by piggybacking on existing running reads on that page (identified by\n+     * page offset). If more than one concurrent request is issued for the same page, only one will be sent to Storage,\n+     * and subsequent ones will be attached to the original one.\n+     *\n+     * @param handle  {@link SegmentHandle} to read from.\n+     * @param offset  Page offset.\n+     * @param length  Page length.\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that will contain the result.\n+     */\n+    @VisibleForTesting\n+    CompletableFuture<ByteArraySegment> readPageFromStorage(SegmentHandle handle, long offset, int length, Duration timeout) {\n+        PendingRead pr;\n+        synchronized (this.pendingReads) {\n+            pr = this.pendingReads.get(offset);\n+            if (pr == null) {\n+                // Nobody else waiting for this offset. Register ourselves.\n+                pr = new PendingRead(offset, length);\n+                pr.completion.whenComplete((r, ex) -> {\n+                    // Cleanup.\n+                    synchronized (this.pendingReads) {\n+                        this.pendingReads.remove(offset);\n+                    }\n+                });\n+                this.pendingReads.put(offset, pr);\n+            } else if (pr.length < length) {\n+                // Somehow the previous request wanted to read less than us. This shouldn't be the case, yet it is\n+                // a situation we should handle. In his case, we will not be recording the PendingRead.\n+                pr = new PendingRead(offset, length);\n+            } else {\n+                // Piggyback on the existing read.\n+                return pr.completion;", "originalCommit": "6f34f5abe8a5f7270e71864b03a648760a46df74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMjIyNA==", "url": "https://github.com/pravega/pravega/pull/5406#discussion_r537932224", "bodyText": "Oops my bad.\nNever mind - I now see it is removed on line 546. Thanks", "author": "sachin-j-joshi", "createdAt": "2020-12-08T00:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyODUwMQ=="}], "type": "inlineReview"}, {"oid": "1d53925c8e8bf63870147115e2c23b038c2dcf69", "url": "https://github.com/pravega/pravega/commit/1d53925c8e8bf63870147115e2c23b038c2dcf69", "message": "Log messages.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-12-08T02:36:16Z", "type": "commit"}, {"oid": "f00f21b6dbe08755cb3e1f2715a242368a2097a3", "url": "https://github.com/pravega/pravega/commit/f00f21b6dbe08755cb3e1f2715a242368a2097a3", "message": "Merge branch 'master' into issue-5401-piggybacks", "committedDate": "2020-12-08T04:54:25Z", "type": "commit"}]}