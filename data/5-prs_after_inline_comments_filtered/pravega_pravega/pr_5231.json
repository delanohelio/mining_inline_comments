{"pr_number": 5231, "pr_title": "Issue 5115: Allow reads using read-only permissions", "pr_createdAt": "2020-10-05T07:45:07Z", "pr_url": "https://github.com/pravega/pravega/pull/5231", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzODUxNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515838517", "bodyText": "wouldnt requested permission for older clients be null?\nshould we invert this check to avoid NPE?", "author": "shiveshr", "createdAt": "2020-11-02T09:26:24Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -380,20 +480,35 @@ public void getEpochSegments(GetEpochSegmentsRequest request, StreamObserver<Seg\n \n     @Override\n     public void getSegments(GetSegmentsRequest request, StreamObserver<SegmentsAtTime> responseObserver) {\n-        log.debug(\"getSegments called for stream \" + request.getStreamInfo().getScope() + \"/\" +\n-                request.getStreamInfo().getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getStreamInfo().getScope(),\n-                        request.getStreamInfo().getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getSegments\", request.getStreamInfo().getScope(),\n-                            request.getStreamInfo().getStream());\n-                    return controllerService.getSegmentsAtHead(request.getStreamInfo().getScope(),\n-                            request.getStreamInfo().getStream())\n+        final StreamInfo streamInfo = request.getStreamInfo();\n+        final String scope = streamInfo.getScope();\n+        final String stream = streamInfo.getStream();\n+        log.debug(\"getSegments called for stream \" + scope + \"/\" + stream);\n+\n+        final boolean isDelegationTokenRequested =\n+                streamInfo.getRequestedPermission().equals(AccessOperation.NONE.toString()) ? false : true;", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTcwOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516395708", "bodyText": "Yes, thanks for spotting the bug. I've made the change now.", "author": "ravisharda", "createdAt": "2020-11-03T02:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzODUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc4OTMzOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515789338", "bodyText": "Does NONE mean that this is requesting a token with the default authorization for the operation (MRP in the PDP)?", "author": "fpj", "createdAt": "2020-11-02T07:51:07Z", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -957,7 +958,7 @@ private Boolean handleScaleResponse(Stream stream, ScaleResponse response, long\n \n         final CompletableFuture<SegmentsAtTime> result = this.retryConfig.runAsync(() -> {\n             RPCAsyncCallback<SegmentsAtTime> callback = new RPCAsyncCallback<>(traceId, \"getSegmentsAtTime\", stream, timestamp);\n-            StreamInfo streamInfo = ModelHelper.createStreamInfo(stream.getScope(), stream.getStreamName());\n+            StreamInfo streamInfo = ModelHelper.createStreamInfo(stream.getScope(), stream.getStreamName(), AccessOperation.NONE);", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg3OTAzMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515879030", "bodyText": "Actually, we are using this to tell the server that the client doesn't need a delegation token to be prepared and sent back. Older clients'll not set it, so the server will continue to return delegation tokens. Newer clients will not receive the token, due to this change.", "author": "ravisharda", "createdAt": "2020-11-02T10:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc4OTMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTQyOQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515791429", "bodyText": "I don't understand why this mark prefix needs to be made public.", "author": "fpj", "createdAt": "2020-11-02T07:55:51Z", "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -132,7 +135,7 @@\n     /**\n      * Prefix for identifying system created mark segments for storing watermarks. \n      */\n-    @Getter(AccessLevel.PACKAGE)\n+    @Getter(AccessLevel.PUBLIC)", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4MTUxNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515881514", "bodyText": "The reason for making this public is that we are not using the getter in io.pravega.controller.server.security.auth.StreamAuthParams class.", "author": "ravisharda", "createdAt": "2020-11-02T10:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515792342", "bodyText": "Although this makes sense, the terminology does not match what is in the PDP. The PDP refers to MRP and RP, which are about permissions, there is no reference to access operations. Perhaps it needs to be reflected in the PDP?", "author": "fpj", "createdAt": "2020-11-02T07:57:45Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4OTAwNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515889004", "bodyText": "Yes, I shall update the PDP later to reflect some of the changes in this PR.\nTo share a bit more context on this:\nThis class is a shared class to represent operations (READ, WRITE, READ_WRITE) being performed. It is similar to the AuthHandler.Permissions enum, which takes on values NONE, READ, READ_UPDATE).\n\n  \n    \n      pravega/shared/authplugin/src/main/java/io/pravega/auth/AuthHandler.java\n    \n    \n        Lines 34 to 37\n      in\n      3b0068f\n    \n    \n    \n    \n\n        \n          \n           enum Permissions { \n        \n\n        \n          \n               NONE, \n        \n\n        \n          \n               READ, \n        \n\n        \n          \n               READ_UPDATE \n        \n    \n  \n\n\nThis new AccessOperation was needed for these reasons:\n\nUsing an AuthHandler AuthHandler.Permissions class in the Client-side'd look awkward.\nAccess operations are things like read, write, delete, update, etc. Permissions reflect things like allow, deny, etc. Right now I've kept the permission enum as is. The client only uses AccessOperation, the server translates it to the corresponding AuthHandler.Permissions. At a later time when we further refine the authorization model, we'll have some flexibility in defining additional operations.", "author": "ravisharda", "createdAt": "2020-11-02T10:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNzQ4Mw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518937483", "bodyText": "Ok, to confirm my understanding, you see AuthHandler.Permissions and AccessOperation diverging in the future, so it makes no sense to try to consolidate the enums, is it right?", "author": "fpj", "createdAt": "2020-11-06T18:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MTMwMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519151301", "bodyText": "IMO, eventually AccessOperation should replace AuthHandler.Permissions altogether. Right now, the client only uses the former, and the server uses both (maps the former to the latter). That'd be too big a change, so I've left the latter for now.", "author": "ravisharda", "createdAt": "2020-11-07T08:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MjIyNg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519152226", "bodyText": "I've created a new issue to track that future change: #5309.", "author": "ravisharda", "createdAt": "2020-11-07T08:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjU3OA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515792578", "bodyText": "In which cases would I want to grant write permission but not read?", "author": "fpj", "createdAt": "2020-11-02T07:58:22Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+\n+    /**\n+     * Doesn't represent any specific operation, and allows the caller to make it explicit that any access operation.\n+     * It is primarily meant for use in tests.\n+     */\n+    ANY,\n+\n+    /**\n+     * Represents reads.\n+     */\n+    READ,\n+\n+    /**\n+     * Represents inserts, updates and deletes.\n+     */\n+    WRITE,", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MTA5MA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515891090", "bodyText": "Say, you want users to append to the stream, but not read from it. (That's not supported as of now.)\nIn the client where we specify these operations, I've tried to reflect the intended operation precisely as WRITE or READ_WRITE.  Right now, both WRITE and READ_WRITE are interpreted as READ_UPDATE in the Controller. Still, this makes it easy to distinguish those operations later if we need to, apart from making the operation more explicit.", "author": "ravisharda", "createdAt": "2020-11-02T10:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515824785", "bodyText": "I'm wondering whether returning the default permissions is the right thing to do. If the string is illegal and we return the default, then aren't we implicitly assuming that the default is what the caller wants? It might be a better approach to error it out.", "author": "fpj", "createdAt": "2020-11-02T09:02:15Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;\n+        }\n+        try {\n+            return toAuthHandlerPermissions(AccessOperation.valueOf(accessOperationStr));\n+        } catch (IllegalArgumentException e) {\n+            return defaultPermissions;", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5OTAyNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516399024", "bodyText": "This method is quite like the Java System.getProperty\u200b(String key, String def). It takes a default value as input and returns that if it is unable to parse. The usage of this method is in StreamAuthParams, which sets the default as READ, based on the purpose it in turn is used in ControllerServiceImpl.\nDoes that sound good to you?", "author": "ravisharda", "createdAt": "2020-11-03T02:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzOTc1MA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518939750", "bodyText": "Say we are trying to get a permission to read_update, and for some reason the string is messed up. Say that the default permission is read, in which case this is returning a read permission. Assuming a scenario like this is possible,  transparently returning the default sounds problematic because that's not the intention.", "author": "fpj", "createdAt": "2020-11-06T18:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1ODcxNg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519158716", "bodyText": "Ok. I've modified the code to throw the exception as-is when a value is present but cannot be parsed.", "author": "ravisharda", "createdAt": "2020-11-07T09:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNDc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNzE1NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515827154", "bodyText": "This feels hacky. Could the delegation token instead contain specific authorization for the internal stream that needs to be written to? This current way is amplifying a read authorization, which I'm not convinced is a good approach.", "author": "fpj", "createdAt": "2020-11-02T09:06:45Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -146,7 +147,8 @@ public void setupAppend(SetupAppend setupAppend) {\n             try {\n                 JsonWebToken token = tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n-                        AuthHandler.Permissions.READ_UPDATE);\n+                        newSegment.contains(NameUtils.INTERNAL_STREAM_IDENTIFYING_PATTERN) ?", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDM2OA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518870368", "bodyText": "Sure, I've changed the implementation now such that the delegation token is assigned the appropriate authorization. Please see if it looks better.", "author": "ravisharda", "createdAt": "2020-11-06T16:40:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNzE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515835018", "bodyText": "Reader Group synchronizer and Mark streams are internal streams, but they have one very important difference. The former is written directly by clients (readers) while the latter is written by the controller. For the Mark stream, what we need to authorize is that controller tracks the requests to note time from the writer, and the writer is already expected to have write access. A reader will only be reading to the Mark stream, not writing to it.", "author": "fpj", "createdAt": "2020-11-02T09:20:45Z", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -64,4 +67,15 @@ public String ofKeyValueTableInScope(String scopeName, String keyValueTableName)\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        if (streamName.startsWith(NameUtils.READER_GROUP_STREAM_PREFIX)) {", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDQ0NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518880444", "bodyText": "For watermark streams we authorize against the corresponding stream:\n\n  \n    \n      pravega/controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java\n    \n    \n        Lines 75 to 76\n      in\n      11daa62\n    \n    \n    \n    \n\n        \n          \n           } else if (streamName.startsWith(NameUtils.getMARK_PREFIX())) { \n        \n\n        \n          \n               return ofStreamInScope(scopeName, streamName.replace(NameUtils.getMARK_PREFIX(), \"\")); \n        \n    \n  \n\n\nDoes that look OK?", "author": "ravisharda", "createdAt": "2020-11-06T16:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MDcwMw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518940703", "bodyText": "My point is that in principle no client needs to write to the mark stream, only the controller writes to the mark stream. We shouldn't be granting the client authorization to write to that stream if it doesn't need it.", "author": "fpj", "createdAt": "2020-11-06T18:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1OTEzMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519159131", "bodyText": "The segment store also authorizes the controller's requests, so it must have permissions to write to that watermark stream. Since the client doesn't invoke the operation, it wouldn't be authorized for the mark stream or issued a delegation token containing the authorization. Does that address your question, or am I missing something?", "author": "ravisharda", "createdAt": "2020-11-07T09:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE5ODExOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519198118", "bodyText": "I'm not sure it addresses my question. The controller appends to the mark stream, and I think you are saying that the controller appending to the mark stream also requires authorization. This part makes sense.\nThe next question I have is how the controller is authorized to append to the mark stream. The controller consolidates in a single stream cut the marks from a group of writers, so it can't be transitively authorized with the token of a single writer. In fact, I'm wondering if its authorization should have anything to do with the authorization of the writers as a controller instance should be able to perform operations against the segment store as long as it can demonstrate that it is a legitimate controller. If a controller has been authenticated as a legitimate controller, then it can be authorized as such to perform operations against the segment store. What am I missing?", "author": "fpj", "createdAt": "2020-11-07T17:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc1NDQ1Ng==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519754456", "bodyText": "I don't know exactly what/how appends are facilitated by the controller and made by the segment store, so I don't know the answers to all the questions above. @shiveshr / @tkaitchuck could you please chime in?\nBased on my experiments, I had seen that the reads from a stream'd fail if the user didn't have permissions on the corresponding mark stream. Please see references to _MARK stream in this PDP.\nSince mark streams are an internal construct, I had modified the code to authorize against the corresponding stream in this PR, based on my discussion with @shiveshr. My understanding is that for a stream myscope/mystream we create a corresponding mark stream myscope/_MARKmystream.", "author": "ravisharda", "createdAt": "2020-11-09T11:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3MjgzMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520272831", "bodyText": "@fpj is correct.\nwriters need to be authorized for read-update on base stream to be able to call notetime.\nwriters do not request for a delegation token for calling notetime as they do not write directly to mark stream.\nController uses the \"master\" delegation token for all writes to all metadata tables and mark streams. So it has permissions by default for writing to any internal stream. Note: for table calls it creates the master delegation token. for client calls (e.g. request stream reader and writer, mark's revisioned stream client, it uses the ClientConfig which loads the creds from the environment which gives it the controller creds for talking to segment store).\n@ravisharda can you please confirm the following:\nif any client application with \"READ_UPDATE\" permission on base stream requests READ_UPDATE on mark stream, do you grant it?\ni think with these changes it would presently do it.\nalthough nowhere in the code does a user application request for write permissions on a mark stream.. but our authorization is not preventing that explicitly which it should. right?", "author": "shiveshr", "createdAt": "2020-11-10T04:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNjk2OA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521016968", "bodyText": "@shiveshr yes, if the client requests for a delegation token (via getDelegationToken call) with READ_UPDATE permissions for a mark stream, we validate that the client has READ_UPDATE permission on the corresponding stream and return a delegation token enabling the client to read from/write to that mark stream. We aren't preventing that from happening as of now.\nIf clients have no business requesting for delegation tokens for mark streams, I can add logic to prevent that from happening. What do you say?", "author": "ravisharda", "createdAt": "2020-11-11T02:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAyMTUyOQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521021529", "bodyText": "we should prevent them from requesting read_update.\nreaders still need \"read\" permissions on it to read from mark stream.", "author": "shiveshr", "createdAt": "2020-11-11T02:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMzNTY2NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521335665", "bodyText": "I've made the change in the latest commit that I just pushed. Please take a look. Here's what it does:\n\nIf the client calls getDelegationToken for read permissions on mark streams, it authorizes the user and returns one.\nIf the client calls getDelegationToken for write permissions on mark streams, it rejects the request with an authorization exception.\nIf the client calls getDelegationToken for mark streams, without specifying the access operation, it authorizes the client for reads and returns a delegation token with read permissions.", "author": "ravisharda", "createdAt": "2020-11-11T12:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyODQxNg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522428416", "bodyText": "There is one point I'd like to clarify, see this:\n#5231 (comment)", "author": "fpj", "createdAt": "2020-11-12T21:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515835577", "bodyText": "... null is equivalent to NONE?", "author": "fpj", "createdAt": "2020-11-02T09:21:45Z", "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -416,10 +418,18 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n-    public static final StreamInfo createStreamInfo(final String scope, final String stream) {\n+    public static final StreamInfo createStreamInfo(final String scope, final String stream, AccessOperation accessOperation) {\n         Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n         Exceptions.checkNotNullOrEmpty(stream, \"stream\");\n-        return StreamInfo.newBuilder().setScope(scope).setStream(stream).build();\n+        StreamInfo.Builder builder = StreamInfo.newBuilder().setScope(scope).setStream(stream);\n+        if (accessOperation != null) {\n+            builder.setRequestedPermission(accessOperation.name());\n+        }", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3Mjk4Nw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518872987", "bodyText": "No, not really. Older clients will not set the access operation, so the server will not receive a requested permission in the input message.", "author": "ravisharda", "createdAt": "2020-11-06T16:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyMDg4OQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518920889", "bodyText": "Ok, so null is for backward compatibility?", "author": "fpj", "createdAt": "2020-11-06T18:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1NzQ3Mw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519157473", "bodyText": "Yes.", "author": "ravisharda", "createdAt": "2020-11-07T09:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNTU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjM5OQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515836399", "bodyText": "Typo in th server.", "author": "fpj", "createdAt": "2020-11-02T09:23:10Z", "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "diffHunk": "@@ -35,25 +36,28 @@ public static DelegationTokenProvider createWithEmptyToken() {\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param scopeName the name of the scope tied to the segment, for which a delegation token is to be obtained\n      * @param streamName the name of the stream tied to the segment, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTg0NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516395844", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2020-11-03T02:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjUxNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515836517", "bodyText": "Same typo.", "author": "fpj", "createdAt": "2020-11-02T09:23:22Z", "path": "client/src/main/java/io/pravega/client/security/auth/DelegationTokenProviderFactory.java", "diffHunk": "@@ -35,25 +36,28 @@ public static DelegationTokenProvider createWithEmptyToken() {\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param scopeName the name of the scope tied to the segment, for which a delegation token is to be obtained\n      * @param streamName the name of the stream tied to the segment, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server\n      * @return a new {@link DelegationTokenProvider} instance\n      * @throws NullPointerException if {@code controller}, {@code scopeName} or {@code streamName} is null\n      * @throws IllegalArgumentException if {@code scopeName} or {@code streamName} is empty\n      */\n     @VisibleForTesting\n-    public static DelegationTokenProvider create(Controller controller, String scopeName, String streamName) {\n-        return create(null, controller, scopeName, streamName);\n+    public static DelegationTokenProvider create(Controller controller, String scopeName, String streamName,\n+                                                 AccessOperation accessOperation) {\n+        return create(null, controller, scopeName, streamName, accessOperation);\n     }\n \n     /**\n      * Creates a {@link DelegationTokenProvider} instance with null delegation token.\n      *\n      * @param controller the {@link Controller} client used for obtaining a delegation token from the Controller\n      * @param segment the {@link Segment}, for which a delegation token is to be obtained\n+     * @param accessOperation the access operation to use when requesting a delegation token from th server", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTg4OA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r516395888", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2020-11-03T02:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNjUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515842834", "bodyText": "One major problem I see with configuring it this way is that it will be difficult for a user to understand what to do about it. It is rather counterintuitive and the tradeoffs are not very clear. What would be the argument against always giving write access to the reader group synchronizer stream instead of adding this parameter?", "author": "fpj", "createdAt": "2020-11-02T09:33:32Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,14 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    /**\n+     * Indicates whether writes to internal streams are allowed with read permissions. If false, writes to internal\n+     * streams will require write permissions too.\n+     *\n+     * @return Whether writes to internal streams are allowed with read permissions.\n+     */\n+    boolean isInternalWritesWithReadPermEnabled();", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIzNTgxNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518235817", "bodyText": "@fpj, I am not sure if you meant what you said, which is \"always give write access\" or you meant \"require write access\".\nI don't think we can \"give\" write access automatically.   The reason why we want to be able to preserve the \"you need READ_UPDATE to touch/mutate this ReaderGroup\" behavior is for these types of deployments where:\n\nenvironments where low level granular \"ahead of time\" acl provisioning is not possible due to the fact that the resources, scopes, streams, reader groups, are not known ahead of time.\nthere is a conscious intent to apply ACLs at the scope level because it's easier to manage for the admin, who does not have to worry about new streams getting created and having to micro manage at that level.  Scopes are more viewed like \"teams\" or \"tenants\".\n\nFor that reason, heavy use of wild cards is required usually at the scope level.  That means that if \"READ\" allowed access to reader groups in general, reader subjects could be interfering with each other.\nAn example of this is when members of a team called \"compute1\" scope for which was created so they can run their own applications etc.   chris is part of that team.\nThere's also a \"compute2\" team/scope with a jack user in it.\nThere is also a team called marketdata with a scope and streams into which stock market data was ingested etc.\nThe desire is that members from compute1 and compute2 can read any streams (present and future) from marketdata but not alter any data. Additionally not be able to mess with reader groups synchronizer states in marketdata or reader groups from the other team's scope.\nACLs would look like this:\nREAD on prn://scope:marketdata/* and READ_UPDATE on prn://scope:compute1/* to chris\nREAD on prn://scope:marketdata/* and READ_UPDATE on prn://scope:compute1/* to jack\n\nchris can read marketata/streamXYZ and is tracking its RG state in compute1/...\njack can read marketata/streamXYZ and is tracking its RG state in compute2/...\nIt is assumed that if chris's friend maddy, with common READ_UPDATE rights on compute1 enters the picture, she can see and update the RG that chris created.  But she's part of the same team.  That is ok).  jack however, is prevented from accessing chris and maddy's RGs, while still benefiting from accessing marketdata's streams.\nIf the READ on prn://scope:marketdata/* was allowing mutation of reader groups, then in theory chris and jack could create reader groups there and mess with each other's reader groups. So in this use case, it's best to remain with the \"Mutation/access to Reader groups is still protected by READ_UPDATE\", such that chris and jack are forced to put their reader groups in their own team scopes.\nThe flag that's added in this PR, when set to false, allows the above to work.", "author": "sarlaccpit", "createdAt": "2020-11-05T17:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkzNjcxNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518936714", "bodyText": "@sarlaccpit thanks for patiently explaining the reasoning behind the option. If a user is granted permission to read from a stream, then it should be automatically granted permission to write to the corresponding reader group stream because without that it can't be part of the reader group. Anything that is needed for a user to be able to read from a stream from an authorization perspective needs to be included in the read authorization, otherwise, from a usability perspective, it won't look very good. The option we are discussing is fairly obscure.\nThe use of wildcards you describe makes sense. If users with read authorization can create reader groups, then they would be messing up with their own reader group. If that's undesirable, which is reasonable, then perhaps we can require read_update to create a reader group, and only read to join.\nOne point I don't understand: what happens if a reader group is configured to read from stream A and B, and a given reader that tries to join is only authorized to read from A? I suppose it won't be able to join the reader group.", "author": "fpj", "createdAt": "2020-11-06T18:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0MTYwNQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r518941605", "bodyText": "The nuances of join versus create, wrt Read group do make sense.   Although that seems like part of what @ravisharda is likely planning in the future; which is the addition of finer grained permissions, beyond READ and READ_UPDATE which admittedly are not fine grain enough (in general that is, not just for reader groups).  One can imagine the need for things like DELETE, and also WRITE_ONLY (append only) that I have seen mentioned in other context.\nBut I don't think this is part of this PR (which is already ambitious as it is :).   So @ravisharda can correct me, but basically READ_UPDATE on the reader group basically means: use the reader group and do what you need with it.\nFor the question of the reader group tracking multiple streams, not all of which you may have access to.   Again, @ravisharda  can say best, but I believe the permission on the reader group is what the focus is, the reader group being its own entity.   The fact it's related to streams is sort of an aside I think?  Meaning, at the end of the day, when the client tries to access stream a or stream b, it'll be confronted to whether or not it has access for these streams then.", "author": "sarlaccpit", "createdAt": "2020-11-06T18:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE1MDg2NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519150865", "bodyText": "@fpj To help make what @sarlaccpit says above a bit more concrete, let me share a couple of examples from the newly added integration tests:\nThe following lines from a test that uses read-only permissions to read data from a stream, shows the low-level permissions - all READ permissions - on the stream, on the reader group and on the scope - required for reading from the stream:\n\n  \n    \n      pravega/test/integration/src/test/java/io/pravega/test/integration/ReadWithReadPermissionsTest.java\n    \n    \n        Lines 71 to 74\n      in\n      11daa62\n    \n    \n    \n    \n\n        \n          \n           passwordInputFileEntries.put(\"reader\", String.join(\";\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData,READ\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/stream:StockPriceUpdates,READ\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ\" \n        \n    \n  \n\n\nThe above is true by default. If you turn a flag on (discussed earlier), reading data from a stream will continue to require READ_UPDATE permissions (as they do today):\n\n  \n    \n      pravega/test/integration/src/test/java/io/pravega/test/integration/ReadWithReadPermissionsTest.java\n    \n    \n        Lines 88 to 93\n      in\n      11daa62\n    \n    \n    \n    \n\n        \n          \n           passwordInputFileEntries.put(\"reader\", String.join(\";\", \n        \n\n        \n          \n                   // READ_UPDATE on scope needed for creating internal streams since we configure \"internal writes with \n        \n\n        \n          \n                   // read permissions\" to false later (during instantiation of the ClusterWrapper object). \n        \n\n        \n          \n                   \"prn::/scope:MarketData,READ_UPDATE\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/stream:StockPriceUpdates,READ\", \n        \n\n        \n          \n                   \"prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE\" \n        \n    \n  \n\n\nHope that clarifies.", "author": "ravisharda", "createdAt": "2020-11-07T08:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE5NzI2MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519197261", "bodyText": "I believe I understand what the two of you are saying, but why do we need the option? Said differently, if we remove the configuration option and have only the behavior of requiring read permission to write to internal streams, then what bad things are going to happen?", "author": "fpj", "createdAt": "2020-11-07T17:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQzNzMyOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519437328", "bodyText": "The initial idea of this PR was to require read permissions for internal streams. But then @sarlaccpit explained a situation where that could be problematic for the platform where this feature would be used. He has explained it in one of the comments above - copying a fragment for reference:\n\nThe desire is that members from compute1 and compute2 can read any streams (present and future) from marketdata but not alter any data. Additionally not be able to mess with reader groups synchronizer states in marketdata or reader groups from the other team's scope.\n\nDoes that help?", "author": "ravisharda", "createdAt": "2020-11-08T15:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0Mjk1NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519442954", "bodyText": "Just adding a quick nuance on \"situation where that could be problematic for the platform where this feature would be used\".\nI'd say it'd be problematic for any environments that use the pravega scope as the main unit of authorization.", "author": "sarlaccpit", "createdAt": "2020-11-08T15:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQ0NDAyNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519444024", "bodyText": "It does not help much because you are trying to convince me that the behavior you are trying to implement makes sense, while the problem for me is not the behavior you are trying to implement, but instead how this PR is proposing to implement it.\nThere are two important points for me:\n\nIn that comment, there is an implicit assumption that the use of the wildcard will lead to all state synchronizer streams and reader groups to be readable. We clearly don't want that. We want that a user that is granted permission to read from a given stream (or set of streams via wildcard) is able to only read from those streams and participate in corresponding reader groups. There is even the question of whether a user authorized to read from a given stream can join any reader group reading from that streams. I'd claim that it shouldn't be like that.\nI'm not convinced we need this configuration flag.  As I see it, you can implement the behavior you want without having this flag, which I find confusing from the point of view of a user. I don't understand why we would want to give the user the ability to turn it on and off.", "author": "fpj", "createdAt": "2020-11-08T16:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzY4OQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519527689", "bodyText": "Regarding the first point:\n\nWe want that a user that is granted permission to read from a given stream (or set of streams via wildcard) is able to only read from those streams and participate in corresponding reader groups.\n\nYes, a subject (a user) can only read from streams that it has read access to.\nNot sure what you mean by \"corresponding\" reader groups. Reader groups (RG) are independent w.r.t. authorization. The user must have access to te RG stream as well:\n\nsay prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ (by default or if the Controller config controller.security.auth.internalStreams.writesWithReadPermissions.enable is true)\nprn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE (if the same config is turned off)\n\nRegarding the second point:\n\nI'm not convinced we need this configuration flag. As I see it, you can implement the behavior you want without having this flag, which I find confusing from the point of view of a user. I don't understand why we would want to give the user the ability to turn it on and off.\n\nIt's really an admin-level config, with a sensible default. The default config lets readers read from a stream with read-only permissions (as shown below), while allowing the admins control over what the readers can read:\nprn::/scope:MarketData,READ;prn::/scope:MarketData/stream:StockPriceUpdates,READ;prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ\nWhen the flag is turned off, the same user requires this ACL to read data:\nprn::/scope:MarketData,READ_UPDATE;prn::/scope:MarketData/stream:StockPriceUpdates,READ;prn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE\nFor systems that use Pravega authorizations at a scope level using wildcards, the config value of false can be useful:\n\nUser Bob has READ_UPDATE permission on BobScope*. He can create an RG under BobScope, create new streams under BobScope and read/write to any streams there.\nUser Alice has READ_UPDATE permission on AliceScope*, and she can create an RG under AliceScope, create new streams under AliceScope and read/write to any streams there.\nAlice also has READ permission on BobScope*, and therefore her RG AliceRg created for her in AliceScope can be used to read from BobScope/BobStream. Everything until here is possible in both configurations)\nHowever, since the config is off in this deployment, she cannot create RGs or join any other existing RGs in BobScope. If this config was set as default/true, she could.\n\nHope that clarifies.", "author": "ravisharda", "createdAt": "2020-11-09T02:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc2NDkxNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519764914", "bodyText": "I'm still not seeing a justification for supporting different behavior. The clarification only explains that there is a use case that limits the participation in reader groups for a principal that is authorized to read. It makes sense to limit participation in reader groups, so I'm wondering why we want to support the other behavior.\nAs for the reader group authorization options:\nprn::/scope:MarketData/reader-group:PriceChangeCalculator,READ\nprn::/scope:MarketData/reader-group:PriceChangeCalculator,READ_UPDATE\n\nMy confusion comes from the fact that if READ_UPDATE is expected, then what does it mean to use READ in an ACL for a reader group. The same for the other case. A reader group in principle can't be read-only. A principal is either authorized to join a reader group or not.  If it is authorized, then it must be able to read and write... or, are you thinking that requesting a checkpoint is a read-only activity that can be performed by a principal with read-only access to the reader group?", "author": "fpj", "createdAt": "2020-11-09T12:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4NDk0MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519784941", "bodyText": "My confusion comes from the fact that if READ_UPDATE is expected, then what does it mean to use READ in an ACL for a reader group.\n\nSince clients post RG state into the RG internal stream, even just reading data required READ_UPDATE permissions on the RG stream. In this PR, that behavior is dependent on whether the controller.security.auth.internalStreams.writesWithReadPermissions.enable is on/off. If it is on, just READ permission is sufficient, otherwise READ_UPDATE is required.\n\nA principal is either authorized to join a reader group or not. If it is authorized, then it must be able to read and write... or, are you thinking that requesting a checkpoint is a read-only activity that can be performed by a principal with read-only access to the reader group?\n\nThe intent has been to allow RG checkpointing using read permissions, while  providing a configuration to disable that globally (for systems that use scope-level authorizations so that admins have greater control, as explained earlier).", "author": "ravisharda", "createdAt": "2020-11-09T12:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg3ODk1Mg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519878952", "bodyText": "To add a bit more context, the flag is useful for systems that use Pravega authorizations at the level of Pravega scopes along with wildcards for child resources like resource groups and streams (as explained earlier in the chain). Ideally, we'd want any external authorization policies applied at that level to be mapped to finer-grained authorizations applied by Pravega at the level of Controller and Segment Store operations.\nHowever, Pravega doesn't support an important feature in this regard: a way of notifying external access control systems (like Keycloak) of creation/updation/deletion of fine-grained resources like streams, reader groups, etc. In the absence of that feature, mapping coarse-grained authorization policies to fine-grained operation-level authorizations is impractical, and that explains the use of wildcards at scope-level that @sarlaccpit was referring to earlier. I think we should live with this new config  until we have a solution for this problem. Once we have a resource lifecycle events notification mechism, we could remove this config later.", "author": "ravisharda", "createdAt": "2020-11-09T15:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjgzNA=="}], "type": "inlineReview"}, {"oid": "ed3f57f786084ae07c2657d4134507754859e0a5", "url": "https://github.com/pravega/pravega/commit/ed3f57f786084ae07c2657d4134507754859e0a5", "message": "Add more tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-02T09:41:58Z", "type": "commit"}, {"oid": "fc1283c13f57ab9e8e42e065a8e4c2a2f10e8a53", "url": "https://github.com/pravega/pravega/commit/fc1283c13f57ab9e8e42e065a8e4c2a2f10e8a53", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-03T02:20:11Z", "type": "commit"}, {"oid": "09e3804a218d2dde53460b1e9f7615ce53e143aa", "url": "https://github.com/pravega/pravega/commit/09e3804a218d2dde53460b1e9f7615ce53e143aa", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-05T17:13:02Z", "type": "commit"}, {"oid": "11daa62619d48b59369586c0aa8444d7df75359e", "url": "https://github.com/pravega/pravega/commit/11daa62619d48b59369586c0aa8444d7df75359e", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-11-05T17:17:05Z", "type": "commit"}, {"oid": "b3f3face185c80142eba6cb5e8b2b45389dc3858", "url": "https://github.com/pravega/pravega/commit/b3f3face185c80142eba6cb5e8b2b45389dc3858", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-11-07T08:08:47Z", "type": "commit"}, {"oid": "0a53fe7cb659b8237adc0b458baa50d87f5200cb", "url": "https://github.com/pravega/pravega/commit/0a53fe7cb659b8237adc0b458baa50d87f5200cb", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-07T09:36:00Z", "type": "commit"}, {"oid": "9b4cc6a164842869b18986323660cb5b44f9fccc", "url": "https://github.com/pravega/pravega/commit/9b4cc6a164842869b18986323660cb5b44f9fccc", "message": "Update access operation\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-08T15:07:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0NTU0Ng==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519545546", "bodyText": "Does this imply that the older client talking to the newer controller server would get default permissions?", "author": "shrids", "createdAt": "2020-11-09T04:23:34Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import com.google.common.base.Strings;\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(@NonNull AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else if (accessOperation.equals(AccessOperation.NONE)) {\n+            return AuthHandler.Permissions.NONE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate access operation \" + accessOperation.name());\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (Strings.isNullOrEmpty(accessOperationStr)) {\n+            return defaultPermissions;", "originalCommit": "9b4cc6a164842869b18986323660cb5b44f9fccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0ODIxMw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519548213", "bodyText": "The way we use this is as follows:\n\nIf the client is an old one, it doesn\u2019t set requested permission, so the server authorized the client for permissions used earlier.\nIf the client is a new one, and doesn\u2019t specify a specific permission as requested permission, we use the default permission. Otherwise, we use the requested permissions.\n\nHope that clarifies.", "author": "ravisharda", "createdAt": "2020-11-09T04:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0NTU0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0ODU5MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r519548591", "bodyText": "Thanks @ravisharda", "author": "shrids", "createdAt": "2020-11-09T04:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0NTU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMDYxNQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520020615", "bodyText": "This conflicts with the fact that / is used a separator between scope and stream.\nWhere is this used?", "author": "tkaitchuck", "createdAt": "2020-11-09T18:18:05Z", "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -34,6 +34,9 @@\n     // The prefix which has to be appended to streams created internally for readerGroups.\n     public static final String READER_GROUP_STREAM_PREFIX = INTERNAL_NAME_PREFIX + \"RG\";\n \n+    // The string which may be used to identify whether a segment is part of an internal stream.\n+    public static final String INTERNAL_STREAM_IDENTIFYING_PATTERN = \"/\" + INTERNAL_NAME_PREFIX;", "originalCommit": "9b4cc6a164842869b18986323660cb5b44f9fccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ4NTU5NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r520485595", "bodyText": "This happened to be unused code after some of the recent changes. I've removed it now in the latest commit I just pushed.", "author": "ravisharda", "createdAt": "2020-11-10T11:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMDYxNQ=="}], "type": "inlineReview"}, {"oid": "10e1c2739255ebcef96aa59285d66e19cf89aaf2", "url": "https://github.com/pravega/pravega/commit/10e1c2739255ebcef96aa59285d66e19cf89aaf2", "message": "Change datatype of requestedPermission field in StreamInfo protobuf message to enum (from String)\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-10T10:29:09Z", "type": "commit"}, {"oid": "6ba73a05dd381ee6117ecc344cfc2345c9325ebd", "url": "https://github.com/pravega/pravega/commit/6ba73a05dd381ee6117ecc344cfc2345c9325ebd", "message": "Include jjwt in the exclude list for client module.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-10T11:03:13Z", "type": "commit"}, {"oid": "841c2ab26675345b0dd56a61c1fb0a87fb3bcfbb", "url": "https://github.com/pravega/pravega/commit/841c2ab26675345b0dd56a61c1fb0a87fb3bcfbb", "message": "Remove dead code\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-10T11:17:04Z", "type": "commit"}, {"oid": "e79911d98d888ea2891c3439a498b4eb9e766b46", "url": "https://github.com/pravega/pravega/commit/e79911d98d888ea2891c3439a498b4eb9e766b46", "message": "Restrict writes to internal streams with read permissions to reader group streams.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-10T12:58:38Z", "type": "commit"}, {"oid": "73529313335ec6818d8e3c30c2214658b28443dc", "url": "https://github.com/pravega/pravega/commit/73529313335ec6818d8e3c30c2214658b28443dc", "message": "Reduce the scope of 'writes with read permissions' from all types of internal streams to reader group internal streams.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-10T16:44:07Z", "type": "commit"}, {"oid": "ace93a3e80b2169bc6246d807584d01f71010c8d", "url": "https://github.com/pravega/pravega/commit/ace93a3e80b2169bc6246d807584d01f71010c8d", "message": "Prevent clients from fetching delegation tokens containing read_update permissions for mark streams.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-11T12:43:12Z", "type": "commit"}, {"oid": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922", "url": "https://github.com/pravega/pravega/commit/fe8f7f527db3221ecfd39899a7e3281d6ae3b922", "message": "Fix backward compatibility issue and remove inadvertant logging of delegation token\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-11T16:46:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521537284", "bodyText": "This question somewhat depends on the answer of the previous one. Should we more broadly be checking whether a principal is requesting READ_UPDATE authorization on internal + mark streams? Or are we checking it elsewhere?\nAlso, if delegation tokens generated here are also used by the controller, then are we limiting access to mark streams by the controller?", "author": "fpj", "createdAt": "2020-11-11T17:54:34Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {\n+                    final AuthHandler.Permissions authorizationPermission;\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE)) {\n+                        // Clients have no business requesting for delegation tokens with write permissions for\n+                        // mark streams. Clients are allowed to read from a mark stream, but aren't allowed to write to\n+                        // it. (Only Controller writes to it.)\n+                        if (authParams.isMarkStream()) {", "originalCommit": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc2ODUxOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521768518", "bodyText": "...Or are we checking it elsewhere?\n\nWe are checking for external/internal streams via this condition:\n\n  \n    \n      pravega/controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java\n    \n    \n         Line 445\n      in\n      fe8f7f5\n    \n    \n    \n    \n\n        \n          \n           if (authParams.isStreamUserDefined()) { \n        \n    \n  \n\n\nAccordingly, line 470 is hit only if the stream is an internal stream.\n\nAlso, if delegation tokens generated here are also used by the controller, then are we limiting access to mark streams by the controller?\n\nThe Controller obtains the delegation token via the LocalController (a client class), which doesn't make the gRPC call, but rather invokes a local call:\n\n  \n    \n      pravega/controller/src/main/java/io/pravega/controller/server/eventProcessor/LocalController.java\n    \n    \n         Line 521\n      in\n      fe8f7f5\n    \n    \n    \n    \n\n        \n          \n           public CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName, AccessOperation accessOperation) {", "author": "ravisharda", "createdAt": "2020-11-12T01:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyNjcwOQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522426709", "bodyText": "Ok, I understand that the controller gets its delegation tokens elsewhere. On mark streams, given that we are saying that internal streams might be accessed by external clients for debug/administration, this is the behavior I'd expect:\n1- If a client is requesting permission to READ_UPDATE a stream S, then it will not get automatically permission to READ_UPDATE the corresponding mark stream of S.\n2- If a client is requesting READ_UPDATE access to a mark stream explicitly, say for debugging/administration purposes like with other internal streams, then it authorizes the access in the case the access configuration allows it.\nI'm not sure we are making a distinction between these two scenarios, and I'm trying to make sure that we are not blocking access to mark streams for say admin tools while access to other internal streams is authorized.", "author": "fpj", "createdAt": "2020-11-12T21:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY1OTc4MA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522659780", "bodyText": "1- If a client is requesting permission to READ_UPDATE a stream S, then it will not get automatically permission to READ_UPDATE the corresponding mark stream of S.\n\nThat is true. We only return a delegation token for the resource (stream, etc.) that the client has explicitly requested it for.\nClients are now blocked by the server from getting a delegation token with READ_UPDATE for a mark stream. This means, if a client requests a token for a markstream with READ_UPDATE, they will encounter an error.\n\n2- If a client is requesting READ_UPDATE access to a mark stream explicitly, say for debugging/administration purposes like with other internal streams, then it authorizes the access in the case the access configuration allows it.\n\nClients are allowed to obtain a delegation token with READ on a mark stream, but not READ_UPDATE (which will be blocked). Since we definitively know clients have no business requesting for READ_UPDATE to a mark-stream, we'd rather block it right now and open it up later if and when the need arises.", "author": "ravisharda", "createdAt": "2020-11-13T05:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc1Mjk0Nw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522752947", "bodyText": "It is correct that regular clients have no business writing to a mark stream, I'm +1 for not grating READ_UPDATE access like that.\nI'm concerned that we might not be doing it for internal streams consistently, which might be necessary for administration/recovery purposes. This is not a case of a regular user trying to append to/read from a stream, but an administrator trying to understand or fix a problem. In such cases, is it a possibility that the administrator might need to have READ_UPDATE access to one or more mark streams?", "author": "fpj", "createdAt": "2020-11-13T07:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3MzQyNg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522873426", "bodyText": "In this PR, I\u2019ve changed how delegation tokens are authorized for mark streams (they now require access on the corresponding streams), so based on a previous discussion that mark streams are not writable by clients, I\u2019ve blocked writes to them. In the future if the need arises for clients to write to them, we can enable that with due consideration.", "author": "ravisharda", "createdAt": "2020-11-13T10:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3NDA3Mg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522874072", "bodyText": "I don\u2019t want to make such a change for all internal streams, as that\u2019s be a much broader change, and something that\u2019s out of scope of this PR.", "author": "ravisharda", "createdAt": "2020-11-13T10:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg3NzM1OA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522877358", "bodyText": "Yes, we should first classify the internal streams into three categories -\n\ninternal streams created for fulfilling a user function and users have full control over it (e.g. reader group streams).\ninternal stream created for fulfilling a user function but users dont have write access to it (e.g. mark stream).\ninternal streams that controller process creates for its own purposes. users have no business looking at or doing anything to do with these streams.\n\nFirst and second streams are already covered by these changes as a special case.\nFor third, we should not prevent READ_UPDATE requests on authorization. this is because segment store also posts events into them. And admin tool may also require READ_UPDATE to allow them to post events to initiate some work to remedy some bad state in the system.", "author": "shiveshr", "createdAt": "2020-11-13T10:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg5ODM1MA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522898350", "bodyText": "Would it make sense to create an issue to define and implement an authorization model for internal streams?", "author": "fpj", "createdAt": "2020-11-13T11:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzNzkxMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522937910", "bodyText": "Yes, I will do so later.", "author": "ravisharda", "createdAt": "2020-11-13T13:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQzNTY1MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r523435651", "bodyText": "An issue to capture the open item we discussed last.\n#5332", "author": "fpj", "createdAt": "2020-11-14T16:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzNzI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521626538", "bodyText": "This else block starting at line 464 is about internal streams. Are the tokens produced here both for the use of application clients and the controller? For application clients, is there a case in which we want to authorize them to read from internal streams that are not mark streams,(e.g., streams the controller use with its workflows)? Is it for some debug or recovery scenario?", "author": "fpj", "createdAt": "2020-11-11T20:42:21Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -343,23 +360,136 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n                 delegationToken -> controllerService.deleteStream(request.getScope(), request.getStream()), responseObserver, requestTag);\n     }\n \n+    private AccessOperation translate(@NonNull StreamInfo.AccessOperation accessOperation) {\n+        return AccessOperation.valueOf(accessOperation.name());\n+    }\n+\n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested = !request.getAccessOperation().equals(StreamInfo.AccessOperation.NONE);\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    translate(request.getAccessOperation()), this.isRGStreamWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isAccessOperationUnspecified()) {\n+                // For backward compatibility: Older clients will not send access operation in the request.\n+                log.debug(\"Access operation was unspecified for request with scope {} and stream {}\",\n+                        request.getScope(), request.getStream());\n+\n+                final AuthHandler.Permissions authAndTokenPermission;\n+                if (authParams.isMarkStream()) {\n+                    // Clients are allowed to read from a mark stream, but aren't allowed to write to it. Since the\n+                    // client didn't specify the access operation, we assume here that it intends to read from it.\n+                    authAndTokenPermission = AuthHandler.Permissions.READ;\n+                } else {\n+                    authAndTokenPermission = AuthHandler.Permissions.READ_UPDATE;\n+                }\n+                this.grpcAuthHelper.checkAuthorization(resource, authAndTokenPermission);\n+                return this.grpcAuthHelper.createDelegationToken(streamResource, authAndTokenPermission);\n+            } else {\n+                log.trace(\"Access operation was {} for request with scope {} and stream {}\",\n+                        translate(request.getAccessOperation()), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);\n+\n+                        // Here, we check whether the user is authorized for the requested access.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    }\n+                } else {", "originalCommit": "fe8f7f527db3221ecfd39899a7e3281d6ae3b922", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc2OTM1NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521769354", "bodyText": "... Are the tokens produced here both for the use of application clients and the controller?\n\nNo, only application clients making the gRPC call will arrive here. The Controller itself uses LocalController as I mentioned in the previous comment.", "author": "ravisharda", "createdAt": "2020-11-12T01:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3MDQ0Nw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r521770447", "bodyText": "For application clients, is there a case in which we want to authorize them to read from internal streams that are not mark streams,(e.g., streams the controller use with its workflows)? Is it for some debug or recovery scenario?\n\nThe reader group stream is an example of internal stream that application clients may access (usually via the client library). For mark streams, I've now blocked any request for delegation tokens with READ_UPDATE permission, but allow READ.\nI don't know the answer for other types of internal streams, but the older code allowed a gRPC client to obtain delegation tokens for any external or internal stream, provided the user was authorized for READ_UPDATE.\nDoes that answer your question?", "author": "ravisharda", "createdAt": "2020-11-12T02:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxNTcyMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522415720", "bodyText": "Sure, it makes sense to authorize read and write access for say debug/administration/recovery purposes.", "author": "fpj", "createdAt": "2020-11-12T20:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU4Nzk0NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r522587944", "bodyText": "Yes, that's right.", "author": "ravisharda", "createdAt": "2020-11-13T03:16:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNjUzOA=="}], "type": "inlineReview"}, {"oid": "1ab612c31adc9a6d870bf7c6894f4044c4179437", "url": "https://github.com/pravega/pravega/commit/1ab612c31adc9a6d870bf7c6894f4044c4179437", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-11-13T03:16:06Z", "type": "commit"}, {"oid": "f920058591b78dc7efafc56bdca1059a5b70c810", "url": "https://github.com/pravega/pravega/commit/f920058591b78dc7efafc56bdca1059a5b70c810", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-11-14T01:54:48Z", "type": "commit"}, {"oid": "df74633b134444482a4db2cbbd52153918fa2453", "url": "https://github.com/pravega/pravega/commit/df74633b134444482a4db2cbbd52153918fa2453", "message": "Refactor PasswordAuthHandler for unit testing\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-07-27T10:37:08Z", "type": "commit"}, {"oid": "e9036ad8f7d3d5a5d695306096317355b66eea3a", "url": "https://github.com/pravega/pravega/commit/e9036ad8f7d3d5a5d695306096317355b66eea3a", "message": "Add unit tests for PasswordAuthHandler\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-07-27T10:37:37Z", "type": "commit"}, {"oid": "854d652dc4c73de8d11d1290d53d5916bd044711", "url": "https://github.com/pravega/pravega/commit/854d652dc4c73de8d11d1290d53d5916bd044711", "message": "Add initial set of authorization-related tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-07-27T11:24:42Z", "type": "commit"}, {"oid": "7afb4ac3b243eb0b6c6c031e279d54ac80f4f058", "url": "https://github.com/pravega/pravega/commit/7afb4ac3b243eb0b6c6c031e279d54ac80f4f058", "message": "Refactoring and reorganization of Handler code\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-04T05:56:38Z", "type": "commit"}, {"oid": "77f0f0fbb45612e5c4a0c12be3a99df1f3e9ada2", "url": "https://github.com/pravega/pravega/commit/77f0f0fbb45612e5c4a0c12be3a99df1f3e9ada2", "message": "Refactoring and reorganization\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-05T03:00:43Z", "type": "commit"}, {"oid": "ee4d55a3632383bd0e8db92d2b876271e0815e75", "url": "https://github.com/pravega/pravega/commit/ee4d55a3632383bd0e8db92d2b876271e0815e75", "message": "Save partial work\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-05T10:18:04Z", "type": "commit"}, {"oid": "195becc1608d80b07ae2aabf7b926bf574194a33", "url": "https://github.com/pravega/pravega/commit/195becc1608d80b07ae2aabf7b926bf574194a33", "message": "Remove support for old format in Auth Handler\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-06T10:49:55Z", "type": "commit"}, {"oid": "4c32f1c94ea4259526cbae0b859caba520cda83c", "url": "https://github.com/pravega/pravega/commit/4c32f1c94ea4259526cbae0b859caba520cda83c", "message": "Finish up new ACL implmenetation and tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-07T08:34:11Z", "type": "commit"}, {"oid": "82284afff3044a9ed791891213cef0b34de8e83a", "url": "https://github.com/pravega/pravega/commit/82284afff3044a9ed791891213cef0b34de8e83a", "message": "Update Controller API tests to use new ACL format\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-07T09:10:48Z", "type": "commit"}, {"oid": "2a74dc5050a3cd3569214a6aaa622c89fccefd3b", "url": "https://github.com/pravega/pravega/commit/2a74dc5050a3cd3569214a6aaa622c89fccefd3b", "message": "Fix for tests and a bug in TestAuthhandler service config\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-10T04:08:29Z", "type": "commit"}, {"oid": "dfba3a80baeb2df930e05d34f5a0bdfd3d4eb581", "url": "https://github.com/pravega/pravega/commit/dfba3a80baeb2df930e05d34f5a0bdfd3d4eb581", "message": "Fix Auth manager tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-10T08:43:09Z", "type": "commit"}, {"oid": "3fd4e727cf05edf44d3877c7a16c2282f96e2223", "url": "https://github.com/pravega/pravega/commit/3fd4e727cf05edf44d3877c7a16c2282f96e2223", "message": "Use structured utility method to compose an auth file entry\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-10T08:53:42Z", "type": "commit"}, {"oid": "bcd6c4a25f8070bd9406765bf93f00d5b37c0698", "url": "https://github.com/pravega/pravega/commit/bcd6c4a25f8070bd9406765bf93f00d5b37c0698", "message": "Merge branch 'master' into auth-resources-permissions\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-10T10:48:04Z", "type": "commit"}, {"oid": "8d1a69534502e32b62778b39ed2961cc558e076c", "url": "https://github.com/pravega/pravega/commit/8d1a69534502e32b62778b39ed2961cc558e076c", "message": "Fix compilation issues after merge\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-11T04:33:25Z", "type": "commit"}, {"oid": "7217a5d504041f7d3e4d5d5657983cefef06eb33", "url": "https://github.com/pravega/pravega/commit/7217a5d504041f7d3e4d5d5657983cefef06eb33", "message": "Modify claimKey to match Segment Store format\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-12T01:26:55Z", "type": "commit"}, {"oid": "ab1b9e67d62d420ca7fbf3ba368dd68217c4b9a5", "url": "https://github.com/pravega/pravega/commit/ab1b9e67d62d420ca7fbf3ba368dd68217c4b9a5", "message": "Revert standalone mode config\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-12T01:27:27Z", "type": "commit"}, {"oid": "e64317b94f2b9c90d7fb6d4fdede50d06522bc2f", "url": "https://github.com/pravega/pravega/commit/e64317b94f2b9c90d7fb6d4fdede50d06522bc2f", "message": "Modify remaining test classes to use new resource format\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-12T03:23:27Z", "type": "commit"}, {"oid": "b8dbfc683ed78b4c1104a06078a04402a159f8dd", "url": "https://github.com/pravega/pravega/commit/b8dbfc683ed78b4c1104a06078a04402a159f8dd", "message": "Modify remaining test classes to use new resource format\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-12T04:43:44Z", "type": "commit"}, {"oid": "ee2ff0ef331b55d718f8378f135328ad5ac942b4", "url": "https://github.com/pravega/pravega/commit/ee2ff0ef331b55d718f8378f135328ad5ac942b4", "message": "Cleanup and add tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-12T09:57:19Z", "type": "commit"}, {"oid": "a000a66776c32c3e475cfd7671eca45a1fbb5b69", "url": "https://github.com/pravega/pravega/commit/a000a66776c32c3e475cfd7671eca45a1fbb5b69", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-08-14T09:13:04Z", "type": "commit"}, {"oid": "4e2196ae352b37497b658da5cc725918172aa82f", "url": "https://github.com/pravega/pravega/commit/4e2196ae352b37497b658da5cc725918172aa82f", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-08-17T02:11:14Z", "type": "commit"}, {"oid": "a459ca0275089b845832c1aac7460f9241ed1462", "url": "https://github.com/pravega/pravega/commit/a459ca0275089b845832c1aac7460f9241ed1462", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-17T08:13:55Z", "type": "commit"}, {"oid": "63b6c65df46adc77db50e1d6da80799adb8a503a", "url": "https://github.com/pravega/pravega/commit/63b6c65df46adc77db50e1d6da80799adb8a503a", "message": "Merge remote-tracking branch 'origin/auth-resources-permissions' into auth-resources-permissions", "committedDate": "2020-08-17T08:15:12Z", "type": "commit"}, {"oid": "060e8d6546291991fc7b6d66970687de9f25cfd3", "url": "https://github.com/pravega/pravega/commit/060e8d6546291991fc7b6d66970687de9f25cfd3", "message": "Push replacement of `*` with `.*` in resource patterns from authorization time to ACE construction time\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-18T02:40:58Z", "type": "commit"}, {"oid": "97d507b9b025950730d0fd61a05d25e793b65207", "url": "https://github.com/pravega/pravega/commit/97d507b9b025950730d0fd61a05d25e793b65207", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-08-19T03:34:49Z", "type": "commit"}, {"oid": "095cfed037b8bef930c5d8dc939bc495de4623c5", "url": "https://github.com/pravega/pravega/commit/095cfed037b8bef930c5d8dc939bc495de4623c5", "message": "Optimize resource parts replacement\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-19T06:06:50Z", "type": "commit"}, {"oid": "1a12909f647b3af7c6759d4560211165b38a3c8b", "url": "https://github.com/pravega/pravega/commit/1a12909f647b3af7c6759d4560211165b38a3c8b", "message": "Merge remote-tracking branch 'origin/auth-resources-permissions' into auth-resources-permissions", "committedDate": "2020-08-19T06:27:03Z", "type": "commit"}, {"oid": "436cfc6991f01911098c1f2860b620734d5f65af", "url": "https://github.com/pravega/pravega/commit/436cfc6991f01911098c1f2860b620734d5f65af", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-08-21T04:50:41Z", "type": "commit"}, {"oid": "d6f00e86ff45a164bac6615c23c5091ddc43bde9", "url": "https://github.com/pravega/pravega/commit/d6f00e86ff45a164bac6615c23c5091ddc43bde9", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-08-26T15:28:04Z", "type": "commit"}, {"oid": "a1051184bd9337e3f27d10f3a4a551a4c1fa0cb8", "url": "https://github.com/pravega/pravega/commit/a1051184bd9337e3f27d10f3a4a551a4c1fa0cb8", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-27T10:09:10Z", "type": "commit"}, {"oid": "f432d3f5b2890a47bfd4ac57c58a39583639f839", "url": "https://github.com/pravega/pravega/commit/f432d3f5b2890a47bfd4ac57c58a39583639f839", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-08-31T03:42:26Z", "type": "commit"}, {"oid": "3d8e0a328341add09a24fd4a64e00106ceeac86d", "url": "https://github.com/pravega/pravega/commit/3d8e0a328341add09a24fd4a64e00106ceeac86d", "message": "Add a test\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-08-31T04:14:57Z", "type": "commit"}, {"oid": "3b0c21aa111a30eb4a156be484e502db13108363", "url": "https://github.com/pravega/pravega/commit/3b0c21aa111a30eb4a156be484e502db13108363", "message": "Initial changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-01T11:03:08Z", "type": "commit"}, {"oid": "e85e2852eb4b67ad9a604597def02fa3d2f3d0f0", "url": "https://github.com/pravega/pravega/commit/e85e2852eb4b67ad9a604597def02fa3d2f3d0f0", "message": "Add a test\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-01T12:17:35Z", "type": "commit"}, {"oid": "fcc6f35ff16b9fb62e3ecaa4c7cf7b00b6bf7353", "url": "https://github.com/pravega/pravega/commit/fcc6f35ff16b9fb62e3ecaa4c7cf7b00b6bf7353", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-02T05:46:27Z", "type": "commit"}, {"oid": "7d452e3a562c0672ce9ead5d8f2aa5615c549a16", "url": "https://github.com/pravega/pravega/commit/7d452e3a562c0672ce9ead5d8f2aa5615c549a16", "message": "Add a test\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-02T06:49:22Z", "type": "commit"}, {"oid": "7bb8e0f7d24a47e934271349f8d69a61017216f9", "url": "https://github.com/pravega/pravega/commit/7bb8e0f7d24a47e934271349f8d69a61017216f9", "message": "Save temporary work\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-02T06:51:15Z", "type": "commit"}, {"oid": "9f868b5acf8b7c5462ac5092c9fe3ef32a36f1b5", "url": "https://github.com/pravega/pravega/commit/9f868b5acf8b7c5462ac5092c9fe3ef32a36f1b5", "message": "Changes to fix compilation issues after merge from master\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-02T08:15:54Z", "type": "commit"}, {"oid": "3b9fbb2112859db5ee7af866195bec6ed0eacf89", "url": "https://github.com/pravega/pravega/commit/3b9fbb2112859db5ee7af866195bec6ed0eacf89", "message": "Merge remote-tracking branch 'origin/auth-resources-permissions' into issue-5115-reads-using-read-permissions", "committedDate": "2020-09-02T09:23:11Z", "type": "commit"}, {"oid": "dd5b809233b14d0735d58fd0c04a5f831f2405ca", "url": "https://github.com/pravega/pravega/commit/dd5b809233b14d0735d58fd0c04a5f831f2405ca", "message": "Save intermediate changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-02T10:07:30Z", "type": "commit"}, {"oid": "f053512c0254879d25e866a2917344c7f3c995cc", "url": "https://github.com/pravega/pravega/commit/f053512c0254879d25e866a2917344c7f3c995cc", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-04T03:34:56Z", "type": "commit"}, {"oid": "22d0368582a8a1af06280f78aae24c4b8ff63498", "url": "https://github.com/pravega/pravega/commit/22d0368582a8a1af06280f78aae24c4b8ff63498", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-08T09:46:28Z", "type": "commit"}, {"oid": "cc25cd9f06ce657f73e40bb535395cdeff55ce1c", "url": "https://github.com/pravega/pravega/commit/cc25cd9f06ce657f73e40bb535395cdeff55ce1c", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-09T07:18:04Z", "type": "commit"}, {"oid": "88be4769834ebaedd19446d31cfee7764f26afeb", "url": "https://github.com/pravega/pravega/commit/88be4769834ebaedd19446d31cfee7764f26afeb", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-09T07:58:24Z", "type": "commit"}, {"oid": "c0086b5173f6b624e9a3d55d98d7bd23440c3d93", "url": "https://github.com/pravega/pravega/commit/c0086b5173f6b624e9a3d55d98d7bd23440c3d93", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-10T03:54:33Z", "type": "commit"}, {"oid": "a195a3244b8ad8a0f5bbe8ec57439ad610b19145", "url": "https://github.com/pravega/pravega/commit/a195a3244b8ad8a0f5bbe8ec57439ad610b19145", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-11T04:49:52Z", "type": "commit"}, {"oid": "0942c4ba4e056b81136c4cecda07d3dcd4c5307f", "url": "https://github.com/pravega/pravega/commit/0942c4ba4e056b81136c4cecda07d3dcd4c5307f", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-11T04:50:13Z", "type": "commit"}, {"oid": "72b8f820f8e15f542949055eeb0c67cc14cd3236", "url": "https://github.com/pravega/pravega/commit/72b8f820f8e15f542949055eeb0c67cc14cd3236", "message": "Merge branch 'master' into auth-resources-permissions", "committedDate": "2020-09-11T10:35:59Z", "type": "commit"}, {"oid": "d13674fdd66b9e954abc9d574d0d0132b363ef89", "url": "https://github.com/pravega/pravega/commit/d13674fdd66b9e954abc9d574d0d0132b363ef89", "message": "Save intermediate changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-14T09:46:28Z", "type": "commit"}, {"oid": "c2754590d501bf045c4ca7c5a3c164785a889530", "url": "https://github.com/pravega/pravega/commit/c2754590d501bf045c4ca7c5a3c164785a889530", "message": "Merge branch 'auth-resources-permissions' of https://github.com/ravisharda/pravega into issue-5115-reads-using-read-permissions\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-14T09:52:05Z", "type": "commit"}, {"oid": "5239db13c33ca150c6e0265ae0b79d7935dc1b1c", "url": "https://github.com/pravega/pravega/commit/5239db13c33ca150c6e0265ae0b79d7935dc1b1c", "message": "Specify access operation for client calls to fetch delegation token\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-16T05:35:27Z", "type": "commit"}, {"oid": "ca54e60caab53f650f36cd29ff86b51f8d1ff54b", "url": "https://github.com/pravega/pravega/commit/ca54e60caab53f650f36cd29ff86b51f8d1ff54b", "message": "Prevent NPE\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-16T07:50:23Z", "type": "commit"}, {"oid": "027c415b8398ecab0eeeb2b3a0ede1c47fd067c9", "url": "https://github.com/pravega/pravega/commit/027c415b8398ecab0eeeb2b3a0ede1c47fd067c9", "message": "Merge remote-tracking branch 'origin/master' into issue-5115-reads-using-read-permissions\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-16T15:56:15Z", "type": "commit"}, {"oid": "7a3a0cab81f605197b49a0e377919c5eb68ff803", "url": "https://github.com/pravega/pravega/commit/7a3a0cab81f605197b49a0e377919c5eb68ff803", "message": "Fix fallouts from merge with master\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-17T04:03:20Z", "type": "commit"}, {"oid": "68d94affe427d304acdbb7ef9bc428e768913360", "url": "https://github.com/pravega/pravega/commit/68d94affe427d304acdbb7ef9bc428e768913360", "message": "Merge remote-tracking branch 'origin/master' into issue-5115-reads-using-read-permissions\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-09-30T15:55:54Z", "type": "commit"}, {"oid": "8f1c686d0a296b6f3fadb7c3e01e690da04f1212", "url": "https://github.com/pravega/pravega/commit/8f1c686d0a296b6f3fadb7c3e01e690da04f1212", "message": "Merge remote-tracking branch 'origin/master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-05T04:26:10Z", "type": "commit"}, {"oid": "05a2d1a768eec07553607f4a3233439927682fa7", "url": "https://github.com/pravega/pravega/commit/05a2d1a768eec07553607f4a3233439927682fa7", "message": "Have shared:security project use the same version of Java as client due to client's dependency on it.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-05T07:34:41Z", "type": "commit"}, {"oid": "8e7dce21927e0efdbb77850565cf8e644a8fd989", "url": "https://github.com/pravega/pravega/commit/8e7dce21927e0efdbb77850565cf8e644a8fd989", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-06T01:48:01Z", "type": "commit"}, {"oid": "d70b2212cc66295fd7374a51e108e4879953048b", "url": "https://github.com/pravega/pravega/commit/d70b2212cc66295fd7374a51e108e4879953048b", "message": "Introduce a Controller config for determining whether to allow writes to internal streams with read permissions.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-06T05:28:41Z", "type": "commit"}, {"oid": "d56f6aeff5094f3359615e84196506037c0b9873", "url": "https://github.com/pravega/pravega/commit/d56f6aeff5094f3359615e84196506037c0b9873", "message": "Save changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-06T07:47:30Z", "type": "commit"}, {"oid": "6f54f55e23cbd12fc4d8ac16b74e06ecff22275c", "url": "https://github.com/pravega/pravega/commit/6f54f55e23cbd12fc4d8ac16b74e06ecff22275c", "message": "Add a test and fix a bug\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-06T08:10:21Z", "type": "commit"}, {"oid": "313a924a7d6b314dd52e12548fc4ffa527ff66eb", "url": "https://github.com/pravega/pravega/commit/313a924a7d6b314dd52e12548fc4ffa527ff66eb", "message": "save changes\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-08T07:45:32Z", "type": "commit"}, {"oid": "ea6a079e50ede528963f9c781f5c7eeb66c961bf", "url": "https://github.com/pravega/pravega/commit/ea6a079e50ede528963f9c781f5c7eeb66c961bf", "message": "Send internal streams as streams to segment store\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-08T08:32:53Z", "type": "commit"}, {"oid": "088f181f607a634c0b98c26e9db0b851b56a1c02", "url": "https://github.com/pravega/pravega/commit/088f181f607a634c0b98c26e9db0b851b56a1c02", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-08T08:33:21Z", "type": "commit"}, {"oid": "5a803f28f4d1a05cef096633196ea4bfe8e6dff2", "url": "https://github.com/pravega/pravega/commit/5a803f28f4d1a05cef096633196ea4bfe8e6dff2", "message": "Clean up\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-08T10:54:00Z", "type": "commit"}, {"oid": "45584b7ad82830fc7dda10229fc138c3a9d8de48", "url": "https://github.com/pravega/pravega/commit/45584b7ad82830fc7dda10229fc138c3a9d8de48", "message": "More clean-up and new tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-08T17:49:14Z", "type": "commit"}, {"oid": "74b0702fc9972dfc31321132a8f581a660ff16bf", "url": "https://github.com/pravega/pravega/commit/74b0702fc9972dfc31321132a8f581a660ff16bf", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-09T02:36:31Z", "type": "commit"}, {"oid": "61f2d9b3c05b964eb42d580f556b90fe473f8cbf", "url": "https://github.com/pravega/pravega/commit/61f2d9b3c05b964eb42d580f556b90fe473f8cbf", "message": "More clean-up and new tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-09T11:03:44Z", "type": "commit"}, {"oid": "72db233d421293ccb9bbb1861588063d9be63cd6", "url": "https://github.com/pravega/pravega/commit/72db233d421293ccb9bbb1861588063d9be63cd6", "message": "Fix a bug\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-12T03:31:21Z", "type": "commit"}, {"oid": "226d1202b8d78fccbc12239e1b38253e52402d63", "url": "https://github.com/pravega/pravega/commit/226d1202b8d78fccbc12239e1b38253e52402d63", "message": "Add tests and cleanup\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-12T05:55:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjMzMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504806331", "bodyText": "Formatting: This can fit on one line.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:16:53Z", "path": "client/src/main/java/io/pravega/client/control/impl/Controller.java", "diffHunk": "@@ -369,13 +371,15 @@\n     void close();\n \n     /**\n-     * Refreshes an expired/non-existent delegation token.\n+     * Obtains a delegation token from the server.\n      *\n-     * @param scope      Scope of the stream.\n+     * @param scope Scope of the stream.\n      * @param streamName Name of the stream.\n+     * @param accessOperation The requested permission.\n      * @return The delegation token for the given stream.\n      */\n-    CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName);\n+    CompletableFuture<String> getOrRefreshDelegationTokenFor(String scope, String streamName,", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxMTE1NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506311154", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-10-16T11:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjUwMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504806501", "bodyText": "Formatting: Revert indentation.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:17:06Z", "path": "client/src/main/java/io/pravega/client/control/impl/ControllerImpl.java", "diffHunk": "@@ -1254,7 +1254,7 @@ private void closeChannel() {\n         final CompletableFuture<DelegationToken> result = this.retryConfig.runAsync(() -> {\n             RPCAsyncCallback<DelegationToken> callback = new RPCAsyncCallback<>(traceId, \"getOrRefreshDelegationTokenFor\", scope, streamName);\n             client.withDeadlineAfter(timeoutMillis, TimeUnit.MILLISECONDS)\n-                  .getDelegationToken(ModelHelper.createStreamInfo(scope, streamName), callback);\n+                    .getDelegationToken(ModelHelper.createStreamInfo(scope, streamName, accessOperation), callback);", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxMzI4NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506313285", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-10-16T11:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjk1NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504806954", "bodyText": "Can you have the other method you overloaded call into this one?", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:17:51Z", "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -377,6 +379,17 @@ public static final NodeUri decode(final PravegaNodeUri uri) {\n         return Controller.ScopeInfo.newBuilder().setScope(scope).build();\n     }\n \n+    public static final StreamInfo createStreamInfo(final String scope, final String stream,", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxMzUxNQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506313515", "bodyText": "Yeah, that makes sense. Changed it.", "author": "ravisharda", "createdAt": "2020-10-16T11:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwNjk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwODY3MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504808671", "bodyText": "Undo or remove commented out code.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:20:28Z", "path": "client/src/main/java/io/pravega/client/stream/impl/SegmentSelector.java", "diffHunk": "@@ -188,7 +188,7 @@ void removeSegmentWriter(Segment segment) {\n     }\n \n     private void createMissingWriters(Consumer<Segment> segmentSealedCallBack) {\n-        tokenProvider.populateToken(currentSegments.getDelegationToken());\n+        // tokenProvider.populateToken(currentSegments.getDelegationToken());", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDEzNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314137", "bodyText": "Removed.", "author": "ravisharda", "createdAt": "2020-10-16T11:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwODY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504809179", "bodyText": "This isn't so simple. KeyValueTable clients can be used for both reading or writing. What if someone just wants to read from KVTs?", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:21:14Z", "path": "client/src/main/java/io/pravega/client/tables/impl/KeyValueTableFactoryImpl.java", "diffHunk": "@@ -38,7 +39,7 @@\n             @NonNull String keyValueTableName, @NonNull Serializer<KeyT> keySerializer,\n             @NonNull Serializer<ValueT> valueSerializer, @NonNull KeyValueTableClientConfiguration clientConfiguration) {\n         val kvt = new KeyValueTableInfo(this.scope, keyValueTableName);\n-        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName());\n+        val provider = DelegationTokenProviderFactory.create(this.controller, kvt.getScope(), kvt.getKeyValueTableName(), AccessOperation.WRITE);", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc3MTA4Mw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510771083", "bodyText": "@andreipaduroiu how do you suggest we handle this?\nOne possibility I see is to let the caller specify the intended access operation (READ, WRITE, or READ_WRITE). If left unspecified, default it to READ_WRITE (both read and WRITE)?\nAlternatively, we could leave it as-is and enhance it later when we support distinguishing write-only from read_write. As of now, both WRITE and READ_WRITE  are interpreted as READ_UPDATE (both reads and writes) on the server-side.\n\n  \n    \n      pravega/shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java\n    \n    \n        Lines 30 to 31\n      in\n      6d27990\n    \n    \n    \n    \n\n        \n          \n           } else if (accessOperation.equals(AccessOperation.WRITE) || accessOperation.equals(AccessOperation.READ_WRITE)) { \n        \n\n        \n          \n               return AuthHandler.Permissions.READ_UPDATE;", "author": "ravisharda", "createdAt": "2020-10-23T09:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyODk2Mg==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515828962", "bodyText": "one alternative is -- client requests a read and read_update token lazily.\nfor example, when any \"create/update/remove\" api on kvt is called, if a write token exists, its used, else its explicitly requested.\nsimilarly when a read/iterate api is called on kvt, a read token is requested once and used henceforth.\nif users are unauthorized for updates, their attempts to update the table may fail but they will still be able to read.", "author": "shiveshr", "createdAt": "2020-11-02T09:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzOTY4MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515839681", "bodyText": "I'm not sure what the use case would be, but a generic one would be that one an application A maintains a table that another application B consumes data from. A read-only table would allow a client only to perform gets on an existing table, while read_update would enable it to perform all operations.", "author": "fpj", "createdAt": "2020-11-02T09:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgwOTE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDQ0MA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504810440", "bodyText": "Please use some api in NameUtils. No code outside of that class should hardcoded these special strings.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:23:14Z", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResourceImpl.java", "diffHunk": "@@ -58,10 +60,29 @@ public String ofReaderGroupInScope(String scopeName, String readerGroupName) {\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_READERGROUP, readerGroupName);\n     }\n \n+    @Override\n+    public String ofWatermarkInScope(String scopeName, String watermarkName) {\n+        Exceptions.checkNotNullOrEmpty(scopeName, \"scopeName\");\n+        Exceptions.checkNotNullOrEmpty(watermarkName, \"watermarkName\");\n+        return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_WATERMARK, watermarkName);\n+    }\n+\n     @Override\n     public String ofKeyValueTableInScope(String scopeName, String keyValueTableName) {\n         Exceptions.checkNotNullOrEmpty(scopeName, \"scopeName\");\n         Exceptions.checkNotNullOrEmpty(keyValueTableName, \"keyValueTableName\");\n         return String.format(\"%s/%s:%s\", ofScope(scopeName), TAG_KEYVALUETABLE, keyValueTableName);\n     }\n+\n+    @Override\n+    public String ofInternalStream(String scopeName, @NonNull String streamName) {\n+        // Internal stream names start with either `_RG` (reader groups) or `_MARK` (watermarks).\n+        if (streamName.startsWith(\"_RG\")) {\n+            return ofReaderGroupInScope(scopeName, streamName.replace(\"_RG\", \"\"));", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDQwMw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314403", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-10-16T11:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDgxMw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504810813", "bodyText": "What does this special string mean? Again, consider using NameUtils. If your method is not there, please add it.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:23:51Z", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.security.auth;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.auth.AuthHandler;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A helper class used for processing auth params for streams.\n+ */\n+@Slf4j\n+public class StreamAuthParams {\n+\n+    private static final AuthorizationResource AUTH_RESOURCE = new AuthorizationResourceImpl();\n+\n+    private final String scope;\n+    private final String stream;\n+    private final boolean isInternalWritesWithReadPermEnabled;\n+\n+    @VisibleForTesting\n+    @Getter\n+    private final boolean isInternalStream;\n+\n+    @VisibleForTesting\n+    StreamAuthParams(@NonNull String scope, @NonNull String stream) {\n+        this(scope, stream, true);\n+    }\n+\n+    public StreamAuthParams(@NonNull String scope, @NonNull String stream, boolean isInternalWritesWithReadPermEnabled) {\n+        this.scope = scope;\n+        this.stream = stream;\n+        this.isInternalWritesWithReadPermEnabled = isInternalWritesWithReadPermEnabled;\n+        if (stream.startsWith(\"_\")) {", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDgxNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314817", "bodyText": "Sure, I've modified it to use NameUtils. I wasn't aware of that class. :)", "author": "ravisharda", "createdAt": "2020-10-16T11:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDg5Nw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504810897", "bodyText": "here too", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:23:58Z", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/StreamAuthParams.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.security.auth;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.auth.AuthHandler;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * A helper class used for processing auth params for streams.\n+ */\n+@Slf4j\n+public class StreamAuthParams {\n+\n+    private static final AuthorizationResource AUTH_RESOURCE = new AuthorizationResourceImpl();\n+\n+    private final String scope;\n+    private final String stream;\n+    private final boolean isInternalWritesWithReadPermEnabled;\n+\n+    @VisibleForTesting\n+    @Getter\n+    private final boolean isInternalStream;\n+\n+    @VisibleForTesting\n+    StreamAuthParams(@NonNull String scope, @NonNull String stream) {\n+        this(scope, stream, true);\n+    }\n+\n+    public StreamAuthParams(@NonNull String scope, @NonNull String stream, boolean isInternalWritesWithReadPermEnabled) {\n+        this.scope = scope;\n+        this.stream = stream;\n+        this.isInternalWritesWithReadPermEnabled = isInternalWritesWithReadPermEnabled;\n+        if (stream.startsWith(\"_\")) {\n+            this.isInternalStream = true;\n+        } else {\n+            this.isInternalStream = false;\n+        }\n+    }\n+\n+    public AuthHandler.Permissions requiredPermissionForWrites() {\n+        if (this.isInternalStream) {\n+            if (this.isInternalWritesWithReadPermEnabled) {\n+                return AuthHandler.Permissions.READ;\n+            } else {\n+                return AuthHandler.Permissions.READ_UPDATE;\n+            }\n+        } else {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        }\n+    }\n+\n+    public String resourceString() {\n+        return toResourceString(this.scope, this.stream);\n+    }\n+\n+    public String streamResourceString() {\n+        return AUTH_RESOURCE.ofStreamInScope(scope, stream);\n+    }\n+\n+    private static String toResourceString(String scope, String stream, boolean isStreamInternal) {\n+        return isStreamInternal ? AUTH_RESOURCE.ofInternalStream(scope, stream) :\n+                AUTH_RESOURCE.ofStreamInScope(scope, stream);\n+    }\n+\n+    public static String toResourceString(String scope, String stream) {\n+        return toResourceString(scope, stream, stream.startsWith(\"_\"));", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNDk1Mw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506314953", "bodyText": "Done.", "author": "ravisharda", "createdAt": "2020-10-16T11:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTMwNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504811307", "bodyText": "and here", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:24:38Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java", "diffHunk": "@@ -146,7 +146,7 @@ public void setupAppend(SetupAppend setupAppend) {\n             try {\n                 JsonWebToken token = tokenVerifier.verifyToken(newSegment,\n                         setupAppend.getDelegationToken(),\n-                        AuthHandler.Permissions.READ_UPDATE);\n+                        newSegment.contains(\"/_\") ? AuthHandler.Permissions.READ : AuthHandler.Permissions.READ_UPDATE);", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNTEzNQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506315135", "bodyText": "Fixed.", "author": "ravisharda", "createdAt": "2020-10-16T11:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTk2Ng==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504811966", "bodyText": "Clearly define what the behavior of this is. What is the most restrictive level that this implies?\nConsider documenting the same for the other ones too so that whomever uses these understands what to expect.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:25:38Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+    /**\n+     * Not known.\n+     */\n+    UNKNOWN,\n+\n+    /**\n+     * Any operation.", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNTYzMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506315631", "bodyText": "I've modified the documentation in the class. Please see if it looks better now.", "author": "ravisharda", "createdAt": "2020-10-16T11:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMTk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjE5OA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504812198", "bodyText": "You may want to specify this applies exclusively to KeyValueTables/Table Segments.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:25:57Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/AccessOperation.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+/**\n+ * Represents an operation that is authorized by a permission (allow, deny, etc.). Currently, permissions\n+ * always 'allow' access to specified access operations in Pravega.\n+ */\n+public enum AccessOperation {\n+    /**\n+     * Not known.\n+     */\n+    UNKNOWN,\n+\n+    /**\n+     * Any operation.\n+     */\n+    ANY,\n+\n+    /**\n+     * Represents reads.\n+     */\n+    READ,\n+\n+    /**\n+     * Represents inserts, updates and deletes.\n+     */\n+    WRITE,\n+\n+    /**\n+     * Represents reads and writes (inserts, updates and deletes).", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNjU4NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506316584", "bodyText": "No, they don't apply to exclusively to Key Value Tables/Table segments and are used broadly.", "author": "ravisharda", "createdAt": "2020-10-16T11:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjM5Ng==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504812396", "bodyText": "Include the argument too. IT will help with debugging.", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:26:13Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) ||\n+                accessOperation.equals(AccessOperation.READ_UPDATE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate\");", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNjc4MA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506316780", "bodyText": "Yeah, that was a miss. Fixed.", "author": "ravisharda", "createdAt": "2020-10-16T11:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjUwMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504812501", "bodyText": "Strings.isEmpty?", "author": "andreipaduroiu", "createdAt": "2020-10-14T16:26:25Z", "path": "shared/security/src/main/java/io/pravega/shared/security/auth/PermissionsHelper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.shared.security.auth;\n+\n+import io.pravega.auth.AuthHandler;\n+import lombok.NonNull;\n+\n+/**\n+ * Helper methods for permissions.\n+ */\n+public class PermissionsHelper {\n+\n+    /**\n+     * Translates the specified {@code accessOperation} to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperation accessOperation to translate\n+     * @return a {@link AuthHandler.Permissions} object that represents the specified {@code accessOperation}\n+     */\n+    public static AuthHandler.Permissions toAuthHandlerPermissions(AccessOperation accessOperation) {\n+        if (accessOperation.equals(AccessOperation.READ)) {\n+            return AuthHandler.Permissions.READ;\n+        } else if (accessOperation.equals(AccessOperation.WRITE) ||\n+                accessOperation.equals(AccessOperation.READ_UPDATE)) {\n+            return AuthHandler.Permissions.READ_UPDATE;\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot translate\");\n+        }\n+    }\n+\n+    /**\n+     * Parse the specified {@code accessOperationStr} string and translate it to an {@link AuthHandler.Permissions} object.\n+     *\n+     * @param accessOperationStr a string value of an {@link AccessOperation} object\n+     * @param defaultPermissions the default {@link AuthHandler.Permissions} object to return in case the\n+     *                           {@code accessOperationStr} can't be parsed.\n+     * @return the parsed or default {@link AuthHandler.Permissions} object,\n+     */\n+    public static AuthHandler.Permissions parse(@NonNull String accessOperationStr, AuthHandler.Permissions defaultPermissions) {\n+        if (accessOperationStr.equals(\"\")) {", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNjk3NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506316974", "bodyText": "Sure, I've changed it now.", "author": "ravisharda", "createdAt": "2020-10-16T11:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgxMjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4ODM1MA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504788350", "bodyText": "what is this change for?", "author": "shiveshr", "createdAt": "2020-10-14T15:51:29Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -416,7 +486,7 @@ public void getURI(SegmentId request, StreamObserver<NodeUri> responseObserver)\n         log.info(\"getURI called for segment {}/{}/{}.\", request.getStreamInfo().getScope(),\n                 request.getStreamInfo().getStream(), request.getSegmentId());\n         authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorization(\n-                authorizationResource.ofStreamInScope(request.getStreamInfo().getScope(), request.getStreamInfo().getStream()),\n+                StreamAuthParams.toResourceString(request.getStreamInfo().getScope(), request.getStreamInfo().getStream()),", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU1OTIyNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507559227", "bodyText": "This change is for making sure that the resource string is adapted based on whether the stream is internal/external and the type of resource it represents. All that logic is encapsulated within StreamAuthParams.toResourceString() so that that auth-specific logic doesn't leak into the business logic contained in this code in the Controller Service implementation.", "author": "ravisharda", "createdAt": "2020-10-19T08:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4ODM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4OTE3MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504789171", "bodyText": "why do we need a differentiation here? for example a readergroup's state synchronizer is an internal stream.. but depending on the api being invoked the user may or may not have the authorization permission.. so would rg stream be treated as \"stream\" and \"internal stream\" interchangably depending on the context?", "author": "shiveshr", "createdAt": "2020-10-14T15:52:39Z", "path": "controller/src/main/java/io/pravega/controller/server/security/auth/AuthorizationResource.java", "diffHunk": "@@ -101,4 +113,13 @@\n      * @throws IllegalArgumentException if {@code scopeName} or {@code kvtName} are empty\n      */\n     String ofKeyValueTableInScope(String scopeName, String kvtName);\n+\n+    /**\n+     * Creates a resource representation for use in authorization of actions related to the specified internal stream.\n+     *\n+     * @param scopeName the name of the scope\n+     * @param streamName the name of the internal stream\n+     * @return a string representing the resource\n+     */\n+    String ofInternalStream(String scopeName, String streamName);", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2ODMwNw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507568307", "bodyText": "Firstly, about the differentiation between the internal vs. external streams. The intent is:\n\nTo treat resource groups and watermarks as resources in their own right and distinguish them from regular streams. This is so that users can  be assigned ACLs that authorize them to perform Controller operations on them.\nFor all internal streams, enable write operations with read permissions, provided the config allows for it.\nThis PDP explains the overall context in more detail.\n\nSecondly, for the question below\n\n... would rg stream be treated as \"stream\" and \"internal stream\" interchangeably depending on the context?\n\nNo, the intent is to always authorize a resource the same way across all operations. If the code doesn't do that, it'd be a flaw.\nDoes that answer your question @shiveshr?", "author": "ravisharda", "createdAt": "2020-10-19T08:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc4OTE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MTgwOA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504791808", "bodyText": "if this is set to false can user never make any write operations with read permissions on reader group streams?\nshould we keep this as a service level setting or a per stream setting?", "author": "shiveshr", "createdAt": "2020-10-14T15:56:08Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -101,14 +103,19 @@\n     // Send to the client server traces on error message replies.\n     private final boolean replyWithStackTraceOnError;\n \n+    private final boolean isInternalWritesWithReadPermEnabled;", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU3MzkxMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507573910", "bodyText": "True, the current configuration is broadly applied - all internal streams can be written to with \"read\" permissions if this config is true, otherwise, they'll require \"write\" permissions.\nMaking it tunable at a stream-level can provide more flexibility. However, it could also hurt usability - presumably, users shall have to make another explicit choice and it wouldn't be easy for them to determine what to do. And, they'd have to understand a bit more about internal workings for being able to decide what to do.\nI'd say we should keep the coarse-grained config as of now, and introduce more granular config if need be at a later point. What do you say?", "author": "ravisharda", "createdAt": "2020-10-19T08:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MTgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA3NzIzNQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r511077235", "bodyText": "IMHO, it is really a system wide setting that the admin/operator installing Pravega decides.", "author": "sarlaccpit", "createdAt": "2020-10-23T18:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Mjk1NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504792955", "bodyText": "should we make a special case for internal \"resources\" in this fashion.\ni can understand an rg resource or watermark resource for creation api.. but subsequent to that the clients access these streams for their segmetns using the same get/successor apis which would treat them as \"stream\" resource.\nright?", "author": "shiveshr", "createdAt": "2020-10-14T15:57:37Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU5NDMwMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507594300", "bodyText": "The streamResource represents the resource in a \"stream\", even for reader groups (prn:://scope:myScope/stream:_RGmyApp) and watermarks that we otherwise treat as resources in their own right (like prn:://scope:myScope/reader-group:myApp).\nThe streamResource (like prn:://scope:myScope/stream:_RGmyApp) is what is used in the claims in the delegation token and Segment Store processes it upon appends/reads. However, the Controller uses prn:://scope:myScope/reader-group:myApp  for any authorization. I kept it that way so that the Segment Store doesn't need to perform a lot of translation in the read/write path to account for the differentiation.\nHope that answers your question.", "author": "ravisharda", "createdAt": "2020-10-19T09:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5Mjk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MzYxMQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504793611", "bodyText": "for older clients would request.getRequestedPermission be empty or can it be null?", "author": "shiveshr", "createdAt": "2020-10-14T15:58:30Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")\n+            // and `_MARK` for internal streams. We use the same strings in delegation tokens sent to Segment Store,\n+            // while we use resource tags lie \"reader-group\" (ex: \"prn:://scope:myScope/reader-group:myApp)\n+            // and \"watermark\" for authorization in Controller.\n+            String streamResource = authParams.streamResourceString();\n+\n+            // This is for backward compatibility.\n+            if (request.getRequestedPermission().equals(\"\") && authParams.isStreamUserDefined()) {", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwMTQ5NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r507601495", "bodyText": "I suppose it should be empty, since its a new String based field in the protobuf schema which should take an empty value when the server parses the message coming from an older client that doesn't populate it:\nmessage StreamInfo {\n    string scope = 1;\n    string stream = 2;\n    string requestedPermission = 3;\n}\n\nAccording to https://developers.google.com/protocol-buffers/docs/proto3,\n\n...\nWhen a message is parsed, if the encoded message does not contain a particular singular element, the corresponding field in the parsed object is set to the default value for that field. These defaults are type-specific:\nFor strings, the default value is the empty string.\n...\n\nDoes that make sense?", "author": "ravisharda", "createdAt": "2020-10-19T09:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5MzYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODE0Mw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r504798143", "bodyText": "can defaulting the permission to read have adverse consequence on old clients?", "author": "shiveshr", "createdAt": "2020-10-14T16:05:05Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -295,6 +308,66 @@ public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges>\n                 responseObserver);\n     }\n \n+    private Supplier<String> createDelegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will take on values containing `_RG` (ex: \"prn:://scope:myScope/stream:_RGmyApp\")\n+            // and `_MARK` for internal streams. We use the same strings in delegation tokens sent to Segment Store,\n+            // while we use resource tags lie \"reader-group\" (ex: \"prn:://scope:myScope/reader-group:myApp)\n+            // and \"watermark\" for authorization in Controller.\n+            String streamResource = authParams.streamResourceString();\n+\n+            // This is for backward compatibility.\n+            if (request.getRequestedPermission().equals(\"\") && authParams.isStreamUserDefined()) {\n+                return this.grpcAuthHelper.checkAuthorizationAndCreateToken(streamResource,\n+                        AuthHandler.Permissions.READ);\n+            }\n+\n+            // The resource string that'll be used in the delegation token for use of the segment store\n+            final String tokenResource;\n+\n+            // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+            // will be allowed to perform the specified operation.\n+            final AuthHandler.Permissions tokenPermission;\n+\n+            if (authParams.isStreamUserDefined()) {\n+                // The operation itself requires the caller to possess read permissions.\n+                AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = PermissionsHelper.parse(request.getRequestedPermission(),\n+                        AuthHandler.Permissions.READ);", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcyMzYyNQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510723625", "bodyText": "I've significantly modified the code now. Please take a look at the revised code. Older clients will now be authorized for READ_UPDATE as earlier so that both read and write paths will continue to work despite them not sending requested permission.", "author": "ravisharda", "createdAt": "2020-10-23T08:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5ODE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NDE3NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505154175", "bodyText": "Preconditions.checkNotNull(accessOperation)", "author": "shrids", "createdAt": "2020-10-15T04:17:38Z", "path": "client/src/main/java/io/pravega/client/security/auth/JwtTokenProviderImpl.java", "diffHunk": "@@ -66,13 +70,14 @@\n     @Getter(AccessLevel.PACKAGE)\n     private final AtomicReference<CompletableFuture<Void>> tokenRefreshFuture = new AtomicReference<>();\n \n-    JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName) {\n+    JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName, AccessOperation accessOperation) {\n         this(controllerClient, scopeName, streamName, ConfigurationOptionsExtractor.extractInt(\n-                REFRESH_THRESHOLD_SYSTEM_PROPERTY, REFRESH_THRESHOLD_ENV_VARIABLE, DEFAULT_REFRESH_THRESHOLD_SECONDS));\n+                REFRESH_THRESHOLD_SYSTEM_PROPERTY, REFRESH_THRESHOLD_ENV_VARIABLE, DEFAULT_REFRESH_THRESHOLD_SECONDS),\n+                accessOperation);\n     }\n \n     private JwtTokenProviderImpl(Controller controllerClient, String scopeName, String streamName,\n-                                 int refreshThresholdInSeconds) {\n+                                 int refreshThresholdInSeconds, AccessOperation accessOperation) {", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNzIzMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506317230", "bodyText": "Sure, done.", "author": "ravisharda", "createdAt": "2020-10-16T11:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NDE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NTY2OA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505155668", "bodyText": "This would cause the SegmentOutputStream created by the RevisionedStreamClient to have READ permissions right ?", "author": "shrids", "createdAt": "2020-10-15T04:23:59Z", "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "diffHunk": "@@ -213,9 +214,8 @@ public ClientFactoryImpl(String scope, Controller controller, ConnectionPool con\n     private <T> RevisionedStreamClient<T> createRevisionedStreamClient(Segment segment, Serializer<T> serializer,\n                                                                        SynchronizerConfig config) {\n         EventSegmentReader in = inFactory.createEventReaderForSegment(segment, config.getReadBufferSize());\n-        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),\n-                                                                                                          segment.getStreamName()), RuntimeException::new);\n-        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(delegationToken, controller, segment);\n+        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(controller, segment,\n+                AccessOperation.READ);\n         ConditionalOutputStream cond = condFactory.createConditionalOutputStream(segment, delegationTokenProvider, config.getEventWriterConfig());\n         SegmentMetadataClient meta = metaFactory.createSegmentMetadataClient(segment, delegationTokenProvider);\n         return new RevisionedStreamClientImpl<>(segment, in, outFactory, cond, meta, serializer, config.getEventWriterConfig(), delegationTokenProvider);", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDczMzUwMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510733500", "bodyText": "Yes, that is right. That's no issue though as the segment store shall allow writes to internal streams with READ permissions (for the Controller, a configuration determines whether it is allowed or not):\n\n  \n    \n      pravega/segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/AppendProcessor.java\n    \n    \n         Line 150\n      in\n      2798cba\n    \n    \n    \n    \n\n        \n          \n           newSegment.contains(NameUtils.INTERNAL_STREAM_IDENTIFYING_PATTERN) ?", "author": "ravisharda", "createdAt": "2020-10-23T08:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjM1NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505156355", "bodyText": "SegmentMetadataCLient can truncate a Stream. Is \"READ\" permission enough to do this ?", "author": "shrids", "createdAt": "2020-10-15T04:26:47Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentMetadataClientImpl.java", "diffHunk": "@@ -63,7 +64,7 @@\n     public SegmentMetadataClientImpl(Segment segment, Controller controller, ConnectionPool connectionPool,\n                                      String delegationToken) {\n         this(segment, controller, connectionPool,\n-                DelegationTokenProviderFactory.create(delegationToken, controller, segment));\n+                DelegationTokenProviderFactory.create(delegationToken, controller, segment, AccessOperation.READ));", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDczNjk3Mw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r510736973", "bodyText": "This particular constructor seems to be used for testing only. I've pushed a change documenting that.", "author": "ravisharda", "createdAt": "2020-10-23T08:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyMjExMA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515822110", "bodyText": "since the constructor is \"public\", it can potentially be used in other contexts. maybe we make it package private?", "author": "shiveshr", "createdAt": "2020-11-02T08:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NjYwNQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505156605", "bodyText": "Same question as above.", "author": "shrids", "createdAt": "2020-10-15T04:27:53Z", "path": "client/src/main/java/io/pravega/client/stream/impl/ReaderGroupImpl.java", "diffHunk": "@@ -322,8 +323,7 @@ private StreamCut computeEndStreamCut(Stream stream, Map<Segment, Long> endSegme\n                     totalLength += endPositions.get(s);\n                 } else {\n                     if (tokenProvider == null) {\n-                        tokenProvider = DelegationTokenProviderFactory.create(\n-                                unreadVal.getDelegationToken(), controller, s);\n+                        tokenProvider = DelegationTokenProviderFactory.create(controller, s, AccessOperation.READ);\n                     }\n                     @Cleanup\n                     SegmentMetadataClient metadataClient = metaFactory.createSegmentMetadataClient(s, tokenProvider);", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NzkwNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r505157904", "bodyText": "we should add a comment to explain this config...", "author": "shrids", "createdAt": "2020-10-15T04:33:18Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/GRPCServerConfig.java", "diffHunk": "@@ -95,6 +95,8 @@\n      */\n     Integer getAccessTokenTTLInSeconds();\n \n+    boolean isInternalWritesWithReadPermEnabled();", "originalCommit": "226d1202b8d78fccbc12239e1b38253e52402d63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjMxNzk1NQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r506317955", "bodyText": "Sure, I've added a comment to explain it now.", "author": "ravisharda", "createdAt": "2020-10-16T11:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NzkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMTEwMw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515831103", "bodyText": "perhaps its good to define what we mean by internal streams here..\nis it streams that system creates for its own uses - controller's streams?\nor is it system streams created to provide user applications some funciton.\neven here we have two types of resources -\n\nmetadata tables\nreadergroup streams and watermark stream\n\n2 is something that user application has access to while 1 should be completely hidden from them.\niiuc you are referring to 2. right?", "author": "shiveshr", "createdAt": "2020-11-02T09:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE1NzkwNA=="}], "type": "inlineReview"}, {"oid": "e94ca554ce203a2485b395bbb87c72d92c759bea", "url": "https://github.com/pravega/pravega/commit/e94ca554ce203a2485b395bbb87c72d92c759bea", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-16T04:16:05Z", "type": "commit"}, {"oid": "be890bcde5fb6247dec3f544adfd5182692a44d0", "url": "https://github.com/pravega/pravega/commit/be890bcde5fb6247dec3f544adfd5182692a44d0", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-16T11:15:56Z", "type": "commit"}, {"oid": "b5bc046748de38d4d266be0eeb7a89be1f4049e7", "url": "https://github.com/pravega/pravega/commit/b5bc046748de38d4d266be0eeb7a89be1f4049e7", "message": "Merge remote-tracking branch 'origin/issue-5115-reads-using-read-permissions' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-16T11:16:36Z", "type": "commit"}, {"oid": "2f2c1ac49f6fd794f329550112d0d42b6f69fbff", "url": "https://github.com/pravega/pravega/commit/2f2c1ac49f6fd794f329550112d0d42b6f69fbff", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-16T11:19:42Z", "type": "commit"}, {"oid": "d4128e72d1c99803bc42c0df1e8f33a9a45babb0", "url": "https://github.com/pravega/pravega/commit/d4128e72d1c99803bc42c0df1e8f33a9a45babb0", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-16T11:22:26Z", "type": "commit"}, {"oid": "6166784d250758f8b907350a2e14ab675a0d4db4", "url": "https://github.com/pravega/pravega/commit/6166784d250758f8b907350a2e14ab675a0d4db4", "message": "Add tests and reduce a log level\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-19T04:45:30Z", "type": "commit"}, {"oid": "15e0ccd2a83a717be4534dee9dbf7ffa11678c59", "url": "https://github.com/pravega/pravega/commit/15e0ccd2a83a717be4534dee9dbf7ffa11678c59", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-19T04:45:57Z", "type": "commit"}, {"oid": "096a1e6c2a2de5be9c5f4d800f1a721669101b22", "url": "https://github.com/pravega/pravega/commit/096a1e6c2a2de5be9c5f4d800f1a721669101b22", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-22T05:51:56Z", "type": "commit"}, {"oid": "6cb5f75bea4ab955e4ebe56041dce4bc113751b4", "url": "https://github.com/pravega/pravega/commit/6cb5f75bea4ab955e4ebe56041dce4bc113751b4", "message": "Address review comments on design and implementation\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-22T15:58:39Z", "type": "commit"}, {"oid": "8ab3e44351a50ba30d75b4f0cb5c772ed791bd8d", "url": "https://github.com/pravega/pravega/commit/8ab3e44351a50ba30d75b4f0cb5c772ed791bd8d", "message": "Merge remote-tracking branch 'origin/issue-5115-reads-using-read-permissions' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-22T15:58:52Z", "type": "commit"}, {"oid": "0dd0a8e724d934a3c9ce0687e6ff3a8d93c8992c", "url": "https://github.com/pravega/pravega/commit/0dd0a8e724d934a3c9ce0687e6ff3a8d93c8992c", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-23T03:16:43Z", "type": "commit"}, {"oid": "c4f6edfeb9fd0e23266e2dd61696e62b09334d13", "url": "https://github.com/pravega/pravega/commit/c4f6edfeb9fd0e23266e2dd61696e62b09334d13", "message": "Modify handling of Watermark resources to account for the fact that it is not user visible.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-23T04:52:24Z", "type": "commit"}, {"oid": "2798cba7eee05aa112af92fce43b21b470c5c683", "url": "https://github.com/pravega/pravega/commit/2798cba7eee05aa112af92fce43b21b470c5c683", "message": "Address review comments\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-23T08:30:01Z", "type": "commit"}, {"oid": "d15769653cdff7794bbbc20e8369197f5b07c494", "url": "https://github.com/pravega/pravega/commit/d15769653cdff7794bbbc20e8369197f5b07c494", "message": "Document the constuctor's test-only usage\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-23T08:55:05Z", "type": "commit"}, {"oid": "6d27990a04eea7ebdc1f132ae3a7942d3beb83ed", "url": "https://github.com/pravega/pravega/commit/6d27990a04eea7ebdc1f132ae3a7942d3beb83ed", "message": "Rename an access operation.\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-23T09:51:23Z", "type": "commit"}, {"oid": "ec8ea19353764489c13aafaf0ace6462b5edfc8a", "url": "https://github.com/pravega/pravega/commit/ec8ea19353764489c13aafaf0ace6462b5edfc8a", "message": "Fix a unit test\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-27T05:18:21Z", "type": "commit"}, {"oid": "223474c9df89b17cb85ab24df92d22f39f88f5f0", "url": "https://github.com/pravega/pravega/commit/223474c9df89b17cb85ab24df92d22f39f88f5f0", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-28T02:17:26Z", "type": "commit"}, {"oid": "f10cb538f5ac89a4c6f15985178479feac095aab", "url": "https://github.com/pravega/pravega/commit/f10cb538f5ac89a4c6f15985178479feac095aab", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-28T15:01:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTE4MQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r513579181", "bodyText": "This is not read-only. The revisioned stream client is used for writes.\nThis is called from the public API above, not for internal streams.\nPlease add unit / integration tests such that this sort of bug would be caught.", "author": "tkaitchuck", "createdAt": "2020-10-28T16:18:34Z", "path": "client/src/main/java/io/pravega/client/stream/impl/ClientFactoryImpl.java", "diffHunk": "@@ -213,9 +214,8 @@ public ClientFactoryImpl(String scope, Controller controller, ConnectionPool con\n     private <T> RevisionedStreamClient<T> createRevisionedStreamClient(Segment segment, Serializer<T> serializer,\n                                                                        SynchronizerConfig config) {\n         EventSegmentReader in = inFactory.createEventReaderForSegment(segment, config.getReadBufferSize());\n-        String delegationToken = Futures.getAndHandleExceptions(controller.getOrRefreshDelegationTokenFor(segment.getScope(),\n-                                                                                                          segment.getStreamName()), RuntimeException::new);\n-        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(delegationToken, controller, segment);\n+        DelegationTokenProvider delegationTokenProvider = DelegationTokenProviderFactory.create(controller, segment,", "originalCommit": "f10cb538f5ac89a4c6f15985178479feac095aab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDI4Nw==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r514150287", "bodyText": "Ok. I've modified the access operation to read_write to reflect that.", "author": "ravisharda", "createdAt": "2020-10-29T10:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1NDA5OQ==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515854099", "bodyText": "Also, I've added a number of tests to supplement the many existing tests we already have for Auth.", "author": "ravisharda", "createdAt": "2020-11-02T09:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTE4MQ=="}], "type": "inlineReview"}, {"oid": "00aba40458a23500aed4354f3fce35cbc4f4a974", "url": "https://github.com/pravega/pravega/commit/00aba40458a23500aed4354f3fce35cbc4f4a974", "message": "Address review comments and add tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-29T10:17:28Z", "type": "commit"}, {"oid": "580281499d49374f6370257f8846b1dcc71c7cb0", "url": "https://github.com/pravega/pravega/commit/580281499d49374f6370257f8846b1dcc71c7cb0", "message": "Merge remote-tracking branch 'origin/issue-5115-reads-using-read-permissions' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-29T10:17:48Z", "type": "commit"}, {"oid": "571cca29b960463d89180e99fda40c19ad5f5d4e", "url": "https://github.com/pravega/pravega/commit/571cca29b960463d89180e99fda40c19ad5f5d4e", "message": "Merge branch 'master' into issue-5115-reads-using-read-permissions", "committedDate": "2020-10-29T10:21:38Z", "type": "commit"}, {"oid": "b77005598f0a4da8cb3ed15ec1bb214fa745cd53", "url": "https://github.com/pravega/pravega/commit/b77005598f0a4da8cb3ed15ec1bb214fa745cd53", "message": "Add jaxb back to avoid test failures and exclude from client\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-10-30T02:09:12Z", "type": "commit"}, {"oid": "73c901175c6c52fc7e319ccbb65b668a795ee2bb", "url": "https://github.com/pravega/pravega/commit/73c901175c6c52fc7e319ccbb65b668a795ee2bb", "message": "Ass support for testing delegation token supplier\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-02T04:42:58Z", "type": "commit"}, {"oid": "fcc039ff041156714a984852b4ab25d21e25d72a", "url": "https://github.com/pravega/pravega/commit/fcc039ff041156714a984852b4ab25d21e25d72a", "message": "Merge from master, resolve conflicts and add tests\n\nSigned-off-by: Ravi Sharda <ravi.sharda@emc.com>", "committedDate": "2020-11-02T07:18:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNzYwNA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515837604", "bodyText": "i am sorry, i think i had asked this earlier too - why do we authorize for both minimum permissions and requested permissions successively.. isnt minimum permission redundant in that case?", "author": "shiveshr", "createdAt": "2020-11-02T09:25:03Z", "path": "controller/src/main/java/io/pravega/controller/server/rpc/grpc/v1/ControllerServiceImpl.java", "diffHunk": "@@ -345,21 +360,106 @@ public void deleteStream(StreamInfo request, StreamObserver<DeleteStreamStatus>\n \n     @Override\n     public void getCurrentSegments(StreamInfo request, StreamObserver<SegmentRanges> responseObserver) {\n-        log.info(\"getCurrentSegments called for stream {}/{}.\", request.getScope(), request.getStream());\n-        authenticateExecuteAndProcessResults(() -> this.grpcAuthHelper.checkAuthorizationAndCreateToken(\n-                authorizationResource.ofStreamInScope(request.getScope(), request.getStream()),\n-                AuthHandler.Permissions.READ_UPDATE),\n-                delegationToken -> {\n-                    logIfEmpty(delegationToken, \"getCurrentSegments\", request.getScope(), request.getStream());\n-                    return controllerService.getCurrentSegments(request.getScope(), request.getStream())\n-                            .thenApply(segmentRanges -> SegmentRanges.newBuilder()\n-                                    .addAllSegmentRanges(segmentRanges)\n-                                    .setDelegationToken(delegationToken)\n-                                    .build());\n+        final String scope = request.getScope();\n+        final String stream = request.getStream();\n+        log.info(\"getCurrentSegments called for stream {}/{}.\", scope, stream);\n+        String resource = StreamAuthParams.toResourceString(scope, stream);\n+\n+        final boolean isDelegationTokenRequested =\n+                request.getRequestedPermission().equals(AccessOperation.NONE.toString()) ? false : true;\n+\n+        authenticateExecuteAndProcessResults(() -> {\n+                    if (isDelegationTokenRequested) {\n+                        // For backward compatibility: older clients still depend on delegation tokens generated\n+                        // by this method for both reads and writes.\n+                        return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+                    } else {\n+                        return this.grpcAuthHelper.checkAuthorization(resource, AuthHandler.Permissions.READ);\n+                    }\n+                },\n+                authorizationResult -> {\n+                    logIfEmpty(authorizationResult, \"getCurrentSegments\", scope, stream);\n+                    return controllerService.getCurrentSegments(scope, stream)\n+                            .thenApply(segmentRanges -> {\n+                                SegmentRanges.Builder builder = SegmentRanges.newBuilder().addAllSegmentRanges(segmentRanges);\n+                                if (isDelegationTokenRequested) {\n+                                    builder.setDelegationToken(authorizationResult);\n+                                }\n+                                return builder.build();\n+                            });\n                 },\n                 responseObserver);\n     }\n \n+    @VisibleForTesting\n+    public Supplier<String> delegationTokenSupplier(StreamInfo request) {\n+        return () -> {\n+            if (!this.isAuthEnabled()) {\n+                return \"\";\n+            }\n+\n+            StreamAuthParams authParams = new StreamAuthParams(request.getScope(), request.getStream(),\n+                    request.getRequestedPermission(), this.isInternalWritesWithReadPermEnabled);\n+\n+            // StreamResource will be a stream representation (ex: \"prn:://scope:myScope/stream:_RGmyApp\") of the\n+            // reader group (ex: \"prn:://scope:myScope/reader-group:myApp). We use stream representation in claims\n+            // put in delegation tokens for Segment Store's use, even though we use the regular representation for\n+            // authorization here in the Controller.\n+            String streamResource = authParams.streamResourceString();\n+            String resource = authParams.resourceString();\n+\n+            if (authParams.isRequestedPermissionEmpty()) {\n+                // For backward compatibility: Older clients will not populate requested permission.\n+                log.info(\"Requested permission was empty for request with scope {} and stream {}\", request.getScope(),\n+                        request.getStream());\n+                return this.grpcAuthHelper.checkAuthorizationAndCreateToken(resource, AuthHandler.Permissions.READ_UPDATE);\n+            } else {\n+                log.debug(\"Requested permission was {} for request with scope {} and stream {}\",\n+                        request.getRequestedPermission(), request.getScope(), request.getStream());\n+\n+                // The resource string that'll be used in the delegation token for use of the segment store\n+                final String tokenResource;\n+\n+                // The operation that'll be specified as granted for the resource in the token. The bearer of the token\n+                // will be allowed to perform the specified operation.\n+                final AuthHandler.Permissions tokenPermission;\n+\n+                // This is the permission that the client is requesting to be assigned on the delegation token.\n+                AuthHandler.Permissions requestedPermissions = authParams.requestedPermission();\n+\n+                if (authParams.isStreamUserDefined()) {\n+                    // The operation itself requires the caller to possess read permissions.\n+                    AuthHandler.Permissions minimumPermissions = AuthHandler.Permissions.READ;\n+\n+                    if (requestedPermissions.equals(AuthHandler.Permissions.READ_UPDATE) ||\n+                            requestedPermissions.equals(minimumPermissions)) {\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, requestedPermissions);\n+                        tokenResource = streamResource;\n+                        tokenPermission = requestedPermissions;\n+                    } else {\n+                        // The minimum permission that the user must have to be able to invoke this call. This\n+                        // authorizes the operation.\n+                        this.grpcAuthHelper.checkAuthorization(streamResource, minimumPermissions);", "originalCommit": "fcc039ff041156714a984852b4ab25d21e25d72a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1Nzg0NA==", "url": "https://github.com/pravega/pravega/pull/5231#discussion_r515857844", "bodyText": "The minimum permissions is the permission required to make this call. The requested permission is the permission the caller wants to be assigned in the delegation token.\nIn most cases, the calling code from the client will ask for one of these:\n\nREAD - in which case authorization is only done for READ\nREAD_WRITE or WRITE - in which case authorization is only done for READ_UPDATE\nNo permission - in which case the default/backward compatibility rule applies.\n\nThis particular piece of code is for other unexpected cases. Here's an example: \n  \n    \n      pravega/controller/src/test/java/io/pravega/controller/server/rpc/grpc/v1/InMemoryControllerServiceImplTest.java\n    \n    \n         Line 170\n      in\n      ed3f57f\n    \n    \n    \n    \n\n        \n          \n           public void supplierCreatesTokenWithReadWhenRequestedPermissionIsUnexpected() {", "author": "ravisharda", "createdAt": "2020-11-02T09:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzNzYwNA=="}], "type": "inlineReview"}]}