{"pr_number": 4485, "pr_title": "Issue 4451: (SegmentStore) Enhancing Segment Attribute Tier 2 Sync", "pr_createdAt": "2020-01-11T01:48:51Z", "pr_url": "https://github.com/pravega/pravega/pull/4485", "timeline": [{"oid": "d1ae508446b9a4c8d55b337063051e615251917c", "url": "https://github.com/pravega/pravega/commit/d1ae508446b9a4c8d55b337063051e615251917c", "message": "BTreeIndex exposes and uses a RootPointer which can be stored externally to aid in recovery.\nSegmentAggregator makes use of this to handle partial updates that made it to Storage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-10T04:06:44Z", "type": "commit"}, {"oid": "10bb1fa4d85d0cbf8d5cad0bafbb864daafe0299", "url": "https://github.com/pravega/pravega/commit/10bb1fa4d85d0cbf8d5cad0bafbb864daafe0299", "message": "Excluding new attribute from unit test checks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-01-10T16:51:28Z", "type": "commit"}, {"oid": "d3335227cd6f2ae58b59449f23b7ac762431ad0b", "url": "https://github.com/pravega/pravega/commit/d3335227cd6f2ae58b59449f23b7ac762431ad0b", "message": "Created AttributeAggregator with all the logic to move Extended Attribute Updates from the DurableLog to Storage/AttributeIndex.\n\nThis is not wired up yet, nor is the same functionality removed from SegmentAggregator.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-01-11T00:19:55Z", "type": "commit"}, {"oid": "0b3db6abe4464e1bf77803acade2fcff4035e6eb", "url": "https://github.com/pravega/pravega/commit/0b3db6abe4464e1bf77803acade2fcff4035e6eb", "message": "Removed attribute logic from SegmentAggregator. Wired AttributeAggregator into StorageWriter.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-01-11T01:47:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUwNTg1Mg==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r365505852", "bodyText": "Will some sort of compare-and-set help here in preventing races?\nYou know the expected previous state", "author": "eolivelli", "createdAt": "2020-01-11T07:23:39Z", "path": "common/src/main/java/io/pravega/common/util/btree/BTreeIndex.java", "diffHunk": "@@ -790,14 +792,17 @@ private ByteArraySegment generateMinKey() {\n         long rootMinOffset = lastPage.getMinOffset();\n         assert rootMinOffset >= 0 : \"root.MinOffset not set\";\n         return this.write.apply(pages, oldOffsets, rootMinOffset, timeout)\n-                         .thenApply(indexLength -> setState(indexLength, rootOffset, rootLength).length);\n+                .thenApply(indexLength -> {\n+                    setState(indexLength, rootOffset, rootLength);", "originalCommit": "0b3db6abe4464e1bf77803acade2fcff4035e6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUyNzk3OQ==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r365527979", "bodyText": "It's not just in memory state that I care about. What I noticed is that, at least for NFS Tier 2 mounts, even if I send a 1MB data block, if we crash while writing it, part of it may have been durably stored onto whatever is behind the NFS mount. While not a problem for regular stream segments (since they're append-only and we can always resume from where we left off), for BTreeIndex it's different. It needs the file (at least the last 12 bytes of it) to be structured, otherwise it won't be able to read the BTree Pages properly. If we wanted to write 10 pages, for example, but crashed after writing 6.5 of them, then the data structure won't be able to recover afterwards.\nGoing back to your question. I need to persist somewhere the pointer to the root page of the BTree index. Previously it was the last 12 bytes of the Attribute File, but since that's not reliable, one of the changes in this PR is to also store it in the main Segment's Core Attributes (these attributes have a different lifecycle so they're not susceptible to this problem). If we crash in the middle of a write (or just after a good write but before persisting the new pointer), we'll always be able to recover from the previous BTree Index pointer, and try again.\nPlease wait until I finish this PR. I only submitted it so I can get some Travis builds done and get some system tests executed, but I am not ready for review. I'll add the appropriate description and explanations when I'm done, most likely in a few days.", "author": "andreipaduroiu", "createdAt": "2020-01-11T15:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUwNTg1Mg=="}], "type": "inlineReview"}, {"oid": "0233471c2867278244443b41065f3af860ce9a8d", "url": "https://github.com/pravega/pravega/commit/0233471c2867278244443b41065f3af860ce9a8d", "message": "Tweaked some unit tests. Added some logging.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-11T17:05:38Z", "type": "commit"}, {"oid": "3b2b4bffddd9889bb81eac71e953f28cdb465d96", "url": "https://github.com/pravega/pravega/commit/3b2b4bffddd9889bb81eac71e953f28cdb465d96", "message": "More unit test coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-11T18:00:12Z", "type": "commit"}, {"oid": "487f138756384e26684e4514bbd0ccfcfc6d494f", "url": "https://github.com/pravega/pravega/commit/487f138756384e26684e4514bbd0ccfcfc6d494f", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-11T21:48:20Z", "type": "commit"}, {"oid": "cfd7c6308bf7677a0932a53a67df5b2775595ba7", "url": "https://github.com/pravega/pravega/commit/cfd7c6308bf7677a0932a53a67df5b2775595ba7", "message": "Added attributes to every append operation in SelfTester.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-12T16:43:12Z", "type": "commit"}, {"oid": "6585e11edc479bf6fa2c83f122ff1aac28b0bc74", "url": "https://github.com/pravega/pravega/commit/6585e11edc479bf6fa2c83f122ff1aac28b0bc74", "message": "Now accepting select UpdateAttributesOperations after the segment is sealed.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-12T21:55:44Z", "type": "commit"}, {"oid": "f7ee03a9d06329e27768fd3afeac63bbc190c3ec", "url": "https://github.com/pravega/pravega/commit/f7ee03a9d06329e27768fd3afeac63bbc190c3ec", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-13T08:19:57Z", "type": "commit"}, {"oid": "82935cdc6168cbc849d67f61ba7804b38d63ab3c", "url": "https://github.com/pravega/pravega/commit/82935cdc6168cbc849d67f61ba7804b38d63ab3c", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-13T09:14:44Z", "type": "commit"}, {"oid": "3bc18b447b56971a907c7ceda10650c359397d93", "url": "https://github.com/pravega/pravega/commit/3bc18b447b56971a907c7ceda10650c359397d93", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-13T23:33:56Z", "type": "commit"}, {"oid": "04f40b5fd8e2b20d2767421ced5d2a84c4f38e87", "url": "https://github.com/pravega/pravega/commit/04f40b5fd8e2b20d2767421ced5d2a84c4f38e87", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-14T11:28:15Z", "type": "commit"}, {"oid": "406dd99c34b5a38ec1626829510e57c1c1f92a02", "url": "https://github.com/pravega/pravega/commit/406dd99c34b5a38ec1626829510e57c1c1f92a02", "message": "Resetting flush timer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-14T17:01:50Z", "type": "commit"}, {"oid": "d651fcb2702e7e1ba924d3fac0edc66afc70e5af", "url": "https://github.com/pravega/pravega/commit/d651fcb2702e7e1ba924d3fac0edc66afc70e5af", "message": "AttributeAggregator is now updating Root Pointers in Core Attributes asynchronously (to avoid slowing down due to throttling).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-15T02:23:53Z", "type": "commit"}, {"oid": "48d173e5819c8e36978b150206bb13ee94ff49e4", "url": "https://github.com/pravega/pravega/commit/48d173e5819c8e36978b150206bb13ee94ff49e4", "message": "Javadoc\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-01-15T20:03:39Z", "type": "commit"}, {"oid": "0a28552a4c43e6f0e106cbb4e85cc7a4ccfd7cf1", "url": "https://github.com/pravega/pravega/commit/0a28552a4c43e6f0e106cbb4e85cc7a4ccfd7cf1", "message": "Passing traceObjectId for better logging.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-01-15T21:50:08Z", "type": "commit"}, {"oid": "6b3310d901a8a209c496900f4418f56b17138d90", "url": "https://github.com/pravega/pravega/commit/6b3310d901a8a209c496900f4418f56b17138d90", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-15T21:55:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5MjYwNQ==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367192605", "bodyText": "It seems odd to configure a minimum in terms of a count without also providing some sort of bound. Like maybe based on time. Otherwise it could sit unflushed indefinitely.", "author": "tkaitchuck", "createdAt": "2020-01-16T01:34:33Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/WriterConfig.java", "diffHunk": "@@ -52,6 +53,12 @@\n     @Getter\n     private final Duration flushThresholdTime;\n \n+    /**\n+     * The minimum number of attributes that should accumulate before flushing them into the Attribute Index.", "originalCommit": "6b3310d901a8a209c496900f4418f56b17138d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ5MzgzMw==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367493833", "bodyText": "There already is a time bound (see line 54 above). It's the same setting used for the regular segment transfer; I decided I didn't want another setting that would have essentially the same value.", "author": "andreipaduroiu", "createdAt": "2020-01-16T15:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5MjYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5Mzg2MA==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367193860", "bodyText": "This should be an immutable list.", "author": "tkaitchuck", "createdAt": "2020-01-16T01:40:05Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/writer/AttributeAggregatorTests.java", "diffHunk": "@@ -0,0 +1,784 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.writer;\n+\n+import io.pravega.common.util.ByteArraySegment;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.AttributeUpdateType;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentSealedException;\n+import io.pravega.segmentstore.server.DataCorruptionException;\n+import io.pravega.segmentstore.server.ManualTimer;\n+import io.pravega.segmentstore.server.MetadataBuilder;\n+import io.pravega.segmentstore.server.SegmentOperation;\n+import io.pravega.segmentstore.server.UpdateableContainerMetadata;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.WriterFlushResult;\n+import io.pravega.segmentstore.server.logs.operations.AttributeUpdaterOperation;\n+import io.pravega.segmentstore.server.logs.operations.CachedStreamSegmentAppendOperation;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import io.pravega.segmentstore.server.logs.operations.StorageOperation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentAppendOperation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentSealOperation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentTruncateOperation;\n+import io.pravega.segmentstore.server.logs.operations.UpdateAttributesOperation;\n+import io.pravega.test.common.AssertExtensions;\n+import io.pravega.test.common.ErrorInjector;\n+import io.pravega.test.common.IntentionalException;\n+import io.pravega.test.common.ThreadPooledTestSuite;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import lombok.Cleanup;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.val;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Unit test for the {@link AttributeAggregator} class.\n+ */\n+public class AttributeAggregatorTests extends ThreadPooledTestSuite {\n+    private static final int CONTAINER_ID = 0;\n+    private static final long SEGMENT_ID = 123;\n+    private static final String SEGMENT_NAME = \"Segment\";\n+    private static final byte[] APPEND_DATA = SEGMENT_NAME.getBytes();\n+    private static final UUID CORE_ATTRIBUTE_ID = Attributes.EVENT_COUNT;\n+    private static final List<UUID> EXTENDED_ATTRIBUTE_IDS = IntStream.range(0, 20).mapToObj(i -> UUID.randomUUID()).collect(Collectors.toList());", "originalCommit": "6b3310d901a8a209c496900f4418f56b17138d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxODUyMg==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367518522", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-01-16T16:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5Mzg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDEwNw==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367194107", "bodyText": "This should be an immutable set.", "author": "tkaitchuck", "createdAt": "2020-01-16T01:41:15Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/StreamSegmentContainerTests.java", "diffHunk": "@@ -143,6 +145,11 @@\n  * DurableDataLog.\n  */\n public class StreamSegmentContainerTests extends ThreadPooledTestSuite {\n+    /**\n+     * Auto-generated attributes which are not set externally but maintained internally. To ease our testing, we will\n+     * exclude these from all our checks.\n+     */\n+    private static final Collection<UUID> AUTO_ATTRIBUTES = Sets.newHashSet(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO);", "originalCommit": "6b3310d901a8a209c496900f4418f56b17138d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxODQ2NA==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367518464", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-01-16T16:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDU5Nw==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367194597", "bodyText": "Between this and the Javadoc at the top of the file it seems like maybe a refactoring is due.", "author": "tkaitchuck", "createdAt": "2020-01-16T01:43:27Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java", "diffHunk": "@@ -331,26 +322,23 @@ public String toString() {\n     @Override\n     public void add(SegmentOperation operation) throws DataCorruptionException {\n         ensureInitializedAndNotClosed();\n+        if (!(operation instanceof StorageOperation)) {", "originalCommit": "6b3310d901a8a209c496900f4418f56b17138d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyMjY1OQ==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367522659", "bodyText": "Well this was a refactoring. The SegmentAggregator deals exclusively with transferring data within the segment and the AttributeAggregator handles attribute transfer.\nI decided to keep segment deletion logic in here because we want to remember to delete attributes when we delete the segment, when we merge it, and one more complex situation. Instead of doing it twice, I preferred to keep that part in one place.\nI don't understand what is wrong with this line though. The SegmentAggregator only handles StorageOperations; all other types of operations are MetadataOperations are not its responsibility. There are other processors for each segment within the StorageWriter, and each deals with its own types of operations. WriterTableProcessor only handles append operations, AttributeAggregator handles AttributeUpdaterOperations (appends & attribute updates) and this handles appends, seals, mergers, deletes, truncates, etc. In other words, anything which applies directly to Tier 2 is a StorageOperation and is handled by this class, while others are a bit more specialized and do not touch Tier 2 (directly).", "author": "andreipaduroiu", "createdAt": "2020-01-16T16:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNjUyNA==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367736524", "bodyText": "I don't have enough context here to suggest a specific alternative, but I am always wary when I see reflection being used in code. It decouples the caller in an impl that makes it possible for one to change without the other knowing that ends up breaking things. There are a lot of ways around this:\n\nJust have multiple functions\nPer type listeners\nVisitor pattern like we do in WireCommands\nHaving a getting on the operation to return a type.\netc.\n\nAs I say, I don't really know the context here. I am not aware of any particularly extreme circumstances that prevents any of these. If there is, then let's document it. If not then let's try to find a more standard pattern.", "author": "tkaitchuck", "createdAt": "2020-01-17T01:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1MzUxMQ==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r368053511", "bodyText": "Let's see if I can explain. The StorageWriter picks Operations (all of them) from Tier1/DurableLog. The StorageWriter also has WriterProcessors for each active segment in the container. A WriterProcessor has a SegmentAggregator, an AttributeAggregator (new in this PR) and a WriterTableProcessor (for Table Segments).\nThe StorageWriter picks operation from Tier 1 (in order) and sends them to all its WriterProcessors, which in turn sends them to all of the aggregators sub-processors. So from this POV, it is using the visitor pattern (in a way). The operations themselves are immutable, but each Processor/Aggregator knows which operations it needs to process and will just ignore the rest. IMO, this can be done in two ways: the current way, in which all processors see all operations and decide which ones they use, and another in which they register with the StorageWriter to send them only those operations they care about. I just happen to do the former, because even if it accepts an operation of a given type, it may end up ignoring it due to other factors.", "author": "andreipaduroiu", "createdAt": "2020-01-17T17:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE0NTUyMw==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r368145523", "bodyText": "That sounds reasonable.\nAlternatively: You could also make WriterProcessor the one to send some types to the SegmentAddregator and others to the WriterTableProcessor. (Obviously this makes it more aware of what those classes are doing, so its up to you as to whether that falls too far outside of its current responsibilities.)", "author": "tkaitchuck", "createdAt": "2020-01-17T21:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1MDgxMA==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r368150810", "bodyText": "Good suggestion. Since this is outside of the scope of this change, I captured this in #4493, which also includes an additional refactoring of the StorageWriter to make it more efficient.", "author": "andreipaduroiu", "createdAt": "2020-01-17T21:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NDU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NTA4NA==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367195084", "bodyText": "Would an enum be better here?", "author": "tkaitchuck", "createdAt": "2020-01-16T01:45:47Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/AttributeAggregator.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.writer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.AbstractTimer;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.StreamSegmentMergedException;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentSealedException;\n+import io.pravega.segmentstore.server.DataCorruptionException;\n+import io.pravega.segmentstore.server.SegmentOperation;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.WriterFlushResult;\n+import io.pravega.segmentstore.server.WriterSegmentProcessor;\n+import io.pravega.segmentstore.server.logs.operations.AttributeUpdaterOperation;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentSealOperation;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Aggregates Attribute Updates for a specific Segment.\n+ *\n+ * This class handles the following operations on a Segment: Attribute Updates (extended attributes only) and Sealing\n+ * the Attribute Index. Any Attribute Index deletions are handled by {@link SegmentAggregator}.\n+ */\n+@Slf4j\n+class AttributeAggregator implements WriterSegmentProcessor, AutoCloseable {\n+    //region Members\n+\n+    private final UpdateableSegmentMetadata metadata;\n+    private final WriterConfig config;\n+    private final AbstractTimer timer;\n+    private final Executor executor;\n+    private final String traceObjectId;\n+    private final WriterDataSource dataSource;\n+    private final AtomicReference<Duration> lastFlush;\n+    private final State state;\n+    private final AtomicBoolean closed;\n+    private final AtomicReference<RootPointerInfo> lastRootPointer;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link AttributeAggregator} class.\n+     *\n+     * @param segmentMetadata The Metadata for the Segment to construct this Aggregator for.\n+     * @param dataSource      The {@link WriterDataSource} to use.\n+     * @param config          The {@link WriterConfig} to use.\n+     * @param timer           An {@link AbstractTimer} to use to determine elapsed time.\n+     * @param executor        An Executor to use for async operations.\n+     */\n+    AttributeAggregator(@NonNull UpdateableSegmentMetadata segmentMetadata, @NonNull WriterDataSource dataSource,\n+                        @NonNull WriterConfig config, @NonNull AbstractTimer timer, @NonNull Executor executor) {\n+        this.metadata = segmentMetadata;\n+        this.config = config;\n+        this.dataSource = dataSource;\n+        this.timer = timer;\n+        this.executor = executor;\n+        this.lastFlush = new AtomicReference<>(timer.getElapsed());\n+\n+        Preconditions.checkArgument(this.metadata.getContainerId() == dataSource.getId(), \"SegmentMetadata.ContainerId is different from WriterDataSource.Id\");\n+        this.traceObjectId = String.format(\"AttributeAggregator[%d-%d]\", this.metadata.getContainerId(), this.metadata.getId());\n+        this.state = new State(segmentMetadata.getAttributes().getOrDefault(Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO, Operation.NO_SEQUENCE_NUMBER));\n+        this.closed = new AtomicBoolean();\n+        this.lastRootPointer = new AtomicReference<>();\n+    }\n+\n+    //endregion\n+\n+    //region AutoCloseable Implementation\n+\n+    @Override\n+    public void close() {\n+        this.closed.set(true);\n+    }\n+\n+    //endregion\n+\n+    //region WriterSegmentProcessor Implementation\n+\n+    @Override\n+    public long getLowestUncommittedSequenceNumber() {\n+        if (this.lastRootPointer.get() == null) {\n+            // There is no async pending update for the root pointer attribute. The LUSN is whatever we accumulated in\n+            // our buffers (if nothing, then this will return Operation.NO_SEQUENCE_NUMBER).\n+            return this.state.getFirstSequenceNumber();\n+        } else {\n+            // There is an async pending update for the root pointer attribute. The LUSN can be calculated based off\n+            // whatever we were last able to acknowledge.\n+            long lpsn = this.state.getLastPersistedSequenceNumber();\n+            return lpsn == Operation.NO_SEQUENCE_NUMBER ? this.state.getFirstSequenceNumber() : lpsn + 1;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return this.closed.get();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"[%d: %s] Count = %d, LUSN = %d, LastSeqNo = %d, LastFlush = %ds\", this.metadata.getId(), this.metadata.getName(),\n+                this.state.size(), getLowestUncommittedSequenceNumber(), this.state.getLastSequenceNumber(), getElapsedSinceLastFlush().toMillis() / 1000);\n+    }\n+\n+    /**\n+     * Adds the given SegmentOperation to the Aggregator.\n+     *\n+     * @param operation the Operation to add.\n+     * @throws DataCorruptionException  If the validation of the given Operation indicates a possible data corruption in\n+     *                                  the code (offset gaps, out-of-order operations, etc.)\n+     * @throws IllegalArgumentException If the validation of the given Operation indicates a possible non-corrupting bug\n+     *                                  in the code.\n+     */\n+    @Override\n+    public void add(SegmentOperation operation) throws DataCorruptionException {\n+        Exceptions.checkNotClosed(isClosed(), this);\n+        Preconditions.checkArgument(\n+                operation.getStreamSegmentId() == this.metadata.getId(),\n+                \"Operation '%s' refers to a different Segment than this one (%s).\", operation, this.metadata.getId());\n+        if (isSegmentDeleted()) {\n+            return;\n+        }\n+\n+        boolean processed = false;\n+        if (operation instanceof StreamSegmentSealOperation) {", "originalCommit": "6b3310d901a8a209c496900f4418f56b17138d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxOTc2MA==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367519760", "bodyText": "That means I'd need to maintain an enum for the types of Operations, where each operation would have a getter that returns its enum value. That would resolve the instanceof but I would still need to cast them eventually to the correct type, so I am not sure we're going to get much benefit out of it. The downside of that would be the need to ensure that the enum matches the operation type; at least with instanceof and cast we don't need to worry about that problem.", "author": "andreipaduroiu", "createdAt": "2020-01-16T16:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NjkxNg==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367196916", "bodyText": "The other members of this class are atomics and this is a normal hashmap which is accessed by include without any synchronization. This looks like a bug.", "author": "tkaitchuck", "createdAt": "2020-01-16T01:54:13Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/AttributeAggregator.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.writer;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.AbstractTimer;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.segmentstore.contracts.AttributeUpdate;\n+import io.pravega.segmentstore.contracts.Attributes;\n+import io.pravega.segmentstore.contracts.StreamSegmentMergedException;\n+import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+import io.pravega.segmentstore.contracts.StreamSegmentSealedException;\n+import io.pravega.segmentstore.server.DataCorruptionException;\n+import io.pravega.segmentstore.server.SegmentOperation;\n+import io.pravega.segmentstore.server.UpdateableSegmentMetadata;\n+import io.pravega.segmentstore.server.WriterFlushResult;\n+import io.pravega.segmentstore.server.WriterSegmentProcessor;\n+import io.pravega.segmentstore.server.logs.operations.AttributeUpdaterOperation;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import io.pravega.segmentstore.server.logs.operations.StreamSegmentSealOperation;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.Data;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Aggregates Attribute Updates for a specific Segment.\n+ *\n+ * This class handles the following operations on a Segment: Attribute Updates (extended attributes only) and Sealing\n+ * the Attribute Index. Any Attribute Index deletions are handled by {@link SegmentAggregator}.\n+ */\n+@Slf4j\n+class AttributeAggregator implements WriterSegmentProcessor, AutoCloseable {\n+    //region Members\n+\n+    private final UpdateableSegmentMetadata metadata;\n+    private final WriterConfig config;\n+    private final AbstractTimer timer;\n+    private final Executor executor;\n+    private final String traceObjectId;\n+    private final WriterDataSource dataSource;\n+    private final AtomicReference<Duration> lastFlush;\n+    private final State state;\n+    private final AtomicBoolean closed;\n+    private final AtomicReference<RootPointerInfo> lastRootPointer;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link AttributeAggregator} class.\n+     *\n+     * @param segmentMetadata The Metadata for the Segment to construct this Aggregator for.\n+     * @param dataSource      The {@link WriterDataSource} to use.\n+     * @param config          The {@link WriterConfig} to use.\n+     * @param timer           An {@link AbstractTimer} to use to determine elapsed time.\n+     * @param executor        An Executor to use for async operations.\n+     */\n+    AttributeAggregator(@NonNull UpdateableSegmentMetadata segmentMetadata, @NonNull WriterDataSource dataSource,\n+                        @NonNull WriterConfig config, @NonNull AbstractTimer timer, @NonNull Executor executor) {\n+        this.metadata = segmentMetadata;\n+        this.config = config;\n+        this.dataSource = dataSource;\n+        this.timer = timer;\n+        this.executor = executor;\n+        this.lastFlush = new AtomicReference<>(timer.getElapsed());\n+\n+        Preconditions.checkArgument(this.metadata.getContainerId() == dataSource.getId(), \"SegmentMetadata.ContainerId is different from WriterDataSource.Id\");\n+        this.traceObjectId = String.format(\"AttributeAggregator[%d-%d]\", this.metadata.getContainerId(), this.metadata.getId());\n+        this.state = new State(segmentMetadata.getAttributes().getOrDefault(Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO, Operation.NO_SEQUENCE_NUMBER));\n+        this.closed = new AtomicBoolean();\n+        this.lastRootPointer = new AtomicReference<>();\n+    }\n+\n+    //endregion\n+\n+    //region AutoCloseable Implementation\n+\n+    @Override\n+    public void close() {\n+        this.closed.set(true);\n+    }\n+\n+    //endregion\n+\n+    //region WriterSegmentProcessor Implementation\n+\n+    @Override\n+    public long getLowestUncommittedSequenceNumber() {\n+        if (this.lastRootPointer.get() == null) {\n+            // There is no async pending update for the root pointer attribute. The LUSN is whatever we accumulated in\n+            // our buffers (if nothing, then this will return Operation.NO_SEQUENCE_NUMBER).\n+            return this.state.getFirstSequenceNumber();\n+        } else {\n+            // There is an async pending update for the root pointer attribute. The LUSN can be calculated based off\n+            // whatever we were last able to acknowledge.\n+            long lpsn = this.state.getLastPersistedSequenceNumber();\n+            return lpsn == Operation.NO_SEQUENCE_NUMBER ? this.state.getFirstSequenceNumber() : lpsn + 1;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return this.closed.get();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"[%d: %s] Count = %d, LUSN = %d, LastSeqNo = %d, LastFlush = %ds\", this.metadata.getId(), this.metadata.getName(),\n+                this.state.size(), getLowestUncommittedSequenceNumber(), this.state.getLastSequenceNumber(), getElapsedSinceLastFlush().toMillis() / 1000);\n+    }\n+\n+    /**\n+     * Adds the given SegmentOperation to the Aggregator.\n+     *\n+     * @param operation the Operation to add.\n+     * @throws DataCorruptionException  If the validation of the given Operation indicates a possible data corruption in\n+     *                                  the code (offset gaps, out-of-order operations, etc.)\n+     * @throws IllegalArgumentException If the validation of the given Operation indicates a possible non-corrupting bug\n+     *                                  in the code.\n+     */\n+    @Override\n+    public void add(SegmentOperation operation) throws DataCorruptionException {\n+        Exceptions.checkNotClosed(isClosed(), this);\n+        Preconditions.checkArgument(\n+                operation.getStreamSegmentId() == this.metadata.getId(),\n+                \"Operation '%s' refers to a different Segment than this one (%s).\", operation, this.metadata.getId());\n+        if (isSegmentDeleted()) {\n+            return;\n+        }\n+\n+        boolean processed = false;\n+        if (operation instanceof StreamSegmentSealOperation) {\n+            this.state.seal();\n+            processed = true;\n+        } else if (operation instanceof AttributeUpdaterOperation) {\n+            AttributeUpdaterOperation op = (AttributeUpdaterOperation) operation;\n+            if (this.state.hasSeal()) {\n+                if (op.isInternal() && op.hasOnlyCoreAttributes()) {\n+                    log.debug(\"{}: Ignored internal operation on sealed segment {}.\", this.traceObjectId, operation);\n+                    return;\n+                } else {\n+                    throw new DataCorruptionException(String.format(\"Illegal operation for a sealed Segment; received '%s'.\", operation));\n+                }\n+            }\n+\n+            processed = this.state.include(op);\n+        }\n+\n+        if (processed) {\n+            log.debug(\"{}: Add {}; OpCount={}.\", this.traceObjectId, operation, this.state.size());\n+        }\n+    }\n+\n+    /**\n+     * Gets a value indicating whether a call to {@link #flush} is required given the current state of this aggregator.\n+     */\n+    @Override\n+    public boolean mustFlush() {\n+        if (isSegmentDeleted()) {\n+            // There isn't more that we can do.\n+            return false;\n+        }\n+\n+        return this.state.hasSeal()\n+                || this.state.size() >= this.config.getFlushAttributesThreshold()\n+                || (this.state.size() > 0 && getElapsedSinceLastFlush().compareTo(this.config.getFlushThresholdTime()) >= 0);\n+    }\n+\n+    /**\n+     * Flushes the contents of the Aggregator to the Storage.\n+     *\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that, when completed, will contain a summary of the flush operation. If any errors\n+     * occurred during the flush, the Future will be completed with the appropriate exception.\n+     */\n+    @Override\n+    public CompletableFuture<WriterFlushResult> flush(Duration timeout) {\n+        Exceptions.checkNotClosed(isClosed(), this);\n+        if (!mustFlush()) {\n+            return CompletableFuture.completedFuture(new WriterFlushResult());\n+        }\n+\n+        TimeoutTimer timer = new TimeoutTimer(timeout);\n+        CompletableFuture<Void> result = handleAttributeException(persistPendingAttributes(\n+                this.state.getAttributes(), this.state.getLastSequenceNumber(), timer));\n+        if (this.state.hasSeal()) {\n+            result = result.thenComposeAsync(v -> handleAttributeException(sealAttributes(timer)));\n+        }\n+\n+        return result.thenApply(v -> {\n+            if (this.state.size() > 0) {\n+                log.debug(\"{}: Flushed. Count={}, SeqNo={}-{}.\", this.traceObjectId, this.state.size(),\n+                        this.state.getFirstSequenceNumber(), this.state.getLastSequenceNumber());\n+            }\n+\n+            WriterFlushResult r = new WriterFlushResult();\n+            r.withFlushedAttributes(this.state.size());\n+            this.state.acceptChanges();\n+            this.lastFlush.set(this.timer.getElapsed());\n+            return r;\n+        });\n+    }\n+\n+    //endregion\n+\n+    //region Helpers\n+\n+    private CompletableFuture<Void> persistPendingAttributes(Map<UUID, Long> attributes, long lastSeqNo, TimeoutTimer timer) {\n+        if (attributes.isEmpty()) {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+\n+        return this.dataSource.persistAttributes(this.metadata.getId(), attributes, timer.getRemaining())\n+                .thenAcceptAsync(rootPointer -> queueRootPointerUpdate(rootPointer, lastSeqNo), this.executor);\n+    }\n+\n+    private CompletableFuture<Void> sealAttributes(TimeoutTimer timer) {\n+        log.debug(\"{}: Sealing Attribute Index.\", this.traceObjectId);\n+        return this.dataSource.sealAttributes(this.metadata.getId(), timer.getRemaining());\n+    }\n+\n+    public void queueRootPointerUpdate(long newRootPointer, long lastSeqNo) {\n+        if (this.lastRootPointer.getAndSet(new RootPointerInfo(newRootPointer, lastSeqNo)) == null) {\n+            // There was nothing else executing now.\n+            // Initiate an async loop that will execute as long as we have a new value.\n+            AtomicBoolean canContinue = new AtomicBoolean(this.lastRootPointer.get() != null);\n+            Futures.loop(\n+                    canContinue::get,\n+                    () -> {\n+                        RootPointerInfo rpi = this.lastRootPointer.get();\n+                        log.debug(\"{}: Updating Root Pointer info to {}.\", this.traceObjectId, rpi);\n+                        return this.dataSource.notifyAttributesPersisted(this.metadata.getId(), rpi.getRootPointer(), rpi.getLastSequenceNumber(), this.config.getFlushTimeout())\n+                                .whenCompleteAsync((r, ex) -> {\n+                                    if (ex != null) {\n+                                        log.error(\"{}: Unable to persist root pointer {}.\", this.traceObjectId, rpi, ex);\n+                                    } else {\n+                                        this.state.setLastPersistedSequenceNumber(rpi.getLastSequenceNumber());\n+                                    }\n+\n+                                    // Set the latest value to null ONLY if it hasn't changed in the meantime.\n+                                    if (this.lastRootPointer.compareAndSet(rpi, null)) {\n+                                        // No new value. Instruct the loop to stop processing.\n+                                        canContinue.set(false);\n+                                    }\n+                                }, this.executor);\n+\n+                    },\n+                    this.executor);\n+        }\n+    }\n+\n+    /**\n+     * Handles expected Attribute-related exceptions. Since the attribute index is a separate segment from the main one,\n+     * it is highly likely that it may get temporarily out of sync with the main one, thus causing spurious StreamSegmentSealedExceptions\n+     * or StreamSegmentNotExistsExceptions. If we get either of those, and they are consistent with our current state, the\n+     * we can safely ignore them; otherwise we should be rethrowing them.\n+     */\n+    private <T> CompletableFuture<T> handleAttributeException(CompletableFuture<T> future) {\n+        return Futures.exceptionallyExpecting(\n+                future,\n+                ex -> (ex instanceof StreamSegmentSealedException && this.metadata.isSealed())\n+                        || ((ex instanceof StreamSegmentNotExistsException || ex instanceof StreamSegmentMergedException)\n+                        && (this.metadata.isMerged() || this.metadata.isDeleted())),\n+                null);\n+    }\n+\n+    private boolean isSegmentDeleted() {\n+        return this.metadata.isDeleted() || this.metadata.isMerged();\n+    }\n+\n+    private Duration getElapsedSinceLastFlush() {\n+        return this.timer.getElapsed().minus(this.lastFlush.get());\n+    }\n+\n+    //endregion\n+\n+    //region RootPointer\n+\n+    @Data\n+    private static class RootPointerInfo {\n+        private final long rootPointer;\n+        private final long lastSequenceNumber;\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"RootPointer=%s, LastSeqNo=%s\", this.rootPointer, this.lastSequenceNumber);\n+        }\n+    }\n+\n+    //endregion\n+\n+    //region AggregatedAttributes\n+\n+    /**\n+     * Aggregates pending Attribute Updates.\n+     */\n+    private static class State {\n+        private final HashMap<UUID, Long> attributes;", "originalCommit": "6b3310d901a8a209c496900f4418f56b17138d90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxODQwNQ==", "url": "https://github.com/pravega/pravega/pull/4485#discussion_r367518405", "bodyText": "Good catch. Fixed.", "author": "andreipaduroiu", "createdAt": "2020-01-16T16:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NjkxNg=="}], "type": "inlineReview"}, {"oid": "36a6cc843d05b38fa47f40440d8d9c1ae1d9a604", "url": "https://github.com/pravega/pravega/commit/36a6cc843d05b38fa47f40440d8d9c1ae1d9a604", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-01-16T16:33:44Z", "type": "commit"}, {"oid": "1ff33ebb928312d561e034dd1756845a11d3de76", "url": "https://github.com/pravega/pravega/commit/1ff33ebb928312d561e034dd1756845a11d3de76", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-17T14:05:42Z", "type": "commit"}, {"oid": "a960ca12da9ebb37d3eb84b439f6e562185c4bb6", "url": "https://github.com/pravega/pravega/commit/a960ca12da9ebb37d3eb84b439f6e562185c4bb6", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-17T21:29:43Z", "type": "commit"}, {"oid": "702a15cb6e7b9ad2232b37e62c101bafb31ec16c", "url": "https://github.com/pravega/pravega/commit/702a15cb6e7b9ad2232b37e62c101bafb31ec16c", "message": "Merge branch 'master' into issue-4451-btree", "committedDate": "2020-01-17T23:28:23Z", "type": "commit"}]}