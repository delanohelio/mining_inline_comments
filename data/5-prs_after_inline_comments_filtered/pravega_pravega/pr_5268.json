{"pr_number": 5268, "pr_title": "Issue 5260: (SegmentStore) Adjustable Operation Priority Levels", "pr_createdAt": "2020-10-20T17:44:30Z", "pr_url": "https://github.com/pravega/pravega/pull/5268", "timeline": [{"oid": "00021683e10e26b42dcea506082bee7542977875", "url": "https://github.com/pravega/pravega/commit/00021683e10e26b42dcea506082bee7542977875", "message": "Defined OperationPriority.\nCreated PriorityBlockingDrainingQueue (+tests).\nIntegrated with CompletableOperation (+tests)\nIntegrated with OperationProcessor (no tests yet).\nIntegrated with DurableLog (no tests yet).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-16T20:42:10Z", "type": "commit"}, {"oid": "87fcc9368d1149a673dad70402b38258c16c2887", "url": "https://github.com/pravega/pravega/commit/87fcc9368d1149a673dad70402b38258c16c2887", "message": "Throttler: added a way to temporarily suspend throttling.\nOperationProcessor: wired up Throttler suspension (+ unit tests).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-16T23:29:07Z", "type": "commit"}, {"oid": "438c729dae67e71ee82f1cb938e25fa8c4a87528", "url": "https://github.com/pravega/pravega/commit/438c729dae67e71ee82f1cb938e25fa8c4a87528", "message": "Throttler: not going in a loop if max==true and suspended.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-17T13:41:14Z", "type": "commit"}, {"oid": "ee690e453c4bf526de3b2780a4f72c76492dc5e6", "url": "https://github.com/pravega/pravega/commit/ee690e453c4bf526de3b2780a4f72c76492dc5e6", "message": "DeleteSegmentOperations have OperationPriority.Critical.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-19T15:24:04Z", "type": "commit"}, {"oid": "b2f95f0debe7d2413d3db9431cb313be0ee25855", "url": "https://github.com/pravega/pravega/commit/b2f95f0debe7d2413d3db9431cb313be0ee25855", "message": "Attributes.ATTRIBUTE_SEGMENT_TYPE is used to store SegmentMetadata.getType. This is refreshed every time the SegmentMetadata is activated (loaded from a checkpoint) or from the MetadataStore (via StreamSegmentMapOperation).\nThis attribute is immutable once the segment is created. Some of its values may be inferred from existing attributes.\n\nStreamSegmentStore: Updated createStreamSegment to accept a SegmentType.\nTableStore: Updated createdSegment to accept SegmentType instead of \"boolean sorted\".\n\nPravegaRequestProcessor, TableBasedMetadataStore, TableMetadataStore: setting correct SegmentTypes on all created segments.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-20T01:06:13Z", "type": "commit"}, {"oid": "d1811935163cd13c681cb2e49be28ee7baaef38c", "url": "https://github.com/pravega/pravega/commit/d1811935163cd13c681cb2e49be28ee7baaef38c", "message": "All Segment Store Operations have OperationType. Deletion is the most exciting one.\nAdded OperationPriority.High - reserved for non-critical system segments.\nAdded PriorityCalculator that helps figure out operation priorities. Wired up in StreamSegmentContainer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-20T17:31:09Z", "type": "commit"}, {"oid": "2eb78b8b36e57832ca2bcdc75079a42d49bfa27f", "url": "https://github.com/pravega/pravega/commit/2eb78b8b36e57832ca2bcdc75079a42d49bfa27f", "message": "Retired OperationLog.add (without priority).\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-20T17:42:59Z", "type": "commit"}, {"oid": "2f6234a492400f28546c855fd1ee67e5f171228b", "url": "https://github.com/pravega/pravega/commit/2f6234a492400f28546c855fd1ee67e5f171228b", "message": "Merge remote-tracking branch 'origin/master' into issue-5260-qos", "committedDate": "2020-10-20T17:43:16Z", "type": "commit"}, {"oid": "19a3e88e13d3cbae6d018a23dca2e390a58ad9c5", "url": "https://github.com/pravega/pravega/commit/19a3e88e13d3cbae6d018a23dca2e390a58ad9c5", "message": "Updated unit tests for StreamSegmentContainer.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-20T20:21:05Z", "type": "commit"}, {"oid": "6c0d62922e139b56a629d5511a12a9890d3af2e6", "url": "https://github.com/pravega/pravega/commit/6c0d62922e139b56a629d5511a12a9890d3af2e6", "message": "Merge branch 'master' into issue-5260-qos", "committedDate": "2020-10-22T00:00:44Z", "type": "commit"}, {"oid": "70799524c8943a0bd347079a91c22919d6da2e43", "url": "https://github.com/pravega/pravega/commit/70799524c8943a0bd347079a91c22919d6da2e43", "message": "Merge remote-tracking branch 'origin/master' into issue-5260-qos\n\n# Conflicts:\n#\tsegmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImplTests.java", "committedDate": "2020-10-28T17:17:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MzQ4NA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516163484", "bodyText": "Should we add back the createSegment(String segmentName, Duration timeout)  overload that creates normal segments?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T18:08:58Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableStore.java", "diffHunk": "@@ -65,38 +66,23 @@\n      */\n     int MAXIMUM_VALUE_LENGTH = 1024 * 1024 - MAXIMUM_KEY_LENGTH;\n \n-    /**\n-     * Creates a new Segment and marks it as a Table Segment. This will be a non-sorted Table Segment.\n-     * See {@link #createSegment(String, boolean, Duration)} (invoked with sorted:=false).\n-     * This segment may not be used for Streaming purposes (i.e., it cannot be used with {@link StreamSegmentStore}).\n-     *\n-     * @param segmentName The name of the Table Segment to create.\n-     * @param timeout     Timeout for the operation.\n-     * @return A CompletableFuture that, when completed normally, will indicate the operation completed. If the operation\n-     * failed, the future will be failed with the causing exception. Notable Exceptions:\n-     * <ul>\n-     * <li>{@link StreamSegmentExistsException} If the Segment does exist (whether as a Table Segment or Stream Segment).\n-     * </ul>\n-     */\n-    default CompletableFuture<Void> createSegment(String segmentName, Duration timeout) {\n-        return createSegment(segmentName, false, timeout);\n-    }\n-\n     /**\n      * Creates a new Segment and marks it as a Table Segment.\n      * This segment may not be used for Streaming purposes (i.e., it cannot be used with {@link StreamSegmentStore}).\n      *\n      * @param segmentName The name of the Table Segment to create.\n-     * @param sorted      EXPERIMENTAL. If true, the created Table Segment will be a Sorted Table Segment, otherwise it\n-     *                    will be a plain Hash Table. See {@link TableStore} Javadoc for difference between the two.\n+     * @param segmentType Type of Segment to Create. If not already specified, this will automatically set the\n+     *                    {@link  SegmentType#isTableSegment()} to true. If {@link  SegmentType#isSortedTableSegment()}\n+     *                    is true, this will create a Sorted Table Segment (EXPERIMENTAL), otherwise it will be a plain\n+     *                    Hash Table. See {@link TableStore} Javadoc for difference between the two.\n      * @param timeout     Timeout for the operation.\n      * @return A CompletableFuture that, when completed normally, will indicate the operation completed. If the operation\n      * failed, the future will be failed with the causing exception. Notable Exceptions:\n      * <ul>\n      * <li>{@link StreamSegmentExistsException} If the Segment does exist (whether as a Table Segment or Stream Segment).\n      * </ul>\n      */\n-    CompletableFuture<Void> createSegment(String segmentName, boolean sorted, Duration timeout);\n+    CompletableFuture<Void> createSegment(String segmentName, SegmentType segmentType, Duration timeout);", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc0NTE3NA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516745174", "bodyText": "I thought about it. It would save some unit test churn. But the reason we had 2 overloads in the first place was because I was lazy to begin with and didn't want to update all unit tests.\nIMO, having 2 overloads is asking for even more overloads to be added in the future as we change things. SegmentType should encompass any type of segment that we would envision creating so I really did not want to have a \"default\" overload. Plus, what is \"normal\" anyway?", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MzQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NjcxNQ==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516166715", "bodyText": "cannot be modified", "author": "sachin-j-joshi", "createdAt": "2020-11-02T18:14:53Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/Attributes.java", "diffHunk": "@@ -98,6 +98,22 @@\n      */\n     public static final UUID ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO = new UUID(CORE_ATTRIBUTE_ID_PREFIX, 8);\n \n+    /**\n+     * Defines an attribute that is used to store the Segment's Type ({@link SegmentType#getValue()}.\n+     * This attribute cannot be modified once set on the Segment.\n+     */\n+    public static final UUID ATTRIBUTE_SEGMENT_TYPE = new UUID(CORE_ATTRIBUTE_ID_PREFIX, TABLE_ATTRIBUTES_START_OFFSET - 1);\n+\n+    /**\n+     * Determines whether the given attribute may NOT be modified once originally set on the Segment.", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2ODI0Mw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516168243", "bodyText": "why TABLE_ATTRIBUTES_START_OFFSET - 1 ?  why not 9?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T18:17:32Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/Attributes.java", "diffHunk": "@@ -98,6 +98,22 @@\n      */\n     public static final UUID ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO = new UUID(CORE_ATTRIBUTE_ID_PREFIX, 8);\n \n+    /**\n+     * Defines an attribute that is used to store the Segment's Type ({@link SegmentType#getValue()}.\n+     * This attribute cannot be modified once set on the Segment.\n+     */\n+    public static final UUID ATTRIBUTE_SEGMENT_TYPE = new UUID(CORE_ATTRIBUTE_ID_PREFIX, TABLE_ATTRIBUTES_START_OFFSET - 1);", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc0NzEwOQ==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516747109", "bodyText": "I forget why I did it this way originally. Thinking about it, there's wasn't really a good reason to do so. 9 will do.", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2ODI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MDI4Mw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516170283", "bodyText": "why not ROLE_CRITICAL = 0b0100_0000L | ROLE_INTERNAL also?\nWhat is the difference between internal and system ?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T18:21:08Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/SegmentType.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.contracts;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.segmentstore.contracts.tables.TableAttributes;\n+import java.util.Map;\n+import java.util.UUID;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Defines Segment Types. A Segment Type is a combination of Formats (how data are stored internally) and Roles (how is\n+ * the Segment used and how does the Segment Store rely on it).\n+ */\n+@RequiredArgsConstructor\n+public class SegmentType {\n+    //region Flags\n+\n+    /*\n+     * Note to developers: DO NOT CHANGE the number (bit) representations of the fields below. They are used for bitwise\n+     * concatenation and their values are stored as Segment Attributes. Changing them would break backwards compatibility.\n+     * Adding new values is OK. Do not reuse retired values. Carefully consider the addition of new values as there are\n+     * a maximum of 64 flags that can be set using this scheme.\n+     */\n+    @VisibleForTesting\n+    static final long FORMAT_BASIC = 0b0000_0000L;\n+    @VisibleForTesting\n+    static final long FORMAT_TABLE_SEGMENT = 0b0000_0001L;\n+    @VisibleForTesting\n+    static final long FORMAT_SORTED_TABLE_SEGMENT = 0b0000_0010L | FORMAT_TABLE_SEGMENT;\n+    @VisibleForTesting\n+    static final long ROLE_INTERNAL = 0b0001_0000L;\n+    @VisibleForTesting\n+    static final long ROLE_SYSTEM = 0b0010_0000L | ROLE_INTERNAL;\n+    @VisibleForTesting\n+    static final long ROLE_CRITICAL = 0b0100_0000L;", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc0OTg0NA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516749844", "bodyText": "The point of Internal is to differentiate between Segment Store-owned segments and external ones. In the future we may restrict access to such segments externally. All system segments are internal, but not all internal segments may require the \"elevated\" priority that system segments have.\nCritical segments need not necessarily be internal segments. The Controller may designate some segments (i.e., Event stream or whatever) as critical to the good functioning of the cluster. At this point we didn't label any of these as such, nor do we expose segment type via the Wire Protocol. But it is something that may be done in the future.", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MDI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwNzUyMw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516807523", "bodyText": "ok. So internal means only Segment Store-owned segments not \"pravega internal\"", "author": "sachin-j-joshi", "createdAt": "2020-11-03T16:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MDI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzM5OA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r517713398", "bodyText": "Precisely.", "author": "andreipaduroiu", "createdAt": "2020-11-05T00:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MDI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4Mjg3Mw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516182873", "bodyText": "predicates?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T18:44:46Z", "path": "segmentstore/contracts/src/test/java/io/pravega/segmentstore/contracts/SegmentTypeTests.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.contracts;\n+\n+import io.pravega.segmentstore.contracts.tables.TableAttributes;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.UUID;\n+import java.util.function.Predicate;\n+import lombok.val;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Unit tests for the {@link SegmentType} class.\n+ */\n+public class SegmentTypeTests {\n+\n+    /**\n+     * Tests all {@link SegmentType}s with a single value.\n+     */\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBuilder() {\n+        checkBuilder(SegmentType.builder().build(), SegmentType.FORMAT_BASIC);\n+        checkBuilder(SegmentType.builder().tableSegment().build(), SegmentType.FORMAT_TABLE_SEGMENT, SegmentType::isTableSegment);\n+        checkBuilder(SegmentType.builder().sortedTableSegment().build(), SegmentType.FORMAT_SORTED_TABLE_SEGMENT,\n+                SegmentType::isTableSegment, SegmentType::isSortedTableSegment);\n+        checkBuilder(SegmentType.builder().internal().build(), SegmentType.ROLE_INTERNAL, SegmentType::isInternal);\n+        checkBuilder(SegmentType.builder().system().build(), SegmentType.ROLE_SYSTEM, SegmentType::isSystem, SegmentType::isInternal);\n+        checkBuilder(SegmentType.builder().critical().build(), SegmentType.ROLE_CRITICAL, SegmentType::isCritical);\n+    }\n+\n+    /**\n+     * Tests {@link SegmentType#fromAttributes} and {@link SegmentType#intoAttributes}.\n+     */\n+    @Test\n+    public void testToFromAttributes() {\n+        val empty = SegmentType.fromAttributes(Collections.emptyMap());\n+        Assert.assertEquals(\"Empty attributes. \", SegmentType.FORMAT_BASIC, empty.getValue());\n+\n+        val baseType = SegmentType.builder().critical().internal().system().build();\n+        val segmentAttributes = new HashMap<UUID, Long>();\n+        Assert.assertTrue(baseType.intoAttributes(segmentAttributes));\n+        Assert.assertFalse(baseType.intoAttributes(segmentAttributes));\n+\n+        val nonTableSegment = SegmentType.fromAttributes(segmentAttributes);\n+        Assert.assertEquals(\"Non-table segment.\", baseType, nonTableSegment);\n+\n+        segmentAttributes.put(TableAttributes.INDEX_OFFSET, 0L);\n+        val simpleTableSegment = SegmentType.fromAttributes(segmentAttributes);\n+        val expectedSimpleSegment = SegmentType.builder(baseType).tableSegment().build();\n+        Assert.assertEquals(\"Simple Table Segment.\", expectedSimpleSegment, simpleTableSegment);\n+\n+        segmentAttributes.put(TableAttributes.SORTED, Attributes.BOOLEAN_FALSE);\n+        Assert.assertEquals(\"Simple Table Segment (Sorted==False).\", expectedSimpleSegment, SegmentType.fromAttributes(segmentAttributes));\n+\n+        segmentAttributes.put(TableAttributes.SORTED, Attributes.BOOLEAN_TRUE);\n+        val sortedTableSegment = SegmentType.fromAttributes(segmentAttributes);\n+        val expectedSortedSegment = SegmentType.builder(expectedSimpleSegment).sortedTableSegment().build();\n+        Assert.assertEquals(\"Sorted Table Segment.\", expectedSortedSegment, sortedTableSegment);\n+    }\n+\n+    private void checkBuilder(SegmentType type, long expectedValue, Predicate<SegmentType>... mustBeTrue) {", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4ODQ3NA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516188474", "bodyText": "Can we add these as static constants to SegmentType itself?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T18:55:11Z", "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -132,6 +133,9 @@\n     private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(PravegaRequestProcessor.class));\n     private static final int MAX_READ_SIZE = 2 * 1024 * 1024;\n     private static final String EMPTY_STACK_TRACE = \"\";\n+    private static final SegmentType STREAM_SEGMENT = SegmentType.builder().build();", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc1NTYyNQ==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516755625", "bodyText": "OK", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4ODQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5Njc2Mg==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516196762", "bodyText": "I am not sure I understood what is happening here. In earlier line we overwrote this.type from attributes, then why would this if condition ever be true?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T19:11:32Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/StreamSegmentMetadata.java", "diffHunk": "@@ -297,6 +299,14 @@ public synchronized void updateAttributes(Map<UUID, Long> attributes) {\n         });\n     }\n \n+    @Override\n+    public synchronized void refreshType() {\n+        this.type = SegmentType.fromAttributes(this.coreAttributes);\n+        if (this.type.intoAttributes(this.coreAttributes)) {", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc1ODUxMw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516758513", "bodyText": "Backwards compatibility. The Segment type does not exist prior to version 0.9 and segments may have already been created in upgraded clusters. We can still infer the format of the type (Stream/Table/SortedTable) by looking at existing attributes.", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5Njc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwMTg0Mg==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516201842", "bodyText": "This could be a static method.\nThere is no state here.", "author": "sachin-j-joshi", "createdAt": "2020-11-02T19:22:04Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/PriorityCalculator.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.logs;\n+\n+import io.pravega.segmentstore.contracts.SegmentType;\n+import io.pravega.segmentstore.server.logs.operations.OperationPriority;\n+import io.pravega.segmentstore.server.logs.operations.OperationType;\n+\n+/**\n+ * Calculates {@link OperationPriority} based on various factors.\n+ */\n+public final class PriorityCalculator {\n+\n+    /**\n+     * Determines an {@link OperationPriority} appropriate for the given {@link SegmentType} and {@link OperationType}.\n+     *\n+     * <pre>\n+     *\n+     * SegmentType       | OperationType | Priority\n+     * ------------------+---------------+----------------\n+     * System & Critical | (any)         | {@link OperationPriority#SystemCritical}\n+     * Critical          | (any)         | {@link OperationPriority#Critical}\n+     * (any)             | Deletion      | {@link OperationPriority#Critical}\n+     * System            | Normal        | {@link OperationPriority#High}\n+     * (all other combinations)          | {@link OperationPriority#Normal}\n+     *\n+     * </pre>\n+     *\n+     * @param segmentType   {@link SegmentType} that the Operation applies to.\n+     * @param operationType Operation's {@link OperationType}.\n+     * @return A {@link OperationPriority}.\n+     */\n+    public OperationPriority getPriority(SegmentType segmentType, OperationType operationType) {", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2MTE4NQ==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516761185", "bodyText": "We can do that for now.", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwMTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwODk5NA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516208994", "bodyText": "why not \"refresh\" it in updateAttributes itself?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T19:35:50Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/ContainerMetadataUpdateTransaction.java", "diffHunk": "@@ -468,6 +468,7 @@ private void updateMetadata(StreamSegmentMapOperation mapping, UpdateableSegment\n         }\n \n         metadata.updateAttributes(mapping.getAttributes());", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2MDI2OA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516760268", "bodyText": "I don't understand.", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwODk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwODM1Mw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516808353", "bodyText": "why can't updateAttributes itself do what refresh is doing?\nI think it will make it less error prone.\nI think you answered it below", "author": "sachin-j-joshi", "createdAt": "2020-11-03T16:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwODk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzY0NQ==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r517713645", "bodyText": "Yes - sorry I only understood your question the second time you brought it up. Does it makes sense now?", "author": "andreipaduroiu", "createdAt": "2020-11-05T00:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIwODk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMDE3Mw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516210173", "bodyText": "PriorityCalculator.getPriority could be static. We could avoid some allocations here.", "author": "sachin-j-joshi", "createdAt": "2020-11-02T19:38:15Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/StorageWriterFactory.java", "diffHunk": "@@ -107,13 +110,15 @@ public int getId() {\n         }\n \n         @Override\n-        public CompletableFuture<Void> notifyAttributesPersisted(long segmentId, long rootPointer, long lastSequenceNumber, Duration timeout) {\n+        public CompletableFuture<Void> notifyAttributesPersisted(long segmentId, SegmentType segmentType, long rootPointer,\n+                                                                 long lastSequenceNumber, Duration timeout) {\n             List<AttributeUpdate> updates = Arrays.asList(\n                     new AttributeUpdate(Attributes.ATTRIBUTE_SEGMENT_ROOT_POINTER, AttributeUpdateType.ReplaceIfGreater, rootPointer),\n                     new AttributeUpdate(Attributes.ATTRIBUTE_SEGMENT_PERSIST_SEQ_NO, AttributeUpdateType.Replace, lastSequenceNumber));\n             UpdateAttributesOperation op = new UpdateAttributesOperation(segmentId, updates);\n             op.setInternal(true); // This is internally generated, so we want to ensure it's accepted even on a sealed segment.\n-            return this.operationLog.add(op, timeout);\n+            OperationPriority priority = new PriorityCalculator().getPriority(segmentType, op.getType());", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjg2Mw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516212863", "bodyText": "Will this really cover al valid combinations?", "author": "sachin-j-joshi", "createdAt": "2020-11-02T19:43:30Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/MetadataStoreTestBase.java", "diffHunk": "@@ -80,16 +82,22 @@ protected int getThreadPoolSize() {\n     @Test\n     public void testCreateSegment() {\n         final int segmentCount = 50;\n+        val segmentTypes = Arrays.asList(\n+                SegmentType.builder().build(),\n+                SegmentType.builder().system().build(),\n+                SegmentType.builder().sortedTableSegment().build(),\n+                SegmentType.builder().critical().internal().build());\n \n         @Cleanup\n         TestContext context = createTestContext();\n \n         // Create some Segments and verify they are properly created and registered.\n         for (int i = 0; i < segmentCount; i++) {\n             String segmentName = getName(i);\n+            val segmentType = segmentTypes.get(i % segmentTypes.size());", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2MjY0Nw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516762647", "bodyText": "There are too many combinations to test. I created a few important ones a few lines above (Stream segment, system stream segment, sorted table segment and critical internal) which should cover all the bits that can be set. The point of this test is not to exhaustively test all possibilities (SegmentTypeTests does that), but to verify that this is properly stored in the metadata store when creating segments.", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMzgxMA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516213810", "bodyText": "why can't updateAttributes itself do what refresh is doing?\nI think it will make it less error prone.", "author": "sachin-j-joshi", "createdAt": "2020-11-02T19:45:12Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/containers/StreamSegmentMetadataTests.java", "diffHunk": "@@ -41,6 +43,45 @@\n     @Rule\n     public Timeout globalTimeout = Timeout.seconds(10);\n \n+    /**\n+     * Tests {@link StreamSegmentMetadata#getType()} and {@link StreamSegmentMetadata#refreshType()}.\n+     */\n+    @Test\n+    public void testSegmentType() {\n+        SegmentType expectedType = SegmentType.builder().build();\n+        StreamSegmentMetadata metadata = new StreamSegmentMetadata(SEGMENT_NAME, SEGMENT_ID, CONTAINER_ID);\n+        Assert.assertEquals(\"Unexpected value for non-initialized type.\", expectedType, metadata.getType());\n+\n+        // Segment type exists in Core attributes.\n+        expectedType = SegmentType.builder().critical().internal().build();\n+        metadata.updateAttributes(Collections.singletonMap(Attributes.ATTRIBUTE_SEGMENT_TYPE, expectedType.getValue()));\n+        metadata.refreshType();\n+        Assert.assertEquals(\"Unexpected value for single type.\", expectedType, metadata.getType());\n+\n+        // Segment type exists in Core attributes, but other attributes indicate this is a Table Segment.\n+        expectedType = SegmentType.builder(expectedType).tableSegment().build();\n+        metadata.updateAttributes(Collections.singletonMap(TableAttributes.INDEX_OFFSET, 0L));", "originalCommit": "70799524c8943a0bd347079a91c22919d6da2e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjc2NjkxMg==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516766912", "bodyText": "I want this externally accessible so I can unit test it properly.\nAlso, there are cases where updateAttributes is invoked where we need not invoke this one as well. One case involves deserialization of metadata, while another is the fact that once created, the segment type should never be changed, hence not invoking this everywhere.", "author": "andreipaduroiu", "createdAt": "2020-11-03T15:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMzgxMA=="}], "type": "inlineReview"}, {"oid": "41e1e46b425df79b734e70f449f11fac2940d34d", "url": "https://github.com/pravega/pravega/commit/41e1e46b425df79b734e70f449f11fac2940d34d", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-03T15:44:47Z", "type": "commit"}, {"oid": "d72267b2f0f6872733c96149802ab277597ce7b1", "url": "https://github.com/pravega/pravega/commit/d72267b2f0f6872733c96149802ab277597ce7b1", "message": "Merge branch 'master' into issue-5260-qos", "committedDate": "2020-11-03T15:47:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4OTU0NA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516889544", "bodyText": "Can new item with higher priority be inserted between getFirstIndex and getQueue?\nMore importantly does it matter in this case that we skipped over higher priority item in this case? If not then at least add a comment that explains the behavior.", "author": "sachin-j-joshi", "createdAt": "2020-11-03T18:59:31Z", "path": "common/src/main/java/io/pravega/common/util/PriorityBlockingDrainingQueue.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import lombok.val;\n+\n+/**\n+ * {@link AbstractDrainingQueue} implementation with multiple priority levels. Supports up to {@link Byte#MAX_VALUE}\n+ * priority levels, with Priority 0 being the highest.\n+ * <p>\n+ * Important notes:\n+ * - {@link #poll(int)} and {@link #take(int)} will return items with the highest available priority and will never mix\n+ * items with different priorities. That means that, even if there are more items (with lower priority), those will not\n+ * be included in the result even if the requested number of items exceeds what we can return. These (lower priority) items\n+ * may be retrieved using a subsequent call (assuming no higher priority items are added in the meantime).\n+ *\n+ * @param <T> Type of item,\n+ */\n+public class PriorityBlockingDrainingQueue<T extends PriorityBlockingDrainingQueue.Item> extends AbstractDrainingQueue<T> {\n+    //region Members.\n+    private final ArrayDeque[] queues;\n+    private int firstIndex;\n+    private int size;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link PriorityBlockingDrainingQueue} class.\n+     *\n+     * @param maxPriorityValue Maximum allowed priority value.\n+     */\n+    public PriorityBlockingDrainingQueue(byte maxPriorityValue) {\n+        Preconditions.checkArgument(maxPriorityValue >= 0, \"maxPriorityLevel must be a value between 0 and %s.\", Byte.MAX_VALUE);\n+        this.queues = new ArrayDeque[maxPriorityValue + 1];\n+        this.firstIndex = 0;\n+        this.size = 0;\n+    }\n+\n+    //endregion\n+\n+    //region AbstractDrainingQueue Implementation\n+\n+    @Override\n+    protected void addInternal(T item) {\n+        byte p = item.getPriorityValue();\n+        Preconditions.checkArgument(p >= 0 && p < this.queues.length,\n+                \"Item.getPriority() must be a value between 0 (inclusive) and %s (exclusive).\", this.queues.length);\n+        getOrCreateQueue(p).add(item);\n+        this.size++;\n+        if (this.firstIndex > p) {\n+            this.firstIndex = p;\n+        }\n+    }\n+\n+    @Override\n+    protected int sizeInternal() {\n+        return this.size;\n+    }\n+\n+    @Override\n+    protected T peekInternal() {\n+        if (this.size == 0) {\n+            return null;\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        return getQueue(fi).peekFirst();\n+    }\n+\n+    @Override\n+    protected Queue<T> fetch(int maxCount) {\n+        if (this.size == 0) {\n+            return new ArrayDeque<>(0);\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";", "originalCommit": "d72267b2f0f6872733c96149802ab277597ce7b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTI2OQ==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r517721269", "bodyText": "No. Because while invoking this method, we are holding the lock (from the super class). See this method's Javadoc in the superclass.", "author": "andreipaduroiu", "createdAt": "2020-11-05T01:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg4OTU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTY1OA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516891658", "bodyText": "If all queues are empty then we'll return -1 .\nThis will result in index out of bound", "author": "sachin-j-joshi", "createdAt": "2020-11-03T19:03:20Z", "path": "common/src/main/java/io/pravega/common/util/PriorityBlockingDrainingQueue.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import lombok.val;\n+\n+/**\n+ * {@link AbstractDrainingQueue} implementation with multiple priority levels. Supports up to {@link Byte#MAX_VALUE}\n+ * priority levels, with Priority 0 being the highest.\n+ * <p>\n+ * Important notes:\n+ * - {@link #poll(int)} and {@link #take(int)} will return items with the highest available priority and will never mix\n+ * items with different priorities. That means that, even if there are more items (with lower priority), those will not\n+ * be included in the result even if the requested number of items exceeds what we can return. These (lower priority) items\n+ * may be retrieved using a subsequent call (assuming no higher priority items are added in the meantime).\n+ *\n+ * @param <T> Type of item,\n+ */\n+public class PriorityBlockingDrainingQueue<T extends PriorityBlockingDrainingQueue.Item> extends AbstractDrainingQueue<T> {\n+    //region Members.\n+    private final ArrayDeque[] queues;\n+    private int firstIndex;\n+    private int size;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link PriorityBlockingDrainingQueue} class.\n+     *\n+     * @param maxPriorityValue Maximum allowed priority value.\n+     */\n+    public PriorityBlockingDrainingQueue(byte maxPriorityValue) {\n+        Preconditions.checkArgument(maxPriorityValue >= 0, \"maxPriorityLevel must be a value between 0 and %s.\", Byte.MAX_VALUE);\n+        this.queues = new ArrayDeque[maxPriorityValue + 1];\n+        this.firstIndex = 0;\n+        this.size = 0;\n+    }\n+\n+    //endregion\n+\n+    //region AbstractDrainingQueue Implementation\n+\n+    @Override\n+    protected void addInternal(T item) {\n+        byte p = item.getPriorityValue();\n+        Preconditions.checkArgument(p >= 0 && p < this.queues.length,\n+                \"Item.getPriority() must be a value between 0 (inclusive) and %s (exclusive).\", this.queues.length);\n+        getOrCreateQueue(p).add(item);\n+        this.size++;\n+        if (this.firstIndex > p) {\n+            this.firstIndex = p;\n+        }\n+    }\n+\n+    @Override\n+    protected int sizeInternal() {\n+        return this.size;\n+    }\n+\n+    @Override\n+    protected T peekInternal() {\n+        if (this.size == 0) {\n+            return null;\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        return getQueue(fi).peekFirst();\n+    }\n+\n+    @Override\n+    protected Queue<T> fetch(int maxCount) {\n+        if (this.size == 0) {\n+            return new ArrayDeque<>(0);\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";", "originalCommit": "d72267b2f0f6872733c96149802ab277597ce7b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTY0NA==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r517721644", "bodyText": "If all the queues are empty then the if(this.size == 0) above will fire and return an empty ArrayDequeue. So we shouldn't even get here anyway.", "author": "andreipaduroiu", "createdAt": "2020-11-05T01:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTg4MQ==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r516891881", "bodyText": "what happens when all queues are empty?", "author": "sachin-j-joshi", "createdAt": "2020-11-03T19:03:42Z", "path": "common/src/main/java/io/pravega/common/util/PriorityBlockingDrainingQueue.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import lombok.val;\n+\n+/**\n+ * {@link AbstractDrainingQueue} implementation with multiple priority levels. Supports up to {@link Byte#MAX_VALUE}\n+ * priority levels, with Priority 0 being the highest.\n+ * <p>\n+ * Important notes:\n+ * - {@link #poll(int)} and {@link #take(int)} will return items with the highest available priority and will never mix\n+ * items with different priorities. That means that, even if there are more items (with lower priority), those will not\n+ * be included in the result even if the requested number of items exceeds what we can return. These (lower priority) items\n+ * may be retrieved using a subsequent call (assuming no higher priority items are added in the meantime).\n+ *\n+ * @param <T> Type of item,\n+ */\n+public class PriorityBlockingDrainingQueue<T extends PriorityBlockingDrainingQueue.Item> extends AbstractDrainingQueue<T> {\n+    //region Members.\n+    private final ArrayDeque[] queues;\n+    private int firstIndex;\n+    private int size;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link PriorityBlockingDrainingQueue} class.\n+     *\n+     * @param maxPriorityValue Maximum allowed priority value.\n+     */\n+    public PriorityBlockingDrainingQueue(byte maxPriorityValue) {\n+        Preconditions.checkArgument(maxPriorityValue >= 0, \"maxPriorityLevel must be a value between 0 and %s.\", Byte.MAX_VALUE);\n+        this.queues = new ArrayDeque[maxPriorityValue + 1];\n+        this.firstIndex = 0;\n+        this.size = 0;\n+    }\n+\n+    //endregion\n+\n+    //region AbstractDrainingQueue Implementation\n+\n+    @Override\n+    protected void addInternal(T item) {\n+        byte p = item.getPriorityValue();\n+        Preconditions.checkArgument(p >= 0 && p < this.queues.length,\n+                \"Item.getPriority() must be a value between 0 (inclusive) and %s (exclusive).\", this.queues.length);\n+        getOrCreateQueue(p).add(item);\n+        this.size++;\n+        if (this.firstIndex > p) {\n+            this.firstIndex = p;\n+        }\n+    }\n+\n+    @Override\n+    protected int sizeInternal() {\n+        return this.size;\n+    }\n+\n+    @Override\n+    protected T peekInternal() {\n+        if (this.size == 0) {\n+            return null;\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        return getQueue(fi).peekFirst();\n+    }\n+\n+    @Override\n+    protected Queue<T> fetch(int maxCount) {\n+        if (this.size == 0) {\n+            return new ArrayDeque<>(0);\n+        }\n+\n+        int fi = getFirstIndex();\n+        assert fi >= 0 : \"size !=0 but firstIndex < 0\";\n+        val q = getQueue(fi);\n+\n+        int count = Math.min(maxCount, q.size());\n+        ArrayDeque<T> result = new ArrayDeque<>(count);\n+        while (result.size() < count) {\n+            result.addLast(q.pollFirst());\n+        }\n+\n+        this.size -= result.size();\n+        return result;\n+\n+    }\n+\n+    //endregion\n+\n+    //region Helper methods.\n+\n+    private int getFirstIndex() {\n+        for (; this.firstIndex < this.queues.length; this.firstIndex++) {\n+            val q = getQueue(this.firstIndex);\n+            if (q != null && !q.isEmpty()) {\n+                return this.firstIndex;\n+            }\n+        }\n+\n+        assert this.size > 0;", "originalCommit": "d72267b2f0f6872733c96149802ab277597ce7b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMTgyNw==", "url": "https://github.com/pravega/pravega/pull/5268#discussion_r517721827", "bodyText": "Returns -1. But see my comment above about how this is used.\nThe unit tests cover this case.", "author": "andreipaduroiu", "createdAt": "2020-11-05T01:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5MTg4MQ=="}], "type": "inlineReview"}]}