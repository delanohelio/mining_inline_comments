{"pr_number": 5239, "pr_title": "Issue 5233: (SegmentStore) Flush-to-Storage API", "pr_createdAt": "2020-10-07T21:12:22Z", "pr_url": "https://github.com/pravega/pravega/pull/5239", "timeline": [{"oid": "ab899b7c76a0e5fad5ba6b2b2e81119252502c3e", "url": "https://github.com/pravega/pravega/commit/ab899b7c76a0e5fad5ba6b2b2e81119252502c3e", "message": "Force Flush API.\nStorageWriter + SegmentAggregator + AttributeAggregator + Tests.\nMetadataCleaner + Tests\nStreamSegmentContainer + impl (needs tests).\nLogFlusher (needs tests)\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-07T00:20:26Z", "type": "commit"}, {"oid": "eb1555730f6247f4f038979fcce04559dbf31a8c", "url": "https://github.com/pravega/pravega/commit/eb1555730f6247f4f038979fcce04559dbf31a8c", "message": "unit tests for LogFlusher and StreamSegmentContainer. Bug fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-07T21:10:54Z", "type": "commit"}, {"oid": "3d71382cb726150f905f8348bfe59a92c4514611", "url": "https://github.com/pravega/pravega/commit/3d71382cb726150f905f8348bfe59a92c4514611", "message": "unit tests for LogFlusher and StreamSegmentContainer. Bug fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-07T21:12:40Z", "type": "commit"}, {"oid": "ff6dcb714e0ec65d3d14983e1def16c4da907c2f", "url": "https://github.com/pravega/pravega/commit/ff6dcb714e0ec65d3d14983e1def16c4da907c2f", "message": "Merge branch 'master' into issue-5233-flush", "committedDate": "2020-10-07T21:12:57Z", "type": "commit"}, {"oid": "4cc9c3800e93ec43dbf6959ce417cd7f085dee2a", "url": "https://github.com/pravega/pravega/commit/4cc9c3800e93ec43dbf6959ce417cd7f085dee2a", "message": "Fixed a possible concurrency bug.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-07T22:12:34Z", "type": "commit"}, {"oid": "d1820301b71b8963f78b51b1f39524199654c4fc", "url": "https://github.com/pravega/pravega/commit/d1820301b71b8963f78b51b1f39524199654c4fc", "message": "Merge branch 'master' into issue-5233-flush", "committedDate": "2020-10-08T19:13:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NTA0Ng==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503495046", "bodyText": "Not sure why we don't want to flush deleted and merged segment.", "author": "sachin-j-joshi", "createdAt": "2020-10-12T19:39:08Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/MetadataCleaner.java", "diffHunk": "@@ -100,6 +101,24 @@ protected void doStop() {\n \n     //endregion\n \n+    /**\n+     * Persists the metadata of all active Segments from the Container's metadata into the {@link MetadataStore}.\n+     * This method does not evict or otherwise perform any cleanup tasks on the Container or its Metadata, nor does it\n+     * interfere with the regular operation of {@link #runOnce()}.\n+     *\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that, when completed, indicates that the operation completed.\n+     */\n+    CompletableFuture<Void> persistAll(Duration timeout) {\n+        val tasks = this.metadata.getAllStreamSegmentIds().stream()\n+                .map(this.metadata::getStreamSegmentMetadata)\n+                .filter(Objects::nonNull)\n+                .filter(sm -> !sm.isDeleted() && !sm.isMerged())", "originalCommit": "d1820301b71b8963f78b51b1f39524199654c4fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU0MzI0MQ==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503543241", "bodyText": "The previous step in LogFlusher (before this is invoked) tells the StorageWriter to apply all the outstanding changes to Storage. That includes any deletions or mergers. Those segments' metadata may still linger in memory (not evicted yet) and should be treated as garbage. No need to write them down here.\nIf you look in the runOnceInternal method in this class (the one that does evictions), you'll see similar logic.", "author": "andreipaduroiu", "createdAt": "2020-10-12T21:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5ODY3Nw==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503498677", "bodyText": "What happens when there is nothing to flush?", "author": "sachin-j-joshi", "createdAt": "2020-10-12T19:48:31Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/WriterState.java", "diffHunk": "@@ -122,6 +129,57 @@ long getLastReadSequenceNumber() {\n     void setLastReadSequenceNumber(long value) {\n         Preconditions.checkArgument(value >= this.lastReadSequenceNumber.get(), \"New LastReadSequenceNumber cannot be smaller than the previous one.\");\n         this.lastReadSequenceNumber.set(value);\n+        recordReadComplete();\n+    }\n+\n+    /**\n+     * Indicates the fact that the {@link StorageWriter} has completed reading.\n+     */\n+    void recordReadComplete() {\n+        val ffc = this.forceFlushContext.get();\n+        if (ffc != null) {\n+            ffc.setLastReadSequenceNumber(this.lastReadSequenceNumber.get());\n+        }\n+    }\n+\n+    /**\n+     * Indicates the fact that the {@link StorageWriter} has completed a flush stage.\n+     *\n+     * @param result The {@link WriterFlushResult} summarizing the flush stage.\n+     */\n+    void recordFlushComplete(WriterFlushResult result) {\n+        val ffc = this.forceFlushContext.get();\n+        if (ffc != null && ffc.flushComplete(result)) {\n+            this.forceFlushContext.set(null);\n+            ffc.getCompletion().complete(ffc.isAnythingFlushed());", "originalCommit": "d1820301b71b8963f78b51b1f39524199654c4fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU0NDIwMQ==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503544201", "bodyText": "The StorageWriter may execute multiple iterations until it is able to complete this. When requested to force flush, it sets a context, and as long as that context is present, the Storage Writer will forcefully try to flush everything, read more data, flush, etc., until the requested \"flush-to\" sequence number has been processed.", "author": "andreipaduroiu", "createdAt": "2020-10-12T21:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5ODY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY3MzM0Mg==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503673342", "bodyText": "Should it be mustFlush instead of mustFlush()?", "author": "ManishKumarKeshri", "createdAt": "2020-10-13T05:21:33Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/WriterSegmentProcessor.java", "diffHunk": "@@ -54,9 +54,22 @@\n     /**\n      * Flushes the contents of the Processor.\n      *\n+     * @param force   If true, force-flushes everything accumulated in the {@link WriterSegmentProcessor}, regardless of\n+     *                the value returned by {@link #mustFlush()}.", "originalCommit": "d1820301b71b8963f78b51b1f39524199654c4fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNDQwMg==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r504134402", "bodyText": "Both are acceptable for Javadoc generation. The former will link to any method matching that name, while the latter will link to a specific method overload (looking at parameters, signature, etc.).", "author": "andreipaduroiu", "createdAt": "2020-10-13T17:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY3MzM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY5Mzc0MA==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503693740", "bodyText": "Will MAX_FLUSH_ATTEMPTS be reached before flushing all operations? I mean, what if there is still something to flush after attemptNo has reached to MAX_FLUSH_ATTEMPTS.", "author": "ManishKumarKeshri", "createdAt": "2020-10-13T06:23:37Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/LogFlusher.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.containers;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.TimeoutTimer;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.util.RetriesExhaustedException;\n+import io.pravega.segmentstore.server.OperationLog;\n+import io.pravega.segmentstore.server.Writer;\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+\n+/**\n+ * Utility class that helps the {@link StreamSegmentContainer} to force-flush all the data to the underlying Storage.\n+ */\n+@RequiredArgsConstructor\n+@Slf4j\n+class LogFlusher {\n+    /**\n+     * Maximum number of {@link Writer} flushes to attempt until no more flush progress is expected to be made.\n+     */\n+    @VisibleForTesting\n+    static final int MAX_FLUSH_ATTEMPTS = 10;\n+    private final int containerId;\n+    @NonNull\n+    private final OperationLog durableLog;\n+    @NonNull\n+    private final Writer writer;\n+    @NonNull\n+    private final MetadataCleaner metadataCleaner;\n+    @NonNull\n+    private final ScheduledExecutorService executor;\n+\n+    /**\n+     * Flushes every outstanding Operation in the Container's {@link OperationLog} to Storage. When this method completes:\n+     * - Every Operation that has been initiated in the {@link OperationLog} prior to the invocation of this method\n+     * will be flushed to the Storage via the {@link Writer}.\n+     * - The effects of such Operations on the Container's Metadata will be persisted to the Container's Metadata Store.\n+     * - The Container's Metadata Store will be persisted (and fully indexed) in Storage (it will contain all changes\n+     * from the previous step).\n+     *\n+     * @param timeout Timeout for the operation.\n+     * @return A CompletableFuture that, when completed, will indicate that the operation completed successfully. If the\n+     * operation failed, it will be failed with the appropriate exception.\n+     */\n+    public CompletableFuture<Void> flushToStorage(Duration timeout) {\n+        // 1. Flush everything we have so far.\n+        // 2. Flush all in-memory Segment metadata to the Metadata Store.\n+        // 3. Flush everything we have so far (again) - to make sure step 2 is persisted in Storage.\n+        TimeoutTimer timer = new TimeoutTimer(timeout);\n+        log.info(\"LogFlusher[{}]: Flushing outstanding data.\", this.containerId);\n+        return flushAll(timer)\n+                .thenComposeAsync(v -> {\n+                    log.info(\"LogFlusher[{}]: Persisting active segment metadata.\", this.containerId);\n+                    return this.metadataCleaner.persistAll(timer.getRemaining());\n+                }, this.executor)\n+                .thenComposeAsync(v -> {\n+                    log.info(\"LogFlusher[{}]: Flushing metadata store.\", this.containerId);\n+                    return flushAll(timer);\n+                }, this.executor);\n+    }\n+\n+    private CompletableFuture<Void> flushAll(TimeoutTimer timer) {\n+        // 1. Queue a checkpoint and get its SeqNo. This is poor man's way of ensuring all initiated ops are in.\n+        // 2. Tell StorageWriter to flush all (new API, with seqNo). Includes: segment data and table segment indexing.\n+        // 3. Repeat 1+2 until StorageWriter claims there is nothing more to flush.\n+        val flushAgain = new AtomicBoolean(true);\n+        val attemptNo = new AtomicInteger(0);\n+        return Futures.loop(\n+                () -> flushAgain.get() && attemptNo.getAndIncrement() < MAX_FLUSH_ATTEMPTS,", "originalCommit": "d1820301b71b8963f78b51b1f39524199654c4fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNjE3MA==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r504136170", "bodyText": "MAX_FLUSH_ATTEMPTS is set to 10. At each attempt, it records a checkpoint into the Tier 1 log, gets its sequence number, and tells the Storage Writer to flush everything up to and including that seq no. The Storage Writer will not complete until it has finished doing so. This qualifies as one \"attempt\".\nHowever, a Storage Writer iteration may produce side effects that get added to Tier 1 (i.e., for Table Segments, new data and/or attributes may be written) - we must make sure that all these get persisted to Storage as well. These should take at most one or two extra iterations, but to add a bit of buffer, I gave it up to 10 attempts to converge.", "author": "andreipaduroiu", "createdAt": "2020-10-13T17:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY5Mzc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwMzUwOQ==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503703509", "bodyText": "#mustFlush, as I see in other places.", "author": "ManishKumarKeshri", "createdAt": "2020-10-13T06:46:58Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/AttributeAggregator.java", "diffHunk": "@@ -190,14 +190,16 @@ public boolean mustFlush() {\n     /**\n      * Flushes the contents of the Aggregator to the Storage.\n      *\n+     * @param force   If true, force-flushes everything accumulated in the {@link AttributeAggregator}, regardless of\n+     *                the value returned by {@link #mustFlush()}.", "originalCommit": "d1820301b71b8963f78b51b1f39524199654c4fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNjMyNg==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r504136326", "bodyText": "See above.", "author": "andreipaduroiu", "createdAt": "2020-10-13T17:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwMzUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc3MDExNg==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r503770116", "bodyText": "One question: why didn't you use INFREQUENT_FLUSH_WRITER_CONFIG?", "author": "ManishKumarKeshri", "createdAt": "2020-10-13T08:38:04Z", "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/writer/SegmentAggregatorTests.java", "diffHunk": "@@ -683,6 +683,55 @@ public void testFlushEmptyAppend() throws Exception {\n         verifySegmentData(expectedData, context);\n     }\n \n+    /**\n+     * Tests the flush() method with the force flag set.\n+     * Verifies both length-based and time-based flush triggers, as well as flushing rather large operations.\n+     */\n+    @Test\n+    public void testFlushForced() throws Exception {\n+        final WriterConfig config = DEFAULT_CONFIG;", "originalCommit": "d1820301b71b8963f78b51b1f39524199654c4fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzNzU1Ng==", "url": "https://github.com/pravega/pravega/pull/5239#discussion_r504137556", "bodyText": "That one isn't defined here.\nIf you look below (lines 714-719), it doesn't matter. I invoke flush (normal) and validate it had no effect. Then I invoked flush (forced), without changing anything else, and validate it flushed everything.", "author": "andreipaduroiu", "createdAt": "2020-10-13T17:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc3MDExNg=="}], "type": "inlineReview"}]}