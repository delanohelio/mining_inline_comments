{"pr_number": 4786, "pr_title": "Issue 4771: (Key Value Tables) Exposing KVTs as Java Maps", "pr_createdAt": "2020-05-12T22:40:52Z", "pr_url": "https://github.com/pravega/pravega/pull/4786", "timeline": [{"oid": "fe34d043e507d2fd098ffe7391b986cc8dd88c4c", "url": "https://github.com/pravega/pravega/commit/fe34d043e507d2fd098ffe7391b986cc8dd88c4c", "message": "MapWrapper, MapWrapperImpl.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-05-05T23:12:13Z", "type": "commit"}, {"oid": "20d24595adf35e298de1c4fa51b8efa0d38d0130", "url": "https://github.com/pravega/pravega/commit/20d24595adf35e298de1c4fa51b8efa0d38d0130", "message": "Unit tests for MapWrapper.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-05-07T21:55:45Z", "type": "commit"}, {"oid": "91e478fd30c0997b89bec3ea65ff8ccf14e2d773", "url": "https://github.com/pravega/pravega/commit/91e478fd30c0997b89bec3ea65ff8ccf14e2d773", "message": "Spotbugs.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-05-08T14:21:10Z", "type": "commit"}, {"oid": "f9b18f58d57d8c700143afbcae3a6cefa13d15e6", "url": "https://github.com/pravega/pravega/commit/f9b18f58d57d8c700143afbcae3a6cefa13d15e6", "message": "Iterator.remove, Javadoc and more tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-05-12T22:05:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3ODI3Mg==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r429478272", "bodyText": "This is a very poor name. Because this is a public API please pick one that defines it from a user's point of view.", "author": "tkaitchuck", "createdAt": "2020-05-22T22:25:53Z", "path": "client/src/main/java/io/pravega/client/tables/MapWrapper.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import lombok.NonNull;\n+\n+/**\n+ * {@link Map} implementation for a {@link KeyValueTable}'s Key Family.\n+ * <p>\n+ * All methods inherited from {@link Map} respect the contracts defined in that interface, except as noted below.\n+ * <p><p>\n+ * Performance considerations:\n+ * <ul>\n+ * <li> The {@link Map} interface defines synchronous operations, however {@link KeyValueTable} defines async operations.\n+ * All methods implementations defined in this interface or inherited from {@link Map} invoke\n+ * {@link CompletableFuture#join()} on any {@link KeyValueTable} methods invoked. This means that two threads are used\n+ * to fulfill these calls: one from the Executor passed in to the {@link KeyValueTable} factory, and one on which this\n+ * request is executing.\n+ *\n+ * <li> The following operations result in a single call to the wrapped {@link KeyValueTable}:\n+ * <ul>\n+ * <li> {@link #containsKey}.\n+ * <li> {@link #get}, {@link #getOrDefault}.\n+ * <li> {@link #putDirect}, {@link #putAll}, {@link #putIfAbsent}.\n+ * <li> {@link #removeDirect}.\n+ * <li> {@link #isEmpty()} (Invokes {@link KeyValueTable#keyIterator} and requests a single item).\n+ * <li> {@link #keySet()}: {@link Set#removeAll}, {@link Set#contains}, {@link Set#containsAll}, {@link Set#isEmpty()}.\n+ * <li> {@link #entrySet()}: {@link Set#contains}, {@link Set#containsAll}, {@link Set#isEmpty()}, {@link Set#add}, {@link Set#addAll}.\n+ * </ul>\n+ *\n+ * <li> The following operations result up to two calls to the wrapped {@link KeyValueTable}:\n+ * <ul>\n+ * <li> {@link #put} (refer to {{@link #putDirect} if the old value is not needed).\n+ * <li> {@link #replace}.\n+ * <li> {@link #remove} (refer to {@link #removeDirect} if the old value is not needed).\n+ * <li> {@link #computeIfPresent}, {@link #compute}}, {@link #computeIfAbsent}.\n+ * <li> {@link #keySet()}{@link Set#remove}.\n+ * <li> {@link #entrySet()}: {@link Set#removeAll}, {@link Set#isEmpty()}.\n+ * </ul>\n+ *\n+ * <li> The following operations may result in iterating through all the Keys using {@link KeyValueTable#keyIterator}:\n+ * <ul>\n+ * <li> {@link #keySet()}{@link Set#iterator()} (Iterates as {@link Iterator#hasNext()} or {@link Iterator#next()} are\n+ * invoked. Calls to {@link Iterator#remove()} will result in a single call to {@link KeyValueTable}).\n+ * <li> {@link #size()} (Iterates through the entire iterator).\n+ * <li> {@link #clear()} (Iterates through the entire iterator and makes repeated calls to {@link KeyValueTable#removeAll}).\n+ * <li> {@link #keySet()}: {@link Set#clear()}, {@link Set#removeIf}, {@link Set#retainAll}.\n+ * </ul>\n+ *\n+ * <li>The following operations may result in iterating through all the Entries using {@link KeyValueTable#entryIterator}:\n+ * <ul>\n+ * <li> {@link #containsValue}.\n+ * <li> {@link #replaceAll} (which makes multiple calls to {@link KeyValueTable#putAll} as well).\n+ * <li> {@link #entrySet()}{@link Set#iterator()} (Iterates as {@link Iterator#hasNext()} or {@link Iterator#next()} are\n+ * invoked. Calls to {@link Iterator#remove()} will result in a single call to {@link KeyValueTable}).\n+ * <li> {@link #entrySet()}: {@link Set#removeIf}, {@link Set#retainAll}\n+ * <li> All operations on {@link #values()}.\n+ * </ul>\n+ * <li>Invocations of {@link Collection#stream()}}, {@link Collection#spliterator()} or {@link Collection#toArray()} on\n+ * {@link #keySet()}, {@link #entrySet()} or {@link #values()} will invoke those collections' iterators (see above).\n+ * </ul>\n+ * <p><p>\n+ * The following operations are not supported (will throw {@link UnsupportedOperationException}) if\n+ * {@link #getKeyFamily()} is null):\n+ * <ul>\n+ * <li>{@link #containsValue}.\n+ * <li>{@link #putAll}.\n+ * <li>{@link #replaceAll}.\n+ * <li>{@link #keySet()}.\n+ * <li>{@link #values()}.\n+ * <li>{@link #entrySet()}.\n+ * <li>{@link #size()}.\n+ * <li>{@link #isEmpty()}.\n+ * <li>{@link #clear()}.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface MapWrapper<KeyT, ValueT> extends Map<KeyT, ValueT> {", "originalCommit": "f9b18f58d57d8c700143afbcae3a6cefa13d15e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0NjUyNw==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430546527", "bodyText": "Renamed to KeyValueTableMap", "author": "andreipaduroiu", "createdAt": "2020-05-26T16:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3ODI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3ODQ5Mg==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r429478492", "bodyText": "Perhaps instead of as which implies a transformation of this object, it should be getMapFor or something to indicate it's tied to a keyFamily.", "author": "tkaitchuck", "createdAt": "2020-05-22T22:27:05Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -280,4 +280,19 @@\n      */\n     @Override\n     void close();\n+\n+    /**\n+     * Exposes this {@link KeyValueTable} instance as a {@link Map}. Please refer to the {@link MapWrapper} documentation\n+     * for special cases and limitations.\n+     * <p>\n+     * This is useful for integrating code that expects to deal with a {@link Map}. Not all the {@link KeyValueTable}\n+     * functionality can be implemented using a {@link Map}, however the {@link Map} interface is fully implemented.\n+     *\n+     * @param keyFamily (Optional) The Key Family to create the {@link MapWrapper} for. Any operations on the returned\n+     *                  {@link MapWrapper} will only affect this Key Family. If no Key Family is provided (null), then\n+     *                  certain {@link MapWrapper} APIs may not be supported. Refer to {@link MapWrapper} documentation\n+     *                  for more details.\n+     * @return A new {@link MapWrapper} instance bound to this {@link KeyValueTable} and Key Family.\n+     */\n+    MapWrapper<KeyT, ValueT> asMap(@Nullable String keyFamily);", "originalCommit": "f9b18f58d57d8c700143afbcae3a6cefa13d15e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0MzEwNg==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430543106", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-05-26T16:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3ODQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NDYxNw==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r429494617", "bodyText": "This seems odd...", "author": "tkaitchuck", "createdAt": "2020-05-23T00:13:00Z", "path": "client/src/main/java/io/pravega/client/tables/impl/MapWrapperImpl.java", "diffHunk": "@@ -0,0 +1,668 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import com.google.common.base.Functions;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.client.tables.BadKeyVersionException;\n+import io.pravega.client.tables.ConditionalTableUpdateException;\n+import io.pravega.client.tables.MapWrapper;\n+import io.pravega.client.tables.TableEntry;\n+import io.pravega.client.tables.TableKey;\n+import io.pravega.client.tables.Version;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.util.Retry;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+\n+/**\n+ * Implementation of {@link MapWrapper}.\n+ *\n+ * @param <KeyT>   Key Type.\n+ * @param <ValueT> Value Type.\n+ */\n+@RequiredArgsConstructor\n+@SuppressWarnings({\"unchecked\", \"NullableProblems\"})", "originalCommit": "f9b18f58d57d8c700143afbcae3a6cefa13d15e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMjgzNg==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430532836", "bodyText": "Unchecked is because the Map API uses Object for arguments.\nNullableProblems is because of annotations on the Map interface which the compiler complains about because it doesn't map those to the Lombok equivalents.", "author": "andreipaduroiu", "createdAt": "2020-05-26T16:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NDYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NTA5MA==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r429495090", "bodyText": "Objects.equals already handles this null case.", "author": "tkaitchuck", "createdAt": "2020-05-23T00:16:03Z", "path": "client/src/main/java/io/pravega/client/tables/impl/MapWrapperImpl.java", "diffHunk": "@@ -0,0 +1,668 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import com.google.common.base.Functions;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.client.tables.BadKeyVersionException;\n+import io.pravega.client.tables.ConditionalTableUpdateException;\n+import io.pravega.client.tables.MapWrapper;\n+import io.pravega.client.tables.TableEntry;\n+import io.pravega.client.tables.TableKey;\n+import io.pravega.client.tables.Version;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.util.Retry;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.val;\n+\n+/**\n+ * Implementation of {@link MapWrapper}.\n+ *\n+ * @param <KeyT>   Key Type.\n+ * @param <ValueT> Value Type.\n+ */\n+@RequiredArgsConstructor\n+@SuppressWarnings({\"unchecked\", \"NullableProblems\"})\n+final class MapWrapperImpl<KeyT, ValueT> implements MapWrapper<KeyT, ValueT> {\n+    private static final int ITERATOR_BATCH_SIZE = 100;\n+    private static final Retry.RetryAndThrowExceptionally<ConditionalTableUpdateException, RuntimeException> RETRY = Retry\n+            .withExpBackoff(10, 4, 10, 30000)\n+            .retryingOn(ConditionalTableUpdateException.class)\n+            .throwingOn(RuntimeException.class);\n+    @NonNull\n+    private final KeyValueTableImpl<KeyT, ValueT> kvt;\n+    @Getter\n+    private final String keyFamily;\n+\n+    //region Map Implementation\n+\n+    @Override\n+    public boolean containsKey(@NonNull Object key) {\n+        val e = this.kvt.get(this.keyFamily, (KeyT) key).join();\n+        return e != null;\n+    }\n+\n+    @Override\n+    public boolean containsValue(@NonNull Object o) {\n+        requiresKeyFamily(\"containsValue\");\n+        ValueT value = (ValueT) o;\n+        return entryStream().anyMatch(e -> areSame(e.getValue(), value));\n+    }\n+\n+    @Override\n+    public ValueT get(@NonNull Object key) {\n+        val e = this.kvt.get(this.keyFamily, (KeyT) key).join();\n+        return e == null ? null : e.getValue();\n+    }\n+\n+    @Override\n+    public ValueT getOrDefault(@NonNull Object key, ValueT defaultValue) {\n+        ValueT value = get(key);\n+        return value == null ? defaultValue : value;\n+    }\n+\n+    @Override\n+    public ValueT put(@NonNull KeyT key, @NonNull ValueT value) {\n+        val oldValue = new AtomicReference<ValueT>();\n+        this.kvt.get(this.keyFamily, key)\n+                .thenCompose(existingEntry -> {\n+                    oldValue.set(existingEntry == null ? null : existingEntry.getValue());\n+                    return this.kvt.put(this.keyFamily, key, value);\n+                })\n+                .join();\n+        return oldValue.get();\n+    }\n+\n+    @Override\n+    public void putDirect(@NonNull KeyT key, @NonNull ValueT value) {\n+        this.kvt.put(this.keyFamily, key, value).join();\n+    }\n+\n+    @Override\n+    public void putAll(@NonNull Map<? extends KeyT, ? extends ValueT> map) {\n+        requiresKeyFamily(\"putAll\");\n+\n+        // Need to go through a few hoops to get rid of the class capture that we were forced into with the Map interface.\n+        val iterator = Iterators.transform(map.entrySet().iterator(), e -> (Map.Entry<KeyT, ValueT>) e);\n+        this.kvt.putAll(this.keyFamily, iterator).join();\n+    }\n+\n+    @Override\n+    public ValueT putIfAbsent(@NonNull KeyT key, @NonNull ValueT value) {\n+        return Futures.exceptionallyComposeExpecting(\n+                this.kvt.putIfAbsent(this.keyFamily, key, value).thenApply(version -> value),\n+                ex -> ex instanceof BadKeyVersionException,\n+                () -> this.kvt.get(this.keyFamily, key).thenApply(TableEntry::getValue))\n+                .join();\n+    }\n+\n+    @Override\n+    public boolean replace(@NonNull KeyT key, @NonNull ValueT expectedValue, @NonNull ValueT newValue) {\n+        return RETRY.run(\n+                () -> this.kvt.get(this.keyFamily, key)\n+                        .thenCompose(e -> {\n+                            if (e != null && areSame(expectedValue, e.getValue())) {\n+                                return this.kvt.replace(this.keyFamily, key, newValue, e.getKey().getVersion())\n+                                        .thenApply(v -> true);\n+                            } else {\n+                                return CompletableFuture.completedFuture(false);\n+                            }\n+                        }).join());\n+    }\n+\n+    @Override\n+    public ValueT replace(@NonNull KeyT key, @NonNull ValueT value) {\n+        return RETRY.run(\n+                () -> this.kvt.get(this.keyFamily, key)\n+                        .thenCompose(e -> {\n+                            if (e != null) {\n+                                return this.kvt.replace(this.keyFamily, key, value, e.getKey().getVersion())\n+                                        .thenApply(v -> e.getValue());\n+                            } else {\n+                                return CompletableFuture.completedFuture(null);\n+                            }\n+                        }).join());\n+    }\n+\n+    @Override\n+    public void replaceAll(@NonNull BiFunction<? super KeyT, ? super ValueT, ? extends ValueT> convert) {\n+        requiresKeyFamily(\"replaceAll\");\n+        val baseIterator = this.kvt.entryIterator(this.keyFamily, ITERATOR_BATCH_SIZE, null).asIterator();\n+        val updateFutures = new ArrayList<CompletableFuture<List<Version>>>();\n+        while (baseIterator.hasNext()) {\n+            val toUpdate = baseIterator.next().getItems().stream()\n+                    .map(e -> (Map.Entry<KeyT, ValueT>) new AbstractMap.SimpleImmutableEntry<KeyT, ValueT>(\n+                            e.getKey().getKey(),\n+                            convert.apply(e.getKey().getKey(), e.getValue())))\n+                    .iterator();\n+            if (toUpdate.hasNext()) {\n+                updateFutures.add(kvt.putAll(keyFamily, toUpdate));\n+            }\n+        }\n+\n+        if (updateFutures.size() > 0) {\n+            Futures.allOf(updateFutures).join();\n+        }\n+    }\n+\n+    @Override\n+    public ValueT remove(@NonNull Object key) {\n+        KeyT k = (KeyT) key;\n+        val existingValue = new AtomicReference<ValueT>();\n+        RETRY.run(\n+                () -> this.kvt.get(this.keyFamily, k)\n+                        .thenCompose(e -> {\n+                            if (e == null) {\n+                                existingValue.set(null);\n+                                return this.kvt.remove(this.keyFamily, k);\n+                            } else {\n+                                existingValue.set(e.getValue());\n+                                return this.kvt.remove(this.keyFamily, k, e.getKey().getVersion());\n+                            }\n+                        }).join());\n+        return existingValue.get();\n+    }\n+\n+    @Override\n+    public boolean remove(@NonNull Object key, Object expectedValue) {\n+        KeyT k = (KeyT) key;\n+        ValueT ev = (ValueT) expectedValue;\n+        return RETRY.run(\n+                () -> this.kvt.get(this.keyFamily, k)\n+                        .thenCompose(e -> {\n+                            if (e != null && areSame(ev, e.getValue())) {\n+                                return this.kvt.remove(this.keyFamily, k, e.getKey().getVersion()).thenApply(v -> true);\n+                            } else {\n+                                return CompletableFuture.completedFuture(false);\n+                            }\n+                        }).join());\n+    }\n+\n+    @Override\n+    public void removeDirect(KeyT key) {\n+        this.kvt.remove(this.keyFamily, key).join();\n+    }\n+\n+    @Override\n+    public ValueT compute(@NonNull KeyT key, @NonNull BiFunction<? super KeyT, ? super ValueT, ? extends ValueT> toCompute) {\n+        ValueT existingValue = get(key);\n+        ValueT newValue = toCompute.apply(key, existingValue);\n+        if (newValue == null) {\n+            if (existingValue != null) {\n+                removeDirect(key);\n+            }\n+\n+            return null;\n+        } else {\n+            if (!areSame(existingValue, newValue)) {\n+                putDirect(key, newValue);\n+            }\n+            return newValue;\n+        }\n+    }\n+\n+    @Override\n+    public ValueT computeIfPresent(@NonNull KeyT key, BiFunction<? super KeyT, ? super ValueT, ? extends ValueT> toCompute) {\n+        ValueT existingValue = get(key);\n+        if (existingValue != null) {\n+            ValueT newValue = toCompute.apply(key, existingValue);\n+            if (newValue != null) {\n+                if (!areSame(existingValue, newValue)) {\n+                    putDirect(key, newValue);\n+                }\n+            } else {\n+                removeDirect(key);\n+            }\n+            return newValue;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ValueT computeIfAbsent(@NonNull KeyT key, Function<? super KeyT, ? extends ValueT> toCompute) {\n+        ValueT existingValue = get(key);\n+        if (existingValue == null) {\n+            ValueT newValue = toCompute.apply(key);\n+            if (newValue != null) {\n+                putDirect(key, newValue);\n+            }\n+            return newValue;\n+        } else {\n+            return existingValue;\n+        }\n+    }\n+\n+    @Override\n+    public Set<KeyT> keySet() {\n+        requiresKeyFamily(\"keySet\");\n+        return new KeySetImpl();\n+    }\n+\n+    @Override\n+    public Collection<ValueT> values() {\n+        requiresKeyFamily(\"values\");\n+        return new ValuesCollectionImpl();\n+    }\n+\n+    @Override\n+    public Set<Entry<KeyT, ValueT>> entrySet() {\n+        requiresKeyFamily(\"entrySet\");\n+        return new EntrySetImpl();\n+    }\n+\n+    @Override\n+    public int size() {\n+        requiresKeyFamily(\"size\");\n+        long size = keyStream().count();\n+        return size > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) size;\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        requiresKeyFamily(\"isEmpty\");\n+        return !keyStream().findFirst().isPresent();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        clear(key -> true);\n+    }\n+\n+    private boolean clear(Predicate<? super KeyT> keyFilter) {\n+        requiresKeyFamily(\"clear\");\n+        val baseIterator = MapWrapperImpl.this.kvt.keyIterator(this.keyFamily, ITERATOR_BATCH_SIZE, null).asIterator();\n+        val deleteFutures = new ArrayList<CompletableFuture<Void>>();\n+        while (baseIterator.hasNext()) {\n+            val toDelete = baseIterator.next().getItems().stream()\n+                    .filter(k -> keyFilter.test(k.getKey()))\n+                    .map(k -> TableKey.unversioned(k.getKey()))\n+                    .collect(Collectors.toList());\n+            if (toDelete.size() > 0) {\n+                deleteFutures.add(this.kvt.removeAll(this.keyFamily, toDelete));\n+            }\n+        }\n+\n+        if (deleteFutures.size() > 0) {\n+            Futures.allOf(deleteFutures).join();\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    //endregion\n+\n+    //region Helpers\n+\n+    private void requiresKeyFamily(String opName) {\n+        if (this.keyFamily == null) {\n+            throw new UnsupportedOperationException(opName + \"() requires a Key Family.\");\n+        }\n+    }\n+\n+    private boolean areSame(ValueT expected, ValueT actual) {\n+        return expected == null && actual == null || Objects.equals(expected, actual);", "originalCommit": "f9b18f58d57d8c700143afbcae3a6cefa13d15e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0NDU2MA==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430544560", "bodyText": "Good catch. Fixed it.", "author": "andreipaduroiu", "createdAt": "2020-05-26T16:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NTA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NTkxOA==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r429495918", "bodyText": "I think this is an accident", "author": "tkaitchuck", "createdAt": "2020-05-23T00:23:46Z", "path": "test/testcommon/src/main/java/io/pravega/test/common/AssertExtensions.java", "diffHunk": "@@ -549,7 +549,7 @@ public void run() {\n     * @param precision the maximum absolute difference between the two values.\n     * @return true if the two operands are both null or the represent the same\n     * value within the given precision\n-    */\n+     */", "originalCommit": "f9b18f58d57d8c700143afbcae3a6cefa13d15e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0NDc1OA==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430544758", "bodyText": "Fixed", "author": "andreipaduroiu", "createdAt": "2020-05-26T16:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5NTkxOA=="}], "type": "inlineReview"}, {"oid": "bcefc3c5cbcf3be5444895c6695891fb253c203f", "url": "https://github.com/pravega/pravega/commit/bcefc3c5cbcf3be5444895c6695891fb253c203f", "message": "Code review feedback. Renamed MapWrapper to KeyValueTableMap; other small changes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-05-26T16:30:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NzkzNw==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430597937", "bodyText": "EntrySet is listed here and on line 40.", "author": "tkaitchuck", "createdAt": "2020-05-26T17:51:54Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableMap.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import lombok.NonNull;\n+\n+/**\n+ * {@link Map} implementation for a {@link KeyValueTable}'s Key Family.\n+ * <p>\n+ * All methods inherited from {@link Map} respect the contracts defined in that interface, except as noted below.\n+ * <p><p>\n+ * Performance considerations:\n+ * <ul>\n+ * <li> The {@link Map} interface defines synchronous operations, however {@link KeyValueTable} defines async operations.\n+ * All method implementations defined in this interface or inherited from {@link Map} invoke\n+ * {@link CompletableFuture#join()} on any {@link KeyValueTable} methods invoked. This means that two threads are used\n+ * to fulfill these calls: one from the Executor passed in to the {@link KeyValueTable} factory, and one on which this\n+ * request is executing.\n+ *\n+ * <li> The following operations result in a single call to the wrapped {@link KeyValueTable}:\n+ * <ul>\n+ * <li> {@link #containsKey}.\n+ * <li> {@link #get}, {@link #getOrDefault}.\n+ * <li> {@link #putDirect}, {@link #putAll}, {@link #putIfAbsent}.\n+ * <li> {@link #removeDirect}.\n+ * <li> {@link #isEmpty()} (Invokes {@link KeyValueTable#keyIterator} and requests a single item).\n+ * <li> {@link #keySet()}: {@link Set#removeAll}, {@link Set#contains}, {@link Set#containsAll}, {@link Set#isEmpty()}.\n+ * <li> {@link #entrySet()}: {@link Set#contains}, {@link Set#containsAll}, {@link Set#isEmpty()}, {@link Set#add}, {@link Set#addAll}.\n+ * </ul>\n+ *\n+ * <li> The following operations result up to two calls to the wrapped {@link KeyValueTable}:\n+ * <ul>\n+ * <li> {@link #put} (refer to {{@link #putDirect} if the old value is not needed).\n+ * <li> {@link #replace}.\n+ * <li> {@link #remove} (refer to {@link #removeDirect} if the old value is not needed).\n+ * <li> {@link #computeIfPresent}, {@link #compute}}, {@link #computeIfAbsent}.\n+ * <li> {@link #keySet()}{@link Set#remove}.\n+ * <li> {@link #entrySet()}: {@link Set#removeAll}, {@link Set#isEmpty()}.", "originalCommit": "bcefc3c5cbcf3be5444895c6695891fb253c203f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1Mzc0MQ==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430753741", "bodyText": "Yes, there is a difference. Calling entrySet by itself does nothing. But the methods listed after this (see the colon :) do. The reason this is listed multiple times is because I'm grouping the actual method calls by their behavior.", "author": "andreipaduroiu", "createdAt": "2020-05-26T23:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxOTQ0OA==", "url": "https://github.com/pravega/pravega/pull/4786#discussion_r430619448", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * The following operations are not supported (will throw {@link UnsupportedOperationException}) if\n          \n          \n            \n             * If {@link #getKeyFamily()} is null):The following operations are not supported and will throw \n          \n          \n            \n             * {@link UnsupportedOperationException} if called.", "author": "tkaitchuck", "createdAt": "2020-05-26T18:26:48Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableMap.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import lombok.NonNull;\n+\n+/**\n+ * {@link Map} implementation for a {@link KeyValueTable}'s Key Family.\n+ * <p>\n+ * All methods inherited from {@link Map} respect the contracts defined in that interface, except as noted below.\n+ * <p><p>\n+ * Performance considerations:\n+ * <ul>\n+ * <li> The {@link Map} interface defines synchronous operations, however {@link KeyValueTable} defines async operations.\n+ * All method implementations defined in this interface or inherited from {@link Map} invoke\n+ * {@link CompletableFuture#join()} on any {@link KeyValueTable} methods invoked. This means that two threads are used\n+ * to fulfill these calls: one from the Executor passed in to the {@link KeyValueTable} factory, and one on which this\n+ * request is executing.\n+ *\n+ * <li> The following operations result in a single call to the wrapped {@link KeyValueTable}:\n+ * <ul>\n+ * <li> {@link #containsKey}.\n+ * <li> {@link #get}, {@link #getOrDefault}.\n+ * <li> {@link #putDirect}, {@link #putAll}, {@link #putIfAbsent}.\n+ * <li> {@link #removeDirect}.\n+ * <li> {@link #isEmpty()} (Invokes {@link KeyValueTable#keyIterator} and requests a single item).\n+ * <li> {@link #keySet()}: {@link Set#removeAll}, {@link Set#contains}, {@link Set#containsAll}, {@link Set#isEmpty()}.\n+ * <li> {@link #entrySet()}: {@link Set#contains}, {@link Set#containsAll}, {@link Set#isEmpty()}, {@link Set#add}, {@link Set#addAll}.\n+ * </ul>\n+ *\n+ * <li> The following operations result up to two calls to the wrapped {@link KeyValueTable}:\n+ * <ul>\n+ * <li> {@link #put} (refer to {{@link #putDirect} if the old value is not needed).\n+ * <li> {@link #replace}.\n+ * <li> {@link #remove} (refer to {@link #removeDirect} if the old value is not needed).\n+ * <li> {@link #computeIfPresent}, {@link #compute}}, {@link #computeIfAbsent}.\n+ * <li> {@link #keySet()}{@link Set#remove}.\n+ * <li> {@link #entrySet()}: {@link Set#removeAll}, {@link Set#isEmpty()}.\n+ * </ul>\n+ *\n+ * <li> The following operations may result in iterating through all the Keys using {@link KeyValueTable#keyIterator}:\n+ * <ul>\n+ * <li> {@link #keySet()}{@link Set#iterator()} (Iterates as {@link Iterator#hasNext()} or {@link Iterator#next()} are\n+ * invoked. Calls to {@link Iterator#remove()} will result in a single call to {@link KeyValueTable}).\n+ * <li> {@link #size()} (Iterates through the entire iterator).\n+ * <li> {@link #clear()} (Iterates through the entire iterator and makes repeated calls to {@link KeyValueTable#removeAll}).\n+ * <li> {@link #keySet()}: {@link Set#clear()}, {@link Set#removeIf}, {@link Set#retainAll}.\n+ * </ul>\n+ *\n+ * <li>The following operations may result in iterating through all the Entries using {@link KeyValueTable#entryIterator}:\n+ * <ul>\n+ * <li> {@link #containsValue}.\n+ * <li> {@link #replaceAll} (which makes multiple calls to {@link KeyValueTable#putAll} as well).\n+ * <li> {@link #entrySet()}{@link Set#iterator()} (Iterates as {@link Iterator#hasNext()} or {@link Iterator#next()} are\n+ * invoked. Calls to {@link Iterator#remove()} will result in a single call to {@link KeyValueTable}).\n+ * <li> {@link #entrySet()}: {@link Set#removeIf}, {@link Set#retainAll}\n+ * <li> All operations on {@link #values()}.\n+ * </ul>\n+ * <li>Invocations of {@link Collection#stream()}}, {@link Collection#spliterator()} or {@link Collection#toArray()} on\n+ * {@link #keySet()}, {@link #entrySet()} or {@link #values()} will invoke those collections' iterators (see above).\n+ * </ul>\n+ * <p><p>\n+ * The following operations are not supported (will throw {@link UnsupportedOperationException}) if", "originalCommit": "bcefc3c5cbcf3be5444895c6695891fb253c203f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "474a634092245a3af0261e5106e644d15e99e30c", "url": "https://github.com/pravega/pravega/commit/474a634092245a3af0261e5106e644d15e99e30c", "message": "Javadoc\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-05-26T23:03:04Z", "type": "commit"}]}