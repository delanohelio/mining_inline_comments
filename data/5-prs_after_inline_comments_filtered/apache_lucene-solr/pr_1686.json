{"pr_number": 1686, "pr_title": "SOLR-13528: Implement Request Rate Limiters", "pr_createdAt": "2020-07-21T19:47:32Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1686", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NTI4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460295285", "bodyText": "nit: use <> instead of explicit types.", "author": "madrob", "createdAt": "2020-07-24T21:26:24Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= 10;\n+  public final static long DEFAULT_EXPIRATION_TIME_INMS = 300;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<String, RequestRateLimiter>();", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NTkyMA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460295920", "bodyText": "Unused.", "author": "madrob", "createdAt": "2020-07-24T21:28:10Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.AsyncEvent;\n+import javax.servlet.AsyncListener;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else asynchronously queue the request.\n+ *\n+ * When an active request completes, a check is performed to see if there are any pending requests.\n+ * If there is an available pending request, process the same.\n+ */\n+public class RequestRateLimiter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private Semaphore allowedConcurrentRequests;\n+  private RateLimiterConfig rateLimiterConfig;\n+  private Queue<AsyncContext> waitQueue;\n+  private Queue<AsyncListener> listenerQueue;\n+\n+  public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n+    this.rateLimiterConfig = rateLimiterConfig;\n+    this.allowedConcurrentRequests = new Semaphore(rateLimiterConfig.allowedRequests);\n+    this.waitQueue = new ConcurrentLinkedQueue<>();\n+    this.listenerQueue = new ConcurrentLinkedQueue<>();\n+  }\n+\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+\n+    if (!rateLimiterConfig.isEnabled) {\n+      return true;\n+    }\n+\n+    boolean accepted = allowedConcurrentRequests.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS);\n+\n+    if (!accepted) {\n+      AsyncContext asyncContext = request.startAsync();\n+      AsyncListener asyncListener = buildAsyncListener();\n+\n+      if (rateLimiterConfig.requestExpirationTimeInMS > 0) {\n+        asyncContext.setTimeout(rateLimiterConfig.requestExpirationTimeInMS);\n+      }\n+\n+      asyncContext.addListener(asyncListener);\n+      listenerQueue.add(asyncListener);\n+      waitQueue.add(asyncContext);\n+    }\n+\n+    return accepted;\n+  }\n+\n+  public boolean resumePendingOperation() {\n+    AsyncContext asyncContext = waitQueue.poll();\n+\n+    if (asyncContext != null) {\n+      try {\n+        asyncContext.dispatch();\n+        return true;\n+      }\n+      catch (IllegalStateException x) {\n+        if (log.isWarnEnabled()) {\n+          String errorMessage = x.getMessage();\n+          log.warn(errorMessage);\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  public void decrementConcurrentRequests() {\n+    allowedConcurrentRequests.release();\n+  }\n+\n+  public void close() {\n+    while (!waitQueue.isEmpty()) {\n+      AsyncContext asyncContext = waitQueue.poll();\n+\n+      asyncContext.complete();\n+    }\n+\n+    listenerQueue.clear();\n+  }\n+\n+  private AsyncListener buildAsyncListener() {\n+    return new AsyncListener() {\n+      @Override\n+      public void onComplete(AsyncEvent asyncEvent) throws IOException {\n+\n+      }\n+\n+      @Override\n+      public void onTimeout(AsyncEvent asyncEvent) throws IOException {\n+        AsyncContext asyncContext = asyncEvent.getAsyncContext();\n+\n+        if (!waitQueue.remove(asyncContext)) {\n+          return;\n+        }\n+\n+        HttpServletResponse servletResponse = ((HttpServletResponse)asyncEvent.getSuppliedResponse());\n+        String responseMessage = \"Too many requests for this request type.\" +", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NjI4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460296287", "bodyText": "We never poll this queue, what is it used for?", "author": "madrob", "createdAt": "2020-07-24T21:29:12Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.AsyncEvent;\n+import javax.servlet.AsyncListener;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else asynchronously queue the request.\n+ *\n+ * When an active request completes, a check is performed to see if there are any pending requests.\n+ * If there is an available pending request, process the same.\n+ */\n+public class RequestRateLimiter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private Semaphore allowedConcurrentRequests;\n+  private RateLimiterConfig rateLimiterConfig;\n+  private Queue<AsyncContext> waitQueue;\n+  private Queue<AsyncListener> listenerQueue;\n+\n+  public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n+    this.rateLimiterConfig = rateLimiterConfig;\n+    this.allowedConcurrentRequests = new Semaphore(rateLimiterConfig.allowedRequests);\n+    this.waitQueue = new ConcurrentLinkedQueue<>();\n+    this.listenerQueue = new ConcurrentLinkedQueue<>();", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3Nzk4MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460677980", "bodyText": "This exists to store the listeners that are registered for the given async contexts. Removed the same, thanks", "author": "atris", "createdAt": "2020-07-27T06:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5NjI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODE3OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460298178", "bodyText": "should this be in the finally block instead?", "author": "madrob", "createdAt": "2020-07-24T21:34:39Z", "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -331,6 +338,10 @@ public void close() {\n           metricManager = null;\n         }\n       }\n+\n+      if (rateLimitManager != null) {", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3ODUzMw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460678533", "bodyText": "Would that not defy the purpose of the destroy method?", "author": "atris", "createdAt": "2020-07-27T06:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5ODI4OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460298288", "bodyText": "SolrException or SolrServerException probably", "author": "madrob", "createdAt": "2020-07-24T21:34:59Z", "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -377,6 +389,16 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n         }\n       }\n \n+      try {\n+        accepted = rateLimitManager.handleRequest(request);\n+      } catch (InterruptedException e) {\n+        throw new RuntimeException(e.getMessage());", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5OTM2MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460299360", "bodyText": "I'm confused as to why this exists. If a query request completes, why does that mean that we have room for an update request now?", "author": "madrob", "createdAt": "2020-07-24T21:38:17Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= 10;\n+  public final static long DEFAULT_EXPIRATION_TIME_INMS = 300;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<String, RequestRateLimiter>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+\n+  // NOTE: It is upto specific rate limiter implementation to handle queuing of rejected requests.\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    return requestRateLimiter.handleRequest(request);\n+  }\n+\n+  // Resume a pending request from one of the registered rate limiters.\n+  // The current model is round robin -- iterate over the list and get a pending request and resume it.\n+\n+  // TODO: This should be a priority queue based model\n+  public void resumePendingRequest(HttpServletRequest request) {\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    RequestRateLimiter previousRequestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (previousRequestRateLimiter == null) {\n+      // No rate limiter for this request type\n+      return;\n+    }\n+\n+    // Give preference to the previous request's rate limiter\n+    if (previousRequestRateLimiter.resumePendingOperation()) {\n+      return;\n+    }\n+\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4Nzc4OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460687788", "bodyText": "This is work stealing -- a thread first tries to get work from its own request rate limiter and if not present, let the thread be used for a different request type. This is to allow smoothening out of skews. Added a flag to enable or disable this behaviour.", "author": "atris", "createdAt": "2020-07-27T07:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI5OTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMTkzNw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460301937", "bodyText": "This seems trivial to forge. Can we tie this into the authentication code paths somehow so that we can really trust that the request is coming from a server instead of just some application claiming to be a server?", "author": "madrob", "createdAt": "2020-07-24T21:46:09Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -358,7 +358,11 @@ protected HttpRequestBase createMethod(@SuppressWarnings({\"rawtypes\"})SolrReques\n     if (parser == null) {\n       parser = this.parser;\n     }\n-    \n+\n+    Header[] contextHeaders = new Header[2];\n+    contextHeaders[0] = new BasicHeader(CommonParams.SOLR_REQUEST_CONTEXT_PARAM, getContext().toString());", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyMDAxMQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460720011", "bodyText": "I am honestly not sure about that -- Can you suggest a mechanism to achieve that? Ideas are more than welcome!", "author": "atris", "createdAt": "2020-07-27T08:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NzE2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465147161", "bodyText": "https://lucene.apache.org/solr/guide/8_5/authentication-and-authorization-plugins.html#securing-inter-node-requests has some ideas.", "author": "madrob", "createdAt": "2020-08-04T15:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMzc0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460303745", "bodyText": "There is a race condition here where new incoming requests can get in before resume of an existing request.", "author": "madrob", "createdAt": "2020-07-24T21:52:04Z", "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -441,6 +463,13 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n       consumeInputFully(request, response);\n       SolrRequestInfo.reset();\n       SolrRequestParsers.cleanupMultipartFiles(request);\n+\n+      if (accepted) {\n+        rateLimitManager.decrementActiveRequests(request);", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyNTY2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464525661", "bodyText": "Redundant now, thanks", "author": "atris", "createdAt": "2020-08-03T16:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwMzc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwNTIzMg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460305232", "bodyText": "Is this different from admin requests sent with async=[async-id]?", "author": "madrob", "createdAt": "2020-07-24T21:56:46Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.AsyncEvent;\n+import javax.servlet.AsyncListener;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else asynchronously queue the request.\n+ *\n+ * When an active request completes, a check is performed to see if there are any pending requests.\n+ * If there is an available pending request, process the same.\n+ */\n+public class RequestRateLimiter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private Semaphore allowedConcurrentRequests;\n+  private RateLimiterConfig rateLimiterConfig;\n+  private Queue<AsyncContext> waitQueue;\n+  private Queue<AsyncListener> listenerQueue;\n+\n+  public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n+    this.rateLimiterConfig = rateLimiterConfig;\n+    this.allowedConcurrentRequests = new Semaphore(rateLimiterConfig.allowedRequests);\n+    this.waitQueue = new ConcurrentLinkedQueue<>();\n+    this.listenerQueue = new ConcurrentLinkedQueue<>();\n+  }\n+\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+\n+    if (!rateLimiterConfig.isEnabled) {\n+      return true;\n+    }\n+\n+    boolean accepted = allowedConcurrentRequests.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS);\n+\n+    if (!accepted) {\n+      AsyncContext asyncContext = request.startAsync();", "originalCommit": "629fbbe44f921345bbe5f438a82fee4cb3a30ecf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY5MzE3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r460693175", "bodyText": "I dont think so -- an async request should just return its current context here.", "author": "atris", "createdAt": "2020-07-27T07:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMwNTIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2MDM3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464860371", "bodyText": "Don't want to nit-pick but 'stealing' sounds like when something is taken undesirably. Considering this is a config setting, I'd suggest using something else here.", "author": "anshumg", "createdAt": "2020-08-04T07:41:18Z", "path": "solr/core/src/java/org/apache/solr/servlet/QueryRateLimiter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_CONCURRENT_REQUESTS;\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class QueryRateLimiter extends RequestRateLimiter {\n+  final static String IS_QUERY_RATE_LIMITER_ENABLED = \"isQueryRateLimiterEnabled\";\n+  final static String MAX_QUERY_REQUESTS = \"maxQueryRequests\";\n+  final static String QUERY_WAIT_FOR_SLOT_ALLOCATION_INMS = \"queryWaitForSlotAllocationInMS\";\n+  final static String QUERY_GUARANTEED_SLOTS = \"queryGuaranteedSlots\";\n+  final static String QUERY_ALLOW_WORK_STEALING = \"queryAllowWorkStealing\";", "originalCommit": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg2MDU0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464860541", "bodyText": "Can we add some java doc to clarify what does this implementation do?", "author": "anshumg", "createdAt": "2020-08-04T07:41:39Z", "path": "solr/core/src/java/org/apache/solr/servlet/QueryRateLimiter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_CONCURRENT_REQUESTS;\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class QueryRateLimiter extends RequestRateLimiter {", "originalCommit": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MDAyMA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464870020", "bodyText": "Forgot to remove this ?", "author": "anshumg", "createdAt": "2020-08-04T07:58:39Z", "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -377,6 +385,20 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n         }\n       }\n \n+      try {\n+        accepted = rateLimitManager.handleRequest(request);\n+      } catch (InterruptedException e) {\n+        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage());\n+      }\n+\n+      if (!accepted) {\n+        String errorMessage = \"Too many requests for this request type.\" +\n+            \"Please try after some time or increase the quota for this request type\";\n+\n+        response.sendError(429, errorMessage);\n+        //throw new SolrException(ErrorCode.TOO_MANY_REQUESTS, \"FOOFOOOFOO\");", "originalCommit": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5Mjc3NA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464892774", "bodyText": "Good catch, thanks!", "author": "atris", "createdAt": "2020-08-04T08:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3MDIzMQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464870231", "bodyText": "@VisibleForTesting ?", "author": "anshumg", "createdAt": "2020-08-04T07:59:05Z", "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -668,4 +694,9 @@ public void close() {\n   public void closeOnDestroy(boolean closeOnDestroy) {\n     this.closeOnDestroy = closeOnDestroy;\n   }\n+\n+  // Only for testing\n+  void replaceRateLimitManager(RateLimitManager rateLimitManager) {", "originalCommit": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3NjQwOA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464876408", "bodyText": "This is really clean!", "author": "anshumg", "createdAt": "2020-08-04T08:10:14Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {", "originalCommit": "6d7071b5fbb87f00ee4b8d0cf7746c0f706b9954", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg5NTc2MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r464895760", "bodyText": "s/stealing/borrowing", "author": "anshumg", "createdAt": "2020-08-04T08:43:40Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isWorkStealingEnabled */);", "originalCommit": "dd40660e20f2ce3b83305788a6cc102fbf1e8cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MTc0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465141745", "bodyText": "unneeded?", "author": "madrob", "createdAt": "2020-08-04T15:35:13Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -387,7 +394,13 @@ protected HttpRequestBase createMethod(@SuppressWarnings({\"rawtypes\"})SolrReques\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\");\n       }\n \n-      return new HttpGet(basePath + path + wparams.toQueryString());\n+      //return new HttpGet(basePath + path + wparams.toQueryString());", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjM4MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465142380", "bodyText": "let's extract this to a method, along with lines 445 and 366", "author": "madrob", "createdAt": "2020-08-04T15:36:08Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -387,7 +394,13 @@ protected HttpRequestBase createMethod(@SuppressWarnings({\"rawtypes\"})SolrReques\n         throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"GET can't send streams!\");\n       }\n \n-      return new HttpGet(basePath + path + wparams.toQueryString());\n+      //return new HttpGet(basePath + path + wparams.toQueryString());\n+\n+      HttpGet result = new HttpGet(basePath + path + wparams.toQueryString());\n+\n+      result.addHeader(contextHeaders[0]);", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MjkyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465142929", "bodyText": "This is maybe more of an admin request? WDYT?", "author": "madrob", "createdAt": "2020-08-04T15:36:55Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/request/SolrPing.java", "diffHunk": "@@ -54,6 +54,11 @@ protected SolrPingResponse createResponse(SolrClient client) {\n   public ModifiableSolrParams getParams() {\n     return params;\n   }\n+\n+  @Override\n+  public String getRequestType() {\n+    return SolrRequestType.QUERY.toString();", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDgyNw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465144827", "bodyText": "Something about this that I think bothers me is that we don't make a differentiation between distinct handlers, so we can't use this to build QoS levels. Like I can't say that RTG should always go through while /select might be acceptable to throttle and /spellcheck is even lower priority.", "author": "madrob", "createdAt": "2020-08-04T15:39:41Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/request/QueryRequest.java", "diffHunk": "@@ -76,5 +76,9 @@ public SolrParams getParams() {\n     return query;\n   }\n \n+  @Override\n+  public String getRequestType() {\n+    return SolrRequestType.QUERY.toString();", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxMDI3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465510275", "bodyText": "This seems like a query prioritization model IMO -- a good idea. I will open a follow up JIRA once this goes in.", "author": "atris", "createdAt": "2020-08-05T06:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTMzMw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465175333", "bodyText": "nit: Collections.singleton", "author": "madrob", "createdAt": "2020-08-04T16:25:26Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -98,6 +99,8 @@\n   private static final Charset FALLBACK_CHARSET = StandardCharsets.UTF_8;\n   private static final String DEFAULT_PATH = \"/select\";\n   private static final long serialVersionUID = -946812319974801896L;\n+\n+  protected static final Set<Integer> UNMATCHED_ACCEPTED_ERROR_CODES = new HashSet<>(Arrays.asList(429));", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTcwMg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465175702", "bodyText": "I don't understand when this condition occurs. Can you add some comments explaining it?", "author": "madrob", "createdAt": "2020-08-04T16:25:59Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -624,6 +641,12 @@ private HttpEntityEnclosingRequestBase fillContentStream(\n       if (procCt != null) {\n         String procMimeType = ContentType.parse(procCt).getMimeType().trim().toLowerCase(Locale.ROOT);\n         if (!procMimeType.equals(mimeType)) {\n+          if (isUnmatchedErrorCode(mimeType, httpStatus)) {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5MzkxNw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465193917", "bodyText": "This is always false due to type mismatch.", "author": "madrob", "createdAt": "2020-08-04T16:55:49Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /* For a rejected request type, do the following:\n+   * For each request rate limiter whose type that is not of the type of the request which got rejected,\n+   * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n+   * If allotted, return else try next request type.\n+   */\n+  private RequestRateLimiter trySlotBorrowing(String requestType) {\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n+      RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n+\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxOTM5Nw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465219397", "bodyText": "Good catch, thanks. Fixed.", "author": "atris", "createdAt": "2020-08-04T17:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5MzkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NDA0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465194047", "bodyText": "do we need a call to handleRequest here?", "author": "madrob", "createdAt": "2020-08-04T16:56:02Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIyMjgxMQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465222811", "bodyText": "No, since the slot would already have been acquired when the slot borrowing succeeded.", "author": "atris", "createdAt": "2020-08-04T17:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NDA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NjgyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465196829", "bodyText": "Please add some comments here clarifying that callers must acquire the semaphore lease before adding requests to the map (and must delete from the map before returning the lease).", "author": "madrob", "createdAt": "2020-08-04T17:00:31Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMzMwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465203305", "bodyText": "Potential deadlock - reorder this. Possibly consider using computeIfPresent.", "author": "madrob", "createdAt": "2020-08-04T17:12:04Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /* For a rejected request type, do the following:\n+   * For each request rate limiter whose type that is not of the type of the request which got rejected,\n+   * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n+   * If allotted, return else try next request type.\n+   */\n+  private RequestRateLimiter trySlotBorrowing(String requestType) {\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n+      RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n+\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {\n+        continue;\n+      }\n+\n+      if (requestRateLimiter.getRateLimiterConfig().isSlotBorrowingEnabled && requestRateLimiter.allowSlotBorrowing()) {\n+        return requestRateLimiter;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  // Decrement the active requests in the rate limiter for the corresponding request type.\n+  public void decrementActiveRequests(HttpServletRequest request) {\n+    RequestRateLimiter requestRateLimiter = activeRequestsMap.get(request);\n+\n+    if (requestRateLimiter == null) {\n+      // No rate limiter for this request type\n+      return;\n+    }\n+\n+    requestRateLimiter.decrementConcurrentRequests();\n+    activeRequestsMap.remove(request);", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNTg3Ng==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465205876", "bodyText": "I feel like this is insufficient. If this request is part of its own queue, but there is another request of this same type that is currently borrowing a slot from another queue, then we shout prioritize returning the borrowed slot instead of our own.\nThis might have potential performance implications and can lead to livelock/request starvation.", "author": "madrob", "createdAt": "2020-08-04T17:16:30Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);\n+    String typeOfRequest = request.getHeader(SOLR_REQUEST_TYPE_PARAM);\n+\n+    if (typeOfRequest == null) {\n+      // Cannot determine if this request should be throttled\n+      return true;\n+    }\n+\n+    // Do not throttle internal requests\n+    if (requestContext != null && requestContext.equals(SolrRequest.SolrClientContext.SERVER.toString())) {\n+      return true;\n+    }\n+\n+    RequestRateLimiter requestRateLimiter = requestRateLimiterMap.get(typeOfRequest);\n+\n+    if (requestRateLimiter == null) {\n+      // No request rate limiter for this request type\n+      return true;\n+    }\n+\n+    if (requestRateLimiter.handleRequest()) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    requestRateLimiter = trySlotBorrowing(typeOfRequest);\n+\n+    if (requestRateLimiter != null) {\n+      activeRequestsMap.put(request, requestRateLimiter);\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /* For a rejected request type, do the following:\n+   * For each request rate limiter whose type that is not of the type of the request which got rejected,\n+   * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n+   * If allotted, return else try next request type.\n+   */\n+  private RequestRateLimiter trySlotBorrowing(String requestType) {\n+    for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n+      RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n+\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {\n+        continue;\n+      }\n+\n+      if (requestRateLimiter.getRateLimiterConfig().isSlotBorrowingEnabled && requestRateLimiter.allowSlotBorrowing()) {\n+        return requestRateLimiter;\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  // Decrement the active requests in the rate limiter for the corresponding request type.\n+  public void decrementActiveRequests(HttpServletRequest request) {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxNTg5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465515893", "bodyText": "Discussed offline. Marking experimental and will follow up with a JIRA for rethinking the same.", "author": "atris", "createdAt": "2020-08-05T07:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNjk1OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465206958", "bodyText": "This is required, make it a constructor parameter on the builder?", "author": "madrob", "createdAt": "2020-08-04T17:18:24Z", "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -184,6 +187,11 @@ public void init(FilterConfig config) throws ServletException\n       coresInit = createCoreContainer(solrHomePath, extraProperties);\n       this.httpClient = coresInit.getUpdateShardHandler().getDefaultHttpClient();\n       setupJvmMetrics(coresInit);\n+      RateLimitManager.Builder builder = new RateLimitManager.Builder();\n+\n+      builder.setConfig(config);", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNzE1NA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465207154", "bodyText": "Thread.currentThread.interrupt", "author": "madrob", "createdAt": "2020-08-04T17:18:45Z", "path": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java", "diffHunk": "@@ -377,6 +386,19 @@ public void doFilter(ServletRequest _request, ServletResponse _response, FilterC\n         }\n       }\n \n+      try {\n+        accepted = rateLimitManager.handleRequest(request);\n+      } catch (InterruptedException e) {\n+        throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage());", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNzY4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465207687", "bodyText": "assertEquals", "author": "madrob", "createdAt": "2020-08-04T17:19:39Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+        }\n+      }\n+\n+      MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n+\n+      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwODAzMg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465208032", "bodyText": "nit: use a lambda?", "author": "madrob", "createdAt": "2020-08-04T17:20:13Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwOTA1NA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465209054", "bodyText": "assertThat(e.getMessage(), contains(...))", "author": "madrob", "createdAt": "2020-08-04T17:22:06Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwOTQwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465209409", "bodyText": "Should we assert anything about the result of this?", "author": "madrob", "createdAt": "2020-08-04T17:22:40Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzOTExNA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465239114", "bodyText": "We assert on the response count in the actual query response in the executable.", "author": "atris", "createdAt": "2020-08-04T18:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwOTQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMDIxMQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465210211", "bodyText": "should this ever be false?", "author": "madrob", "createdAt": "2020-08-04T17:24:02Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzOTM1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465239352", "bodyText": "In case of an exception (TOO_MANY_REQUESTS?)", "author": "atris", "createdAt": "2020-08-04T18:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMDIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMDkzMg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465210932", "bodyText": "I'd like to see some testing around the slot borrowing?", "author": "madrob", "createdAt": "2020-08-04T17:25:13Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NTk4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465245982", "bodyText": "Might want to declare both of these as final ?", "author": "anshumg", "createdAt": "2020-08-04T18:26:54Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+\n+/**\n+ * Handles rate limiting for a specific request type.\n+ *\n+ * The control flow is as follows:\n+ * Handle request -- Check if slot is available -- If available, acquire slot and proceed --\n+ * else reject the same.\n+ */\n+public class RequestRateLimiter {\n+  private Semaphore allowedConcurrentRequests;", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NjU5NA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465246594", "bodyText": "You could declare all of these as final", "author": "anshumg", "createdAt": "2020-08-04T18:28:06Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+        }\n+      }\n+\n+      MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n+\n+      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n+          mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n+      assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n+      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n+              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n+          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  private static class MockRequestRateLimiter extends RequestRateLimiter {\n+    AtomicInteger incomingRequestCount;", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NzUwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465247505", "bodyText": "this throws is redundant here considering we always throw a RuntimeException", "author": "anshumg", "createdAt": "2020-08-04T18:29:45Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxNTI1MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465515250", "bodyText": "Converted to lambda", "author": "atris", "createdAt": "2020-08-05T07:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0NzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0ODkzMg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465248932", "bodyText": "Let's change these assertions to assertEquals? It's going to help debug or get more information from failure. assertTrue only prints true/false, but equals provides information like expected X but got Y", "author": "anshumg", "createdAt": "2020-08-04T18:32:13Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.impl.CloudSolrClient;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.solr.servlet.RateLimitManager.DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS;\n+\n+public class TestRequestRateLimiter extends SolrCloudTestCase {\n+  private final static String COLLECTION = \"c1\";\n+\n+  @BeforeClass\n+  public static void setupCluster() throws Exception {\n+    configureCluster(1).addConfig(COLLECTION, configset(\"cloud-minimal\")).configure();\n+  }\n+\n+  @Test\n+  public void testConcurrentQueries() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(COLLECTION, 1, 1);\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig rateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RateLimitManager.Builder builder = new MockBuilder(new MockRequestRateLimiter(rateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(new Callable<Boolean>() {\n+          @Override\n+          public Boolean call() throws Exception {\n+            try {\n+              QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+              if (response.getResults().getNumFound() > 0) {\n+                assertEquals(100, response.getResults().getNumFound());\n+              }\n+            } catch (Exception e) {\n+              throw new RuntimeException(e.getMessage());\n+            }\n+\n+            return true;\n+          }\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();\n+        } catch (Exception e) {\n+          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+        }\n+      }\n+\n+      MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n+\n+      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),", "originalCommit": "e65539a3d56e370522b3449434ded38e08bf7af1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUxOTk3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r465519971", "bodyText": "Some of them cannot be converted since they are expressions. I have converted the remaining to assertEquals, thanks.", "author": "atris", "createdAt": "2020-08-05T07:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0ODkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NzQ5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466587499", "bodyText": "s/gexperimental/experimental", "author": "madrob", "createdAt": "2020-08-06T17:55:00Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -92,17 +100,28 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n    * For each request rate limiter whose type that is not of the type of the request which got rejected,\n    * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n    * If allotted, return else try next request type.\n+   *\n+   * @lucene.gexperimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4ODg3MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466588870", "bodyText": "nit: swap the parameters. assertEquals(expected, actual)", "author": "madrob", "createdAt": "2020-08-06T17:57:20Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4OTA4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466589081", "bodyText": "(expected, actual)", "author": "madrob", "createdAt": "2020-08-06T17:57:45Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MDU3Mg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466660572", "bodyText": "if numFound == 0, then as you said this means the request was throttled? So we should be in the catch block at that point? I don't think we need the conditional then, right?", "author": "madrob", "createdAt": "2020-08-06T20:14:14Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  @Test\n+  public void testSlotBorrowing() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(SECOND_COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(SECOND_COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(SECOND_COLLECTION, 1, 1);\n+\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig queryRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RequestRateLimiter.RateLimiterConfig indexRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.UPDATE,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    // We are fine with a null FilterConfig here since we ensure that MockBuilder never invokes its parent\n+    RateLimitManager.Builder builder = new MockBuilder(null /*dummy FilterConfig */, new MockRequestRateLimiter(queryRateLimiterConfig, 5), new MockRequestRateLimiter(indexRateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(() -> {\n+          try {\n+            QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+            if (response.getResults().getNumFound() > 0) {\n+              assertEquals(100, response.getResults().getNumFound());\n+            }", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTIwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466661205", "bodyText": "assertTrue(future.get()); for when it doesn't throw an exception?", "author": "madrob", "createdAt": "2020-08-06T20:15:32Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  @Test\n+  public void testSlotBorrowing() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(SECOND_COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(SECOND_COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(SECOND_COLLECTION, 1, 1);\n+\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig queryRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RequestRateLimiter.RateLimiterConfig indexRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.UPDATE,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    // We are fine with a null FilterConfig here since we ensure that MockBuilder never invokes its parent\n+    RateLimitManager.Builder builder = new MockBuilder(null /*dummy FilterConfig */, new MockRequestRateLimiter(queryRateLimiterConfig, 5), new MockRequestRateLimiter(indexRateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {\n+      for (int i = 0; i < 25; i++) {\n+        callableList.add(() -> {\n+          try {\n+            QueryResponse response = client.query(new SolrQuery(\"*:*\"));\n+\n+            if (response.getResults().getNumFound() > 0) {\n+              assertEquals(100, response.getResults().getNumFound());\n+            }\n+          } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage());\n+          }\n+\n+          return true;\n+        });\n+      }\n+\n+      futures = executor.invokeAll(callableList);\n+\n+      for (Future<?> future : futures) {\n+        try {\n+          future.get();", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxMjk4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466812986", "bodyText": "assertTrue(future.get() != null); instead?", "author": "atris", "createdAt": "2020-08-07T04:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk4NTg4MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466985880", "bodyText": "I\u2019m just going by memory here, but I thought future.get gives you the return value of the callable which should always be true in this case for success?", "author": "madrob", "createdAt": "2020-08-07T11:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MTg2OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466661868", "bodyText": "given that this pattern is repeated between the tests, can we pull it into a separate method?", "author": "madrob", "createdAt": "2020-08-06T20:16:50Z", "path": "solr/core/src/test/org/apache/solr/servlet/TestRequestRateLimiter.java", "diffHunk": "@@ -102,31 +103,101 @@ public Boolean call() throws Exception {\n         try {\n           future.get();\n         } catch (Exception e) {\n-          assertTrue(\"Not true \" + e.getMessage(), e.getMessage().contains(\"non ok status: 429, message:Too Many Requests\"));\n+          assertThat(e.getMessage(), containsString(\"non ok status: 429, message:Too Many Requests\"));\n         }\n       }\n \n       MockRequestRateLimiter mockQueryRateLimiter = (MockRequestRateLimiter) rateLimitManager.getRequestRateLimiter(SolrRequest.SolrRequestType.QUERY);\n \n-      assertTrue(\"Incoming request count did not match. Expected == 25  incoming \" + mockQueryRateLimiter.incomingRequestCount.get(),\n-          mockQueryRateLimiter.incomingRequestCount.get() == 25);\n+      assertEquals(mockQueryRateLimiter.incomingRequestCount.get(),25);\n       assertTrue(\"Incoming accepted new request count did not match. Expected 5 incoming \" + mockQueryRateLimiter.acceptedNewRequestCount.get(),\n           mockQueryRateLimiter.acceptedNewRequestCount.get() < 25);\n       assertTrue(\"Incoming rejected new request count did not match. Expected 20 incoming \" + mockQueryRateLimiter.rejectedRequestCount.get(),\n           mockQueryRateLimiter.rejectedRequestCount.get() > 0);\n-      assertTrue(\"Incoming total processed requests count did not match. Expected \" + mockQueryRateLimiter.incomingRequestCount.get() + \" incoming \"\n-              + (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()),\n-          (mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get()) == mockQueryRateLimiter.incomingRequestCount.get());\n+      assertEquals(mockQueryRateLimiter.acceptedNewRequestCount.get() + mockQueryRateLimiter.rejectedRequestCount.get(),\n+          mockQueryRateLimiter.incomingRequestCount.get());\n+    } finally {\n+      executor.shutdown();\n+    }\n+  }\n+\n+  @Test\n+  public void testSlotBorrowing() throws Exception {\n+    CloudSolrClient client = cluster.getSolrClient();\n+    client.setDefaultCollection(SECOND_COLLECTION);\n+\n+    CollectionAdminRequest.createCollection(SECOND_COLLECTION, 1, 1).process(client);\n+    cluster.waitForActiveCollection(SECOND_COLLECTION, 1, 1);\n+\n+\n+    SolrDispatchFilter solrDispatchFilter = cluster.getJettySolrRunner(0).getSolrDispatchFilter();\n+\n+    RequestRateLimiter.RateLimiterConfig queryRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.QUERY,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    RequestRateLimiter.RateLimiterConfig indexRateLimiterConfig = new RequestRateLimiter.RateLimiterConfig(SolrRequest.SolrRequestType.UPDATE,\n+        true, 1, DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS, 5 /* allowedRequests */, true /* isSlotBorrowing */);\n+    // We are fine with a null FilterConfig here since we ensure that MockBuilder never invokes its parent\n+    RateLimitManager.Builder builder = new MockBuilder(null /*dummy FilterConfig */, new MockRequestRateLimiter(queryRateLimiterConfig, 5), new MockRequestRateLimiter(indexRateLimiterConfig, 5));\n+    RateLimitManager rateLimitManager = builder.build();\n+\n+    solrDispatchFilter.replaceRateLimitManager(rateLimitManager);\n+\n+    for (int i = 0; i < 100; i++) {\n+      SolrInputDocument doc = new SolrInputDocument();\n+\n+      doc.setField(\"id\", i);\n+      doc.setField(\"text\", \"foo\");\n+      client.add(doc);\n+    }\n+\n+    client.commit();\n+\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\"threadpool\");\n+    List<Callable<Boolean>> callableList = new ArrayList<>();\n+    List<Future<Boolean>> futures;\n+\n+    try {", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MjU3OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466662578", "bodyText": "maybe declare this as a ConcurrentMap just to really drive the point home?", "author": "madrob", "createdAt": "2020-08-06T20:18:16Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -38,9 +41,14 @@\n  * rate limiting is being done for a specific request type.\n  */\n public class RateLimitManager {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n   public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n   public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n   private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  // IMPORTANT: The slot from the corresponding rate limiter should be acquired before adding the request\n+  // to this map. Subsequently, the request should be deleted from the map before the slot is released.\n   private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxMzE4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466813189", "bodyText": "This is already a ConcurrentHashMap. The comment is redundant, removing.", "author": "atris", "createdAt": "2020-08-07T04:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MjU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2MzE1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466663159", "bodyText": "Add a comment something like // Can't borrow from ourselves", "author": "madrob", "createdAt": "2020-08-06T20:19:27Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -92,17 +100,28 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n    * For each request rate limiter whose type that is not of the type of the request which got rejected,\n    * check if slot borrowing is enabled. If enabled, try to acquire a slot.\n    * If allotted, return else try next request type.\n+   *\n+   * @lucene.gexperimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.\n    */\n   private RequestRateLimiter trySlotBorrowing(String requestType) {\n     for (Map.Entry<String, RequestRateLimiter> currentEntry : requestRateLimiterMap.entrySet()) {\n       RequestRateLimiter requestRateLimiter = currentEntry.getValue();\n \n-      if (requestRateLimiter.getRateLimiterConfig().requestType.equals(requestType)) {\n+      if (requestRateLimiter.getRateLimiterConfig().requestType.toString().equals(requestType)) {", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2ODkzMw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466668933", "bodyText": "combine these into populateHeaders(HttpMessage, Header[])", "author": "madrob", "createdAt": "2020-08-06T20:30:55Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java", "diffHunk": "@@ -723,14 +716,35 @@ private HttpEntityEnclosingRequestBase fillContentStream(\n     }\n   }\n \n-  // When raising an error using HTTP sendError, mime types can be mismatched\n+  // When raising an error using HTTP sendError, mime types can be mismatched. This is specifically true when\n+  // SolrDispatchFilter uses the sendError mechanism since the expected MIME type of response is not HTML but\n+  // HTTP sendError generates a HTML output, which can lead to mismatch\n   private boolean isUnmatchedErrorCode(String mimeType, int httpStatus) {\n     if (mimeType.equalsIgnoreCase(\"text/html\") && UNMATCHED_ACCEPTED_ERROR_CODES.contains(httpStatus)) {\n       return true;\n     }\n \n     return false;\n   }\n+\n+  private Header[] buildRequestSpecificHeaders(@SuppressWarnings({\"rawtypes\"}) final SolrRequest request) {\n+    Header[] contextHeaders = new Header[2];\n+\n+    contextHeaders[0] = new BasicHeader(CommonParams.SOLR_REQUEST_CONTEXT_PARAM, getContext().toString());\n+    contextHeaders[1] = new BasicHeader(CommonParams.SOLR_REQUEST_TYPE_PARAM, request.getRequestType());\n+\n+    return contextHeaders;\n+  }\n+\n+  private void populateHeadersInResult(HttpGet result, Header[] contextHeaders) {\n+    result.addHeader(contextHeaders[0]);\n+    result.addHeader(contextHeaders[1]);\n+  }\n+\n+  private void populateHeadersInRequestBase(HttpEntityEnclosingRequestBase postOrPut, Header[] contextHeaders) {\n+    postOrPut.addHeader(contextHeaders[0]);\n+    postOrPut.addHeader(contextHeaders[1]);\n+  }", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3Mzk2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466673963", "bodyText": "This is suspicious, given that we don't synchronize on the instance when trying to acquire permits directly (non-borrowed). I understand that the goal is to prevent a race between checking that there are enough sufficient permits and acquiring one of the extras... but the java docs for available permits also suggests that it is for debugging or testing only, not a real concurrency construct. The proper way to do this might be two semaphores - one for dedicated slots and one for shared slots. Incoming requests for this limiter can take from the shared slots first and then if those run out then they can go to the reserved slots. Borrow requests can only go to the share slot semaphore. Would need to track which pool we took from then, which makes this less ideal.", "author": "madrob", "createdAt": "2020-08-06T20:41:08Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -53,6 +53,8 @@ public boolean handleRequest() throws InterruptedException {\n    * Whether to allow another request type to borrow a slot from this request rate limiter. Typically works fine\n    * if there is a relatively lesser load on this request rate limiter's type compared to the others (think of skew).\n    * @return true if allow, false otherwise\n+   *\n+   * @lucene.experimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.\n    */\n   public boolean allowSlotBorrowing() {\n     synchronized (this) {", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3NTc4MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466675780", "bodyText": "Also need to restore interrupted status.", "author": "madrob", "createdAt": "2020-08-06T20:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3Mzk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkxODg1Mw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466918853", "bodyText": "Good point. I was not sure around using availablePermits for this use but decided for using it. IMO the worst that can happen is that a request gets an indication from availablePermits as to the availability of a slot but fails to acquire it since another concurrent request has acquired the same. The approach that you suggest is more comprehensive, so changed to that, thanks.", "author": "atris", "createdAt": "2020-08-07T09:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3Mzk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4NzE3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466687173", "bodyText": "Did we give up on using the authentication plugin info to determine if this is an internal request or not?", "author": "madrob", "createdAt": "2020-08-06T21:08:05Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  // IMPORTANT: The slot from the corresponding rate limiter should be acquired before adding the request\n+  // to this map. Subsequently, the request should be deleted from the map before the slot is released.\n+  private final Map<HttpServletRequest, RequestRateLimiter> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected\n+  public boolean handleRequest(HttpServletRequest request) throws InterruptedException {\n+    String requestContext = request.getHeader(SOLR_REQUEST_CONTEXT_PARAM);", "originalCommit": "47d2916ae38c001b9b4cc7ff6e083130ba3604de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0Nzc4OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r466947788", "bodyText": "https://issues.apache.org/jira/browse/SOLR-14720", "author": "atris", "createdAt": "2020-08-07T10:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4NzE3Mw=="}], "type": "inlineReview"}, {"oid": "51b38a88c2844080865d90fda0aa57ebf4369f90", "url": "https://github.com/apache/lucene-solr/commit/51b38a88c2844080865d90fda0aa57ebf4369f90", "message": "Move to a dedicated pool and more fixes", "committedDate": "2020-08-07T10:15:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNDEzNw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467104137", "bodyText": "I would write this as something like:\nclass SemaphoreWrapper() {\n  Semaphore wrapped;\n\n  release() {\n    if (wrapped != null) wrapped.release();\n  }\n}\n\n  public SempahoreWrapper handleRequest() throws InterruptedException {\n      if (!rateLimiterConfig.isEnabled) {\n       return nopPool; // = new SemaphoreWrapper(null);\n     }\n\n    if (guaranteedSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n       return new SemaphoreWrapper(guaranteedSlotsPool);\n     }\n\n    if (borrowableSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n       return new SemaphoreWrapper(borrowableSlotsPool);\n     }\n \n      return null;\n   }\n\nAnd probably have the limiter own the wrappers and return the right thing each time instead of creating a new wrapper.", "author": "madrob", "createdAt": "2020-08-07T15:15:13Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -58,18 +58,18 @@ public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n   public Pair<Boolean, AcquiredSlotMetadata> handleRequest() throws InterruptedException {\n \n     if (!rateLimiterConfig.isEnabled) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, null);\n+      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(null, null));\n     }\n \n     if (guaranteedSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, false));\n+      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, guaranteedSlotsPool));\n     }\n \n     if (borrowableSlotsPool.tryAcquire(rateLimiterConfig.waitForSlotAcquisition, TimeUnit.MILLISECONDS)) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, true));\n+      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(this, borrowableSlotsPool));\n     }\n \n-    return new Pair<Boolean, AcquiredSlotMetadata>(false, null);\n+    return new Pair<Boolean, AcquiredSlotMetadata>(false, new AcquiredSlotMetadata(null, null));\n   }", "originalCommit": "3fd6aad10476ae5bbbf9387ea20968c0e634b799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzExMDI3NA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467110274", "bodyText": "We need the rate limiter to be a part of the returned value here so that the decrement can be invoked on the right RequestRateLimiter?", "author": "atris", "createdAt": "2020-08-07T15:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNDEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MTY3Ng==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467161676", "bodyText": "I'd prefer to see these as pre declared members so that we're not allocating a new metadata on each request.", "author": "madrob", "createdAt": "2020-08-07T17:03:15Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -55,21 +54,21 @@ public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n    * NOTE: Always check for a null metadata object even if this method returns a true -- this will be the scenario when\n    * rate limiters are not enabled.\n    * */\n-  public Pair<Boolean, AcquiredSlotMetadata> handleRequest() throws InterruptedException {\n+  public SlotMetadata handleRequest() throws InterruptedException {\n \n     if (!rateLimiterConfig.isEnabled) {\n-      return new Pair<Boolean, AcquiredSlotMetadata>(true, new AcquiredSlotMetadata(null, null));\n+      return new SlotMetadata(null);", "originalCommit": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MzI5MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467163290", "bodyText": "This seems like an implementation detail that we don't need to expose?", "author": "madrob", "createdAt": "2020-08-07T17:06:36Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -152,14 +143,22 @@ public RateLimiterConfig(SolrRequest.SolrRequestType requestType, boolean isEnab\n     }\n   }\n \n-  // Represents the metadata for an acquired slot\n-  static class AcquiredSlotMetadata {\n-    public RequestRateLimiter requestRateLimiter;\n-    public Semaphore usedPool;\n+  // Represents the metadata for a slot\n+  static class SlotMetadata {\n+    private Semaphore usedPool;\n \n-    public AcquiredSlotMetadata(RequestRateLimiter requestRateLimiter, Semaphore usedPool) {\n-      this.requestRateLimiter = requestRateLimiter;\n+    public SlotMetadata(Semaphore usedPool) {\n       this.usedPool = usedPool;\n     }\n+\n+    public void decrementRequest() {\n+      if (usedPool != null) {\n+        usedPool.release();\n+      }\n+    }\n+\n+    public boolean isUsedPoolNull() {", "originalCommit": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NjY2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467176662", "bodyText": "We need this to avoid caching a request when request rate limiter is disabled. Renaming the method.", "author": "atris", "createdAt": "2020-08-07T17:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MzI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTA3OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467165078", "bodyText": "I think I would flip this condition so that we only have one return point from the method.", "author": "madrob", "createdAt": "2020-08-07T17:10:10Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -147,19 +145,16 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n \n   // Decrement the active requests in the rate limiter for the corresponding request type.\n   public void decrementActiveRequests(HttpServletRequest request) {\n-    RequestRateLimiter.AcquiredSlotMetadata acquiredSlotMetadata = activeRequestsMap.get(request);\n+    RequestRateLimiter.SlotMetadata slotMetadata = activeRequestsMap.get(request);\n \n-    if (acquiredSlotMetadata == null) {\n+    if (slotMetadata == null) {", "originalCommit": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTQwNg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467165406", "bodyText": "This should never happen, right?", "author": "madrob", "createdAt": "2020-08-07T17:10:48Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -132,12 +130,12 @@ public boolean handleRequest(HttpServletRequest request) throws InterruptedExcep\n           Thread.currentThread().interrupt();\n         }\n \n-        if (result != null && result.first()) {\n-          if (result.second() == null) {\n-            throw new IllegalStateException(\"AcquiredSlotMetadata object null even when slot is acquired and rate limiters are enabled\");\n-          }\n+        if (result == null) {", "originalCommit": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3ODI1MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467178250", "bodyText": "Yes, thats why the check.", "author": "atris", "createdAt": "2020-08-07T17:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTYzMg==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467165632", "bodyText": "javadoc on this is out of date, still refers to booleans", "author": "madrob", "createdAt": "2020-08-07T17:11:16Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -80,20 +79,12 @@ public RequestRateLimiter(RateLimiterConfig rateLimiterConfig) {\n    *\n    * @lucene.experimental -- Can cause slots to be blocked if a request borrows a slot and is itself long lived.\n    */\n-  public Pair<Boolean, AcquiredSlotMetadata> allowSlotBorrowing() throws InterruptedException {\n+  public SlotMetadata allowSlotBorrowing() throws InterruptedException {", "originalCommit": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NjExMw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467166113", "bodyText": "nit: use proper javadoc", "author": "madrob", "createdAt": "2020-08-07T17:12:17Z", "path": "solr/core/src/java/org/apache/solr/servlet/RateLimitManager.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.servlet;\n+\n+import javax.servlet.FilterConfig;\n+import javax.servlet.http.HttpServletRequest;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_CONTEXT_PARAM;\n+import static org.apache.solr.common.params.CommonParams.SOLR_REQUEST_TYPE_PARAM;\n+\n+/**\n+ * This class is responsible for managing rate limiting per request type. Rate limiters\n+ * can be registered with this class against a corresponding type. There can be only one\n+ * rate limiter associated with a request type.\n+ *\n+ * The actual rate limiting and the limits should be implemented in the corresponding RequestRateLimiter\n+ * implementation. RateLimitManager is responsible for the orchestration but not the specifics of how the\n+ * rate limiting is being done for a specific request type.\n+ */\n+public class RateLimitManager {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public final static int DEFAULT_CONCURRENT_REQUESTS= (Runtime.getRuntime().availableProcessors()) * 3;\n+  public final static long DEFAULT_SLOT_ACQUISITION_TIMEOUT_MS = -1;\n+  private final Map<String, RequestRateLimiter> requestRateLimiterMap;\n+\n+  private final Map<HttpServletRequest, RequestRateLimiter.SlotMetadata> activeRequestsMap;\n+\n+  public RateLimitManager() {\n+    this.requestRateLimiterMap = new HashMap<>();\n+    this.activeRequestsMap = new ConcurrentHashMap<>();\n+  }\n+\n+  // Handles an incoming request. The main orchestration code path, this method will\n+  // identify which (if any) rate limiter can handle this request. Internal requests will not be\n+  // rate limited\n+  // Returns true if request is accepted for processing, false if it should be rejected", "originalCommit": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NjY3MA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467166670", "bodyText": "\ud83d\udc4d", "author": "madrob", "createdAt": "2020-08-07T17:13:29Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -152,14 +143,22 @@ public RateLimiterConfig(SolrRequest.SolrRequestType requestType, boolean isEnab\n     }\n   }\n \n-  // Represents the metadata for an acquired slot\n-  static class AcquiredSlotMetadata {\n-    public RequestRateLimiter requestRateLimiter;\n-    public Semaphore usedPool;\n+  // Represents the metadata for a slot\n+  static class SlotMetadata {", "originalCommit": "e5ca7201ab3c5322c7e8ea4db058e286ceb41af3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c658dcd1841d7f07e3e1acfc6726990418058cff", "url": "https://github.com/apache/lucene-solr/commit/c658dcd1841d7f07e3e1acfc6726990418058cff", "message": "First cut at identifying request types", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "2a6598caf6c139dacfa7268e731708070f88590e", "url": "https://github.com/apache/lucene-solr/commit/2a6598caf6c139dacfa7268e731708070f88590e", "message": "First cut at request level rate limiter", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "c3ae7db2e75078aec0d87c42b0ec4b20e746d505", "url": "https://github.com/apache/lucene-solr/commit/c3ae7db2e75078aec0d87c42b0ec4b20e746d505", "message": "Get Query Test Passing", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "20d53a49f0bbab13dc8de128e964fb6b4f812f76", "url": "https://github.com/apache/lucene-solr/commit/20d53a49f0bbab13dc8de128e964fb6b4f812f76", "message": "Make tests more intense", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "c7128313d9adc701d6a47233566403383d7eeabe", "url": "https://github.com/apache/lucene-solr/commit/c7128313d9adc701d6a47233566403383d7eeabe", "message": "Pass all tests", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "b4b91567e40451798a5f937cfda537195418e809", "url": "https://github.com/apache/lucene-solr/commit/b4b91567e40451798a5f937cfda537195418e809", "message": "Basic Cleanup", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "c9ed4891697af34678e3b78e01fc10dd901d0b91", "url": "https://github.com/apache/lucene-solr/commit/c9ed4891697af34678e3b78e01fc10dd901d0b91", "message": "Remove erratic character", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "067beab1073b21025977148ed599b5c853ed50d5", "url": "https://github.com/apache/lucene-solr/commit/067beab1073b21025977148ed599b5c853ed50d5", "message": "More Documentation", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "e68b4b380e407b371993f7626989aa2197c5af63", "url": "https://github.com/apache/lucene-solr/commit/e68b4b380e407b371993f7626989aa2197c5af63", "message": "Give priority to previous request's rate limiter when taking next request", "committedDate": "2020-08-07T18:00:48Z", "type": "commit"}, {"oid": "d27b7d5fa2ea2e70364693e2f58cc5a9495d46cb", "url": "https://github.com/apache/lucene-solr/commit/d27b7d5fa2ea2e70364693e2f58cc5a9495d46cb", "message": "Better Documentation", "committedDate": "2020-08-07T18:00:49Z", "type": "commit"}, {"oid": "724ef32aa7cbc2213667be5aa6f798572ca2bcad", "url": "https://github.com/apache/lucene-solr/commit/724ef32aa7cbc2213667be5aa6f798572ca2bcad", "message": "Remove index rate limiter", "committedDate": "2020-08-07T18:00:49Z", "type": "commit"}, {"oid": "58c51b6d9be3b949f62acb21d2ad35bfd1f54740", "url": "https://github.com/apache/lucene-solr/commit/58c51b6d9be3b949f62acb21d2ad35bfd1f54740", "message": "More refactor", "committedDate": "2020-08-07T18:00:49Z", "type": "commit"}, {"oid": "8144a3bf4f67ea2579fb155f39751b8e58baeff7", "url": "https://github.com/apache/lucene-solr/commit/8144a3bf4f67ea2579fb155f39751b8e58baeff7", "message": "Update CHANGES>txt entry", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "957582bd99374b96281935419d665161c0358dab", "url": "https://github.com/apache/lucene-solr/commit/957582bd99374b96281935419d665161c0358dab", "message": "More stuff", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "8218c9530c886d8dcd3ae0bbbbfb0ea513134a03", "url": "https://github.com/apache/lucene-solr/commit/8218c9530c886d8dcd3ae0bbbbfb0ea513134a03", "message": "Remove redundant definitions", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "3041eefc5a2bed425ddb6f0fafdc9eea34057f71", "url": "https://github.com/apache/lucene-solr/commit/3041eefc5a2bed425ddb6f0fafdc9eea34057f71", "message": "Rename configuration parameters", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "df6e0163e0a456e3ba7e2b86eadb902315393f56", "url": "https://github.com/apache/lucene-solr/commit/df6e0163e0a456e3ba7e2b86eadb902315393f56", "message": "Add missing request type impl", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "0c32e4e625333d88b6d95cc2fbc8e53f8d2685e6", "url": "https://github.com/apache/lucene-solr/commit/0c32e4e625333d88b6d95cc2fbc8e53f8d2685e6", "message": "Renaming variables", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "860a47fafff67101faee981f6e43e60766a43355", "url": "https://github.com/apache/lucene-solr/commit/860a47fafff67101faee981f6e43e60766a43355", "message": "Make HttpSolrClient handle 503", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "5eb67b83755e4e6913ec559baf09393b920afdb0", "url": "https://github.com/apache/lucene-solr/commit/5eb67b83755e4e6913ec559baf09393b920afdb0", "message": "Add new parameter and error handling", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "29e79734b91bde1af5cad2ac1436587f99ffee03", "url": "https://github.com/apache/lucene-solr/commit/29e79734b91bde1af5cad2ac1436587f99ffee03", "message": "Update error sending mechanism", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "d74d096bdd35ca572979d0706310e93fa9f328f5", "url": "https://github.com/apache/lucene-solr/commit/d74d096bdd35ca572979d0706310e93fa9f328f5", "message": "Fix wrong doc link", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "dd3e46d94eba2ad511e4b69381b1d35be8c77678", "url": "https://github.com/apache/lucene-solr/commit/dd3e46d94eba2ad511e4b69381b1d35be8c77678", "message": "Strict log checking", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "0190f279218d3a0c59b037e55f373139f48e1fc5", "url": "https://github.com/apache/lucene-solr/commit/0190f279218d3a0c59b037e55f373139f48e1fc5", "message": "Fix Gradle precommit", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "7fe6f4fdb411a75ef06a10b0d8424068fcd58dd9", "url": "https://github.com/apache/lucene-solr/commit/7fe6f4fdb411a75ef06a10b0d8424068fcd58dd9", "message": "More stuff", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "8368b7d5790d2e6fcfa958cfccfa219176bfbb5d", "url": "https://github.com/apache/lucene-solr/commit/8368b7d5790d2e6fcfa958cfccfa219176bfbb5d", "message": "Fix Review Comments", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "2180c798b9c54bbcf296f6ac91dfd88cafd01f10", "url": "https://github.com/apache/lucene-solr/commit/2180c798b9c54bbcf296f6ac91dfd88cafd01f10", "message": "Remove redundant mock rate limiter", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "0495aecd14564cf269c053b21a80037afe441032", "url": "https://github.com/apache/lucene-solr/commit/0495aecd14564cf269c053b21a80037afe441032", "message": "Do not block rejected requests", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "25dd53d4cee10ffdb4dad4a1074f0bd24935c04a", "url": "https://github.com/apache/lucene-solr/commit/25dd53d4cee10ffdb4dad4a1074f0bd24935c04a", "message": "More Stuff", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "6aaaf4a10f592688be8632d0185fb50665b7e3bd", "url": "https://github.com/apache/lucene-solr/commit/6aaaf4a10f592688be8632d0185fb50665b7e3bd", "message": "Update per comments", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "cafbd3e0c05e40954838c4fb0d04e15e8fc3a0a4", "url": "https://github.com/apache/lucene-solr/commit/cafbd3e0c05e40954838c4fb0d04e15e8fc3a0a4", "message": "More updates", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "c03c57b61a41a0e8ba792cf756d572c1f79becc3", "url": "https://github.com/apache/lucene-solr/commit/c03c57b61a41a0e8ba792cf756d572c1f79becc3", "message": "More stuff", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "59175512b9608586190be13eb944593219d424b7", "url": "https://github.com/apache/lucene-solr/commit/59175512b9608586190be13eb944593219d424b7", "message": "More review comments", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "2df9dc4948b3fbc33a2a1bfd8a645b40c9d2e393", "url": "https://github.com/apache/lucene-solr/commit/2df9dc4948b3fbc33a2a1bfd8a645b40c9d2e393", "message": "Fix Precommit Failures", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "2db8bdc7ff43d86e66590c0e0e39b96f561c38f9", "url": "https://github.com/apache/lucene-solr/commit/2db8bdc7ff43d86e66590c0e0e39b96f561c38f9", "message": "Move to a dedicated pool and more fixes", "committedDate": "2020-08-07T18:01:44Z", "type": "commit"}, {"oid": "877d008f36e0acf99060910e270e9ce07ff179c6", "url": "https://github.com/apache/lucene-solr/commit/877d008f36e0acf99060910e270e9ce07ff179c6", "message": "Stricter type casting", "committedDate": "2020-08-07T18:01:45Z", "type": "commit"}, {"oid": "6f67e8ec0b2c38990808ab499f4a1ef483d42e9e", "url": "https://github.com/apache/lucene-solr/commit/6f67e8ec0b2c38990808ab499f4a1ef483d42e9e", "message": "Remove redundant params", "committedDate": "2020-08-07T18:01:45Z", "type": "commit"}, {"oid": "65fb7565b861cbf71da4c9ee9b4d7b7cc0f3791b", "url": "https://github.com/apache/lucene-solr/commit/65fb7565b861cbf71da4c9ee9b4d7b7cc0f3791b", "message": "Refactor metadata to use better null semantics", "committedDate": "2020-08-07T18:01:45Z", "type": "commit"}, {"oid": "efa5bce5ef1e74a93ccfa4fb04bcdae1d7351956", "url": "https://github.com/apache/lucene-solr/commit/efa5bce5ef1e74a93ccfa4fb04bcdae1d7351956", "message": "Refactor to use pools", "committedDate": "2020-08-07T18:01:45Z", "type": "commit"}, {"oid": "47ff3abdeb6c7bc8053dffeab3468a61f95f17a7", "url": "https://github.com/apache/lucene-solr/commit/47ff3abdeb6c7bc8053dffeab3468a61f95f17a7", "message": "Update per comments", "committedDate": "2020-08-07T18:01:45Z", "type": "commit"}, {"oid": "e35a15736d7507dab31d3d8d8fc23db8538dd29c", "url": "https://github.com/apache/lucene-solr/commit/e35a15736d7507dab31d3d8d8fc23db8538dd29c", "message": "Fix test", "committedDate": "2020-08-07T18:01:45Z", "type": "commit"}, {"oid": "e35a15736d7507dab31d3d8d8fc23db8538dd29c", "url": "https://github.com/apache/lucene-solr/commit/e35a15736d7507dab31d3d8d8fc23db8538dd29c", "message": "Fix test", "committedDate": "2020-08-07T18:01:45Z", "type": "forcePushed"}, {"oid": "71d7991dae8af503ddb63b674d6072c0e9ca8ce7", "url": "https://github.com/apache/lucene-solr/commit/71d7991dae8af503ddb63b674d6072c0e9ca8ce7", "message": "Update CHANGES.txt", "committedDate": "2020-08-07T18:03:59Z", "type": "commit"}, {"oid": "12c71a553759d33c12bf7810d10581cb83cc3878", "url": "https://github.com/apache/lucene-solr/commit/12c71a553759d33c12bf7810d10581cb83cc3878", "message": "Remove wrong entry", "committedDate": "2020-08-07T18:19:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMzI0OA==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467213248", "bodyText": "Should be != null, right? Check the condition wherever this is called too, might need to invert those.", "author": "madrob", "createdAt": "2020-08-07T18:51:47Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -157,7 +162,7 @@ public void decrementRequest() {\n       }\n     }\n \n-    public boolean isUsedPoolNull() {\n+    public boolean isReleasable() {\n       return usedPool == null;", "originalCommit": "47ff3abdeb6c7bc8053dffeab3468a61f95f17a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxOTQ5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467219496", "bodyText": "Fixed", "author": "atris", "createdAt": "2020-08-07T19:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMzc2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1686#discussion_r467213763", "bodyText": "can this be static? pretty minor but since it doesn't do anything, it can be shared by all the instances and save some memory", "author": "madrob", "createdAt": "2020-08-07T18:53:07Z", "path": "solr/core/src/java/org/apache/solr/servlet/RequestRateLimiter.java", "diffHunk": "@@ -40,32 +42,35 @@\n   private final Semaphore borrowableSlotsPool;\n \n   private final RateLimiterConfig rateLimiterConfig;\n+  private final SlotMetadata guaranteedSlotMetadata;\n+  private final SlotMetadata borrowedSlotMetadata;\n+  private final SlotMetadata nullSlotMetadata;", "originalCommit": "47ff3abdeb6c7bc8053dffeab3468a61f95f17a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64c26359d5c38eb0d1a8b5e57f08c0a190508745", "url": "https://github.com/apache/lucene-solr/commit/64c26359d5c38eb0d1a8b5e57f08c0a190508745", "message": "Fix method usage", "committedDate": "2020-08-07T18:58:49Z", "type": "commit"}, {"oid": "a13dc369ac8cf24388231b4aa0adb4efb31144e6", "url": "https://github.com/apache/lucene-solr/commit/a13dc369ac8cf24388231b4aa0adb4efb31144e6", "message": "Fix statics", "committedDate": "2020-08-07T19:06:41Z", "type": "commit"}, {"oid": "48bb56c92256603c41de5f7721c344a99927f149", "url": "https://github.com/apache/lucene-solr/commit/48bb56c92256603c41de5f7721c344a99927f149", "message": "Fix blah", "committedDate": "2020-08-07T19:15:24Z", "type": "commit"}, {"oid": "0d2f88d18af64fb046a949986c99a29ae61b1159", "url": "https://github.com/apache/lucene-solr/commit/0d2f88d18af64fb046a949986c99a29ae61b1159", "message": "Move static initialization", "committedDate": "2020-08-07T19:49:25Z", "type": "commit"}]}