{"pr_number": 1606, "pr_title": "SOLR-14588: Implement Circuit Breakers", "pr_createdAt": "2020-06-23T15:46:01Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1606", "timeline": [{"oid": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "url": "https://github.com/apache/lucene-solr/commit/4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-23T16:01:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzNDI3OA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444334278", "bodyText": "prefer entrySet", "author": "madrob", "createdAt": "2020-06-23T15:58:49Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every\n+ * request.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    assert circuitBreakerType != null && circuitBreaker != null;\n+\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = new HashMap<>();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {", "originalCommit": "56d8b7a183c36caf5ef682000eba8cd0f4cf3d8a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMzNzk4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444337985", "bodyText": "this would be better as seenMemory=X allowedMemory=Y - a little bit less human readable but a lot easier to grep for or search in something like Splunk.", "author": "madrob", "createdAt": "2020-06-23T16:04:06Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTI2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444341261", "bodyText": "Should we validate that this is between 0 and 100?", "author": "madrob", "createdAt": "2020-06-23T16:08:50Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,9 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);\n+    memoryCircuitBreakerThreshold = getInt(\"query/memoryCircuitBreakerThreshold\", 100);", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4Mjc5OA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444382798", "bodyText": "Good catch, thanks!", "author": "atris", "createdAt": "2020-06-23T17:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTUxNw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444341517", "bodyText": "Is this checking for overflow? How does the error condition occur otherwise?", "author": "madrob", "createdAt": "2020-06-23T16:09:16Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;\n+    }\n+\n+    double thresholdInFraction = (double) thresholdValueInPercentage / 100;\n+    double actualLimit = currentMaxHeap * thresholdInFraction;\n+\n+    if (actualLimit <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNTA2MA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444425060", "bodyText": "Yes, this is an overflow check.", "author": "atris", "createdAt": "2020-06-23T18:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MTg4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444341889", "bodyText": "I think this makes more sense to be a long. Returning fractional bytes is meaningless.", "author": "madrob", "createdAt": "2020-06-23T16:09:50Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;\n+    }\n+\n+    double thresholdInFraction = (double) thresholdValueInPercentage / 100;\n+    double actualLimit = currentMaxHeap * thresholdInFraction;", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MjIxMw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444342213", "bodyText": "commit-optimize-commit in a loop won't get you multiple segments", "author": "madrob", "createdAt": "2020-06-23T16:10:20Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNTM4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444425382", "bodyText": "Removed the commit optimize.", "author": "atris", "createdAt": "2020-06-23T18:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MjIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MjU2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444342561", "bodyText": "Probably want to also call executor.shutdown in addition to null?", "author": "madrob", "createdAt": "2020-06-23T16:10:51Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    executor = null;", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4Mzg1MA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444383850", "bodyText": "This should be shutdown in the test itself. I have added a check to check if it is shut down before making the reference null.", "author": "atris", "createdAt": "2020-06-23T17:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MjU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzQyNw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444343427", "bodyText": "Use logger instead of system.out", "author": "madrob", "createdAt": "2020-06-23T16:12:07Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    executor = null;\n+    super.tearDown();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    System.clearProperty(\"filterCache.enabled\");\n+    System.clearProperty(\"queryResultCache.enabled\");\n+    System.clearProperty(\"documentCache.enabled\");\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testBuildingMemoryPressure() throws Exception {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    CircuitBreaker circuitBreaker = new BuildingUpMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    for (int i = 0; i < 5; i++) {\n+      System.out.println(\"i is \" + i);", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4NDM5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444384399", "bodyText": "Stray debugging output, removed, thanks", "author": "atris", "createdAt": "2020-06-23T17:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzY5MQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444343691", "bodyText": "use unit asserts instead of java asserts please", "author": "madrob", "createdAt": "2020-06-23T16:12:31Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.lucene.util.NamedThreadFactory;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+  private static ExecutorService executor;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(commit());\n+      assertU(optimize());\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    executor = null;\n+    super.tearDown();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    System.clearProperty(\"filterCache.enabled\");\n+    System.clearProperty(\"queryResultCache.enabled\");\n+    System.clearProperty(\"documentCache.enabled\");\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testBuildingMemoryPressure() throws Exception {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    CircuitBreaker circuitBreaker = new BuildingUpMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    for (int i = 0; i < 5; i++) {\n+      System.out.println(\"i is \" + i);\n+      executor.submit(() -> {\n+        try {\n+          h.query(req(\"name:\\\"john smith\\\"\"));\n+        } catch (SolrException e) {\n+          failureCount.incrementAndGet();\n+        } catch (Exception e) {\n+          throw new RuntimeException(e.getMessage());\n+        }\n+      });\n+    }\n+\n+    executor.shutdown();\n+    try {\n+      executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException e) {\n+      throw new RuntimeException(e.getMessage());\n+    }\n+\n+    assert failureCount.get() == 1;", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444344367", "bodyText": "Is this expensive to get? If we're doing it for every query, I'd want to make sure that it is an efficient call.", "author": "madrob", "createdAt": "2020-06-23T16:13:35Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;\n+    }\n+\n+    double thresholdInFraction = (double) thresholdValueInPercentage / 100;\n+    double actualLimit = currentMaxHeap * thresholdInFraction;\n+\n+    if (actualLimit <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+\n+    return actualLimit;\n+  }\n+\n+  /**\n+   * Calculate the live memory usage for the system. This method has package visibility\n+   * to allow using for testing\n+   * @return Memory usage in bytes\n+   */\n+  protected long calculateLiveMemoryUsage() {\n+    return MEMORY_MX_BEAN.getHeapMemoryUsage().getUsed();", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM5NDU0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444394541", "bodyText": "I did not see any regression -- if we note anything otherwise, we can probably cache these values with a TTL. I would be surprised if it causes anything noticeable, though.", "author": "atris", "createdAt": "2020-06-23T17:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNjUxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444416519", "bodyText": "This article claims that each call is about 100ns, https://www.inoneo.com/en/blog/8/java/monitoring-jvm-memory-usage-inside-a-java-application and suggest using a listener instead. I'm not sure how true this is for more modern JVMs anyway.\nIf you look into drop wizard metrics that we're reporting in JMX, MemoryUsageGuageSet reports memory as the combination of heap and non-heap. I'm not sure we need to consider non-heap here, but at least a comment highlighting that would be useful.", "author": "madrob", "createdAt": "2020-06-23T18:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDAwNA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444444004", "bodyText": "Yes, I considered MemoryUsageGaugeSet and did not use it for the precise reason that you described. To be honest, the listener based implementation is harder to read than the current, and I was not sure if it is worth going that route for shaving off < 100 ns per query. However, if you have concerns or if we ever hear slowness reports due to this feature, I am happy to take that route. For now, I have added the comment as suggested, thanks.", "author": "atris", "createdAt": "2020-06-23T19:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5ODQ3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444798477", "bodyText": "@madrob Just verified that Elasticsearch also uses getHeapMemoryUsage() to trigger similar checks per call. Also, I am not sure if NotificationListener will allow us to be real time since it triggers a notification when the threshold is breached. but I could not find a way to know when the threshold has gone back to normal. I am proposing sticking to this for now, if that sounds fine?", "author": "atris", "createdAt": "2020-06-24T10:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1MjU1NQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444952555", "bodyText": "Yea, add some comments to this effect to the code so that if people run into issues with it they can more easily figure out what's up without having to find the comments from this PR.", "author": "madrob", "createdAt": "2020-06-24T14:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk4ODU4OA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444988588", "bodyText": "Added a comment, thanks", "author": "atris", "createdAt": "2020-06-24T15:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDY4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444344681", "bodyText": "This should be constant, right? Get it once at constructor?", "author": "madrob", "createdAt": "2020-06-23T16:14:05Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {\n+      // No threshold\n+      return false;\n+    }\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory \" + seenMemory + \" allowed memory \" + allowedMemory;\n+  }\n+\n+  private double getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();", "originalCommit": "4189d7d483b578ebf91f742c1c3a5e15de8ca77e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM5MjQxMg==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444392412", "bodyText": "Good point, thanks", "author": "atris", "createdAt": "2020-06-23T17:33:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0NDY4MQ=="}], "type": "inlineReview"}, {"oid": "9704538f8fc4764286a82b2010cd27f718d861c0", "url": "https://github.com/apache/lucene-solr/commit/9704538f8fc4764286a82b2010cd27f718d861c0", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-23T16:37:39Z", "type": "commit"}, {"oid": "9704538f8fc4764286a82b2010cd27f718d861c0", "url": "https://github.com/apache/lucene-solr/commit/9704538f8fc4764286a82b2010cd27f718d861c0", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: initial circuit breakers infrastructure and real JVM memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-23T16:37:39Z", "type": "forcePushed"}, {"oid": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839", "url": "https://github.com/apache/lucene-solr/commit/ba9ec9c65399bb6f6bbeb058d8df450f0586f839", "message": "Update per comments", "committedDate": "2020-06-23T18:03:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzEyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444417129", "bodyText": "We only want to do this validation if circuitBreakers are enabled, right?", "author": "madrob", "createdAt": "2020-06-23T18:15:30Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,13 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);\n+    memoryCircuitBreakerThreshold = getInt(\"query/memoryCircuitBreakerThreshold\", 100);\n+\n+    if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {", "originalCommit": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyMzg0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444423842", "bodyText": "I was being overtly cautious here -- it seems wrong if the parameter is incorrectly specified regardless of whether it is used or not?", "author": "atris", "createdAt": "2020-06-23T18:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1MzYzOA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444453638", "bodyText": "Perhaps you want to change this to early saying \"Circuit breaker disabled, but incorrectly configured\" or  conditionally?", "author": "anshumg", "createdAt": "2020-06-23T19:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc0OTA2MA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444749060", "bodyText": "I have changed the check to be only performed when circuit breakers are enabled.", "author": "atris", "createdAt": "2020-06-24T09:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzk0MA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444417940", "bodyText": "This will never be true.", "author": "madrob", "createdAt": "2020-06-23T18:17:05Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private double seenMemory;\n+  private double allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    if (allowedMemory < 0) {", "originalCommit": "ba9ec9c65399bb6f6bbeb058d8df450f0586f839", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNDM0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444424345", "bodyText": "Another of my overtly cautious safety nets :) Removed, thanks.", "author": "atris", "createdAt": "2020-06-23T18:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNzk0MA=="}], "type": "inlineReview"}, {"oid": "3284e7841349c64b9057200cbcb69e171b09ca81", "url": "https://github.com/apache/lucene-solr/commit/3284e7841349c64b9057200cbcb69e171b09ca81", "message": "More comments", "committedDate": "2020-06-23T18:31:39Z", "type": "commit"}, {"oid": "356cc2ce2bdf28b06dc9d51026314b5afff7649e", "url": "https://github.com/apache/lucene-solr/commit/356cc2ce2bdf28b06dc9d51026314b5afff7649e", "message": "Add comment explaining memory calculation choices", "committedDate": "2020-06-23T19:08:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NTAwNA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444455004", "bodyText": "I was thinking of moving this outside of SolrCore, so custom Circuit breakers could be implemented and plugged without any change to SolrCore? What do you think?", "author": "anshumg", "createdAt": "2020-06-23T19:24:50Z", "path": "solr/core/src/java/org/apache/solr/core/SolrCore.java", "diffHunk": "@@ -1164,6 +1171,16 @@ private SolrCoreMetricManager initCoreMetricManager(SolrConfig config) {\n     return coreMetricManager;\n   }\n \n+  private CircuitBreakerManager initCircuitBreakerManager() {\n+    CircuitBreakerManager circuitBreakerManager = new CircuitBreakerManager();\n+\n+    // Install the default circuit breakers\n+    CircuitBreaker memoryCircuitBreaker = new MemoryCircuitBreaker(this);\n+    circuitBreakerManager.registerCircuitBreaker(CircuitBreakerType.MEMORY, memoryCircuitBreaker);", "originalCommit": "356cc2ce2bdf28b06dc9d51026314b5afff7649e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MDMwMg==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444750302", "bodyText": "Agreed. I have moved this to a method in CircuitBreakerManager that can be delegated to for handling this scenario.", "author": "atris", "createdAt": "2020-06-24T09:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1NTAwNA=="}], "type": "inlineReview"}, {"oid": "93765b35d47bf40eb2358c5d025dc087e610ec0c", "url": "https://github.com/apache/lucene-solr/commit/93765b35d47bf40eb2358c5d025dc087e610ec0c", "message": "Cleanups", "committedDate": "2020-06-24T09:05:50Z", "type": "commit"}, {"oid": "ef6f804b232d7f3c4ba7361c4b80ed2242198dbf", "url": "https://github.com/apache/lucene-solr/commit/ef6f804b232d7f3c4ba7361c4b80ed2242198dbf", "message": "Update obsolete comment", "committedDate": "2020-06-24T09:10:00Z", "type": "commit"}, {"oid": "bed17e4266f1b6152acd58e56d737fda01ae222d", "url": "https://github.com/apache/lucene-solr/commit/bed17e4266f1b6152acd58e56d737fda01ae222d", "message": "Fix Precommit", "committedDate": "2020-06-24T09:23:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NDM5Nw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444954397", "bodyText": "nit: s/practise/practice", "author": "madrob", "createdAt": "2020-06-24T14:52:24Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NTIyMA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444955220", "bodyText": "Why is there an assert here? It might be fine to leave it, but I'm curious what the intent is. If you want this check to happen in production, then you probably need to use something like Objects.assertNotNull()", "author": "madrob", "createdAt": "2020-06-24T14:53:24Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every\n+ * request.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    assert circuitBreakerType != null && circuitBreaker != null;", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk5NDE3OQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444994179", "bodyText": "A paranoid security check. Removed, thanks", "author": "atris", "createdAt": "2020-06-24T15:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NzUyNA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444957524", "bodyText": "s/seen memory/seenMemory - one word for log processing", "author": "madrob", "createdAt": "2020-06-24T14:56:30Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private long seenMemory;\n+  private long allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory=\" + seenMemory + \" allowed memory=\" + allowedMemory;", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTI3OA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444961278", "bodyText": "Is this thread safe? If there are multiple queries happening, concurrent with GC, would these values be stale?", "author": "madrob", "createdAt": "2020-06-24T15:01:22Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private long seenMemory;\n+  private long allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MzE4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445063185", "bodyText": "Yes, these values can be stale. I was debating if we need a synchronization here for exact values. Would it make sense to move these to thread local state inside the class instead?", "author": "atris", "createdAt": "2020-06-24T17:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA4Mjg4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445082883", "bodyText": "Moved to thread local", "author": "atris", "createdAt": "2020-06-24T18:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MTI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MzYxNA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444963614", "bodyText": "Does this make sense? It indicates an error condition in the JVM, right? Can move this check to the constructor and throw an Exception since we'd effectively be blocking all queries at that point anyway?", "author": "madrob", "createdAt": "2020-06-24T15:04:27Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private long seenMemory;\n+  private long allowedMemory;\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory = getCurrentMemoryThreshold();\n+\n+    seenMemory = calculateLiveMemoryUsage();\n+\n+    return (seenMemory >= allowedMemory);\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seen memory=\" + seenMemory + \" allowed memory=\" + allowedMemory;\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+\n+    if (currentMaxHeap <= 0) {\n+      return Long.MIN_VALUE;", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxMTczNA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445011734", "bodyText": "My idea was to avoid blocking errors as much as possible but I agree with you. Fixed, thanks", "author": "atris", "createdAt": "2020-06-24T16:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2MzYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2NjE0OA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444966148", "bodyText": "Use a try-finally to make sure this executor is shut down.", "author": "madrob", "createdAt": "2020-06-24T15:08:03Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrCore;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.CircuitBreakerType;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  @AfterClass\n+  public static void afterClass() {\n+    System.clearProperty(\"filterCache.enabled\");\n+    System.clearProperty(\"queryResultCache.enabled\");\n+    System.clearProperty(\"documentCache.enabled\");\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore());\n+\n+    h.getCore().getCircuitBreakerManager().registerCircuitBreaker(CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+  }\n+\n+  public void testBuildingMemoryPressure() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2ODgwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444968805", "bodyText": "A question about the design of this class... We have methods for registering a custom circuit breaker, and some notion of default circuit breakers, but I don't see an easy way to add additional ones. Ideally this would be through the XML or through some kind of schema API or could be very powerful combined with the Package API. I don't have a full idea of what this needs to look like, and this is fine as is to commit now, but I'd really like us to come back to this and develop the idea further. Possibly as a SIP?", "author": "madrob", "createdAt": "2020-06-24T15:11:33Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practise to register new circuit breakers here if you want them checked for every\n+ * request.\n+ */\n+public class CircuitBreakerManager {", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzODMxNg==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445038316", "bodyText": "That is a good point. I was thinking of a schema API since I dont trust XMLs for class level detailing much. Your idea to combine with the package API is a great one. I will open a JIRA once this is committed and follow up with a SIP. For now, adding a comment for the same.", "author": "atris", "createdAt": "2020-06-24T16:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2ODgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2OTUxOA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444969518", "bodyText": "I think we would want to have two separate controls for this.", "author": "madrob", "createdAt": "2020-06-24T15:12:32Z", "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,19 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxNTA5OA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445015098", "bodyText": "++", "author": "atris", "createdAt": "2020-06-24T16:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk2OTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3MjE3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r444972175", "bodyText": "Do we want to time this and include that in the response (useful for both passed and failed breakers)", "author": "madrob", "createdAt": "2020-06-24T15:16:15Z", "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,19 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();", "originalCommit": "bed17e4266f1b6152acd58e56d737fda01ae222d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAzODgxNw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445038817", "bodyText": "Not sure if I understood. Would you mean the epoch timestamp when the circuit breaker triggered?", "author": "atris", "createdAt": "2020-06-24T16:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3MjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA0NjA1Mw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445046053", "bodyText": "I mean in response we send timing info with debug=true(see RTimerTree subt = timer.sub( \"prepare\" );), maybe this is worthwhile to include there as well since otherwise the times may not add up", "author": "madrob", "createdAt": "2020-06-24T17:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3MjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA5NDQ4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445094485", "bodyText": "Added, thanks", "author": "atris", "createdAt": "2020-06-24T18:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3MjE3NQ=="}], "type": "inlineReview"}, {"oid": "7c1b57c262df097ad95678baa516f08056975440", "url": "https://github.com/apache/lucene-solr/commit/7c1b57c262df097ad95678baa516f08056975440", "message": "Moce to ThreadLocal and add timing for debugging", "committedDate": "2020-06-24T18:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODc2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445188767", "bodyText": "Need .get() here.", "author": "madrob", "createdAt": "2020-06-24T21:43:19Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -44,25 +48,20 @@ public boolean isCircuitBreakerGauntletTripped() {\n       return false;\n     }\n \n-    allowedMemory = getCurrentMemoryThreshold();\n+    allowedMemory.set(getCurrentMemoryThreshold());\n \n-    seenMemory = calculateLiveMemoryUsage();\n+    seenMemory.set(calculateLiveMemoryUsage());\n \n-    return (seenMemory >= allowedMemory);\n+    return (seenMemory.get() >= allowedMemory.get());\n   }\n \n   @Override\n   public String printDebugInfo() {\n-    return \"seen memory=\" + seenMemory + \" allowed memory=\" + allowedMemory;\n+    return \"seenMemory=\" + seenMemory + \" allowedMemory=\" + allowedMemory;", "originalCommit": "7c1b57c262df097ad95678baa516f08056975440", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyMTc4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445321786", "bodyText": "Interesting, I thought the default toString delegate should handle the right debug output. Added the get, thanks", "author": "atris", "createdAt": "2020-06-25T05:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTMxNA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445191314", "bodyText": "I'm not sure this is the right error code. A 5xx code usually indicates a server error - and I'm not sure how we effectively convey to clients that this error is something that is ok to retry. They might log the message, but retry logic will typically look at the code returned as a first branch in the decision tree. Need to think about this and maybe look at some examples.", "author": "madrob", "createdAt": "2020-06-24T21:49:05Z", "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,23 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n+\n+    if (trippedCircuitBreakers != null) {\n+      final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n+\n+      if (timer != null) {\n+        RTimerTree subt = timer.sub(\"circuitbreaker\");\n+        rb.setTimer(subt.sub(\"circuitbreaker\"));\n+      }\n+      String errorMessage = CircuitBreakerManager.constructFinalErrorMessageString(trippedCircuitBreakers);\n+      rsp.add(STATUS, FAILURE);\n+      rsp.setException(new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Circuit Breakers tripped \" + errorMessage));", "originalCommit": "7c1b57c262df097ad95678baa516f08056975440", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzMjE2MA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445332160", "bodyText": "I looked at a couple of HTTP codes and SERVICE_UNAVAILABLE seems to be the closest one matching the scenario (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503). Did you have anything else in mind?", "author": "atris", "createdAt": "2020-06-25T06:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0NzA3Mg==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445647072", "bodyText": "Coming back to this, yea, I think 503 is best. I was thinking maybe 429, but this is probably good.", "author": "madrob", "createdAt": "2020-06-25T15:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTg1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445191859", "bodyText": "I'd like for all of this to be dynamically configurable at some point, but it doesn't have to be in this PR. Can add it to the future SIP or create a separate JIRA for it, as you think would be appropriate.", "author": "madrob", "createdAt": "2020-06-24T21:50:18Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,11 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"query/useCircuitBreakers\", false);", "originalCommit": "7c1b57c262df097ad95678baa516f08056975440", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMzMjk3OA==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445332978", "bodyText": "I would ideally want this to be a part of the API we were discussing upstream so will add it to the SIP.", "author": "atris", "createdAt": "2020-06-25T06:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MTg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5Mjc1Mw==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445192753", "bodyText": "I'd combine this with the later call to req.getRequestTimer so that we're not doing that twice. You're also checking this before we call rb.setDebug(), so it probably is always false at this point.\nWe should be timing the circuitBreakerCheck as well (Lines 299-300).", "author": "madrob", "createdAt": "2020-06-24T21:52:16Z", "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,23 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n+\n+    if (trippedCircuitBreakers != null) {\n+      final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;", "originalCommit": "7c1b57c262df097ad95678baa516f08056975440", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1Njg4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445356885", "bodyText": "Fixed, thanks", "author": "atris", "createdAt": "2020-06-25T07:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5Mjc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MzQxMg==", "url": "https://github.com/apache/lucene-solr/pull/1606#discussion_r445193412", "bodyText": "We never stop this subtimer.", "author": "madrob", "createdAt": "2020-06-24T21:53:52Z", "path": "solr/core/src/java/org/apache/solr/handler/component/SearchHandler.java", "diffHunk": "@@ -289,6 +295,23 @@ public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throw\n       rb.requestInfo.setResponseBuilder(rb);\n     }\n \n+    //TODO: Should this be for indexing requests as well?\n+    CircuitBreakerManager circuitBreakerManager = req.getCore().getCircuitBreakerManager();\n+    Map<CircuitBreakerType, CircuitBreaker> trippedCircuitBreakers = circuitBreakerManager.checkAllCircuitBreakers();\n+\n+    if (trippedCircuitBreakers != null) {\n+      final RTimerTree timer = rb.isDebug() ? req.getRequestTimer() : null;\n+\n+      if (timer != null) {\n+        RTimerTree subt = timer.sub(\"circuitbreaker\");", "originalCommit": "7c1b57c262df097ad95678baa516f08056975440", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "073113908be650e36d85ae1ac4745e48bccd6d7b", "url": "https://github.com/apache/lucene-solr/commit/073113908be650e36d85ae1ac4745e48bccd6d7b", "message": "Update timer usage and debug print info", "committedDate": "2020-06-25T07:42:29Z", "type": "commit"}]}