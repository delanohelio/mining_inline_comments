{"pr_number": 2159, "pr_title": "SOLR-14923: Nested docs indexing performance.", "pr_createdAt": "2020-12-21T21:46:38Z", "pr_url": "https://github.com/apache/lucene-solr/pull/2159", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzMTE1OQ==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r551131159", "bodyText": "NULL_DEREFERENCE:  object returned by field.getFirstValue() could be null and is dereferenced at line 205.", "author": "sonatype-lift", "createdAt": "2021-01-04T06:04:05Z", "path": "solr/core/src/java/org/apache/solr/update/AddUpdateCommand.java", "diffHunk": "@@ -95,121 +124,129 @@ public SolrInputDocument getSolrInputDocument() {\n    }\n \n   /**\n-   * Creates and returns a lucene Document to index.\n-   * Nested documents, if found, will cause an exception to be thrown.  Call {@link #getLuceneDocsIfNested()} for that.\n+   * Creates and returns a lucene Document for in-place update.\n+   * The SolrInputDocument itself may be modified, which will be reflected in the update log.\n    * Any changes made to the returned Document will not be reflected in the SolrInputDocument, or future calls to this\n    * method.\n-   * Note that the behavior of this is sensitive to {@link #isInPlaceUpdate()}.*/\n-   public Document getLuceneDocument() {\n-     final boolean ignoreNestedDocs = false; // throw an exception if found\n-     SolrInputDocument solrInputDocument = getSolrInputDocument();\n-     if (!isInPlaceUpdate() && getReq().getSchema().isUsableForChildDocs()) {\n-       addRootField(solrInputDocument, getRootIdUsingRouteParam());\n-     }\n-     return DocumentBuilder.toDocument(solrInputDocument, req.getSchema(), isInPlaceUpdate(), ignoreNestedDocs);\n-   }\n-\n-  /** Returns the indexed ID for this document.  The returned BytesRef is retained across multiple calls, and should not be modified. */\n-   public BytesRef getIndexedId() {\n-     if (indexedId == null) {\n-       IndexSchema schema = req.getSchema();\n-       SchemaField sf = schema.getUniqueKeyField();\n-       if (sf != null) {\n-         if (solrDoc != null) {\n-           SolrInputField field = solrDoc.getField(sf.getName());\n-\n-           int count = field==null ? 0 : field.getValueCount();\n-           if (count == 0) {\n-             if (overwrite) {\n-               throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document is missing mandatory uniqueKey field: \" + sf.getName());\n-             }\n-           } else if (count  > 1) {\n-             throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document contains multiple values for uniqueKey field: \" + field);\n-           } else {\n-             BytesRefBuilder b = new BytesRefBuilder();\n-             sf.getType().readableToIndexed(field.getFirstValue().toString(), b);\n-             indexedId = b.get();\n-           }\n-         }\n-       }\n+   */\n+   Document makeLuceneDocForInPlaceUpdate() {\n+     // perhaps this should move to UpdateHandler or DocumentBuilder?\n+     assert isInPlaceUpdate();\n+     if (req.getSchema().isUsableForChildDocs() && solrDoc.getField(IndexSchema.ROOT_FIELD_NAME) == null) {\n+       solrDoc.setField(IndexSchema.ROOT_FIELD_NAME, getIndexedIdStr());\n      }\n-     return indexedId;\n-   }\n-\n-   public void setIndexedId(BytesRef indexedId) {\n-     this.indexedId = indexedId;\n+     final boolean forInPlaceUpdate = true;\n+     final boolean ignoreNestedDocs = false; // throw an exception if found\n+     return DocumentBuilder.toDocument(solrDoc, req.getSchema(), forInPlaceUpdate, ignoreNestedDocs);\n    }\n \n-   public String getPrintableId() {\n-    if (req != null) {\n-      IndexSchema schema = req.getSchema();\n-      SchemaField sf = schema.getUniqueKeyField();\n-      if (solrDoc != null && sf != null) {\n-        SolrInputField field = solrDoc.getField(sf.getName());\n-        if (field != null) {\n-          return field.getFirstValue().toString();\n-        }\n-      }\n-    }\n-     return \"(null)\";\n-   }\n+  /**\n+   * Returns the indexed ID for this document, or the root ID for nested documents.\n+   *\n+   * @return possibly null if there's no uniqueKey field\n+   */\n+  public String getIndexedIdStr() {\n+    extractIdsIfNeeded();\n+    return indexedIdStr;\n+  }\n \n   /**\n+   * Returns the indexed ID for this document, or the root ID for nested documents. The returned\n+   * BytesRef should be treated as immutable. It will not be re-used/modified for additional docs.\n    *\n-   * @return value of _route_ param({@link ShardParams#_ROUTE_}), otherwise doc id.\n+   * @return possibly null if there's no uniqueKey field\n    */\n-  public String getRootIdUsingRouteParam() {\n-     return req.getParams().get(ShardParams._ROUTE_, getHashableId());\n-   }\n+  public BytesRef getIndexedId() {\n+    extractIdsIfNeeded();\n+    return indexedId;\n+  }\n \n   /**\n-   * @return String id to hash\n+   * Returns the ID of the doc itself, possibly different from {@link #getIndexedIdStr()} which\n+   * points to the root doc.\n+   *\n+   * @return possibly null if there's no uniqueKey field\n    */\n-  public String getHashableId() {\n+  public String getChildDocIdStr() {\n+    extractIdsIfNeeded();\n+    return childDocIdStr;\n+  }\n+\n+  /** The ID for logging purposes. */\n+  public String getPrintableId() {\n+    extractIdsIfNeeded();\n+    if (indexedIdStr == null) {\n+      return \"(null)\";\n+    } else if (indexedIdStr.equals(childDocIdStr)) {\n+      return indexedIdStr;\n+    } else {\n+      return childDocIdStr + \" (root=\" + indexedIdStr + \")\";\n+    }\n+  }\n+\n+  private void extractIdsIfNeeded() {\n+    if (indexedId != null) {\n+      return;\n+    }\n     IndexSchema schema = req.getSchema();\n     SchemaField sf = schema.getUniqueKeyField();\n     if (sf != null) {\n       if (solrDoc != null) {\n         SolrInputField field = solrDoc.getField(sf.getName());\n-\n-        int count = field == null ? 0 : field.getValueCount();\n+        // check some uniqueKey constraints\n+        int count = field==null ? 0 : field.getValueCount();\n         if (count == 0) {\n           if (overwrite) {\n-            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-                \"Document is missing mandatory uniqueKey field: \"\n-                    + sf.getName());\n+            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document is missing mandatory uniqueKey field: \" + sf.getName());\n           }\n-        } else if (count > 1) {\n-          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-              \"Document contains multiple values for uniqueKey field: \" + field);\n+        } else if (count  > 1) {\n+          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document contains multiple values for uniqueKey field: \" + field);\n         } else {\n-          return field.getFirstValue().toString();\n+          this.childDocIdStr = field.getFirstValue().toString();", "originalCommit": "6f3854058969475d99ad582097d702010f5e0bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzMTE2Mw==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r551131163", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UpdateLog.add(...) indirectly reads without synchronization from container cmd.solrDoc._fields via call to Map.get(...). Potentially races with write in method UpdateLog.add(...).\nReporting because this access may occur on a background thread.", "author": "sonatype-lift", "createdAt": "2021-01-04T06:04:07Z", "path": "solr/core/src/java/org/apache/solr/update/UpdateLog.java", "diffHunk": "@@ -561,6 +565,13 @@ public void add(AddUpdateCommand cmd, boolean clearCaches) {\n     // TODO: we currently need to log to maintain correct versioning, rtg, etc\n     // if ((cmd.getFlags() & UpdateCommand.REPLAY) != 0) return;\n \n+    // This hack could be removed after SOLR-15064 when we insist updates to child docs include _root_.\n+    // Until then, if we're in a buffering mode, then the solrDoc won't have the _root_ field.\n+    // Otherwise, it should already be there, placed by the client.\n+    if (usableForChildDocs && cmd.useRouteAsRoot != null && cmd.solrDoc.getField(IndexSchema.ROOT_FIELD_NAME) == null) {", "originalCommit": "6f3854058969475d99ad582097d702010f5e0bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzMTE2Ng==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r551131166", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UpdateLog.add(...) indirectly writes to field cmd.childDocIdStr outside of synchronization.\nReporting because this access may occur on a background thread.", "author": "sonatype-lift", "createdAt": "2021-01-04T06:04:08Z", "path": "solr/core/src/java/org/apache/solr/update/UpdateLog.java", "diffHunk": "@@ -561,6 +565,13 @@ public void add(AddUpdateCommand cmd, boolean clearCaches) {\n     // TODO: we currently need to log to maintain correct versioning, rtg, etc\n     // if ((cmd.getFlags() & UpdateCommand.REPLAY) != 0) return;\n \n+    // This hack could be removed after SOLR-15064 when we insist updates to child docs include _root_.\n+    // Until then, if we're in a buffering mode, then the solrDoc won't have the _root_ field.\n+    // Otherwise, it should already be there, placed by the client.\n+    if (usableForChildDocs && cmd.useRouteAsRoot != null && cmd.solrDoc.getField(IndexSchema.ROOT_FIELD_NAME) == null) {\n+      cmd.solrDoc.setField(IndexSchema.ROOT_FIELD_NAME, cmd.getIndexedIdStr());", "originalCommit": "6f3854058969475d99ad582097d702010f5e0bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzMTU0MA==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552231540", "bodyText": "NULL_DEREFERENCE:  object docs last assigned on line 111 could be null and is dereferenced at line 112.", "author": "sonatype-lift", "createdAt": "2021-01-05T22:15:55Z", "path": "solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer.java", "diffHunk": "@@ -76,6 +87,37 @@ public String getName()  {\n   @Override\n   public boolean needsSolrIndexSearcher() { return true; }\n \n+  @Override\n+  public String[] getExtraRequestFields() {\n+    return extraRequestedFields;\n+  }\n+\n+  private int getPrevRootGivenFilter(LeafReaderContext leafReaderContext, int segRootId) throws IOException {\n+    final BitSet segParentsBitSet = parentsFilter.getBitSet(leafReaderContext);\n+    if (segParentsBitSet != null) {\n+      return segRootId == 0 ? -1 : segParentsBitSet.prevSetBit(segRootId - 1);\n+    }\n+    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+        \"Parent filter '\" + parentsFilter + \"' doesn't match any parent documents\");\n+  }\n+\n+  private int getPrevRootGivenId(LeafReaderContext leafReaderContext, int segRootId,\n+                                 BytesRef idBytes) throws IOException {\n+    final LeafReader reader = leafReaderContext.reader();\n+    final Terms terms = reader.terms(IndexSchema.ROOT_FIELD_NAME); // never returns null here\n+    final TermsEnum iterator = terms.iterator();\n+    if (iterator.seekExact(idBytes)) {\n+      PostingsEnum docs = iterator.postings(null, PostingsEnum.NONE);\n+      docs = BitsFilteredPostingsEnum.wrap(docs, reader.getLiveDocs());\n+      int id = docs.nextDoc();", "originalCommit": "1bc9a612545ca49cdbe95b18acd6abfd88c4bca7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0MTU5Ng==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552241596", "bodyText": "Wrong; iterator.postings() never returns null -- so says its documentation.", "author": "dsmiley", "createdAt": "2021-01-05T22:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzMTU0MA=="}], "type": "inlineReview"}, {"oid": "3d50a2fd05c9256344ef82123efc0f4d64eb8a02", "url": "https://github.com/apache/lucene-solr/commit/3d50a2fd05c9256344ef82123efc0f4d64eb8a02", "message": "SOLR-14923: Nested docs indexing performance & robustness\n* When the schema defines _root_, and you want to do atomic/partial updates...\n** _root_ needn't be stored or have docValues any more\n** _nest_path_ field isn't needed for this any more\n** Simplified internal logic\n* Allow (and recommend, eventually insist) that the _root_ field be passed for atomic/partial updates to child docs.\n** In the absence of _root_, assume the _route_ param is equivalent to ameliorate back-compat scope.  This is a temporary hack; remove in SOLR-15064.\n** One of the two is required; you'll get an exception if the assumption is false.  THIS IS A BACK-COMPAT CHANGE\n* Ensure that the update log contains the _root_ field if it's defined in the schema; in some cases it wasn't.  It's important for robustness of atomic/partial updates to child docs.  Caveat: the buffer replay scenario is not tested with child docs.\n* Limited the cases when a realtime searcher is re-opened.  It was being applied to any update that included child docs but now only some narrow subset: only for atomic/partial updates, and when the update log contains an in-place update for the same nest because it's complicated to resolve those log entries.\n* Internal improvements to RealTimeGetComponent to aid clarity & robustness & probably performance...\n** Use SolrDocumentFetcher.solrDoc(docID, ReturnFields) instead of more manual loading.  Will do more with this in another PR.\n** Clarify when only root doc IDs are expected.\n** Use Resolution enum more, add PARTIAL, remove DOC_WITH_CHILDREN; enhance docs.\n** When have ReturnFields, a Set of \"onlyTheseFields\" becomes redundant.  Add a child doc resolution via a transformer when needed.\n** Clarified where copy-field targets are removed\n* NestPathField should default to single valued, instead of inheriting the schema default, which for ancient schemas was multi-valued.\n* AddUpdateCommand.getLuceneDocument(s) methods are very internal; made package visible and refactored a bit for clarity\n* DocumentBuilder: when in-place update, skip id and _root_ here, thus also simplifying further logic\n* NestedShardedAtomicUpdateTest no longer extends AbstractFullDistribZkTestBase because it wasn't really leveraging the \"control client\" checking, and it added too much complexity to debug failures.", "committedDate": "2021-01-07T15:49:40Z", "type": "commit"}, {"oid": "064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "url": "https://github.com/apache/lucene-solr/commit/064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "message": "small improvements", "committedDate": "2021-01-07T15:50:55Z", "type": "commit"}, {"oid": "064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "url": "https://github.com/apache/lucene-solr/commit/064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "message": "small improvements", "committedDate": "2021-01-07T15:50:55Z", "type": "forcePushed"}, {"oid": "6ba773a6d7a8245bb16896abbea129bfe8c42d30", "url": "https://github.com/apache/lucene-solr/commit/6ba773a6d7a8245bb16896abbea129bfe8c42d30", "message": "docs: no more field requirements for nested docs.\ndocs: clarity under-the-hood.", "committedDate": "2021-01-07T17:36:21Z", "type": "commit"}, {"oid": "3ccedcf4521e87bf79049916b8c355e9ed1c257c", "url": "https://github.com/apache/lucene-solr/commit/3ccedcf4521e87bf79049916b8c355e9ed1c257c", "message": "docs: Woops; the root doc has \"!prod\" suffix", "committedDate": "2021-01-07T20:51:01Z", "type": "commit"}, {"oid": "4e474bbae5154b3938e2bd7c6468d2c5cb1ff7d0", "url": "https://github.com/apache/lucene-solr/commit/4e474bbae5154b3938e2bd7c6468d2c5cb1ff7d0", "message": "Merge branch 'master' into solr-14923-nestedDocsRealtimeSearcher", "committedDate": "2021-01-08T04:19:10Z", "type": "commit"}]}