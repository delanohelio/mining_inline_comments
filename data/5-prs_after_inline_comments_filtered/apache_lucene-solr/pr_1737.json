{"pr_number": 1737, "pr_title": "SOLR-14615: Implement CPU Utilization Based Circuit Breaker", "pr_createdAt": "2020-08-11T08:48:18Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1737", "timeline": [{"oid": "27a66a0117a1aa7df18af9a4977e2ab8cf1177fc", "url": "https://github.com/apache/lucene-solr/commit/27a66a0117a1aa7df18af9a4977e2ab8cf1177fc", "message": "SOLR-14615: Implement CPU Utilization Based Circuit Breaker\n\nThis commit introduces CPU based circuit breaker. This circuit breaker\ntracks the average CPU load per minute and triggers if the value exceeds\na configurable value.\n\nThis commit also adds a specific control flag for Memory Circuit Breaker\nto allow enabling/disabling the same.", "committedDate": "2020-08-11T08:43:24Z", "type": "commit"}, {"oid": "cf897f8ea89c5aed93cbbc242a9da1eedfbbe539", "url": "https://github.com/apache/lucene-solr/commit/cf897f8ea89c5aed93cbbc242a9da1eedfbbe539", "message": "Remove redundant stuff", "committedDate": "2020-08-11T08:45:07Z", "type": "commit"}, {"oid": "96513f0e2fc47e23c32deda7c972e00e2e6ec85f", "url": "https://github.com/apache/lucene-solr/commit/96513f0e2fc47e23c32deda7c972e00e2e6ec85f", "message": "Add CHANGES.txt entry", "committedDate": "2020-08-11T08:46:41Z", "type": "commit"}, {"oid": "1f44a29841e2e6bb8555702b81eca358bb10f52e", "url": "https://github.com/apache/lucene-solr/commit/1f44a29841e2e6bb8555702b81eca358bb10f52e", "message": "Remove redundant print statements", "committedDate": "2020-08-11T08:51:35Z", "type": "commit"}, {"oid": "342f5277de21d8284292e769266ffdf5c1afd1c0", "url": "https://github.com/apache/lucene-solr/commit/342f5277de21d8284292e769266ffdf5c1afd1c0", "message": "Update to use Java MXBean", "committedDate": "2020-08-11T11:00:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMTI2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468711266", "bodyText": "thread locals should be static", "author": "madrob", "createdAt": "2020-08-11T16:30:28Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean isCpuCircuitBreakerEnabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Double> seenCPUUsage = new ThreadLocal<>();", "originalCommit": "342f5277de21d8284292e769266ffdf5c1afd1c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMjMxNA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468712314", "bodyText": "I don't think CPU load average is typically measured on a 0-100 scale. Can you confirm some sample values of what calculateLiveCPUUsage returns?", "author": "madrob", "createdAt": "2020-08-11T16:32:08Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -811,10 +818,18 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n-  private void validateMemoryBreakerThreshold() {\n+  private void validateCircuitBreakerThresholds() {\n     if (useCircuitBreakers) {\n-      if (memoryCircuitBreakerThresholdPct > 95 || memoryCircuitBreakerThresholdPct < 50) {\n-        throw new IllegalArgumentException(\"Valid value range of memoryCircuitBreakerThresholdPct is 50 -  95\");\n+      if (isMemoryCircuitBreakerEnabled) {\n+        if (memoryCircuitBreakerThresholdPct > 95 || memoryCircuitBreakerThresholdPct < 50) {\n+          throw new IllegalArgumentException(\"Valid value range of memoryCircuitBreakerThresholdPct is 50 -  95\");\n+        }\n+      }\n+\n+      if (isCpuCircuitBreakerEnabled) {\n+        if (cpuCircuitBreakerThresholdPct > 95 || cpuCircuitBreakerThresholdPct < 40) {\n+          throw new IllegalArgumentException(\"Valid value range for cpuCircuitBreakerThresholdPct is 40 - 95\");", "originalCommit": "342f5277de21d8284292e769266ffdf5c1afd1c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1Njc4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468756781", "bodyText": "I see values between 0 - 100. Ran stress locally and validated values.", "author": "atris", "createdAt": "2020-08-11T17:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMjMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTI2NA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r469081264", "bodyText": "Scratch that, this is a value that can exceed 100 as well. Removed the top ceiling on the value here.", "author": "atris", "createdAt": "2020-08-12T08:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMjMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNDkxMA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r469104910", "bodyText": "It typically doesn't go past 450 unless you have an issue. I would still keep it bounded at some measure @atris", "author": "MarcusSorealheis", "createdAt": "2020-08-12T08:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxMjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxNDI4MA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468714280", "bodyText": "return false if only if warn enabled seems odd.", "author": "madrob", "createdAt": "2020-08-11T16:35:22Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean isCpuCircuitBreakerEnabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Double> seenCPUUsage = new ThreadLocal<>();\n+  private final ThreadLocal<Double> allowedCPUUsage = new ThreadLocal<>();\n+\n+  public CPUCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    this.isCpuCircuitBreakerEnabled = solrConfig.isCpuCircuitBreakerEnabled;\n+    this.cpuUsageThreshold = solrConfig.cpuCircuitBreakerThresholdPct;\n+  }\n+\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    if (!isCpuCircuitBreakerEnabled) {\n+      return false;\n+    }\n+\n+    double localAllowedCPUUsage = getCpuUsageThreshold();\n+    double localSeenCPUUsage = calculateLiveCPUUsage();\n+\n+    if (localSeenCPUUsage < 0) {\n+      if (log.isWarnEnabled()) {\n+        String msg = \"Unable to get CPU usage\";\n+\n+        log.warn(msg);\n+\n+        return false;", "originalCommit": "342f5277de21d8284292e769266ffdf5c1afd1c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcyODg1MA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468728850", "bodyText": "Good catch, thanks.", "author": "atris", "createdAt": "2020-08-11T16:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxNDI4MA=="}], "type": "inlineReview"}, {"oid": "0972a36314ae643583817530938a5704bb90d9bb", "url": "https://github.com/apache/lucene-solr/commit/0972a36314ae643583817530938a5704bb90d9bb", "message": "Update per comments", "committedDate": "2020-08-11T18:25:11Z", "type": "commit"}, {"oid": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "url": "https://github.com/apache/lucene-solr/commit/c5d95cd9e35bf56e47da12754deb7daeda7d3746", "message": "Rename parameter and remove ceiling on the threshold range", "committedDate": "2020-08-12T07:46:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MzI1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468773252", "bodyText": "these are unused", "author": "madrob", "createdAt": "2020-08-11T18:15:42Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();", "originalCommit": "342f5277de21d8284292e769266ffdf5c1afd1c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MzMzNg==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r468773336", "bodyText": "class can be static", "author": "madrob", "createdAt": "2020-08-11T18:15:52Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -240,4 +303,15 @@ protected long calculateLiveMemoryUsage() {\n       return Long.MIN_VALUE; // Random number guaranteed to not trip the circuit breaker\n     }\n   }\n+\n+  private class FakeCPUCircuitBreaker extends CPUCircuitBreaker {", "originalCommit": "342f5277de21d8284292e769266ffdf5c1afd1c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxODU4NA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470618584", "bodyText": "static class", "author": "madrob", "createdAt": "2020-08-14T13:19:43Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -179,7 +236,13 @@ public void testResponseWithCBTiming() {\n     );\n   }\n \n-  private class MockCircuitBreaker extends CircuitBreaker {\n+  private void removeAllExistingCircuitBreakers() {\n+    List<CircuitBreaker> registeredCircuitBreakers = h.getCore().getCircuitBreakerManager().getRegisteredCircuitBreakers();\n+\n+    registeredCircuitBreakers.clear();\n+  }\n+\n+  private class MockCircuitBreaker extends MemoryCircuitBreaker {", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxODg2NA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470618864", "bodyText": "thread.interrupt", "author": "madrob", "createdAt": "2020-08-14T13:20:15Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {\n+          try {\n+            h.query(req(\"name:\\\"john smith\\\"\"));\n+          } catch (SolrException e) {\n+            if (!e.getMessage().startsWith(\"Circuit Breakers tripped\")) {\n+              if (log.isInfoEnabled()) {\n+                String logMessage = \"Expected error message for testFakeCPUCircuitBreaker was not received. Error message \" + e.getMessage();\n+                log.info(logMessage);\n+              }\n+              throw new RuntimeException(\"Expected error message was not received. Error message \" + e.getMessage());\n+            }\n+            failureCount.incrementAndGet();\n+          } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage());\n+          }\n+        });\n+      }\n+\n+      executor.shutdown();\n+      try {\n+        executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n+      } catch (InterruptedException e) {\n+        throw new RuntimeException(e.getMessage());", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyODYxNg==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470628616", "bodyText": "Can we simplify this whole block to assertThat(e.getMessage(), containsString(\"Circuit Breakers tripped\"))", "author": "madrob", "createdAt": "2020-08-14T13:37:57Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {\n+          try {\n+            h.query(req(\"name:\\\"john smith\\\"\"));\n+          } catch (SolrException e) {\n+            if (!e.getMessage().startsWith(\"Circuit Breakers tripped\")) {\n+              if (log.isInfoEnabled()) {\n+                String logMessage = \"Expected error message for testFakeCPUCircuitBreaker was not received. Error message \" + e.getMessage();\n+                log.info(logMessage);\n+              }\n+              throw new RuntimeException(\"Expected error message was not received. Error message \" + e.getMessage());\n+            }", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMTM2NA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470631364", "bodyText": "Does circuit breaker throw a more specific exception? It's kind of cumbersome from a client API perspective that they need to inspect the string message for knowing that they should retry from circuit breakers.", "author": "madrob", "createdAt": "2020-08-14T13:43:01Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {\n+          try {\n+            h.query(req(\"name:\\\"john smith\\\"\"));\n+          } catch (SolrException e) {", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMwNTE3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471305173", "bodyText": "Shouldnt return code 500 help there?", "author": "atris", "createdAt": "2020-08-17T07:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxMzM2NA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471413364", "bodyText": "Currently the CircuitBreakerManager.toErrorMessage uses individual breaker's getDebugInfo to construct the error message. I think we should improve these individual messages to clearly say why a break was tripped. Currently it's not obvious - eg. when a mem breaker trips it just reports the current and total memory but not the thresholdPct.\nMaybe we need a different method like CircuitBreaker.getErrorMessage ?", "author": "sigram", "createdAt": "2020-08-17T11:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MjEwNw==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471562107", "bodyText": "return code 500 doesn't matter if the SolrJ client converts it into an exception every single time.", "author": "madrob", "createdAt": "2020-08-17T15:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1MTcyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471651725", "bodyText": "https://issues.apache.org/jira/browse/SOLR-14755", "author": "atris", "createdAt": "2020-08-17T17:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMTM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzMzgyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r470633829", "bodyText": "save this Future and assert that it did not throw an exception", "author": "madrob", "createdAt": "2020-08-14T13:47:27Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +163,57 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(\n+        new SolrNamedThreadFactory(\"TestCircuitBreaker\"));\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    AtomicInteger failureCount = new AtomicInteger();\n+\n+    try {\n+      removeAllExistingCircuitBreakers();\n+\n+      CircuitBreaker circuitBreaker = new FakeCPUCircuitBreaker(h.getCore().getSolrConfig());\n+\n+      h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n+\n+      for (int i = 0; i < 5; i++) {\n+        executor.submit(() -> {", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471404467", "bodyText": "Javadoc for OSMxBean says \"This method is designed to provide a hint about the system load and may be queried frequently.\" Not sure what \"frequently\" means here, though...\nIt will be interesting to see the dynamic behavior of this breaker - I'm somewhat worried that the 1-min average may be too unstable and we end up flip-flopping between the states too often (eg. every dozen requests or so). Depending on the volume of momentary load (eg. an ongoing large merge or split shard) the 1-min average may exceed a threshold even though it doesn't properly reflect a sustained longer-term overload that we should worry about. Average load is a convenient lie ;)\nOTOH that's the only method we have in the OS MXBean, so we would have to compute that longer-term average ourselves, which is messy... so I guess we'll see .", "author": "sigram", "createdAt": "2020-08-17T11:04:42Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwODQzOQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471408439", "bodyText": "Also, caching doesn't have to be complicated .. you simply check the elapsed time since last request and if it's longer than timeout you refresh the value first, it's probably less than 10 lines of code.", "author": "sigram", "createdAt": "2020-08-17T11:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0OTY0MA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471549640", "bodyText": "Yea, I think this is a very good point. If load average only updates every 5 seconds, that seems like a huge interval where we're going to block query execution. Let's think about how we can get better granularity.", "author": "madrob", "createdAt": "2020-08-17T15:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU3NzUyMg==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471577522", "bodyText": "The Javadocs state that the average load is updated per one minute -- so I am not sure how we can get a granularity better than that. Its unfortunate that this unit is not configurable (and I believe it must be internally caching as well since it talks about being prepared for \"querying frequently\". Any thoughts on this?", "author": "atris", "createdAt": "2020-08-17T15:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwNjE2OA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471606168", "bodyText": "Thinking more about this, the load is an average of one minute. If there is a transient spike -- should it not be smoothened out over the minute so that the average value is reasonable?", "author": "atris", "createdAt": "2020-08-17T16:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MTA4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472071087", "bodyText": "Uh ... I see there's still some misunderstanding about this. The call itself is directly passed to the native method that invokes stdlib getloadavg, which in turn reads these values from the /proc pseudo-fs. So, the cost is truly minimal and the call doesn't block - if it turns out that it's still too costly to call for every request then we can introduce some timeout-based caching.\nThese averages are so called exponentially weighted moving averages, so indeed a 1-min average has traces of past load values from outside the 1-min window, which helps in smoothing it. This may turn out to be sufficient to avoid false positives due to short-term spikes (such as large merges). Linux loadavg represents to some degree a combined CPU + disk IO load, so indeed intensive IO operations will affect it.\nWe always have an option to use Codahale Meter to easily calculate 5- and 15-min EWMAs if it turns out that we're getting too many false positives. Until then users can configure higher thresholds, thus reducing the number of false positives at the cost of higher contention.", "author": "sigram", "createdAt": "2020-08-18T10:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNzQwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471407405", "bodyText": "I think that on ThreadLocal.get() you would get a null value and consequently an NPE. You would have to use ThreadLocal.withInitial(supplier) to get a Double(0) here.", "author": "sigram", "createdAt": "2020-08-17T11:10:58Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean isCpuCircuitBreakerEnabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private static final ThreadLocal<Double> seenCPUUsage = new ThreadLocal<>();\n+  private static final ThreadLocal<Double> allowedCPUUsage = new ThreadLocal<>();\n+\n+  public CPUCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    this.isCpuCircuitBreakerEnabled = solrConfig.isCpuCircuitBreakerEnabled;\n+    this.cpuUsageThreshold = solrConfig.cpuCircuitBreakerThreshold;\n+  }\n+\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    if (!isCpuCircuitBreakerEnabled) {\n+      return false;\n+    }\n+\n+    double localAllowedCPUUsage = getCpuUsageThreshold();\n+    double localSeenCPUUsage = calculateLiveCPUUsage();\n+\n+    if (localSeenCPUUsage < 0) {\n+      if (log.isWarnEnabled()) {\n+        String msg = \"Unable to get CPU usage\";\n+\n+        log.warn(msg);\n+      }\n+\n+      return false;\n+    }\n+\n+    allowedCPUUsage.set(localAllowedCPUUsage);\n+\n+    seenCPUUsage.set(localSeenCPUUsage);\n+\n+    return (localSeenCPUUsage >= localAllowedCPUUsage);\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenCPUUsage.get() == 0L || allowedCPUUsage.get() == 0L) {", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwODkyMg==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471408922", "bodyText": "We know it's a boolean and it's in the MemoryCircuitBreaker, why not simply call it enabled (like many other Solr plugins do)?", "author": "sigram", "createdAt": "2020-08-17T11:14:24Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -43,6 +43,7 @@\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n   private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n \n+  private boolean isMemoryCircuitBreakerEnabled;", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU2MDUyOA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471560528", "bodyText": "Agree with this. is* prefix typically makes more sense on the methods not fields.", "author": "madrob", "createdAt": "2020-08-17T15:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwODkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQxMDIyNg==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471410226", "bodyText": "I'm not sure if the boolean flags should always contain is, also I generally hate too long names... ;) we already know this is a section for circuit breakers, so the name doesn't have to repeat all of it. How about cpuBreakerEnabled, memoryBreakerEnabled etc?", "author": "sigram", "createdAt": "2020-08-17T11:16:57Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -229,9 +229,13 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n \n     useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n+    isCpuCircuitBreakerEnabled = getBool(\"circuitBreaker/isCpuCircuitBreakerEnabled\", false);", "originalCommit": "c5d95cd9e35bf56e47da12754deb7daeda7d3746", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bdd4f219f4fb7bad694fe96d05e6e90318f3289f", "url": "https://github.com/apache/lucene-solr/commit/bdd4f219f4fb7bad694fe96d05e6e90318f3289f", "message": "Update per comments", "committedDate": "2020-08-17T18:20:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTczMTM2OQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r471731369", "bodyText": "withInitial is supposed to be on the declaration, not on each use", "author": "madrob", "createdAt": "2020-08-17T19:35:55Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -91,11 +91,18 @@ public boolean isTripped() {\n \n   @Override\n   public String getDebugInfo() {\n-    if (seenCPUUsage.get() == 0L || allowedCPUUsage.get() == 0L) {\n+\n+    if (seenCPUUsage.withInitial(supplier).get() == 0.0 || seenCPUUsage.withInitial(supplier).get() == 0.0) {", "originalCommit": "bdd4f219f4fb7bad694fe96d05e6e90318f3289f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "095a6f26eb549be4bf749392660fa35742db2625", "url": "https://github.com/apache/lucene-solr/commit/095a6f26eb549be4bf749392660fa35742db2625", "message": "Use withInitial correctly", "committedDate": "2020-08-18T04:12:50Z", "type": "commit"}, {"oid": "fe997a4893c59cfc37ad016c709a76c9af27aa4a", "url": "https://github.com/apache/lucene-solr/commit/fe997a4893c59cfc37ad016c709a76c9af27aa4a", "message": "Remove redundant import", "committedDate": "2020-08-18T04:29:21Z", "type": "commit"}, {"oid": "98612bcf3acae5583c678f928e9d8103009b825e", "url": "https://github.com/apache/lucene-solr/commit/98612bcf3acae5583c678f928e9d8103009b825e", "message": "More precommit stuff", "committedDate": "2020-08-18T04:44:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA2MDEyMA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472060120", "bodyText": "Can we please simplify these names? they are awfully verbose and repeating the parts that are already unique and obvious.", "author": "sigram", "createdAt": "2020-08-18T09:56:19Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -229,9 +229,13 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n \n     useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n+    cpuCircuitBreakerEnabled = getBool(\"circuitBreaker/cpuCircuitBreakerEnabled\", false);", "originalCommit": "98612bcf3acae5583c678f928e9d8103009b825e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjY1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472072659", "bodyText": "Maybe \"greater than allocated threshold\" ?", "author": "sigram", "createdAt": "2020-08-18T10:19:00Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CPUCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.OperatingSystemMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks current CPU usage and triggers if the specified threshold is breached.\n+ *\n+ * This circuit breaker gets the average CPU load over the last minute and uses\n+ * that data to take a decision. Ideally, we should be able to cache the value\n+ * locally and only query once the minute has elapsed. However, that will introduce\n+ * more complexity than the current structure and might not get us major performance\n+ * wins. If this ever becomes a performance bottleneck, that can be considered.\n+ * </p>\n+ *\n+ * <p>\n+ * The configuration to define which mode to use and the trigger threshold are defined in\n+ * solrconfig.xml\n+ * </p>\n+ */\n+public class CPUCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final OperatingSystemMXBean operatingSystemMXBean = ManagementFactory.getOperatingSystemMXBean();\n+\n+  private final boolean enabled;\n+  private final double cpuUsageThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private static final ThreadLocal<Double> seenCPUUsage = ThreadLocal.withInitial(() -> 0.0);\n+\n+  private static final ThreadLocal<Double> allowedCPUUsage = ThreadLocal.withInitial(() -> 0.0);\n+\n+  public CPUCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    this.enabled = solrConfig.cpuCircuitBreakerEnabled;\n+    this.cpuUsageThreshold = solrConfig.cpuCircuitBreakerThreshold;\n+  }\n+\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    if (!enabled) {\n+      return false;\n+    }\n+\n+    double localAllowedCPUUsage = getCpuUsageThreshold();\n+    double localSeenCPUUsage = calculateLiveCPUUsage();\n+\n+    if (localSeenCPUUsage < 0) {\n+      if (log.isWarnEnabled()) {\n+        String msg = \"Unable to get CPU usage\";\n+\n+        log.warn(msg);\n+      }\n+\n+      return false;\n+    }\n+\n+    allowedCPUUsage.set(localAllowedCPUUsage);\n+\n+    seenCPUUsage.set(localSeenCPUUsage);\n+\n+    return (localSeenCPUUsage >= localAllowedCPUUsage);\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+\n+    if (seenCPUUsage.get() == 0.0 || seenCPUUsage.get() == 0.0) {\n+      log.warn(\"CPUCircuitBreaker's monitored values (seenCPUUSage, allowedCPUUsage) not set\");\n+    }\n+\n+    return \"seenCPUUSage=\" + seenCPUUsage.get() + \" allowedCPUUsage=\" + allowedCPUUsage.get();\n+  }\n+\n+  @Override\n+  public String getErrorMessage() {\n+    return \"CPU Circuit Breaker Triggered. Seen CPU usage \" + seenCPUUsage.get() + \" and allocated threshold \" +", "originalCommit": "98612bcf3acae5583c678f928e9d8103009b825e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzU5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472073599", "bodyText": "Similarly, \"greater than allocated threshold\" ?", "author": "sigram", "createdAt": "2020-08-18T10:20:50Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -88,13 +95,19 @@ public boolean isTripped() {\n \n   @Override\n   public String getDebugInfo() {\n-    if (seenMemory.get() == 0L || allowedMemory.get() == 0L) {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {\n       log.warn(\"MemoryCircuitBreaker's monitored values (seenMemory, allowedMemory) not set\");\n     }\n \n     return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n   }\n \n+  @Override\n+  public String getErrorMessage() {\n+    return \"Memory Circuit Breaker Triggered. Seen JVM heap memory usage \" + seenMemory.get() + \" and allocated threshold \" +", "originalCommit": "98612bcf3acae5583c678f928e9d8103009b825e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NDQ1Nw==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472074457", "bodyText": "The same comment applies as in the CPU breaker regarding caching vs. calling this for every request. The cost should be minimal, it's just making a fast native call to read a value.", "author": "sigram", "createdAt": "2020-08-18T10:22:35Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -76,6 +79,10 @@ public boolean isTripped() {\n       return false;\n     }\n \n+    if (!enabled) {\n+      return false;\n+    }\n+\n     long localAllowedMemory = getCurrentMemoryThreshold();", "originalCommit": "98612bcf3acae5583c678f928e9d8103009b825e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNDE0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r472104145", "bodyText": "So we do not need to cache here.", "author": "atris", "createdAt": "2020-08-18T11:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NDQ1Nw=="}], "type": "inlineReview"}, {"oid": "cada13b4dddcfa6010c5bef87bb984afa08cbf42", "url": "https://github.com/apache/lucene-solr/commit/cada13b4dddcfa6010c5bef87bb984afa08cbf42", "message": "Update per comments", "committedDate": "2020-08-18T11:29:53Z", "type": "commit"}, {"oid": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "url": "https://github.com/apache/lucene-solr/commit/bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "message": "Fix Compilation Errors", "committedDate": "2020-08-18T14:32:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NjI4OA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473196288", "bodyText": "I don't think this was supposed to change", "author": "madrob", "createdAt": "2020-08-19T17:15:33Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -88,13 +95,20 @@ public boolean isTripped() {\n \n   @Override\n   public String getDebugInfo() {\n-    if (seenMemory.get() == 0L || allowedMemory.get() == 0L) {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {", "originalCommit": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NjMyOA==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473196328", "bodyText": "static", "author": "madrob", "createdAt": "2020-08-19T17:15:37Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -43,22 +43,25 @@\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n   private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n \n+  private boolean enabled;\n   private final long heapMemoryThreshold;\n \n   // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n-  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n-  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> seenMemory = ThreadLocal.withInitial(() -> 0L);", "originalCommit": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NjgwMg==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473196802", "bodyText": "Do we have to suppress here? I'd rather not have warnings in the new code to begin with", "author": "madrob", "createdAt": "2020-08-19T17:16:28Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -41,6 +45,9 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+@SuppressWarnings({\"rawtypes\"})", "originalCommit": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NzEzMw==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473197133", "bodyText": "Future<?>", "author": "madrob", "createdAt": "2020-08-19T17:17:04Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -119,33 +130,42 @@ public void testBuildingMemoryPressure() {\n     AtomicInteger failureCount = new AtomicInteger();\n \n     try {\n+      removeAllExistingCircuitBreakers();\n+\n       CircuitBreaker circuitBreaker = new BuildingUpMemoryPressureCircuitBreaker(h.getCore().getSolrConfig());\n \n       h.getCore().getCircuitBreakerManager().register(circuitBreaker);\n \n+      List<Future> futures = new ArrayList<>();\n+\n       for (int i = 0; i < 5; i++) {\n-        executor.submit(() -> {\n+        Future future = executor.submit(() -> {", "originalCommit": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTA5NQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473199095", "bodyText": "log, not sys out.", "author": "madrob", "createdAt": "2020-08-19T17:19:55Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -206,11 +286,12 @@ public FakeMemoryPressureCircuitBreaker(SolrConfig solrConfig) {\n     @Override\n     protected long calculateLiveMemoryUsage() {\n       // Return a number large enough to trigger a pushback from the circuit breaker\n+      System.out.println(\"I AM SENDING MAX VALUE\");", "originalCommit": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5OTUxNQ==", "url": "https://github.com/apache/lucene-solr/pull/1737#discussion_r473199515", "bodyText": "Better practice to declare this right before the try block, without intervening declarations.", "author": "madrob", "createdAt": "2020-08-19T17:20:39Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -157,6 +177,60 @@ public void testBuildingMemoryPressure() {\n     }\n   }\n \n+  public void testFakeCPUCircuitBreaker() {\n+    ExecutorService executor = ExecutorUtil.newMDCAwareCachedThreadPool(", "originalCommit": "bae9ebe35a6ae59ed108340ff9a17c53e8b89d13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d964ddb3adf494c8417b2d03e4b79a34f5c8635e", "url": "https://github.com/apache/lucene-solr/commit/d964ddb3adf494c8417b2d03e4b79a34f5c8635e", "message": "Update per comments", "committedDate": "2020-08-20T06:08:44Z", "type": "commit"}]}