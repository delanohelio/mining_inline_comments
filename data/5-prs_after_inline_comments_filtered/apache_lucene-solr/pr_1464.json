{"pr_number": 1464, "pr_title": "LUCENE-9087: Build always trees with full leaves and lower the default value for maxPointsPerLeafNode", "pr_createdAt": "2020-04-28T16:47:40Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1464", "timeline": [{"oid": "900f412cf81c07dbf0367301217786d0e4747ddd", "url": "https://github.com/apache/lucene-solr/commit/900f412cf81c07dbf0367301217786d0e4747ddd", "message": "change construction logic of the BKD tree to always build unbalanced trees with fully populated leaves.", "committedDate": "2020-04-27T13:21:47Z", "type": "commit"}, {"oid": "c368f3bd7527b5eeab093f46ca45729348d49e36", "url": "https://github.com/apache/lucene-solr/commit/c368f3bd7527b5eeab093f46ca45729348d49e36", "message": "Simplify logic to distribute points for avery recursion. Fix test bug.", "committedDate": "2020-04-28T14:11:12Z", "type": "commit"}, {"oid": "9f2eb5c1aab5b38eec6ab856affb38ca86484c42", "url": "https://github.com/apache/lucene-solr/commit/9f2eb5c1aab5b38eec6ab856affb38ca86484c42", "message": "Simplify logic for rotating leaves", "committedDate": "2020-04-28T16:19:55Z", "type": "commit"}, {"oid": "11ac8d4d1e673e12164d013254ddca8c296b9f0c", "url": "https://github.com/apache/lucene-solr/commit/11ac8d4d1e673e12164d013254ddca8c296b9f0c", "message": "lower the default for maxPointsInLeafNode to 512", "committedDate": "2020-04-28T16:24:50Z", "type": "commit"}, {"oid": "7c72768899fc84d7a3fc4259dece17187e33d465", "url": "https://github.com/apache/lucene-solr/commit/7c72768899fc84d7a3fc4259dece17187e33d465", "message": "fail failing test", "committedDate": "2020-04-28T17:51:31Z", "type": "commit"}, {"oid": "46d4fb062b296f0cae27749bd8b93db2b956199f", "url": "https://github.com/apache/lucene-solr/commit/46d4fb062b296f0cae27749bd8b93db2b956199f", "message": "simplify slightly how we distribute unbalanced nodes", "committedDate": "2020-04-28T18:17:23Z", "type": "commit"}, {"oid": "580a9ba5bf57f6cacf9f61bad07ec4ce0334030f", "url": "https://github.com/apache/lucene-solr/commit/580a9ba5bf57f6cacf9f61bad07ec4ce0334030f", "message": "small simplification", "committedDate": "2020-04-28T18:40:11Z", "type": "commit"}, {"oid": "e4e758dedf0e110b3d70c8b69350ebc9edd337e0", "url": "https://github.com/apache/lucene-solr/commit/e4e758dedf0e110b3d70c8b69350ebc9edd337e0", "message": "remove duplicated comment", "committedDate": "2020-04-29T05:31:42Z", "type": "commit"}, {"oid": "805e39a41a7236ac36265096e95872b46b493908", "url": "https://github.com/apache/lucene-solr/commit/805e39a41a7236ac36265096e95872b46b493908", "message": "reorder comments", "committedDate": "2020-04-29T05:34:56Z", "type": "commit"}, {"oid": "dabdb4891b38771f94ba7ed5d1cb6562f48537d2", "url": "https://github.com/apache/lucene-solr/commit/dabdb4891b38771f94ba7ed5d1cb6562f48537d2", "message": "extract method getNumLeftLeaveNodes", "committedDate": "2020-04-30T07:31:34Z", "type": "commit"}, {"oid": "ff1123ea5928489ba570a8409eca40da7ed49ad1", "url": "https://github.com/apache/lucene-solr/commit/ff1123ea5928489ba570a8409eca40da7ed49ad1", "message": "final clean up", "committedDate": "2020-04-30T07:35:17Z", "type": "commit"}, {"oid": "d3a050cff496a26fb679df9446e04b576401bd1e", "url": "https://github.com/apache/lucene-solr/commit/d3a050cff496a26fb679df9446e04b576401bd1e", "message": "move rotate leaves to pack index", "committedDate": "2020-04-30T08:00:41Z", "type": "commit"}, {"oid": "5b8089415c243135bb1ccc2093dd6701624e69c0", "url": "https://github.com/apache/lucene-solr/commit/5b8089415c243135bb1ccc2093dd6701624e69c0", "message": "remove while loop from rotate tree", "committedDate": "2020-04-30T08:39:57Z", "type": "commit"}, {"oid": "b80627babd64c62bdaa725a03e389e5308227f87", "url": "https://github.com/apache/lucene-solr/commit/b80627babd64c62bdaa725a03e389e5308227f87", "message": "add assert", "committedDate": "2020-04-30T09:11:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg4ODQwMg==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417888402", "bodyText": "is there an off-by-one error? I'd expect maxLevel to be ceil(log2(numLeaves)), which would be 32 - Integer.numberOfLeadingZeros(numLeaves-1) according to https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Integer.html#numberOfLeadingZeros(int)", "author": "jpountz", "createdAt": "2020-04-30T09:46:28Z", "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -730,6 +730,22 @@ private void rotateToTree(int nodeID, int offset, int count, byte[] index, List<\n     return newLeafBlockFPs;\n   }\n \n+  private int getNumLeftLeaveNodes(int numLeaves) {\n+    // return the max level for this number of leaves. If level is full it returns the next level\n+    int maxLevel = 32 - Integer.numberOfLeadingZeros(numLeaves);", "originalCommit": "dabdb4891b38771f94ba7ed5d1cb6562f48537d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxNzc2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417917762", "bodyText": "I have rewritten the method (and fix some grammatical mistakes) to make it more clear. I think the best way is to start calculating the full level which can be done using:\nint lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n\nThen it is clear what we are doing.", "author": "iverase", "createdAt": "2020-04-30T10:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg4ODQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk0ODgyMA==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417948820", "bodyText": "this makes sense to me", "author": "jpountz", "createdAt": "2020-04-30T11:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg4ODQwMg=="}], "type": "inlineReview"}, {"oid": "97f86582199ed6dcb79c1cafd42fedc0eadc7f3d", "url": "https://github.com/apache/lucene-solr/commit/97f86582199ed6dcb79c1cafd42fedc0eadc7f3d", "message": "make more clear the technique for distributing leaf nodes between left and right branches", "committedDate": "2020-04-30T10:36:16Z", "type": "commit"}, {"oid": "6f36e942d464206d709b41f0ea5ba4fd27062bc4", "url": "https://github.com/apache/lucene-solr/commit/6f36e942d464206d709b41f0ea5ba4fd27062bc4", "message": "typo", "committedDate": "2020-04-30T10:52:45Z", "type": "commit"}, {"oid": "d0e008e109dc11841964037f9931e37c98607bfd", "url": "https://github.com/apache/lucene-solr/commit/d0e008e109dc11841964037f9931e37c98607bfd", "message": "typo", "committedDate": "2020-04-30T10:53:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1MzQzMA==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417953430", "bodyText": "nit: It's a bit sad that we try to protect against overflows  when dividing, but then don't check again for overflows when incrementing numLeaves. Can we compute the right value of numLeaves entirely before it gets converted to an int, e.g.\nfinal int numLeaves = Math.toIntExact((pointCount + maxPointsInLeafNode - 1) / maxPointsInLeafNode);", "author": "jpountz", "createdAt": "2020-04-30T11:51:55Z", "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -420,16 +421,13 @@ private long writeFieldNDims(IndexOutput out, String fieldName, MutablePointValu\n     // Mark that we already finished:\n     finished = true;\n \n-    long countPerLeaf = pointCount = values.size();\n-    long innerNodeCount = 1;\n+    pointCount = values.size();\n \n-    while (countPerLeaf > maxPointsInLeafNode) {\n-      countPerLeaf = (countPerLeaf+1)/2;\n-      innerNodeCount *= 2;\n+    int numLeaves = Math.toIntExact(pointCount / maxPointsInLeafNode);\n+    if (pointCount % maxPointsInLeafNode != 0) {\n+      numLeaves++;", "originalCommit": "d0e008e109dc11841964037f9931e37c98607bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAzMzAwNA==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r418033004", "bodyText": "Yes, I agree it seems a better approach.", "author": "iverase", "createdAt": "2020-04-30T14:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1MzQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4NTU0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417985541", "bodyText": "also assert that numLeftLeafNodes < 2L * (numLeaves - numLeftLeafNodes)?", "author": "jpountz", "createdAt": "2020-04-30T12:51:49Z", "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -665,55 +663,45 @@ assert valuesInOrderAndBounds(leafCount, 0, ArrayUtil.copyOfSubArray(leafValues,\n     }\n   }\n \n-  // TODO: there must be a simpler way?\n-  private void rotateToTree(int nodeID, int offset, int count, byte[] index, List<byte[]> leafBlockStartValues) {\n-    //System.out.println(\"ROTATE: nodeID=\" + nodeID + \" offset=\" + offset + \" count=\" + count + \" bpd=\" + bytesPerDim + \" index.length=\" + index.length);\n-    if (count == 1) {\n+  private void rotateToTree(int nodeID, int offset, int numNodes, byte[] index, List<byte[]> leafBlockStartValues) {\n+    if (numNodes == 1) {\n       // Leaf index node\n-      //System.out.println(\"  leaf index node\");\n-      //System.out.println(\"  index[\" + nodeID + \"] = blockStartValues[\" + offset + \"]\");\n       System.arraycopy(leafBlockStartValues.get(offset), 0, index, nodeID*(1+bytesPerDim)+1, bytesPerDim);\n-    } else if (count > 1) {\n-      // Internal index node: binary partition of count\n-      int countAtLevel = 1;\n-      int totalCount = 0;\n-      while (true) {\n-        int countLeft = count - totalCount;\n-        //System.out.println(\"    cycle countLeft=\" + countLeft + \" coutAtLevel=\" + countAtLevel);\n-        if (countLeft <= countAtLevel) {\n-          // This is the last level, possibly partially filled:\n-          int lastLeftCount = Math.min(countAtLevel/2, countLeft);\n-          assert lastLeftCount >= 0;\n-          int leftHalf = (totalCount-1)/2 + lastLeftCount;\n-\n-          int rootOffset = offset + leftHalf;\n-          /*\n-          System.out.println(\"  last left count \" + lastLeftCount);\n-          System.out.println(\"  leftHalf \" + leftHalf + \" rightHalf=\" + (count-leftHalf-1));\n-          System.out.println(\"  rootOffset=\" + rootOffset);\n-          */\n-\n-          System.arraycopy(leafBlockStartValues.get(rootOffset), 0, index, nodeID*(1+bytesPerDim)+1, bytesPerDim);\n-          //System.out.println(\"  index[\" + nodeID + \"] = blockStartValues[\" + rootOffset + \"]\");\n-\n-          // TODO: we could optimize/specialize, when we know it's simply fully balanced binary tree\n-          // under here, to save this while loop on each recursion\n-\n-          // Recurse left\n-          rotateToTree(2*nodeID, offset, leftHalf, index, leafBlockStartValues);\n-\n-          // Recurse right\n-          rotateToTree(2*nodeID+1, rootOffset+1, count-leftHalf-1, index, leafBlockStartValues);\n-          return;\n-        }\n-        totalCount += countAtLevel;\n-        countAtLevel *= 2;\n-      }\n+    } else if (numNodes > 1) {\n+      // Internal index node\n+      // numNodes + 1 is the number of leaves\n+      // -1 because there is one less inner node\n+      int leftHalf = getNumLeftLeafNodes(numNodes + 1) - 1;\n+      int rootOffset = offset + leftHalf;\n+\n+      System.arraycopy(leafBlockStartValues.get(rootOffset), 0, index, nodeID*(1+bytesPerDim)+1, bytesPerDim);\n+\n+      // Recurse left\n+      rotateToTree(2*nodeID, offset, leftHalf, index, leafBlockStartValues);\n+      // Recurse right\n+      rotateToTree(2*nodeID+1, rootOffset+1, numNodes-leftHalf-1, index, leafBlockStartValues);\n     } else {\n-      assert count == 0;\n+      assert numNodes == 0;\n     }\n   }\n \n+  private int getNumLeftLeafNodes(int numLeaves) {\n+    assert numLeaves > 1: \"getNumLeftLeaveNodes() called with \" + numLeaves;\n+    // return the level that can be filled with this number of leaves\n+    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n+    // how many leaf nodes are in the full level\n+    int leavesFullLevel = 1 << lastFullLevel;\n+    // half of the leaf nodes from the full level goes to the left\n+    int numLeftLeafNodes = leavesFullLevel / 2;\n+    // leaf nodes that do not fit in the full level\n+    int unbalancedLeafNodes = numLeaves - leavesFullLevel;\n+    // distribute unbalanced leaf nodes\n+    numLeftLeafNodes += Math.min(unbalancedLeafNodes, numLeftLeafNodes);\n+    // we should always place unbalanced leaf nodes on the left\n+    assert numLeftLeafNodes >= numLeaves - numLeftLeafNodes;", "originalCommit": "d0e008e109dc11841964037f9931e37c98607bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAzMzQyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r418033425", "bodyText": "needs to be <= to support the case of a balanced tree.", "author": "iverase", "createdAt": "2020-04-30T14:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4NTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5NTY2MQ==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r417995661", "bodyText": "In getNumLeftLeafNodes above we do unbalancedLeafNodes = numLeaves - leavesFullLevel, which has a factor 2 difference with the above formula. I think I understand the reason but can me make it less confusing and avoid naming the same way different quantities?", "author": "jpountz", "createdAt": "2020-04-30T13:08:21Z", "path": "lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java", "diffHunk": "@@ -822,39 +804,27 @@ public long finish(IndexOutput out) throws IOException {\n \n     // Write index:\n     long indexFP = out.getFilePointer();\n-    writeIndex(out, Math.toIntExact(countPerLeaf), leafBlockFPs, splitPackedValues);\n+    writeIndex(out, maxPointsInLeafNode, leafBlockFPs, splitPackedValues);\n     return indexFP;\n   }\n \n   /** Packs the two arrays, representing a balanced binary tree, into a compact byte[] structure. */\n   private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {\n-\n     int numLeaves = leafBlockFPs.length;\n-\n-    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree (only happens\n-    // if it was created by OneDimensionBKDWriter).  In this case the leaf nodes may straddle the two bottom\n+    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree.\n+    // In this case the leaf nodes may straddle the two bottom\n     // levels of the binary tree:\n-    if (numIndexDims == 1 && numLeaves > 1) {\n-      int levelCount = 2;\n-      while (true) {\n-        if (numLeaves >= levelCount && numLeaves <= 2*levelCount) {\n-          int lastLevel = 2*(numLeaves - levelCount);\n-          assert lastLevel >= 0;\n-          if (lastLevel != 0) {\n-            // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading\n-            // at read-time, so that we can still delta code them on disk at write:\n-            long[] newLeafBlockFPs = new long[numLeaves];\n-            System.arraycopy(leafBlockFPs, lastLevel, newLeafBlockFPs, 0, leafBlockFPs.length - lastLevel);\n-            System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, leafBlockFPs.length - lastLevel, lastLevel);\n-            leafBlockFPs = newLeafBlockFPs;\n-          }\n-          break;\n-        }\n-\n-        levelCount *= 2;\n-      }\n+    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);\n+    int leavesFullLevel = 1 << lastFullLevel;\n+    int unbalancedLeafNodes = 2 * (numLeaves - leavesFullLevel);", "originalCommit": "d0e008e109dc11841964037f9931e37c98607bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAzMzg3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1464#discussion_r418033875", "bodyText": "renamed to leavesPartialLevel", "author": "iverase", "createdAt": "2020-04-30T14:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5NTY2MQ=="}], "type": "inlineReview"}, {"oid": "63b534c942f4ddb447d475816ee58ab6b0997db3", "url": "https://github.com/apache/lucene-solr/commit/63b534c942f4ddb447d475816ee58ab6b0997db3", "message": "address review comments", "committedDate": "2020-04-30T13:59:41Z", "type": "commit"}, {"oid": "66ec20e74e1485ccb3412ef9249dd4fcf1f5b11c", "url": "https://github.com/apache/lucene-solr/commit/66ec20e74e1485ccb3412ef9249dd4fcf1f5b11c", "message": "Merge branch 'master' into bkdtree-unbalanced", "committedDate": "2020-05-02T09:12:05Z", "type": "commit"}, {"oid": "fdc5441f9cf8fbb4eed13b4700b1519b7db74af0", "url": "https://github.com/apache/lucene-solr/commit/fdc5441f9cf8fbb4eed13b4700b1519b7db74af0", "message": "add entry in CHANGES.txt", "committedDate": "2020-05-02T09:15:25Z", "type": "commit"}]}