{"pr_number": 1861, "pr_title": "SOLR-10391: Add overwrite option to UPLOAD ConfigSet action", "pr_createdAt": "2020-09-12T00:23:24Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1861", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwOTI2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r488909266", "bodyText": "If you are overwriting an untrusted configSet with a trusted configSet, I din't think that will get updated here. I guess you would only want it if CLEANUP is true, since only then are you sure that all of the content is trusted.\nSo doing it in that if statement would probably work.", "author": "HoustonPutman", "createdAt": "2020-09-15T19:19:47Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ConfigSetsHandler.java", "diffHunk": "@@ -170,21 +176,90 @@ private void handleConfigUploadRequest(SolrQueryRequest req, SolrQueryResponse r\n \n     // Create a node for the configuration in zookeeper\n     boolean trusted = getTrusted(req);\n-    zkClient.makePath(configPathInZk, (\"{\\\"trusted\\\": \" + Boolean.toString(trusted) + \"}\").\n-        getBytes(StandardCharsets.UTF_8), true);\n+    Set<String> filesToDelete = Collections.emptySet();\n+    if (overwritesExisting) {\n+      if (!trusted) {\n+        ensureOverwritingUntrustedConfigSet(zkClient, configPathInZk);\n+      }\n+      if (req.getParams().getBool(ConfigSetParams.CLEANUP, false)) {\n+        filesToDelete = getAllConfigsetFiles(zkClient, configPathInZk);\n+      }\n+    } else {", "originalCommit": "94649b931674346932096d71c5b9944074826500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAwMTU3Mg==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r489001572", "bodyText": "As it currently stands, an overwrite never updates the \"trusted\" flag, if it wasn't trusted before, it'll continue to be untrusted after the upgrade. If it was trusted, only an authenticated request would be allowed. I see your point that if \"cleanup\" is set to \"true\", an authenticated request could turn the configset to trusted, is that what you are suggesting?", "author": "tflobbe", "createdAt": "2020-09-15T21:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwOTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ0NTgzMA==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r489445830", "bodyText": "Yeah, for example if you want to use plugins or something similar, I could see someone not using a trusted configSet at first, but then wanting to overwrite their configSet to be \"trusted\" to be able to use the plugins.\nI don't see why that shouldn't be possible, given that there's little difference security-wise between creating a new config set and overwriting w/ cleanup.", "author": "HoustonPutman", "createdAt": "2020-09-16T13:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwOTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMzQ1NA==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r488913454", "bodyText": "We might want to clear data that the znode has if it exists and has data.", "author": "HoustonPutman", "createdAt": "2020-09-15T19:24:52Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ConfigSetsHandler.java", "diffHunk": "@@ -170,21 +176,90 @@ private void handleConfigUploadRequest(SolrQueryRequest req, SolrQueryResponse r\n \n     // Create a node for the configuration in zookeeper\n     boolean trusted = getTrusted(req);\n-    zkClient.makePath(configPathInZk, (\"{\\\"trusted\\\": \" + Boolean.toString(trusted) + \"}\").\n-        getBytes(StandardCharsets.UTF_8), true);\n+    Set<String> filesToDelete = Collections.emptySet();\n+    if (overwritesExisting) {\n+      if (!trusted) {\n+        ensureOverwritingUntrustedConfigSet(zkClient, configPathInZk);\n+      }\n+      if (req.getParams().getBool(ConfigSetParams.CLEANUP, false)) {\n+        filesToDelete = getAllConfigsetFiles(zkClient, configPathInZk);\n+      }\n+    } else {\n+      zkClient.makePath(configPathInZk, (\"{\\\"trusted\\\": \" + Boolean.toString(trusted) + \"}\").\n+              getBytes(StandardCharsets.UTF_8), true);\n+    }\n \n     ZipInputStream zis = new ZipInputStream(inputStream, StandardCharsets.UTF_8);\n     ZipEntry zipEntry = null;\n     while ((zipEntry = zis.getNextEntry()) != null) {\n       String filePathInZk = configPathInZk + \"/\" + zipEntry.getName();\n+      if (filePathInZk.endsWith(\"/\")) {\n+        filesToDelete.remove(filePathInZk.substring(0, filePathInZk.length() -1));\n+      } else {\n+        filesToDelete.remove(filePathInZk);\n+      }\n       if (zipEntry.isDirectory()) {\n-        zkClient.makePath(filePathInZk, true);\n+        zkClient.makePath(filePathInZk, false,  true);", "originalCommit": "94649b931674346932096d71c5b9944074826500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAwMTk4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r489001982", "bodyText": "Can that ever happen in a configset?", "author": "tflobbe", "createdAt": "2020-09-15T21:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ0NzUxNg==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r489447516", "bodyText": "Not very likely, was just thinking about possibilities. It's probably not an issue 99.9% of times, so it likely doesn't need to be addressed.", "author": "HoustonPutman", "createdAt": "2020-09-16T13:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQyMzUwNw==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r492423507", "bodyText": "Yes, I don't think this would be needed at this point. No API would set this, and no Solr component would read it. I guess the only case would be a custom component that writes and reads directly to ZooKeeper.", "author": "tflobbe", "createdAt": "2020-09-22T00:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMzQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNjcyNw==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r488916727", "bodyText": "the new ZKMaintenanceUtils.ZKVisitory() { ... } can be replaced with files::add", "author": "HoustonPutman", "createdAt": "2020-09-15T19:28:41Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ConfigSetsHandler.java", "diffHunk": "@@ -170,21 +176,90 @@ private void handleConfigUploadRequest(SolrQueryRequest req, SolrQueryResponse r\n \n     // Create a node for the configuration in zookeeper\n     boolean trusted = getTrusted(req);\n-    zkClient.makePath(configPathInZk, (\"{\\\"trusted\\\": \" + Boolean.toString(trusted) + \"}\").\n-        getBytes(StandardCharsets.UTF_8), true);\n+    Set<String> filesToDelete = Collections.emptySet();\n+    if (overwritesExisting) {\n+      if (!trusted) {\n+        ensureOverwritingUntrustedConfigSet(zkClient, configPathInZk);\n+      }\n+      if (req.getParams().getBool(ConfigSetParams.CLEANUP, false)) {\n+        filesToDelete = getAllConfigsetFiles(zkClient, configPathInZk);\n+      }\n+    } else {\n+      zkClient.makePath(configPathInZk, (\"{\\\"trusted\\\": \" + Boolean.toString(trusted) + \"}\").\n+              getBytes(StandardCharsets.UTF_8), true);\n+    }\n \n     ZipInputStream zis = new ZipInputStream(inputStream, StandardCharsets.UTF_8);\n     ZipEntry zipEntry = null;\n     while ((zipEntry = zis.getNextEntry()) != null) {\n       String filePathInZk = configPathInZk + \"/\" + zipEntry.getName();\n+      if (filePathInZk.endsWith(\"/\")) {\n+        filesToDelete.remove(filePathInZk.substring(0, filePathInZk.length() -1));\n+      } else {\n+        filesToDelete.remove(filePathInZk);\n+      }\n       if (zipEntry.isDirectory()) {\n-        zkClient.makePath(filePathInZk, true);\n+        zkClient.makePath(filePathInZk, false,  true);\n       } else {\n         createZkNodeIfNotExistsAndSetData(zkClient, filePathInZk,\n             IOUtils.toByteArray(zis));\n       }\n     }\n     zis.close();\n+    deleteUnusedFiles(zkClient, filesToDelete);\n+  }\n+\n+  private void deleteUnusedFiles(SolrZkClient zkClient, Set<String> filesToDelete) throws InterruptedException, KeeperException {\n+    if (!filesToDelete.isEmpty()) {\n+      if (log.isInfoEnabled()) {\n+        log.info(\"Cleaning up {} unused files\", filesToDelete.size());\n+      }\n+      if (log.isDebugEnabled()) {\n+        log.debug(\"Cleaning up unused files: {}\", filesToDelete);\n+      }\n+      for (String f:filesToDelete) {\n+        try {\n+          zkClient.delete(f, -1, true);\n+        } catch (KeeperException.NoNodeException nne) {\n+        }\n+      }\n+    }\n+  }\n+\n+  private Set<String> getAllConfigsetFiles(SolrZkClient zkClient, String configPathInZk) throws KeeperException, InterruptedException {\n+    final Set<String> files = new HashSet<>();\n+    if (!configPathInZk.startsWith(ZkConfigManager.CONFIGS_ZKNODE + \"/\")) {\n+      throw new IllegalArgumentException(\"\\\"\" + configPathInZk + \"\\\" not recognized as a configset path\");\n+    }\n+    ZkMaintenanceUtils.traverseZkTree(zkClient, configPathInZk, ZkMaintenanceUtils.VISIT_ORDER.VISIT_POST, new ZkMaintenanceUtils.ZkVisitor() {\n+      @Override\n+      public void visit(String path) throws InterruptedException, KeeperException {\n+        files.add(path);\n+      }\n+    });", "originalCommit": "94649b931674346932096d71c5b9944074826500", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMDExNw==", "url": "https://github.com/apache/lucene-solr/pull/1861#discussion_r488920117", "bodyText": "using getOrDefault(\"trusted\", false) would remove the need for the null check.", "author": "HoustonPutman", "createdAt": "2020-09-15T19:32:41Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ConfigSetsHandler.java", "diffHunk": "@@ -170,21 +176,90 @@ private void handleConfigUploadRequest(SolrQueryRequest req, SolrQueryResponse r\n \n     // Create a node for the configuration in zookeeper\n     boolean trusted = getTrusted(req);\n-    zkClient.makePath(configPathInZk, (\"{\\\"trusted\\\": \" + Boolean.toString(trusted) + \"}\").\n-        getBytes(StandardCharsets.UTF_8), true);\n+    Set<String> filesToDelete = Collections.emptySet();\n+    if (overwritesExisting) {\n+      if (!trusted) {\n+        ensureOverwritingUntrustedConfigSet(zkClient, configPathInZk);\n+      }\n+      if (req.getParams().getBool(ConfigSetParams.CLEANUP, false)) {\n+        filesToDelete = getAllConfigsetFiles(zkClient, configPathInZk);\n+      }\n+    } else {\n+      zkClient.makePath(configPathInZk, (\"{\\\"trusted\\\": \" + Boolean.toString(trusted) + \"}\").\n+              getBytes(StandardCharsets.UTF_8), true);\n+    }\n \n     ZipInputStream zis = new ZipInputStream(inputStream, StandardCharsets.UTF_8);\n     ZipEntry zipEntry = null;\n     while ((zipEntry = zis.getNextEntry()) != null) {\n       String filePathInZk = configPathInZk + \"/\" + zipEntry.getName();\n+      if (filePathInZk.endsWith(\"/\")) {\n+        filesToDelete.remove(filePathInZk.substring(0, filePathInZk.length() -1));\n+      } else {\n+        filesToDelete.remove(filePathInZk);\n+      }\n       if (zipEntry.isDirectory()) {\n-        zkClient.makePath(filePathInZk, true);\n+        zkClient.makePath(filePathInZk, false,  true);\n       } else {\n         createZkNodeIfNotExistsAndSetData(zkClient, filePathInZk,\n             IOUtils.toByteArray(zis));\n       }\n     }\n     zis.close();\n+    deleteUnusedFiles(zkClient, filesToDelete);\n+  }\n+\n+  private void deleteUnusedFiles(SolrZkClient zkClient, Set<String> filesToDelete) throws InterruptedException, KeeperException {\n+    if (!filesToDelete.isEmpty()) {\n+      if (log.isInfoEnabled()) {\n+        log.info(\"Cleaning up {} unused files\", filesToDelete.size());\n+      }\n+      if (log.isDebugEnabled()) {\n+        log.debug(\"Cleaning up unused files: {}\", filesToDelete);\n+      }\n+      for (String f:filesToDelete) {\n+        try {\n+          zkClient.delete(f, -1, true);\n+        } catch (KeeperException.NoNodeException nne) {\n+        }\n+      }\n+    }\n+  }\n+\n+  private Set<String> getAllConfigsetFiles(SolrZkClient zkClient, String configPathInZk) throws KeeperException, InterruptedException {\n+    final Set<String> files = new HashSet<>();\n+    if (!configPathInZk.startsWith(ZkConfigManager.CONFIGS_ZKNODE + \"/\")) {\n+      throw new IllegalArgumentException(\"\\\"\" + configPathInZk + \"\\\" not recognized as a configset path\");\n+    }\n+    ZkMaintenanceUtils.traverseZkTree(zkClient, configPathInZk, ZkMaintenanceUtils.VISIT_ORDER.VISIT_POST, new ZkMaintenanceUtils.ZkVisitor() {\n+      @Override\n+      public void visit(String path) throws InterruptedException, KeeperException {\n+        files.add(path);\n+      }\n+    });\n+    files.remove(configPathInZk);\n+    return files;\n+  }\n+\n+  /*\n+   * Fail if an untrusted request tries to update a trusted ConfigSet\n+   */\n+  private void ensureOverwritingUntrustedConfigSet(SolrZkClient zkClient, String configSetZkPath) {\n+    byte[] configSetNodeContent;\n+    try {\n+      configSetNodeContent = zkClient.getData(configSetZkPath, null, null, true);\n+    } catch (KeeperException e) {\n+      throw new SolrException(ErrorCode.SERVER_ERROR, \"Exception while fetching current configSet at \" + configSetZkPath, e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while fetching current configSet at \" + configSetZkPath, e);\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    Map<Object, Object> contentMap = (Map<Object, Object>) Utils.fromJSON(configSetNodeContent);\n+    Boolean isCurrentlyTrusted = (Boolean) contentMap.get(\"trusted\");", "originalCommit": "94649b931674346932096d71c5b9944074826500", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "879c88010677861e7282f2b61d29929f0a701546", "url": "https://github.com/apache/lucene-solr/commit/879c88010677861e7282f2b61d29929f0a701546", "message": "Fix test after rebase", "committedDate": "2020-09-21T18:19:23Z", "type": "forcePushed"}, {"oid": "c876ca1cacf84b44b55f78fbb1101d8b0982ec1c", "url": "https://github.com/apache/lucene-solr/commit/c876ca1cacf84b44b55f78fbb1101d8b0982ec1c", "message": "Add override option to UPLOAD ConfigSet action\n\nWhen set to 'true', Solr will override an existing configset in ZooKeeper if an UPLOAD action happens on an existing configset", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "74ff7c029803d8de1a0625e561335901ccbcd869", "url": "https://github.com/apache/lucene-solr/commit/74ff7c029803d8de1a0625e561335901ccbcd869", "message": "s/override/overwrite/", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "c99c7500e928b2357889d90cbf8d8a0e607ca445", "url": "https://github.com/apache/lucene-solr/commit/c99c7500e928b2357889d90cbf8d8a0e607ca445", "message": "Add cleanup option when overwritting ConfigSets", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "38c1f634e6da010fe9834992daa2ef2233821ecb", "url": "https://github.com/apache/lucene-solr/commit/38c1f634e6da010fe9834992daa2ef2233821ecb", "message": "Add test for ZkMaintenanceUtils.traverseZkTree", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "2f30ffdecc7bba84fbeea2bc7b9a0c4b07b68b7f", "url": "https://github.com/apache/lucene-solr/commit/2f30ffdecc7bba84fbeea2bc7b9a0c4b07b68b7f", "message": "Add ref guide docs", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "6ca8d62f5f8218485a093c89de863d0893644799", "url": "https://github.com/apache/lucene-solr/commit/6ca8d62f5f8218485a093c89de863d0893644799", "message": "Fix precommit", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "16e08ee16862c8f205d3d9c7f7e99007052b7151", "url": "https://github.com/apache/lucene-solr/commit/16e08ee16862c8f205d3d9c7f7e99007052b7151", "message": "Address some PR comments", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "b5e01eae8f9261473d564256387bacc882e77fed", "url": "https://github.com/apache/lucene-solr/commit/b5e01eae8f9261473d564256387bacc882e77fed", "message": "Trusted request with cleanup convert untrusted to trusted configsets", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "003d8b81a62f53c1053972e2349858d5229f44c1", "url": "https://github.com/apache/lucene-solr/commit/003d8b81a62f53c1053972e2349858d5229f44c1", "message": "Fix test after rebase", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "16b0da0f8ad9398251328d5af25cbf7d1a7185cc", "url": "https://github.com/apache/lucene-solr/commit/16b0da0f8ad9398251328d5af25cbf7d1a7185cc", "message": "Rename method", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "8d941638cef1b95398facbd1ef8d29e3aa46333f", "url": "https://github.com/apache/lucene-solr/commit/8d941638cef1b95398facbd1ef8d29e3aa46333f", "message": "Fix precommit", "committedDate": "2020-09-22T17:13:36Z", "type": "commit"}, {"oid": "add38edc39b84694218cfa12a908b9351e556d5c", "url": "https://github.com/apache/lucene-solr/commit/add38edc39b84694218cfa12a908b9351e556d5c", "message": "Add CHANGES entry", "committedDate": "2020-09-22T17:15:27Z", "type": "commit"}, {"oid": "add38edc39b84694218cfa12a908b9351e556d5c", "url": "https://github.com/apache/lucene-solr/commit/add38edc39b84694218cfa12a908b9351e556d5c", "message": "Add CHANGES entry", "committedDate": "2020-09-22T17:15:27Z", "type": "forcePushed"}]}