{"pr_number": 1624, "pr_title": "use MethodHandles in AnnotatedAPI", "pr_createdAt": "2020-06-28T01:07:40Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1624", "timeline": [{"oid": "8cf8e13d13015445efbbb5a91a6b5ff75c466281", "url": "https://github.com/apache/lucene-solr/commit/8cf8e13d13015445efbbb5a91a6b5ff75c466281", "message": "use MethodHandles", "committedDate": "2020-06-28T01:05:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MjY2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446592665", "bodyText": "Catching Throwable is generally something to avoid.  Why here do you think it makes sense?", "author": "dsmiley", "createdAt": "2020-06-28T02:55:39Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -306,7 +313,7 @@ void invoke(SolrQueryRequest req, SolrQueryResponse rsp, CommandOperation cmd) {\n       } catch (InvocationTargetException ite) {\n         log.error(\"Error executing command \", ite);\n         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, ite.getCause());\n-      } catch (Exception e) {\n+      } catch (Throwable e) {", "originalCommit": "8cf8e13d13015445efbbb5a91a6b5ff75c466281", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5Nzc4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446597787", "bodyText": "methodhandle.invoke() throws Throwable. What choice do we have?", "author": "noblepaul", "createdAt": "2020-06-28T04:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MjY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNjc4NA==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446626784", "bodyText": "I think a comment referencing the MethodHandle Javadoc would be helpful here, as the Javadoc explains Throwable should be caught and the exception wrapped.\n\nBut in Java source code, methods which perform method handle calls must either explicitly throw Throwable, or else must catch all throwables locally, rethrowing only those which are legal in the context, and wrapping ones which are illegal.", "author": "murblanc", "createdAt": "2020-06-28T09:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MjY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMTUxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446631519", "bodyText": "There are two things to do:\n\nhave the try-catch only around the invoke and nothing else, so we don't accidentally catch any unwanted exception in the surrounding code\nonly checked exceptions should be wrapped, everything else rethrown. This keeps stack traces clean.\n\nThe reason for the declaration of \"Throwable\" comes from the fact that the method handle always throws the original Exception and it's now wrapped like for reflection. As checked exceptions is a compiler thing, normal code using method handles in bytecode or invokedynamic never needs to catch Throwable. It's only the stupid Java compiler that enforces us to catch everything, because it can't know if the handle might possibly throw a checked exception. When writing scripting languages you just ignore the Throwable when you produce bytecode. \ud83e\udd13\nHere we should catch all possible exceptions that are commonly thrown by plugins: SolrException, Runtime exception, Error and rethrown those. The last catch block would catch Throwable and log it separately as some fatal error.\nThe code above should check the possible exceptions a method may throw and forbid e.g. a plugin to throw Interrupted exception. So maybe get all throws clauses of method and have whitelist. In the catch clause then throw AssertionError if the \"unknown\" exception happens.", "author": "uschindler", "createdAt": "2020-06-28T10:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MjY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzg1MA==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446623850", "bodyText": "You obviously meant theClass.getName() here and not klas.getName().", "author": "murblanc", "createdAt": "2020-06-28T09:07:01Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -87,16 +88,18 @@ public EndPoint getEndPoint() {\n   public static List<Api> getApis(Object obj) {\n     return getApis(obj.getClass(), obj);\n   }\n-  public static List<Api> getApis(Class<? extends Object> klas , Object obj) {\n-    if (!Modifier.isPublic(klas.getModifiers())) {\n-      throw new RuntimeException(klas.getName() + \" is not public\");\n+  public static List<Api> getApis(Class<? extends Object> theClass , Object obj)  {\n+    Class<?> klas = null;\n+    try {\n+      klas = MethodHandles.publicLookup().accessClass(theClass);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(klas.getName() + \" is not public\", e);", "originalCommit": "8cf8e13d13015445efbbb5a91a6b5ff75c466281", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMjA5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446632093", "bodyText": "Good catch. The code here is a mess, as you declare the variable as null. You should declare it final before catch block and not assign null. Then compiler would have been complained.\nThe current code is a horrible antipattern. Always declare variables as final before try and assign once.", "author": "uschindler", "createdAt": "2020-06-28T10:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMjE1Nw==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r447412157", "bodyText": "Thanks, everyone. I wanted to get a quick review for the implementation. Basically, I was not too sure about the idioms we normally use for MethodHandle based reflection code. Moreover, We are more worried about the security manager complaining and wanted to do a PoC if that problem goes away", "author": "noblepaul", "createdAt": "2020-06-30T05:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNTE5MQ==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446625191", "bodyText": "Lets throw SolrException here.", "author": "chatman", "createdAt": "2020-06-28T09:19:01Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -225,7 +228,11 @@ public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n       if (Modifier.isPublic(method.getModifiers())) {\n         this.command = command;\n         this.obj = obj;\n-        this.method = method;\n+        try {\n+          this.method = MethodHandles.publicLookup().unreflect(method);\n+        } catch (IllegalAccessException e) {\n+          throw new RuntimeException(\"Unable to unlookup method\");", "originalCommit": "8cf8e13d13015445efbbb5a91a6b5ff75c466281", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNTkzMw==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446625933", "bodyText": "Unrelated to to this PR (i.e. comment holds for previous version of the code), maybe InterruptedException should be caught separately and Thread.currentThread().interrupt() be called.", "author": "murblanc", "createdAt": "2020-06-28T09:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNjQwNA==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446626404", "bodyText": "unlookup? (did you mean unreflect?)", "author": "murblanc", "createdAt": "2020-06-28T09:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNTE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMjY4MA==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446632680", "bodyText": "The exception text should not mention internal details. It should just say that the method cannot be called, as it's not accessible (non public, class not visible, different classloader,...)", "author": "uschindler", "createdAt": "2020-06-28T10:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNzIxMA==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446627210", "bodyText": "Is this still needed? Wouldn't MethodHandles.publicLookup().accessClass(theClass) only return public methods?", "author": "murblanc", "createdAt": "2020-06-28T09:38:36Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -113,7 +116,7 @@ public EndPoint getEndPoint() {\n       return Collections.singletonList(new AnnotatedApi(specProvider, endPoint, commands, null));\n     } else {\n       List<Api> apis = new ArrayList<>();\n-      for (Method m : klas.getDeclaredMethods()) {\n+      for (Method m : klas.getMethods()) {\n         EndPoint endPoint = m.getAnnotation(EndPoint.class);\n         if (endPoint == null) continue;\n         if (!Modifier.isPublic(m.getModifiers())) {", "originalCommit": "8cf8e13d13015445efbbb5a91a6b5ff75c466281", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMDQ4MA==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446630480", "bodyText": "Yes, we still need some way to check public methods. The accessClass() method above returns itsself, but the check for public is not needed if we use getMethods() instead of getDeclaredMethods().\nThe accessClass() check can't be backported to 8.x as it is new in Java 9. So we need to somehow do the check for accessibility manually.", "author": "uschindler", "createdAt": "2020-06-28T10:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNzIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMTMxMQ==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446631311", "bodyText": "So you agree @uschindler that the if can be removed in the master branch we're looking at, did I understand you correctly?", "author": "murblanc", "createdAt": "2020-06-28T10:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNzIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMjUyMg==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446632522", "bodyText": "Yes. For both branches.\nIn 8.x we have to fix the class accessibility check (unrelated to the if statement).", "author": "uschindler", "createdAt": "2020-06-28T10:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNzIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMjkzMg==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446632932", "bodyText": "The if statement is not needed, because the public checks are done by unreflect().\nThis code is from reflection times to catch error early. By using method handles everything is checked and linked early, so you can't get any surprises later. So the public checks is complete obsolete, all this is handled by unreflect.", "author": "uschindler", "createdAt": "2020-06-28T10:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njg5MDAzMw==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r446890033", "bodyText": "This catch block can go away!", "author": "uschindler", "createdAt": "2020-06-29T11:12:50Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -306,7 +313,7 @@ void invoke(SolrQueryRequest req, SolrQueryResponse rsp, CommandOperation cmd) {\n       } catch (InvocationTargetException ite) {", "originalCommit": "8cf8e13d13015445efbbb5a91a6b5ff75c466281", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "330dd5398ff3226c58083d8c3e3e0332ed162f66", "url": "https://github.com/apache/lucene-solr/commit/330dd5398ff3226c58083d8c3e3e0332ed162f66", "message": "Implementing review comments", "committedDate": "2020-06-30T08:01:17Z", "type": "commit"}, {"oid": "1a7184bffc9d0e227f66d36fd7d771f3e57824cf", "url": "https://github.com/apache/lucene-solr/commit/1a7184bffc9d0e227f66d36fd7d771f3e57824cf", "message": "implement review comments", "committedDate": "2020-06-30T08:03:21Z", "type": "commit"}, {"oid": "c2ebf59a01a54ce416577bb82792f39c3adda59e", "url": "https://github.com/apache/lucene-solr/commit/c2ebf59a01a54ce416577bb82792f39c3adda59e", "message": "Implementing review comments", "committedDate": "2020-06-30T12:01:23Z", "type": "commit"}, {"oid": "7c160be57ffbb580d78ea5b435664585c564ae40", "url": "https://github.com/apache/lucene-solr/commit/7c160be57ffbb580d78ea5b435664585c564ae40", "message": "precommit errors", "committedDate": "2020-06-30T12:21:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1MDk2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r447650963", "bodyText": "this should be declared final and not nulled.", "author": "uschindler", "createdAt": "2020-06-30T12:41:22Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -87,16 +83,18 @@ public EndPoint getEndPoint() {\n   public static List<Api> getApis(Object obj) {\n     return getApis(obj.getClass(), obj);\n   }\n-  public static List<Api> getApis(Class<? extends Object> klas , Object obj) {\n-    if (!Modifier.isPublic(klas.getModifiers())) {\n-      throw new RuntimeException(klas.getName() + \" is not public\");\n+  public static List<Api> getApis(Class<? extends Object> theClass , Object obj)  {\n+    Class<?> klas = null;", "originalCommit": "7c160be57ffbb580d78ea5b435664585c564ae40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNjQ1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1624#discussion_r447736459", "bodyText": "how is that possible?", "author": "noblepaul", "createdAt": "2020-06-30T14:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1MDk2Mw=="}], "type": "inlineReview"}]}