{"pr_number": 1626, "pr_title": "SOLR-14588: Implement Circuit Breakers", "pr_createdAt": "2020-06-28T18:02:48Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1626", "timeline": [{"oid": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "url": "https://github.com/apache/lucene-solr/commit/b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-28T18:08:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTExNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685116", "bodyText": "I always like to put in default values where the Java defaults wouldn't work, just in case \"somehow\" this isn't set in future. memoryCircuitBreakerThreshold defaults to 0 in this case, is that OK?\nAnd maybe name this memoryCircuitBreakerThresholdPct?", "author": "ErickErickson", "createdAt": "2020-06-28T18:54:50Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -522,6 +527,10 @@ public SolrRequestParsers getRequestParsers() {\n   public final int queryResultWindowSize;\n   public final int queryResultMaxDocsCached;\n   public final boolean enableLazyFieldLoading;\n+\n+  // Circuit Breaker Configuration\n+  public final boolean useCircuitBreakers;\n+  public final int memoryCircuitBreakerThreshold;", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTU4OA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685588", "bodyText": "Does it really make sense to allow either of these values? 0 seems like it'd cause everything to break (haven't seen the rest of the code yet, maybe 0 is a special case). 100% seems too late. Do we have any good information about what reasonable upper and lower bounds are? And should we enforce them? Say 50%/90% as a straw-man proposal for discussion...", "author": "ErickErickson", "createdAt": "2020-06-28T18:59:11Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0ODQ1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447048456", "bodyText": "This is more of a sanity test to ensure that the incoming values lie in the range of percentage. If we wish to restrain the actual domain of values that memoryCircuitBreakerThreshold can take, I can add another check and add the same in the documentation.", "author": "atris", "createdAt": "2020-06-29T15:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTg4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446685886", "bodyText": "Add what valid percentages are here, especially if we decide to enforce as above..\nThis should also echo the number entered and what the valid limits are, something like:\nmemoryCircuitBreakerThreshold was set to\" + memoryCircuitBreakerThreshold + \". Valid percentages must be between X% and Y%\"", "author": "ErickErickson", "createdAt": "2020-06-28T19:02:03Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+        throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");\n+      }", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5MzQ0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447093442", "bodyText": "Same as above. If we wish to enforce a smaller domain of values, we should discuss the range and I will add extra checks.", "author": "atris", "createdAt": "2020-06-29T16:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NzU4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447597583", "bodyText": "Added the same, thanks", "author": "atris", "createdAt": "2020-06-30T11:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4NTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446687849", "bodyText": "Why not just allocate a new HashMap here and avoid the null check below?\nHmmm, I suppose if there aren't any circuit breakers one could return null, NM.", "author": "ErickErickson", "createdAt": "2020-06-28T19:20:39Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNTgyOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446935828", "bodyText": "If this is called on every query request then it makes sense to avoid allocations until they are needed.", "author": "sigram", "createdAt": "2020-06-29T12:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NjE0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447586147", "bodyText": "There's a typo in this method name - \"checked\" -> \"check\".\nIn general, could we use shorter method names rather than these very long ones? We already know what the component does, we know that it manages CircuitBreakers - IMHO there's no need whatsoever to remind users in every method name that they deal with CircuitBreakers. :)\nI propose getTripped, checkAnyTripped, toErrorMessage and so on, avoiding repetition where it's obvious what we're dealing with.", "author": "sigram", "createdAt": "2020-06-30T10:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4Nzg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446688878", "bodyText": "This seems like an awfully small file, perhaps put this in the abstract CircuitBreaker class? No big deal either way.", "author": "ErickErickson", "createdAt": "2020-06-28T19:31:18Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+/**\n+ * Types of circuit breakers\n+ */", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA5NDQ3Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447094476", "bodyText": "I prefer cleaner abstractions -- helps avoid compiler errors ;)", "author": "atris", "createdAt": "2020-06-29T16:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MDIxMA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447590210", "bodyText": "I think Erick suggested (and I agree) that this enum should be simply declared in CircuitBreaker class, as CircuitBreaker.CircuitBreakerType or just CircuitBreaker.Type. This doesn't affect compilation but helps to reduce the number of trivial class files. This is also a pattern that is used frequently in Solr in other places.", "author": "sigram", "createdAt": "2020-06-30T10:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY4ODg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMDk1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446910959", "bodyText": "I think 0 also doesn't make much sense.", "author": "sigram", "createdAt": "2020-06-29T11:52:12Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -804,6 +813,14 @@ private void initLibs(SolrResourceLoader loader, boolean isConfigsetTrusted) {\n     loader.reloadLuceneSPI();\n   }\n \n+  private void validateMemoryBreakerThreshold() {\n+    if (useCircuitBreakers) {\n+      if (memoryCircuitBreakerThreshold > 100 || memoryCircuitBreakerThreshold < 0) {\n+        throw new IllegalArgumentException(\"memoryCircuitBreakerThreshold is not a valid percentage\");", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcxNA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446914714", "bodyText": "The following probably belongs to the SIP ... but the way I think about the common usage of this class for different code-paths is if breaker configs are labeled and correspond to different code-paths, eg.:\n\n\"query\" -> one config\n\"index\" -> another config\n\"foobar\" -> yet another config, used perhaps in my custom component\n\nCurrent implementation limits us to use the same config for potentially very different code paths.", "author": "sigram", "createdAt": "2020-06-29T11:59:07Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEyMzY4MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447123680", "bodyText": "Agreed. I added the single configuration since there is only one code path. I have a SIP upcoming to add an API for controlling these configs, will add this to the same. Thanks for bringing the same up.", "author": "atris", "createdAt": "2020-06-29T17:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNDcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNTYzNw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446915637", "bodyText": "OMG, what a name :) Maybe just checkTrippedBreakers ?", "author": "sigram", "createdAt": "2020-06-29T12:00:43Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNjQ3MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446916470", "bodyText": "Maybe checkAnyBreakerTripped ? Because we don't actually check all breakers here.", "author": "sigram", "createdAt": "2020-06-29T12:02:11Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAllCircuitBreakers() {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNzcwOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446917708", "bodyText": "Do we actually need SolrCore here, or just the breakers' config (currently in SolrConfig)?", "author": "sigram", "createdAt": "2020-06-29T12:04:17Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkAllCircuitBreakersAndReturnTrippedBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAllCircuitBreakers() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isCircuitBreakerEnabled() &&\n+          circuitBreaker.isCircuitBreakerGauntletTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).printDebugInfo());\n+    }\n+\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Register default circuit breakers and return a constructed CircuitBreakerManager\n+   * instance which serves the given circuit breakers.\n+   *\n+   * Any default circuit breakers should be registered here\n+   */\n+  public static CircuitBreakerManager buildDefaultCircuitBreakerManager(SolrCore solrCore) {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxODc5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446918796", "bodyText": "It needs  tags to actually make a new paragraph.", "author": "sigram", "createdAt": "2020-06-29T12:06:18Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxOTgxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446919819", "bodyText": "This can be calculated once in the constructor - IIRC if SolrConfig is updated the core is reloaded anyway, which will construct the breaker once again.", "author": "sigram", "createdAt": "2020-06-29T12:08:00Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyMjEzOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446922138", "bodyText": "This comment is somewhat misleading ... if I correctly understand the intent :) MemoryUsageGaugeSet does provide the heap and the non-heap usages separately, so it's possible to get the value we want from it - but it incurs unnecessary cost and additional allocations, so we can do it cheaper by using MemoryMXBean directly.", "author": "sigram", "createdAt": "2020-06-29T12:12:08Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ *\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrCore solrCore) {\n+    super(solrCore);\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isCircuitBreakerGauntletTripped() {\n+    if (!isCircuitBreakerEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String printDebugInfo() {\n+    return \"seenMemory=\" + seenMemory.get() + \" allowedMemory=\" + allowedMemory.get();\n+  }\n+\n+  private long getCurrentMemoryThreshold() {\n+    int thresholdValueInPercentage = solrCore.getSolrConfig().memoryCircuitBreakerThreshold;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    long actualLimit = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (actualLimit <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+\n+    return actualLimit;\n+  }\n+\n+  /**\n+   * Calculate the live memory usage for the system. This method has package visibility\n+   * to allow using for testing\n+   * @return Memory usage in bytes\n+   */\n+  protected long calculateLiveMemoryUsage() {\n+    // NOTE: MemoryUsageGaugeSet provides memory usage statistics but we do not use them\n+    // here since MemoryUsageGaugeSet provides combination of heap and non heap usage and", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4NTM4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447185389", "bodyText": "Better wording, thanks!", "author": "atris", "createdAt": "2020-06-29T18:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyMjEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTg2OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446925869", "bodyText": "Maybe isEnabled ?", "author": "sigram", "createdAt": "2020-06-29T12:18:39Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNjA0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446926047", "bodyText": "Maybe isTripped ?", "author": "sigram", "createdAt": "2020-06-29T12:18:57Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {\n+    return solrCore.getSolrConfig().useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this allocation will trigger circuit breaker.\n+   */\n+  public abstract boolean isCircuitBreakerGauntletTripped();", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNjcxNw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r446926717", "bodyText": "This doesn't actually print anything, maybe name it getDebugInfo ?", "author": "sigram", "createdAt": "2020-06-29T12:20:08Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrCore;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrCore solrCore;\n+\n+  public CircuitBreaker(SolrCore solrCore) {\n+    this.solrCore = solrCore;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isCircuitBreakerEnabled() {\n+    return solrCore.getSolrConfig().useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this allocation will trigger circuit breaker.\n+   */\n+  public abstract boolean isCircuitBreakerGauntletTripped();\n+\n+  /**\n+   * Print debug useful info\n+   */\n+  public abstract String printDebugInfo();", "originalCommit": "b6463fa8d68fcc016bbcdbaf23f08f3f0564d881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "url": "https://github.com/apache/lucene-solr/commit/f6f38abf5c30e6f8eecb06a0bbef7e80481b5a07", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-29T19:06:28Z", "type": "forcePushed"}, {"oid": "d9f7624131475761b466c92603abcd9846e62bad", "url": "https://github.com/apache/lucene-solr/commit/d9f7624131475761b466c92603abcd9846e62bad", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-29T19:11:17Z", "type": "forcePushed"}, {"oid": "61ca4c0bd71f5cc35b515308e1757292965f90ff", "url": "https://github.com/apache/lucene-solr/commit/61ca4c0bd71f5cc35b515308e1757292965f90ff", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-06-29T19:19:03Z", "type": "forcePushed"}, {"oid": "b5582fa759c575623b37c911d7f4485bef7ac940", "url": "https://github.com/apache/lucene-solr/commit/b5582fa759c575623b37c911d7f4485bef7ac940", "message": "Update test parameter", "committedDate": "2020-06-30T07:57:03Z", "type": "forcePushed"}, {"oid": "e8c53bd42247904060bb5ee4903ccf46c4057c49", "url": "https://github.com/apache/lucene-solr/commit/e8c53bd42247904060bb5ee4903ccf46c4057c49", "message": "More Updates", "committedDate": "2020-06-30T11:11:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NjM1NA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447586354", "bodyText": "checkAnyTripped ?", "author": "sigram", "createdAt": "2020-06-30T10:39:39Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NzMyMw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447587323", "bodyText": "This is an awkward name - maybe toErrorString or toErrorMessage ?", "author": "sigram", "createdAt": "2020-06-30T10:41:26Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODAwNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447588006", "bodyText": "New-lines or other separator characters would make this message more readable, now we're getting a single very long line.", "author": "sigram", "createdAt": "2020-06-30T10:42:48Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo());", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODUzNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447588536", "bodyText": "If circuit breakers are not enabled in SolrConfig is there still any point to register any of them?\nAlso, I propose to rename this method to just build - we don't have any way yet to build a non-default manager anyway. The javadoc already says it builds a default configuration.", "author": "sigram", "createdAt": "2020-06-30T10:43:45Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {\n+    Map<CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyCircuitBreakerTripped() {\n+    for (Map.Entry<CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip\n+   * @param circuitBreakerMap Input list for circuit breakers\n+   * @return Constructed error message\n+   */\n+  public static String constructFinalErrorMessageString(Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo());\n+    }\n+\n+    return sb.toString();\n+  }\n+\n+  /**\n+   * Register default circuit breakers and return a constructed CircuitBreakerManager\n+   * instance which serves the given circuit breakers.\n+   *\n+   * Any default circuit breakers should be registered here\n+   */\n+  public static CircuitBreakerManager buildDefaultCircuitBreakerManager(SolrConfig solrConfig) {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczODY3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447738671", "bodyText": "Fixed, thanks.", "author": "atris", "createdAt": "2020-06-30T14:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NzY3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447597673", "bodyText": "These can be final too (it doesn't matter at runtime but it makes the intent clear).", "author": "sigram", "createdAt": "2020-06-30T11:01:06Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThreshold\n+ * in solrconfig.xml\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking printDebugInfo()\n+  private ThreadLocal<Long> seenMemory = new ThreadLocal<>();", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5OTc0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447599741", "bodyText": "This javadoc is confusing - why not simply say \"Check if this breaker is tripped\"? It's not the request that trips the breaker, it's the underlying condition that does this.", "author": "sigram", "createdAt": "2020-06-30T11:05:23Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this request will trigger circuit breaker.", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5OTkxMA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447599910", "bodyText": "Get useful debug info.", "author": "sigram", "createdAt": "2020-06-30T11:05:46Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ *\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same)\n+ *  2. Use the circuit breaker in a specific code path(s)\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if this request will trigger circuit breaker.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Print debug useful info", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDQ4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447600489", "bodyText": "We can drop CircuitBreaker from the method name - we already know what we're going to register.", "author": "sigram", "createdAt": "2020-06-30T11:07:01Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDc4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447600789", "bodyText": "Drop CircuitBreakers?", "author": "sigram", "createdAt": "2020-06-30T11:07:41Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+\n+  private final Map<CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void registerCircuitBreaker(CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreakerType, CircuitBreaker> checkedTrippedCircuitBreakers() {", "originalCommit": "b5582fa759c575623b37c911d7f4485bef7ac940", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "80b5ce7495c720c927c883411b76326cf009409d", "url": "https://github.com/apache/lucene-solr/commit/80b5ce7495c720c927c883411b76326cf009409d", "message": "Renamings", "committedDate": "2020-06-30T15:27:33Z", "type": "forcePushed"}, {"oid": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "url": "https://github.com/apache/lucene-solr/commit/4225317e4da65a5f6ae49d5f6ecac47db274444f", "message": "Renamings", "committedDate": "2020-06-30T15:35:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjgyMg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447792822", "bodyText": "Add full-stops at the end of sentences and a <p> between paragraphs, otherwise the lines will run into each other.", "author": "sigram", "createdAt": "2020-06-30T15:53:28Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.putIfAbsent(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered", "originalCommit": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MzI0NA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447793244", "bodyText": "Full-stop? ;)", "author": "sigram", "createdAt": "2020-06-30T15:54:04Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check if any circuit breaker has triggered.\n+   * @return CircuitBreakers which have triggered, null otherwise\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkedTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.putIfAbsent(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered\n+   *\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip", "originalCommit": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDczMA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447794730", "bodyText": "Hmm, if we're warning about this then maybe we should give some details about what's wrong, i.e. which value was unexpected.", "author": "sigram", "createdAt": "2020-06-30T15:56:04Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {\n+      log.warn(\"MemoryCircuitBreaker's monitored values not set correctly\");", "originalCommit": "4225317e4da65a5f6ae49d5f6ecac47db274444f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxMzYwOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r447813608", "bodyText": "Added a message stating the variables not set", "author": "atris", "createdAt": "2020-06-30T16:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDczMA=="}], "type": "inlineReview"}, {"oid": "5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "url": "https://github.com/apache/lucene-solr/commit/5bc42f0ddbdf25b721fb806b34dc380e52a241f5", "message": "Moar Stuff", "committedDate": "2020-06-30T17:31:08Z", "type": "forcePushed"}, {"oid": "69594b7c28658a702b5bf2462e568290bec05e61", "url": "https://github.com/apache/lucene-solr/commit/69594b7c28658a702b5bf2462e568290bec05e61", "message": "Moar Stuff", "committedDate": "2020-06-30T17:45:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MzM4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448453381", "bodyText": "I don't think 100 is a safe default here, since later we check that the value is between 50-95.", "author": "madrob", "createdAt": "2020-07-01T15:43:21Z", "path": "solr/core/src/java/org/apache/solr/core/SolrConfig.java", "diffHunk": "@@ -224,6 +224,11 @@ private SolrConfig(SolrResourceLoader loader, String name, boolean isConfigsetTr\n     queryResultWindowSize = Math.max(1, getInt(\"query/queryResultWindowSize\", 1));\n     queryResultMaxDocsCached = getInt(\"query/queryResultMaxDocsCached\", Integer.MAX_VALUE);\n     enableLazyFieldLoading = getBool(\"query/enableLazyFieldLoading\", false);\n+\n+    useCircuitBreakers = getBool(\"circuitBreaker/useCircuitBreakers\", false);\n+    memoryCircuitBreakerThresholdPct = getInt(\"circuitBreaker/memoryCircuitBreakerThresholdPct\", 100);", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5Mzk2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448493962", "bodyText": "Changed to 95.", "author": "atris", "createdAt": "2020-07-01T16:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MzM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NTU3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448455577", "bodyText": "This is a little scary that we sometimes return null here? I think I would prefer an implementation of CBM that knows it is turned off so we don't accidentally get an NPE somewhere else.", "author": "madrob", "createdAt": "2020-07-01T15:46:44Z", "path": "solr/core/src/java/org/apache/solr/core/SolrCore.java", "diffHunk": "@@ -1164,6 +1168,16 @@ private SolrCoreMetricManager initCoreMetricManager(SolrConfig config) {\n     return coreMetricManager;\n   }\n \n+  private CircuitBreakerManager initCircuitBreakerManager() {\n+    if (solrConfig.useCircuitBreakers) {\n+      CircuitBreakerManager circuitBreakerManager = CircuitBreakerManager.build(solrConfig);\n+\n+      return circuitBreakerManager;\n+    }\n+\n+    return null;", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1Nzg5MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448457890", "bodyText": "This is unused? Maybe delete it for now and add it back when somebody comes up with an implementation?", "author": "madrob", "createdAt": "2020-07-01T15:50:27Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ * <p>\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n+ *  2. Use the circuit breaker in a specific code path(s).\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ * </p>\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config.\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if circuit breaker is tripped.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Get debug useful info.\n+   */\n+  public abstract String getDebugInfo();\n+\n+  /**\n+   * Types of circuit breakers.\n+   */\n+  public enum CircuitBreakerType {\n+    MEMORY,\n+    CPU", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1ODM4MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448458380", "bodyText": "Does this need a \"CUSTOM\" type or something else for folks who will be implementing their own?", "author": "madrob", "createdAt": "2020-07-01T15:51:14Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreaker.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Default class to define circuit breakers for Solr.\n+ * <p>\n+ *  There are two (typical) ways to use circuit breakers:\n+ *  1. Have them checked at admission control by default (use CircuitBreakerManager for the same).\n+ *  2. Use the circuit breaker in a specific code path(s).\n+ *\n+ * TODO: This class should be grown as the scope of circuit breakers grow.\n+ * </p>\n+ */\n+public abstract class CircuitBreaker {\n+  public static final String NAME = \"circuitbreaker\";\n+\n+  protected final SolrConfig solrConfig;\n+\n+  public CircuitBreaker(SolrConfig solrConfig) {\n+    this.solrConfig = solrConfig;\n+  }\n+\n+  // Global config for all circuit breakers. For specific circuit breaker configs, define\n+  // your own config.\n+  protected boolean isEnabled() {\n+    return solrConfig.useCircuitBreakers;\n+  }\n+\n+  /**\n+   * Check if circuit breaker is tripped.\n+   */\n+  public abstract boolean isTripped();\n+\n+  /**\n+   * Get debug useful info.\n+   */\n+  public abstract String getDebugInfo();\n+\n+  /**\n+   * Types of circuit breakers.\n+   */\n+  public enum CircuitBreakerType {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NDQ2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448494462", "bodyText": "Preferably, they can add their own type when implementing a new one?", "author": "atris", "createdAt": "2020-07-01T16:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1ODM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTAzNw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459037", "bodyText": "circuitBreakerMap.values()", "author": "madrob", "createdAt": "2020-07-01T15:52:22Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NTM0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448495347", "bodyText": "Need both the key and the value in this loop, so values() wont work?", "author": "atris", "createdAt": "2020-07-01T16:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTcwNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459706", "bodyText": "This doesn't seem right... I can only have one circuit breaker of each type? I can imagine having multiple breakers that all work in conjunction - limit QPS to X, and limit QPM to Y, for example.", "author": "madrob", "createdAt": "2020-07-01T15:53:30Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1OTg2MA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448459860", "bodyText": "Is this needed?", "author": "madrob", "createdAt": "2020-07-01T15:53:46Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDI3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448460273", "bodyText": "do multiple append calls instead of string concat.", "author": "madrob", "createdAt": "2020-07-01T15:54:24Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * Construct the final error message to be printed when circuit breakers trip.\n+   *\n+   * @param circuitBreakerMap Input list for circuit breakers.\n+   * @return Constructed error message.\n+   */\n+  public static String toErrorMessage(Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap) {\n+    assert circuitBreakerMap != null;\n+\n+    StringBuilder sb = new StringBuilder();\n+\n+    for (CircuitBreaker.CircuitBreakerType circuitBreakerType : circuitBreakerMap.keySet()) {\n+      sb.append(circuitBreakerType.toString() + \" \" + circuitBreakerMap.get(circuitBreakerType).getDebugInfo() + \"\\n\");", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDY1MQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448460651", "bodyText": "This method is never used?", "author": "madrob", "createdAt": "2020-07-01T15:54:58Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NTU2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448495565", "bodyText": "Added for sanity.", "author": "atris", "createdAt": "2020-07-01T16:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MTE4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448461185", "bodyText": "This is unused?", "author": "madrob", "createdAt": "2020-07-01T15:55:48Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/CircuitBreakerManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.solr.core.SolrConfig;\n+\n+/**\n+ * Manages all registered circuit breaker instances. Responsible for a holistic view\n+ * of whether a circuit breaker has tripped or not.\n+ *\n+ * There are two typical ways of using this class's instance:\n+ * 1. Check if any circuit breaker has triggered -- and know which circuit breaker has triggered.\n+ * 2. Get an instance of a specific circuit breaker and perform checks.\n+ *\n+ * It is a good practice to register new circuit breakers here if you want them checked for every\n+ * request.\n+ *\n+ * NOTE: The current way of registering new default circuit breakers is minimal and not a long term\n+ * solution. There will be a follow up with a SIP for a schema API design.\n+ */\n+public class CircuitBreakerManager {\n+  private final Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> circuitBreakerMap = new HashMap<>();\n+\n+  // Allows replacing of existing circuit breaker\n+  public void register(CircuitBreaker.CircuitBreakerType circuitBreakerType, CircuitBreaker circuitBreaker) {\n+    circuitBreakerMap.put(circuitBreakerType, circuitBreaker);\n+  }\n+\n+  public CircuitBreaker getCircuitBreaker(CircuitBreaker.CircuitBreakerType circuitBreakerType) {\n+    assert circuitBreakerType != null;\n+\n+    return circuitBreakerMap.get(circuitBreakerType);\n+  }\n+\n+  /**\n+   * Check and return circuit breakers that have triggered\n+   * @return CircuitBreakers which have triggered, null otherwise.\n+   */\n+  public Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> checkTripped() {\n+    Map<CircuitBreaker.CircuitBreakerType, CircuitBreaker> triggeredCircuitBreakers = null;\n+\n+    for (Map.Entry<CircuitBreaker.CircuitBreakerType, CircuitBreaker> entry : circuitBreakerMap.entrySet()) {\n+      CircuitBreaker circuitBreaker = entry.getValue();\n+\n+      if (circuitBreaker.isEnabled() &&\n+          circuitBreaker.isTripped()) {\n+        if (triggeredCircuitBreakers == null) {\n+          triggeredCircuitBreakers = new HashMap<>();\n+        }\n+\n+        triggeredCircuitBreakers.put(entry.getKey(), circuitBreaker);\n+      }\n+    }\n+\n+    return triggeredCircuitBreakers;\n+  }\n+\n+  /**\n+   * Returns true if *any* circuit breaker has triggered, false if none have triggered.\n+   *\n+   * <p>\n+   * NOTE: This method short circuits the checking of circuit breakers -- the method will\n+   * return as soon as it finds a circuit breaker that is enabled and has triggered.\n+   * </p>\n+   */\n+  public boolean checkAnyTripped() {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NTYyOA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448495628", "bodyText": "Added for sanity", "author": "atris", "createdAt": "2020-07-01T16:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MTE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448462009", "bodyText": "Should we store these to local values so that we don't have to call an extra .get() on the concurrent structure? Probably doesn't make a difference.", "author": "madrob", "createdAt": "2020-07-01T15:57:09Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml.\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NjkwMg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448496902", "bodyText": "It would be a two step process -- setting local value and then setting the thread local. Seems cleaner this way? I doubt if it will really cause a performance issue -- the variables are thread local", "author": "atris", "createdAt": "2020-07-01T16:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MDQ4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448550485", "bodyText": "this solution has an extra unboxing.", "author": "madrob", "createdAt": "2020-07-01T18:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MjMxNA==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448462314", "bodyText": "Why are we comparing a long to a floating point?", "author": "madrob", "createdAt": "2020-07-01T15:57:38Z", "path": "solr/core/src/java/org/apache/solr/util/circuitbreaker/MemoryCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.circuitbreaker;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+import org.apache.solr.core.SolrConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * <p>\n+ * Tracks the current JVM heap usage and triggers if it exceeds the defined percentage of the maximum\n+ * heap size allocated to the JVM. This circuit breaker is a part of the default CircuitBreakerManager\n+ * so is checked for every request -- hence it is realtime. Once the memory usage goes below the threshold,\n+ * it will start allowing queries again.\n+ * </p>\n+ *\n+ * <p>\n+ * The memory threshold is defined as a percentage of the maximum memory allocated -- see memoryCircuitBreakerThresholdPct\n+ * in solrconfig.xml.\n+ * </p>\n+ */\n+\n+public class MemoryCircuitBreaker extends CircuitBreaker {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final MemoryMXBean MEMORY_MX_BEAN = ManagementFactory.getMemoryMXBean();\n+\n+  private final long heapMemoryThreshold;\n+\n+  // Assumption -- the value of these parameters will be set correctly before invoking getDebugInfo()\n+  private final ThreadLocal<Long> seenMemory = new ThreadLocal<>();\n+  private final ThreadLocal<Long> allowedMemory = new ThreadLocal<>();\n+\n+  public MemoryCircuitBreaker(SolrConfig solrConfig) {\n+    super(solrConfig);\n+\n+    long currentMaxHeap = MEMORY_MX_BEAN.getHeapMemoryUsage().getMax();\n+\n+    if (currentMaxHeap <= 0) {\n+      throw new IllegalArgumentException(\"Invalid JVM state for the max heap usage\");\n+    }\n+\n+    int thresholdValueInPercentage = solrConfig.memoryCircuitBreakerThresholdPct;\n+    double thresholdInFraction = thresholdValueInPercentage / (double) 100;\n+    heapMemoryThreshold = (long) (currentMaxHeap * thresholdInFraction);\n+\n+    if (heapMemoryThreshold <= 0) {\n+      throw new IllegalStateException(\"Memory limit cannot be less than or equal to zero\");\n+    }\n+  }\n+\n+  // TODO: An optimization can be to trip the circuit breaker for a duration of time\n+  // after the circuit breaker condition is matched. This will optimize for per call\n+  // overhead of calculating the condition parameters but can result in false positives.\n+  @Override\n+  public boolean isTripped() {\n+    if (!isEnabled()) {\n+      return false;\n+    }\n+\n+    allowedMemory.set(getCurrentMemoryThreshold());\n+\n+    seenMemory.set(calculateLiveMemoryUsage());\n+\n+    return (seenMemory.get() >= allowedMemory.get());\n+  }\n+\n+  @Override\n+  public String getDebugInfo() {\n+    if (seenMemory.get() == 0.0 || allowedMemory.get() == 0.0) {", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ4MzEwNg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448483106", "bodyText": "What is this testing? Is this just resetting the circuitbreakermanager? Should be in a Before/After blocks?", "author": "madrob", "createdAt": "2020-07-01T16:32:47Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @Rule\n+  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(adoc(\"id\", \"1\", \"title\", \"this is a title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"2\", \"title\", \"this is another title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"3\", \"title\", \"Mary had a little lamb.\", \"inStock_b1\", \"false\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  public void testCBAlwaysTrips() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new MockCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+\n+    circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+  }\n+\n+  public void testCBFakeMemoryPressure() throws IOException {\n+    HashMap<String, String> args = new HashMap<String, String>();\n+\n+    args.put(QueryParsing.DEFTYPE, CircuitBreaker.NAME);\n+    args.put(CommonParams.FL, \"id\");\n+\n+    CircuitBreaker circuitBreaker = new FakeMemoryPressureCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);\n+\n+    expectThrows(SolrException.class, () -> {\n+      h.query(req(\"name:\\\"john smith\\\"\"));\n+    });\n+\n+    circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(CircuitBreaker.CircuitBreakerType.MEMORY, circuitBreaker);", "originalCommit": "69594b7c28658a702b5bf2462e568290bec05e61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU1MTQwMg==", "url": "https://github.com/apache/lucene-solr/pull/1626#discussion_r448551402", "bodyText": "This appends to the list, doesn't do any clearing. By the last test you'll have three of the same circuit breakers running.", "author": "madrob", "createdAt": "2020-07-01T18:44:33Z", "path": "solr/core/src/test/org/apache/solr/util/TestCircuitBreaker.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util;\n+\n+import java.util.HashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.params.CommonParams;\n+import org.apache.solr.common.util.ExecutorUtil;\n+import org.apache.solr.common.util.SolrNamedThreadFactory;\n+import org.apache.solr.core.SolrConfig;\n+import org.apache.solr.search.QueryParsing;\n+import org.apache.solr.util.circuitbreaker.CircuitBreaker;\n+import org.apache.solr.util.circuitbreaker.MemoryCircuitBreaker;\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+\n+public class TestCircuitBreaker extends SolrTestCaseJ4 {\n+  private final static int NUM_DOCS = 20;\n+\n+  @Rule\n+  public TestRule solrTestRules = RuleChain.outerRule(new SystemPropertiesRestoreRule());\n+\n+  @BeforeClass\n+  public static void setUpClass() throws Exception {\n+    System.setProperty(\"filterCache.enabled\", \"false\");\n+    System.setProperty(\"queryResultCache.enabled\", \"false\");\n+    System.setProperty(\"documentCache.enabled\", \"true\");\n+\n+    initCore(\"solrconfig-memory-circuitbreaker.xml\", \"schema.xml\");\n+    for (int i = 0 ; i < NUM_DOCS ; i ++) {\n+      assertU(adoc(\"name\", \"john smith\", \"id\", \"1\"));\n+      assertU(adoc(\"name\", \"johathon smith\", \"id\", \"2\"));\n+      assertU(adoc(\"name\", \"john percival smith\", \"id\", \"3\"));\n+      assertU(adoc(\"id\", \"1\", \"title\", \"this is a title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"2\", \"title\", \"this is another title.\", \"inStock_b1\", \"true\"));\n+      assertU(adoc(\"id\", \"3\", \"title\", \"Mary had a little lamb.\", \"inStock_b1\", \"false\"));\n+\n+      //commit inside the loop to get multiple segments to make search as realistic as possible\n+      assertU(commit());\n+    }\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    super.tearDown();\n+  }\n+\n+  @After\n+  public void after() {\n+    CircuitBreaker circuitBreaker = new MemoryCircuitBreaker(h.getCore().getSolrConfig());\n+\n+    h.getCore().getCircuitBreakerManager().register(circuitBreaker);", "originalCommit": "3dbfc0b02afb925d7abd3da00a309cf8c723a1e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "413b4b98172d453cfc9bdc78c2802d7879031983", "url": "https://github.com/apache/lucene-solr/commit/413b4b98172d453cfc9bdc78c2802d7879031983", "message": "SOLR-14588: Implement Circuit Breakers\n\nThis commit consists of two parts: add circuit breakers infrastructure and a \"real\" JVM heap memory based\ncircuit breaker which monitors incoming search requests and rejects them with SERVICE_TOO_BUSY error\nif the defined threshold is breached, thus giving headroom to existing indexing and search requests\nto complete.", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "d02a6e2f7f87757c2e6016fa97c0b2544e6facb4", "url": "https://github.com/apache/lucene-solr/commit/d02a6e2f7f87757c2e6016fa97c0b2544e6facb4", "message": "Update test parameter", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "64448f0a8b068712e584d898073e3d912dcfe1ec", "url": "https://github.com/apache/lucene-solr/commit/64448f0a8b068712e584d898073e3d912dcfe1ec", "message": "More Updates", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "65751ee38aa0da73bc99b697500b31bbc3e5b6e8", "url": "https://github.com/apache/lucene-solr/commit/65751ee38aa0da73bc99b697500b31bbc3e5b6e8", "message": "Renamings", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "e2a19278643409558709d582638e20c4832d78e1", "url": "https://github.com/apache/lucene-solr/commit/e2a19278643409558709d582638e20c4832d78e1", "message": "Updated per comments", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "3fa18af58be636fce922a68c9de0ea2cbfe198b9", "url": "https://github.com/apache/lucene-solr/commit/3fa18af58be636fce922a68c9de0ea2cbfe198b9", "message": "Add remaining formatting", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "de529ed55a44941f5448fd5c30733645add0acd7", "url": "https://github.com/apache/lucene-solr/commit/de529ed55a44941f5448fd5c30733645add0acd7", "message": "Moar Stuff", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "64722f96b1ba5890763a467eacb6acb1ffd94328", "url": "https://github.com/apache/lucene-solr/commit/64722f96b1ba5890763a467eacb6acb1ffd94328", "message": "More comments", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "1045e161ae9e2d0aeb68aea517cce883dbaf231a", "url": "https://github.com/apache/lucene-solr/commit/1045e161ae9e2d0aeb68aea517cce883dbaf231a", "message": "Brain Fart", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "5099095fe532ad46db8c01029ef42fb8d6113010", "url": "https://github.com/apache/lucene-solr/commit/5099095fe532ad46db8c01029ef42fb8d6113010", "message": "Fix precommit", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "url": "https://github.com/apache/lucene-solr/commit/8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "message": "Updating per comments", "committedDate": "2020-07-02T06:54:50Z", "type": "commit"}, {"oid": "8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "url": "https://github.com/apache/lucene-solr/commit/8133ecbdc0f20fd37f52e7acc716b3f1abe2dcae", "message": "Updating per comments", "committedDate": "2020-07-02T06:54:50Z", "type": "forcePushed"}]}