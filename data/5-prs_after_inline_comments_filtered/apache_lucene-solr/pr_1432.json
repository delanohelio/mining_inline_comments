{"pr_number": 1432, "pr_title": "SOLR-14404 CoreContainer level custom requesthandlers", "pr_createdAt": "2020-04-14T13:32:29Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1432", "timeline": [{"oid": "87a57bc680352018da29a6698bda53d7f3f71c82", "url": "https://github.com/apache/lucene-solr/commit/87a57bc680352018da29a6698bda53d7f3f71c82", "message": "initial commit", "committedDate": "2020-04-13T00:06:19Z", "type": "commit"}, {"oid": "e9500d2a61647af86b85369d78c5c1b589c38de5", "url": "https://github.com/apache/lucene-solr/commit/e9500d2a61647af86b85369d78c5c1b589c38de5", "message": "Added a few tests . Still WIP", "committedDate": "2020-04-13T18:04:29Z", "type": "commit"}, {"oid": "2a172f5ec68e648d5b0b15d66f4f07bdd011b14d", "url": "https://github.com/apache/lucene-solr/commit/2a172f5ec68e648d5b0b15d66f4f07bdd011b14d", "message": "Added more tests . Still WIP", "committedDate": "2020-04-14T01:42:02Z", "type": "commit"}, {"oid": "288a261c43d6373aec89630b1388a8a4d3f51943", "url": "https://github.com/apache/lucene-solr/commit/288a261c43d6373aec89630b1388a8a4d3f51943", "message": "Added more tests . Still WIP", "committedDate": "2020-04-14T07:16:59Z", "type": "commit"}, {"oid": "453911ed39b3b9301c738b29654cb7b96b01dff2", "url": "https://github.com/apache/lucene-solr/commit/453911ed39b3b9301c738b29654cb7b96b01dff2", "message": "Added more tests. Ready for review", "committedDate": "2020-04-14T13:27:40Z", "type": "commit"}, {"oid": "e1118c707c6a973a26b21dc47cd99ae30a967b6a", "url": "https://github.com/apache/lucene-solr/commit/e1118c707c6a973a26b21dc47cd99ae30a967b6a", "message": "Some more refatoring", "committedDate": "2020-04-15T03:33:55Z", "type": "commit"}, {"oid": "82bcd38bb851274c0b2fba85190f29b46400640f", "url": "https://github.com/apache/lucene-solr/commit/82bcd38bb851274c0b2fba85190f29b46400640f", "message": "Some more refatoring", "committedDate": "2020-04-15T07:03:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3NjI2NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409676264", "bodyText": "Should this be synchronized to match register?", "author": "madrob", "createdAt": "2020-04-16T16:07:58Z", "path": "solr/core/src/java/org/apache/solr/api/ApiBag.java", "diffHunk": "@@ -134,6 +142,14 @@ static void registerIntrospect(List<String> l, PathTrie<Api> registry, Map<Strin\n     registry.insert(copy, substitutes, introspect);\n   }\n \n+  public Api unregister(SolrRequest.METHOD method, String path) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4MDAyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409680029", "bodyText": "Should this be METHOD.DELETE instead of a post?", "author": "madrob", "createdAt": "2020-04-16T16:13:33Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler.admin;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.solr.api.AnnotatedApi;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.CustomContainerPlugins;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.api.PayloadObj;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.cloud.SolrZkClient;\n+import org.apache.solr.common.cloud.ZkStateReader;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+\n+public class ContainerPluginsApi {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String PLUGIN = \"plugin\";\n+  private final Supplier<SolrZkClient> zkClientSupplier;\n+  private final CoreContainer coreContainer;\n+  public final Read readAPI = new Read();\n+  public final Edit editAPI = new Edit();\n+\n+  public ContainerPluginsApi(CoreContainer coreContainer) {\n+    this.zkClientSupplier = coreContainer.zkClientSupplier;\n+    this.coreContainer = coreContainer;\n+  }\n+\n+  @EndPoint(method = METHOD.GET,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public class Read {\n+\n+    @Command\n+    public void list(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n+      rsp.add(PLUGIN, plugins(zkClientSupplier));\n+    }\n+  }\n+\n+  @EndPoint(method = METHOD.POST,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_EDIT_PERM)\n+  public class Edit {\n+\n+    @Command(name = \"add\")\n+    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta> payload) throws IOException {\n+      PluginMeta info = payload.get();\n+      validateConfig(payload, info);\n+      if(payload.hasError()) return;\n+      persistPlugins(map -> {\n+        if (map.containsKey(info.name)) {\n+          payload.addError(info.name + \" already exists\");\n+          return null;\n+        }\n+        map.put(info.name, info);\n+        return map;\n+      });\n+    }\n+\n+    @Command(name = \"remove\")\n+    public void remove(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<String> payload) throws IOException {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE0ODExMw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412148113", "bodyText": "We could, but , this is the convention that we follow", "author": "noblepaul", "createdAt": "2020-04-21T12:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4MDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409684159", "bodyText": "Why do we need this check? setCore already handles nulls.", "author": "madrob", "createdAt": "2020-04-16T16:19:38Z", "path": "solr/core/src/java/org/apache/solr/pkg/PackageListeners.java", "diffHunk": "@@ -63,13 +63,13 @@ public synchronized void removeListener(Listener listener) {\n   }\n \n   synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n-    MDCLoggingContext.setCore(core);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE0OTgyMA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412149820", "bodyText": "because we are calling a\nMDCLoggingContext.clear(); in finally", "author": "noblepaul", "createdAt": "2020-04-21T12:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MDY3OA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412490678", "bodyText": "I was under the impression that it setCore/clear still work even if the core was null.", "author": "madrob", "createdAt": "2020-04-21T21:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzNzQwNA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426237404", "bodyText": "OK, got it. I misunderstood the comment", "author": "noblepaul", "createdAt": "2020-05-17T09:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NzU2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409687566", "bodyText": "I assume this is used to generate containerplugin.v.1.jar.bin and v.2? Should we have two source files for those? Can we do this some other way, besides checking in binaries to the repo?", "author": "madrob", "createdAt": "2020-04-16T16:24:42Z", "path": "solr/core/src/test-files/runtimecode/MyPlugin.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+\n+@EndPoint(path = \"/plugin/my/path\",\n+    method = METHOD.GET,\n+    permission = PermissionNameProvider.Name.CONFIG_READ_PERM)\n+public class MyPlugin {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MTYwNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412151606", "bodyText": "This is for documentation purposes for anyone who wants to know what the code looks like. Yes, we could possibly have 2 files, but then , they will have to be different files and the class name can't match the file name\n\nCan we do this some other way,\n\nUnfortunately it's so hard. We need to ensure that these classes are never in the classpath. If we try to compile it some other way, it may come under the classpath and the purpose of the test is defeated. I'm not saying it is not possible, but it is not easy", "author": "noblepaul", "createdAt": "2020-04-21T12:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NzU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4ODU2OA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409688568", "bodyText": "use expectThrows here.", "author": "madrob", "createdAt": "2020-04-16T16:26:08Z", "path": "solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrClient;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;\n+import org.apache.solr.client.solrj.request.V2Request;\n+import org.apache.solr.client.solrj.request.beans.Package;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.client.solrj.response.V2Response;\n+import org.apache.solr.cloud.MiniSolrCloudCluster;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.NavigableObject;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.filestore.PackageStoreAPI;\n+import org.apache.solr.filestore.TestDistribPackageStore;\n+import org.apache.solr.pkg.TestPackages;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n+import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n+import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+public class TestContainerPlugin extends SolrCloudTestCase {\n+\n+  @Before\n+  public void setup() {\n+    System.setProperty(\"enable.packages\", \"true\");\n+  }\n+\n+  @After\n+  public void teardown() {\n+    System.clearProperty(\"enable.packages\");\n+  }\n+\n+  @Test\n+  public void testApi() throws Exception {\n+    MiniSolrCloudCluster cluster =\n+        configureCluster(4)\n+            .withJettyConfig(jetty -> jetty.enableV2(true))\n+            .configure();\n+    String errPath = \"/error/details[0]/errorMessages[0]\";\n+    try {\n+      PluginMeta plugin = new PluginMeta();\n+      plugin.name = \"testplugin\";\n+      plugin.klass = C2.class.getName();\n+      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", plugin))\n+          .build();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n+\n+      plugin.klass = C1.class.getName();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Invalid class, no @EndPoint annotation\");\n+\n+      plugin.klass = C3.class.getName();\n+      req.process(cluster.getSolrClient());\n+\n+      V2Response rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/testkey\", \"testval\"));\n+\n+      new V2Request.Builder(\"/cluster/plugin\")\n+          .withMethod(POST)\n+          .forceV2(true)\n+          .withPayload(\"{remove : testplugin}\")\n+          .build()\n+          .process(cluster.getSolrClient());\n+\n+      rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n+\n+    } finally {\n+      cluster.shutdown();\n+    }\n+  }\n+  @Test\n+  public void testApiFromPackage() throws Exception {\n+    MiniSolrCloudCluster cluster =\n+        configureCluster(4)\n+            .withJettyConfig(jetty -> jetty.enableV2(true))\n+            .configure();\n+    String FILE1 = \"/myplugin/v1.jar\";\n+    String FILE2 = \"/myplugin/v2.jar\";\n+\n+    String errPath = \"/error/details[0]/errorMessages[0]\";\n+    try {\n+      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n+      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n+      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.1.jar.bin\", FILE1,\n+          \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n+     TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n+          \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n+\n+      Package.AddVersion add = new Package.AddVersion();\n+      add.version = \"1.0\";\n+      add.pkg = \"mypkg\";\n+      add.files = List.of(FILE1);\n+      V2Request addPkgVersionReq = new V2Request.Builder(\"/cluster/package\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", add))\n+          .build();\n+      addPkgVersionReq.process(cluster.getSolrClient());\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/cluster/package\").\n+              withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          Utils.makeMap(\n+              \":result:packages:mypkg[0]:version\", \"1.0\",\n+              \":result:packages:mypkg[0]:files[0]\", FILE1\n+          ));\n+\n+      PluginMeta plugin = new PluginMeta();\n+      plugin.name = \"myplugin\";\n+      plugin.klass = \"mypkg:org.apache.solr.handler.MyPlugin\";\n+      plugin.version = add.version;\n+      V2Request req1 = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", plugin))\n+          .build();\n+      req1.process(cluster.getSolrClient());\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/cluster/plugin\").\n+              withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\n+              \"/plugin/myplugin/class\", plugin.klass,\n+              \"/plugin/myplugin/version\", plugin.version\n+          ));\n+      Callable<NavigableObject> invokePlugin = () -> new V2Request.Builder(\"/plugin/my/path\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build().process(cluster.getSolrClient());\n+      TestDistribPackageStore.assertResponseValues(10,\n+          invokePlugin,\n+          ImmutableMap.of(\"/myplugin.version\", \"1.0\"));\n+\n+      add.version = \"2.0\";\n+      add.files = List.of(FILE2);\n+      addPkgVersionReq.process(cluster.getSolrClient());\n+\n+      plugin.version = add.version;\n+      new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"update\", plugin))\n+          .build()\n+      .process(cluster.getSolrClient());\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/cluster/plugin\").\n+              withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\n+              \"/plugin/myplugin/class\", plugin.klass,\n+              \"/plugin/myplugin/version\", \"2.0\"\n+          ));\n+      TestDistribPackageStore.assertResponseValues(10,\n+          invokePlugin,\n+          ImmutableMap.of(\"/myplugin.version\", \"2.0\"));\n+    } finally {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  public static class C1 {\n+\n+  }\n+\n+  @EndPoint(\n+      method = GET,\n+      path = \"/plugin/my/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public class C2 {\n+\n+\n+  }\n+\n+  @EndPoint(\n+      method = GET,\n+      path = \"/plugin/my/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public static class C3 {\n+    @Command\n+    public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      rsp.add(\"testkey\", \"testval\");\n+    }\n+\n+  }\n+\n+\n+  private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n+    try {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNDYxNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426434616", "bodyText": "expectThrows does not work here", "author": "noblepaul", "createdAt": "2020-05-18T07:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4ODU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2MjY4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443962681", "bodyText": "fixed", "author": "noblepaul", "createdAt": "2020-06-23T05:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4ODU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4OTQ0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409689441", "bodyText": "cluster setup and teardown can go in Before/After methods", "author": "madrob", "createdAt": "2020-04-16T16:27:30Z", "path": "solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrClient;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;\n+import org.apache.solr.client.solrj.request.V2Request;\n+import org.apache.solr.client.solrj.request.beans.Package;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.client.solrj.response.V2Response;\n+import org.apache.solr.cloud.MiniSolrCloudCluster;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.NavigableObject;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.filestore.PackageStoreAPI;\n+import org.apache.solr.filestore.TestDistribPackageStore;\n+import org.apache.solr.pkg.TestPackages;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n+import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n+import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+public class TestContainerPlugin extends SolrCloudTestCase {\n+\n+  @Before\n+  public void setup() {\n+    System.setProperty(\"enable.packages\", \"true\");\n+  }\n+\n+  @After\n+  public void teardown() {\n+    System.clearProperty(\"enable.packages\");\n+  }\n+\n+  @Test\n+  public void testApi() throws Exception {\n+    MiniSolrCloudCluster cluster =", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTY5Mg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426209692", "bodyText": "These clusters are created on a per testcase basis. We don't want remnants of other tests to screw up other tests", "author": "noblepaul", "createdAt": "2020-05-17T02:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4OTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MDg5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409690893", "bodyText": "unclear what this test is testing", "author": "madrob", "createdAt": "2020-04-16T16:29:41Z", "path": "solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java", "diffHunk": "@@ -199,6 +200,25 @@ public void testPayload() {\n \n   }\n \n+  public void testApiWrapper() {\n+    Class<ApiWithConstructor> klas = ApiWithConstructor.class;", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MjE2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426452163", "bodyText": "it got in there accidentally , removed", "author": "noblepaul", "createdAt": "2020-05-18T08:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MDg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MTkyNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409691926", "bodyText": "There's already a null check later, what kinds of messages do we get here that are useful and don't leak too much internals?", "author": "madrob", "createdAt": "2020-04-16T16:31:24Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java", "diffHunk": "@@ -62,6 +63,9 @@ public static RemoteExecutionException create(String host, NamedList errResponse\n       if (errObj != null) {\n         Number code = (Number) getObjectByPath(errObj, true, Collections.singletonList(\"code\"));\n         String msg = (String) getObjectByPath(errObj, true, Collections.singletonList(\"msg\"));\n+        if(msg == null) msg = \"\";", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MzMyMA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409693320", "bodyText": "this is a fairly long test and was somewhat hard to follow, can we break it up into smaller pieces?", "author": "madrob", "createdAt": "2020-04-16T16:33:30Z", "path": "solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrClient;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;\n+import org.apache.solr.client.solrj.request.V2Request;\n+import org.apache.solr.client.solrj.request.beans.Package;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.client.solrj.response.V2Response;\n+import org.apache.solr.cloud.MiniSolrCloudCluster;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.NavigableObject;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.filestore.PackageStoreAPI;\n+import org.apache.solr.filestore.TestDistribPackageStore;\n+import org.apache.solr.pkg.TestPackages;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n+import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n+import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+public class TestContainerPlugin extends SolrCloudTestCase {\n+\n+  @Before\n+  public void setup() {\n+    System.setProperty(\"enable.packages\", \"true\");\n+  }\n+\n+  @After\n+  public void teardown() {\n+    System.clearProperty(\"enable.packages\");\n+  }\n+\n+  @Test\n+  public void testApi() throws Exception {\n+    MiniSolrCloudCluster cluster =\n+        configureCluster(4)\n+            .withJettyConfig(jetty -> jetty.enableV2(true))\n+            .configure();\n+    String errPath = \"/error/details[0]/errorMessages[0]\";\n+    try {\n+      PluginMeta plugin = new PluginMeta();\n+      plugin.name = \"testplugin\";\n+      plugin.klass = C2.class.getName();\n+      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", plugin))\n+          .build();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n+\n+      plugin.klass = C1.class.getName();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Invalid class, no @EndPoint annotation\");\n+\n+      plugin.klass = C3.class.getName();\n+      req.process(cluster.getSolrClient());\n+\n+      V2Response rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/testkey\", \"testval\"));\n+\n+      new V2Request.Builder(\"/cluster/plugin\")\n+          .withMethod(POST)\n+          .forceV2(true)\n+          .withPayload(\"{remove : testplugin}\")\n+          .build()\n+          .process(cluster.getSolrClient());\n+\n+      rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n+\n+    } finally {\n+      cluster.shutdown();\n+    }\n+  }\n+  @Test\n+  public void testApiFromPackage() throws Exception {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzNzU3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426237573", "bodyText": "Splitting these tests will create another cluster and slow down the test execution further. I shall try to add inline comments to make it more clear as to what it is doing", "author": "noblepaul", "createdAt": "2020-05-17T09:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MzMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5NDYwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409694609", "bodyText": "There's a minor inconsistency here between edit/read and write/read, maybe we can standardize on one?", "author": "madrob", "createdAt": "2020-04-16T16:35:37Z", "path": "solr/core/src/java/org/apache/solr/core/CoreContainer.java", "diffHunk": "@@ -648,8 +655,8 @@ public void load() {\n       pkiAuthenticationPlugin.initializeMetrics(solrMetricsContext, \"/authentication/pki\");\n       TracerConfigurator.loadTracer(loader, cfg.getTracerConfiguratorPluginInfo(), getZkController().getZkStateReader());\n       packageLoader = new PackageLoader(this);\n-      containerHandlers.getApiBag().register(new AnnotatedApi(packageLoader.getPackageAPI().editAPI), Collections.EMPTY_MAP);\n-      containerHandlers.getApiBag().register(new AnnotatedApi(packageLoader.getPackageAPI().readAPI), Collections.EMPTY_MAP);\n+      containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().editAPI);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzM4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412493389", "bodyText": "prefer Collections.emptyMap()", "author": "madrob", "createdAt": "2020-04-21T21:09:39Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzQxNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412493416", "bodyText": "This parameter is unused?", "author": "madrob", "createdAt": "2020-04-21T21:09:42Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTIwMw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412495203", "bodyText": "This feels like a super klunky API writing errors to a string in a constructor argument? Why can't we just throw exceptions here?", "author": "madrob", "createdAt": "2020-04-21T21:12:34Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+        }\n+      } else {\n+        ApiHolder old = plugins.get(apiInfo.key);\n+        if (path.equals(apiInfo.key)) {\n+          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n+            //this plugin uses the same version. No need to update\n+            continue;\n+          }\n+          //this apiInfo existed at the same path but uses a newer version of the package\n+          //refresh the existing Api holder\n+          try {\n+            apiInfo.init();\n+          } catch (Exception exception) {\n+            log.error(\"COuld not inititlaize Plugin\", exception);\n+          }\n+          plugins.get(apiInfo.key).refresh(apiInfo);\n+        } else {// the path is changed for the same apiInfo. it's not allowed\n+          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n+        }\n+      }\n+    }\n+    Set<String> toBeRemoved = new HashSet<>();\n+    for (String s : pluginNameVsPath.keySet()) {\n+      if (!pluginInfos.containsKey(s)) {\n+        toBeRemoved.add(s);\n+      }\n+    }\n+    for (String s : toBeRemoved) {\n+      String pathKey = pluginNameVsPath.remove(s);\n+      ApiHolder holder = plugins.remove(pathKey);\n+      if (holder != null) {\n+        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n+        if (old instanceof Closeable) {\n+          closeWhileHandlingException((Closeable) old);\n+        }\n+\n+      }\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {\n+    private final String key;\n+    private ApiInfo apiInfo;\n+\n+    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n+      super(apiInfo.delegate);\n+      this.apiInfo = apiInfo;\n+      this.key = apiInfo.key;\n+    }\n+\n+    @Override\n+    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      apiInfo.delegate.call(req, rsp);\n+    }\n+\n+    void refresh(ApiInfo info) {\n+      this.apiInfo = info;\n+      super.spec = info.delegate;\n+    }\n+  }\n+\n+  public class ApiInfo implements ReflectMapWriter  {\n+    /*This is the path at which this handler is\n+     *\n+     */\n+    @JsonProperty\n+    public String key;\n+    @JsonProperty\n+    private final PluginMeta info;\n+\n+    @JsonProperty(value = \"package\")\n+    public final String pkg;\n+    private PackageLoader.Package.Version pkgVersion;\n+    EndPoint endPoint;\n+\n+    private Class klas;\n+\n+\n+    private AnnotatedApi delegate;\n+\n+\n+    public ApiInfo(PluginMeta info, List<String> errs) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTYxMA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426209610", "bodyText": "The objective is to collect multiple errors and eventually throw one single Exception whihc contains all of them", "author": "noblepaul", "createdAt": "2020-05-17T02:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTI5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412495299", "bodyText": "nit: raw types", "author": "madrob", "createdAt": "2020-04-21T21:12:45Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+        }\n+      } else {\n+        ApiHolder old = plugins.get(apiInfo.key);\n+        if (path.equals(apiInfo.key)) {\n+          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n+            //this plugin uses the same version. No need to update\n+            continue;\n+          }\n+          //this apiInfo existed at the same path but uses a newer version of the package\n+          //refresh the existing Api holder\n+          try {\n+            apiInfo.init();\n+          } catch (Exception exception) {\n+            log.error(\"COuld not inititlaize Plugin\", exception);\n+          }\n+          plugins.get(apiInfo.key).refresh(apiInfo);\n+        } else {// the path is changed for the same apiInfo. it's not allowed\n+          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n+        }\n+      }\n+    }\n+    Set<String> toBeRemoved = new HashSet<>();\n+    for (String s : pluginNameVsPath.keySet()) {\n+      if (!pluginInfos.containsKey(s)) {\n+        toBeRemoved.add(s);\n+      }\n+    }\n+    for (String s : toBeRemoved) {\n+      String pathKey = pluginNameVsPath.remove(s);\n+      ApiHolder holder = plugins.remove(pathKey);\n+      if (holder != null) {\n+        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n+        if (old instanceof Closeable) {\n+          closeWhileHandlingException((Closeable) old);\n+        }\n+\n+      }\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {\n+    private final String key;\n+    private ApiInfo apiInfo;\n+\n+    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n+      super(apiInfo.delegate);\n+      this.apiInfo = apiInfo;\n+      this.key = apiInfo.key;\n+    }\n+\n+    @Override\n+    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      apiInfo.delegate.call(req, rsp);\n+    }\n+\n+    void refresh(ApiInfo info) {\n+      this.apiInfo = info;\n+      super.spec = info.delegate;\n+    }\n+  }\n+\n+  public class ApiInfo implements ReflectMapWriter  {\n+    /*This is the path at which this handler is\n+     *\n+     */\n+    @JsonProperty\n+    public String key;\n+    @JsonProperty\n+    private final PluginMeta info;\n+\n+    @JsonProperty(value = \"package\")\n+    public final String pkg;\n+    private PackageLoader.Package.Version pkgVersion;\n+    EndPoint endPoint;\n+\n+    private Class klas;", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTgzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412495835", "bodyText": "should this have a continue?", "author": "madrob", "createdAt": "2020-04-21T21:13:36Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjI2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r433002266", "bodyText": "fixed", "author": "noblepaul", "createdAt": "2020-06-01T00:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjE3MA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412496170", "bodyText": "refresh(properties)?", "author": "madrob", "createdAt": "2020-04-21T21:14:09Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjIxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r433002219", "bodyText": "cleaned up", "author": "noblepaul", "createdAt": "2020-06-01T00:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5ODMwMw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412498303", "bodyText": "why do we need to iterate twice here?", "author": "madrob", "createdAt": "2020-04-21T21:17:57Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+        }\n+      } else {\n+        ApiHolder old = plugins.get(apiInfo.key);\n+        if (path.equals(apiInfo.key)) {\n+          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n+            //this plugin uses the same version. No need to update\n+            continue;\n+          }\n+          //this apiInfo existed at the same path but uses a newer version of the package\n+          //refresh the existing Api holder\n+          try {\n+            apiInfo.init();\n+          } catch (Exception exception) {\n+            log.error(\"COuld not inititlaize Plugin\", exception);\n+          }\n+          plugins.get(apiInfo.key).refresh(apiInfo);\n+        } else {// the path is changed for the same apiInfo. it's not allowed\n+          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n+        }\n+      }\n+    }\n+    Set<String> toBeRemoved = new HashSet<>();\n+    for (String s : pluginNameVsPath.keySet()) {\n+      if (!pluginInfos.containsKey(s)) {\n+        toBeRemoved.add(s);\n+      }\n+    }\n+    for (String s : toBeRemoved) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5ODY2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412498666", "bodyText": "there's a lot of nested classes here, can any of those be split out into their own files?", "author": "madrob", "createdAt": "2020-04-21T21:18:35Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5OTYwNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412499606", "bodyText": "nit: raw types on Map", "author": "madrob", "createdAt": "2020-04-21T21:20:11Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler.admin;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.solr.api.AnnotatedApi;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.CustomContainerPlugins;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.api.PayloadObj;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.cloud.SolrZkClient;\n+import org.apache.solr.common.cloud.ZkStateReader;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+\n+public class ContainerPluginsApi {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String PLUGIN = \"plugin\";\n+  private final Supplier<SolrZkClient> zkClientSupplier;\n+  private final CoreContainer coreContainer;\n+  public final Read readAPI = new Read();\n+  public final Edit editAPI = new Edit();\n+\n+  public ContainerPluginsApi(CoreContainer coreContainer) {\n+    this.zkClientSupplier = coreContainer.zkClientSupplier;\n+    this.coreContainer = coreContainer;\n+  }\n+\n+  @EndPoint(method = METHOD.GET,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public class Read {\n+\n+    @Command\n+    public void list(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n+      rsp.add(PLUGIN, plugins(zkClientSupplier));\n+    }\n+  }\n+\n+  @EndPoint(method = METHOD.POST,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_EDIT_PERM)\n+  public class Edit {\n+\n+    @Command(name = \"add\")\n+    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta> payload) throws IOException {\n+      PluginMeta info = payload.get();\n+      validateConfig(payload, info);\n+      if(payload.hasError()) return;\n+      persistPlugins(map -> {\n+        if (map.containsKey(info.name)) {\n+          payload.addError(info.name + \" already exists\");\n+          return null;\n+        }\n+        map.put(info.name, info);\n+        return map;\n+      });\n+    }\n+\n+    @Command(name = \"remove\")\n+    public void remove(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<String> payload) throws IOException {\n+      persistPlugins(map -> {\n+        if (map.remove(payload.get()) == null) {\n+          payload.addError(\"No such plugin: \" + payload.get());\n+          return null;\n+        }\n+        return map;\n+      });\n+    }\n+\n+    @Command(name = \"update\")\n+    public void update(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta> payload) throws IOException {\n+      PluginMeta info = payload.get();\n+      validateConfig(payload, info);\n+      if(payload.hasError()) return;\n+      persistPlugins(map -> {\n+        Map existing = (Map) map.get(info.name);\n+        if (existing == null) {\n+          payload.addError(\"No such plugin: \" + info.name);\n+          return null;\n+        } else {\n+          map.put(info.name, info);\n+          return map;\n+        }\n+      });\n+    }\n+  }\n+\n+  private void validateConfig(PayloadObj<PluginMeta> payload, PluginMeta info) {\n+    if (info.klass.indexOf(':') > 0) {\n+      if (info.version == null) {\n+        payload.addError(\"Using package. must provide a packageVersion\");\n+        return;\n+      }\n+    }\n+    List<String> errs = new ArrayList<>();\n+    CustomContainerPlugins.ApiInfo apiInfo = coreContainer.getCustomContainerPlugins().createInfo(info, errs);\n+    if (!errs.isEmpty()) {\n+      for (String err : errs) payload.addError(err);\n+      return;\n+    }\n+    AnnotatedApi api = null ;\n+    try {\n+      api =  apiInfo.init();\n+    } catch (Exception e) {\n+      log.error(\"Error instantiating plugin \", e);\n+      errs.add(e.getMessage());\n+      return;\n+    } finally {\n+      closeWhileHandlingException(api);\n+    }\n+  }\n+\n+  public static Map<String, Object> plugins(Supplier<SolrZkClient> zkClientSupplier) throws IOException {\n+    SolrZkClient zkClient = zkClientSupplier.get();\n+    try {\n+      Map<String, Object> clusterPropsJson = (Map<String, Object>) Utils.fromJSON(zkClient.getData(ZkStateReader.CLUSTER_PROPS, null, new Stat(), true));\n+      return (Map<String, Object>) clusterPropsJson.computeIfAbsent(PLUGIN, Utils.NEW_LINKED_HASHMAP_FUN);\n+    } catch (KeeperException.NoNodeException e) {\n+      return new LinkedHashMap<>();\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Error reading cluster property\", SolrZkClient.checkInterrupted(e));\n+    }\n+  }\n+\n+  private void persistPlugins(Function<Map, Map> modifier) throws IOException {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f051b497f549762a727ce4b1248a0fc5fa513d24", "url": "https://github.com/apache/lucene-solr/commit/f051b497f549762a727ce4b1248a0fc5fa513d24", "message": "resolving conflicts and incorporating some review comments", "committedDate": "2020-05-18T01:32:20Z", "type": "commit"}, {"oid": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "url": "https://github.com/apache/lucene-solr/commit/c28707df2d3611ac5e425c2848997b3b034ea1b0", "message": "Added support for multiple @EndPoint per plugin and tests", "committedDate": "2020-05-18T08:49:36Z", "type": "commit"}, {"oid": "c53c4a1a83963e6c9275e2dcae732274b4fb5c2c", "url": "https://github.com/apache/lucene-solr/commit/c53c4a1a83963e6c9275e2dcae732274b4fb5c2c", "message": "Merge branch 'master' into jira/solr14404", "committedDate": "2020-05-18T08:54:56Z", "type": "commit"}, {"oid": "7f010d4c4f0196b4e0aff3562c1bb9ff3f2aebff", "url": "https://github.com/apache/lucene-solr/commit/7f010d4c4f0196b4e0aff3562c1bb9ff3f2aebff", "message": "removed unused imports", "committedDate": "2020-06-01T00:37:20Z", "type": "commit"}, {"oid": "4818edf01bae0b50c48a0e48bd3170eccb43e828", "url": "https://github.com/apache/lucene-solr/commit/4818edf01bae0b50c48a0e48bd3170eccb43e828", "message": "support any path other than collection, cores, cluster, node", "committedDate": "2020-06-01T04:33:31Z", "type": "commit"}, {"oid": "a0b81a57822cb232c434d20ef6764d7e00871629", "url": "https://github.com/apache/lucene-solr/commit/a0b81a57822cb232c434d20ef6764d7e00871629", "message": "moved the custom plugin detection to the end", "committedDate": "2020-06-09T23:57:52Z", "type": "commit"}, {"oid": "e5f2651a59283d8ba5127c86c3fc988bea014665", "url": "https://github.com/apache/lucene-solr/commit/e5f2651a59283d8ba5127c86c3fc988bea014665", "message": "merged changes from master", "committedDate": "2020-06-10T00:01:22Z", "type": "commit"}, {"oid": "bec449cc4da5cb9343cbb936c7bf8d2ec8a382a7", "url": "https://github.com/apache/lucene-solr/commit/bec449cc4da5cb9343cbb936c7bf8d2ec8a382a7", "message": "Merge branch 'master' into jira/solr14404", "committedDate": "2020-06-10T01:24:22Z", "type": "commit"}, {"oid": "e26789532073430cca6a8a89c66a78b866cce2d4", "url": "https://github.com/apache/lucene-solr/commit/e26789532073430cca6a8a89c66a78b866cce2d4", "message": "merging with master", "committedDate": "2020-06-10T01:45:29Z", "type": "commit"}, {"oid": "35c057fdd1ba4154c4c453250ef59766473e3d96", "url": "https://github.com/apache/lucene-solr/commit/35c057fdd1ba4154c4c453250ef59766473e3d96", "message": "Merge branch 'master' into jira/solr14404", "committedDate": "2020-06-21T00:59:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NDY1NQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443254655", "bodyText": "Our code style is to put java.* up front.  See \n  \n    \n      lucene-solr/dev-tools/idea/.idea/codeStyleSettings.xml\n    \n    \n         Line 25\n      in\n      aa5b26f\n    \n    \n    \n    \n\n        \n          \n           <option name=\"IMPORT_LAYOUT_TABLE\"> \n        \n    \n  \n\n\nPlease update your IDE settings accordingly.", "author": "dsmiley", "createdAt": "2020-06-21T20:36:16Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -48,6 +34,12 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.Closeable;", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NDk0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443254945", "bodyText": "Could use a comment here as to what types \"looks like\"; seems several possibilities.", "author": "dsmiley", "createdAt": "2020-06-21T20:40:18Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -274,12 +302,21 @@ void invoke(SolrQueryRequest req, SolrQueryResponse rsp, CommandOperation cmd) {\n       }\n \n     }\n+\n+    private void checkForErrorInPayload(CommandOperation cmd) {\n+      if (cmd.hasError()) {\n+        throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error executing command\",\n+            CommandOperation.captureErrors(Collections.singletonList(cmd)));\n+      }\n+    }\n   }\n \n   public static Map<String, Object> createSchema(Method m) {\n     Type[] types = m.getGenericParameterTypes();\n-    if (types.length == 3) {\n-      Type t = types[2];\n+    Type t = null;", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NTI3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443255277", "bodyText": "FWIW at this line and at some other lines, consider simply doing e.toString() thus capturing both the class name & message.  Long ago I once used e.getMessage() but I never call it any more because you're throwing away interesting info in the exception type.  For example a FileNotFoundException's message is simply the name of the file, giving no indication of what the problem is.", "author": "dsmiley", "createdAt": "2020-06-21T20:45:06Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.*;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh();\n+    return false;\n+  }\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      try {\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n+      }\n+    }\n+\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+        try {\n+          apiInfo.init();\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n+        }\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n+          }\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {\n+    final AnnotatedApi api;\n+\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n+    }\n+\n+    @Override\n+    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n+    }\n+  }\n+\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n+    @JsonProperty\n+    private final PluginMeta info;\n+\n+    @JsonProperty(value = \"package\")\n+    public final String pkg;\n+\n+    private PackageLoader.Package.Version pkgVersion;\n+    private Class klas;\n+    Object instance;\n+\n+\n+    public ApiInfo(PluginMeta info, List<String> errs) {\n+      this.info = info;\n+      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n+      pkg = klassInfo.first();\n+      if (pkg != null) {\n+        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+        if (p == null) {\n+          errs.add(\"Invalid package \" + klassInfo.first());\n+          return;\n+        }\n+        this.pkgVersion = p.getVersion(info.version);\n+        if (pkgVersion == null) {\n+          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+          return;\n+        }\n+        try {\n+          klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n+        } catch (Exception e) {\n+          log.error(\"Error loading class\", e);\n+          errs.add(\"Error loading class \" + e.getMessage());", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NTQ1MA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443255450", "bodyText": "Please add at least one sentence javadoc to the class", "author": "dsmiley", "createdAt": "2020-06-21T20:47:18Z", "path": "solr/core/src/java/org/apache/solr/api/PayloadObj.java", "diffHunk": "@@ -18,18 +18,31 @@\n package org.apache.solr.api;\n \n import org.apache.solr.common.util.CommandOperation;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n \n-public  class PayloadObj<T> extends CommandOperation {\n+public class PayloadObj<T> extends CommandOperation {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NjM4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443256385", "bodyText": "should be static; maybe other inner classes here too?", "author": "dsmiley", "createdAt": "2020-06-21T20:59:33Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.*;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh();\n+    return false;\n+  }\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      try {\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n+      }\n+    }\n+\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+        try {\n+          apiInfo.init();\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n+        }\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n+          }\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NjgxNw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443256817", "bodyText": "No; it was correct before.  Internally, setCore can accept null and doesn't require the caller to care if core is null.  Furthermore, PackageListeners.core will never be null.  It ought to be declared final as well; it's only set in the constructor.", "author": "dsmiley", "createdAt": "2020-06-21T21:05:21Z", "path": "solr/core/src/java/org/apache/solr/pkg/PackageListeners.java", "diffHunk": "@@ -69,7 +69,7 @@ synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n         invokeListeners(pkgInfo);\n       }\n     } finally {\n-      MDCLoggingContext.clear();\n+      if(core != null) MDCLoggingContext.clear();", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MzQ0NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443953444", "bodyText": "PackageListeners.core will never be null\n\nNow it's not.\nThe schema plugins will no more be associated with a core. They will have it as null. I don't need to deal with it in this. So, I'll remove the null check now. PackageListeners is not used in ContainerPlugins", "author": "noblepaul", "createdAt": "2020-06-23T04:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NzMwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443257301", "bodyText": "Add at least one line of javadoc for every public class", "author": "dsmiley", "createdAt": "2020-06-21T21:12:15Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.request.beans;\n+\n+import java.util.Objects;\n+\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+\n+public class PluginMeta implements ReflectMapWriter {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NzQ3NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443257474", "bodyText": "I think the name \"unregister\" would only make sense if there was a corresponding \"register\" method.  How about a more generic \"remove\"?", "author": "dsmiley", "createdAt": "2020-06-21T21:14:16Z", "path": "solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java", "diffHunk": "@@ -82,6 +80,22 @@ public boolean add(String s) {\n     return parts;\n   }\n \n+  public T unregister(List<String> path) {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1NDc0NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443954744", "bodyText": "yeah, remove() is better for insert()", "author": "noblepaul", "createdAt": "2020-06-23T04:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NzQ3NA=="}], "type": "inlineReview"}, {"oid": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "url": "https://github.com/apache/lucene-solr/commit/6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "message": "implemented feedback comments", "committedDate": "2020-06-23T04:39:17Z", "type": "commit"}, {"oid": "a71602f2c6690df5afe77445d0361581b511aa3f", "url": "https://github.com/apache/lucene-solr/commit/a71602f2c6690df5afe77445d0361581b511aa3f", "message": "Update sig.txt", "committedDate": "2020-06-23T05:00:41Z", "type": "commit"}, {"oid": "0a552d83c7a472eda5233ff881ce75f5969e46a2", "url": "https://github.com/apache/lucene-solr/commit/0a552d83c7a472eda5233ff881ce75f5969e46a2", "message": "CHANGES.txt", "committedDate": "2020-06-24T00:22:01Z", "type": "commit"}, {"oid": "9c1e5aa599893bf5fa653af7f282bb8d3b8e49c4", "url": "https://github.com/apache/lucene-solr/commit/9c1e5aa599893bf5fa653af7f282bb8d3b8e49c4", "message": "no hashCode", "committedDate": "2020-06-24T00:34:25Z", "type": "commit"}, {"oid": "f2be5efec94c5f914fee2558ac3731b3c0854988", "url": "https://github.com/apache/lucene-solr/commit/f2be5efec94c5f914fee2558ac3731b3c0854988", "message": "no hashCode", "committedDate": "2020-06-24T02:04:36Z", "type": "commit"}, {"oid": "6d1ca0cbbdc1a2fd0bd336bd2eb51c7253fce1df", "url": "https://github.com/apache/lucene-solr/commit/6d1ca0cbbdc1a2fd0bd336bd2eb51c7253fce1df", "message": "javadocs", "committedDate": "2020-06-24T02:07:45Z", "type": "commit"}, {"oid": "677d84f7be7665a748d8d94ab5eee952dac60926", "url": "https://github.com/apache/lucene-solr/commit/677d84f7be7665a748d8d94ab5eee952dac60926", "message": "  @SuppressWarnings", "committedDate": "2020-06-24T04:54:51Z", "type": "commit"}, {"oid": "0422611a07865c85f89db5c81e9fc6b5ee08a4f0", "url": "https://github.com/apache/lucene-solr/commit/0422611a07865c85f89db5c81e9fc6b5ee08a4f0", "message": "  @SuppressWarnings", "committedDate": "2020-06-24T04:56:02Z", "type": "commit"}, {"oid": "67fe4666c91d6f5220538c35e76ceadc169155e1", "url": "https://github.com/apache/lucene-solr/commit/67fe4666c91d6f5220538c35e76ceadc169155e1", "message": "merging with upstream", "committedDate": "2020-06-24T05:03:26Z", "type": "commit"}, {"oid": "4b412de64321d6eb2059e9f300c0e3a1393b7578", "url": "https://github.com/apache/lucene-solr/commit/4b412de64321d6eb2059e9f300c0e3a1393b7578", "message": "merging with upstream", "committedDate": "2020-06-24T05:25:31Z", "type": "commit"}, {"oid": "6d7db166aa2f61b43b6f114e4bc89c1a0cbb3f3a", "url": "https://github.com/apache/lucene-solr/commit/6d7db166aa2f61b43b6f114e4bc89c1a0cbb3f3a", "message": "merging with master", "committedDate": "2020-06-24T05:31:42Z", "type": "commit"}, {"oid": "a9dbd36ead985ddc220e8e326407f9f57220531a", "url": "https://github.com/apache/lucene-solr/commit/a9dbd36ead985ddc220e8e326407f9f57220531a", "message": "merging with origin", "committedDate": "2020-06-24T05:38:52Z", "type": "commit"}, {"oid": "92871f6547af30e6cb9fb4e1a60298e7432739f6", "url": "https://github.com/apache/lucene-solr/commit/92871f6547af30e6cb9fb4e1a60298e7432739f6", "message": "merging with origin", "committedDate": "2020-06-24T05:41:31Z", "type": "commit"}, {"oid": "fb07c1b3a55a432281c8b9125a356010c648a5f9", "url": "https://github.com/apache/lucene-solr/commit/fb07c1b3a55a432281c8b9125a356010c648a5f9", "message": "CHANGES.txt", "committedDate": "2020-06-24T05:46:17Z", "type": "commit"}, {"oid": "d1a22c8e84c9df8a5fb633ca829c9fbedf27de6b", "url": "https://github.com/apache/lucene-solr/commit/d1a22c8e84c9df8a5fb633ca829c9fbedf27de6b", "message": "SuppressWarnings", "committedDate": "2020-06-24T06:01:42Z", "type": "commit"}, {"oid": "b1e4dee970a87c9a77c09b706ad1674358b5dbf8", "url": "https://github.com/apache/lucene-solr/commit/b1e4dee970a87c9a77c09b706ad1674358b5dbf8", "message": "CHANGES.txt", "committedDate": "2020-06-25T01:35:56Z", "type": "commit"}, {"oid": "c9c17577b051e0e9e7158944004d3d72a71e0bbd", "url": "https://github.com/apache/lucene-solr/commit/c9c17577b051e0e9e7158944004d3d72a71e0bbd", "message": "Merge remote-tracking branch 'origin/master' into jira/solr14404\n\nmerge with master", "committedDate": "2020-06-25T01:36:02Z", "type": "commit"}, {"oid": "1c74faf0943da286f77ba2aab2cd5d0e400883f8", "url": "https://github.com/apache/lucene-solr/commit/1c74faf0943da286f77ba2aab2cd5d0e400883f8", "message": "merging with master", "committedDate": "2020-06-25T01:46:04Z", "type": "commit"}, {"oid": "cda8390a5edb21e978da618eb8b68ad8f43f28ef", "url": "https://github.com/apache/lucene-solr/commit/cda8390a5edb21e978da618eb8b68ad8f43f28ef", "message": "merging with master", "committedDate": "2020-06-25T01:48:01Z", "type": "commit"}, {"oid": "55ef0ebee05ef9b127125da69dcd5de21fc7101a", "url": "https://github.com/apache/lucene-solr/commit/55ef0ebee05ef9b127125da69dcd5de21fc7101a", "message": "merging with master", "committedDate": "2020-06-25T01:50:58Z", "type": "commit"}, {"oid": "371c92b54587d90c376929ae99dfc9d2acc15a5e", "url": "https://github.com/apache/lucene-solr/commit/371c92b54587d90c376929ae99dfc9d2acc15a5e", "message": "SuppressWarnings", "committedDate": "2020-06-25T02:34:39Z", "type": "commit"}, {"oid": "227743a2c383eb4245f56ca7204897111553f382", "url": "https://github.com/apache/lucene-solr/commit/227743a2c383eb4245f56ca7204897111553f382", "message": "SuppressWarnings", "committedDate": "2020-06-25T02:48:56Z", "type": "commit"}]}