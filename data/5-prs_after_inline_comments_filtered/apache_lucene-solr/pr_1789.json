{"pr_number": 1789, "pr_title": "LUCENE-9484: Allow sorting an index after the fact", "pr_createdAt": "2020-08-26T11:37:30Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1789", "timeline": [{"oid": "a72c4a06762b57087815cb90d6a0329efff0ee3a", "url": "https://github.com/apache/lucene-solr/commit/a72c4a06762b57087815cb90d6a0329efff0ee3a", "message": "LUCENE-9484: Allow sorting an index after the fact\n\nToday we need to decide on an index sorting before we create the index.\nIn some situations it might make a lot of sense to sort an index afterwards\nwhen the index doesn't change anymore or to compress older indices.\nThis comit adds the ability to wrap readers from an unsorted index and merge it\ninto a sorted index by using IW#addIndices.", "committedDate": "2020-08-26T11:34:14Z", "type": "commit"}, {"oid": "e15b2ff1e562511d876351755acfba21d8ed419f", "url": "https://github.com/apache/lucene-solr/commit/e15b2ff1e562511d876351755acfba21d8ed419f", "message": "Merge branch 'master' into LUCENE-9484", "committedDate": "2020-08-31T08:04:49Z", "type": "commit"}, {"oid": "4ab5eba329af050390041b56c119a556da37ed1d", "url": "https://github.com/apache/lucene-solr/commit/4ab5eba329af050390041b56c119a556da37ed1d", "message": "apply feedback", "committedDate": "2020-08-31T08:52:04Z", "type": "commit"}, {"oid": "23299d4e34307679dacba2ff3be2d616348d6832", "url": "https://github.com/apache/lucene-solr/commit/23299d4e34307679dacba2ff3be2d616348d6832", "message": "beef up testing", "committedDate": "2020-08-31T15:12:08Z", "type": "commit"}, {"oid": "080e2f457fb69741cd1f3fe5f866f4f7a04cf410", "url": "https://github.com/apache/lucene-solr/commit/080e2f457fb69741cd1f3fe5f866f4f7a04cf410", "message": "reduce code duplication", "committedDate": "2020-08-31T15:29:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NDU2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r480384563", "bodyText": "IMO we should delegate to in#getPointsReader() as the contract is slightly different on the reader and the points reader (the reader returns null if the field was not indexed with points while the points reader fails).", "author": "jpountz", "createdAt": "2020-08-31T20:36:11Z", "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -1090,20 +1150,64 @@ public Bits getLiveDocs() {\n   }\n \n   @Override\n-  public PointValues getPointValues(String fieldName) throws IOException {\n-    final PointValues inPointValues = in.getPointValues(fieldName);\n-    if (inPointValues == null) {\n-      return null;\n-    } else {\n-      return new SortingPointValues(inPointValues, docMap);\n-    }\n+  public PointsReader getPointsReader() {\n+    return new PointsReader() {\n+      @Override\n+      public void checkIntegrity() throws IOException {\n+        in.getPointsReader().checkIntegrity();\n+      }\n+\n+      @Override\n+      public PointValues getValues(String field) throws IOException {\n+        final PointValues inPointValues = in.getPointValues(field);", "originalCommit": "080e2f457fb69741cd1f3fe5f866f4f7a04cf410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NTE3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r480385173", "bodyText": "it can never be null since getValues may only be called on fields that were indexed with points on points readers", "author": "jpountz", "createdAt": "2020-08-31T20:37:24Z", "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -1090,20 +1150,64 @@ public Bits getLiveDocs() {\n   }\n \n   @Override\n-  public PointValues getPointValues(String fieldName) throws IOException {\n-    final PointValues inPointValues = in.getPointValues(fieldName);\n-    if (inPointValues == null) {\n-      return null;\n-    } else {\n-      return new SortingPointValues(inPointValues, docMap);\n-    }\n+  public PointsReader getPointsReader() {\n+    return new PointsReader() {\n+      @Override\n+      public void checkIntegrity() throws IOException {\n+        in.getPointsReader().checkIntegrity();\n+      }\n+\n+      @Override\n+      public PointValues getValues(String field) throws IOException {\n+        final PointValues inPointValues = in.getPointValues(field);\n+        if (inPointValues == null) {", "originalCommit": "080e2f457fb69741cd1f3fe5f866f4f7a04cf410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NTQzMg==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r480385432", "bodyText": "likewise, delegate to in#getNormsReader here?", "author": "jpountz", "createdAt": "2020-08-31T20:37:56Z", "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -1090,20 +1150,64 @@ public Bits getLiveDocs() {\n   }\n \n   @Override\n-  public PointValues getPointValues(String fieldName) throws IOException {\n-    final PointValues inPointValues = in.getPointValues(fieldName);\n-    if (inPointValues == null) {\n-      return null;\n-    } else {\n-      return new SortingPointValues(inPointValues, docMap);\n-    }\n+  public PointsReader getPointsReader() {\n+    return new PointsReader() {\n+      @Override\n+      public void checkIntegrity() throws IOException {\n+        in.getPointsReader().checkIntegrity();\n+      }\n+\n+      @Override\n+      public PointValues getValues(String field) throws IOException {\n+        final PointValues inPointValues = in.getPointValues(field);\n+        if (inPointValues == null) {\n+          return null;\n+        } else {\n+          return new SortingPointValues(inPointValues, docMap);\n+        }\n+      }\n+\n+      @Override\n+      public void close() throws IOException {\n+        in.getPointsReader().close();\n+      }\n+\n+      @Override\n+      public long ramBytesUsed() {\n+        return in.getPointsReader().ramBytesUsed();\n+      }\n+    };\n   }\n \n   private final Map<String,CachedNumericDVs> cachedNorms = new HashMap<>();\n \n   @Override\n-  public NumericDocValues getNormValues(String field) throws IOException {\n-    final NumericDocValues oldNorms = in.getNormValues(field);\n+  public NormsProducer getNormsReader() {\n+    return new NormsProducer() {\n+      @Override\n+      public NumericDocValues getNorms(FieldInfo field) throws IOException {\n+        final NumericDocValues oldNorms = in.getNormValues(field.name);", "originalCommit": "080e2f457fb69741cd1f3fe5f866f4f7a04cf410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "535455d87df702df9f903a5d9ca0abc90d5744c3", "url": "https://github.com/apache/lucene-solr/commit/535455d87df702df9f903a5d9ca0abc90d5744c3", "message": "apply feedback", "committedDate": "2020-09-01T07:49:53Z", "type": "commit"}, {"oid": "2d06cb5c926087154b100b1c50cee21028207ad6", "url": "https://github.com/apache/lucene-solr/commit/2d06cb5c926087154b100b1c50cee21028207ad6", "message": "move corresponding sort classes to their main users", "committedDate": "2020-09-01T09:28:14Z", "type": "commit"}, {"oid": "eb181d9f59ecbc20b85c68980b279c5de8ddbc65", "url": "https://github.com/apache/lucene-solr/commit/eb181d9f59ecbc20b85c68980b279c5de8ddbc65", "message": "Merge branch 'master' into LUCENE-9484", "committedDate": "2020-09-01T09:32:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyMzU1Mw==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r481823553", "bodyText": "I think this will fail if target is > maxDoc? Maybe this class should just throw UOE for advance and advanceExact since codecs are only supposed to consume these doc values via nextDoc.", "author": "jpountz", "createdAt": "2020-09-02T07:20:05Z", "path": "lucene/core/src/java/org/apache/lucene/index/BinaryDocValuesWriter.java", "diffHunk": "@@ -202,4 +203,63 @@ public BytesRef binaryValue() {\n       return value.get();\n     }\n   }\n+\n+  static class SortingBinaryDocValues extends BinaryDocValues {\n+\n+    private final CachedBinaryDVs dvs;\n+    private int docID = -1;\n+\n+    SortingBinaryDocValues(CachedBinaryDVs dvs) {\n+      this.dvs = dvs;\n+    }\n+\n+    @Override\n+    public int nextDoc() {\n+      if (docID+1 == dvs.docsWithField.length()) {\n+        docID = NO_MORE_DOCS;\n+      } else {\n+        docID = dvs.docsWithField.nextSetBit(docID+1);\n+      }\n+\n+      return docID;\n+    }\n+\n+    @Override\n+    public int docID() {\n+      return docID;\n+    }\n+\n+    @Override\n+    public int advance(int target) {\n+      docID = dvs.docsWithField.nextSetBit(target);\n+      return docID;", "originalCommit": "2d06cb5c926087154b100b1c50cee21028207ad6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgyMzk2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r481823967", "bodyText": "I think we should either throw UOE here or cache the cardinality.", "author": "jpountz", "createdAt": "2020-09-02T07:20:36Z", "path": "lucene/core/src/java/org/apache/lucene/index/BinaryDocValuesWriter.java", "diffHunk": "@@ -202,4 +203,63 @@ public BytesRef binaryValue() {\n       return value.get();\n     }\n   }\n+\n+  static class SortingBinaryDocValues extends BinaryDocValues {\n+\n+    private final CachedBinaryDVs dvs;\n+    private int docID = -1;\n+\n+    SortingBinaryDocValues(CachedBinaryDVs dvs) {\n+      this.dvs = dvs;\n+    }\n+\n+    @Override\n+    public int nextDoc() {\n+      if (docID+1 == dvs.docsWithField.length()) {\n+        docID = NO_MORE_DOCS;\n+      } else {\n+        docID = dvs.docsWithField.nextSetBit(docID+1);\n+      }\n+\n+      return docID;\n+    }\n+\n+    @Override\n+    public int docID() {\n+      return docID;\n+    }\n+\n+    @Override\n+    public int advance(int target) {\n+      docID = dvs.docsWithField.nextSetBit(target);\n+      return docID;\n+    }\n+\n+    @Override\n+    public boolean advanceExact(int target) throws IOException {\n+      docID = target;\n+      return dvs.docsWithField.get(target);\n+    }\n+\n+    @Override\n+    public BytesRef binaryValue() {\n+      return dvs.values[docID];\n+    }\n+\n+    @Override\n+    public long cost() {\n+      return dvs.docsWithField.cardinality();", "originalCommit": "2d06cb5c926087154b100b1c50cee21028207ad6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1MzY0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r481953649", "bodyText": "can you call in.visitDocument instead?", "author": "jpountz", "createdAt": "2020-09-02T10:05:24Z", "path": "lucene/core/src/java/org/apache/lucene/index/SortingCodecReader.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.lucene.codecs.DocValuesProducer;\n+import org.apache.lucene.codecs.FieldsProducer;\n+import org.apache.lucene.codecs.NormsProducer;\n+import org.apache.lucene.codecs.PointsReader;\n+import org.apache.lucene.codecs.StoredFieldsReader;\n+import org.apache.lucene.codecs.TermVectorsReader;\n+import org.apache.lucene.search.Sort;\n+import org.apache.lucene.util.Bits;\n+import org.apache.lucene.util.FixedBitSet;\n+\n+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;\n+\n+/**\n+ * An {@link org.apache.lucene.index.CodecReader} which supports sorting documents by a given\n+ * {@link Sort}. This can be used to re-sort and index after it's been created by wrapping all\n+ * readers of the index with this reader and adding it to a fresh IndexWriter via\n+ * {@link IndexWriter#addIndexes(CodecReader...)}.\n+ *\n+ * @lucene.experimental\n+ */\n+public final class SortingCodecReader extends FilterCodecReader {\n+\n+  private final Map<String, NumericDocValuesWriter.CachedNumericDVs> cachedNumericDVs = new HashMap<>();\n+\n+  private final Map<String, BinaryDocValuesWriter.CachedBinaryDVs> cachedBinaryDVs = new HashMap<>();\n+\n+  private final Map<String, int[]> cachedSortedDVs = new HashMap<>();\n+\n+  // TODO: pack long[][] into an int[] (offset) and long[] instead:\n+  private final Map<String, long[][]> cachedSortedSetDVs = new HashMap<>();\n+\n+  private final Map<String, long[][]> cachedSortedNumericDVs = new HashMap<>();\n+\n+  private static class SortingBits implements Bits {\n+\n+    private final Bits in;\n+    private final Sorter.DocMap docMap;\n+\n+    SortingBits(final Bits in, Sorter.DocMap docMap) {\n+      this.in = in;\n+      this.docMap = docMap;\n+    }\n+\n+    @Override\n+    public boolean get(int index) {\n+      return in.get(docMap.newToOld(index));\n+    }\n+\n+    @Override\n+    public int length() {\n+      return in.length();\n+    }\n+  }\n+\n+  private static class SortingPointValues extends PointValues {\n+\n+    private final PointValues in;\n+    private final Sorter.DocMap docMap;\n+\n+    SortingPointValues(final PointValues in, Sorter.DocMap docMap) {\n+      this.in = in;\n+      this.docMap = docMap;\n+    }\n+\n+    @Override\n+    public void intersect(IntersectVisitor visitor) throws IOException {\n+      in.intersect(new IntersectVisitor() {\n+                     @Override\n+                     public void visit(int docID) throws IOException {\n+                       visitor.visit(docMap.oldToNew(docID));\n+                     }\n+\n+                     @Override\n+                     public void visit(int docID, byte[] packedValue) throws IOException {\n+                       visitor.visit(docMap.oldToNew(docID), packedValue);\n+                     }\n+\n+                     @Override\n+                     public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+                       return visitor.compare(minPackedValue, maxPackedValue);\n+                     }\n+                   });\n+    }\n+\n+    @Override\n+    public long estimatePointCount(IntersectVisitor visitor) {\n+      return in.estimatePointCount(visitor);\n+    }\n+\n+    @Override\n+    public byte[] getMinPackedValue() throws IOException {\n+      return in.getMinPackedValue();\n+    }\n+\n+    @Override\n+    public byte[] getMaxPackedValue() throws IOException {\n+      return in.getMaxPackedValue();\n+    }\n+\n+    @Override\n+    public int getNumDimensions() throws IOException {\n+      return in.getNumDimensions();\n+    }\n+\n+    @Override\n+    public int getNumIndexDimensions() throws IOException {\n+      return in.getNumIndexDimensions();\n+    }\n+\n+    @Override\n+    public int getBytesPerDimension() throws IOException {\n+      return in.getBytesPerDimension();\n+    }\n+\n+    @Override\n+    public long size() {\n+      return in.size();\n+    }\n+\n+    @Override\n+    public int getDocCount() {\n+      return in.getDocCount();\n+    }\n+  }\n+\n+\n+\n+\n+\n+  /** Return a sorted view of <code>reader</code> according to the order\n+   *  defined by <code>sort</code>. If the reader is already sorted, this\n+   *  method might return the reader as-is. */\n+  public static CodecReader wrap(CodecReader reader, Sort sort) throws IOException {\n+    return wrap(reader, new Sorter(sort).sort(reader), sort);\n+  }\n+\n+  /** Expert: same as {@link #wrap(org.apache.lucene.index.CodecReader, Sort)} but operates directly on a {@link Sorter.DocMap}. */\n+  static CodecReader wrap(CodecReader reader, Sorter.DocMap docMap, Sort sort) {\n+    LeafMetaData metaData = reader.getMetaData();\n+    LeafMetaData newMetaData = new LeafMetaData(metaData.getCreatedVersionMajor(), metaData.getMinVersion(), sort);\n+    if (docMap == null) {\n+      // the reader is already sorted\n+      return new FilterCodecReader(reader) {\n+        @Override\n+        public CacheHelper getCoreCacheHelper() {\n+          return null;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+          return null;\n+        }\n+\n+        @Override\n+        public LeafMetaData getMetaData() {\n+          return newMetaData;\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return \"SortingCodecReader(\" + in + \")\";\n+        }\n+      };\n+    }\n+    if (reader.maxDoc() != docMap.size()) {\n+      throw new IllegalArgumentException(\"reader.maxDoc() should be equal to docMap.size(), got\" + reader.maxDoc() + \" != \" + docMap.size());\n+    }\n+    assert Sorter.isConsistent(docMap);\n+    return new SortingCodecReader(reader, docMap, newMetaData);\n+  }\n+\n+  final Sorter.DocMap docMap; // pkg-protected to avoid synthetic accessor methods\n+  final LeafMetaData metaData;\n+\n+  private SortingCodecReader(final CodecReader in, final Sorter.DocMap docMap, LeafMetaData metaData) {\n+    super(in);\n+    this.docMap = docMap;\n+    this.metaData = metaData;\n+  }\n+\n+\n+  @Override\n+  public FieldsProducer getPostingsReader() {\n+    FieldsProducer postingsReader = in.getPostingsReader();\n+    return new FieldsProducer() {\n+      @Override\n+      public void close() throws IOException {\n+        postingsReader.close();\n+      }\n+\n+      @Override\n+      public void checkIntegrity() throws IOException {\n+        postingsReader.checkIntegrity();\n+      }\n+\n+      @Override\n+      public Iterator<String> iterator() {\n+        return postingsReader.iterator();\n+      }\n+\n+      @Override\n+      public Terms terms(String field) throws IOException {\n+        Terms terms = postingsReader.terms(field);\n+        return terms == null ? null : new FreqProxTermsWriter.SortingTerms(terms,\n+            in.getFieldInfos().fieldInfo(field).getIndexOptions(), docMap);\n+      }\n+\n+      @Override\n+      public int size() {\n+        return postingsReader.size();\n+      }\n+\n+      @Override\n+      public long ramBytesUsed() {\n+        return postingsReader.ramBytesUsed();\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public StoredFieldsReader getFieldsReader() {\n+    StoredFieldsReader delegate = in.getFieldsReader();\n+    return newStoredFieldsReader(delegate);\n+  }\n+\n+  private StoredFieldsReader newStoredFieldsReader(StoredFieldsReader delegate) {\n+    return new StoredFieldsReader() {\n+      @Override\n+      public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException {\n+        in.document(docMap.newToOld(docID), visitor);", "originalCommit": "2d06cb5c926087154b100b1c50cee21028207ad6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "563878d7da64e91d759ea2b9834ed62298a1d427", "url": "https://github.com/apache/lucene-solr/commit/563878d7da64e91d759ea2b9834ed62298a1d427", "message": "apply feedback", "committedDate": "2020-09-02T13:31:31Z", "type": "commit"}, {"oid": "037d4a0943604fd75b5494661690e9efffb24ecf", "url": "https://github.com/apache/lucene-solr/commit/037d4a0943604fd75b5494661690e9efffb24ecf", "message": "improve testing for index sorting after the fact", "committedDate": "2020-09-02T14:30:19Z", "type": "commit"}, {"oid": "81690a1b6864fd4c7349338ad9c182fd2529ac9c", "url": "https://github.com/apache/lucene-solr/commit/81690a1b6864fd4c7349338ad9c182fd2529ac9c", "message": "fix forbidden APIs", "committedDate": "2020-09-02T14:59:01Z", "type": "commit"}, {"oid": "d28a65a9fa444be9a6054b3df2c5c8560ceb5082", "url": "https://github.com/apache/lucene-solr/commit/d28a65a9fa444be9a6054b3df2c5c8560ceb5082", "message": "reorder args", "committedDate": "2020-09-02T15:08:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQxOTE2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r482419163", "bodyText": "cache the cost?", "author": "jpountz", "createdAt": "2020-09-02T20:28:35Z", "path": "lucene/core/src/java/org/apache/lucene/index/NumericDocValuesWriter.java", "diffHunk": "@@ -165,4 +166,62 @@ public long longValue() {\n       return value;\n     }\n   }\n+\n+  static class SortingNumericDocValues extends NumericDocValues {\n+\n+    private final CachedNumericDVs dvs;\n+    private int docID = -1;\n+\n+    SortingNumericDocValues(CachedNumericDVs dvs) {\n+      this.dvs = dvs;\n+    }\n+\n+    @Override\n+    public int docID() {\n+      return docID;\n+    }\n+\n+    @Override\n+    public int nextDoc() {\n+      if (docID+1 == dvs.docsWithField.length()) {\n+        docID = NO_MORE_DOCS;\n+      } else {\n+        docID = dvs.docsWithField.nextSetBit(docID+1);\n+      }\n+\n+      return docID;\n+    }\n+\n+    @Override\n+    public int advance(int target) {\n+      docID = dvs.docsWithField.nextSetBit(target);\n+      return docID;\n+    }\n+\n+    @Override\n+    public boolean advanceExact(int target) throws IOException {\n+      docID = target;\n+      return dvs.docsWithField.get(target);\n+    }\n+\n+    @Override\n+    public long longValue() {\n+      return dvs.values[docID];\n+    }\n+\n+    @Override\n+    public long cost() {\n+      return dvs.docsWithField.cardinality();", "originalCommit": "d28a65a9fa444be9a6054b3df2c5c8560ceb5082", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzNDE3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r482434175", "bodyText": "I just realized reading other comments that this method might be required when configuring index sorting on a binary field.", "author": "jpountz", "createdAt": "2020-09-02T20:40:01Z", "path": "lucene/core/src/java/org/apache/lucene/index/BinaryDocValuesWriter.java", "diffHunk": "@@ -202,4 +203,63 @@ public BytesRef binaryValue() {\n       return value.get();\n     }\n   }\n+\n+  static class SortingBinaryDocValues extends BinaryDocValues {\n+    private final CachedBinaryDVs dvs;\n+    private int docID = -1;\n+    private long cost = -1;\n+\n+    SortingBinaryDocValues(CachedBinaryDVs dvs) {\n+      this.dvs = dvs;\n+    }\n+\n+    @Override\n+    public int nextDoc() {\n+      if (docID+1 == dvs.docsWithField.length()) {\n+        docID = NO_MORE_DOCS;\n+      } else {\n+        docID = dvs.docsWithField.nextSetBit(docID+1);\n+      }\n+      return docID;\n+    }\n+\n+    @Override\n+    public int docID() {\n+      return docID;\n+    }\n+\n+    @Override\n+    public int advance(int target) {\n+      throw new UnsupportedOperationException(\"use nextDoc instead\");\n+    }\n+\n+    @Override\n+    public boolean advanceExact(int target) throws IOException {\n+      throw new UnsupportedOperationException(\"use nextDoc instead\");", "originalCommit": "d28a65a9fa444be9a6054b3df2c5c8560ceb5082", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MDI2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r482740267", "bodyText": "many others are needed but afaik if you wanna sort on a binary field it needs to be SortedDocValues and not BinaryDocValues - at least I wasn't able to make any test fail here..", "author": "s1monw", "createdAt": "2020-09-03T06:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzNDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3MjE4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1789#discussion_r482772181", "bodyText": "\ud83d\udc4d", "author": "jpountz", "createdAt": "2020-09-03T07:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzNDE3NQ=="}], "type": "inlineReview"}, {"oid": "bfde6fa92048111ea01800f454b6bf6169b80383", "url": "https://github.com/apache/lucene-solr/commit/bfde6fa92048111ea01800f454b6bf6169b80383", "message": "cache more costs", "committedDate": "2020-09-03T06:42:59Z", "type": "commit"}, {"oid": "b03e064668bb7eb0fa405af1ec16b0c273478f27", "url": "https://github.com/apache/lucene-solr/commit/b03e064668bb7eb0fa405af1ec16b0c273478f27", "message": "add comments why certain impls are needed", "committedDate": "2020-09-03T06:50:46Z", "type": "commit"}, {"oid": "4c75a3b45769c45f0a595921fd908d326e02bb78", "url": "https://github.com/apache/lucene-solr/commit/4c75a3b45769c45f0a595921fd908d326e02bb78", "message": "Merge branch 'master' into LUCENE-9484", "committedDate": "2020-09-03T06:58:29Z", "type": "commit"}, {"oid": "3d53b2d99b0b813a512fede8cddeba424fc40757", "url": "https://github.com/apache/lucene-solr/commit/3d53b2d99b0b813a512fede8cddeba424fc40757", "message": "add CHANGES.txt entry", "committedDate": "2020-09-03T07:14:54Z", "type": "commit"}]}