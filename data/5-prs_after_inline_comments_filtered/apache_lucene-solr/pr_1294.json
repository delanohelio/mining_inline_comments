{"pr_number": 1294, "pr_title": "LUCENE-9074: Slice Allocation Control Plane For Concurrent Searches", "pr_createdAt": "2020-02-27T04:56:32Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1294", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNDc5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r384914799", "bodyText": "To quote @jpountz :\n\"this doesn't need an executor, does it?\"\nIt is needed since executor is a final member of IndexSearcher hence needs to be initialized? We could potentially always set it null since it anyways wont be used but that seemed a bit counter intuitive. WDYT?", "author": "atris", "createdAt": "2020-02-27T05:03:04Z", "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -211,6 +215,18 @@ public IndexSearcher(IndexReaderContext context, Executor executor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n     reader = context.reader();\n     this.executor = executor;\n+    this.sliceExecutionControlPlane = executor == null ? null : getSliceExecutionControlPlane(executor);\n+    this.readerContext = context;\n+    leafContexts = context.leaves();\n+    this.leafSlices = executor == null ? null : slices(leafContexts);\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutionControlPlane sliceExecutionControlPlane) {", "originalCommit": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NzA0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388497042", "bodyText": "Is there anything we need to do with the executor that we couldn't do with the sliceExecutionControlPlane?", "author": "jpountz", "createdAt": "2020-03-05T19:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNDc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r384915037", "bodyText": "To quote @jpountz\n\"the generics on this interface look over-engineered?\"\nI am not sure as to what the correct generics should be. Could you please advice?", "author": "atris", "createdAt": "2020-02-27T05:04:17Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Execution control plane which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+public interface SliceExecutionControlPlane<C, T extends Runnable> {\n+  /**\n+   * Invoke all slices that are allocated for the query\n+   */\n+  C invokeAll(Collection<T> tasks);", "originalCommit": "3e9cd7f33ca4c490c3066e0e4c2508fb1482f965", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MDQxNg==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385080416", "bodyText": "I think it does not need to be generic at all since the only use case is for Future and FutureTask. In fact the interface serves no visible purpose; we could simply rename DefaultSliceExecutionControlPlane to SliceExecutionControlPlane and nothing else would change. Since we're on naming, the naming seems rather grandiose for my tastes. I tend to think of a ControlPlane as a component in a distributed system, but I struggle to come up with anything better. Maybe SliceRunner?", "author": "msokolov", "createdAt": "2020-02-27T11:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxOTQ0Nw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385819447", "bodyText": "Thanks for taking a look. I have fixed your comments. I have introduced the interface to allow easy extensibility. I agree that the current use case is with Future and FutureTask but that should not restrict the future use cases that are possible on top of the interface.\nRegarding the name, SliceRunner does not seem to convey the right message since the class can control the way the execution of the query happens without any internal directions hence it is vital to highlight that the execution of a query can be influenced by the decisions of this class.", "author": "atris", "createdAt": "2020-02-28T17:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEwOTE5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r386109193", "bodyText": "This is an internal detail of IndexSearcher, right? We're always free to change the method signatures later (if we keep the classes package-private - we should!). Maybe it would help if you were to explain what extension you have in mind.\nBy the way, using force push makes it more difficult for reviewers since we can't easily see what changed from one version to the next. In general it's better to push your commits and then squash-merge them at the end (github will even do this for you I think)", "author": "msokolov", "createdAt": "2020-03-01T13:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEwOTI1MA==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r386109250", "bodyText": "Also- I'm curious if you saw any performance impact from the back pressure here?", "author": "msokolov", "createdAt": "2020-03-01T13:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3NTE2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388075165", "bodyText": "I do not have a very strong preference to the extensibility model of the interface -- so removed it per your recommendation. Let me know if you have any further comments or thoughts", "author": "atris", "createdAt": "2020-03-05T04:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA3NTMyNw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388075327", "bodyText": "Also- I'm curious if you saw any performance impact from the back pressure here?\n\nWhen testing with artificial CPU stress and a small threadpool size, the worst case performance tends towards sequential since all tasks will be scheduled on the caller thread", "author": "atris", "createdAt": "2020-03-05T04:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNTAzNw=="}], "type": "inlineReview"}, {"oid": "ab1e377bdc9642145e0e1be4ee2334198df55642", "url": "https://github.com/apache/lucene-solr/commit/ab1e377bdc9642145e0e1be4ee2334198df55642", "message": "Update exception handling to reflect original exception stack", "committedDate": "2020-02-27T05:06:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MjU0NA==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385082544", "bodyText": "The logic around this boolean is hard to read. I think it would be clearer if we restructure the logic a bit and avoid modifying an incoming boolean parameter", "author": "msokolov", "createdAt": "2020-02-27T11:59:36Z", "path": "lucene/core/src/java/org/apache/lucene/search/DefaultSliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Implementation of SliceExecutionControlPlane with queue backpressure based thread allocation\n+ */\n+public class DefaultSliceExecutionControlPlane implements SliceExecutionControlPlane<List<Future>, FutureTask> {\n+  private final Executor executor;\n+\n+  public DefaultSliceExecutionControlPlane(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  @Override\n+  public List<Future> invokeAll(Collection<FutureTask> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected void processTask(FutureTask task, List<Future> futures,\n+                             boolean shouldExecuteOnCallerThread) {", "originalCommit": "ab1e377bdc9642145e0e1be4ee2334198df55642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MjcxMg==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385082712", "bodyText": "else?", "author": "msokolov", "createdAt": "2020-02-27T12:00:02Z", "path": "lucene/core/src/java/org/apache/lucene/search/DefaultSliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Implementation of SliceExecutionControlPlane with queue backpressure based thread allocation\n+ */\n+public class DefaultSliceExecutionControlPlane implements SliceExecutionControlPlane<List<Future>, FutureTask> {\n+  private final Executor executor;\n+\n+  public DefaultSliceExecutionControlPlane(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  @Override\n+  public List<Future> invokeAll(Collection<FutureTask> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected void processTask(FutureTask task, List<Future> futures,\n+                             boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+        shouldExecuteOnCallerThread = true;\n+      }\n+    }\n+\n+    if (shouldExecuteOnCallerThread) {\n+      try {\n+        task.run();\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {", "originalCommit": "ab1e377bdc9642145e0e1be4ee2334198df55642", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MzUwNw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r385083507", "bodyText": "could we add this to the first if block? ie executor.execute() .. futures.add() ...?  Then use early return and you don't need to modify the incoming parameter", "author": "msokolov", "createdAt": "2020-02-27T12:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MjcxMg=="}], "type": "inlineReview"}, {"oid": "a7762eb840f5f9b240e4dfd78899b73f2c04fcbd", "url": "https://github.com/apache/lucene-solr/commit/a7762eb840f5f9b240e4dfd78899b73f2c04fcbd", "message": "Update exception handling to reflect original exception stack", "committedDate": "2020-02-27T17:30:53Z", "type": "forcePushed"}, {"oid": "36adb01f7f47689a2b0b17b1b901adc6a6463cdb", "url": "https://github.com/apache/lucene-solr/commit/36adb01f7f47689a2b0b17b1b901adc6a6463cdb", "message": "Update exception handling to reflect original exception stack", "committedDate": "2020-02-27T17:38:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzgxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388493819", "bodyText": "it feels wrong to not take the one from the constructor?", "author": "jpountz", "createdAt": "2020-03-05T18:54:38Z", "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -211,6 +213,18 @@ public IndexSearcher(IndexReaderContext context, Executor executor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n     reader = context.reader();\n     this.executor = executor;\n+    this.sliceExecutionControlPlane = executor == null ? null : getSliceExecutionControlPlane(executor);\n+    this.readerContext = context;\n+    leafContexts = context.leaves();\n+    this.leafSlices = executor == null ? null : slices(leafContexts);\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutionControlPlane sliceExecutionControlPlane) {\n+    assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n+    reader = context.reader();\n+    this.executor = executor;\n+    this.sliceExecutionControlPlane = executor == null ? null : sliceExecutionControlPlane;", "originalCommit": "ca4b7843d20751d3b58ba11c492eac6855c7fcf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzODc5MQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r389038791", "bodyText": "Not sure if I understood your point. The passed in instance is the one being assigned to the member?", "author": "atris", "createdAt": "2020-03-06T17:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUxNDI1Nw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390514257", "bodyText": "My point was that it sounds like a bug on the caller of this constructor to pass a null executor and a non-null sliceExecutionControlPlane? So I'd rather have validation around it rather than be lenient and ignore the provided sliceExecutionControlPlane if the executor is null?", "author": "jpountz", "createdAt": "2020-03-10T18:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE5MjE1NQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r391192155", "bodyText": "+1, did not add it since it was a test method but I see your point. Added now, thanks!", "author": "atris", "createdAt": "2020-03-11T18:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5MzgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NzUxMQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388497511", "bodyText": "Let's avoid introducing warnings about generics, FutureTask needs to be parameterized?", "author": "jpountz", "createdAt": "2020-03-05T19:00:57Z", "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -662,34 +676,19 @@ public TopFieldDocs reduce(Collection<TopFieldCollector> collectors) throws IOEx\n       }\n       query = rewrite(query);\n       final Weight weight = createWeight(query, scoreMode, 1);\n-      final List<Future<C>> topDocsFutures = new ArrayList<>(leafSlices.length);\n-      for (int i = 0; i < leafSlices.length - 1; ++i) {\n+      final List<FutureTask> listTasks = new ArrayList<>();", "originalCommit": "ca4b7843d20751d3b58ba11c492eac6855c7fcf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5ODE4OA==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r388498188", "bodyText": "nit: I'd prefer a simpler name, e.g. SliceExecutor", "author": "jpountz", "createdAt": "2020-03-05T19:02:15Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutionControlPlane.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Execution control plane which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutionControlPlane {", "originalCommit": "ca4b7843d20751d3b58ba11c492eac6855c7fcf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUxNTAyNA==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390515024", "bodyText": "maybe this should delegate to the below constructor?", "author": "jpountz", "createdAt": "2020-03-10T18:12:46Z", "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -211,6 +213,18 @@ public IndexSearcher(IndexReaderContext context, Executor executor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n     reader = context.reader();\n     this.executor = executor;\n+    this.sliceExecutor = executor == null ? null : getSliceExecutionControlPlane(executor);\n+    this.readerContext = context;\n+    leafContexts = context.leaves();\n+    this.leafSlices = executor == null ? null : slices(leafContexts);", "originalCommit": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMTc5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390521799", "bodyText": "we don't need this catch block as task.run() doesn't declare any non-runtime exception?", "author": "jpountz", "createdAt": "2020-03-10T18:24:13Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future<C>> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected <C> void processTask(final FutureTask<C> task, final List<Future<C>> futures,\n+                             final boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+        futures.add(task);\n+\n+        return;\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+      }\n+    }\n+\n+    runTaskOnCallerThread(task);\n+\n+    try {\n+      futures.add(CompletableFuture.completedFuture(task.get()));\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  // Private helper method to run a task on the caller thread\n+  private void runTaskOnCallerThread(FutureTask task) {\n+    try {\n+      task.run();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }", "originalCommit": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMjc3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390522773", "bodyText": "we shouldn't make this method public if it returns a pkg-private class, let's make the method pkg-private too? Or even remove it entirely as I'm not seeing any call site for it?", "author": "jpountz", "createdAt": "2020-03-10T18:25:48Z", "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -933,6 +932,13 @@ public Executor getExecutor() {\n     return executor;\n   }\n \n+  /**\n+   * Returns this searchers slice execution control plane or <code>null</code> if no executor was provided\n+   */\n+  public SliceExecutor getSliceExecutor() {", "originalCommit": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMzQzNw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390523437", "bodyText": "I wonder whether this is the right API. We could change the return type to void and use Runnable instead of FutureTask and that would still work, right? The return value isn't really useful since it has the same content as the input collection? So what about making it just: public void invokeAll(Collection<? extends Runnable> tasks)?", "author": "jpountz", "createdAt": "2020-03-10T18:26:55Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {", "originalCommit": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4MTQxOA==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r391181418", "bodyText": "Agreed, fixed, thanks", "author": "atris", "createdAt": "2020-03-11T18:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMzQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyMzk2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390523963", "bodyText": "we should never use generic types without type parameters, can you address all these compilation warnings?", "author": "jpountz", "createdAt": "2020-03-10T18:27:43Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future<C>> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {", "originalCommit": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyNTkwMw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r390525903", "bodyText": "this has the same effect as futures.add(task) unless I'm missing something", "author": "jpountz", "createdAt": "2020-03-10T18:30:51Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public <C> List<Future<C>> invokeAll(Collection<FutureTask<C>> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    List<Future<C>> futures = new ArrayList();\n+\n+    int i = 0;\n+\n+    for (FutureTask task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, futures, shouldExecuteOnCallerThread);\n+      ++i;\n+    }\n+\n+    return futures;\n+  }\n+\n+  // Helper method to execute a single task\n+  protected <C> void processTask(final FutureTask<C> task, final List<Future<C>> futures,\n+                             final boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+        futures.add(task);\n+\n+        return;\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+      }\n+    }\n+\n+    runTaskOnCallerThread(task);\n+\n+    try {\n+      futures.add(CompletableFuture.completedFuture(task.get()));", "originalCommit": "b0f3886e064ae1ef73c498df3fe6f4bb6c0aa3ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MDI4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400480289", "bodyText": "maybe do assert (sliceExecutor == null) == (executor==null); which is shorter and not harder to read?", "author": "jpountz", "createdAt": "2020-03-30T20:41:03Z", "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -208,9 +210,22 @@ public IndexSearcher(IndexReader r, Executor executor) {\n    * @lucene.experimental\n    */\n   public IndexSearcher(IndexReaderContext context, Executor executor) {\n+    this(context, executor, getSliceExecutionControlPlane(executor));\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutor sliceExecutor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n+    if (executor == null) {\n+      assert sliceExecutor == null;\n+    }\n+    if (sliceExecutor == null) {\n+      assert executor == null;\n+    }", "originalCommit": "1b8e10b15248593f94419f55bbc86b9b90448b75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MzA1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400483056", "bodyText": "I believe you meant tasks, not threads.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * threads should be active. If the limit is exceeded, further segments are searched on the caller thread\n          \n          \n            \n             * tasks should be active. If the limit is exceeded, further segments are searched on the caller thread", "author": "jpountz", "createdAt": "2020-03-30T20:46:19Z", "path": "lucene/core/src/java/org/apache/lucene/search/QueueSizeBasedExecutor.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ThreadPoolExecutor;\n+\n+/**\n+ * Derivative of SliceExecutor that controls the number of active threads\n+ * that are used for a single query. At any point, no more than (maximum pool size of the executor * LIMITING_FACTOR)\n+ * threads should be active. If the limit is exceeded, further segments are searched on the caller thread", "originalCommit": "1b8e10b15248593f94419f55bbc86b9b90448b75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4Njk4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400486985", "bodyText": "do we really need a helper for this?", "author": "jpountz", "createdAt": "2020-03-30T20:53:32Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {\n+  private final Executor executor;\n+\n+  public SliceExecutor(Executor executor) {\n+    this.executor = executor;\n+  }\n+\n+  public void invokeAll(Collection<? extends Runnable> tasks) {\n+\n+    if (tasks == null) {\n+      throw new IllegalArgumentException(\"Tasks is null\");\n+    }\n+\n+    if (executor == null) {\n+      throw new IllegalArgumentException(\"Executor is null\");\n+    }\n+\n+    int i = 0;\n+\n+    for (Runnable task : tasks) {\n+      boolean shouldExecuteOnCallerThread = false;\n+\n+      // Execute last task on caller thread\n+      if (i == tasks.size() - 1) {\n+        shouldExecuteOnCallerThread = true;\n+      }\n+\n+      processTask(task, shouldExecuteOnCallerThread);\n+      ++i;\n+    };\n+  }\n+\n+  // Helper method to execute a single task\n+  protected void processTask(final Runnable task,\n+                             final boolean shouldExecuteOnCallerThread) {\n+    if (task == null) {\n+      throw new IllegalArgumentException(\"Input is null\");\n+    }\n+\n+    if (!shouldExecuteOnCallerThread) {\n+      try {\n+        executor.execute(task);\n+\n+        return;\n+      } catch (RejectedExecutionException e) {\n+        // Execute on caller thread\n+      }\n+    }\n+\n+    runTaskOnCallerThread(task);\n+  }\n+\n+  // Private helper method to run a task on the caller thread\n+  private void runTaskOnCallerThread(Runnable task) {\n+    task.run();\n+  }", "originalCommit": "1b8e10b15248593f94419f55bbc86b9b90448b75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0NDQ3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401544477", "bodyText": "Fair point -- I dont know what I was thinking :)", "author": "atris", "createdAt": "2020-04-01T11:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4Njk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTYwNw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400489607", "bodyText": "or just boolean shouldExecuteOnCallerThread = random().nextBoolean()?", "author": "jpountz", "createdAt": "2020-03-30T20:58:24Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +370,82 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, false);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  public void testRandomBlockingCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, true);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  private void runCPTest(ThreadPoolExecutor service, boolean useRandomCP) throws Exception {\n+    SliceExecutor sliceExecutor = useRandomCP == true ? new RandomBlockingSliceExecutor(service) :\n+                                                              new QueueSizeBasedExecutor(service);\n+\n+    IndexSearcher searcher = new IndexSearcher(reader2.getContext(), service, sliceExecutor);\n+\n+    Query queries[] = new Query[] {\n+        new MatchAllDocsQuery(),\n+        new TermQuery(new Term(\"field\", \"1\"))\n+    };\n+    Sort sorts[] = new Sort[] {\n+        null,\n+        new Sort(new SortField(\"field2\", SortField.Type.STRING))\n+    };\n+    ScoreDoc afters[] = new ScoreDoc[] {\n+        null,\n+        new FieldDoc(0, 0f, new Object[] { new BytesRef(\"boo!\") })\n+    };\n+\n+    for (ScoreDoc after : afters) {\n+      for (Query query : queries) {\n+        for (Sort sort : sorts) {\n+          searcher.search(query, Integer.MAX_VALUE);\n+          searcher.searchAfter(after, query, Integer.MAX_VALUE);\n+          if (sort != null) {\n+            searcher.search(query, Integer.MAX_VALUE, sort);\n+            searcher.search(query, Integer.MAX_VALUE, sort, true);\n+            searcher.search(query, Integer.MAX_VALUE, sort, false);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private class RandomBlockingSliceExecutor extends SliceExecutor {\n+\n+    public RandomBlockingSliceExecutor(Executor executor) {\n+      super(executor);\n+    }\n+\n+    @Override\n+    public void invokeAll(Collection<? extends Runnable> tasks){\n+\n+      for (Runnable task : tasks) {\n+        boolean shouldExecuteOnCallerThread = false;\n+\n+        if (random().nextBoolean()) {\n+          shouldExecuteOnCallerThread = true;\n+        }", "originalCommit": "1b8e10b15248593f94419f55bbc86b9b90448b75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MDUxNQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400490515", "bodyText": "should we assert on the results?", "author": "jpountz", "createdAt": "2020-03-30T21:00:05Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +370,82 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, false);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  public void testRandomBlockingCP() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runCPTest(service, true);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  private void runCPTest(ThreadPoolExecutor service, boolean useRandomCP) throws Exception {\n+    SliceExecutor sliceExecutor = useRandomCP == true ? new RandomBlockingSliceExecutor(service) :\n+                                                              new QueueSizeBasedExecutor(service);\n+\n+    IndexSearcher searcher = new IndexSearcher(reader2.getContext(), service, sliceExecutor);\n+\n+    Query queries[] = new Query[] {\n+        new MatchAllDocsQuery(),\n+        new TermQuery(new Term(\"field\", \"1\"))\n+    };\n+    Sort sorts[] = new Sort[] {\n+        null,\n+        new Sort(new SortField(\"field2\", SortField.Type.STRING))\n+    };\n+    ScoreDoc afters[] = new ScoreDoc[] {\n+        null,\n+        new FieldDoc(0, 0f, new Object[] { new BytesRef(\"boo!\") })\n+    };\n+\n+    for (ScoreDoc after : afters) {\n+      for (Query query : queries) {\n+        for (Sort sort : sorts) {\n+          searcher.search(query, Integer.MAX_VALUE);\n+          searcher.searchAfter(after, query, Integer.MAX_VALUE);\n+          if (sort != null) {\n+            searcher.search(query, Integer.MAX_VALUE, sort);\n+            searcher.search(query, Integer.MAX_VALUE, sort, true);\n+            searcher.search(query, Integer.MAX_VALUE, sort, false);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true);\n+            searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false);", "originalCommit": "1b8e10b15248593f94419f55bbc86b9b90448b75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MDg1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400490859", "bodyText": "what is CP the acronym of?", "author": "jpountz", "createdAt": "2020-03-30T21:00:46Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +370,82 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedCP() throws Exception {", "originalCommit": "1b8e10b15248593f94419f55bbc86b9b90448b75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MTA3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r400491077", "bodyText": "why are we not reusing reader1?", "author": "jpountz", "createdAt": "2020-03-30T21:01:14Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -70,13 +75,31 @@ public void setUp() throws Exception {\n     }\n     reader = iw.getReader();\n     iw.close();\n+\n+    Random random = random();\n+    RandomIndexWriter iw2 = new RandomIndexWriter(random(), dir2, newIndexWriterConfig().setMergePolicy(newLogMergePolicy()));\n+    for (int i = 0; i < 100; i++) {\n+      Document doc = new Document();\n+      doc.add(newStringField(\"field\", Integer.toString(i), Field.Store.NO));\n+      doc.add(newStringField(\"field2\", Boolean.toString(i % 2 == 0), Field.Store.NO));\n+      doc.add(new SortedDocValuesField(\"field2\", new BytesRef(Boolean.toString(i % 2 == 0))));\n+      iw2.addDocument(doc);\n+\n+      if (random.nextBoolean()) {\n+        iw2.commit();\n+      }\n+    }\n+    reader2 = iw2.getReader();\n+    iw2.close();", "originalCommit": "1b8e10b15248593f94419f55bbc86b9b90448b75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU0MjI4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401542281", "bodyText": "reader2 has random commits baked into it to ensure random slice distributions each time the test is run.", "author": "atris", "createdAt": "2020-04-01T11:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MTA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1NTM2OQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401555369", "bodyText": "Would it be a problem to add these random commits to the existing reader?", "author": "jpountz", "createdAt": "2020-04-01T11:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MTA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU2NTc3Ng==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401565776", "bodyText": "I did not want to touch the existing reader since it is used by many tests -- dont see any risk though, given the specifics of the tests that use the existing reader, should be safe. Updated, thanks", "author": "atris", "createdAt": "2020-04-01T12:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MTA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4MzAzMg==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401583032", "bodyText": "this is covered by the below assert already?", "author": "jpountz", "createdAt": "2020-04-01T12:40:16Z", "path": "lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java", "diffHunk": "@@ -208,9 +210,21 @@ public IndexSearcher(IndexReader r, Executor executor) {\n    * @lucene.experimental\n    */\n   public IndexSearcher(IndexReaderContext context, Executor executor) {\n+    this(context, executor, getSliceExecutionControlPlane(executor));\n+  }\n+\n+  // Package private for testing\n+  IndexSearcher(IndexReaderContext context, Executor executor, SliceExecutor sliceExecutor) {\n     assert context.isTopLevel: \"IndexSearcher's ReaderContext must be topLevel for reader\" + context.reader();\n+    if (executor == null) {\n+      assert sliceExecutor == null;\n+    }", "originalCommit": "c5e9dbb5bdb498a369afc6b4b1a3d421b1558e14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4NDQ0Mw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r401584443", "bodyText": "we should use assertTrue rather than assert in tests, since the latter only runs when assertions are enabled, and it can be useful to run tests with assertions disabled to make sure that the logic remains correct when assertions are off", "author": "jpountz", "createdAt": "2020-04-01T12:42:40Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java", "diffHunk": "@@ -347,4 +354,89 @@ public void execute(final Runnable runnable) {\n       throw new RejectedExecutionException();\n     }\n   }\n+\n+  public void testQueueSizeBasedSliceExecutor() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runSliceExecutorTest(service, false);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  public void testRandomBlockingSliceExecutor() throws Exception {\n+    ThreadPoolExecutor service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n+        new LinkedBlockingQueue<Runnable>(),\n+        new NamedThreadFactory(\"TestIndexSearcher\"));\n+\n+    runSliceExecutorTest(service, true);\n+\n+    TestUtil.shutdownExecutorService(service);\n+  }\n+\n+  private void runSliceExecutorTest(ThreadPoolExecutor service, boolean useRandomSliceExecutor) throws Exception {\n+    SliceExecutor sliceExecutor = useRandomSliceExecutor == true ? new RandomBlockingSliceExecutor(service) :\n+                                                              new QueueSizeBasedExecutor(service);\n+\n+    IndexSearcher searcher = new IndexSearcher(reader.getContext(), service, sliceExecutor);\n+\n+    Query queries[] = new Query[] {\n+        new MatchAllDocsQuery(),\n+        new TermQuery(new Term(\"field\", \"1\"))\n+    };\n+    Sort sorts[] = new Sort[] {\n+        null,\n+        new Sort(new SortField(\"field2\", SortField.Type.STRING))\n+    };\n+    ScoreDoc afters[] = new ScoreDoc[] {\n+        null,\n+        new FieldDoc(0, 0f, new Object[] { new BytesRef(\"boo!\") })\n+    };\n+\n+    for (ScoreDoc after : afters) {\n+      for (Query query : queries) {\n+        for (Sort sort : sorts) {\n+          searcher.search(query, Integer.MAX_VALUE);\n+          searcher.searchAfter(after, query, Integer.MAX_VALUE);\n+          if (sort != null) {\n+            TopDocs topDocs = searcher.search(query, Integer.MAX_VALUE, sort);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.search(query, Integer.MAX_VALUE, sort, true);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.search(query, Integer.MAX_VALUE, sort, false);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.searchAfter(after, query, Integer.MAX_VALUE, sort);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true);\n+            assert topDocs.totalHits.value > 0;\n+\n+            topDocs = searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false);\n+            assert topDocs.totalHits.value > 0;", "originalCommit": "c5e9dbb5bdb498a369afc6b4b1a3d421b1558e14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "78685d24a194f22b7a4ac0f75070cb3d2e15c460", "url": "https://github.com/apache/lucene-solr/commit/78685d24a194f22b7a4ac0f75070cb3d2e15c460", "message": "Update with more tests and rethought strategy", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "17c275ed33efeac77570d34e23861625da9a1142", "url": "https://github.com/apache/lucene-solr/commit/17c275ed33efeac77570d34e23861625da9a1142", "message": "Update exception handling to reflect original exception stack", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "12bfa34e8b76b0ee3ce9717de52b966789d770a3", "url": "https://github.com/apache/lucene-solr/commit/12bfa34e8b76b0ee3ce9717de52b966789d770a3", "message": "Refactor the check code", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "e9cc78111413002f4206c3854584cade413a55d8", "url": "https://github.com/apache/lucene-solr/commit/e9cc78111413002f4206c3854584cade413a55d8", "message": "Remove the interface", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "415aae16772e6bf39a0181e2d92a661e8411921f", "url": "https://github.com/apache/lucene-solr/commit/415aae16772e6bf39a0181e2d92a661e8411921f", "message": "Change visibility of classes to package-private", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "838c8b3a26fcf02af56a615c7a702dcedbb96d69", "url": "https://github.com/apache/lucene-solr/commit/838c8b3a26fcf02af56a615c7a702dcedbb96d69", "message": "Renaming and better generic typecasting", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "f5dc07ccf2695d66fee76190a1be89ab6b79bb4f", "url": "https://github.com/apache/lucene-solr/commit/f5dc07ccf2695d66fee76190a1be89ab6b79bb4f", "message": "Refactor the core API", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "a57e06191841245ef4b3fe67626bd288cafdfcbb", "url": "https://github.com/apache/lucene-solr/commit/a57e06191841245ef4b3fe67626bd288cafdfcbb", "message": "Precommit failures", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "c8a0d616ede47c3eb10f66bbd74353341ca39e32", "url": "https://github.com/apache/lucene-solr/commit/c8a0d616ede47c3eb10f66bbd74353341ca39e32", "message": "More checkstyle fixes", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "68f1d8bf437e242a635c523d0ecef2cd862586df", "url": "https://github.com/apache/lucene-solr/commit/68f1d8bf437e242a635c523d0ecef2cd862586df", "message": "Fix per comments", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "efe4903b1020c4adba7db456f146bb7e75099f1d", "url": "https://github.com/apache/lucene-solr/commit/efe4903b1020c4adba7db456f146bb7e75099f1d", "message": "Update asserts used", "committedDate": "2020-04-01T14:24:12Z", "type": "commit"}, {"oid": "efe4903b1020c4adba7db456f146bb7e75099f1d", "url": "https://github.com/apache/lucene-solr/commit/efe4903b1020c4adba7db456f146bb7e75099f1d", "message": "Update asserts used", "committedDate": "2020-04-01T14:24:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0ODAzMjc1MQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r648032751", "bodyText": "Was there a reason for not making SliceExecutor public ?\nI'd want to inject my own SliceExecutor without having to fork Lucene", "author": "16pierre", "createdAt": "2021-06-09T07:18:47Z", "path": "lucene/core/src/java/org/apache/lucene/search/SliceExecutor.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import java.util.Collection;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * Executor which is responsible\n+ * for execution of slices based on the current status\n+ * of the system and current system load\n+ */\n+class SliceExecutor {", "originalCommit": "efe4903b1020c4adba7db456f146bb7e75099f1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0ODA0NzczMQ==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r648047731", "bodyText": "Not really. I will fix this and add to current release", "author": "atris", "createdAt": "2021-06-09T07:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0ODAzMjc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0OTkyMzc4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1294#discussion_r649923783", "bodyText": "Great thanks a lot !\nWhile I'm at it:\nthe reduce operation also runs on the main thread, it would be lovely to make this configurable.\nGlad to put up a PR for it if I find time. I'd hesitate between adding some more methods on SliceExecutor, or plumbing the reduce executor totally independently.\nThe name SliceExecutor feels awkward if we also add logic for reduce there. Since SliceExecutor wasn't public, maybe we can still afford a rename ?", "author": "16pierre", "createdAt": "2021-06-11T12:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0ODAzMjc1MQ=="}], "type": "inlineReview"}]}