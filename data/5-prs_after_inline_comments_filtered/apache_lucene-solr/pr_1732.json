{"pr_number": 1732, "pr_title": "Clean up many small fixes", "pr_createdAt": "2020-08-10T18:42:20Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1732", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjI0Ng==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468106246", "bodyText": "Can you not change those scopes in public API classes? This applies here and in other places -- protected changed to package-scope for source is not really an API-compatible change.", "author": "dweiss", "createdAt": "2020-08-10T18:46:05Z", "path": "lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java", "diffHunk": "@@ -94,7 +94,7 @@\n    * Create a new Analyzer, reusing the same set of components per-thread\n    * across calls to {@link #tokenStream(String, Reader)}. \n    */\n-  public Analyzer() {", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMDUzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468220535", "bodyText": "I understand that it's notionally an API change, but abstract classes have no reason for public constructors. We can make everything protected and the subclasses that people use will be able to pick it up. I was over-zealous in a couple places going to package instead of protected, I'll fix that up.", "author": "madrob", "createdAt": "2020-08-10T22:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2NjgwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468366809", "bodyText": "The constructors I understand, fine (although it's really a no-op change, as you indicated).", "author": "dweiss", "createdAt": "2020-08-11T06:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjY0Mw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468106643", "bodyText": "This is wrong, uses default locale.", "author": "dweiss", "createdAt": "2020-08-10T18:46:51Z", "path": "lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java", "diffHunk": "@@ -709,7 +709,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n \n           PendingTerm term = (PendingTerm) ent;\n \n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + new String(term.termBytes) + \" prefix=\" + prefix;", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMDY4NA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468220684", "bodyText": "Are these UTF-8? I wasn't sure, and hoped somebody would let me know during review.", "author": "madrob", "createdAt": "2020-08-10T22:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjY0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2NzE0OA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468367148", "bodyText": "They should be. You can also dump it as a byte array for consistency with other changes you made.", "author": "dweiss", "createdAt": "2020-08-11T07:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzM2OA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468107368", "bodyText": "previous version was correct camel case (upTo).", "author": "dweiss", "createdAt": "2020-08-10T18:48:22Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocValuesUpdate.java", "diffHunk": "@@ -152,12 +152,12 @@ static BytesRef readFrom(DataInput in, BytesRef scratch) throws IOException {\n     }\n \n     NumericDocValuesUpdate(Term term, String field, Long value) {\n-      this(term, field, value != null ? value.longValue() : -1, BufferedUpdates.MAX_INT, value != null);\n+      this(term, field, value != null ? value : -1, BufferedUpdates.MAX_INT, value != null);\n     }\n \n \n-    private NumericDocValuesUpdate(Term term, String field, long value, int docIDUpTo, boolean hasValue) {", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMTYzMA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468221630", "bodyText": "There were 16 instances of Upto and 4 of UpTo so I went with the more common one for consistency. Happy to switch the other way if it's more correct according to English. Looking it up now and looks like \"upto\" isn't a word?", "author": "madrob", "createdAt": "2020-08-10T22:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNzM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwODI0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468108241", "bodyText": "These are serious changes... you're adding synchronization on core classes. I don't think they should be piggybacked on top of trivial ones - I'm sure @s1monw would chip in whether this synchronization here makes sense but he'll probably overlook if it's a bulk of trivial changes on top.", "author": "dweiss", "createdAt": "2020-08-10T18:49:59Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java", "diffHunk": "@@ -324,12 +324,12 @@ synchronized void doOnAbort(DocumentsWriterPerThread perThread) {\n     }\n   }\n \n-  private void checkoutAndBlock(DocumentsWriterPerThread perThread) {\n+  private synchronized void checkoutAndBlock(DocumentsWriterPerThread perThread) {", "originalCommit": "fc43993f1962dcf4e907c85f5a2b85b239b8fad2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMTY5MQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468221691", "bodyText": "I'll split this out.", "author": "madrob", "createdAt": "2020-08-10T22:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwODI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNzA5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468227099", "bodyText": "https://issues.apache.org/jira/browse/LUCENE-9453 I explain in that issue why I believe it is minor, but it will help to get more eyes on it", "author": "madrob", "createdAt": "2020-08-10T22:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwODI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2OTQwMA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468369400", "bodyText": "Leave this as it was (with throw ...) - don't know whether IntelliJ is smart enough to detect this method always throws an exception but other compilers are not (and this ensures the compiler sees it as a the only codepath leaving the clause).", "author": "dweiss", "createdAt": "2020-08-11T07:05:48Z", "path": "lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java", "diffHunk": "@@ -440,7 +440,7 @@ public static final SegmentInfos readCommit(Directory directory, ChecksumIndexIn\n       if (format >= VERSION_70) { // oldest supported version\n         CodecUtil.checkFooter(input, priorE);\n       } else {\n-        throw IOUtils.rethrowAlways(priorE);", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzMTM5NA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468631394", "bodyText": "The original compiler complaint was that the throw is inside the finally block. Could I replace the \"Unreachable code\" at the end with this rethrow? I believe the logic will be the same.", "author": "madrob", "createdAt": "2020-08-11T14:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2OTQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTU5MA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r469031590", "bodyText": "And what's wrong about a throw from within finally? A finally block is technically just a block of code, like any other. The compiler very likely assumes you're suppressing an exception if you throw from within finally but it's not the case here.\nI don't know if moving that throw will change the logic. Maybe not. Maybe yes. Given the two options, I wouldn't touch it. My concern was that you slipped such things as part of an otherwise \"trivial\" set of patches.", "author": "dweiss", "createdAt": "2020-08-12T06:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM2OTQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MDc1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468370752", "bodyText": "that 'term' class (PendingTerm) actually has a perfectly fine toString method... why not just remove termBytes and let it do its job?", "author": "dweiss", "createdAt": "2020-08-11T07:08:50Z", "path": "lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java", "diffHunk": "@@ -709,7 +710,8 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n \n           PendingTerm term = (PendingTerm) ent;\n \n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MDgxNQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468370815", "bodyText": "Same here.", "author": "dweiss", "createdAt": "2020-08-11T07:08:59Z", "path": "lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java", "diffHunk": "@@ -741,7 +743,8 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n \n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371162", "bodyText": "Don't change to package private scope here. It will prevent subclasses from outside of the package from accessing those fields (and there may be classes outside of Lucene code doing that).", "author": "dweiss", "createdAt": "2020-08-11T07:09:47Z", "path": "lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java", "diffHunk": "@@ -367,12 +367,12 @@ public void close() {\n     /**\n      * Original source of the tokens.\n      */\n-    protected final Consumer<Reader> source;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3NDc3OQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468374779", "bodyText": "Removing this would break many outside analyzers. I know it's seldom that analyzers access these fields, but this is a real backward breaking change. Don't do this.\nI have no problem with the ctors, but here it's serious! Why did Intellij suggest a change like that? Looks like it was not so intelligent. \ud83e\udd28", "author": "uschindler", "createdAt": "2020-08-11T07:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3NjA2OA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468376068", "bodyText": "There's also no risk somebody could do anything wrong. It's both (also next one) final field and the it's for consuming only.", "author": "uschindler", "createdAt": "2020-08-11T07:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyMjg3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468622877", "bodyText": "I think it's because the field is final and there is a getter for it, so the code analyzer prefers encapsulation?", "author": "madrob", "createdAt": "2020-08-11T14:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNzkzOA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r469027938", "bodyText": "Maybe. It doesn't matter though - this changes the API of a class that's been there for ages. I bet there is a class out there somewhere (let's say A extends Analyzer) and another one (B extends A) where A overrides the getter but B reaches out for the original field. Do we want this to break just to hide a field that can be useful for subclasses just to silence an automatic code inspection? I don't think we should.", "author": "dweiss", "createdAt": "2020-08-12T06:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTIyNA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371224", "bodyText": "Same here.", "author": "dweiss", "createdAt": "2020-08-11T07:09:55Z", "path": "lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java", "diffHunk": "@@ -367,12 +367,12 @@ public void close() {\n     /**\n      * Original source of the tokens.\n      */\n-    protected final Consumer<Reader> source;\n+    final Consumer<Reader> source;\n     /**\n      * Sink tokenstream, such as the outer tokenfilter decorating\n      * the chain. This can be the source if there are no filters.\n      */\n-    protected final TokenStream sink;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTQ1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371459", "bodyText": "term has a toString method - use it.", "author": "dweiss", "createdAt": "2020-08-11T07:10:22Z", "path": "lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java", "diffHunk": "@@ -604,7 +605,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           assert ent.isTerm: \"i=\" + i;\n \n           PendingTerm term = (PendingTerm) ent;\n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM3MTQ5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r468371496", "bodyText": "term has a toString method - use it.", "author": "dweiss", "createdAt": "2020-08-11T07:10:26Z", "path": "lucene/codecs/src/java/org/apache/lucene/codecs/blocktreeords/OrdsBlockTreeTermsWriter.java", "diffHunk": "@@ -640,7 +641,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           PendingEntry ent = pending.get(i);\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;", "originalCommit": "3c2b03513ec4cdfe3c1ffe9a9681907c26b8d066", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f1bc86221bcab1095b29128cf99307e83e60eaba", "url": "https://github.com/apache/lucene-solr/commit/f1bc86221bcab1095b29128cf99307e83e60eaba", "message": "Clean up many small fixes\n\n* Abstract classes don't need public constructors since they can only be\n  called by subclasses\n* Don't escape html characters in @code tags in javadoc\n* Fixed a few int/long arithmetic\n* Use explicit Term.toString instead of implicit byte[].toString\n* Javadoc typos\n* Consistent capitalization for field and parameter names", "committedDate": "2020-08-16T02:25:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTEwNw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075107", "bodyText": "I didn't look at the code but this looks suspicious. The reordering here changes happens-before relationship between these statements. Please leave the order of assignment of tail as it was (inside the locked block).", "author": "dweiss", "createdAt": "2020-08-16T06:59:19Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue.java", "diffHunk": "@@ -510,8 +510,8 @@ public String toString() {\n   }\n   \n   private boolean forceApplyGlobalSlice() {", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTUwNg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075506", "bodyText": "inconsistent with other calls (should use term.toString())?", "author": "dweiss", "createdAt": "2020-08-16T07:03:34Z", "path": "lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java", "diffHunk": "@@ -582,7 +583,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           assert ent.isTerm: \"i=\" + i;\n \n           PendingTerm term = (PendingTerm) ent;\n-          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;\n+          assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2MDcyOA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r473360728", "bodyText": "yikes, thank you.", "author": "madrob", "createdAt": "2020-08-19T21:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTUzMg==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075532", "bodyText": "term.toString() again?", "author": "dweiss", "createdAt": "2020-08-16T07:03:53Z", "path": "lucene/sandbox/src/java/org/apache/lucene/codecs/idversion/VersionBlockTreeTermsWriter.java", "diffHunk": "@@ -610,7 +611,7 @@ private PendingBlock writeBlock(int prefixLength, boolean isFloor, int floorLead\n           PendingEntry ent = pending.get(i);\n           if (ent.isTerm) {\n             PendingTerm term = (PendingTerm) ent;\n-            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + term.termBytes + \" prefix=\" + prefix;\n+            assert StringHelper.startsWith(term.termBytes, prefix): \"term.term=\" + Arrays.toString(term.termBytes) + \" prefix=\" + prefix;", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTY3NA==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r471075674", "bodyText": "Since you're cleaning up I think it'd be better to use assertThrows() with lambda...", "author": "dweiss", "createdAt": "2020-08-16T07:05:26Z", "path": "lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java", "diffHunk": "@@ -504,8 +504,8 @@ protected void assertEquals(RandomTokenStream tk, FieldType ft, Terms terms) thr\n           }\n           try {", "originalCommit": "f1bc86221bcab1095b29128cf99307e83e60eaba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM5NDEzNw==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r473394137", "bodyText": "So it turns out be be less clean, since two of the implementations throw IllegalStateException and two throw AssertionError.", "author": "madrob", "createdAt": "2020-08-19T22:36:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMzczOQ==", "url": "https://github.com/apache/lucene-solr/pull/1732#discussion_r473913739", "bodyText": "@jpountz  may be interested in why this is inconsistent between implementations?", "author": "dweiss", "createdAt": "2020-08-20T11:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA3NTY3NA=="}], "type": "inlineReview"}, {"oid": "ea68d599aa5ad0705228365af0592d5cc861a84d", "url": "https://github.com/apache/lucene-solr/commit/ea68d599aa5ad0705228365af0592d5cc861a84d", "message": "Clean up many small fixes\n\n* Abstract classes don't need public constructors since they can only be\n  called by subclasses\n* Don't escape html characters in @code tags in javadoc\n* Fixed a few int/long arithmetic\n* Use explicit Term.toString instead of implicit byte[].toString\n* Javadoc typos\n* Consistent capitalization for field and parameter names", "committedDate": "2020-09-04T15:34:57Z", "type": "commit"}, {"oid": "ea68d599aa5ad0705228365af0592d5cc861a84d", "url": "https://github.com/apache/lucene-solr/commit/ea68d599aa5ad0705228365af0592d5cc861a84d", "message": "Clean up many small fixes\n\n* Abstract classes don't need public constructors since they can only be\n  called by subclasses\n* Don't escape html characters in @code tags in javadoc\n* Fixed a few int/long arithmetic\n* Use explicit Term.toString instead of implicit byte[].toString\n* Javadoc typos\n* Consistent capitalization for field and parameter names", "committedDate": "2020-09-04T15:34:57Z", "type": "forcePushed"}]}