{"pr_number": 1504, "pr_title": "SOLR-14462: cache more than one autoscaling session", "pr_createdAt": "2020-05-11T12:58:59Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1504", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNDA5NQ==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425424095", "bodyText": "Minor: \"requirees\" -> requires", "author": "megancarey", "createdAt": "2020-05-14T20:54:17Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -382,45 +383,55 @@ static MapWriter loggingInfo(Policy policy, SolrCloudManager cloudManager, Sugge\n   }\n \n   public enum Status {\n-    NULL,\n-    //it is just created and not yet used or all operations on it has been completed fully\n-    UNUSED,\n-    COMPUTING, EXECUTING\n+    COMPUTING, // A command is actively using and modifying the session to compute placements\n+    EXECUTING // A command is not done yet processing its changes but no longer uses the session\n   }\n \n   /**\n-   * This class stores a session for sharing purpose. If a process creates a session to\n-   * compute operations,\n-   * 1) see if there is a session that is available in the cache,\n-   * 2) if yes, check if it is expired\n-   * 3) if it is expired, create a new session\n-   * 4) if it is not expired, borrow it\n-   * 5) after computing operations put it back in the cache\n+   * This class stores sessions for sharing purposes. If a process requirees a session to", "originalCommit": "808b966f2dc89b1f4388c41f41394c68516332ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkxOTY2OQ==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r427919669", "bodyText": "Thanks. I have the MacBook Pro butterfly keyboard, it's a catastrophe!", "author": "murblanc", "createdAt": "2020-05-20T10:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNDA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyOTcxMw==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425429713", "bodyText": "Assuming the thread could be waiting on the lockObj for a while, it might make more sense to leave at the beginning of the critical section?", "author": "megancarey", "createdAt": "2020-05-14T21:04:56Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n+        // If nothing in the cache can possibly work, create a new session\n+        if (!hasNonExpiredSession(zkVersion, oldestUpdateTimeNs)) {\n           return createSession(cloudManager);\n-        } else {\n+        }\n+\n+        // Try to find a session available right away\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        } else if (allowWait) {\n+          // No session available, but if we wait a bit, maybe one can become available\n+          // wait 1 to 10 secs in case a session is returned. Random to spread wakeup otherwise sessions not reused\n+          long waitForMs = (long) (Math.random() * 9 * 1000 + 1000);\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING. starting wait of {}ms\", waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+\n+          // Try again to find an available session\n+          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+          if (sw != null) {\n             if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n+              log.debug(\"Wait over. reusing an existing session {}\", sw.getCreateTime());\n             }\n+            return sw;\n+          } else {\n+            return createSession(cloudManager);\n           }\n+        } else {\n+          return createSession(cloudManager);\n         }\n       }\n     }\n \n+    /**\n+     * Returns an available session from the cache (the best one once cache strategies are defined), or null if no session\n+     * from the cache is available (i.e. all are still COMPUTING, are too old, wrong zk version or the cache is empty).<p>\n+     * This method must be called while holding the monitor on {@link #lockObj}.<p>\n+     * The method updates the session status to computing.\n+     */\n+    private SessionWrapper getAvailableSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.status == Status.EXECUTING && sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          sw.status = Status.COMPUTING;\n+          return sw;\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Returns true if there's a session in the cache that could be returned (if it was free). This is required to\n+     * know if there's any point in waiting or if a new session should better be created right away.\n+     */\n+    private boolean hasNonExpiredSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+\n     private SessionWrapper createSession(SolrCloudManager cloudManager) throws InterruptedException, IOException {\n-      synchronized (lockObj) {\n+      if (log.isDebugEnabled()) {", "originalCommit": "808b966f2dc89b1f4388c41f41394c68516332ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyMTU2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r427921563", "bodyText": "From a timing perspective you're right. I was trying to minimize non necessary activity done while holding the lock. I'll put the log back inside the synchronized block since the logging delay is negligible compared to the wait for a session to become free.", "author": "murblanc", "createdAt": "2020-05-20T11:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyOTcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3NDk5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425474999", "bodyText": "Nit: rename to \"hasViableSession\" or something since it also requires zkVersion check", "author": "megancarey", "createdAt": "2020-05-14T22:55:43Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n+        // If nothing in the cache can possibly work, create a new session\n+        if (!hasNonExpiredSession(zkVersion, oldestUpdateTimeNs)) {\n           return createSession(cloudManager);\n-        } else {\n+        }\n+\n+        // Try to find a session available right away\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        } else if (allowWait) {\n+          // No session available, but if we wait a bit, maybe one can become available\n+          // wait 1 to 10 secs in case a session is returned. Random to spread wakeup otherwise sessions not reused\n+          long waitForMs = (long) (Math.random() * 9 * 1000 + 1000);\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING. starting wait of {}ms\", waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+\n+          // Try again to find an available session\n+          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+          if (sw != null) {\n             if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n+              log.debug(\"Wait over. reusing an existing session {}\", sw.getCreateTime());\n             }\n+            return sw;\n+          } else {\n+            return createSession(cloudManager);\n           }\n+        } else {\n+          return createSession(cloudManager);\n         }\n       }\n     }\n \n+    /**\n+     * Returns an available session from the cache (the best one once cache strategies are defined), or null if no session\n+     * from the cache is available (i.e. all are still COMPUTING, are too old, wrong zk version or the cache is empty).<p>\n+     * This method must be called while holding the monitor on {@link #lockObj}.<p>\n+     * The method updates the session status to computing.\n+     */\n+    private SessionWrapper getAvailableSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.status == Status.EXECUTING && sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          sw.status = Status.COMPUTING;\n+          return sw;\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Returns true if there's a session in the cache that could be returned (if it was free). This is required to\n+     * know if there's any point in waiting or if a new session should better be created right away.\n+     */\n+    private boolean hasNonExpiredSession(int zkVersion, long oldestUpdateTimeNs) {", "originalCommit": "808b966f2dc89b1f4388c41f41394c68516332ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyMzYyNg==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r427923626", "bodyText": "hasCandidateSession", "author": "murblanc", "createdAt": "2020-05-20T11:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3NDk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4MzQ1NA==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425483454", "bodyText": "Do we know how many sessions we might have at any given time? Could this be expensive? I suppose it guarantees savings of 1-10 seconds in cases where allowWait is true and there's nothing worth waiting for; just wondering what average case scenario is", "author": "megancarey", "createdAt": "2020-05-14T23:24:09Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n+        // If nothing in the cache can possibly work, create a new session\n+        if (!hasNonExpiredSession(zkVersion, oldestUpdateTimeNs)) {\n           return createSession(cloudManager);\n-        } else {\n+        }\n+\n+        // Try to find a session available right away\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        } else if (allowWait) {\n+          // No session available, but if we wait a bit, maybe one can become available\n+          // wait 1 to 10 secs in case a session is returned. Random to spread wakeup otherwise sessions not reused\n+          long waitForMs = (long) (Math.random() * 9 * 1000 + 1000);\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING. starting wait of {}ms\", waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+\n+          // Try again to find an available session\n+          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+          if (sw != null) {\n             if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n+              log.debug(\"Wait over. reusing an existing session {}\", sw.getCreateTime());\n             }\n+            return sw;\n+          } else {\n+            return createSession(cloudManager);\n           }\n+        } else {\n+          return createSession(cloudManager);\n         }\n       }\n     }\n \n+    /**\n+     * Returns an available session from the cache (the best one once cache strategies are defined), or null if no session\n+     * from the cache is available (i.e. all are still COMPUTING, are too old, wrong zk version or the cache is empty).<p>\n+     * This method must be called while holding the monitor on {@link #lockObj}.<p>\n+     * The method updates the session status to computing.\n+     */\n+    private SessionWrapper getAvailableSession(int zkVersion, long oldestUpdateTimeNs) {\n+      for (SessionWrapper sw : sessionWrapperSet) {\n+        if (sw.status == Status.EXECUTING && sw.getLastUpdateTime() >= oldestUpdateTimeNs && sw.zkVersion == zkVersion) {\n+          sw.status = Status.COMPUTING;\n+          return sw;\n+        }\n+      }\n+      return null;\n+    }\n+\n+    /**\n+     * Returns true if there's a session in the cache that could be returned (if it was free). This is required to\n+     * know if there's any point in waiting or if a new session should better be created right away.\n+     */\n+    private boolean hasNonExpiredSession(int zkVersion, long oldestUpdateTimeNs) {", "originalCommit": "808b966f2dc89b1f4388c41f41394c68516332ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkyNDg4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r427924889", "bodyText": "Under low load, there should be 0 or 1 sessions. More than that implies a lot of concurrent commands and the iteration here is negligible. A Session is released as soon as it is possible to  do so, when all commands that have been using it have completed.", "author": "murblanc", "createdAt": "2020-05-20T11:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4MzQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4ODk5NA==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r425488994", "bodyText": "Wrote up a slightly different implementation here: https://gist.github.com/megancarey/ae2bad53d320ef660ef45c8b003901e1\nNo more redundant code but I suppose worse in terms of memory, since it makes a recursive call", "author": "megancarey", "createdAt": "2020-05-14T23:43:09Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +440,124 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n \n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {", "originalCommit": "808b966f2dc89b1f4388c41f41394c68516332ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzMDU0OA==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r427930548", "bodyText": "Thanks. I feel it makes the flow a bit harder to read and the savings are not huge so I prefer to stick to the original structure of this method.\n(the memory impact is negligible IMO. There's also an additional call to hasNonExpiredSession in the proposal but again no big deal)", "author": "murblanc", "createdAt": "2020-05-20T11:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4ODk5NA=="}], "type": "inlineReview"}, {"oid": "fa6aea1e6828cd442af3cdaefbacd192e3a9cfcf", "url": "https://github.com/apache/lucene-solr/commit/fa6aea1e6828cd442af3cdaefbacd192e3a9cfcf", "message": "SOLR-14462 initial. Cahcing multuiple Autoscaling sessions. Tests not run.", "committedDate": "2020-05-20T10:48:48Z", "type": "commit"}, {"oid": "2c3a361a6715709bc2b353a60001796525486367", "url": "https://github.com/apache/lucene-solr/commit/2c3a361a6715709bc2b353a60001796525486367", "message": "SOLR-14462 added unit test for multi session cache", "committedDate": "2020-05-20T10:48:49Z", "type": "commit"}, {"oid": "f725053f5fef3e1b540711e192accbe9aaf43fba", "url": "https://github.com/apache/lucene-solr/commit/f725053f5fef3e1b540711e192accbe9aaf43fba", "message": "fix gradle precommit issues and minor changes from PR comments", "committedDate": "2020-05-20T11:23:11Z", "type": "commit"}, {"oid": "8e09f8fabe9bc87c263476467dd13b611c77c80e", "url": "https://github.com/apache/lucene-solr/commit/8e09f8fabe9bc87c263476467dd13b611c77c80e", "message": "Get Session creation outside of the critical session of session wrapper management", "committedDate": "2020-05-20T16:39:48Z", "type": "commit"}, {"oid": "8e09f8fabe9bc87c263476467dd13b611c77c80e", "url": "https://github.com/apache/lucene-solr/commit/8e09f8fabe9bc87c263476467dd13b611c77c80e", "message": "Get Session creation outside of the critical session of session wrapper management", "committedDate": "2020-05-20T16:39:48Z", "type": "forcePushed"}, {"oid": "bfa7753932f60c0e76b508b850db1a890d314b54", "url": "https://github.com/apache/lucene-solr/commit/bfa7753932f60c0e76b508b850db1a890d314b54", "message": "Make gradle precommit happy", "committedDate": "2020-05-20T16:59:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3NzU2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428377565", "bodyText": "Minor: \"yeet\" \ud83d\ude04", "author": "megancarey", "createdAt": "2020-05-21T00:14:38Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -382,45 +383,78 @@ static MapWriter loggingInfo(Policy policy, SolrCloudManager cloudManager, Sugge\n   }\n \n   public enum Status {\n-    NULL,\n-    //it is just created and not yet used or all operations on it has been completed fully\n-    UNUSED,\n-    COMPUTING, EXECUTING\n+    /**\n+     * A command is actively using and modifying the session to compute placements\n+     */\n+    COMPUTING,\n+    /**\n+     * A command is not done yet processing its changes but no longer updates or even uses the session\n+     */\n+    EXECUTING\n   }\n \n   /**\n-   * This class stores a session for sharing purpose. If a process creates a session to\n-   * compute operations,\n-   * 1) see if there is a session that is available in the cache,\n-   * 2) if yes, check if it is expired\n-   * 3) if it is expired, create a new session\n-   * 4) if it is not expired, borrow it\n-   * 5) after computing operations put it back in the cache\n+   * This class stores sessions for sharing purposes. If a process requires a session to\n+   * compute operations:\n+   * <ol>\n+   * <li>see if there is an available non expired session in the cache,</li>\n+   * <li>if yes, borrow it.</li>\n+   * <li>if no, create a new one and borrow it.</li>\n+   * <li>after computing (update) operations are done, {@link #returnSession(SessionWrapper)} back to the cache so it's\n+   * again available for borrowing.</li>\n+   * <li>after all borrowers are done computing then executing with the session, {@link #release(SessionWrapper)} it,\n+   * which removes it from the cache.</li>\n+   * </ol>\n    */\n   static class SessionRef {\n+    /**\n+     * Lock protecting access to {@link #sessionWrapperSet} and to {@link #creationsInProgress}\n+     */\n     private final Object lockObj = new Object();\n-    private SessionWrapper sessionWrapper = SessionWrapper.DEFAULT_INSTANCE;\n \n+    /**\n+     * Sessions currently in use in {@link Status#COMPUTING} or {@link Status#EXECUTING} states. As soon as all\n+     * uses of a session are over, that session is removed from this set. Sessions not actively in use are NOT kept around.\n+     *\n+     * <p>Access should only be done under the protection of {@link #lockObj}</p>\n+     */\n+    private Set<SessionWrapper> sessionWrapperSet = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+\n+    /**\n+     * Number of sessions currently being created but not yeet present in {@link #sessionWrapperSet}.", "originalCommit": "bfa7753932f60c0e76b508b850db1a890d314b54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1NzIwNg==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428457206", "bodyText": "Think different", "author": "murblanc", "createdAt": "2020-05-21T05:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3NzU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODAwMA==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428378000", "bodyText": "Minor: over-indented?", "author": "megancarey", "createdAt": "2020-05-21T00:15:57Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -382,45 +383,78 @@ static MapWriter loggingInfo(Policy policy, SolrCloudManager cloudManager, Sugge\n   }\n \n   public enum Status {\n-    NULL,\n-    //it is just created and not yet used or all operations on it has been completed fully\n-    UNUSED,\n-    COMPUTING, EXECUTING\n+    /**\n+     * A command is actively using and modifying the session to compute placements\n+     */\n+    COMPUTING,\n+    /**\n+     * A command is not done yet processing its changes but no longer updates or even uses the session\n+     */\n+    EXECUTING\n   }\n \n   /**\n-   * This class stores a session for sharing purpose. If a process creates a session to\n-   * compute operations,\n-   * 1) see if there is a session that is available in the cache,\n-   * 2) if yes, check if it is expired\n-   * 3) if it is expired, create a new session\n-   * 4) if it is not expired, borrow it\n-   * 5) after computing operations put it back in the cache\n+   * This class stores sessions for sharing purposes. If a process requires a session to\n+   * compute operations:\n+   * <ol>\n+   * <li>see if there is an available non expired session in the cache,</li>\n+   * <li>if yes, borrow it.</li>\n+   * <li>if no, create a new one and borrow it.</li>\n+   * <li>after computing (update) operations are done, {@link #returnSession(SessionWrapper)} back to the cache so it's\n+   * again available for borrowing.</li>\n+   * <li>after all borrowers are done computing then executing with the session, {@link #release(SessionWrapper)} it,\n+   * which removes it from the cache.</li>\n+   * </ol>\n    */\n   static class SessionRef {\n+    /**\n+     * Lock protecting access to {@link #sessionWrapperSet} and to {@link #creationsInProgress}\n+     */\n     private final Object lockObj = new Object();\n-    private SessionWrapper sessionWrapper = SessionWrapper.DEFAULT_INSTANCE;\n \n+    /**\n+     * Sessions currently in use in {@link Status#COMPUTING} or {@link Status#EXECUTING} states. As soon as all\n+     * uses of a session are over, that session is removed from this set. Sessions not actively in use are NOT kept around.\n+     *\n+     * <p>Access should only be done under the protection of {@link #lockObj}</p>\n+     */\n+    private Set<SessionWrapper> sessionWrapperSet = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+\n+    /**\n+     * Number of sessions currently being created but not yeet present in {@link #sessionWrapperSet}.\n+     *\n+     * <p>Access should only be done under the protection of {@link #lockObj}</p>\n+     */\n+    private int creationsInProgress = 0;\n \n     public SessionRef() {\n     }\n \n-\n-    //only for debugging\n-    SessionWrapper getSessionWrapper() {\n-      return sessionWrapper;\n+    // used only by tests\n+    boolean isEmpty() {\n+      synchronized (lockObj) {\n+        return sessionWrapperSet.isEmpty();\n+      }\n     }\n \n     /**\n      * All operations suggested by the current session object\n      * is complete. Do not even cache anything\n      */\n     private void release(SessionWrapper sessionWrapper) {\n+      boolean present;\n       synchronized (lockObj) {\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime && this.sessionWrapper.refCount.get() <= 0) {\n-          log.debug(\"session set to NULL\");\n-          this.sessionWrapper = SessionWrapper.DEFAULT_INSTANCE;\n-        } // else somebody created a new session b/c of expiry . So no need to do anything about it\n+        present = sessionWrapperSet.remove(sessionWrapper);\n+      }\n+      if (!present) {\n+        log.warn(\"released session {} not found in session set\", sessionWrapper.getCreateTime());\n+      } else {\n+          TimeSource timeSource = sessionWrapper.session.cloudManager.getTimeSource();", "originalCommit": "bfa7753932f60c0e76b508b850db1a890d314b54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1NzA2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428457066", "bodyText": "Look ok to me", "author": "murblanc", "createdAt": "2020-05-21T05:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3OTA0NA==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428379044", "bodyText": "Minor: put allowWait at beginning of check to short-circuit if allowWait is false", "author": "megancarey", "createdAt": "2020-05-21T00:19:54Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +463,149 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        // Important to wake up a single one, otherwise of multiple waiting threads, all but one will immediately create new sessions\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n-\n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    /**\n+     * <p>Method returning an available session that can be used for {@link Status#COMPUTING}, either from the\n+     * {@link #sessionWrapperSet} cache or by creating a new one. The status of the returned session is set to {@link Status#COMPUTING}.</p>\n+     *\n+     * Some waiting is done in two cases:\n+     * <ul>\n+     *   <li>A candidate session is present in {@link #sessionWrapperSet} but is still {@link Status#COMPUTING}, a random wait\n+     *   is observed to see if the session gets freed to save a session creation and allow session reuse,</li>\n+     *   <li>It is necessary to create a new session but there are already sessions in the process of being created, a\n+     *   random wait is observed (if no waiting already occurred waiting for a session to become free) before creation\n+     *   takes place, just in case one of the created sessions got used then {@link #returnSession(SessionWrapper)} in the meantime.</li>\n+     * </ul>\n+     *\n+     * The random wait prevents the \"thundering herd\" effect when all threads needing a session at the same time create a new\n+     * one even though some differentiated waits could have led to better reuse and less session creations.\n+     *\n+     * @param allowWait usually <code>true</code> except in tests that know there's no point in waiting because nothing\n+     *                  will happen...\n+     */\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n-          return createSession(cloudManager);\n-        } else {\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        // Best case scenario: an available session\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        }\n+\n+        // Wait for a while before deciding what to do if waiting could help...\n+        if ((creationsInProgress != 0 || hasCandidateSession(zkVersion, oldestUpdateTimeNs)) && allowWait) {", "originalCommit": "bfa7753932f60c0e76b508b850db1a890d314b54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1NTI5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428455296", "bodyText": "Put it in purpose at the end: it's only true in tests", "author": "murblanc", "createdAt": "2020-05-21T05:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3OTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3OTk1MQ==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428379951", "bodyText": "I think we want to put lines 543-552 in the if statement, since we probably don't want to check for an available session twice in  immediate succession if allowWait is false/there are no candidate sessions to wait for.", "author": "megancarey", "createdAt": "2020-05-21T00:23:15Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/PolicyHelper.java", "diffHunk": "@@ -429,87 +463,149 @@ private void release(SessionWrapper sessionWrapper) {\n      * The session can be used by others while the caller is performing operations\n      */\n     private void returnSession(SessionWrapper sessionWrapper) {\n-      TimeSource timeSource = sessionWrapper.session != null ? sessionWrapper.session.cloudManager.getTimeSource() : TimeSource.NANO_TIME;\n+      boolean present;\n       synchronized (lockObj) {\n         sessionWrapper.status = Status.EXECUTING;\n-        if (log.isDebugEnabled()) {\n-          log.debug(\"returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} \"\n-              , time(timeSource, MILLISECONDS),\n-              sessionWrapper.createTime,\n-              this.sessionWrapper.createTime);\n-        }\n-        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {\n-          //this session was used for computing new operations and this can now be used for other\n-          // computing\n-          this.sessionWrapper = sessionWrapper;\n+        present = sessionWrapperSet.contains(sessionWrapper);\n \n-          //one thread who is waiting for this need to be notified.\n-          lockObj.notify();\n-        } else {\n-          log.debug(\"create time NOT SAME {} \", SessionWrapper.DEFAULT_INSTANCE.createTime);\n-          //else just ignore it\n-        }\n+        // wake up single thread waiting for a session return (ok if not woken up, wait is short)\n+        // Important to wake up a single one, otherwise of multiple waiting threads, all but one will immediately create new sessions\n+        lockObj.notify();\n       }\n \n+      // Logging\n+      if (present) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"returnSession {}\", sessionWrapper.getCreateTime());\n+        }\n+      } else {\n+        log.warn(\"returning unknown session {} \", sessionWrapper.getCreateTime());\n+      }\n     }\n \n-\n-    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {\n+    /**\n+     * <p>Method returning an available session that can be used for {@link Status#COMPUTING}, either from the\n+     * {@link #sessionWrapperSet} cache or by creating a new one. The status of the returned session is set to {@link Status#COMPUTING}.</p>\n+     *\n+     * Some waiting is done in two cases:\n+     * <ul>\n+     *   <li>A candidate session is present in {@link #sessionWrapperSet} but is still {@link Status#COMPUTING}, a random wait\n+     *   is observed to see if the session gets freed to save a session creation and allow session reuse,</li>\n+     *   <li>It is necessary to create a new session but there are already sessions in the process of being created, a\n+     *   random wait is observed (if no waiting already occurred waiting for a session to become free) before creation\n+     *   takes place, just in case one of the created sessions got used then {@link #returnSession(SessionWrapper)} in the meantime.</li>\n+     * </ul>\n+     *\n+     * The random wait prevents the \"thundering herd\" effect when all threads needing a session at the same time create a new\n+     * one even though some differentiated waits could have led to better reuse and less session creations.\n+     *\n+     * @param allowWait usually <code>true</code> except in tests that know there's no point in waiting because nothing\n+     *                  will happen...\n+     */\n+    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {\n       TimeSource timeSource = cloudManager.getTimeSource();\n+      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;\n+      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();\n+\n       synchronized (lockObj) {\n-        if (sessionWrapper.status == Status.NULL ||\n-            sessionWrapper.zkVersion != cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion() ||\n-            TimeUnit.SECONDS.convert(timeSource.getTimeNs() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {\n-          //no session available or the session is expired\n-          return createSession(cloudManager);\n-        } else {\n+        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);\n+\n+        // Best case scenario: an available session\n+        if (sw != null) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"reusing session {}\", sw.getCreateTime());\n+          }\n+          return sw;\n+        }\n+\n+        // Wait for a while before deciding what to do if waiting could help...\n+        if ((creationsInProgress != 0 || hasCandidateSession(zkVersion, oldestUpdateTimeNs)) && allowWait) {\n+          // Either an existing session might be returned and become usable while we wait, or a session in the process of being\n+          // created might finish creation, be used then returned and become usable. So we wait.\n+          // wait 1 to 10 secs. Random to help spread wakeups.\n+          long waitForMs = (long) (Math.random() * 9 * 1000) + 1000;\n+\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"No sessions are available, all busy COMPUTING (or {} creations in progress). starting wait of {}ms\",\n+                creationsInProgress, waitForMs);\n+          }\n           long waitStart = time(timeSource, MILLISECONDS);\n-          //the session is not expired\n-          log.debug(\"reusing a session {}\", this.sessionWrapper.createTime);\n-          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-            this.sessionWrapper.status = Status.COMPUTING;\n-            return sessionWrapper;\n-          } else {\n-            //status= COMPUTING it's being used for computing. computing is\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"session being used. waiting... current time {} \", time(timeSource, MILLISECONDS));\n-            }\n-            try {\n-              lockObj.wait(10 * 1000);//wait for a max of 10 seconds\n-            } catch (InterruptedException e) {\n-              log.info(\"interrupted... \");\n-            }\n-            if (log.isDebugEnabled()) {\n-              log.debug(\"out of waiting curr-time:{} time-elapsed {}\"\n-                  , time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));\n-            }\n-            // now this thread has woken up because it got timed out after 10 seconds or it is notified after\n-            // the session was returned from another COMPUTING operation\n-            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {\n-              log.debug(\"Wait over. reusing the existing session \");\n-              this.sessionWrapper.status = Status.COMPUTING;\n-              return sessionWrapper;\n-            } else {\n-              //create a new Session\n-              return createSession(cloudManager);\n-            }\n+          try {\n+            lockObj.wait(waitForMs);\n+          } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"out of waiting. wait of {}ms, actual time elapsed {}ms\", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));\n+          }\n+        }\n+\n+        // We've waited (or not), now we can either reuse immediately an available session, or immediately create a new one", "originalCommit": "bfa7753932f60c0e76b508b850db1a890d314b54", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MzQ3OQ==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428383479", "bodyText": "Might want to add a test for creationsInProgress? But would probably require refactoring/exposing creationsInProgress", "author": "megancarey", "createdAt": "2020-05-21T00:36:05Z", "path": "solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy.java", "diffHunk": "@@ -1709,13 +1708,134 @@ public DistribStateManager getDistribStateManager() {\n     assertEquals(2, s1.getRefCount());\n \n     s2[0].release();\n-    assertFalse(sessionRef.getSessionWrapper() == PolicyHelper.SessionWrapper.DEFAULT_INSTANCE);\n+    assertFalse(sessionRef.isEmpty());\n     s1.release();\n-    assertTrue(sessionRef.getSessionWrapper() == PolicyHelper.SessionWrapper.DEFAULT_INSTANCE);\n+    assertTrue(sessionRef.isEmpty());\n \n \n   }\n \n+  @Test", "originalCommit": "bfa7753932f60c0e76b508b850db1a890d314b54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1NzQ0NA==", "url": "https://github.com/apache/lucene-solr/pull/1504#discussion_r428457444", "bodyText": "Yes. Not sure it's worth it. We'll see what others think.", "author": "murblanc", "createdAt": "2020-05-21T05:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MzQ3OQ=="}], "type": "inlineReview"}, {"oid": "8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "url": "https://github.com/apache/lucene-solr/commit/8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "message": "minor changes", "committedDate": "2020-05-21T05:58:28Z", "type": "commit"}, {"oid": "8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "url": "https://github.com/apache/lucene-solr/commit/8fec381d81acfe57514e7b4a0a9d8a5036f87e32", "message": "minor changes", "committedDate": "2020-05-21T05:58:28Z", "type": "forcePushed"}, {"oid": "730999e5f9859792bdb9dbba51e3a309cc3d9d6f", "url": "https://github.com/apache/lucene-solr/commit/730999e5f9859792bdb9dbba51e3a309cc3d9d6f", "message": "Merge branch 'master' into SOLR-14462", "committedDate": "2020-06-24T18:02:48Z", "type": "commit"}, {"oid": "0bbc1a58a822e17913f2832883d5d4c9ac151706", "url": "https://github.com/apache/lucene-solr/commit/0bbc1a58a822e17913f2832883d5d4c9ac151706", "message": "SOLR-14462: clean up test and remove warnings", "committedDate": "2020-06-24T18:17:20Z", "type": "commit"}]}