{"pr_number": 1548, "pr_title": "SOLR-14524: Harden MultiThreadedOCPTest testFillWorkQueue()", "pr_createdAt": "2020-06-01T09:14:50Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1548", "timeline": [{"oid": "2991445da7db2d203fee3efdc85b8d0a9a5543d1", "url": "https://github.com/apache/lucene-solr/commit/2991445da7db2d203fee3efdc85b8d0a9a5543d1", "message": "SOLR-14524: make MultiThreadedOCPTest.testFillWorkQueue() less vulnerable to timing issues", "committedDate": "2020-06-01T09:05:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4NzQ5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433287496", "bodyText": "I found this section a little bit hard to read, would prefer something more verbose but potentially easier to understand at a glance.", "author": "madrob", "createdAt": "2020-06-01T15:01:27Z", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;", "originalCommit": "2991445da7db2d203fee3efdc85b8d0a9a5543d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NzE5MQ==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433397191", "bodyText": "Extracted two methods and simplified flow.", "author": "murblanc", "createdAt": "2020-06-01T18:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4NzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MTI4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433291286", "bodyText": "I think one way to make this cleaner is to extract getStatusResponse().getResponse.get(\"MOCK_FINISHED\") out into a separate method.", "author": "madrob", "createdAt": "2020-06-01T15:07:49Z", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");", "originalCommit": "2991445da7db2d203fee3efdc85b8d0a9a5543d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MjI3Mg==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433292272", "bodyText": "Do we really care about checking for a3 here? Why not check once after the loop?", "author": "madrob", "createdAt": "2020-06-01T15:09:34Z", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;\n       for (int i = 0; i < 500; i++) {\n-        if (bcoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"200\", client);\n-          bcoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"2\", client);\n-          acoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n+        if (acoll3 == null) {", "originalCommit": "2991445da7db2d203fee3efdc85b8d0a9a5543d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NjUzNw==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433396537", "bodyText": "moved", "author": "murblanc", "createdAt": "2020-06-01T17:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5Mjg3NA==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433292874", "bodyText": "Assuming the queue works as advertised, can we skip checking a0 and only check a1?", "author": "madrob", "createdAt": "2020-06-01T15:10:34Z", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {", "originalCommit": "2991445da7db2d203fee3efdc85b8d0a9a5543d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NjcyNA==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433396724", "bodyText": "Removed check for task 0, left only task 1", "author": "murblanc", "createdAt": "2020-06-01T17:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5Mjg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MzI1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433293256", "bodyText": "Inconsistent naming: acoll0, acoll1, then acoll3.", "author": "madrob", "createdAt": "2020-06-01T15:11:11Z", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -79,40 +78,57 @@ private void testFillWorkQueue() throws Exception {\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n             ASYNC, String.valueOf(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n+      }\n \n+      // Wait until we see the first two A_COLL tasks getting processed\n+      boolean acoll0done = false, acoll1done = false;\n+      for (int i = 0; i < 500; i++) {\n+        if (!acoll0done) {\n+          acoll0done = null != getStatusResponse(\"0\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (!acoll1done) {\n+          acoll1done = null != getStatusResponse(\"1\", client).getResponse().get(\"MOCK_FINISHED\");\n+        }\n+        if (acoll0done && acoll1done) break;\n+        Thread.sleep(100);\n       }\n-      Thread.sleep(100);//wait and post the next message\n+      assertTrue(\"Queue did not process first two tasks on A_COLL, can't run test\", acoll0done && acoll1done);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", getStatusResponse(\"2\", client).getResponse().get(\"MOCK_FINISHED\"));\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n-\n-      Long acoll = null, bcoll = null;\n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long acoll3 = null, bcoll = null;", "originalCommit": "2991445da7db2d203fee3efdc85b8d0a9a5543d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NjgzMw==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r433396833", "bodyText": "Thanks. Fixed.", "author": "murblanc", "createdAt": "2020-06-01T18:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5MzI1Ng=="}], "type": "inlineReview"}, {"oid": "481408a6b07d3dc9e469e329c7341d85a6b3a120", "url": "https://github.com/apache/lucene-solr/commit/481408a6b07d3dc9e469e329c7341d85a6b3a120", "message": "SOLR-14524: comments from madrob", "committedDate": "2020-06-01T17:44:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgyNjcwOA==", "url": "https://github.com/apache/lucene-solr/pull/1548#discussion_r434826708", "bodyText": "nit: javadoc complains about this not being a visible reference", "author": "madrob", "createdAt": "2020-06-03T20:13:34Z", "path": "solr/core/src/test/org/apache/solr/cloud/MultiThreadedOCPTest.java", "diffHunk": "@@ -77,42 +76,68 @@ private void testFillWorkQueue() throws Exception {\n         distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n             \"collection\", \"A_COLL\",\n             QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n-            ASYNC, String.valueOf(i),\n+            ASYNC, Integer.toString(i),\n \n-            \"sleep\", (i == 0 ? \"1000\" : \"1\") //first task waits for 1 second, and thus blocking\n-            // all other tasks. Subsequent tasks only wait for 1ms\n+            // third task waits for a long time, and thus blocks the queue for all other tasks for A_COLL.\n+            // Subsequent tasks as well as the first two only wait for 1ms\n+            \"sleep\", (i == 2 ? \"10000\" : \"1\")\n         )));\n         log.info(\"MOCK task added {}\", i);\n-\n       }\n-      Thread.sleep(100);//wait and post the next message\n \n-      //this is not going to be blocked because it operates on another collection\n+      // Wait until we see the second A_COLL task getting processed (assuming the first got processed as well)\n+      Long task1CollA = waitForTaskToCompleted(client, 1);\n+\n+      assertNotNull(\"Queue did not process first two tasks on A_COLL, can't run test\", task1CollA);\n+\n+      // Make sure the long running task did not finish, otherwise no way the B_COLL task can be tested to run in parallel with it\n+      assertNull(\"Long running task finished too early, can't test\", checkTaskHasCompleted(client, 2));\n+\n+      // Enqueue a task on another collection not competing with the lock on A_COLL and see that it can be executed right away\n       distributedQueue.offer(Utils.toJSON(Utils.makeMap(\n           \"collection\", \"B_COLL\",\n           QUEUE_OPERATION, MOCK_COLL_TASK.toLower(),\n           ASYNC, \"200\",\n           \"sleep\", \"1\"\n       )));\n \n+      // We now check that either the B_COLL task has completed before the third (long running) task on A_COLL,\n+      // Or if both have completed (if this check got significantly delayed for some reason), we verify B_COLL was first.\n+      Long taskCollB = waitForTaskToCompleted(client, 200);\n \n-      Long acoll = null, bcoll = null;\n-      for (int i = 0; i < 500; i++) {\n-        if (bcoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"200\", client);\n-          bcoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll == null) {\n-          CollectionAdminResponse statusResponse = getStatusResponse(\"2\", client);\n-          acoll = (Long) statusResponse.getResponse().get(\"MOCK_FINISHED\");\n-        }\n-        if (acoll != null && bcoll != null) break;\n-        Thread.sleep(100);\n+      // We do not wait for the long running task to finish, that would be a waste of time.\n+      Long task2CollA = checkTaskHasCompleted(client, 2);\n+\n+      // Given the wait delay (500 iterations of 100ms), the task has plenty of time to complete, so this is not expected.\n+      assertNotNull(\"Task on  B_COLL did not complete, can't test\", taskCollB);\n+      // We didn't wait for the 3rd A_COLL task to complete (test can run quickly) but if it did, we expect the B_COLL to have finished first.\n+      assertTrue(\"task2CollA: \" + task2CollA + \" taskCollB: \" + taskCollB, task2CollA  == null || task2CollA > taskCollB);\n+    }\n+  }\n+\n+  /**\n+   * Verifies the status of an async task submitted to the Overseer Collection queue.\n+   * @return <code>null</code> if the task has not completed, the completion timestamp if the task has completed\n+   * (see {@link org.apache.solr.cloud.api.collections.OverseerCollectionMessageHandler#mockOperation}).", "originalCommit": "481408a6b07d3dc9e469e329c7341d85a6b3a120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0925f90960dd2264ffb162ab481976f1fb0ce283", "url": "https://github.com/apache/lucene-solr/commit/0925f90960dd2264ffb162ab481976f1fb0ce283", "message": "SOLR-14524: make javadoc happy by removing reference to private method", "committedDate": "2020-06-04T00:12:43Z", "type": "commit"}]}