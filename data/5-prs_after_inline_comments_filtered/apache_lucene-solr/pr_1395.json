{"pr_number": 1395, "pr_title": "SOLR-14365: CollapsingQParser - Avoiding always allocate int[] and float[] with size equals to number of unique values (WIP)", "pr_createdAt": "2020-04-02T08:04:33Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1395", "timeline": [{"oid": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "url": "https://github.com/apache/lucene-solr/commit/0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "message": "SOLR-14365: CollapsingQParser - Avoiding always allocate int[] and float[] with size equals to number of unique values (WIP)", "committedDate": "2020-04-02T08:03:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5ODkzNA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402198934", "bodyText": "Should be named \"capacity\" rather than \"size\".", "author": "bruno-roustant", "createdAt": "2020-04-02T10:06:46Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/IntIntArrayBasedMap.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.IntConsumer;\n+\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntIntArrayBasedMap implements IntIntMap {\n+\n+  private int size;", "originalCommit": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwMDA5Mg==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402200092", "bodyText": "keyValues.length is a capacity while size() semantics is more a size: the current number of entries in the map. We should return a counter instead.", "author": "bruno-roustant", "createdAt": "2020-04-02T10:08:48Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/IntIntArrayBasedMap.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.IntConsumer;\n+\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntIntArrayBasedMap implements IntIntMap {\n+\n+  private int size;\n+  private int[] keyValues;\n+  private int emptyValue;\n+\n+  public IntIntArrayBasedMap(int initialSize, int emptyValue) {\n+    this.size = initialSize;\n+    this.keyValues = new int[initialSize];\n+    this.emptyValue = emptyValue;\n+    if (emptyValue != 0) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+  }\n+\n+  @Override\n+  public void set(int key, int value) {\n+    if (key >= size) {\n+      keyValues = ArrayUtil.grow(keyValues);\n+      if (emptyValue != 0) {\n+        for (int i = size; i < keyValues.length; i++) {\n+          keyValues[i] = emptyValue;\n+        }\n+      }\n+      size = keyValues.length;\n+    }\n+    keyValues[key] = value;\n+  }\n+\n+  @Override\n+  public int get(int key) {\n+    if (key >= size) {\n+      return emptyValue;\n+    }\n+    return keyValues[key];\n+  }\n+\n+  @Override\n+  public void forEachValue(IntConsumer consumer) {\n+    for (int val: keyValues) {\n+      if (val != emptyValue) {\n+        consumer.accept(val);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void remove(int key) {\n+    if (key < size) keyValues[key] = emptyValue;\n+  }\n+\n+  @Override\n+  public int size() {\n+    return keyValues.length;", "originalCommit": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NzAxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402687019", "bodyText": "Thanks! This kinda like a debug method and I will delete it.", "author": "CaoManhDat", "createdAt": "2020-04-03T01:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwMDA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwMTM5NA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402201394", "bodyText": "Here keyValues is enlarged (based on its current capacity), but are we sure it is enlarged enough to hold \"key\"?", "author": "bruno-roustant", "createdAt": "2020-04-02T10:11:05Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/IntIntArrayBasedMap.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.IntConsumer;\n+\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntIntArrayBasedMap implements IntIntMap {\n+\n+  private int size;\n+  private int[] keyValues;\n+  private int emptyValue;\n+\n+  public IntIntArrayBasedMap(int initialSize, int emptyValue) {\n+    this.size = initialSize;\n+    this.keyValues = new int[initialSize];\n+    this.emptyValue = emptyValue;\n+    if (emptyValue != 0) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+  }\n+\n+  @Override\n+  public void set(int key, int value) {\n+    if (key >= size) {\n+      keyValues = ArrayUtil.grow(keyValues);", "originalCommit": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NzExMg==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402687112", "bodyText": "oh, right! :+1", "author": "CaoManhDat", "createdAt": "2020-04-03T01:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwMTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwNzIzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402207235", "bodyText": "I agree that we should use primitive map instead of array if we don't load enough arrays. The speed of the map put/get is sufficiently fast that I suppose it should not be visible in the overall perf of this CollapsingQParser.\nBut do we need to have a new factory for primitive map to switch between hash map and array? I think we could need this if we often had both cases (high load and low load of the array) AND if we had a way to switch automatically. But I suppose we don't know in advance (so we don't switch auto), and that most often the load is low.\nSo I suggest that we don't add the complexity of these new classes (the new util.numeric package) and we just use HPPC primitive map directly.", "author": "bruno-roustant", "createdAt": "2020-04-02T10:21:58Z", "path": "solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java", "diffHunk": "@@ -524,6 +533,7 @@ public int docID() {\n \n     public OrdScoreCollector(int maxDoc,\n                              int segments,\n+                             PrimitiveMapFactory mapFactory,", "originalCommit": "0d82a9f5cdac67c9de92c979e016c1c6b1f8dcf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5MTg4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402691881", "bodyText": "That is what I thought in the first place and HPPC primitive map did gave a very good result in our performance test on large collection (number of unique values in the collapsing field is 1.2million), around 5x better in qps.\nBut when I write a simple single-thread benchmark test (I can add it here in this PR so you can try to tune it).\n\nNumber of docs are 300k\n95% percent of queries are sparse ones so we only doing collapsing on 1% of docs.\n\nArray approach actually do better than map (around 1.5x better). The reason for that is\n\nWe don't now how much size we gonna need for the map, so we pay lot of cost on resizing the map.\nMap needs 2 array for storing key and value seperately, plus with above point it leads to more memory usage.\n\nI just don't want to do a commit that can potentially slow down users. Although switching to HPPC primitive map is much easier and makes thing simple for me.\nAny idea on this @dsmiley @shalinmangar @joel-bernstein", "author": "CaoManhDat", "createdAt": "2020-04-03T01:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwNzIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxMTYyNA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402711624", "bodyText": "I suggest we take inspiration from two similar places in Lucene/Solr:  org.apache.lucene.util.DocIdSetBuilder and org.apache.solr.search.DocSetBuilder which are doing essentially the same thing.  Basically, start with a memory efficient data structure, and then once we reach a threshold, switch on the fly to a larger but more efficient structure.\nSo start with a hash based map with a substantial initial capacity (not 4!), then upgrade to an array based map impl instead of resizing the map if we exceed that capacity.  This might be done with a map impl that delegates to the real impl (hppc) with switch/resize logic.", "author": "dsmiley", "createdAt": "2020-04-03T03:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwNzIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNTQzNw==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r402825437", "bodyText": "If some preliminary perf tests show that sometime the array version is clearly faster, then I agree we should invest in an automated switch logic. But in this case the interfaces presented in this PR do not fit this switch logic: we should be able to change the underlying implementation of the map seamlessly. This is more work.\nI would like to understand better the simple benchmark test you did, because the reason for the speed/memory difference is still not obvious to me.\n\n95% percent of queries are sparse ones so we only doing collapsing on 1% of docs.\n\nDoes that mean that only 1% of the 300K docs are put in the map?\nSo on the map implementation side we have an internal capacity of 2^12 (4K) or 2^13 (8K) for 2 arrays.\nOn the array implementation side we have 1 array of 300K.\nFor the memory the map is more efficient. For the speed, it will depend on the actual load factor and the map implementation.\n\nSo start with a hash based map with a substantial initial capacity (not 4!), then upgrade to an array based map impl\n\nOr maybe the reverse? This depends on the map load factor.", "author": "bruno-roustant", "createdAt": "2020-04-03T08:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwNzIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQxNjQ0NA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r403416444", "bodyText": "Ok then I will add the benchmark class here and may be delete it in subsequence commits.", "author": "CaoManhDat", "createdAt": "2020-04-04T03:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwNzIzNQ=="}], "type": "inlineReview"}, {"oid": "1190118cfe8c4ccb5c564d0fdc712f6a12372d39", "url": "https://github.com/apache/lucene-solr/commit/1190118cfe8c4ccb5c564d0fdc712f6a12372d39", "message": "Adding benchmark", "committedDate": "2020-04-04T03:22:45Z", "type": "commit"}, {"oid": "a1be3dd08f506990b81e7aae08aa6a4ec8ec869f", "url": "https://github.com/apache/lucene-solr/commit/a1be3dd08f506990b81e7aae08aa6a4ec8ec869f", "message": "SOLR-14365: Switch to dynamic map", "committedDate": "2020-04-07T09:26:24Z", "type": "commit"}, {"oid": "05e40c11a837fc732158d35e8d228337e434e9ae", "url": "https://github.com/apache/lucene-solr/commit/05e40c11a837fc732158d35e8d228337e434e9ae", "message": "Comments update", "committedDate": "2020-04-07T09:27:46Z", "type": "commit"}, {"oid": "66de7721d182defb4b8143063cc1f6b0d3fc4963", "url": "https://github.com/apache/lucene-solr/commit/66de7721d182defb4b8143063cc1f6b0d3fc4963", "message": "Remove benchmark code", "committedDate": "2020-04-07T09:28:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NTkwOA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r404785908", "bodyText": "Safer to add +1\n(int) (threshold(expectedMaxSize) / HashContainers.DEFAULT_LOAD_FACTOR) + 1", "author": "bruno-roustant", "createdAt": "2020-04-07T12:56:00Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/DynamicMap.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import com.carrotsearch.hppc.HashContainers;\n+\n+public interface DynamicMap {\n+  static boolean useArrayBased(int expectedMaxSize) {\n+    // for small size, prefer using array based\n+    return expectedMaxSize < (1 << 12);\n+  }\n+\n+  static int threshold(int expectedMaxSize) {\n+    return expectedMaxSize >>> 6;\n+  }\n+\n+  static int mapExpectedElements(int expectedMaxSize) {\n+    return (int) (threshold(expectedMaxSize) / HashContainers.DEFAULT_LOAD_FACTOR);", "originalCommit": "66de7721d182defb4b8143063cc1f6b0d3fc4963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM1NTkzNw==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405355937", "bodyText": "why it is safer?", "author": "CaoManhDat", "createdAt": "2020-04-08T08:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NTkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NjUyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r404786529", "bodyText": "Safer to test >=\nif (this.hashMap.size() >= threshold) {", "author": "bruno-roustant", "createdAt": "2020-04-07T12:56:59Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+import static org.apache.solr.util.numeric.DynamicMap.mapExpectedElements;\n+import static org.apache.solr.util.numeric.DynamicMap.threshold;\n+import static org.apache.solr.util.numeric.DynamicMap.useArrayBased;\n+\n+public class IntFloatDynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  public IntFloatDynamicMap(int expectedMaxSize, float emptyValue) {\n+    this.threshold = threshold(expectedMaxSize);\n+    this.maxSize = expectedMaxSize;\n+    this.emptyValue = emptyValue;\n+    if (useArrayBased(expectedMaxSize)) {\n+      upgradeToArray();\n+    } else {\n+      this.hashMap = new IntFloatHashMap(mapExpectedElements(expectedMaxSize));\n+    }\n+  }\n+\n+  private void upgradeToArray() {\n+    keyValues = new float[maxSize];\n+    if (emptyValue != 0.0f) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+    if (hashMap != null) {\n+      hashMap.forEach((IntFloatProcedure) (key, value) -> keyValues[key] = value);\n+      hashMap = null;\n+    }\n+  }\n+\n+  private void growBuffer(int minSize) {\n+    assert keyValues != null;\n+    int size = keyValues.length;\n+    keyValues = ArrayUtil.grow(keyValues, minSize);\n+    if (emptyValue != 0.0f) {\n+      for (int i = size; i < keyValues.length; i++) {\n+        keyValues[i] = emptyValue;\n+      }\n+    }\n+  }\n+\n+\n+  public void set(int key, float value) {\n+    if (keyValues != null) {\n+      if (key >= keyValues.length) {\n+        growBuffer(key + 1);\n+      }\n+      keyValues[key] = value;\n+    } else {\n+      this.hashMap.put(key, value);\n+      this.maxSize = Math.max(key, maxSize);\n+      if (this.hashMap.size() > threshold) {", "originalCommit": "66de7721d182defb4b8143063cc1f6b0d3fc4963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM1NjE2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405356167", "bodyText": "why it is safer?", "author": "CaoManhDat", "createdAt": "2020-04-08T08:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NjUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ3ODcxNw==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405478717", "bodyText": "Did you test and debug when the DynamicMap upgrades from a map to an array internally? I mean in debug mode step by step here. I think the map first enlarges and rehashes just before the upgrade to an array.\nLet's take an example with expectedKeyMax = 500K.\nthis.threshold = threshold(expectedKeyMax) = 500000/64 = 7812\nIntFloatHashMap initial capacity = mapExpectedElements(expectedKeyMax) = (int) (threshold(expectedKeyMax) / 0.75f) = (int) (7812 / 0.75f) = 10416\nIntFloatHashMap internal threshold = ceil(initial capacity * 0.75) = ceil(10416 * 0.75) = 7812\nInternally the HPPC map enlarges during a put() when its size == 7812 before incrementing the size.\nHere the condition to upgrade to an array triggers when the map size after the put is > 7812, so at 7813.\nSo I think the map first enlarges and rehashes just before we upgrade to an array, which would be wasteful.\nAlso, the map internal threshold is ceil(initial capacity * 0.75), but it could be without ceil() for other implementations. To be safe wrt the float rounding, I suggested to add +1 in DynamicMap. mapExpectedElements(int), but it is probably better to be safe here.", "author": "bruno-roustant", "createdAt": "2020-04-08T12:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc4NjUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MDc3NA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r404980774", "bodyText": "Actually I missed here something risky: what if a large key is provided? We have no protection here yet. Nothing prevents the user to put a key 500M. In this case we should not grow the array too large just for one key.\nMaybe we should have a strong limit on the map capacity in the constructor.", "author": "bruno-roustant", "createdAt": "2020-04-07T17:20:07Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+import static org.apache.solr.util.numeric.DynamicMap.mapExpectedElements;\n+import static org.apache.solr.util.numeric.DynamicMap.threshold;\n+import static org.apache.solr.util.numeric.DynamicMap.useArrayBased;\n+\n+public class IntFloatDynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  public IntFloatDynamicMap(int expectedMaxSize, float emptyValue) {\n+    this.threshold = threshold(expectedMaxSize);\n+    this.maxSize = expectedMaxSize;\n+    this.emptyValue = emptyValue;\n+    if (useArrayBased(expectedMaxSize)) {\n+      upgradeToArray();\n+    } else {\n+      this.hashMap = new IntFloatHashMap(mapExpectedElements(expectedMaxSize));\n+    }\n+  }\n+\n+  private void upgradeToArray() {\n+    keyValues = new float[maxSize];\n+    if (emptyValue != 0.0f) {\n+      Arrays.fill(keyValues, emptyValue);\n+    }\n+    if (hashMap != null) {\n+      hashMap.forEach((IntFloatProcedure) (key, value) -> keyValues[key] = value);\n+      hashMap = null;\n+    }\n+  }\n+\n+  private void growBuffer(int minSize) {\n+    assert keyValues != null;\n+    int size = keyValues.length;\n+    keyValues = ArrayUtil.grow(keyValues, minSize);\n+    if (emptyValue != 0.0f) {\n+      for (int i = size; i < keyValues.length; i++) {\n+        keyValues[i] = emptyValue;\n+      }\n+    }\n+  }\n+\n+\n+  public void set(int key, float value) {\n+    if (keyValues != null) {\n+      if (key >= keyValues.length) {", "originalCommit": "66de7721d182defb4b8143063cc1f6b0d3fc4963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5ODgzNA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405098834", "bodyText": "On a related note, do we even want to bother resizing this array vs size it appropriately up-front?", "author": "dsmiley", "createdAt": "2020-04-07T20:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MDc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQxMTE3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405411173", "bodyText": "The javadoc in the constructor is good, but I'm concerned that this util class may be used elsewhere without clearly reading/understanding the risk. Mainly because the class is named Map, and a Map generally can take any key value.\nCould we create a second constructor with a third param, something like \"hardLimitKeyMax\" which would be checked here otherwise throw an IllegalArgumentException? It could have a default limit of 10x expectedKeyMax in the first constructor for example. And it could be increased if someone knows what she is doing.", "author": "bruno-roustant", "createdAt": "2020-04-08T10:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MDc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2MTg2NA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405061864", "bodyText": "if assertions are enabled, then perhaps return false so as to have tests test the DynamicMap.  I've seen @yonik use this technique in data structure sizing and thought it was clever.", "author": "dsmiley", "createdAt": "2020-04-07T19:34:18Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/DynamicMap.java", "diffHunk": "@@ -17,13 +17,19 @@\n \n package org.apache.solr.util.numeric;\n \n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n+import com.carrotsearch.hppc.HashContainers;\n \n-public interface IntIntMap {\n-  void set(int key, int value);\n-  int get(int key);\n-  void forEachValue(IntConsumer consumer);\n-  void remove(int key);\n-  int size();\n+public interface DynamicMap {\n+  static boolean useArrayBased(int expectedMaxSize) {\n+    // for small data set, prefer using array based\n+    return expectedMaxSize < (1 << 12);", "originalCommit": "a1be3dd08f506990b81e7aae08aa6a4ec8ec869f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NjUwOA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405086508", "bodyText": "+1", "author": "bruno-roustant", "createdAt": "2020-04-07T20:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2MTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2MTk4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405061981", "bodyText": "Needs docs!", "author": "dsmiley", "createdAt": "2020-04-07T19:34:33Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/DynamicMap.java", "diffHunk": "@@ -17,13 +17,19 @@\n \n package org.apache.solr.util.numeric;\n \n-import java.util.function.Consumer;\n-import java.util.function.IntConsumer;\n+import com.carrotsearch.hppc.HashContainers;\n \n-public interface IntIntMap {\n-  void set(int key, int value);\n-  int get(int key);\n-  void forEachValue(IntConsumer consumer);\n-  void remove(int key);\n-  int size();\n+public interface DynamicMap {", "originalCommit": "a1be3dd08f506990b81e7aae08aa6a4ec8ec869f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzIyNw==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405217227", "bodyText": "@dsmiley @bruno-roustant If we do not allow resizing automatically (which I would like to do), then how can we deal with this case?", "author": "CaoManhDat", "createdAt": "2020-04-08T02:08:46Z", "path": "solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.java", "diffHunk": "@@ -2258,29 +2215,20 @@ public void collapse(int collapseKey, int contextDoc, int globalDoc) throws IOEx\n         final int idx;\n         if((idx = cmap.indexOf(collapseKey)) >= 0) {\n           int pointer = cmap.indexGet(idx);\n-          if(comp.test(currentVal, testValues[pointer])) {\n-            testValues[pointer]= currentVal;\n-            docs[pointer] = globalDoc;\n+          if(comp.test(currentVal, testValues.get(pointer))) {\n+            testValues.set(pointer, currentVal);\n+            docs.set(pointer, globalDoc);\n             if(needsScores) {\n-              scores[pointer] = scorer.score();\n+              scores.set(pointer, scorer.score());\n             }\n           }\n         } else {\n           ++index;\n           cmap.put(collapseKey, index);\n-          if(index == testValues.length) {\n-            testValues = ArrayUtil.grow(testValues);", "originalCommit": "66de7721d182defb4b8143063cc1f6b0d3fc4963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxOTcwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405219705", "bodyText": "or we revert this change and handle it later?", "author": "CaoManhDat", "createdAt": "2020-04-08T02:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1Mjc4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405252783", "bodyText": "Thanks for pointing that out; I had thought the numerical range was pre-determined but I see in this scenario (numeric DocValues), it is not.  Keep the resizing in there then; as long as the other cases we size correctly up-front.", "author": "dsmiley", "createdAt": "2020-04-08T04:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNzIyNw=="}], "type": "inlineReview"}, {"oid": "2748def6330d1e7b63bb10e13ab2757d67d4c614", "url": "https://github.com/apache/lucene-solr/commit/2748def6330d1e7b63bb10e13ab2757d67d4c614", "message": "Rename set(key, val) -> put(key, val) and add javadocs", "committedDate": "2020-04-08T08:46:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQwMzAyOA==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405403028", "bodyText": "Javadoc: similar to java.util.function.IntConsumer", "author": "bruno-roustant", "createdAt": "2020-04-08T09:54:56Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/FloatConsumer.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+@FunctionalInterface\n+public interface FloatConsumer {", "originalCommit": "2748def6330d1e7b63bb10e13ab2757d67d4c614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQwNjkzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1395#discussion_r405406935", "bodyText": "We can be explicit and say: more than key x 4B, so for a max key 100M it may allocate more than 400 MB.", "author": "bruno-roustant", "createdAt": "2020-04-08T10:01:25Z", "path": "solr/core/src/java/org/apache/solr/util/numeric/IntFloatDynamicMap.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.util.numeric;\n+\n+import java.util.Arrays;\n+\n+import com.carrotsearch.hppc.IntFloatHashMap;\n+import com.carrotsearch.hppc.cursors.FloatCursor;\n+import com.carrotsearch.hppc.procedures.IntFloatProcedure;\n+import org.apache.lucene.util.ArrayUtil;\n+\n+public class IntFloatDynamicMap implements DynamicMap {\n+  private int maxSize;\n+  private IntFloatHashMap hashMap;\n+  private float[] keyValues;\n+  private float emptyValue;\n+  private int threshold;\n+\n+  /**\n+   * Create map with expected max value of key.\n+   * Although the map will automatically do resizing to be able to hold key >= {@code expectedKeyMax}.\n+   * But putting key much larger than {@code expectedKeyMax} is discourage since it can leads to use LOT OF memory.", "originalCommit": "2748def6330d1e7b63bb10e13ab2757d67d4c614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc4d33f850e8cf11a0616cadc1fef07ed5be9f35", "url": "https://github.com/apache/lucene-solr/commit/cc4d33f850e8cf11a0616cadc1fef07ed5be9f35", "message": "Move classes to util package and adding test", "committedDate": "2020-04-09T02:12:39Z", "type": "commit"}, {"oid": "47a9793a97d3784689d6374769f36c0111adf09c", "url": "https://github.com/apache/lucene-solr/commit/47a9793a97d3784689d6374769f36c0111adf09c", "message": "Fix precommit", "committedDate": "2020-04-09T03:04:50Z", "type": "commit"}, {"oid": "77635050d238c8fbe517fc41b42de5d58d14c0da", "url": "https://github.com/apache/lucene-solr/commit/77635050d238c8fbe517fc41b42de5d58d14c0da", "message": "Update CHANGES", "committedDate": "2020-04-09T06:59:26Z", "type": "commit"}, {"oid": "0e148071042056587bd934796bce3c27da81f922", "url": "https://github.com/apache/lucene-solr/commit/0e148071042056587bd934796bce3c27da81f922", "message": "Merge branch 'master' into jira/SOLR-14365", "committedDate": "2020-04-10T07:51:45Z", "type": "commit"}]}