{"pr_number": 1440, "pr_title": "LUCENE-9330: Make SortFields responsible for index sorting and serialization", "pr_createdAt": "2020-04-20T11:07:28Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1440", "timeline": [{"oid": "f54eb391fa599343745c2e331fe19372499b718b", "url": "https://github.com/apache/lucene-solr/commit/f54eb391fa599343745c2e331fe19372499b718b", "message": "Make SortFields responsible for index sorting and serialization", "committedDate": "2020-04-20T10:56:15Z", "type": "commit"}, {"oid": "6bd0aab1b94b6366eba833827b6e3692ac7dc88b", "url": "https://github.com/apache/lucene-solr/commit/6bd0aab1b94b6366eba833827b6e3692ac7dc88b", "message": "Use SortFieldProvider SPI", "committedDate": "2020-04-20T14:52:38Z", "type": "commit"}, {"oid": "b08ce257e2a2842f53343931d9652839b4d50243", "url": "https://github.com/apache/lucene-solr/commit/b08ce257e2a2842f53343931d9652839b4d50243", "message": "sandbox codecs", "committedDate": "2020-04-20T15:01:03Z", "type": "commit"}, {"oid": "0afbc1d2d7b6fc2c1db75364ac9bc7122fd659e4", "url": "https://github.com/apache/lucene-solr/commit/0afbc1d2d7b6fc2c1db75364ac9bc7122fd659e4", "message": "Further cleanup in DIC", "committedDate": "2020-04-20T19:08:31Z", "type": "commit"}, {"oid": "247ef622e51476a882a8f7cf706968f339d04813", "url": "https://github.com/apache/lucene-solr/commit/247ef622e51476a882a8f7cf706968f339d04813", "message": "javadocs", "committedDate": "2020-04-21T10:19:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwNDc4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412304782", "bodyText": "assert that the bytes have been fully consumed?", "author": "jpountz", "createdAt": "2020-04-21T16:25:46Z", "path": "lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoFormat.java", "diffHunk": "@@ -171,133 +168,17 @@ public SegmentInfo read(Directory directory, String segmentName, byte[] segmentI\n       SortField[] sortField = new SortField[numSortFields];\n       for (int i = 0; i < numSortFields; ++i) {\n         SimpleTextUtil.readLine(input, scratch);\n-        assert StringHelper.startsWith(scratch.get(), SI_SORT_FIELD);\n-        final String field = readString(SI_SORT_FIELD.length, scratch);\n+        assert StringHelper.startsWith(scratch.get(), SI_SORT_NAME);\n+        final String provider = readString(SI_SORT_NAME.length, scratch);\n \n         SimpleTextUtil.readLine(input, scratch);\n         assert StringHelper.startsWith(scratch.get(), SI_SORT_TYPE);\n-        final String typeAsString = readString(SI_SORT_TYPE.length, scratch);\n-\n-        final SortField.Type type;\n-        SortedSetSelector.Type selectorSet = null;\n-        SortedNumericSelector.Type selectorNumeric = null;\n-        switch (typeAsString) {\n-          case \"string\":\n-            type = SortField.Type.STRING;\n-            break;\n-          case \"long\":\n-            type = SortField.Type.LONG;\n-            break;\n-          case \"int\":\n-            type = SortField.Type.INT;\n-            break;\n-          case \"double\":\n-            type = SortField.Type.DOUBLE;\n-            break;\n-          case \"float\":\n-            type = SortField.Type.FLOAT;\n-            break;\n-          case \"multi_valued_string\":\n-            type = SortField.Type.STRING;\n-            selectorSet = readSetSelector(input, scratch);\n-            break;\n-          case \"multi_valued_long\":\n-            type = SortField.Type.LONG;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          case \"multi_valued_int\":\n-            type = SortField.Type.INT;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          case \"multi_valued_double\":\n-            type = SortField.Type.DOUBLE;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          case \"multi_valued_float\":\n-            type = SortField.Type.FLOAT;\n-            selectorNumeric = readNumericSelector(input, scratch);\n-            break;\n-          default:\n-            throw new CorruptIndexException(\"unable to parse sort type string: \" + typeAsString, input);\n-        }\n \n         SimpleTextUtil.readLine(input, scratch);\n-        assert StringHelper.startsWith(scratch.get(), SI_SORT_REVERSE);\n-        final boolean reverse = Boolean.parseBoolean(readString(SI_SORT_REVERSE.length, scratch));\n-\n-        SimpleTextUtil.readLine(input, scratch);\n-        assert StringHelper.startsWith(scratch.get(), SI_SORT_MISSING);\n-        final String missingLastAsString = readString(SI_SORT_MISSING.length, scratch);\n-        final Object missingValue;\n-        switch (type) {\n-          case STRING:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              case \"first\":\n-                missingValue = SortField.STRING_FIRST;\n-                break;\n-              case \"last\":\n-                missingValue = SortField.STRING_LAST;\n-                break;\n-              default:\n-                throw new CorruptIndexException(\"unable to parse missing string: \" + typeAsString, input);\n-            }\n-            break;\n-          case LONG:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Long.parseLong(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          case INT:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Integer.parseInt(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          case DOUBLE:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Double.parseDouble(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          case FLOAT:\n-            switch (missingLastAsString) {\n-              case \"null\":\n-                missingValue = null;\n-                break;\n-              default:\n-                missingValue = Float.parseFloat(missingLastAsString);\n-                break;\n-            }\n-            break;\n-          default:\n-            throw new AssertionError();\n-        }\n-        if (selectorSet != null) {\n-          sortField[i] = new SortedSetSortField(field, reverse);\n-        } else if (selectorNumeric != null) {\n-          sortField[i] = new SortedNumericSortField(field, type, reverse);\n-        } else {\n-          sortField[i] = new SortField(field, type, reverse);\n-        }\n-        if (missingValue != null) {\n-          sortField[i].setMissingValue(missingValue);\n-        }\n+        assert StringHelper.startsWith(scratch.get(), SI_SORT_BYTES);\n+        BytesRef serializedSort = SimpleTextUtil.fromBytesRefString(readString(SI_SORT_BYTES.length, scratch));\n+        final ByteArrayDataInput bytes = new ByteArrayDataInput(serializedSort.bytes, serializedSort.offset, serializedSort.length);\n+        sortField[i] = SortFieldProvider.forName(provider).loadSortField(bytes);", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwODMwOA==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412308308", "bodyText": "can we remove this since getDocValues already returns an iterator? (we might need to do T extends DocIdSetIterator above)", "author": "jpountz", "createdAt": "2020-04-21T16:31:21Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocValuesWriter.java", "diffHunk": "@@ -21,12 +21,10 @@\n \n import org.apache.lucene.codecs.DocValuesConsumer;\n import org.apache.lucene.search.DocIdSetIterator;\n-import org.apache.lucene.search.SortField;\n \n-abstract class DocValuesWriter {\n-  abstract void finish(int numDoc);\n+abstract class DocValuesWriter<T> {\n   abstract void flush(SegmentWriteState state, Sorter.DocMap sortMap, DocValuesConsumer consumer) throws IOException;\n-  abstract Sorter.DocComparator getDocComparator(int numDoc, SortField sortField) throws IOException;\n+  abstract T getDocValues();\n   abstract DocIdSetIterator getDocIdSet();", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMDY2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412310665", "bodyText": "I wonder if it would work to move it to SortFieldProvider instead for symmetry, so that the serialization and deserialization logic would be in the same place.", "author": "jpountz", "createdAt": "2020-04-21T16:34:17Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexSorter.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.LongValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.apache.lucene.util.packed.PackedInts;\n+\n+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;\n+\n+/**\n+ * Handles how documents should be sorted in an index, both within a segment and between\n+ * segments.\n+ *\n+ * Implementers must provide the following methods:\n+ * {@link #getDocComparator(LeafReader)} - an object that determines how documents within a segment are to be sorted\n+ * {@link #getComparableProviders(List)} - an array of objects that return a sortable long value per document and segment\n+ * {@link #serialize(DataOutput)} - how the sort should be written into the segment header\n+ * {@link #getProviderName()} - the SPI-registered name of a {@link SortFieldProvider} to deserialize the sort\n+ *\n+ * The companion {@link SortFieldProvider} should be registered with SPI via {@code META-INF/services}\n+ */\n+public interface IndexSorter {\n+\n+  /** Used for sorting documents across segments */\n+  public interface ComparableProvider {\n+    /**\n+     * Returns a long so that the natural ordering of long values matches the\n+     * ordering of doc IDs for the given comparator\n+     */\n+    long getAsComparableLong(int docID) throws IOException;\n+  }\n+\n+  /** A comparator of doc IDs, used for sorting documents within a segment */\n+  public interface DocComparator {\n+    /** Compare docID1 against docID2. The contract for the return value is the\n+     *  same as {@link Comparator#compare(Object, Object)}. */\n+    int compare(int docID1, int docID2);\n+  }\n+\n+  /**\n+   * Get an array of {@link ComparableProvider}, one per segment, for merge sorting documents in different segments\n+   * @param readers the readers to be merged\n+   */\n+  public abstract ComparableProvider[] getComparableProviders(List<? extends LeafReader> readers) throws IOException;\n+\n+  /**\n+   * Get a comparator that determines the sort order of docs within a single Reader.\n+   *\n+   * NB We cannot simply use the {@link FieldComparator} API because it requires docIDs to be sent\n+   * in-order. The default implementations allocate array[maxDoc] to hold native values for comparison,\n+   * but 1) they are transient (only alive while sorting this one segment) and 2) in the typical\n+   * index sorting case, they are only used to sort newly flushed segments, which will be smaller\n+   * than merged segments\n+   *\n+   * @param reader the Reader to sort\n+   */\n+  public abstract DocComparator getDocComparator(LeafReader reader) throws IOException;\n+\n+  /**\n+   * Serializes the parent SortField.  This is used to write Sort information into the Segment header\n+   *\n+   * @see SortFieldProvider#loadSortField(DataInput)\n+   */\n+  public abstract void serialize(DataOutput out) throws IOException;", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMjg4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412312883", "bodyText": "There is an even nicer syntax now.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(new IndexSorter.DocComparator[0]));\n          \n          \n            \n                return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(IndexSorter.DocComparator[]::new));", "author": "jpountz", "createdAt": "2020-04-21T16:37:27Z", "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -94,29 +89,100 @@ public DefaultIndexingChain(DocumentsWriterPerThread docWriter) {\n     termsHash = new FreqProxTermsWriter(docWriter, termVectorsWriter);\n   }\n \n+  private LeafReader getDocValuesReader(int maxDoc) {\n+    return new DocValuesReader() {\n+      @Override\n+      public NumericDocValues getNumericDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.NUMERIC) {\n+          return (NumericDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n+          return (BinaryDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public SortedDocValues getSortedDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.SORTED) {\n+          return (SortedDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.SORTED_NUMERIC) {\n+          return (SortedNumericDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n+        PerField pf = getPerField(field);\n+        if (pf == null) {\n+          return null;\n+        }\n+        if (pf.fieldInfo.getDocValuesType() == DocValuesType.SORTED_SET) {\n+          return (SortedSetDocValues) pf.docValuesWriter.getDocValues();\n+        }\n+        return null;\n+      }\n+\n+      @Override\n+      public FieldInfos getFieldInfos() {\n+        return fieldInfos.finish();\n+      }\n+\n+      @Override\n+      public int maxDoc() {\n+        return maxDoc;\n+      }\n+    };\n+  }\n+\n   private Sorter.DocMap maybeSortSegment(SegmentWriteState state) throws IOException {\n     Sort indexSort = state.segmentInfo.getIndexSort();\n     if (indexSort == null) {\n       return null;\n     }\n \n-    List<Sorter.DocComparator> comparators = new ArrayList<>();\n+    LeafReader docValuesReader = getDocValuesReader(state.segmentInfo.maxDoc());\n+\n+    List<IndexSorter.DocComparator> comparators = new ArrayList<>();\n     for (int i = 0; i < indexSort.getSort().length; i++) {\n       SortField sortField = indexSort.getSort()[i];\n-      PerField perField = getPerField(sortField.getField());\n-      if (perField != null && perField.docValuesWriter != null &&\n-          finishedDocValues.contains(perField.fieldInfo.name) == false) {\n-          perField.docValuesWriter.finish(state.segmentInfo.maxDoc());\n-          Sorter.DocComparator cmp = perField.docValuesWriter.getDocComparator(state.segmentInfo.maxDoc(), sortField);\n-          comparators.add(cmp);\n-          finishedDocValues.add(perField.fieldInfo.name);\n-      } else {\n-        // safe to ignore, sort field with no values or already seen before\n+      IndexSorter sorter = sortField.getIndexSorter();\n+      if (sorter == null) {\n+        throw new UnsupportedOperationException(\"Cannot sort index using sort field \" + sortField);\n       }\n+      comparators.add(sorter.getDocComparator(docValuesReader));\n     }\n     Sorter sorter = new Sorter(indexSort);\n     // returns null if the documents are already sorted\n-    return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(new Sorter.DocComparator[comparators.size()]));\n+    return sorter.sort(state.segmentInfo.maxDoc(), comparators.toArray(new IndexSorter.DocComparator[0]));", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzc3MA==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412313770", "bodyText": "should it be an actual exception instead of an assertion? Or are we checking it up-front already?", "author": "jpountz", "createdAt": "2020-04-21T16:38:54Z", "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -527,45 +589,61 @@ private void indexPoint(PerField fp, IndexableField field) throws IOException {\n     fp.pointValuesWriter.addPackedValue(docState.docID, field.binaryValue());\n   }\n \n-  private void validateIndexSortDVType(Sort indexSort, String fieldName, DocValuesType dvType) {\n+  private void validateIndexSortDVType(Sort indexSort, String fieldToValidate, DocValuesType dvType) throws IOException {\n     for (SortField sortField : indexSort.getSort()) {\n-      if (sortField.getField().equals(fieldName)) {\n-        switch (dvType) {\n-          case NUMERIC:\n-            if (sortField.getType().equals(SortField.Type.INT) == false &&\n-                  sortField.getType().equals(SortField.Type.LONG) == false &&\n-                  sortField.getType().equals(SortField.Type.FLOAT) == false &&\n-                  sortField.getType().equals(SortField.Type.DOUBLE) == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+      IndexSorter sorter = sortField.getIndexSorter();\n+      assert sorter != null;", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4Mzk2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412783967", "bodyText": "It's checked in IndexWriterConfig.setSort() but I'll add an exception here as well; you could conceivably get here via a funky Codec that instantiates a Sort with no IndexSorter defined.", "author": "romseygeek", "createdAt": "2020-04-22T08:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxMzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNDM2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412314365", "bodyText": "when I first saw this class I thought it would be similar to DocValuesProducer, maybe rename to DocValuesLeafReader to clear potential confusion?", "author": "jpountz", "createdAt": "2020-04-21T16:39:55Z", "path": "lucene/core/src/java/org/apache/lucene/index/DocValuesReader.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+\n+import org.apache.lucene.util.Bits;\n+\n+abstract class DocValuesReader extends LeafReader {", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjk4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412316982", "bodyText": "make it lucene.internal?", "author": "jpountz", "createdAt": "2020-04-21T16:44:03Z", "path": "lucene/core/src/java/org/apache/lucene/search/SortField.java", "diffHunk": "@@ -392,4 +491,31 @@ public SortField rewrite(IndexSearcher searcher) throws IOException {\n   public boolean needsScores() {\n     return type == Type.SCORE;\n   }\n+\n+  /**\n+   * Returns an {@link IndexSorter} used for sorting index segments by this SortField.\n+   *\n+   * If the SortField cannot be used for index sorting (for example, if it uses scores or\n+   * other query-dependent values) then this method should return {@code null}\n+   *\n+   * SortFields that implement this method should also implement a constructor that\n+   * takes a {@link DataInput} for deserialization, to match the {@link IndexSorter#serialize(DataOutput)}\n+   * method on the returned IndexSorter\n+   */", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4NjczNg==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412786736", "bodyText": "I'm not sure this API is particularly internal? If people want to implement their own SortFields and make them indexable they will need to implement this method, which makes it public IMO.\nWe should probably take @lucene.experimental off getFieldComparator() as well, it's been there since 2004...", "author": "romseygeek", "createdAt": "2020-04-22T08:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY2MzI3MA==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413663270", "bodyText": "I suggested it because I was seeing your change as a cleanup to the way that we support configuring index sorts. experimental would work for me too, what I like is to signal users that we feel free to make breaking changes to these APIs.", "author": "jpountz", "createdAt": "2020-04-23T09:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNzQ3Mg==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412317472", "bodyText": "maybe reuse the class name like we do for codecs, ie. SortField?", "author": "jpountz", "createdAt": "2020-04-21T16:44:48Z", "path": "lucene/core/src/java/org/apache/lucene/search/SortField.java", "diffHunk": "@@ -120,6 +126,99 @@ public SortField(String field, Type type, boolean reverse) {\n     this.reverse = reverse;\n   }\n \n+  /** A SortFieldProvider for field sorts */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this Provider is registered under */\n+    public static final String NAME = \"field\";", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNzU5MQ==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412317591", "bodyText": "maybe reuse the class name?", "author": "jpountz", "createdAt": "2020-04-21T16:44:58Z", "path": "lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java", "diffHunk": "@@ -83,6 +89,80 @@ public SortedNumericSortField(String field, SortField.Type type, boolean reverse\n     this.type = type;\n   }\n \n+  /** A SortFieldProvider for this sort field */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this provider is registered under */\n+    public static final String NAME = \"sortedNumericField\";", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNzk3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412317975", "bodyText": "use the class name?", "author": "jpountz", "createdAt": "2020-04-21T16:45:32Z", "path": "lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java", "diffHunk": "@@ -68,6 +72,54 @@ public SortedSetSortField(String field, boolean reverse, SortedSetSelector.Type\n     }\n     this.selector = selector;\n   }\n+\n+  /** A SortFieldProvider for this sort */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this provider is registered under */\n+    public static final String NAME = \"sortedSetField\";", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxOTY3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412319671", "bodyText": "can it be package private?", "author": "jpountz", "createdAt": "2020-04-21T16:47:46Z", "path": "lucene/core/src/java/org/apache/lucene/index/IndexSorter.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.lucene.search.FieldComparator;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.LongValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.apache.lucene.util.packed.PackedInts;\n+\n+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;\n+\n+/**\n+ * Handles how documents should be sorted in an index, both within a segment and between\n+ * segments.\n+ *\n+ * Implementers must provide the following methods:\n+ * {@link #getDocComparator(LeafReader)} - an object that determines how documents within a segment are to be sorted\n+ * {@link #getComparableProviders(List)} - an array of objects that return a sortable long value per document and segment\n+ * {@link #serialize(DataOutput)} - how the sort should be written into the segment header\n+ * {@link #getProviderName()} - the SPI-registered name of a {@link SortFieldProvider} to deserialize the sort\n+ *\n+ * The companion {@link SortFieldProvider} should be registered with SPI via {@code META-INF/services}\n+ */\n+public interface IndexSorter {\n+\n+  /** Used for sorting documents across segments */\n+  public interface ComparableProvider {\n+    /**\n+     * Returns a long so that the natural ordering of long values matches the\n+     * ordering of doc IDs for the given comparator\n+     */\n+    long getAsComparableLong(int docID) throws IOException;\n+  }\n+\n+  /** A comparator of doc IDs, used for sorting documents within a segment */\n+  public interface DocComparator {\n+    /** Compare docID1 against docID2. The contract for the return value is the\n+     *  same as {@link Comparator#compare(Object, Object)}. */\n+    int compare(int docID1, int docID2);\n+  }\n+\n+  /**\n+   * Get an array of {@link ComparableProvider}, one per segment, for merge sorting documents in different segments\n+   * @param readers the readers to be merged\n+   */\n+  public abstract ComparableProvider[] getComparableProviders(List<? extends LeafReader> readers) throws IOException;\n+\n+  /**\n+   * Get a comparator that determines the sort order of docs within a single Reader.\n+   *\n+   * NB We cannot simply use the {@link FieldComparator} API because it requires docIDs to be sent\n+   * in-order. The default implementations allocate array[maxDoc] to hold native values for comparison,\n+   * but 1) they are transient (only alive while sorting this one segment) and 2) in the typical\n+   * index sorting case, they are only used to sort newly flushed segments, which will be smaller\n+   * than merged segments\n+   *\n+   * @param reader the Reader to sort\n+   */\n+  public abstract DocComparator getDocComparator(LeafReader reader) throws IOException;\n+\n+  /**\n+   * Serializes the parent SortField.  This is used to write Sort information into the Segment header\n+   *\n+   * @see SortFieldProvider#loadSortField(DataInput)\n+   */\n+  public abstract void serialize(DataOutput out) throws IOException;\n+\n+  /**\n+   * The SPI-registered name of a {@link SortFieldProvider} that will deserialize the parent SortField\n+   */\n+  public abstract String getProviderName();\n+\n+  /**\n+   * Provide a NumericDocValues instance for a LeafReader\n+   */\n+  public interface NumericDocValuesProvider {\n+    /**\n+     * Returns the NumericDocValues instance for this LeafReader\n+     */\n+    NumericDocValues get(LeafReader reader) throws IOException;\n+  }\n+\n+  /**\n+   * Provide a SortedDocValues instance for a LeafReader\n+   */\n+  public interface SortedDocValuesProvider {\n+    /**\n+     * Returns the SortedDocValues instance for this LeafReader\n+     */\n+    SortedDocValues get(LeafReader reader) throws IOException;\n+  }\n+\n+  /**\n+   * Serialize an object into a DataOutput\n+   */\n+  public interface Serializer {\n+    /** Serializes an object into a DataOutput */\n+    void serialize(DataOutput out) throws IOException;\n+  }\n+\n+  /**\n+   * Sorts documents based on integer values from a NumericDocValues instance\n+   */\n+  public static final class IntSorter implements IndexSorter {", "originalCommit": "247ef622e51476a882a8f7cf706968f339d04813", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyOTE1NA==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r412829154", "bodyText": "IndexSorter is an interface (started as an abstract class in a first iteration) so everything is public and static, and we don't need those modifiers anymore.", "author": "romseygeek", "createdAt": "2020-04-22T09:37:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxOTY3MQ=="}], "type": "inlineReview"}, {"oid": "303e38b76de8208261c6e1ee2b6dd219c1561f0a", "url": "https://github.com/apache/lucene-solr/commit/303e38b76de8208261c6e1ee2b6dd219c1561f0a", "message": "Merge remote-tracking branch 'origin/master' into sorts", "committedDate": "2020-04-22T08:20:14Z", "type": "commit"}, {"oid": "7df302381100657e8591648f64d0590f16985972", "url": "https://github.com/apache/lucene-solr/commit/7df302381100657e8591648f64d0590f16985972", "message": "feedback", "committedDate": "2020-04-22T09:35:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NzQxNg==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413647416", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private LeafReader getDocValuesReader(int maxDoc) {\n          \n          \n            \n              private LeafReader getDocValuesLeafReader(int maxDoc) {", "author": "jpountz", "createdAt": "2020-04-23T09:09:59Z", "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -94,29 +89,100 @@ public DefaultIndexingChain(DocumentsWriterPerThread docWriter) {\n     termsHash = new FreqProxTermsWriter(docWriter, termVectorsWriter);\n   }\n \n+  private LeafReader getDocValuesReader(int maxDoc) {", "originalCommit": "7df302381100657e8591648f64d0590f16985972", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MTY5Mg==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413651692", "bodyText": "I'd have a slight preferenrece for throwing an UOE here, would it work?", "author": "jpountz", "createdAt": "2020-04-23T09:16:08Z", "path": "lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java", "diffHunk": "@@ -527,45 +589,63 @@ private void indexPoint(PerField fp, IndexableField field) throws IOException {\n     fp.pointValuesWriter.addPackedValue(docState.docID, field.binaryValue());\n   }\n \n-  private void validateIndexSortDVType(Sort indexSort, String fieldName, DocValuesType dvType) {\n+  private void validateIndexSortDVType(Sort indexSort, String fieldToValidate, DocValuesType dvType) throws IOException {\n     for (SortField sortField : indexSort.getSort()) {\n-      if (sortField.getField().equals(fieldName)) {\n-        switch (dvType) {\n-          case NUMERIC:\n-            if (sortField.getType().equals(SortField.Type.INT) == false &&\n-                  sortField.getType().equals(SortField.Type.LONG) == false &&\n-                  sortField.getType().equals(SortField.Type.FLOAT) == false &&\n-                  sortField.getType().equals(SortField.Type.DOUBLE) == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+      IndexSorter sorter = sortField.getIndexSorter();\n+      if (sorter == null) {\n+        throw new IllegalStateException(\"Cannot sort index with sort order \" + sortField);\n+      }\n+      sorter.getDocComparator(new DocValuesLeafReader() {\n+        @Override\n+        public NumericDocValues getNumericDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.NUMERIC) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be NUMERIC but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptyNumeric();\n+        }\n \n-          case BINARY:\n-            throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n+        @Override\n+        public BinaryDocValues getBinaryDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.BINARY) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be BINARY but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptyBinary();\n+        }\n \n-          case SORTED:\n-            if (sortField.getType().equals(SortField.Type.STRING) == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+        @Override\n+        public SortedDocValues getSortedDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.SORTED) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be SORTED but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptySorted();\n+        }\n \n-          case SORTED_NUMERIC:\n-            if (sortField instanceof SortedNumericSortField == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+        @Override\n+        public SortedNumericDocValues getSortedNumericDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.SORTED_NUMERIC) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be SORTED_NUMERIC but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptySortedNumeric(0);\n+        }\n \n-          case SORTED_SET:\n-            if (sortField instanceof SortedSetSortField == false) {\n-              throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n-            }\n-            break;\n+        @Override\n+        public SortedSetDocValues getSortedSetDocValues(String field) {\n+          if (Objects.equals(field, fieldToValidate) && dvType != DocValuesType.SORTED_SET) {\n+            throw new IllegalArgumentException(\"SortField \" + sortField + \" expected field [\" + field + \"] to be SORTED_SET but it is [\" + dvType + \"]\");\n+          }\n+          return DocValues.emptySortedSet();\n+        }\n \n-          default:\n-            throw new IllegalArgumentException(\"invalid doc value type:\" + dvType + \" for sortField:\" + sortField);\n+        @Override\n+        public FieldInfos getFieldInfos() {\n+          throw new UnsupportedOperationException();\n         }\n-        break;\n-      }\n+\n+        @Override\n+        public int maxDoc() {\n+          return 0;", "originalCommit": "7df302381100657e8591648f64d0590f16985972", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4OTEzMw==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413689133", "bodyText": "IndexSorter.getDocComparator(Reader) calls maxDoc() on the reader to allocate its comparison arrays.  We could change the signature so that it takes maxDoc as well as the Reader, which would reduce the indirection a bit and make it easier to read?", "author": "romseygeek", "createdAt": "2020-04-23T10:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MTY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0NjAzMQ==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413746031", "bodyText": "+1", "author": "jpountz", "createdAt": "2020-04-23T11:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1NjIwMA==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413656200", "bodyText": "javadocs?", "author": "jpountz", "createdAt": "2020-04-23T09:22:36Z", "path": "lucene/core/src/java/org/apache/lucene/index/SortFieldProvider.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.NamedSPILoader;\n+\n+/**\n+ * Reads a named SortField from a segment info file, used to record index sorts\n+ */\n+public abstract class SortFieldProvider implements NamedSPILoader.NamedSPI {\n+\n+  private static class Holder {\n+    private static final NamedSPILoader<SortFieldProvider> LOADER = new NamedSPILoader<>(SortFieldProvider.class);\n+\n+    static NamedSPILoader<SortFieldProvider> getLoader() {\n+      if (LOADER == null) {\n+        throw new IllegalStateException(\"You tried to lookup a SortFieldProvider by name before all SortFieldProviders could be initialized. \"+\n+            \"This likely happens if you call SortFieldProvider#forName from a SortFieldProviders's ctor.\");\n+      }\n+      return LOADER;\n+    }\n+  }\n+\n+  /**\n+   * Looks up a SortFieldProvider by name\n+   */\n+  public static SortFieldProvider forName(String name) {\n+    return Holder.getLoader().lookup(name);\n+  }\n+\n+  /**\n+   * Lists all available SortFieldProviders\n+   */\n+  public static Set<String> availableSortFieldProviders() {\n+    return Holder.getLoader().availableServices();\n+  }\n+\n+  /**\n+   * Reloads the SortFieldProvider list from the given {@link ClassLoader}.\n+   * Changes to the list are visible after the method ends, all\n+   * iterators ({@link #availableSortFieldProviders()} ()},...) stay consistent.\n+   *\n+   * <p><b>NOTE:</b> Only new SortFieldProviders are added, existing ones are\n+   * never removed or replaced.\n+   *\n+   * <p><em>This method is expensive and should only be called for discovery\n+   * of new SortFieldProviders on the given classpath/classloader!</em>\n+   */\n+  public static void reloadSortFieldProviders(ClassLoader classLoader) {\n+    Holder.getLoader().reload(classLoader);\n+  }\n+\n+  public static void serialize(SortField sf, DataOutput output) throws IOException {", "originalCommit": "7df302381100657e8591648f64d0590f16985972", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1NjYxNw==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413656617", "bodyText": "javadocs?", "author": "jpountz", "createdAt": "2020-04-23T09:23:13Z", "path": "lucene/core/src/java/org/apache/lucene/index/SortFieldProvider.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.index;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.store.DataInput;\n+import org.apache.lucene.store.DataOutput;\n+import org.apache.lucene.util.NamedSPILoader;\n+\n+/**\n+ * Reads a named SortField from a segment info file, used to record index sorts\n+ */\n+public abstract class SortFieldProvider implements NamedSPILoader.NamedSPI {\n+\n+  private static class Holder {\n+    private static final NamedSPILoader<SortFieldProvider> LOADER = new NamedSPILoader<>(SortFieldProvider.class);\n+\n+    static NamedSPILoader<SortFieldProvider> getLoader() {\n+      if (LOADER == null) {\n+        throw new IllegalStateException(\"You tried to lookup a SortFieldProvider by name before all SortFieldProviders could be initialized. \"+\n+            \"This likely happens if you call SortFieldProvider#forName from a SortFieldProviders's ctor.\");\n+      }\n+      return LOADER;\n+    }\n+  }\n+\n+  /**\n+   * Looks up a SortFieldProvider by name\n+   */\n+  public static SortFieldProvider forName(String name) {\n+    return Holder.getLoader().lookup(name);\n+  }\n+\n+  /**\n+   * Lists all available SortFieldProviders\n+   */\n+  public static Set<String> availableSortFieldProviders() {\n+    return Holder.getLoader().availableServices();\n+  }\n+\n+  /**\n+   * Reloads the SortFieldProvider list from the given {@link ClassLoader}.\n+   * Changes to the list are visible after the method ends, all\n+   * iterators ({@link #availableSortFieldProviders()} ()},...) stay consistent.\n+   *\n+   * <p><b>NOTE:</b> Only new SortFieldProviders are added, existing ones are\n+   * never removed or replaced.\n+   *\n+   * <p><em>This method is expensive and should only be called for discovery\n+   * of new SortFieldProviders on the given classpath/classloader!</em>\n+   */\n+  public static void reloadSortFieldProviders(ClassLoader classLoader) {\n+    Holder.getLoader().reload(classLoader);\n+  }\n+\n+  public static void serialize(SortField sf, DataOutput output) throws IOException {\n+    IndexSorter sorter = sf.getIndexSorter();\n+    if (sorter == null) {\n+      throw new IllegalArgumentException(\"Cannot serialize sort field \" + sf);\n+    }\n+    SortFieldProvider provider = SortFieldProvider.forName(sorter.getProviderName());\n+    provider.writeSortField(sf, output);\n+  }\n+\n+  /** The name this SortFieldProvider is registered under */\n+  protected final String name;\n+\n+  /**\n+   * Creates a new SortFieldProvider.\n+   * <p>\n+   * The provided name will be written into the index segment: in order to\n+   * for the segment to be read this class should be registered with Java's\n+   * SPI mechanism (registered in META-INF/ of your jar file, etc).\n+   * @param name must be all ascii alphanumeric, and less than 128 characters in length.\n+   */\n+  protected SortFieldProvider(String name) {\n+    this.name = name;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return name;\n+  }\n+\n+  /**\n+   * Loads a SortField from serialized bytes\n+   */\n+  public abstract SortField loadSortField(DataInput in) throws IOException;\n+\n+  public abstract void writeSortField(SortField sf, DataOutput out) throws IOException;", "originalCommit": "7df302381100657e8591648f64d0590f16985972", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1NzQ5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413657496", "bodyText": "I wonder if there are undesired consequences of dropping this?", "author": "jpountz", "createdAt": "2020-04-23T09:24:29Z", "path": "lucene/core/src/java/org/apache/lucene/index/SortedDocValuesWriter.java", "diffHunk": "@@ -79,11 +78,6 @@ public void addValue(int docID, BytesRef value) {\n     lastDocID = docID;\n   }\n \n-  @Override\n-  public void finish(int maxDoc) {\n-    updateBytesUsed();\n-  }", "originalCommit": "7df302381100657e8591648f64d0590f16985972", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5Mjk0Ng==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r413692946", "bodyText": "It was always called either immediately before flush or getDocComparator, so it seemed to make sense to just fold it directly into those methods.", "author": "romseygeek", "createdAt": "2020-04-23T10:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1NzQ5Ng=="}], "type": "inlineReview"}, {"oid": "7103b98018a08ac00f7379f6ab959f16554b2b07", "url": "https://github.com/apache/lucene-solr/commit/7103b98018a08ac00f7379f6ab959f16554b2b07", "message": "Merge remote-tracking branch 'origin/master' into sorts", "committedDate": "2020-04-23T10:00:01Z", "type": "commit"}, {"oid": "18d83686caf6ce31e5d658ec39d07de4e383d35b", "url": "https://github.com/apache/lucene-solr/commit/18d83686caf6ce31e5d658ec39d07de4e383d35b", "message": "feedback", "committedDate": "2020-04-23T11:17:01Z", "type": "commit"}, {"oid": "3b608eb5821b5e9d81c9ec737188f08a07aa4041", "url": "https://github.com/apache/lucene-solr/commit/3b608eb5821b5e9d81c9ec737188f08a07aa4041", "message": "Add CHANGES", "committedDate": "2020-04-23T11:34:26Z", "type": "commit"}, {"oid": "063fa710a3aabad9ca2e11c8d98c983487567a7d", "url": "https://github.com/apache/lucene-solr/commit/063fa710a3aabad9ca2e11c8d98c983487567a7d", "message": "Add test for backwards-codecs", "committedDate": "2020-04-23T13:08:13Z", "type": "commit"}, {"oid": "0bc533cbbdf7467137fb0ed2d866827851c9f251", "url": "https://github.com/apache/lucene-solr/commit/0bc533cbbdf7467137fb0ed2d866827851c9f251", "message": "Merge remote-tracking branch 'origin/master' into sorts", "committedDate": "2020-04-24T11:31:33Z", "type": "commit"}, {"oid": "082b2ced58d316def6c2f3099ae180a447682569", "url": "https://github.com/apache/lucene-solr/commit/082b2ced58d316def6c2f3099ae180a447682569", "message": "Pass maxDoc directly to IndexSorter.getDocComparator()", "committedDate": "2020-04-24T11:36:56Z", "type": "commit"}, {"oid": "f160e01549648548e8a23200fbc5a81105d1179a", "url": "https://github.com/apache/lucene-solr/commit/f160e01549648548e8a23200fbc5a81105d1179a", "message": "package-info.java", "committedDate": "2020-04-24T12:28:07Z", "type": "commit"}, {"oid": "6e5f1e0773a6dd90a6d8801dd707653272f246a3", "url": "https://github.com/apache/lucene-solr/commit/6e5f1e0773a6dd90a6d8801dd707653272f246a3", "message": "Merge remote-tracking branch 'origin/master' into sorts", "committedDate": "2020-05-05T13:41:42Z", "type": "commit"}, {"oid": "135ca9958a33afd6892bc6e4c2822ff39917b166", "url": "https://github.com/apache/lucene-solr/commit/135ca9958a33afd6892bc6e4c2822ff39917b166", "message": "Merge remote-tracking branch 'origin/master' into sorts", "committedDate": "2020-05-07T10:46:57Z", "type": "commit"}, {"oid": "240b11cd0fcd5e47dbd72b772bd96c92aacf0aa1", "url": "https://github.com/apache/lucene-solr/commit/240b11cd0fcd5e47dbd72b772bd96c92aacf0aa1", "message": "Don't call back to reader.maxDoc()", "committedDate": "2020-05-07T11:04:31Z", "type": "commit"}, {"oid": "19801ee084887203803f99c41b98641bd885656c", "url": "https://github.com/apache/lucene-solr/commit/19801ee084887203803f99c41b98641bd885656c", "message": "Revert \"Don't call back to reader.maxDoc()\"\n\nThis reverts commit 240b11cd0fcd5e47dbd72b772bd96c92aacf0aa1.", "committedDate": "2020-05-07T13:42:27Z", "type": "commit"}, {"oid": "f38d0e4c474d9bcf4fb021973c4aeb98302c9ac9", "url": "https://github.com/apache/lucene-solr/commit/f38d0e4c474d9bcf4fb021973c4aeb98302c9ac9", "message": "Merge remote-tracking branch 'origin/master' into sorts", "committedDate": "2020-05-07T13:42:33Z", "type": "commit"}, {"oid": "578ce8e47e258e169ac9f51a9130413e7a8fb922", "url": "https://github.com/apache/lucene-solr/commit/578ce8e47e258e169ac9f51a9130413e7a8fb922", "message": "Compilation", "committedDate": "2020-05-07T13:47:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3ODY0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r426378641", "bodyText": "Can we look into not using enum ordinals for serialization? It makes something that looks as harmless as reordering an enum cause backward-compatibility breaks. E.g. maybe we could have a mapping between Type constants and int IDs as a constant on this class?", "author": "jpountz", "createdAt": "2020-05-18T05:36:31Z", "path": "lucene/core/src/java/org/apache/lucene/search/SortField.java", "diffHunk": "@@ -120,6 +126,104 @@ public SortField(String field, Type type, boolean reverse) {\n     this.reverse = reverse;\n   }\n \n+  /** A SortFieldProvider for field sorts */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this Provider is registered under */\n+    public static final String NAME = \"SortField\";\n+\n+    /** Creates a new Provider */\n+    public Provider() {\n+      super(NAME);\n+    }\n+\n+    @Override\n+    public SortField readSortField(DataInput in) throws IOException {\n+      SortField sf = new SortField(in.readString(), readType(in), in.readInt() == 1);\n+      if (in.readInt() == 1) {\n+        // missing object\n+        switch (sf.type) {\n+          case STRING:\n+            int missingString = in.readInt();\n+            if (missingString == 1) {\n+              sf.setMissingValue(STRING_FIRST);\n+            }\n+            else {\n+              sf.setMissingValue(STRING_LAST);\n+            }\n+            break;\n+          case INT:\n+            sf.setMissingValue(in.readInt());\n+            break;\n+          case LONG:\n+            sf.setMissingValue(in.readLong());\n+            break;\n+          case FLOAT:\n+            sf.setMissingValue(NumericUtils.sortableIntToFloat(in.readInt()));\n+            break;\n+          case DOUBLE:\n+            sf.setMissingValue(NumericUtils.sortableLongToDouble(in.readLong()));\n+            break;\n+          default:\n+            throw new IllegalArgumentException(\"Cannot deserialize sort of type \" + sf.type);\n+        }\n+      }\n+      return sf;\n+    }\n+\n+    @Override\n+    public void writeSortField(SortField sf, DataOutput out) throws IOException {\n+      sf.serialize(out);\n+    }\n+  }\n+\n+  protected static Type readType(DataInput in) throws IOException {\n+    int type = in.readInt();\n+    if (type >= Type.values().length) {\n+      throw new IllegalArgumentException(\"Can't deserialize SortField - unknown type \" + type);\n+    }\n+    return Type.values()[type];\n+  }\n+\n+  private void serialize(DataOutput out) throws IOException {\n+    out.writeString(field);\n+    out.writeInt(type.ordinal());", "originalCommit": "578ce8e47e258e169ac9f51a9130413e7a8fb922", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3ODc0Ng==", "url": "https://github.com/apache/lucene-solr/pull/1440#discussion_r426378746", "bodyText": "same here?", "author": "jpountz", "createdAt": "2020-05-18T05:37:02Z", "path": "lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java", "diffHunk": "@@ -83,6 +89,86 @@ public SortedNumericSortField(String field, SortField.Type type, boolean reverse\n     this.type = type;\n   }\n \n+  /** A SortFieldProvider for this sort field */\n+  public static final class Provider extends SortFieldProvider {\n+\n+    /** The name this provider is registered under */\n+    public static final String NAME = \"SortedNumericSortField\";\n+\n+    /** Creates a new Provider */\n+    public Provider() {\n+      super(NAME);\n+    }\n+\n+    @Override\n+    public SortField readSortField(DataInput in) throws IOException {\n+      SortedNumericSortField sf = new SortedNumericSortField(in.readString(), readType(in), in.readInt() == 1, readSelectorType(in));\n+      if (in.readInt() == 1) {\n+        switch (sf.type) {\n+          case INT:\n+            sf.setMissingValue(in.readInt());\n+            break;\n+          case LONG:\n+            sf.setMissingValue(in.readLong());\n+            break;\n+          case FLOAT:\n+            sf.setMissingValue(NumericUtils.sortableIntToFloat(in.readInt()));\n+            break;\n+          case DOUBLE:\n+            sf.setMissingValue(NumericUtils.sortableLongToDouble(in.readLong()));\n+            break;\n+          default:\n+            throw new AssertionError();\n+        }\n+      }\n+      return sf;\n+    }\n+\n+    @Override\n+    public void writeSortField(SortField sf, DataOutput out) throws IOException {\n+      assert sf instanceof SortedNumericSortField;\n+      ((SortedNumericSortField)sf).serialize(out);\n+    }\n+  }\n+\n+  private static SortedNumericSelector.Type readSelectorType(DataInput in) throws IOException {\n+    int selectorType = in.readInt();\n+    if (selectorType >= SortedNumericSelector.Type.values().length) {\n+      throw new IllegalArgumentException(\"Can't deserialize SortedNumericSortField - unknown selector type \" + selectorType);\n+    }\n+    return SortedNumericSelector.Type.values()[selectorType];", "originalCommit": "578ce8e47e258e169ac9f51a9130413e7a8fb922", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e290bb0feb218d1ff299d6fb7191c3628204c122", "url": "https://github.com/apache/lucene-solr/commit/e290bb0feb218d1ff299d6fb7191c3628204c122", "message": "Merge remote-tracking branch 'origin/master' into sorts", "committedDate": "2020-05-22T09:27:36Z", "type": "commit"}, {"oid": "1a1548c61447a5913ec2f89f7c66dc01c3cb0858", "url": "https://github.com/apache/lucene-solr/commit/1a1548c61447a5913ec2f89f7c66dc01c3cb0858", "message": "Serialize sortfield types as strings rather than ords", "committedDate": "2020-05-22T10:27:10Z", "type": "commit"}]}