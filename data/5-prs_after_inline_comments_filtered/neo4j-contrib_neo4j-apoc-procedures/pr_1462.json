{"pr_number": 1462, "pr_title": "fix deadlock situation in concurrent executions", "pr_createdAt": "2020-03-28T14:40:51Z", "pr_url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462", "timeline": [{"oid": "45245536ee01b783c033b4f1f6fff61808180ffa", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/45245536ee01b783c033b4f1f6fff61808180ffa", "message": "ensure tombstone is sent, adding `queueCapacity` parameter", "committedDate": "2020-03-19T16:38:15Z", "type": "commit"}, {"oid": "8414e6a750a3bbe6c91d50f1a0b84808f9b50501", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/8414e6a750a3bbe6c91d50f1a0b84808f9b50501", "message": "WIP - bookmark for delivered snapshot", "committedDate": "2020-03-24T19:35:35Z", "type": "commit"}, {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/0a16124b759d7511b6608ca769de5fb5ed764275", "message": "prevent QueueBasedSpliterator from waiting forever\n\nUsing a state variable QueueBasedSpliterator knows if it already has seen tombstone.", "committedDate": "2020-03-28T14:33:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjIyMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866220", "bodyText": "can this lead into being blocked forever? Shouldn't we take the timeout into account?\nint put and/or the whole method time?", "author": "jexp", "createdAt": "2020-03-29T22:54:34Z", "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -95,26 +112,47 @@\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n+        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n-        Util.inThread(() -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n+        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(queueCapacity);\n+        runInSeparateThreadAndSendTombstone(() -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runSchemaStatementsInTx(reader, queue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runDataStatementsInTx(reader, queue, params, addStatistics, timeout);\n             }\n-            queue.put(RowResult.TOMBSTONE);\n-            return null;\n-        });\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n+        }, queue, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard), false);\n+    }\n+\n+\n+    private <T> void runInSeparateThreadAndSendTombstone(Runnable action, BlockingQueue<T> queue, T tombstone) {\n+        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n+           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n+           wait in the pool's job queue.\n+         */\n+        new Thread(() -> {\n+            try {\n+                action.run();\n+            } finally {\n+                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n+                    try {\n+                        queue.put(tombstone);\n+                        return;\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMzY2MA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404803660", "bodyText": "Blocking forever?", "author": "jexp", "createdAt": "2020-04-07T13:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjMzOA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866338", "bodyText": "this is now blocking forever if the queue is full?\nexactly what we wanted to avoid with the timeout?\nthat was the reason we used offer in the first place ...", "author": "jexp", "createdAt": "2020-03-29T22:55:46Z", "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -163,7 +203,7 @@ private Object executeStatement(BlockingQueue<RowResult> queue, String stmt, Map\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n+                queue.put(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)));", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3ODQ4Mg==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404678482", "bodyText": "Did you want to wrap this one too?", "author": "jexp", "createdAt": "2020-04-07T09:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjkwMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866900", "bodyText": "this will now potentially block forever ...", "author": "jexp", "createdAt": "2020-03-29T23:01:06Z", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2Njk1NQ==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866955", "bodyText": "should this really return true if the tombstone was found?", "author": "jexp", "createdAt": "2020-03-29T23:01:40Z", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();\n+            if (element.equals(tombstone)) {\n+                foundTombstone = true;\n+            } else {\n+                action.accept(element);\n+            }\n+            return true;", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzEzMg==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867132", "bodyText": "it was null when the timeout hit, which now would block forever causing downstream processing being starved b/c the queue is no longer filled upstream ... (e.g. no threads available or other reasons)", "author": "jexp", "createdAt": "2020-03-29T23:03:23Z", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzQxNw==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867417", "bodyText": "does this have any data to run on?", "author": "jexp", "createdAt": "2020-03-29T23:05:36Z", "path": "src/test/java/apoc/cypher/CypherTest.java", "diffHunk": "@@ -463,4 +478,20 @@ public void testRunFileWithEmptyFile() throws Exception {\n         testResult(db, \"CALL apoc.cypher.runFile('src/test/resources/empty.cypher')\",\n                 r -> assertFalse(\"should be empty\", r.hasNext()));\n     }\n+\n+    @Test\n+    public void lengthyRunManyShouldTerminate() {\n+        String repetetiveStatement= \"CALL apoc.cypher.runFile(\\\"src/test/resources/enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"218598584\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonMASnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\" +", "originalCommit": "0a16124b759d7511b6608ca769de5fb5ed764275", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/de07980676970f5c00cc04ed5cc0670cd0a793ac", "message": "using poll/offer instead of put/take for queues", "committedDate": "2020-03-30T18:56:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjE4OA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806188", "bodyText": "we can compute  started + timeoutSeconds * 1000 here (in both methods)", "author": "jexp", "createdAt": "2020-04-07T13:25:33Z", "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();", "originalCommit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806534", "bodyText": "do we have to return something from this method? or can it be just void?", "author": "jexp", "createdAt": "2020-04-07T13:26:00Z", "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;", "originalCommit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4MTExMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405081110", "bodyText": "BlockingQueue.put doesn't return anything, therefore I choose void for the method signature. Since withHandlingInterrupted is using a generic return type, I have to return something - null in this case.", "author": "sarmbruster", "createdAt": "2020-04-07T20:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NDgxMA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405084810", "bodyText": "I'm inlining that indirection anyway, see comment below.", "author": "sarmbruster", "createdAt": "2020-04-07T20:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNzIzMg==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404807232", "bodyText": "not sure it's worth the indirection.\nwhat about that Thread.currentThread().interrrupt()\nhandling? I always forget which one is right :)", "author": "jexp", "createdAt": "2020-04-07T13:26:58Z", "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;\n+                }\n+                checkDuringOffering.run();\n+            }\n+            if (failWithExecption) {\n+                throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n+            }\n+            return null;\n+        });\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#take}\n+     * @param queue\n+     * @param timeoutSeconds\n+     * @param checkDuringPolling a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     * @return\n+     */\n+    public static <T> T take(BlockingQueue<T> queue, long timeoutSeconds, Runnable checkDuringPolling) {\n+        return withHandlingInterrupted(\"Queue poll interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                T polled = queue.poll(WAIT, WAIT_UNIT);\n+                if (polled != null) {\n+                    return polled;\n+                }\n+                checkDuringPolling.run();\n+            }\n+            throw new RuntimeException(\"Error polling, timeout of \" + timeoutSeconds + \" seconds reached.\");\n+        });\n+    }\n+\n+    public static <T> T withHandlingInterrupted(String msg, ThrowingSupplier<T, InterruptedException> consumer) {", "originalCommit": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NTMwOA==", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405085308", "bodyText": "Gonna remove the indirection. I guess Thread.currentThread.interrupt() is not good here since I don't know what to return for take() in this case. So bubbling up the exception sounds more reasonable to me.", "author": "sarmbruster", "createdAt": "2020-04-07T20:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNzIzMg=="}], "type": "inlineReview"}, {"oid": "98af0330559d6668f877756fa06e5941d3a3bbd3", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/98af0330559d6668f877756fa06e5941d3a3bbd3", "message": "code review request", "committedDate": "2020-04-07T20:20:23Z", "type": "commit"}]}