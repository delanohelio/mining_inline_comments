{"pr_number": 142, "pr_title": "IItemHandler support", "pr_createdAt": "2020-07-22T20:05:21Z", "pr_url": "https://github.com/PatchworkMC/patchwork-api/pull/142", "timeline": [{"oid": "17deaf9ad9dcdef44350e108e6ffaa5037cc572a", "url": "https://github.com/PatchworkMC/patchwork-api/commit/17deaf9ad9dcdef44350e108e6ffaa5037cc572a", "message": "IItemHandler support", "committedDate": "2020-07-22T20:02:08Z", "type": "commit"}, {"oid": "fc947dca99ab21ddb53900fc4fdd8aa531376939", "url": "https://github.com/PatchworkMC/patchwork-api/commit/fc947dca99ab21ddb53900fc4fdd8aa531376939", "message": "Remove a sneaky debug print", "committedDate": "2020-07-23T17:22:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODA4Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/142#discussion_r462598087", "bodyText": "Turns out setting a ThreadLocal to null causes a memory leak.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\tPatchworkItems.currentSide.set(null);\n          \n          \n            \n            \t\t\t\t\tPatchworkItems.currentSide.remove();", "author": "TheGlitch76", "createdAt": "2020-07-29T21:24:23Z", "path": "patchwork-items/src/main/java/net/patchworkmc/mixin/items/MixinHopperBlockEntity.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.mixin.items;\n+\n+import net.minecraftforge.common.capabilities.ICapabilityProvider;\n+import net.minecraftforge.common.util.LazyOptional;\n+import net.minecraftforge.items.CapabilityItemHandler;\n+import net.minecraftforge.items.IItemHandler;\n+import net.minecraftforge.items.IItemHandlerModifiable;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.HopperBlock;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.block.entity.Hopper;\n+import net.minecraft.block.entity.HopperBlockEntity;\n+import net.minecraft.inventory.Inventory;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Direction;\n+import net.minecraft.world.World;\n+\n+import net.patchworkmc.impl.items.PatchworkItems;\n+import net.patchworkmc.impl.items.ItemHandlerInventoryWrapper;\n+\n+@Mixin(HopperBlockEntity.class)\n+public class MixinHopperBlockEntity {\n+\t@Inject(method = \"getInputInventory\", at = @At(\"HEAD\"))\n+\tprivate static void onGetInputInventory(Hopper hopper, CallbackInfoReturnable<Inventory> cir) {\n+\t\tPatchworkItems.currentSide.set(Direction.UP);\n+\t}\n+\n+\t@Inject(method = \"getOutputInventory\", at = @At(\"HEAD\"))\n+\tprivate void onGetOutputInventory(CallbackInfoReturnable<Inventory> cir) {\n+\t\tPatchworkItems.currentSide.set(((BlockEntity) (Object) this).getCachedState().get(HopperBlock.FACING));\n+\t}\n+\n+\t@Inject(method = \"getInventoryAt(Lnet/minecraft/world/World;DDD)Lnet/minecraft/inventory/Inventory;\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/world/World;getEntities(Lnet/minecraft/entity/Entity;Lnet/minecraft/util/math/Box;Ljava/util/function/Predicate;)Ljava/util/List;\"), cancellable = true)\n+\tprivate static void onGetInventoryAt(World world, double x, double y, double z, CallbackInfoReturnable<Inventory> cir) {\n+\t\tBlockPos blockPos = new BlockPos(x, y, z);\n+\t\tBlockState blockState = world.getBlockState(blockPos);\n+\t\tBlock block = blockState.getBlock();\n+\n+\t\tif (block.hasBlockEntity()) {\n+\t\t\tBlockEntity blockEntity = world.getBlockEntity(blockPos);\n+\n+\t\t\tif (blockEntity != null) {\n+\t\t\t\tDirection direction = PatchworkItems.currentSide.get();\n+\n+\t\t\t\tif (direction != null) {\n+\t\t\t\t\tLazyOptional<IItemHandler> capability = ((ICapabilityProvider) blockEntity).getCapability(CapabilityItemHandler.ITEM_HANDLER_CAPABILITY, direction.getOpposite());\n+\t\t\t\t\tPatchworkItems.currentSide.set(null);", "originalCommit": "fc947dca99ab21ddb53900fc4fdd8aa531376939", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc3Mjg0Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/142#discussion_r462772847", "bodyText": "Confirmed, setting the value to null will not remove the reference to the Thread from the internal map.", "author": "rikka0w0", "createdAt": "2020-07-30T06:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODA4Nw=="}], "type": "inlineReview"}, {"oid": "7619dd2459c1a92730fee0c8fe5e3b5c0e7ed42c", "url": "https://github.com/PatchworkMC/patchwork-api/commit/7619dd2459c1a92730fee0c8fe5e3b5c0e7ed42c", "message": "Apparently this can cause a memory leak, TIL", "committedDate": "2020-07-30T19:38:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyNTY0Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/142#discussion_r467325642", "bodyText": "Looks like MCP\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * This method is an adaptation of Container#calcRedstoneFromInventory(IInventory).\n          \n          \n            \n            \t * This method is an adaptation of Container#calculateComparatorOutput(Inventory).", "author": "TheGlitch76", "createdAt": "2020-08-07T23:24:30Z", "path": "patchwork-items/src/main/java/net/minecraftforge/items/ItemHandlerHelper.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.items;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.util.math.MathHelper;\n+\n+import net.patchworkmc.impl.capability.CapabilityProviderHolder;\n+\n+public class ItemHandlerHelper {\n+\tprivate static boolean patchwork$areItemStackCapsCompatible(ItemStack a, ItemStack b) {\n+\t\treturn ((CapabilityProviderHolder) (Object) a).areCapsCompatible(((CapabilityProviderHolder) (Object) b).getCapabilityProvider());\n+\t}\n+\n+\t@Nonnull\n+\tpublic static ItemStack insertItem(IItemHandler dest, @Nonnull ItemStack stack, boolean simulate) {\n+\t\tif (dest == null || stack.isEmpty()) {\n+\t\t\treturn stack;\n+\t\t}\n+\n+\t\tfor (int i = 0; i < dest.getSlots(); i++) {\n+\t\t\tstack = dest.insertItem(i, stack, simulate);\n+\n+\t\t\tif (stack.isEmpty()) {\n+\t\t\t\treturn ItemStack.EMPTY;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn stack;\n+\t}\n+\n+\tpublic static boolean canItemStacksStack(@Nonnull ItemStack a, @Nonnull ItemStack b) {\n+\t\tif (a.isEmpty() || !a.isItemEqualIgnoreDamage(b) || a.hasTag() != b.hasTag()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn (!a.hasTag() || a.getTag().equals(b.getTag())) && patchwork$areItemStackCapsCompatible(a, b);\n+\t}\n+\n+\t/**\n+\t * A relaxed version of canItemStacksStack that stacks itemstacks with different metadata if they don't have subtypes.\n+\t * This usually only applies when players pick up items.\n+\t */\n+\tpublic static boolean canItemStacksStackRelaxed(@Nonnull ItemStack a, @Nonnull ItemStack b) {\n+\t\tif (a.isEmpty() || b.isEmpty() || a.getItem() != b.getItem()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (!a.isStackable()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (a.hasTag() != b.hasTag()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn (!a.hasTag() || a.getTag().equals(b.getTag())) && patchwork$areItemStackCapsCompatible(a, b);\n+\t}\n+\n+\t@Nonnull\n+\tpublic static ItemStack copyStackWithSize(@Nonnull ItemStack itemStack, int size) {\n+\t\tif (size == 0) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\tItemStack copy = itemStack.copy();\n+\t\tcopy.setCount(size);\n+\t\treturn copy;\n+\t}\n+\n+\t/**\n+\t * Inserts the ItemStack into the inventory, filling up already present stacks first.\n+\t * This is equivalent to the behaviour of a player picking up an item.\n+\t * Note: This function stacks items without subtypes with different metadata together.\n+\t */\n+\t@Nonnull\n+\tpublic static ItemStack insertItemStacked(IItemHandler inventory, @Nonnull ItemStack stack, boolean simulate) {\n+\t\tif (inventory == null || stack.isEmpty()) {\n+\t\t\treturn stack;\n+\t\t}\n+\n+\t\t// not stackable -> just insert into a new slot\n+\t\tif (!stack.isStackable()) {\n+\t\t\treturn insertItem(inventory, stack, simulate);\n+\t\t}\n+\n+\t\tint sizeInventory = inventory.getSlots();\n+\n+\t\t// go through the inventory and try to fill up already existing items\n+\t\tfor (int i = 0; i < sizeInventory; i++) {\n+\t\t\tItemStack slot = inventory.getStackInSlot(i);\n+\n+\t\t\tif (canItemStacksStackRelaxed(slot, stack)) {\n+\t\t\t\tstack = inventory.insertItem(i, stack, simulate);\n+\n+\t\t\t\tif (stack.isEmpty()) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// insert remainder into empty slots\n+\t\tif (!stack.isEmpty()) {\n+\t\t\t// find empty slot\n+\t\t\tfor (int i = 0; i < sizeInventory; i++) {\n+\t\t\t\tif (inventory.getStackInSlot(i).isEmpty()) {\n+\t\t\t\t\tstack = inventory.insertItem(i, stack, simulate);\n+\n+\t\t\t\t\tif (stack.isEmpty()) {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn stack;\n+\t}\n+\n+\t/**\n+\t * giveItemToPlayer without preferred slot\n+\t */\n+\n+\t/* TODO: PlayerMainInvWrapper\n+\tpublic static void giveItemToPlayer(PlayerEntity player, @Nonnull ItemStack stack) {\n+\t\tgiveItemToPlayer(player, stack, -1);\n+\t}*/\n+\n+\t/**\n+\t * Inserts the given itemstack into the players inventory.\n+\t * If the inventory can't hold it, the item will be dropped in the world at the players position.\n+\t *\n+\t * @param player The player to give the item to\n+\t * @param stack  The itemstack to insert\n+\t */\n+\n+\t/* TODO: PlayerMainInvWrapper\n+\tpublic static void giveItemToPlayer(PlayerEntity player, @Nonnull ItemStack stack, int preferredSlot) {\n+\t\tif (stack.isEmpty()) return;\n+\n+\t\tIItemHandler inventory = new PlayerMainInvWrapper(player.inventory);\n+\t\tWorld world = player.world;\n+\n+\t\t// try adding it into the inventory\n+\t\tItemStack remainder = stack;\n+\n+\t\t// insert into preferred slot first\n+\t\tif (preferredSlot >= 0 && preferredSlot < inventory.getSlots()) {\n+\t\t\tremainder = inventory.insertItem(preferredSlot, stack, false);\n+\t\t}\n+\n+\t\t// then into the inventory in general\n+\t\tif (!remainder.isEmpty()) {\n+\t\t\tremainder = insertItemStacked(inventory, remainder, false);\n+\t\t}\n+\n+\t\t// play sound if something got picked up\n+\t\tif (remainder.isEmpty() || remainder.getCount() != stack.getCount()) {\n+\t\t\tworld.playSound(null, player.x, player.y + 0.5, player.z,\n+\t\t\t\t\t\t\tSoundEvents.ENTITY_ITEM_PICKUP, SoundCategory.PLAYERS, 0.2F, ((world.random.nextFloat() - world.random.nextFloat()) * 0.7F + 1.0F) * 2.0F);\n+\t\t}\n+\n+\t\t// drop remaining itemstack into the world\n+\t\tif (!remainder.isEmpty() && !world.isClient) {\n+\t\t\tItemEntity entityitem = new ItemEntity(world, player.x, player.y + 0.5, player.z, remainder);\n+\t\t\tentityitem.setPickupDelay(40);\n+\t\t\tentityitem.setVelocity(entityitem.getVelocity().multiply(0, 1, 0));\n+\n+\t\t\tworld.spawnEntity(entityitem);\n+\t\t}\n+\t}*/\n+\n+\t/**\n+\t * This method uses the standard vanilla algorithm to calculate a comparator output for how \"full\" the inventory is.\n+\t * This method is an adaptation of Container#calcRedstoneFromInventory(IInventory).", "originalCommit": "7619dd2459c1a92730fee0c8fe5e3b5c0e7ed42c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "554f26defd5ccd6057b145586d94c9a564bc7fb4", "url": "https://github.com/PatchworkMC/patchwork-api/commit/554f26defd5ccd6057b145586d94c9a564bc7fb4", "message": "Update patchwork-items/src/main/java/net/minecraftforge/items/ItemHandlerHelper.java", "committedDate": "2020-08-08T23:41:00Z", "type": "commit"}, {"oid": "ef4e2386e184573966c709967b7796dad826c65f", "url": "https://github.com/PatchworkMC/patchwork-api/commit/ef4e2386e184573966c709967b7796dad826c65f", "message": "Merge branch 'master' into feature/iitemhandler", "committedDate": "2020-08-10T01:02:48Z", "type": "commit"}]}