{"pr_number": 79, "pr_title": "Add custom registry support", "pr_createdAt": "2020-06-13T00:25:02Z", "pr_url": "https://github.com/PatchworkMC/patchwork-api/pull/79", "timeline": [{"oid": "2d0564e7b4f040d2c2623185e539adb161c29b87", "url": "https://github.com/PatchworkMC/patchwork-api/commit/2d0564e7b4f040d2c2623185e539adb161c29b87", "message": "Add custom registry support", "committedDate": "2020-06-13T00:24:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzU0NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439697545", "bodyText": "Use placeholder {} instead of string concatenation", "author": "TheGlitch76", "createdAt": "2020-06-13T01:40:37Z", "path": "patchwork-dispatcher/src/main/java/net/patchworkmc/impl/Patchwork.java", "diffHunk": "@@ -63,7 +64,10 @@ private static void dispatch(Map<ForgeInitializer, FMLModContainer> mods, Functi\n \t\tfor (FMLModContainer container : mods.values()) {\n \t\t\tModLoadingContext.get().setActiveContainer(container, new FMLJavaModLoadingContext(container));\n \n-\t\t\tcontainer.getEventBus().post(provider.apply(container));\n+\t\t\tEvent event = provider.apply(container);\n+\t\t\tLOGGER.info(\"Firing event for modid \" + container.getModId() + \" : \" + event.toString());", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzkyMA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439697920", "bodyText": "Why comment this out when it wasn't previously?", "author": "TheGlitch76", "createdAt": "2020-06-13T01:45:03Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistries.java", "diffHunk": "@@ -109,42 +102,49 @@\n \t\t// Make sure all the registries have been setup first.\n \t\tBootstrap.initialize();\n \n+\t\t// Game objects\n \t\tBLOCKS = wrap(\"block\", Block.class);\n+\t\tFLUIDS = wrap(\"fluid\", Fluid.class);\n \t\tITEMS = wrap(\"item\", Item.class);\n-\t\tACTIVITIES = wrap(\"activity\", Activity.class);\n+\t\tPOTIONS = wrap(\"mob_effect\", StatusEffect.class);\n \t\tBIOMES = wrap(\"biome\", Biome.class);\n-\t\tBIOME_PROVIDER_TYPES = wrap(\"biome_source_type\", BiomeSourceType.class);\n-\t\tTILE_ENTITIES = wrap(\"block_entity_type\", BlockEntityType.class);\n-\t\tWORLD_CARVERS = wrap(\"carver\", Carver.class);\n-\t\tCHUNK_GENERATOR_TYPES = wrap(\"chunk_generator_type\", ChunkGeneratorType.class);\n-\t\tCHUNK_STATUS = wrap(\"chunk_status\", ChunkStatus.class);\n-\t\twrap(\"custom_stat\", Identifier.class);\n-\t\tDECORATORS = wrap(\"decorator\", Decorator.class);\n-\t\twrap(\"dimension_type\", DimensionType.class);\n+\t\tSOUND_EVENTS = wrap(\"sound_event\", SoundEvent.class);\n+\t\tPOTION_TYPES = wrap(\"potion\", Potion.class);\n \t\tENCHANTMENTS = wrap(\"enchantment\", Enchantment.class);\n \t\tENTITIES = wrap(\"entity_type\", EntityType.class);\n-\t\tFEATURES = wrap(\"feature\", Feature.class);\n-\t\tFLUIDS = wrap(\"fluid\", Fluid.class);\n-\t\tMEMORY_MODULE_TYPES = wrap(\"memory_module_type\", MemoryModuleType.class);\n+\t\tTILE_ENTITIES = wrap(\"block_entity_type\", BlockEntityType.class);\n+\t\tPARTICLE_TYPES = wrap(\"particle_type\", ParticleType.class);\n \t\tCONTAINERS = wrap(\"menu\", ContainerType.class);\n-\t\tPOTIONS = wrap(\"mob_effect\", StatusEffect.class);\n \t\tPAINTING_TYPES = wrap(\"motive\", PaintingMotive.class);\n-\t\tPARTICLE_TYPES = wrap(\"particle_type\", ParticleType.class);\n-\t\tPOI_TYPES = wrap(\"point_of_interest_type\", PointOfInterestType.class);\n-\t\tPOTION_TYPES = wrap(\"potion\", Potion.class);\n \t\tRECIPE_SERIALIZERS = wrap(\"recipe_serializer\", RecipeSerializer.class);\n+\t\tSTAT_TYPES = wrap(\"stat_type\", StatType.class);\n+\n+\t\t// Villages\n+\t\tPROFESSIONS = wrap(\"villager_profession\", VillagerProfession.class);\n+\t\tPOI_TYPES = wrap(\"point_of_interest_type\", PointOfInterestType.class);\n+\t\tMEMORY_MODULE_TYPES = wrap(\"memory_module_type\", MemoryModuleType.class);\n+\t\tSENSOR_TYPES = wrap(\"sensor_type\", SensorType.class);\n+\t\tSCHEDULES = wrap(\"schedule\", Schedule.class);\n+\t\tACTIVITIES = wrap(\"activity\", Activity.class);\n+\n+\t\t// Worldgen\n+\t\tWORLD_CARVERS = wrap(\"carver\", Carver.class);\n+\t\tSURFACE_BUILDERS = wrap(\"surface_builder\", SurfaceBuilder.class);\n+\t\tFEATURES = wrap(\"feature\", Feature.class);\n+\t\tDECORATORS = wrap(\"decorator\", Decorator.class);\n+\t\tBIOME_PROVIDER_TYPES = wrap(\"biome_source_type\", BiomeSourceType.class);\n+\t\tCHUNK_GENERATOR_TYPES = wrap(\"chunk_generator_type\", ChunkGeneratorType.class);\n+\t\tCHUNK_STATUS = wrap(\"chunk_status\", ChunkStatus.class);\n+\n+\t\t// TODO: Patchwork Project, check these\n+\t\twrap(\"dimension_type\", DimensionType.class);\n+\t\twrap(\"custom_stat\", Identifier.class);\n \t\twrap(\"recipe_type\", RecipeType.class);\n \t\twrap(\"rule_test\", RuleTestType.class);\n-\t\tSCHEDULES = wrap(\"schedule\", Schedule.class);\n-\t\tSENSOR_TYPES = wrap(\"sensor_type\", SensorType.class);\n-\t\tSOUND_EVENTS = wrap(\"sound_event\", SoundEvent.class);\n-\t\tSTAT_TYPES = wrap(\"stat_type\", StatType.class);\n-\t\twrap(\"structure_feature\", StructureFeature.class);\n+\t\t/*wrap(\"structure_feature\", StructureFeature.class);", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNTI0NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439725244", "bodyText": "These types don't have a registry in Forge.\nIn particular, StructureFeature extends Feature, so StructureFeature cannot be a registry base class, as this violates forge's registry rule: a new registry type should not be a sub class of an existing registry type\nPlease correct me if these are not true.", "author": "rikka0w0", "createdAt": "2020-06-13T09:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NzkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5ODEwNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439698106", "bodyText": "What's up with these package-private members? If they're unused they can safely be removed.\nIt would also reduce the noise of this PR a fair bit.", "author": "TheGlitch76", "createdAt": "2020-06-13T01:46:55Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -19,189 +19,804 @@\n \n package net.minecraftforge.registries;\n \n-import java.util.ArrayList;\n+import java.util.BitSet;\n import java.util.Collection;\n-import java.util.HashSet;\n+import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n+import java.util.Map.Entry;\n \n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n \n+import org.apache.commons.lang3.Validate;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.Marker;\n import org.apache.logging.log4j.MarkerManager;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import net.minecraftforge.fml.ModLoadingContext;\n+import net.minecraftforge.fml.common.ObfuscationReflectionHelper;\n \n import net.minecraft.util.Identifier;\n-import net.minecraft.util.registry.DefaultedRegistry;\n-import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+// TODO: snapshot and missing mapping are not implemented\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryInternal<V>, IForgeRegistryModifiable<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n+\t//private static Marker REGISTRYDUMP = MarkerManager.getMarker(\"REGISTRYDUMP\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final RegistryManager stage;\n+\tprivate final BiMap<Integer, V> ids = HashBiMap.create();\n+\tprivate final BiMap<Identifier, V> names = HashBiMap.create();\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, Identifier> aliases = Maps.newHashMap();\n+\tfinal Map<Identifier, ?> slaves = Maps.newHashMap();\n+\tprivate final Identifier defaultKey;\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final ValidateCallback<V> validate;\n+\tprivate final BakeCallback<V> bake;\n+\t//private final MissingFactory<V> missing;\n+\tprivate final BitSet availabilityMap;\n+\tprivate final Set<Identifier> dummies = Sets.newHashSet();\n+\tprivate final Set<Integer> blocked = Sets.newHashSet();\n+\tprivate final Multimap<Identifier, V> overrides = ArrayListMultimap.create();\n+\tprivate final BiMap<OverrideOwner, V> owners = HashBiMap.create();\n+\tprivate final DummyFactory<V> dummyFactory;\n+\tprivate final boolean isDelegated;\n+\tprivate final int min;\n+\tprivate final int max;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate V defaultValue = null;\n+\tboolean isFrozen = false;\n+\n+\tprivate final Identifier name;\n+\tprivate final RegistryBuilder<V> builder;\n+\n+\tForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n \t\tthis.name = name;\n-\t\tthis.vanilla = vanilla;\n-\t\tthis.superType = superType;\n-\t}\n-\n-\t@Override\n-\tpublic Identifier getRegistryName() {\n-\t\treturn name;\n+\t\tthis.builder = builder;\n+\t\tthis.stage = stage;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.defaultKey = builder.getDefault();\n+\t\tthis.min = builder.getMinId();\n+\t\tthis.max = builder.getMaxId();\n+\t\tthis.availabilityMap = new BitSet(Math.min(max + 1, 0x0FFF));\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.validate = builder.getValidate();\n+\t\tthis.bake = builder.getBake();\n+\t\t//this.missing = builder.getMissingFactory();\n+\t\tthis.dummyFactory = builder.getDummyFactory();\n+\t\tthis.isDelegated = ForgeRegistryEntry.class.isAssignableFrom(superType); //TODO: Make this IDelegatedRegistryEntry?\n+\t\tthis.allowOverrides = builder.getAllowOverrides();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n+\n+\t\tif (this.create != null) {\n+\t\t\tthis.create.onCreate(this, stage);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic Class<V> getRegistrySuperType() {\n-\t\treturn superType;\n+\tpublic void register(V value) {\n+\t\tadd(-1, value);\n \t}\n \n \t@Override\n-\tpublic void register(V value) {\n-\t\tObjects.requireNonNull(value, \"value must not be null\");\n-\t\tIdentifier identifier = value.getRegistryName();\n-\n-\t\tOptional<V> potentialOldValue = vanilla.getOrEmpty(identifier);\n+\tpublic Iterator<V> iterator() {\n+\t\treturn new Iterator<V>() {\n+\t\t\tint cur = -1;\n+\t\t\tV next = null;\n+\t\t\t{ next(); }\n+\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn next != null;\n+\t\t\t}\n \n-\t\tpotentialOldValue.ifPresent(\n-\t\t\t\toldValue -> {\n-\t\t\t\t\tif (oldValue == value) {\n-\t\t\t\t\t\tLOGGER.warn(REGISTRIES, \"Registry {}: The object {} has been registered twice for the same name {}.\", this.superType.getSimpleName(), value, identifier);\n+\t\t\t@Override\n+\t\t\tpublic V next() {\n+\t\t\t\tV ret = next;\n \n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"The name %s has been registered twice, for %s and %s.\", identifier, oldValue, value));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t);\n+\t\t\t\tdo {\n+\t\t\t\t\tcur = availabilityMap.nextSetBit(cur + 1);\n+\t\t\t\t\tnext = ids.get(cur);\n+\t\t\t\t} while (next == null && cur != -1); // nextSetBit returns -1 when none is found\n+\t\t\t\treturn ret;\n+\t\t\t}\n \n-\t\tIdentifier oldIdentifier = vanilla.getId(value);\n+\t\t\t//TODO add remove support?\n+\t\t};\n+\t}\n \n-\t\tif (oldIdentifier != getDefaultKey()) {\n-\t\t\tthrow new IllegalArgumentException(String.format(\"The object %s{%x} has been registered twice, using the names %s and %s.\", value, System.identityHashCode(value), oldIdentifier, identifier));\n-\t\t}\n+\t@Override\n+\tpublic Identifier getRegistryName() {\n+\t\treturn this.name;\n+\t}\n \n-\t\tRegistry.register(vanilla, identifier, value);\n+\t@Override\n+\tpublic Class<V> getRegistrySuperType() {\n+\t\treturn superType;\n \t}\n \n \t@Override\n-\tpublic void registerAll(V... values) {\n+\tpublic void registerAll(@SuppressWarnings(\"unchecked\") V... values) {\n \t\tfor (V value : values) {\n \t\t\tregister(value);\n \t\t}\n \t}\n \n \t@Override\n \tpublic boolean containsKey(Identifier key) {\n-\t\treturn vanilla.containsId(key);\n+\t\twhile (key != null) {\n+\t\t\tif (this.names.containsKey(key)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tkey = this.aliases.get(key);\n+\t\t}\n+\n+\t\treturn false;\n \t}\n \n \t@Override\n \tpublic boolean containsValue(V value) {\n-\t\treturn vanilla.getId(value) != null;\n+\t\treturn this.names.containsValue(value);\n \t}\n \n \t@Override\n \tpublic boolean isEmpty() {\n-\t\treturn vanilla.getIds().isEmpty();\n+\t\treturn this.names.isEmpty();\n \t}\n \n \t@Override\n \tpublic V getValue(Identifier key) {\n-\t\treturn vanilla.get(key);\n+\t\tV ret = this.names.get(key);\n+\t\tkey = this.aliases.get(key);\n+\n+\t\twhile (ret == null && key != null) {\n+\t\t\tret = this.names.get(key);\n+\t\t\tkey = this.aliases.get(key);\n+\t\t}\n+\n+\t\treturn ret == null ? this.defaultValue : ret;\n \t}\n \n \t@Override\n \tpublic Identifier getKey(V value) {\n-\t\treturn vanilla.getId(value);\n+\t\tIdentifier ret = this.names.inverse().get(value);\n+\t\treturn ret == null ? this.defaultKey : ret;\n+\t}\n+\n+\t@Override\n+\tpublic Set<Identifier> getKeys() {\n+\t\treturn Collections.unmodifiableSet(this.names.keySet());\n+\t}\n+\n+\t@Nonnull\n+\t@Override\n+\tpublic Collection<V> getValues() {\n+\t\treturn Collections.unmodifiableSet(this.names.values());\n+\t}\n+\n+\t@Override\n+\tpublic Set<Entry<Identifier, V>> getEntries() {\n+\t\treturn Collections.unmodifiableSet(this.names.entrySet());\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\tpublic <T> T getSlaveMap(Identifier name, Class<T> type) {\n+\t\treturn (T) this.slaves.get(name);\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n+\tpublic void setSlaveMap(Identifier name, Object obj) {\n+\t\t((Map<Identifier, Object>) this.slaves).put(name, obj);\n+\t}\n+\n+\tpublic int getID(V value) {\n+\t\tInteger ret = this.ids.inverse().get(value);\n+\n+\t\tif (ret == null && this.defaultValue != null) {\n+\t\t\tret = this.ids.inverse().get(this.defaultValue);\n+\t\t}\n+\n+\t\treturn ret == null ? -1 : ret.intValue();\n+\t}\n+\n+\tpublic int getID(Identifier name) {\n+\t\treturn getID(this.names.get(name));\n+\t}\n+\n+\tprivate int getIDRaw(V value) {\n+\t\tInteger ret = this.ids.inverse().get(value);\n+\t\treturn ret == null ? -1 : ret.intValue();\n+\t}\n+\n+\tprivate int getIDRaw(Identifier name) {\n+\t\treturn getIDRaw(this.names.get(name));\n+\t}\n+\n+\tpublic V getValue(int id) {\n+\t\tV ret = this.ids.get(id);\n+\t\treturn ret == null ? this.defaultValue : ret;\n+\t}\n+\n+\tvoid validateKey() {", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODIzNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439708237", "bodyText": "I agree, I'd like to avoid pulling in all of the baggage of the ridiculously over complicated Forge registry system with this PR.", "author": "coderbot16", "createdAt": "2020-06-13T04:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5ODEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5ODE4Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439698186", "bodyText": "remove if unused, change the comment to a javadoc otherwise", "author": "TheGlitch76", "createdAt": "2020-06-13T01:47:45Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -19,189 +19,804 @@\n \n package net.minecraftforge.registries;\n \n-import java.util.ArrayList;\n+import java.util.BitSet;\n import java.util.Collection;\n-import java.util.HashSet;\n+import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n+import java.util.Map.Entry;\n \n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n \n+import org.apache.commons.lang3.Validate;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.Marker;\n import org.apache.logging.log4j.MarkerManager;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import net.minecraftforge.fml.ModLoadingContext;\n+import net.minecraftforge.fml.common.ObfuscationReflectionHelper;\n \n import net.minecraft.util.Identifier;\n-import net.minecraft.util.registry.DefaultedRegistry;\n-import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+// TODO: snapshot and missing mapping are not implemented\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryInternal<V>, IForgeRegistryModifiable<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n+\t//private static Marker REGISTRYDUMP = MarkerManager.getMarker(\"REGISTRYDUMP\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final RegistryManager stage;\n+\tprivate final BiMap<Integer, V> ids = HashBiMap.create();\n+\tprivate final BiMap<Identifier, V> names = HashBiMap.create();\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, Identifier> aliases = Maps.newHashMap();\n+\tfinal Map<Identifier, ?> slaves = Maps.newHashMap();\n+\tprivate final Identifier defaultKey;\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final ValidateCallback<V> validate;\n+\tprivate final BakeCallback<V> bake;\n+\t//private final MissingFactory<V> missing;\n+\tprivate final BitSet availabilityMap;\n+\tprivate final Set<Identifier> dummies = Sets.newHashSet();\n+\tprivate final Set<Integer> blocked = Sets.newHashSet();\n+\tprivate final Multimap<Identifier, V> overrides = ArrayListMultimap.create();\n+\tprivate final BiMap<OverrideOwner, V> owners = HashBiMap.create();\n+\tprivate final DummyFactory<V> dummyFactory;\n+\tprivate final boolean isDelegated;\n+\tprivate final int min;\n+\tprivate final int max;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate V defaultValue = null;\n+\tboolean isFrozen = false;\n+\n+\tprivate final Identifier name;\n+\tprivate final RegistryBuilder<V> builder;\n+\n+\tForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n \t\tthis.name = name;\n-\t\tthis.vanilla = vanilla;\n-\t\tthis.superType = superType;\n-\t}\n-\n-\t@Override\n-\tpublic Identifier getRegistryName() {\n-\t\treturn name;\n+\t\tthis.builder = builder;\n+\t\tthis.stage = stage;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.defaultKey = builder.getDefault();\n+\t\tthis.min = builder.getMinId();\n+\t\tthis.max = builder.getMaxId();\n+\t\tthis.availabilityMap = new BitSet(Math.min(max + 1, 0x0FFF));\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.validate = builder.getValidate();\n+\t\tthis.bake = builder.getBake();\n+\t\t//this.missing = builder.getMissingFactory();\n+\t\tthis.dummyFactory = builder.getDummyFactory();\n+\t\tthis.isDelegated = ForgeRegistryEntry.class.isAssignableFrom(superType); //TODO: Make this IDelegatedRegistryEntry?\n+\t\tthis.allowOverrides = builder.getAllowOverrides();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n+\n+\t\tif (this.create != null) {\n+\t\t\tthis.create.onCreate(this, stage);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic Class<V> getRegistrySuperType() {\n-\t\treturn superType;\n+\tpublic void register(V value) {\n+\t\tadd(-1, value);\n \t}\n \n \t@Override\n-\tpublic void register(V value) {\n-\t\tObjects.requireNonNull(value, \"value must not be null\");\n-\t\tIdentifier identifier = value.getRegistryName();\n-\n-\t\tOptional<V> potentialOldValue = vanilla.getOrEmpty(identifier);\n+\tpublic Iterator<V> iterator() {\n+\t\treturn new Iterator<V>() {\n+\t\t\tint cur = -1;\n+\t\t\tV next = null;\n+\t\t\t{ next(); }\n+\n+\t\t\t@Override\n+\t\t\tpublic boolean hasNext() {\n+\t\t\t\treturn next != null;\n+\t\t\t}\n \n-\t\tpotentialOldValue.ifPresent(\n-\t\t\t\toldValue -> {\n-\t\t\t\t\tif (oldValue == value) {\n-\t\t\t\t\t\tLOGGER.warn(REGISTRIES, \"Registry {}: The object {} has been registered twice for the same name {}.\", this.superType.getSimpleName(), value, identifier);\n+\t\t\t@Override\n+\t\t\tpublic V next() {\n+\t\t\t\tV ret = next;\n \n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"The name %s has been registered twice, for %s and %s.\", identifier, oldValue, value));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t);\n+\t\t\t\tdo {\n+\t\t\t\t\tcur = availabilityMap.nextSetBit(cur + 1);\n+\t\t\t\t\tnext = ids.get(cur);\n+\t\t\t\t} while (next == null && cur != -1); // nextSetBit returns -1 when none is found\n+\t\t\t\treturn ret;\n+\t\t\t}\n \n-\t\tIdentifier oldIdentifier = vanilla.getId(value);\n+\t\t\t//TODO add remove support?\n+\t\t};\n+\t}\n \n-\t\tif (oldIdentifier != getDefaultKey()) {\n-\t\t\tthrow new IllegalArgumentException(String.format(\"The object %s{%x} has been registered twice, using the names %s and %s.\", value, System.identityHashCode(value), oldIdentifier, identifier));\n-\t\t}\n+\t@Override\n+\tpublic Identifier getRegistryName() {\n+\t\treturn this.name;\n+\t}\n \n-\t\tRegistry.register(vanilla, identifier, value);\n+\t@Override\n+\tpublic Class<V> getRegistrySuperType() {\n+\t\treturn superType;\n \t}\n \n \t@Override\n-\tpublic void registerAll(V... values) {\n+\tpublic void registerAll(@SuppressWarnings(\"unchecked\") V... values) {\n \t\tfor (V value : values) {\n \t\t\tregister(value);\n \t\t}\n \t}\n \n \t@Override\n \tpublic boolean containsKey(Identifier key) {\n-\t\treturn vanilla.containsId(key);\n+\t\twhile (key != null) {\n+\t\t\tif (this.names.containsKey(key)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\n+\t\t\tkey = this.aliases.get(key);\n+\t\t}\n+\n+\t\treturn false;\n \t}\n \n \t@Override\n \tpublic boolean containsValue(V value) {\n-\t\treturn vanilla.getId(value) != null;\n+\t\treturn this.names.containsValue(value);\n \t}\n \n \t@Override\n \tpublic boolean isEmpty() {\n-\t\treturn vanilla.getIds().isEmpty();\n+\t\treturn this.names.isEmpty();\n \t}\n \n \t@Override\n \tpublic V getValue(Identifier key) {\n-\t\treturn vanilla.get(key);\n+\t\tV ret = this.names.get(key);\n+\t\tkey = this.aliases.get(key);\n+\n+\t\twhile (ret == null && key != null) {\n+\t\t\tret = this.names.get(key);\n+\t\t\tkey = this.aliases.get(key);\n+\t\t}\n+\n+\t\treturn ret == null ? this.defaultValue : ret;\n \t}\n \n \t@Override\n \tpublic Identifier getKey(V value) {\n-\t\treturn vanilla.getId(value);\n+\t\tIdentifier ret = this.names.inverse().get(value);\n+\t\treturn ret == null ? this.defaultKey : ret;\n+\t}\n+\n+\t@Override\n+\tpublic Set<Identifier> getKeys() {\n+\t\treturn Collections.unmodifiableSet(this.names.keySet());\n+\t}\n+\n+\t@Nonnull\n+\t@Override\n+\tpublic Collection<V> getValues() {\n+\t\treturn Collections.unmodifiableSet(this.names.values());\n+\t}\n+\n+\t@Override\n+\tpublic Set<Entry<Identifier, V>> getEntries() {\n+\t\treturn Collections.unmodifiableSet(this.names.entrySet());\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\tpublic <T> T getSlaveMap(Identifier name, Class<T> type) {\n+\t\treturn (T) this.slaves.get(name);\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n+\tpublic void setSlaveMap(Identifier name, Object obj) {\n+\t\t((Map<Identifier, Object>) this.slaves).put(name, obj);\n+\t}\n+\n+\tpublic int getID(V value) {\n+\t\tInteger ret = this.ids.inverse().get(value);\n+\n+\t\tif (ret == null && this.defaultValue != null) {\n+\t\t\tret = this.ids.inverse().get(this.defaultValue);\n+\t\t}\n+\n+\t\treturn ret == null ? -1 : ret.intValue();\n+\t}\n+\n+\tpublic int getID(Identifier name) {\n+\t\treturn getID(this.names.get(name));\n+\t}\n+\n+\tprivate int getIDRaw(V value) {\n+\t\tInteger ret = this.ids.inverse().get(value);\n+\t\treturn ret == null ? -1 : ret.intValue();\n+\t}\n+\n+\tprivate int getIDRaw(Identifier name) {\n+\t\treturn getIDRaw(this.names.get(name));\n+\t}\n+\n+\tpublic V getValue(int id) {\n+\t\tV ret = this.ids.get(id);\n+\t\treturn ret == null ? this.defaultValue : ret;\n+\t}\n+\n+\tvoid validateKey() {\n+\t\tif (this.defaultKey != null) {\n+\t\t\tValidate.notNull(this.defaultValue,\n+\t\t\t\t\t\"Missing default of ForgeRegistry: \" + this.defaultKey + \" Type: \" + this.superType);\n+\t\t}\n+\t}\n+\n+\t@Nullable\n \tpublic Identifier getDefaultKey() {\n-\t\tif (vanilla instanceof DefaultedRegistry) {\n-\t\t\treturn ((DefaultedRegistry<V>) vanilla).getDefaultId();\n+\t\treturn this.defaultKey;\n+\t}\n+\n+\tForgeRegistry<V> copy(RegistryManager stage) {\n+\t\treturn new ForgeRegistry<>(stage, name, builder);\n+\t}\n+\n+\tint add(int id, V value) {\n+\t\tfinal String owner = ModLoadingContext.get().getActiveNamespace();\n+\t\treturn add(id, value, owner);\n+\t}\n+\n+\tint add(int id, V value, String owner) {\n+\t\tIdentifier key = value == null ? null : value.getRegistryName();\n+\t\tPreconditions.checkNotNull(key, \"Can't use a null-name for the registry, object %s.\", value);\n+\t\tPreconditions.checkNotNull(value, \"Can't add null-object to the registry, name %s.\", key);\n+\n+\t\tint idToUse = id;\n+\n+\t\tif (idToUse < 0 || availabilityMap.get(idToUse)) {\n+\t\t\tidToUse = availabilityMap.nextClearBit(min);\n+\t\t}\n+\n+\t\tif (idToUse > max) {\n+\t\t\tthrow new RuntimeException(String.format(\"Invalid id %d - maximum id range exceeded.\", idToUse));\n+\t\t}\n+\n+\t\tV oldEntry = getRaw(key);\n+\t\tif (oldEntry == value) { // already registered, return prev registration's id\n+\t\t\tLOGGER.warn(REGISTRIES, \"Registry {}: The object {} has been registered twice for the same name {}.\",\n+\t\t\t\t\tthis.superType.getSimpleName(), value, key);\n+\t\t\treturn this.getID(value);\n+\t\t}\n+\n+\t\tif (oldEntry != null) { // duplicate name\n+\n+\t\t\tif (!this.allowOverrides) {\n+\t\t\t\tthrow new IllegalArgumentException(String\n+\t\t\t\t\t\t.format(\"The name %s has been registered twice, for %s and %s.\", key, getRaw(key), value));\n+\t\t\t}\n+\n+\t\t\tif (owner == null) {\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\tString.format(\"Could not determine owner for the override on %s. Value: %s\", key, value));\n+\t\t\t}\n+\n+\t\t\tLOGGER.debug(REGISTRIES, \"Registry {} Override: {} {} -> {}\", this.superType.getSimpleName(), key, oldEntry,\n+\t\t\t\t\tvalue);\n+\t\t\tidToUse = this.getID(oldEntry);\n+\t\t}\n+\n+\t\tInteger foundId = this.ids.inverse().get(value); // Is this ever possible to trigger with otherThing being different?\n+\n+\t\tif (foundId != null) {\n+\t\t\tV otherThing = this.ids.get(foundId);\n+\t\t\tthrow new IllegalArgumentException(String.format(\n+\t\t\t\t\t\"The object %s{%x} has been registered twice, using the names %s and %s. (Other object at this id is %s{%x})\",\n+\t\t\t\t\tvalue, System.identityHashCode(value), getKey(value), key, otherThing,\n+\t\t\t\t\tSystem.identityHashCode(otherThing)));\n+\t\t}\n+\n+\t\tif (isLocked()) {\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\tString.format(\"The object %s (name %s) is being added too late.\", value, key));\n+\t\t}\n+\n+\t\tif (defaultKey != null && defaultKey.equals(key)) {\n+\t\t\tif (this.defaultValue != null) {\n+\t\t\t\tthrow new IllegalStateException(String.format(\n+\t\t\t\t\t\t\"Attemped to override already set default value. This is not allowed: The object %s (name %s)\",\n+\t\t\t\t\t\tvalue, key));\n+\t\t\t}\n+\n+\t\t\tthis.defaultValue = value;\n+\t\t}\n+\n+\t\tthis.names.put(key, value);\n+\t\tthis.ids.put(idToUse, value);\n+\t\tthis.availabilityMap.set(idToUse);\n+\t\tthis.owners.put(new OverrideOwner(owner == null ? key.getPath() : owner, key), value);\n+\n+\t\tif (isDelegated) {\n+\t\t\t/*\n+\t\t\t * getDelegate(value).setName(key); if (oldEntry != null) { if\n+\t\t\t * (!this.overrides.get(key).contains(oldEntry)) this.overrides.put(key,\n+\t\t\t * oldEntry); this.overrides.get(key).remove(value); if (this.stage ==\n+\t\t\t * RegistryManager.ACTIVE) getDelegate(oldEntry).changeReference(value); }\n+\t\t\t */\n+\t\t}\n+\n+\t\tif (this.add != null) {\n+\t\t\tthis.add.onAdd(this, this.stage, idToUse, value, oldEntry);\n+\t\t}\n+\n+\t\tif (this.dummies.remove(key)) {\n+\t\t\tLOGGER.debug(REGISTRIES, \"Registry {} Dummy Remove: {}\", this.superType.getSimpleName(), key);\n \t\t}\n \n-\t\treturn null;\n+\t\tLOGGER.trace(REGISTRIES, \"Registry {} add: {} {} {} (req. id {})\", this.superType.getSimpleName(), key, idToUse,\n+\t\t\t\tvalue, id);\n+\n+\t\treturn idToUse;\n \t}\n \n-\t@Override\n-\tpublic Set<Identifier> getKeys() {\n-\t\treturn vanilla.getIds();\n+\tpublic V getRaw(Identifier key) {\n+\t\tV ret = this.names.get(key);\n+\t\tkey = this.aliases.get(key);\n+\n+\t\twhile (ret == null && key != null) {\n+\t\t\tret = this.names.get(key);\n+\t\t\tkey = this.aliases.get(key);\n+\t\t}\n+\n+\t\treturn ret;\n+\t}\n+\n+\t@Deprecated // Public for ByteByfUtils only!", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzY2NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439707665", "bodyText": "I don't think it's needed to fully-qualify Event", "author": "coderbot16", "createdAt": "2020-06-13T04:23:05Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/event/RegistryEvent.java", "diffHunk": "@@ -30,6 +30,16 @@\n \t\tsuper(clazz);\n \t}\n \n+\t/**\n+\t * Register new registries when you receive this event.\n+\t */\n+\tpublic static class NewRegistry extends net.minecraftforge.eventbus.api.Event {", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzczNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439707737", "bodyText": "I'm not sure if it makes sense to have these debugging messages on by default. Maybe drop them from INFO to DEBUG at least?", "author": "coderbot16", "createdAt": "2020-06-13T04:24:37Z", "path": "patchwork-dispatcher/src/main/java/net/patchworkmc/impl/Patchwork.java", "diffHunk": "@@ -63,7 +64,10 @@ private static void dispatch(Map<ForgeInitializer, FMLModContainer> mods, Functi\n \t\tfor (FMLModContainer container : mods.values()) {\n \t\t\tModLoadingContext.get().setActiveContainer(container, new FMLJavaModLoadingContext(container));\n \n-\t\t\tcontainer.getEventBus().post(provider.apply(container));\n+\t\t\tEvent event = provider.apply(container);\n+\t\t\tLOGGER.info(\"Firing event for modid \" + container.getModId() + \" : \" + event.toString());", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNTU5MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439725590", "bodyText": "Yes, sure.\nBtw, how to set the fabric / patchwork logging level to debug?", "author": "rikka0w0", "createdAt": "2020-06-13T09:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MzE5Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439773196", "bodyText": "Not sure, it's probably some log4j setting. Maybe it's better to just remove these messages?", "author": "coderbot16", "createdAt": "2020-06-13T22:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NzcwOA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439847708", "bodyText": "LOGGER.info are changed to LOGGER.debug", "author": "rikka0w0", "createdAt": "2020-06-14T16:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODU3Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439708576", "bodyText": "I noticed that this essentially replaces the old ForgeRegistry class. One of the things that was quite nice about the old system was that it was able to wrap the vanilla registry system instead of reinventing it. Is it possible to preserve that somehow?\nI think the best route would be to trim down this class as is, and then move the old vanilla-wrapping implementation into a separate class inside the patchwork package. Then, at least for vanilla registries, the direct vanilla-wrapping implementation can be used instead, and ForgeRegistry can be used for modded registries.", "author": "coderbot16", "createdAt": "2020-06-13T04:41:45Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -19,189 +19,804 @@\n \n package net.minecraftforge.registries;\n \n-import java.util.ArrayList;\n+import java.util.BitSet;\n import java.util.Collection;\n-import java.util.HashSet;\n+import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n import java.util.Set;\n-import java.util.stream.Collectors;\n+import java.util.Map.Entry;\n \n import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n \n+import org.apache.commons.lang3.Validate;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.Marker;\n import org.apache.logging.log4j.MarkerManager;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import net.minecraftforge.fml.ModLoadingContext;\n+import net.minecraftforge.fml.common.ObfuscationReflectionHelper;\n \n import net.minecraft.util.Identifier;\n-import net.minecraft.util.registry.DefaultedRegistry;\n-import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+// TODO: snapshot and missing mapping are not implemented\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryInternal<V>, IForgeRegistryModifiable<V> {", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNjI2Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439726266", "bodyText": "Yes, I'm reverting back to the  vanilla registry system", "author": "rikka0w0", "createdAt": "2020-06-13T09:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODkwNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439708905", "bodyText": "I'd much prefer it if we could continue using the old vanilla wrapping system for vanilla registries. As is, it seems like attempting to get vanilla content from these registries will fail because the forge registries will only contain the modded content! ForgeRegistry as is should only be used for modded registries, because I don't think its complexity is needed for vanilla registries.", "author": "coderbot16", "createdAt": "2020-06-13T04:47:39Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistries.java", "diffHunk": "@@ -153,16 +153,30 @@\n \t\tIdentifier identifier = new Identifier(\"minecraft\", name);\n \t\tRegistry registry = Registry.REGISTRIES.get(identifier);\n \n-\t\tForgeRegistry wrapped = new ForgeRegistry(identifier, registry, superClazz);", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODQ5OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439768499", "bodyText": "In the latest commit, the entire ForgeRegistry impl is based on the vanilla registry", "author": "rikka0w0", "createdAt": "2020-06-13T20:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODk3NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439708974", "bodyText": "These should be plural names since they're lists. Even better, I think these should be replaced with the Fabric Event system, because that's almost exactly what's replicated here!\n\nEach List<Callback> becomes an Event<Callback>\nThe bodies of getAdd, getClear, etc just become event.invoker()", "author": "coderbot16", "createdAt": "2020-06-13T04:49:11Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.registries;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.Lists;\n+import net.minecraftforge.registries.IForgeRegistry.AddCallback;\n+import net.minecraftforge.registries.IForgeRegistry.BakeCallback;\n+import net.minecraftforge.registries.IForgeRegistry.ClearCallback;\n+import net.minecraftforge.registries.IForgeRegistry.CreateCallback;\n+import net.minecraftforge.registries.IForgeRegistry.DummyFactory;\n+import net.minecraftforge.registries.IForgeRegistry.MissingFactory;\n+import net.minecraftforge.registries.IForgeRegistry.ValidateCallback;\n+\n+import net.minecraft.util.Identifier;\n+\n+public class RegistryBuilder<T extends IForgeRegistryEntry<T>> {\n+\tprivate static final int MAX_ID = Integer.MAX_VALUE - 1;\n+\n+\tprivate Identifier registryName;\n+\tprivate Class<T> registryType;\n+\tprivate Identifier optionalDefaultKey;\n+\tprivate int minId = 0;\n+\tprivate int maxId = MAX_ID;\n+\tprivate List<AddCallback<T>> addCallback = Lists.newArrayList();\n+\tprivate List<ClearCallback<T>> clearCallback = Lists.newArrayList();\n+\tprivate List<CreateCallback<T>> createCallback = Lists.newArrayList();\n+\tprivate List<ValidateCallback<T>> validateCallback = Lists.newArrayList();\n+\tprivate List<BakeCallback<T>> bakeCallback = Lists.newArrayList();", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MjcwMg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439772702", "bodyText": "We cannot use event here, these are not global callba cks, they are implemented by the registry to monitor the modification of its content", "author": "rikka0w0", "createdAt": "2020-06-13T22:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MzE2NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439773164", "bodyText": "Just so we're clear, I'm referring to fabric events here, not Forge events. Fabric events are basically a list (well, it's implemented using an array) of callbacks, which is exactly what's going on here.", "author": "coderbot16", "createdAt": "2020-06-13T22:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MTgxOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439841819", "bodyText": "addCallback is now implemented with the aid of fabric events", "author": "rikka0w0", "createdAt": "2020-06-14T15:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MDE2Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439850167", "bodyText": "Why not use the fabric Event classes here? That's what I was originally requesting. It's possible to replace each List with a fabric Event.", "author": "coderbot16", "createdAt": "2020-06-14T17:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Njc4OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439856789", "bodyText": "This class is just a builder for constructing ForgeRegistry.\nDuring the creation, references to callback handlers are added by forge mods and forge itself.\nUpon the creation of ForgeRegistry, it combines the list into one single xxxCallback handler and the resulting handler is stored inside ForgeRegistry.\nE.g.:\nhttps://github.com/rikka0w0/patchwork-api/blob/22f059b0959ec6b9079af40d4a5496f55aa0bdef/patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java#L213\nI think we should keep the List", "author": "rikka0w0", "createdAt": "2020-06-14T18:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTQwNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439709405", "bodyText": "It's worth a TODO in the right spots if these aren't supported as well.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t//if (builder.getSaveToDisc())\n          \n          \n            \n            \t\t//\tthis.persisted.add(name);\n          \n          \n            \n            \t\t//if (builder.getSync())\n          \n          \n            \n            \t\t//\tthis.synced.add(name);\n          \n          \n            \n            \t\t//for (ResourceLocation legacyName : builder.getLegacyNames())\n          \n          \n            \n            \t\t//\taddLegacyName(legacyName, name);\n          \n          \n            \n            \t\t/*\n          \n          \n            \n            \t\tif (builder.getSaveToDisc())\n          \n          \n            \n            \t\t\tthis.persisted.add(name);\n          \n          \n            \n            \t\tif (builder.getSync())\n          \n          \n            \n            \t\t\tthis.synced.add(name);\n          \n          \n            \n            \t\tfor (ResourceLocation legacyName : builder.getLegacyNames())\n          \n          \n            \n            \t\t\taddLegacyName(legacyName, name);\n          \n          \n            \n            \t\t*/", "author": "coderbot16", "createdAt": "2020-06-13T04:57:08Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -52,19 +60,79 @@ public String getName() {\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> getRegistry(Class<? super V> clazz) {\n-\t\treturn getRegistry(RegistryClassMapping.getIdentifier(clazz));\n+\t\tIdentifier existingKey = this.getName(clazz);\n+\n+\t\tif (existingKey == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn getRegistry(existingKey);\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> Identifier getName(IForgeRegistry<V> reg) {\n \t\treturn reg.getRegistryName();\n \t}\n \n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the mapping\n-\t */\n-\tvoid addRegistry(Identifier key, ForgeRegistry registry) {\n-\t\tregistries.put(key, registry);\n+\tpublic Identifier getName(Class<?> clazz) {\n+\t\tif (clazz == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tdo {\n+\t\t\tIdentifier existingKey = RegistryManager.ACTIVE.superTypes.get(clazz);\n+\n+\t\t\tif (existingKey != null) {\n+\t\t\t\treturn existingKey;\n+\t\t\t}\n+\n+\t\t\tclazz = clazz.getSuperclass();\n+\t\t} while (clazz != null && clazz != Object.class);\n+\n+\t\treturn null;\n+\t}\n+\n+\tpublic Set<Identifier> getRegistryNames() {\n+\t\treturn this.registries.keySet();\n+\t}\n+\n+\t<V extends IForgeRegistryEntry<V>> ForgeRegistry<V> createRegistry(Identifier name, RegistryBuilder<V> builder) {\n+\t\tSet<Class<?>> parents = Sets.newHashSet();\n+\t\tfindSuperTypes(builder.getType(), parents);\n+\t\tSetView<Class<?>> overlappedTypes = Sets.intersection(parents, superTypes.keySet());\n+\n+\t\tif (!overlappedTypes.isEmpty()) {\n+\t\t\tClass<?> foundType = overlappedTypes.iterator().next();\n+\t\t\tLOGGER.error(\n+\t\t\t\t\t\"Found existing registry of type {} named {}, you cannot create a new registry ({}) with type {}, as {} has a parent of that type\",\n+\t\t\t\t\tfoundType, superTypes.get(foundType), name, builder.getType(), builder.getType());\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Duplicate registry parent type found - you can only have one registry for a particular super type\");\n+\t\t}\n+\n+\t\tForgeRegistry<V> reg = new ForgeRegistry<V>(this, name, builder);\n+\t\tregistries.put(name, reg);\n+\t\tsuperTypes.put(builder.getType(), name);\n+\t\t//if (builder.getSaveToDisc())\n+\t\t//\tthis.persisted.add(name);\n+\t\t//if (builder.getSync())\n+\t\t//\tthis.synced.add(name);\n+\t\t//for (ResourceLocation legacyName : builder.getLegacyNames())\n+\t\t//\taddLegacyName(legacyName, name);", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTQ3Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439709473", "bodyText": "Why move this call around? There's no need to sort with those entries in the list if they're going to be removed and re-added anyways.", "author": "coderbot16", "createdAt": "2020-06-13T04:58:29Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/RegistryEventDispatcher.java", "diffHunk": "@@ -26,36 +26,26 @@\n import java.util.function.Consumer;\n \n import net.minecraftforge.event.RegistryEvent;\n-import net.minecraftforge.registries.IForgeRegistry;\n+import net.minecraftforge.registries.ForgeRegistry;\n+import net.minecraftforge.registries.RegistryManager;\n \n-import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.Identifier;\n \n @SuppressWarnings(\"rawtypes\")\n public class RegistryEventDispatcher {\n \tprivate static final boolean CHECK_SUPERS = false;\n-\tprivate static List<IForgeRegistry> registered = new ArrayList<>();\n-\n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the dispatch list\n-\t */\n-\tpublic static void register(IForgeRegistry registry) {\n-\t\tregistered.add(registry);\n-\t}\n \n \t/**\n \t * @return the ordering of registries that Forge expects\n \t */\n \tprivate static List<Identifier> getExpectedOrdering() {\n-\t\tList<Identifier> registries = new ArrayList<>(Registry.REGISTRIES.getIds());\n+\t\tList<Identifier> registries = new ArrayList<>(RegistryManager.ACTIVE.getRegistryNames());\n+\t\tregistries.sort((o1, o2) -> String.valueOf(o1).compareToIgnoreCase(String.valueOf(o2)));\n \n \t\tregistries.remove(Registry.REGISTRIES.getId(Registry.BLOCK));\n \t\tregistries.remove(Registry.REGISTRIES.getId(Registry.ITEM));\n \n-\t\tregistries.sort((o1, o2) -> String.valueOf(o1).compareToIgnoreCase(String.valueOf(o2)));", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NTc5Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439845797", "bodyText": "It has been reverted", "author": "rikka0w0", "createdAt": "2020-06-14T16:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTUyMg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439709522", "bodyText": "Since this is no longer used for validation, this could be renamed.", "author": "coderbot16", "createdAt": "2020-06-13T04:59:57Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/RegistryEventDispatcher.java", "diffHunk": "@@ -26,36 +26,26 @@\n import java.util.function.Consumer;\n \n import net.minecraftforge.event.RegistryEvent;\n-import net.minecraftforge.registries.IForgeRegistry;\n+import net.minecraftforge.registries.ForgeRegistry;\n+import net.minecraftforge.registries.RegistryManager;\n \n-import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.Identifier;\n \n @SuppressWarnings(\"rawtypes\")\n public class RegistryEventDispatcher {\n \tprivate static final boolean CHECK_SUPERS = false;\n-\tprivate static List<IForgeRegistry> registered = new ArrayList<>();\n-\n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the dispatch list\n-\t */\n-\tpublic static void register(IForgeRegistry registry) {\n-\t\tregistered.add(registry);\n-\t}\n \n \t/**\n \t * @return the ordering of registries that Forge expects\n \t */\n \tprivate static List<Identifier> getExpectedOrdering() {", "originalCommit": "2d0564e7b4f040d2c2623185e539adb161c29b87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "url": "https://github.com/PatchworkMC/patchwork-api/commit/4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "message": "Use vanilla registry for storage, simplify impl", "committedDate": "2020-06-13T20:52:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439768745", "bodyText": "ForgeRegistry#getSlaveMap and ForgeRegistry#setSlaveMap are for handing special vanilla case:\nStructrueFeature extends Feature, this is not allowed in Forge, so they created \"SlaveMap\". Not sure if we should keep this.", "author": "rikka0w0", "createdAt": "2020-06-13T20:58:41Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -204,4 +272,72 @@ public int hashCode() {\n \t\t\treturn identifier.hashCode() * 33 + value.hashCode();\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used to control the times where people can modify this registry.\n+\t * Users should only ever register things in the Register<?> events!\n+\t */\n+\tpublic void freeze() {\n+\t\tthis.isFrozen = true;\n+\t}\n+\n+\tpublic void unfreeze() {\n+\t\tthis.isFrozen = false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isLocked() {\n+\t\treturn this.isFrozen;\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to clear a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to clear the registry to late.\");\n+\t\t}\n+\n+\t\tif (!this.isVanilla) {\n+\t\t\tthrow new UnsupportedOperationException(\"Vanilla registry does not support clear().\");\n+\t\t}\n+\n+\t\tif (this.clear != null) {\n+\t\t\tthis.clear.onClear(this, stage);\n+\t\t}\n+\n+\t\tExtendedVanillaRegistry<V> reg = (ExtendedVanillaRegistry<V>) this.vanilla;\n+\t\treg.clear();\n+\t}\n+\n+\t@Override\n+\tpublic V remove(Identifier key) {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to remove from a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to remove from the registry to late.\");\n+\t\t}\n+\n+\t\tif (!this.isVanilla) {\n+\t\t\tthrow new UnsupportedOperationException(\"Vanilla registry does not support remove().\");\n+\t\t}\n+\n+\t\tthrow new UnsupportedOperationException(\"Remove() is not implemented for Forge Mod registries.\");\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\tpublic <T> T getSlaveMap(Identifier name, Class<T> type) {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTU4OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439769589", "bodyText": "Is it something that could be redirected in Patcher, or is it too much of a hack?", "author": "TheGlitch76", "createdAt": "2020-06-13T21:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MjU2Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439772563", "bodyText": "I'm also looking at it", "author": "rikka0w0", "createdAt": "2020-06-13T22:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MzMyMg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439773322", "bodyText": "I think it's possible to work with this system while still using our vanilla wrapper implementation, I think we can avoid patcher here.", "author": "coderbot16", "createdAt": "2020-06-13T22:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NDc3MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439844770", "bodyText": "Forge mods register both Feature and StructureFeature during IForgeRegistry<Feature<?>> registry event:\nhttps://github.com/Cheaterpaul/Vampirism/blob/1.14/src/main/java/de/teamlapen/vampirism/core/ModFeatures.java", "author": "rikka0w0", "createdAt": "2020-06-14T16:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NjAwNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439846004", "bodyText": "getSlaveMap is declared in IForgeRegistry, so it is a part of the Forge API, we should keep this to maintain compatibility", "author": "rikka0w0", "createdAt": "2020-06-14T16:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjkwMA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439852900", "bodyText": "I think we could create a class extending ForgeRegistry that properly splits Feature and StructureFeature between the two registries.", "author": "coderbot16", "createdAt": "2020-06-14T17:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2Mzc4Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863786", "bodyText": "StructureFeature is supported", "author": "rikka0w0", "createdAt": "2020-06-14T20:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc2MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439768760", "bodyText": "as in DefaultedRegistry?", "author": "TheGlitch76", "createdAt": "2020-06-13T20:59:04Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/ExtendedVanillaRegistry.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.impl.registries;\n+\n+import net.minecraftforge.registries.ForgeRegistry;\n+import net.minecraftforge.registries.IForgeRegistryEntry;\n+\n+import net.minecraft.util.registry.SimpleRegistry;\n+\n+// TODO: implement default registry", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MjgyMg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439772822", "bodyText": "Yes", "author": "rikka0w0", "createdAt": "2020-06-13T22:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODI4Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439848286", "bodyText": "But for this minor version, let's just use the functions provided by SimpleRegistry. They should be able to covert most Forge mod usage. After this pr, I'm going to reimpl this class to give full forge compatibility", "author": "rikka0w0", "createdAt": "2020-06-14T16:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODk5MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439768991", "bodyText": "Ew.\nWould changing this to a normal while loop and removing the extra null check above break any behavior in this method?", "author": "TheGlitch76", "createdAt": "2020-06-13T21:02:56Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -43,28 +53,121 @@ public String getName() {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> Class<V> getSuperType(Identifier key) {\n-\t\treturn (Class<V>) RegistryClassMapping.getClass(key);\n+\t\treturn (Class<V>) this.superTypes.inverse().get(key);\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> ForgeRegistry<V> getRegistry(Identifier key) {\n-\t\treturn (ForgeRegistry<V>) this.registries.get(key);\n+\t\tRegistry<?> vanillaRegistry = Registry.REGISTRIES.get(key);\n+\n+\t\tif (vanillaRegistry instanceof ForgeRegistryProvider) {\n+\t\t\treturn ((ForgeRegistryProvider) vanillaRegistry).getForgeRegistry();\n+\t\t}\n+\n+\t\treturn null;\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> getRegistry(Class<? super V> clazz) {\n-\t\treturn getRegistry(RegistryClassMapping.getIdentifier(clazz));\n+\t\tIdentifier existingKey = this.getName(clazz);\n+\n+\t\tif (existingKey == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn getRegistry(existingKey);\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> Identifier getName(IForgeRegistry<V> reg) {\n \t\treturn reg.getRegistryName();\n \t}\n \n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the mapping\n-\t */\n-\tvoid addRegistry(Identifier key, ForgeRegistry registry) {\n-\t\tregistries.put(key, registry);\n+\tpublic Identifier getName(Class<?> clazz) {\n+\t\tif (clazz == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tdo {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MDUxNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439770514", "bodyText": "Object.class.getSuperclass() returns null, so that part stays the same. But, the existingKey code would be missed. Is there any reason that the existingKey stuff isn't the first thing in the method? EDIT: didn't notice its actual behavior", "author": "coderbot16", "createdAt": "2020-06-13T21:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzk3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777978", "bodyText": "Okay, after looking closely, it would only change the behavior if there's a registry with a super type of Object. That shouldn't happen, and in fact, we should probably have checks for that in the creation methods.", "author": "coderbot16", "createdAt": "2020-06-13T23:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NjA3Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439846073", "bodyText": "I have changed the loop to a standard while loop", "author": "rikka0w0", "createdAt": "2020-06-14T16:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTA1Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439769052", "bodyText": "This is a tiny nitpick, but please replace Sets.newHashSet() in this file with the diamond operator new HashSet<>()", "author": "TheGlitch76", "createdAt": "2020-06-13T21:04:39Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -43,28 +53,121 @@ public String getName() {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> Class<V> getSuperType(Identifier key) {\n-\t\treturn (Class<V>) RegistryClassMapping.getClass(key);\n+\t\treturn (Class<V>) this.superTypes.inverse().get(key);\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> ForgeRegistry<V> getRegistry(Identifier key) {\n-\t\treturn (ForgeRegistry<V>) this.registries.get(key);\n+\t\tRegistry<?> vanillaRegistry = Registry.REGISTRIES.get(key);\n+\n+\t\tif (vanillaRegistry instanceof ForgeRegistryProvider) {\n+\t\t\treturn ((ForgeRegistryProvider) vanillaRegistry).getForgeRegistry();\n+\t\t}\n+\n+\t\treturn null;\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> getRegistry(Class<? super V> clazz) {\n-\t\treturn getRegistry(RegistryClassMapping.getIdentifier(clazz));\n+\t\tIdentifier existingKey = this.getName(clazz);\n+\n+\t\tif (existingKey == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn getRegistry(existingKey);\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> Identifier getName(IForgeRegistry<V> reg) {\n \t\treturn reg.getRegistryName();\n \t}\n \n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the mapping\n-\t */\n-\tvoid addRegistry(Identifier key, ForgeRegistry registry) {\n-\t\tregistries.put(key, registry);\n+\tpublic Identifier getName(Class<?> clazz) {\n+\t\tif (clazz == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tdo {\n+\t\t\tIdentifier existingKey = RegistryManager.ACTIVE.superTypes.get(clazz);\n+\n+\t\t\tif (existingKey != null) {\n+\t\t\t\treturn existingKey;\n+\t\t\t}\n+\n+\t\t\tclazz = clazz.getSuperclass();\n+\t\t} while (clazz != null && clazz != Object.class);\n+\n+\t\treturn null;\n+\t}\n+\n+\tpublic Set<Identifier> getRegistryNames() {\n+\t\treturn Registry.REGISTRIES.getIds();\n+\t}\n+\n+\t<V extends IForgeRegistryEntry<V>> ForgeRegistry<V> createRegistry(Identifier name, RegistryBuilder<V> builder) {\n+\t\tSet<Class<?>> parents = Sets.newHashSet();", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODM1Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439848352", "bodyText": "fixed", "author": "rikka0w0", "createdAt": "2020-06-14T16:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTMzNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439769337", "bodyText": "Diamond operator here please", "author": "TheGlitch76", "createdAt": "2020-06-13T21:10:05Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -40,17 +41,68 @@\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryModifiable<V>, IForgeRegistryInternal<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = Maps.newHashMap();", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUxOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439769519", "bodyText": "What would these callbacks be used for?", "author": "TheGlitch76", "createdAt": "2020-06-13T21:12:49Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -40,17 +41,68 @@\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryModifiable<V>, IForgeRegistryInternal<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = Maps.newHashMap();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\n+\t/**\n+\t * Called by RegistryBuilder, for moded registries.\n+\t * @param stage\n+\t * @param name\n+\t * @param builder\n+\t */\n+\tpublic ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n+\t\tthis.name = name;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n \n+\t\tthis.vanilla = new ExtendedVanillaRegistry<>(this);\n+\t\tthis.isVanilla = false;\n+\n+\t\tif (this.create != null) {\n+\t\t\tthis.create.onCreate(this, stage);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * For vanilla registeries.\n+\t * @param name\n+\t * @param vanilla\n+\t * @param superType\n+\t */\n \tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n \t\tthis.name = name;\n \t\tthis.vanilla = vanilla;\n \t\tthis.superType = superType;\n+\n+\t\tthis.create = null;\n+\t\tthis.add = null;", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MjQ4Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439772487", "bodyText": "These callbacks are set in the RegistryBuilder, when the ForgeRegistry is created. We should keep this to maintain compatibility with Forge", "author": "rikka0w0", "createdAt": "2020-06-13T22:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3OTQ0Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439779447", "bodyText": "This should be fired then.\nI believe coderbot's comment on RegistryEntryAddedCallback would resolve this.", "author": "TheGlitch76", "createdAt": "2020-06-14T00:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NjI2Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439846266", "bodyText": "In the latest commit, the mixin injection is replaced by a RegistryEntryAddedCallback", "author": "rikka0w0", "createdAt": "2020-06-14T16:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUzNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439769537", "bodyText": "this.create != null will always be true", "author": "TheGlitch76", "createdAt": "2020-06-13T21:13:10Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -40,17 +41,68 @@\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryModifiable<V>, IForgeRegistryInternal<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = Maps.newHashMap();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\n+\t/**\n+\t * Called by RegistryBuilder, for moded registries.\n+\t * @param stage\n+\t * @param name\n+\t * @param builder\n+\t */\n+\tpublic ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n+\t\tthis.name = name;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n \n+\t\tthis.vanilla = new ExtendedVanillaRegistry<>(this);\n+\t\tthis.isVanilla = false;\n+\n+\t\tif (this.create != null) {\n+\t\t\tthis.create.onCreate(this, stage);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * For vanilla registeries.\n+\t * @param name\n+\t * @param vanilla\n+\t * @param superType\n+\t */\n \tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n \t\tthis.name = name;\n \t\tthis.vanilla = vanilla;\n \t\tthis.superType = superType;\n+\n+\t\tthis.create = null;\n+\t\tthis.add = null;\n+\t\tthis.clear = null;\n+\t\tthis.stage = null;\n+\t\tthis.isModifiable = false;\n+\t\tthis.isVanilla = true;\n+\n+\t\tif (this.create != null) {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzc3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777778", "bodyText": "You mean, it will always be false? This code looks like dead code to me.", "author": "coderbot16", "createdAt": "2020-06-13T23:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3OTM5Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439779392", "bodyText": "Yes, that was a typo", "author": "TheGlitch76", "createdAt": "2020-06-14T00:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NjM5NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439846394", "bodyText": "this.create can be null, if RegistryBuilder does not supply any callbacks. Upon registry creation, RegistryBuilder batch all callbacks into one. So here we need to check the nullity.", "author": "rikka0w0", "createdAt": "2020-06-14T16:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2OTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NjI1Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439776257", "bodyText": "Why not use RegistryEntryAddedCallback instead? It allows you to listen to registry additions quite easily. It would allow you to remove this mixin, VanillaRegistry, and ForgeRegistryProvider.", "author": "coderbot16", "createdAt": "2020-06-13T23:02:25Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/mixin/registries/MixinSimpleRegistry.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.mixin.registries;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n+import net.minecraftforge.registries.ForgeRegistry;\n+import net.minecraftforge.registries.IForgeRegistryEntry;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.SimpleRegistry;\n+\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+@Mixin(SimpleRegistry.class)\n+public abstract class MixinSimpleRegistry<T> implements VanillaRegistry {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NDk5MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439844990", "bodyText": "RegistryEntryAddedCallback is used in the latest commit, the unnecessary mixin injection is removed", "author": "rikka0w0", "createdAt": "2020-06-14T16:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NjI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzI4NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777284", "bodyText": "This should probably actually be implemented as a mixin to SimpleRegistry, and then have a ClearableRegistry interface implemented by the mixin.", "author": "coderbot16", "createdAt": "2020-06-13T23:24:52Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/ExtendedVanillaRegistry.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.impl.registries;\n+\n+import net.minecraftforge.registries.ForgeRegistry;\n+import net.minecraftforge.registries.IForgeRegistryEntry;\n+\n+import net.minecraft.util.registry.SimpleRegistry;\n+\n+// TODO: implement default registry\n+public class ExtendedVanillaRegistry<V extends IForgeRegistryEntry<V>> extends SimpleRegistry<V> implements ForgeRegistryProvider {\n+\tprivate final ForgeRegistry<V> forgeRegistry;\n+\tpublic ExtendedVanillaRegistry(ForgeRegistry<V> forgeRegistry) {\n+\t\tthis.forgeRegistry = forgeRegistry;\n+\t}\n+\n+\tpublic void clear() {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgxOTA2NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439819064", "bodyText": "This class is for forge modded registries, they may need functions that is not supported by SimpleRegistry, like remove(). I'm planning to reimpl this", "author": "rikka0w0", "createdAt": "2020-06-14T11:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NzYzMA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439847630", "bodyText": "ClearableRegistry is created", "author": "rikka0w0", "createdAt": "2020-06-14T16:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzM3Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777372", "bodyText": "Per the StructureFeature / Feature issue and similar issues with ForgeRegistry, will this crash or break mods as is? I would think that the overlap checks would cause this to fail or mess up somehow.", "author": "coderbot16", "createdAt": "2020-06-13T23:26:39Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistries.java", "diffHunk": "@@ -109,57 +105,57 @@\n \t\t// Make sure all the registries have been setup first.\n \t\tBootstrap.initialize();\n \n+\t\t// Game objects\n \t\tBLOCKS = wrap(\"block\", Block.class);\n+\t\tFLUIDS = wrap(\"fluid\", Fluid.class);\n \t\tITEMS = wrap(\"item\", Item.class);\n-\t\tACTIVITIES = wrap(\"activity\", Activity.class);\n+\t\tPOTIONS = wrap(\"mob_effect\", StatusEffect.class);\n \t\tBIOMES = wrap(\"biome\", Biome.class);\n-\t\tBIOME_PROVIDER_TYPES = wrap(\"biome_source_type\", BiomeSourceType.class);\n-\t\tTILE_ENTITIES = wrap(\"block_entity_type\", BlockEntityType.class);\n-\t\tWORLD_CARVERS = wrap(\"carver\", Carver.class);\n-\t\tCHUNK_GENERATOR_TYPES = wrap(\"chunk_generator_type\", ChunkGeneratorType.class);\n-\t\tCHUNK_STATUS = wrap(\"chunk_status\", ChunkStatus.class);\n-\t\twrap(\"custom_stat\", Identifier.class);\n-\t\tDECORATORS = wrap(\"decorator\", Decorator.class);\n-\t\twrap(\"dimension_type\", DimensionType.class);\n+\t\tSOUND_EVENTS = wrap(\"sound_event\", SoundEvent.class);\n+\t\tPOTION_TYPES = wrap(\"potion\", Potion.class);\n \t\tENCHANTMENTS = wrap(\"enchantment\", Enchantment.class);\n \t\tENTITIES = wrap(\"entity_type\", EntityType.class);\n-\t\tFEATURES = wrap(\"feature\", Feature.class);\n-\t\tFLUIDS = wrap(\"fluid\", Fluid.class);\n-\t\tMEMORY_MODULE_TYPES = wrap(\"memory_module_type\", MemoryModuleType.class);\n+\t\tTILE_ENTITIES = wrap(\"block_entity_type\", BlockEntityType.class);\n+\t\tPARTICLE_TYPES = wrap(\"particle_type\", ParticleType.class);\n \t\tCONTAINERS = wrap(\"menu\", ContainerType.class);\n-\t\tPOTIONS = wrap(\"mob_effect\", StatusEffect.class);\n \t\tPAINTING_TYPES = wrap(\"motive\", PaintingMotive.class);\n-\t\tPARTICLE_TYPES = wrap(\"particle_type\", ParticleType.class);\n-\t\tPOI_TYPES = wrap(\"point_of_interest_type\", PointOfInterestType.class);\n-\t\tPOTION_TYPES = wrap(\"potion\", Potion.class);\n \t\tRECIPE_SERIALIZERS = wrap(\"recipe_serializer\", RecipeSerializer.class);\n+\t\tSTAT_TYPES = wrap(\"stat_type\", StatType.class);\n+\n+\t\t// Villages\n+\t\tPROFESSIONS = wrap(\"villager_profession\", VillagerProfession.class);\n+\t\tPOI_TYPES = wrap(\"point_of_interest_type\", PointOfInterestType.class);\n+\t\tMEMORY_MODULE_TYPES = wrap(\"memory_module_type\", MemoryModuleType.class);\n+\t\tSENSOR_TYPES = wrap(\"sensor_type\", SensorType.class);\n+\t\tSCHEDULES = wrap(\"schedule\", Schedule.class);\n+\t\tACTIVITIES = wrap(\"activity\", Activity.class);\n+\n+\t\t// Worldgen\n+\t\tWORLD_CARVERS = wrap(\"carver\", Carver.class);\n+\t\tSURFACE_BUILDERS = wrap(\"surface_builder\", SurfaceBuilder.class);\n+\t\tFEATURES = wrap(\"feature\", Feature.class);\n+\t\tDECORATORS = wrap(\"decorator\", Decorator.class);\n+\t\tBIOME_PROVIDER_TYPES = wrap(\"biome_source_type\", BiomeSourceType.class);\n+\t\tCHUNK_GENERATOR_TYPES = wrap(\"chunk_generator_type\", ChunkGeneratorType.class);\n+\t\tCHUNK_STATUS = wrap(\"chunk_status\", ChunkStatus.class);\n+\n+\t\t// TODO: Patchwork Project, check these\n+\t\twrap(\"dimension_type\", DimensionType.class);\n+\t\twrap(\"custom_stat\", Identifier.class);\n \t\twrap(\"recipe_type\", RecipeType.class);\n \t\twrap(\"rule_test\", RuleTestType.class);\n-\t\tSCHEDULES = wrap(\"schedule\", Schedule.class);\n-\t\tSENSOR_TYPES = wrap(\"sensor_type\", SensorType.class);\n-\t\tSOUND_EVENTS = wrap(\"sound_event\", SoundEvent.class);\n-\t\tSTAT_TYPES = wrap(\"stat_type\", StatType.class);\n \t\twrap(\"structure_feature\", StructureFeature.class);", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgxODc0MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439818741", "bodyText": "If I understand correctly, forge mods register StructureFeatures during RegistryEvent.Register and forge will place them into the correct vanilla registry. So yes, we need to do more stuff on this. I'm thinking about implementing forge's slavemap. The slavemap only affects forge mods, fabric mods are not affected", "author": "rikka0w0", "createdAt": "2020-06-14T11:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2Mzc2Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863763", "bodyText": "StructureFeatures registration for forge mods is now supported", "author": "rikka0w0", "createdAt": "2020-06-14T20:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzY3MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777671", "bodyText": "\ud83d\udeb2 \ud83c\udfe0\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tthrow new IllegalStateException(\"Attempted to clear the registry to late.\");\n          \n          \n            \n            \t\t\tthrow new IllegalStateException(\"Attempted to clear the registry too late.\");", "author": "coderbot16", "createdAt": "2020-06-13T23:34:44Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -204,4 +272,72 @@ public int hashCode() {\n \t\t\treturn identifier.hashCode() * 33 + value.hashCode();\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used to control the times where people can modify this registry.\n+\t * Users should only ever register things in the Register<?> events!\n+\t */\n+\tpublic void freeze() {\n+\t\tthis.isFrozen = true;\n+\t}\n+\n+\tpublic void unfreeze() {\n+\t\tthis.isFrozen = false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isLocked() {\n+\t\treturn this.isFrozen;\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to clear a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to clear the registry to late.\");", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzczMw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777733", "bodyText": "Maybe have a TODO here?", "author": "coderbot16", "createdAt": "2020-06-13T23:35:44Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -204,4 +272,72 @@ public int hashCode() {\n \t\t\treturn identifier.hashCode() * 33 + value.hashCode();\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used to control the times where people can modify this registry.\n+\t * Users should only ever register things in the Register<?> events!\n+\t */\n+\tpublic void freeze() {\n+\t\tthis.isFrozen = true;\n+\t}\n+\n+\tpublic void unfreeze() {\n+\t\tthis.isFrozen = false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isLocked() {\n+\t\treturn this.isFrozen;\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to clear a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to clear the registry to late.\");\n+\t\t}\n+\n+\t\tif (!this.isVanilla) {\n+\t\t\tthrow new UnsupportedOperationException(\"Vanilla registry does not support clear().\");\n+\t\t}\n+\n+\t\tif (this.clear != null) {\n+\t\t\tthis.clear.onClear(this, stage);\n+\t\t}\n+\n+\t\tExtendedVanillaRegistry<V> reg = (ExtendedVanillaRegistry<V>) this.vanilla;\n+\t\treg.clear();\n+\t}\n+\n+\t@Override\n+\tpublic V remove(Identifier key) {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzc2Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777766", "bodyText": "All registries should be able to support clearing with the help of a mixin (see my other comment)", "author": "coderbot16", "createdAt": "2020-06-13T23:36:21Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -204,4 +272,72 @@ public int hashCode() {\n \t\t\treturn identifier.hashCode() * 33 + value.hashCode();\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used to control the times where people can modify this registry.\n+\t * Users should only ever register things in the Register<?> events!\n+\t */\n+\tpublic void freeze() {\n+\t\tthis.isFrozen = true;\n+\t}\n+\n+\tpublic void unfreeze() {\n+\t\tthis.isFrozen = false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isLocked() {\n+\t\treturn this.isFrozen;\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to clear a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to clear the registry to late.\");\n+\t\t}\n+\n+\t\tif (!this.isVanilla) {\n+\t\t\tthrow new UnsupportedOperationException(\"Vanilla registry does not support clear().\");", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MTYwNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439841605", "bodyText": "Could clearing vanilla registries break something?", "author": "rikka0w0", "createdAt": "2020-06-14T15:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzc5Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777792", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * For vanilla registeries.\n          \n          \n            \n            \t * For vanilla registries.", "author": "coderbot16", "createdAt": "2020-06-13T23:37:15Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -40,17 +41,68 @@\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryModifiable<V>, IForgeRegistryInternal<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = Maps.newHashMap();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\n+\t/**\n+\t * Called by RegistryBuilder, for moded registries.\n+\t * @param stage\n+\t * @param name\n+\t * @param builder\n+\t */\n+\tpublic ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n+\t\tthis.name = name;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n \n+\t\tthis.vanilla = new ExtendedVanillaRegistry<>(this);\n+\t\tthis.isVanilla = false;\n+\n+\t\tif (this.create != null) {\n+\t\t\tthis.create.onCreate(this, stage);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * For vanilla registeries.", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NzgwNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777806", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Called by RegistryBuilder, for moded registries.\n          \n          \n            \n            \t * Called by RegistryBuilder, for modded registries.", "author": "coderbot16", "createdAt": "2020-06-13T23:37:22Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -40,17 +41,68 @@\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryModifiable<V>, IForgeRegistryInternal<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = Maps.newHashMap();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\n+\t/**\n+\t * Called by RegistryBuilder, for moded registries.", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzg0MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777841", "bodyText": "Maybe use a defaulted registry here if the builder declares default values / keys?", "author": "coderbot16", "createdAt": "2020-06-13T23:38:10Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -40,17 +41,68 @@\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistryModifiable<V>, IForgeRegistryInternal<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = Maps.newHashMap();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\n+\t/**\n+\t * Called by RegistryBuilder, for moded registries.\n+\t * @param stage\n+\t * @param name\n+\t * @param builder\n+\t */\n+\tpublic ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n+\t\tthis.name = name;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n \n+\t\tthis.vanilla = new ExtendedVanillaRegistry<>(this);", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzMzQ1OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r440333458", "bodyText": "defaulted registry is supported now", "author": "rikka0w0", "createdAt": "2020-06-15T17:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzg5MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439777890", "bodyText": "Alternatively, it might be a good idea to have a vanilla registry instance -> ForgeRegistry map here, instead of attaching it as a value of the registry instance with a mixin? Not entirely sure on this issue though.", "author": "coderbot16", "createdAt": "2020-06-13T23:39:52Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -43,28 +53,121 @@ public String getName() {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> Class<V> getSuperType(Identifier key) {\n-\t\treturn (Class<V>) RegistryClassMapping.getClass(key);\n+\t\treturn (Class<V>) this.superTypes.inverse().get(key);\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> ForgeRegistry<V> getRegistry(Identifier key) {\n-\t\treturn (ForgeRegistry<V>) this.registries.get(key);\n+\t\tRegistry<?> vanillaRegistry = Registry.REGISTRIES.get(key);\n+\n+\t\tif (vanillaRegistry instanceof ForgeRegistryProvider) {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MzA3Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439843072", "bodyText": "In the vanilla registry record, all forge modded registries are instance of ExtendedVanillaRegistry (super class of MutableRegistry), and they hold the reference to the its ForgeRegistry. The interface ForgeRegistryProvider is used for both forge and vanilla registries for retrieving ForgeRegistry reference.\nHaving a vanilla registry->ForgeRegistry map would work, but I still prefer to not maintaining a separate map.", "author": "rikka0w0", "createdAt": "2020-06-14T15:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MzM3Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439843373", "bodyText": "I also have a concern, currently vanilla and fabric mods can access registries added by forge, but not the other way around. How should we handle the registries created by fabric mods? Should we make them visible to forge mods?", "author": "rikka0w0", "createdAt": "2020-06-14T15:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjAxMw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439852013", "bodyText": "I don't think it's needed to give Forge mods access non-vanilla and non-Forge registries, what would they be able to do with them?", "author": "coderbot16", "createdAt": "2020-06-14T17:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MDc1Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439860756", "bodyText": "I cant imagin any of those cases... So our current code should be fine", "author": "rikka0w0", "createdAt": "2020-06-14T19:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3Nzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3ODAyNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439778027", "bodyText": "Since most of this code is shared with wrapVanilla, could it be moved into a common method?", "author": "coderbot16", "createdAt": "2020-06-13T23:43:01Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -43,28 +53,121 @@ public String getName() {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> Class<V> getSuperType(Identifier key) {\n-\t\treturn (Class<V>) RegistryClassMapping.getClass(key);\n+\t\treturn (Class<V>) this.superTypes.inverse().get(key);\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> ForgeRegistry<V> getRegistry(Identifier key) {\n-\t\treturn (ForgeRegistry<V>) this.registries.get(key);\n+\t\tRegistry<?> vanillaRegistry = Registry.REGISTRIES.get(key);\n+\n+\t\tif (vanillaRegistry instanceof ForgeRegistryProvider) {\n+\t\t\treturn ((ForgeRegistryProvider) vanillaRegistry).getForgeRegistry();\n+\t\t}\n+\n+\t\treturn null;\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> getRegistry(Class<? super V> clazz) {\n-\t\treturn getRegistry(RegistryClassMapping.getIdentifier(clazz));\n+\t\tIdentifier existingKey = this.getName(clazz);\n+\n+\t\tif (existingKey == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn getRegistry(existingKey);\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> Identifier getName(IForgeRegistry<V> reg) {\n \t\treturn reg.getRegistryName();\n \t}\n \n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the mapping\n-\t */\n-\tvoid addRegistry(Identifier key, ForgeRegistry registry) {\n-\t\tregistries.put(key, registry);\n+\tpublic Identifier getName(Class<?> clazz) {\n+\t\tif (clazz == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tdo {\n+\t\t\tIdentifier existingKey = RegistryManager.ACTIVE.superTypes.get(clazz);\n+\n+\t\t\tif (existingKey != null) {\n+\t\t\t\treturn existingKey;\n+\t\t\t}\n+\n+\t\t\tclazz = clazz.getSuperclass();\n+\t\t} while (clazz != null && clazz != Object.class);\n+\n+\t\treturn null;\n+\t}\n+\n+\tpublic Set<Identifier> getRegistryNames() {\n+\t\treturn Registry.REGISTRIES.getIds();\n+\t}\n+\n+\t<V extends IForgeRegistryEntry<V>> ForgeRegistry<V> createRegistry(Identifier name, RegistryBuilder<V> builder) {\n+\t\tSet<Class<?>> parents = Sets.newHashSet();\n+\t\tfindSuperTypes(builder.getType(), parents);\n+\t\tSetView<Class<?>> overlappedTypes = Sets.intersection(parents, superTypes.keySet());\n+\n+\t\tif (!overlappedTypes.isEmpty()) {\n+\t\t\tClass<?> foundType = overlappedTypes.iterator().next();\n+\t\t\tthrowSuperClassOverlapException(foundType, builder.getType());\n+\t\t}", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MzUyNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439843525", "bodyText": "wrapVanilla has been removed", "author": "rikka0w0", "createdAt": "2020-06-14T15:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3ODAyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0Nzc5OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439847798", "bodyText": "vanilla wrapping is done by the RegistryManager and GameData", "author": "rikka0w0", "createdAt": "2020-06-14T16:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3ODAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3ODExNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439778114", "bodyText": "Should explain the significance of this check. What's going on here? Also, how does this handle stuff like Feature/StructureFeature?", "author": "coderbot16", "createdAt": "2020-06-13T23:45:17Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -43,28 +53,121 @@ public String getName() {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> Class<V> getSuperType(Identifier key) {\n-\t\treturn (Class<V>) RegistryClassMapping.getClass(key);\n+\t\treturn (Class<V>) this.superTypes.inverse().get(key);\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> ForgeRegistry<V> getRegistry(Identifier key) {\n-\t\treturn (ForgeRegistry<V>) this.registries.get(key);\n+\t\tRegistry<?> vanillaRegistry = Registry.REGISTRIES.get(key);\n+\n+\t\tif (vanillaRegistry instanceof ForgeRegistryProvider) {\n+\t\t\treturn ((ForgeRegistryProvider) vanillaRegistry).getForgeRegistry();\n+\t\t}\n+\n+\t\treturn null;\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> getRegistry(Class<? super V> clazz) {\n-\t\treturn getRegistry(RegistryClassMapping.getIdentifier(clazz));\n+\t\tIdentifier existingKey = this.getName(clazz);\n+\n+\t\tif (existingKey == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn getRegistry(existingKey);\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> Identifier getName(IForgeRegistry<V> reg) {\n \t\treturn reg.getRegistryName();\n \t}\n \n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the mapping\n-\t */\n-\tvoid addRegistry(Identifier key, ForgeRegistry registry) {\n-\t\tregistries.put(key, registry);\n+\tpublic Identifier getName(Class<?> clazz) {\n+\t\tif (clazz == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tdo {\n+\t\t\tIdentifier existingKey = RegistryManager.ACTIVE.superTypes.get(clazz);\n+\n+\t\t\tif (existingKey != null) {\n+\t\t\t\treturn existingKey;\n+\t\t\t}\n+\n+\t\t\tclazz = clazz.getSuperclass();\n+\t\t} while (clazz != null && clazz != Object.class);\n+\n+\t\treturn null;\n+\t}\n+\n+\tpublic Set<Identifier> getRegistryNames() {\n+\t\treturn Registry.REGISTRIES.getIds();\n+\t}\n+\n+\t<V extends IForgeRegistryEntry<V>> ForgeRegistry<V> createRegistry(Identifier name, RegistryBuilder<V> builder) {\n+\t\tSet<Class<?>> parents = Sets.newHashSet();\n+\t\tfindSuperTypes(builder.getType(), parents);\n+\t\tSetView<Class<?>> overlappedTypes = Sets.intersection(parents, superTypes.keySet());\n+\n+\t\tif (!overlappedTypes.isEmpty()) {\n+\t\t\tClass<?> foundType = overlappedTypes.iterator().next();\n+\t\t\tthrowSuperClassOverlapException(foundType, builder.getType());\n+\t\t}\n+\n+\t\tForgeRegistry<V> reg = new ForgeRegistry<V>(this, name, builder);\n+\t\tMutableRegistry vanillaReg = (MutableRegistry) reg.getVanilla();\n+\t\tRegistry.REGISTRIES.add(name, vanillaReg);\n+\t\tsuperTypes.put(builder.getType(), name);\n+\n+\t\treturn getRegistry(name);\n+\t}\n+\n+\tprivate void findSuperTypes(Class<?> type, Set<Class<?>> types) {\n+\t\tif (type == null || type == Object.class) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\ttypes.add(type);\n+\n+\t\tfor (Class<?> interfac : type.getInterfaces()) {\n+\t\t\tfindSuperTypes(interfac, types);\n+\t\t}\n+\n+\t\tfindSuperTypes(type.getSuperclass(), types);\n+\t}\n+\n+\tprivate void throwSuperClassOverlapException(Class<?> foundType, Class<?> superClazz) {\n+\t\tLOGGER.error(\n+\t\t\t\t\"Found existing registry of type {} named {}, you cannot create a new registry ({}) with type {}, as {} has a parent of that type\",\n+\t\t\t\tfoundType, superTypes.get(foundType), name, superClazz, superClazz);\n+\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"Duplicate registry parent type found - you can only have one registry for a particular super type\");\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> wrapVanilla(Identifier identifier, Class<V> superClazz) {\n+\t\tRegistry<V> registry = (Registry<V>) Registry.REGISTRIES.get(identifier);\n+\n+\t\tSet<Class<?>> parents = Sets.newHashSet();\n+\t\tfindSuperTypes(superClazz, parents);\n+\t\tSetView<Class<?>> overlappedTypes = Sets.intersection(parents, superTypes.keySet());\n+\n+\t\tif (!overlappedTypes.isEmpty()) {\n+\t\t\tClass<?> foundType = overlappedTypes.iterator().next();\n+\n+\t\t\tif (overlappedTypes.size() == 1) {", "originalCommit": "4b73200ad6ba3252c2db30ca87cb26ceac3dea95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fe3b1e2fa83bf2f37b299a68f8d2d9e3b48f7526", "url": "https://github.com/PatchworkMC/patchwork-api/commit/fe3b1e2fa83bf2f37b299a68f8d2d9e3b48f7526", "message": "Simplify the vanilla wrapper, ForgeRegistry#register() now supports replacement", "committedDate": "2020-06-14T15:15:19Z", "type": "commit"}, {"oid": "3d26faed5dea07cd6ab03bdd02ca50bffa75050f", "url": "https://github.com/PatchworkMC/patchwork-api/commit/3d26faed5dea07cd6ab03bdd02ca50bffa75050f", "message": "Code clean up", "committedDate": "2020-06-14T15:32:35Z", "type": "commit"}, {"oid": "1e00aadbc5bd49940e3bcdefd875ca1f423a7221", "url": "https://github.com/PatchworkMC/patchwork-api/commit/1e00aadbc5bd49940e3bcdefd875ca1f423a7221", "message": "more clean up", "committedDate": "2020-06-14T16:04:04Z", "type": "commit"}, {"oid": "9e90359ce17c9b324d18f447679d407de9360676", "url": "https://github.com/PatchworkMC/patchwork-api/commit/9e90359ce17c9b324d18f447679d407de9360676", "message": "add ClearableRegistry interface", "committedDate": "2020-06-14T16:41:42Z", "type": "commit"}, {"oid": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "url": "https://github.com/PatchworkMC/patchwork-api/commit/22f059b0959ec6b9079af40d4a5496f55aa0bdef", "message": "version 0.2.0", "committedDate": "2020-06-14T16:50:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODkzOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439848939", "bodyText": "Registry replacement should only be allowed on custom registries, the rest of the vanilla / fabric ecosystem is not currently prepared to handle registry replacement. This can be handled in GameData.", "author": "coderbot16", "createdAt": "2020-06-14T17:00:55Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -70,17 +137,21 @@ public void register(V value) {\n \n \t\tOptional<V> potentialOldValue = vanilla.getOrEmpty(identifier);\n \n-\t\tpotentialOldValue.ifPresent(\n-\t\t\t\toldValue -> {\n-\t\t\t\t\tif (oldValue == value) {\n-\t\t\t\t\t\tLOGGER.warn(REGISTRIES, \"Registry {}: The object {} has been registered twice for the same name {}.\", this.superType.getSimpleName(), value, identifier);\n-\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"The name %s has been registered twice, for %s and %s.\", identifier, oldValue, value));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t);\n+\t\tif (potentialOldValue.isPresent()) {\n+\t\t\tV oldValue = potentialOldValue.get();\n+\n+\t\t\tif (oldValue == value) {\n+\t\t\t\tLOGGER.warn(REGISTRIES, \"Registry {}: The object {} has been registered twice for the same name {}.\", this.superType.getSimpleName(), value, identifier);\n+\t\t\t\treturn;\n+\t\t\t} else if (this.allowOverrides) {\n+\t\t\t\tthis.oldValue = oldValue;\n+\t\t\t\tLOGGER.debug(REGISTRIES, \"Registry {}: The object {} {} has been overridden by {}.\", this.superType.getSimpleName(), identifier, oldValue, value);", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MDE3Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439860176", "bodyText": "By default, allowOverrides is set to false by the RegistryBuilder. All wrapped vanilla registeries have allowOverrides set to false, so this wont be a problem.", "author": "rikka0w0", "createdAt": "2020-06-14T19:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NTA4NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441085084", "bodyText": "This is not the case, see my comment on RegistryBuilder.", "author": "coderbot16", "createdAt": "2020-06-16T19:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MjM1Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441772356", "bodyText": "fixed in the latest commit", "author": "rikka0w0", "createdAt": "2020-06-17T19:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTAzNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439849036", "bodyText": "Why change this from ifPresent? You could set oldValue to null as a default before the ifPresent call if that's what you're trying to do.", "author": "coderbot16", "createdAt": "2020-06-14T17:02:21Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -70,17 +137,21 @@ public void register(V value) {\n \n \t\tOptional<V> potentialOldValue = vanilla.getOrEmpty(identifier);\n \n-\t\tpotentialOldValue.ifPresent(\n-\t\t\t\toldValue -> {\n-\t\t\t\t\tif (oldValue == value) {\n-\t\t\t\t\t\tLOGGER.warn(REGISTRIES, \"Registry {}: The object {} has been registered twice for the same name {}.\", this.superType.getSimpleName(), value, identifier);\n-\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tthrow new IllegalArgumentException(String.format(\"The name %s has been registered twice, for %s and %s.\", identifier, oldValue, value));\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t);\n+\t\tif (potentialOldValue.isPresent()) {\n+\t\t\tV oldValue = potentialOldValue.get();", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1OTk0NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439859944", "bodyText": "I need to do multiple checks here, I feel it is easier to control the flow when ifPresent() is removed here.", "author": "rikka0w0", "createdAt": "2020-06-14T19:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NDg3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441084878", "bodyText": "At this point it might make more sense to just do this.oldValue = vanilla.getOrEmpty(identifier).orElse(null); and then work with the nullable value directly, since that's effectively what's going on here. It would probably simplify the control flow a bit.", "author": "coderbot16", "createdAt": "2020-06-16T19:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MzY5Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441773692", "bodyText": "solved", "author": "rikka0w0", "createdAt": "2020-06-17T19:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTI2OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439849268", "bodyText": "I think you're right here, we should block clearing wrapped vanilla registries since that's bound to cause massive issues. Clearing entirely modded registries is fine though. I think the vanilla check should be moved to the top.\nI think this could be implemented by making only ExtendedVanillaRegistry implement ClearableRegistry, then just use an instanceof.", "author": "coderbot16", "createdAt": "2020-06-14T17:05:15Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -204,4 +282,61 @@ public int hashCode() {\n \t\t\treturn identifier.hashCode() * 33 + value.hashCode();\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used to control the times where people can modify this registry.\n+\t * Users should only ever register things in the Register<?> events!\n+\t */\n+\tpublic void freeze() {\n+\t\tthis.isFrozen = true;\n+\t}\n+\n+\tpublic void unfreeze() {\n+\t\tthis.isFrozen = false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isLocked() {\n+\t\treturn this.isFrozen;\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to clear a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to clear the registry too late.\");\n+\t\t}\n+\n+\t\tif (this.isVanilla) {\n+\t\t\tLOGGER.debug(\"Vanilla registery {} is cleared!\", this.name);", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MDYxOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439860619", "bodyText": "I think we should keep this logic, and throw a warning message when the vanilla registry is replaced or cleared", "author": "rikka0w0", "createdAt": "2020-06-14T19:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MDc4Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439850782", "bodyText": "I would appreciate if you could create a README.md documenting all of these TODOs at the module root.", "author": "coderbot16", "createdAt": "2020-06-14T17:24:46Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -58,4 +213,17 @@ public static Identifier checkPrefix(String name, boolean warnOverrides) {\n \n \t\treturn new Identifier(prefix, newName);\n \t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> wrapVanilla(Identifier identifier, Registry<?> registry) {\n+\t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) GameData.getBuilder(identifier);\n+\n+\t\tif (builder.getType().isAssignableFrom(StructureFeature.class)) {\n+\t\t\t// TODO: StructureFeature Needs slave map impl\n+\t\t\treturn null;", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MjE1MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439862151", "bodyText": "I'm planning to do so", "author": "rikka0w0", "createdAt": "2020-06-14T19:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MDc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MDkwOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439850909", "bodyText": "Why would the static initializer run twice?", "author": "coderbot16", "createdAt": "2020-06-14T17:26:15Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -19,14 +19,169 @@\n \n package net.minecraftforge.registries;\n \n+import java.util.HashMap;\n import java.util.Locale;\n+import java.util.Map;\n \n import org.apache.logging.log4j.LogManager;\n import net.minecraftforge.fml.ModLoadingContext;\n \n+import net.minecraft.block.Block;\n+import net.minecraft.block.entity.BlockEntityType;\n+import net.minecraft.container.ContainerType;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.ai.brain.Activity;\n+import net.minecraft.entity.ai.brain.MemoryModuleType;\n+import net.minecraft.entity.ai.brain.Schedule;\n+import net.minecraft.entity.ai.brain.sensor.SensorType;\n+import net.minecraft.entity.decoration.painting.PaintingMotive;\n+import net.minecraft.entity.effect.StatusEffect;\n+import net.minecraft.fluid.Fluid;\n+import net.minecraft.item.Item;\n+import net.minecraft.particle.ParticleType;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.recipe.RecipeSerializer;\n+import net.minecraft.recipe.RecipeType;\n+import net.minecraft.sound.SoundEvent;\n+import net.minecraft.stat.StatType;\n+import net.minecraft.structure.StructurePieceType;\n+import net.minecraft.structure.pool.StructurePoolElementType;\n+import net.minecraft.structure.processor.StructureProcessorType;\n+import net.minecraft.structure.rule.RuleTestType;\n import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.village.VillagerProfession;\n+import net.minecraft.village.VillagerType;\n+import net.minecraft.world.biome.Biome;\n+import net.minecraft.world.biome.source.BiomeSourceType;\n+import net.minecraft.world.chunk.ChunkStatus;\n+import net.minecraft.world.dimension.DimensionType;\n+import net.minecraft.world.gen.carver.Carver;\n+import net.minecraft.world.gen.chunk.ChunkGeneratorType;\n+import net.minecraft.world.gen.decorator.Decorator;\n+import net.minecraft.world.gen.feature.Feature;\n+import net.minecraft.world.gen.feature.StructureFeature;\n+import net.minecraft.world.gen.surfacebuilder.SurfaceBuilder;\n+import net.minecraft.world.poi.PointOfInterestType;\n \n public class GameData {\n+\t// These are needed because some Forge mods access these static public fields\n+\t// Vanilla registries\n+\t// Names used here match those in net.minecraft.util.Registry\n+\n+\t// Game objects\n+\tpublic static final Identifier BLOCKS = new Identifier(\"block\");\n+\tpublic static final Identifier FLUIDS = new Identifier(\"fluid\");\n+\tpublic static final Identifier ITEMS = new Identifier(\"item\");\n+\tpublic static final Identifier POTIONS = new Identifier(\"mob_effect\");\n+\tpublic static final Identifier BIOMES = new Identifier(\"biome\");\n+\tpublic static final Identifier SOUNDEVENTS = new Identifier(\"sound_event\");\n+\tpublic static final Identifier POTIONTYPES = new Identifier(\"potion\");\n+\tpublic static final Identifier ENCHANTMENTS = new Identifier(\"enchantment\");\n+\tpublic static final Identifier ENTITIES = new Identifier(\"entity_type\");\n+\tpublic static final Identifier TILEENTITIES = new Identifier(\"block_entity_type\");\n+\tpublic static final Identifier PARTICLE_TYPES = new Identifier(\"particle_type\");\n+\tpublic static final Identifier CONTAINERS = new Identifier(\"menu\");\n+\tpublic static final Identifier PAINTING_TYPES = new Identifier(\"motive\"); // sic\n+\tpublic static final Identifier RECIPE_SERIALIZERS = new Identifier(\"recipe_serializer\");\n+\tpublic static final Identifier STAT_TYPES = new Identifier(\"stat_type\");\n+\n+\t// Villages\n+\tpublic static final Identifier PROFESSIONS = new Identifier(\"villager_profession\");\n+\tpublic static final Identifier POI_TYPES = new Identifier(\"point_of_interest_type\");\n+\tpublic static final Identifier MEMORY_MODULE_TYPES = new Identifier(\"memory_module_type\");\n+\tpublic static final Identifier SENSOR_TYPES = new Identifier(\"sensor_type\");\n+\tpublic static final Identifier SCHEDULES = new Identifier(\"schedule\");\n+\tpublic static final Identifier ACTIVITIES = new Identifier(\"activity\");\n+\n+\t// Worldgen\n+\tpublic static final Identifier WORLD_CARVERS = new Identifier(\"carver\");\n+\tpublic static final Identifier SURFACE_BUILDERS = new Identifier(\"surface_builder\");\n+\tpublic static final Identifier FEATURES = new Identifier(\"feature\");\n+\tpublic static final Identifier DECORATORS = new Identifier(\"decorator\");\n+\tpublic static final Identifier BIOME_PROVIDER_TYPES = new Identifier(\"biome_source_type\");\n+\tpublic static final Identifier CHUNK_GENERATOR_TYPES = new Identifier(\"chunk_generator_type\");\n+\tpublic static final Identifier CHUNK_STATUS = new Identifier(\"chunk_status\");\n+\n+\t// TODO: Custom forge registries\n+\t// public static final Identifier MODDIMENSIONS = new\n+\t// Identifier(\"forge:moddimensions\");\n+\t// public static final Identifier SERIALIZERS = new\n+\t// Identifier(\"minecraft:dataserializers\");\n+\t// public static final Identifier LOOT_MODIFIER_SERIALIZERS = new\n+\t// Identifier(\"forge:loot_modifier_serializers\");\n+\n+\tprivate static final Map<Identifier, RegistryBuilder<?>> vanillaWrapperBuilders = new HashMap<>();\n+\n+\tstatic {\n+\t\tif (!vanillaWrapperBuilders.isEmpty()) {\n+\t\t\tthrow new RuntimeException(\"Duplicated type map initialization!\");", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MjgwNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439862806", "bodyText": "removed", "author": "rikka0w0", "createdAt": "2020-06-14T20:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MDkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MDkyNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439850926", "bodyText": "No need to make this public\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic static RegistryBuilder<?> getBuilder(Identifier identifier) {\n          \n          \n            \n            \tprivate static RegistryBuilder<?> getBuilder(Identifier identifier) {", "author": "coderbot16", "createdAt": "2020-06-14T17:26:22Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -19,14 +19,169 @@\n \n package net.minecraftforge.registries;\n \n+import java.util.HashMap;\n import java.util.Locale;\n+import java.util.Map;\n \n import org.apache.logging.log4j.LogManager;\n import net.minecraftforge.fml.ModLoadingContext;\n \n+import net.minecraft.block.Block;\n+import net.minecraft.block.entity.BlockEntityType;\n+import net.minecraft.container.ContainerType;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.ai.brain.Activity;\n+import net.minecraft.entity.ai.brain.MemoryModuleType;\n+import net.minecraft.entity.ai.brain.Schedule;\n+import net.minecraft.entity.ai.brain.sensor.SensorType;\n+import net.minecraft.entity.decoration.painting.PaintingMotive;\n+import net.minecraft.entity.effect.StatusEffect;\n+import net.minecraft.fluid.Fluid;\n+import net.minecraft.item.Item;\n+import net.minecraft.particle.ParticleType;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.recipe.RecipeSerializer;\n+import net.minecraft.recipe.RecipeType;\n+import net.minecraft.sound.SoundEvent;\n+import net.minecraft.stat.StatType;\n+import net.minecraft.structure.StructurePieceType;\n+import net.minecraft.structure.pool.StructurePoolElementType;\n+import net.minecraft.structure.processor.StructureProcessorType;\n+import net.minecraft.structure.rule.RuleTestType;\n import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.village.VillagerProfession;\n+import net.minecraft.village.VillagerType;\n+import net.minecraft.world.biome.Biome;\n+import net.minecraft.world.biome.source.BiomeSourceType;\n+import net.minecraft.world.chunk.ChunkStatus;\n+import net.minecraft.world.dimension.DimensionType;\n+import net.minecraft.world.gen.carver.Carver;\n+import net.minecraft.world.gen.chunk.ChunkGeneratorType;\n+import net.minecraft.world.gen.decorator.Decorator;\n+import net.minecraft.world.gen.feature.Feature;\n+import net.minecraft.world.gen.feature.StructureFeature;\n+import net.minecraft.world.gen.surfacebuilder.SurfaceBuilder;\n+import net.minecraft.world.poi.PointOfInterestType;\n \n public class GameData {\n+\t// These are needed because some Forge mods access these static public fields\n+\t// Vanilla registries\n+\t// Names used here match those in net.minecraft.util.Registry\n+\n+\t// Game objects\n+\tpublic static final Identifier BLOCKS = new Identifier(\"block\");\n+\tpublic static final Identifier FLUIDS = new Identifier(\"fluid\");\n+\tpublic static final Identifier ITEMS = new Identifier(\"item\");\n+\tpublic static final Identifier POTIONS = new Identifier(\"mob_effect\");\n+\tpublic static final Identifier BIOMES = new Identifier(\"biome\");\n+\tpublic static final Identifier SOUNDEVENTS = new Identifier(\"sound_event\");\n+\tpublic static final Identifier POTIONTYPES = new Identifier(\"potion\");\n+\tpublic static final Identifier ENCHANTMENTS = new Identifier(\"enchantment\");\n+\tpublic static final Identifier ENTITIES = new Identifier(\"entity_type\");\n+\tpublic static final Identifier TILEENTITIES = new Identifier(\"block_entity_type\");\n+\tpublic static final Identifier PARTICLE_TYPES = new Identifier(\"particle_type\");\n+\tpublic static final Identifier CONTAINERS = new Identifier(\"menu\");\n+\tpublic static final Identifier PAINTING_TYPES = new Identifier(\"motive\"); // sic\n+\tpublic static final Identifier RECIPE_SERIALIZERS = new Identifier(\"recipe_serializer\");\n+\tpublic static final Identifier STAT_TYPES = new Identifier(\"stat_type\");\n+\n+\t// Villages\n+\tpublic static final Identifier PROFESSIONS = new Identifier(\"villager_profession\");\n+\tpublic static final Identifier POI_TYPES = new Identifier(\"point_of_interest_type\");\n+\tpublic static final Identifier MEMORY_MODULE_TYPES = new Identifier(\"memory_module_type\");\n+\tpublic static final Identifier SENSOR_TYPES = new Identifier(\"sensor_type\");\n+\tpublic static final Identifier SCHEDULES = new Identifier(\"schedule\");\n+\tpublic static final Identifier ACTIVITIES = new Identifier(\"activity\");\n+\n+\t// Worldgen\n+\tpublic static final Identifier WORLD_CARVERS = new Identifier(\"carver\");\n+\tpublic static final Identifier SURFACE_BUILDERS = new Identifier(\"surface_builder\");\n+\tpublic static final Identifier FEATURES = new Identifier(\"feature\");\n+\tpublic static final Identifier DECORATORS = new Identifier(\"decorator\");\n+\tpublic static final Identifier BIOME_PROVIDER_TYPES = new Identifier(\"biome_source_type\");\n+\tpublic static final Identifier CHUNK_GENERATOR_TYPES = new Identifier(\"chunk_generator_type\");\n+\tpublic static final Identifier CHUNK_STATUS = new Identifier(\"chunk_status\");\n+\n+\t// TODO: Custom forge registries\n+\t// public static final Identifier MODDIMENSIONS = new\n+\t// Identifier(\"forge:moddimensions\");\n+\t// public static final Identifier SERIALIZERS = new\n+\t// Identifier(\"minecraft:dataserializers\");\n+\t// public static final Identifier LOOT_MODIFIER_SERIALIZERS = new\n+\t// Identifier(\"forge:loot_modifier_serializers\");\n+\n+\tprivate static final Map<Identifier, RegistryBuilder<?>> vanillaWrapperBuilders = new HashMap<>();\n+\n+\tstatic {\n+\t\tif (!vanillaWrapperBuilders.isEmpty()) {\n+\t\t\tthrow new RuntimeException(\"Duplicated type map initialization!\");\n+\t\t}\n+\n+\t\t// Game objects\n+\t\twrap(BLOCKS, Block.class);\n+\t\twrap(FLUIDS, Fluid.class);\n+\t\twrap(ITEMS, Item.class);\n+\t\twrap(POTIONS, StatusEffect.class);\n+\t\twrap(BIOMES, Biome.class);\n+\t\twrap(SOUNDEVENTS, SoundEvent.class);\n+\t\twrap(POTIONTYPES, Potion.class);\n+\t\twrap(ENCHANTMENTS, Enchantment.class);\n+\t\twrap(ENTITIES, EntityType.class);\n+\t\twrap(TILEENTITIES, BlockEntityType.class);\n+\t\twrap(PARTICLE_TYPES, ParticleType.class);\n+\t\twrap(CONTAINERS, ContainerType.class);\n+\t\twrap(PAINTING_TYPES, PaintingMotive.class);\n+\t\twrap(RECIPE_SERIALIZERS, RecipeSerializer.class);\n+\t\twrap(STAT_TYPES, StatType.class);\n+\n+\t\t// Villages\n+\t\twrap(PROFESSIONS, VillagerProfession.class);\n+\t\twrap(POI_TYPES, PointOfInterestType.class);\n+\t\twrap(MEMORY_MODULE_TYPES, MemoryModuleType.class);\n+\t\twrap(SENSOR_TYPES, SensorType.class);\n+\t\twrap(SCHEDULES, Schedule.class);\n+\t\twrap(ACTIVITIES, Activity.class);\n+\n+\t\t// Worldgen\n+\t\twrap(WORLD_CARVERS, Carver.class);\n+\t\twrap(SURFACE_BUILDERS, SurfaceBuilder.class);\n+\t\twrap(FEATURES, Feature.class);\n+\t\twrap(DECORATORS, Decorator.class);\n+\t\twrap(BIOME_PROVIDER_TYPES, BiomeSourceType.class);\n+\t\twrap(CHUNK_GENERATOR_TYPES, ChunkGeneratorType.class);\n+\t\twrap(CHUNK_STATUS, ChunkStatus.class);\n+\n+\t\t// TODO: Patchwork Project, check these\n+\t\twrap(\"dimension_type\", DimensionType.class);\n+\t\twrap(\"custom_stat\", Identifier.class);\n+\t\twrap(\"recipe_type\", RecipeType.class);\n+\t\twrap(\"rule_test\", RuleTestType.class);\n+\t\twrap(\"structure_feature\", StructureFeature.class);\n+\t\twrap(\"structure_piece\", StructurePieceType.class);\n+\t\twrap(\"structure_pool_element\", StructurePoolElementType.class);\n+\t\twrap(\"structure_processor\", StructureProcessorType.class);\n+\t\twrap(\"villager_type\", VillagerType.class);\n+\t}\n+\n+\tprivate static void wrap(String name, Class superClazz) {\n+\t\twrap(new Identifier(name), superClazz);\n+\t}\n+\n+\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+\tprivate static RegistryBuilder<?> wrap(Identifier id, Class superClazz) {\n+\t\tRegistryBuilder builder = new RegistryBuilder();\n+\t\tbuilder.setName(id);\n+\t\tbuilder.setType(superClazz);\n+\t\tvanillaWrapperBuilders.put(id, builder);\n+\t\treturn builder;\n+\t}\n+\n+\tpublic static RegistryBuilder<?> getBuilder(Identifier identifier) {", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MjkwNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439862907", "bodyText": "changed to private", "author": "rikka0w0", "createdAt": "2020-06-14T20:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MDkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTU4Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439851583", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate static <T, R extends MutableRegistry<T>> void putDefaultEntry(String name, R reg, Supplier<T> supplier, CallbackInfoReturnable<R> info) {\n          \n          \n            \n            \tprivate static <T, R extends MutableRegistry<T>> void handleNewVanillaRegistry(String name, R reg, Supplier<T> supplier, CallbackInfoReturnable<R> info) {", "author": "coderbot16", "createdAt": "2020-06-14T17:34:44Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/mixin/registries/MixinRegistry.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.mixin.registries;\n+\n+import java.util.function.Supplier;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n+import net.minecraftforge.registries.GameData;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+@Mixin(Registry.class)\n+public class MixinRegistry {\n+\t@Inject(at = @At(\"TAIL\"), method = \"putDefaultEntry(Ljava/lang/String;Lnet/minecraft/util/registry/MutableRegistry;Ljava/util/function/Supplier;)Lnet/minecraft/util/registry/MutableRegistry;\")\n+\tprivate static <T, R extends MutableRegistry<T>> void putDefaultEntry(String name, R reg, Supplier<T> supplier, CallbackInfoReturnable<R> info) {", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2Mjk0Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439862943", "bodyText": "changed", "author": "rikka0w0", "createdAt": "2020-06-14T20:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTYyMw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439851623", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) GameData.getBuilder(identifier);\n          \n          \n            \n            \t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) getBuilder(identifier);", "author": "coderbot16", "createdAt": "2020-06-14T17:35:08Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -58,4 +213,17 @@ public static Identifier checkPrefix(String name, boolean warnOverrides) {\n \n \t\treturn new Identifier(prefix, newName);\n \t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> wrapVanilla(Identifier identifier, Registry<?> registry) {\n+\t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) GameData.getBuilder(identifier);", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTY4Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439851686", "bodyText": "It's possible that vanilla added a new vanilla registry, without there being an equivalent Forge one. This will cause a NullPointerException?", "author": "coderbot16", "createdAt": "2020-06-14T17:35:55Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -58,4 +213,17 @@ public static Identifier checkPrefix(String name, boolean warnOverrides) {\n \n \t\treturn new Identifier(prefix, newName);\n \t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> wrapVanilla(Identifier identifier, Registry<?> registry) {\n+\t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) GameData.getBuilder(identifier);\n+\n+\t\tif (builder.getType().isAssignableFrom(StructureFeature.class)) {\n+\t\t\t// TODO: StructureFeature Needs slave map impl\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tbuilder.setVanillaRegistry((Registry<V>) registry);", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzIxNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863217", "bodyText": "yes, this can happen.\nI add a check in the latest commit so it wont crash.\nHowever we should think about making Fabric registry visible to forge mods", "author": "rikka0w0", "createdAt": "2020-06-14T20:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTc1Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439851756", "bodyText": "Should disable overrides here", "author": "coderbot16", "createdAt": "2020-06-14T17:36:53Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -19,14 +19,169 @@\n \n package net.minecraftforge.registries;\n \n+import java.util.HashMap;\n import java.util.Locale;\n+import java.util.Map;\n \n import org.apache.logging.log4j.LogManager;\n import net.minecraftforge.fml.ModLoadingContext;\n \n+import net.minecraft.block.Block;\n+import net.minecraft.block.entity.BlockEntityType;\n+import net.minecraft.container.ContainerType;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.ai.brain.Activity;\n+import net.minecraft.entity.ai.brain.MemoryModuleType;\n+import net.minecraft.entity.ai.brain.Schedule;\n+import net.minecraft.entity.ai.brain.sensor.SensorType;\n+import net.minecraft.entity.decoration.painting.PaintingMotive;\n+import net.minecraft.entity.effect.StatusEffect;\n+import net.minecraft.fluid.Fluid;\n+import net.minecraft.item.Item;\n+import net.minecraft.particle.ParticleType;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.recipe.RecipeSerializer;\n+import net.minecraft.recipe.RecipeType;\n+import net.minecraft.sound.SoundEvent;\n+import net.minecraft.stat.StatType;\n+import net.minecraft.structure.StructurePieceType;\n+import net.minecraft.structure.pool.StructurePoolElementType;\n+import net.minecraft.structure.processor.StructureProcessorType;\n+import net.minecraft.structure.rule.RuleTestType;\n import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.village.VillagerProfession;\n+import net.minecraft.village.VillagerType;\n+import net.minecraft.world.biome.Biome;\n+import net.minecraft.world.biome.source.BiomeSourceType;\n+import net.minecraft.world.chunk.ChunkStatus;\n+import net.minecraft.world.dimension.DimensionType;\n+import net.minecraft.world.gen.carver.Carver;\n+import net.minecraft.world.gen.chunk.ChunkGeneratorType;\n+import net.minecraft.world.gen.decorator.Decorator;\n+import net.minecraft.world.gen.feature.Feature;\n+import net.minecraft.world.gen.feature.StructureFeature;\n+import net.minecraft.world.gen.surfacebuilder.SurfaceBuilder;\n+import net.minecraft.world.poi.PointOfInterestType;\n \n public class GameData {\n+\t// These are needed because some Forge mods access these static public fields\n+\t// Vanilla registries\n+\t// Names used here match those in net.minecraft.util.Registry\n+\n+\t// Game objects\n+\tpublic static final Identifier BLOCKS = new Identifier(\"block\");\n+\tpublic static final Identifier FLUIDS = new Identifier(\"fluid\");\n+\tpublic static final Identifier ITEMS = new Identifier(\"item\");\n+\tpublic static final Identifier POTIONS = new Identifier(\"mob_effect\");\n+\tpublic static final Identifier BIOMES = new Identifier(\"biome\");\n+\tpublic static final Identifier SOUNDEVENTS = new Identifier(\"sound_event\");\n+\tpublic static final Identifier POTIONTYPES = new Identifier(\"potion\");\n+\tpublic static final Identifier ENCHANTMENTS = new Identifier(\"enchantment\");\n+\tpublic static final Identifier ENTITIES = new Identifier(\"entity_type\");\n+\tpublic static final Identifier TILEENTITIES = new Identifier(\"block_entity_type\");\n+\tpublic static final Identifier PARTICLE_TYPES = new Identifier(\"particle_type\");\n+\tpublic static final Identifier CONTAINERS = new Identifier(\"menu\");\n+\tpublic static final Identifier PAINTING_TYPES = new Identifier(\"motive\"); // sic\n+\tpublic static final Identifier RECIPE_SERIALIZERS = new Identifier(\"recipe_serializer\");\n+\tpublic static final Identifier STAT_TYPES = new Identifier(\"stat_type\");\n+\n+\t// Villages\n+\tpublic static final Identifier PROFESSIONS = new Identifier(\"villager_profession\");\n+\tpublic static final Identifier POI_TYPES = new Identifier(\"point_of_interest_type\");\n+\tpublic static final Identifier MEMORY_MODULE_TYPES = new Identifier(\"memory_module_type\");\n+\tpublic static final Identifier SENSOR_TYPES = new Identifier(\"sensor_type\");\n+\tpublic static final Identifier SCHEDULES = new Identifier(\"schedule\");\n+\tpublic static final Identifier ACTIVITIES = new Identifier(\"activity\");\n+\n+\t// Worldgen\n+\tpublic static final Identifier WORLD_CARVERS = new Identifier(\"carver\");\n+\tpublic static final Identifier SURFACE_BUILDERS = new Identifier(\"surface_builder\");\n+\tpublic static final Identifier FEATURES = new Identifier(\"feature\");\n+\tpublic static final Identifier DECORATORS = new Identifier(\"decorator\");\n+\tpublic static final Identifier BIOME_PROVIDER_TYPES = new Identifier(\"biome_source_type\");\n+\tpublic static final Identifier CHUNK_GENERATOR_TYPES = new Identifier(\"chunk_generator_type\");\n+\tpublic static final Identifier CHUNK_STATUS = new Identifier(\"chunk_status\");\n+\n+\t// TODO: Custom forge registries\n+\t// public static final Identifier MODDIMENSIONS = new\n+\t// Identifier(\"forge:moddimensions\");\n+\t// public static final Identifier SERIALIZERS = new\n+\t// Identifier(\"minecraft:dataserializers\");\n+\t// public static final Identifier LOOT_MODIFIER_SERIALIZERS = new\n+\t// Identifier(\"forge:loot_modifier_serializers\");\n+\n+\tprivate static final Map<Identifier, RegistryBuilder<?>> vanillaWrapperBuilders = new HashMap<>();\n+\n+\tstatic {\n+\t\tif (!vanillaWrapperBuilders.isEmpty()) {\n+\t\t\tthrow new RuntimeException(\"Duplicated type map initialization!\");\n+\t\t}\n+\n+\t\t// Game objects\n+\t\twrap(BLOCKS, Block.class);\n+\t\twrap(FLUIDS, Fluid.class);\n+\t\twrap(ITEMS, Item.class);\n+\t\twrap(POTIONS, StatusEffect.class);\n+\t\twrap(BIOMES, Biome.class);\n+\t\twrap(SOUNDEVENTS, SoundEvent.class);\n+\t\twrap(POTIONTYPES, Potion.class);\n+\t\twrap(ENCHANTMENTS, Enchantment.class);\n+\t\twrap(ENTITIES, EntityType.class);\n+\t\twrap(TILEENTITIES, BlockEntityType.class);\n+\t\twrap(PARTICLE_TYPES, ParticleType.class);\n+\t\twrap(CONTAINERS, ContainerType.class);\n+\t\twrap(PAINTING_TYPES, PaintingMotive.class);\n+\t\twrap(RECIPE_SERIALIZERS, RecipeSerializer.class);\n+\t\twrap(STAT_TYPES, StatType.class);\n+\n+\t\t// Villages\n+\t\twrap(PROFESSIONS, VillagerProfession.class);\n+\t\twrap(POI_TYPES, PointOfInterestType.class);\n+\t\twrap(MEMORY_MODULE_TYPES, MemoryModuleType.class);\n+\t\twrap(SENSOR_TYPES, SensorType.class);\n+\t\twrap(SCHEDULES, Schedule.class);\n+\t\twrap(ACTIVITIES, Activity.class);\n+\n+\t\t// Worldgen\n+\t\twrap(WORLD_CARVERS, Carver.class);\n+\t\twrap(SURFACE_BUILDERS, SurfaceBuilder.class);\n+\t\twrap(FEATURES, Feature.class);\n+\t\twrap(DECORATORS, Decorator.class);\n+\t\twrap(BIOME_PROVIDER_TYPES, BiomeSourceType.class);\n+\t\twrap(CHUNK_GENERATOR_TYPES, ChunkGeneratorType.class);\n+\t\twrap(CHUNK_STATUS, ChunkStatus.class);\n+\n+\t\t// TODO: Patchwork Project, check these\n+\t\twrap(\"dimension_type\", DimensionType.class);\n+\t\twrap(\"custom_stat\", Identifier.class);\n+\t\twrap(\"recipe_type\", RecipeType.class);\n+\t\twrap(\"rule_test\", RuleTestType.class);\n+\t\twrap(\"structure_feature\", StructureFeature.class);\n+\t\twrap(\"structure_piece\", StructurePieceType.class);\n+\t\twrap(\"structure_pool_element\", StructurePoolElementType.class);\n+\t\twrap(\"structure_processor\", StructureProcessorType.class);\n+\t\twrap(\"villager_type\", VillagerType.class);\n+\t}\n+\n+\tprivate static void wrap(String name, Class superClazz) {\n+\t\twrap(new Identifier(name), superClazz);\n+\t}\n+\n+\t@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+\tprivate static RegistryBuilder<?> wrap(Identifier id, Class superClazz) {\n+\t\tRegistryBuilder builder = new RegistryBuilder();\n+\t\tbuilder.setName(id);\n+\t\tbuilder.setType(superClazz);", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzI1Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863252", "bodyText": "override is not enabled by default, so this is fine", "author": "rikka0w0", "createdAt": "2020-06-14T20:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTc5NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439851795", "bodyText": "They actually do not, because we're using yarn!\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t// Names used here match those in net.minecraft.util.Registry", "author": "coderbot16", "createdAt": "2020-06-14T17:37:27Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -19,14 +19,169 @@\n \n package net.minecraftforge.registries;\n \n+import java.util.HashMap;\n import java.util.Locale;\n+import java.util.Map;\n \n import org.apache.logging.log4j.LogManager;\n import net.minecraftforge.fml.ModLoadingContext;\n \n+import net.minecraft.block.Block;\n+import net.minecraft.block.entity.BlockEntityType;\n+import net.minecraft.container.ContainerType;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.ai.brain.Activity;\n+import net.minecraft.entity.ai.brain.MemoryModuleType;\n+import net.minecraft.entity.ai.brain.Schedule;\n+import net.minecraft.entity.ai.brain.sensor.SensorType;\n+import net.minecraft.entity.decoration.painting.PaintingMotive;\n+import net.minecraft.entity.effect.StatusEffect;\n+import net.minecraft.fluid.Fluid;\n+import net.minecraft.item.Item;\n+import net.minecraft.particle.ParticleType;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.recipe.RecipeSerializer;\n+import net.minecraft.recipe.RecipeType;\n+import net.minecraft.sound.SoundEvent;\n+import net.minecraft.stat.StatType;\n+import net.minecraft.structure.StructurePieceType;\n+import net.minecraft.structure.pool.StructurePoolElementType;\n+import net.minecraft.structure.processor.StructureProcessorType;\n+import net.minecraft.structure.rule.RuleTestType;\n import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.village.VillagerProfession;\n+import net.minecraft.village.VillagerType;\n+import net.minecraft.world.biome.Biome;\n+import net.minecraft.world.biome.source.BiomeSourceType;\n+import net.minecraft.world.chunk.ChunkStatus;\n+import net.minecraft.world.dimension.DimensionType;\n+import net.minecraft.world.gen.carver.Carver;\n+import net.minecraft.world.gen.chunk.ChunkGeneratorType;\n+import net.minecraft.world.gen.decorator.Decorator;\n+import net.minecraft.world.gen.feature.Feature;\n+import net.minecraft.world.gen.feature.StructureFeature;\n+import net.minecraft.world.gen.surfacebuilder.SurfaceBuilder;\n+import net.minecraft.world.poi.PointOfInterestType;\n \n public class GameData {\n+\t// These are needed because some Forge mods access these static public fields\n+\t// Vanilla registries\n+\t// Names used here match those in net.minecraft.util.Registry", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzMzNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863334", "bodyText": "understood, removed", "author": "rikka0w0", "createdAt": "2020-06-14T20:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTg4Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439851883", "bodyText": "These should warn somewhere along the code path as long as they're not supported", "author": "coderbot16", "createdAt": "2020-06-14T17:38:34Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.registries;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.Lists;\n+import net.minecraftforge.registries.IForgeRegistry.AddCallback;\n+import net.minecraftforge.registries.IForgeRegistry.BakeCallback;\n+import net.minecraftforge.registries.IForgeRegistry.ClearCallback;\n+import net.minecraftforge.registries.IForgeRegistry.CreateCallback;\n+import net.minecraftforge.registries.IForgeRegistry.DummyFactory;\n+import net.minecraftforge.registries.IForgeRegistry.MissingFactory;\n+import net.minecraftforge.registries.IForgeRegistry.ValidateCallback;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+public class RegistryBuilder<T extends IForgeRegistryEntry<T>> {\n+\tprivate static final int MAX_ID = Integer.MAX_VALUE - 1;\n+\n+\tprivate Identifier registryName;\n+\tprivate Class<T> registryType;\n+\tprivate Identifier optionalDefaultKey;\n+\tprivate int minId = 0;\n+\tprivate int maxId = MAX_ID;\n+\tprivate List<AddCallback<T>> addCallback = Lists.newArrayList();\n+\tprivate List<ClearCallback<T>> clearCallback = Lists.newArrayList();\n+\tprivate List<CreateCallback<T>> createCallback = Lists.newArrayList();\n+\tprivate List<ValidateCallback<T>> validateCallback = Lists.newArrayList();\n+\tprivate List<BakeCallback<T>> bakeCallback = Lists.newArrayList();\n+\tprivate boolean saveToDisc = true;\n+\tprivate boolean sync = true;\n+\tprivate boolean allowOverrides = true;\n+\tprivate boolean allowModifications = false;\n+\tprivate DummyFactory<T> dummyFactory;\n+\tprivate MissingFactory<T> missingFactory;\n+\tprivate Set<Identifier> legacyNames = new HashSet<>();\n+\n+\tprivate Registry<T> vanilla;\n+\n+\t/**\n+\t * Used by the Patchwork Vanilla Wrapper.\n+\t * @param vanilla\n+\t * @return\n+\t */\n+\tpublic RegistryBuilder<T> setVanillaRegistry(Registry<T> vanilla) {\n+\t\tthis.vanilla = vanilla;\n+\t\treturn this;\n+\t}\n+\n+\tpublic Registry<T> getVanillaRegistry() {\n+\t\treturn this.vanilla;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setName(Identifier name) {\n+\t\tthis.registryName = name;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setType(Class<T> type) {\n+\t\tthis.registryType = type;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setIDRange(int min, int max) {\n+\t\tthis.minId = Math.max(min, 0);\n+\t\tthis.maxId = Math.min(max, MAX_ID);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setMaxID(int max) {\n+\t\treturn this.setIDRange(0, max);\n+\t}\n+\n+\tpublic RegistryBuilder<T> setDefaultKey(Identifier key) {\n+\t\tthis.optionalDefaultKey = key;\n+\t\treturn this;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic RegistryBuilder<T> addCallback(Object inst) {\n+\t\tif (inst instanceof AddCallback) {\n+\t\t\tthis.add((AddCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof ClearCallback) {\n+\t\t\tthis.add((ClearCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof CreateCallback) {\n+\t\t\tthis.add((CreateCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof ValidateCallback) {\n+\t\t\tthis.add((ValidateCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof BakeCallback) {\n+\t\t\tthis.add((BakeCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof DummyFactory) {\n+\t\t\tthis.set((DummyFactory<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof MissingFactory) {\n+\t\t\tthis.set((MissingFactory<T>) inst);\n+\t\t}\n+\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(AddCallback<T> add) {\n+\t\tthis.addCallback.add(add);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(ClearCallback<T> clear) {\n+\t\tthis.clearCallback.add(clear);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(CreateCallback<T> create) {\n+\t\tthis.createCallback.add(create);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(ValidateCallback<T> validate) {\n+\t\tthis.validateCallback.add(validate);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(BakeCallback<T> bake) {\n+\t\tthis.bakeCallback.add(bake);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> set(DummyFactory<T> factory) {\n+\t\tthis.dummyFactory = factory;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> set(MissingFactory<T> missing) {\n+\t\tthis.missingFactory = missing;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> disableSaving() {\n+\t\tthis.saveToDisc = false;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> disableSync() {\n+\t\tthis.sync = false;\n+\t\treturn this;\n+\t}", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODg5Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439858896", "bodyText": "Added warning message", "author": "rikka0w0", "createdAt": "2020-06-14T19:08:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjI1OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439852259", "bodyText": "Should block using Object here, as well as null.", "author": "coderbot16", "createdAt": "2020-06-14T17:43:06Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.registries;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.Lists;\n+import net.minecraftforge.registries.IForgeRegistry.AddCallback;\n+import net.minecraftforge.registries.IForgeRegistry.BakeCallback;\n+import net.minecraftforge.registries.IForgeRegistry.ClearCallback;\n+import net.minecraftforge.registries.IForgeRegistry.CreateCallback;\n+import net.minecraftforge.registries.IForgeRegistry.DummyFactory;\n+import net.minecraftforge.registries.IForgeRegistry.MissingFactory;\n+import net.minecraftforge.registries.IForgeRegistry.ValidateCallback;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+public class RegistryBuilder<T extends IForgeRegistryEntry<T>> {\n+\tprivate static final int MAX_ID = Integer.MAX_VALUE - 1;\n+\n+\tprivate Identifier registryName;\n+\tprivate Class<T> registryType;\n+\tprivate Identifier optionalDefaultKey;\n+\tprivate int minId = 0;\n+\tprivate int maxId = MAX_ID;\n+\tprivate List<AddCallback<T>> addCallback = Lists.newArrayList();\n+\tprivate List<ClearCallback<T>> clearCallback = Lists.newArrayList();\n+\tprivate List<CreateCallback<T>> createCallback = Lists.newArrayList();\n+\tprivate List<ValidateCallback<T>> validateCallback = Lists.newArrayList();\n+\tprivate List<BakeCallback<T>> bakeCallback = Lists.newArrayList();\n+\tprivate boolean saveToDisc = true;\n+\tprivate boolean sync = true;\n+\tprivate boolean allowOverrides = true;\n+\tprivate boolean allowModifications = false;\n+\tprivate DummyFactory<T> dummyFactory;\n+\tprivate MissingFactory<T> missingFactory;\n+\tprivate Set<Identifier> legacyNames = new HashSet<>();\n+\n+\tprivate Registry<T> vanilla;\n+\n+\t/**\n+\t * Used by the Patchwork Vanilla Wrapper.\n+\t * @param vanilla\n+\t * @return\n+\t */\n+\tpublic RegistryBuilder<T> setVanillaRegistry(Registry<T> vanilla) {\n+\t\tthis.vanilla = vanilla;\n+\t\treturn this;\n+\t}\n+\n+\tpublic Registry<T> getVanillaRegistry() {\n+\t\treturn this.vanilla;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setName(Identifier name) {\n+\t\tthis.registryName = name;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setType(Class<T> type) {\n+\t\tthis.registryType = type;", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzIwMw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439857203", "bodyText": "the RegistryManger#findSuperTypes cannot block Object.class and null.\nThis must be a forge's problem. We can do a check here, if the type is not valid, we can throw an error.", "author": "rikka0w0", "createdAt": "2020-06-14T18:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1OTExNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439859117", "bodyText": "an error will be thrown if type is null or Object", "author": "rikka0w0", "createdAt": "2020-06-14T19:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjM0Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439852342", "bodyText": "Why insert the registry into the map only to retrieve it again?", "author": "coderbot16", "createdAt": "2020-06-14T17:44:22Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -43,28 +52,85 @@ public String getName() {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> Class<V> getSuperType(Identifier key) {\n-\t\treturn (Class<V>) RegistryClassMapping.getClass(key);\n+\t\treturn (Class<V>) this.superTypes.inverse().get(key);\n \t}\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic <V extends IForgeRegistryEntry<V>> ForgeRegistry<V> getRegistry(Identifier key) {\n-\t\treturn (ForgeRegistry<V>) this.registries.get(key);\n+\t\tRegistry<?> vanillaRegistry = Registry.REGISTRIES.get(key);\n+\n+\t\tif (vanillaRegistry instanceof ForgeRegistryProvider) {\n+\t\t\treturn ((ForgeRegistryProvider) vanillaRegistry).getForgeRegistry();\n+\t\t}\n+\n+\t\t// TODO: should we make fabric registries visible to forge mods?\n+\t\treturn null;\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> getRegistry(Class<? super V> clazz) {\n-\t\treturn getRegistry(RegistryClassMapping.getIdentifier(clazz));\n+\t\tIdentifier existingKey = this.getName(clazz);\n+\n+\t\tif (existingKey == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn getRegistry(existingKey);\n \t}\n \n \tpublic <V extends IForgeRegistryEntry<V>> Identifier getName(IForgeRegistry<V> reg) {\n \t\treturn reg.getRegistryName();\n \t}\n \n-\t/**\n-\t * Used by {@link net.minecraftforge.registries.ForgeRegistries}.\n-\t *\n-\t * @param registry the registry to add to the mapping\n-\t */\n-\tvoid addRegistry(Identifier key, ForgeRegistry registry) {\n-\t\tregistries.put(key, registry);\n+\tpublic Identifier getName(Class<?> clazz) {\n+\t\twhile (clazz != null && clazz != Object.class) {\n+\t\t\tIdentifier existingKey = RegistryManager.ACTIVE.superTypes.get(clazz);\n+\n+\t\t\tif (existingKey != null) {\n+\t\t\t\treturn existingKey;\n+\t\t\t}\n+\n+\t\t\tclazz = clazz.getSuperclass();\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\tpublic Set<Identifier> getRegistryNames() {\n+\t\t// These types are known to MinecraftForge\n+\t\treturn this.superTypes.values();\n+\t}\n+\n+\t<V extends IForgeRegistryEntry<V>> ForgeRegistry<V> createRegistry(Identifier name, RegistryBuilder<V> builder) {\n+\t\tSet<Class<?>> parents = new HashSet<>();\n+\t\tfindSuperTypes(builder.getType(), parents);\n+\t\tSetView<Class<?>> overlappedTypes = Sets.intersection(parents, superTypes.keySet());\n+\n+\t\tif (!overlappedTypes.isEmpty()) {\n+\t\t\tClass<?> foundType = overlappedTypes.iterator().next();\n+\t\t\tLOGGER.error(\n+\t\t\t\t\t\"Found existing registry of type {} named {}, you cannot create a new registry ({}) with type {}, as {} has a parent of that type\",\n+\t\t\t\t\tfoundType, superTypes.get(foundType), name, builder.getType(), builder.getType());\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"Duplicate registry parent type found - you can only have one registry for a particular super type\");\n+\t\t}\n+\n+\t\tForgeRegistry<V> reg = new ForgeRegistry<V>(this, name, builder);\n+\t\tsuperTypes.put(builder.getType(), name);\n+\n+\t\treturn getRegistry(name);", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODUzMw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439858533", "bodyText": "This were left from previous implementation, removed", "author": "rikka0w0", "createdAt": "2020-06-14T19:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjU4NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439852585", "bodyText": "On second thought, it's probably not a good idea to make vanilla registries clearable.", "author": "coderbot16", "createdAt": "2020-06-14T17:46:48Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/VanillaRegistry.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.impl.registries;\n+\n+import net.minecraftforge.registries.ForgeRegistry;\n+\n+public interface VanillaRegistry extends ForgeRegistryProvider, ClearableRegistry {", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzM1OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863359", "bodyText": "We can leave it for now and throw a warning when a forge mod perform this action", "author": "rikka0w0", "createdAt": "2020-06-14T20:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjY2Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439852667", "bodyText": "It's probably easier to just remove this method now, since it's a single call.", "author": "coderbot16", "createdAt": "2020-06-14T17:47:46Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistries.java", "diffHunk": "@@ -150,16 +146,7 @@\n \n \t@SuppressWarnings(\"unchecked\")\n \tprivate static <T> IForgeRegistry wrap(String name, Class superClazz) {\n-\t\tIdentifier identifier = new Identifier(\"minecraft\", name);\n-\t\tRegistry registry = Registry.REGISTRIES.get(identifier);\n-\n-\t\tForgeRegistry wrapped = new ForgeRegistry(identifier, registry, superClazz);\n-\n-\t\tRegistryClassMapping.register(wrapped);\n-\t\tRegistryManager.ACTIVE.addRegistry(identifier, wrapped);\n-\t\tRegistryEventDispatcher.register(wrapped);\n-\n-\t\treturn wrapped;\n+\t\treturn RegistryManager.ACTIVE.getRegistry(superClazz);", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1OTYxMg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439859612", "bodyText": "I can clean up this part later", "author": "rikka0w0", "createdAt": "2020-06-14T19:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjcwMg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439852702", "bodyText": "This probably shouldn't be public", "author": "coderbot16", "createdAt": "2020-06-14T17:48:10Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -39,18 +40,84 @@\n import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.registry.MutableRegistry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+import net.patchworkmc.impl.registries.ClearableRegistry;\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements\n+\t\tIForgeRegistryModifiable<V>, IForgeRegistryInternal<V>, RegistryEntryAddedCallback<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = new HashMap<>();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\tprivate V oldValue; // context of AddCallback, does not use elsewhere\n+\n+\t/**\n+\t * Called by RegistryBuilder, for modded registries.\n+\t * @param stage\n+\t * @param name\n+\t * @param builder\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1OTI5MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439859291", "bodyText": "changed to protected", "author": "rikka0w0", "createdAt": "2020-06-14T19:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MjcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MzA3Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439853077", "bodyText": "Though it's invalid to do this on Forge, it's valid on Fabric. I think it's still reasonable to keep this for now to present a sane universe to Forge mods, but it should be noted here.", "author": "coderbot16", "createdAt": "2020-06-14T17:52:45Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -39,18 +40,84 @@\n import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.registry.MutableRegistry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+import net.patchworkmc.impl.registries.ClearableRegistry;\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements\n+\t\tIForgeRegistryModifiable<V>, IForgeRegistryInternal<V>, RegistryEntryAddedCallback<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = new HashMap<>();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\tprivate V oldValue; // context of AddCallback, does not use elsewhere\n+\n+\t/**\n+\t * Called by RegistryBuilder, for modded registries.\n+\t * @param stage\n+\t * @param name\n+\t * @param builder\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n \t\tthis.name = name;\n-\t\tthis.vanilla = vanilla;\n-\t\tthis.superType = superType;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.allowOverrides = builder.getAllowOverrides();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n+\n+\t\tRegistry<V> vanilla = builder.getVanillaRegistry();\n+\n+\t\tif (vanilla == null) {\n+\t\t\t// Forge modded registry\n+\t\t\tthis.vanilla = new ExtendedVanillaRegistry<>(this);\n+\t\t\tRegistry.REGISTRIES.add(name, (MutableRegistry) this.vanilla);\n+\t\t\tthis.isVanilla = false;\n+\t\t} else {\n+\t\t\t// Vanilla registry\n+\t\t\tthis.vanilla = vanilla;\n+\t\t\t((VanillaRegistry) this.vanilla).setForgeRegistry(this);\n+\t\t\tthis.isVanilla = true;\n+\t\t}\n+\n+\t\t// Fabric hooks\n+\t\t// TODO: Some vanilla registry types are not patched yet, add this check to avoid crash\n+\t\tif (IForgeRegistryEntry.class.isAssignableFrom(this.superType)) {\n+\t\t\tRegistryEntryAddedCallback.event(this.vanilla).register(this);\n+\t\t}\n+\n+\t\tif (this.create != null) {\n+\t\t\tthis.create.onCreate(this, stage);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onEntryAdded(int rawId, Identifier id, V newValue) {\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(String.format(\"The object %s (name %s) is being added too late.\", newValue, id));", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTg4OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439855888", "bodyText": "Sure, I will add a note", "author": "rikka0w0", "createdAt": "2020-06-14T18:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MzA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzY2MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863660", "bodyText": "note added", "author": "rikka0w0", "createdAt": "2020-06-14T20:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MzA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MzI3Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439853272", "bodyText": "What vanilla types are missing? That should be noted here and fixed soon", "author": "coderbot16", "createdAt": "2020-06-14T17:55:10Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -39,18 +40,84 @@\n import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.registry.MutableRegistry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+import net.patchworkmc.impl.registries.ClearableRegistry;\n+import net.patchworkmc.impl.registries.ExtendedVanillaRegistry;\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements\n+\t\tIForgeRegistryModifiable<V>, IForgeRegistryInternal<V>, RegistryEntryAddedCallback<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final Identifier name;\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = new HashMap<>();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\tprivate V oldValue; // context of AddCallback, does not use elsewhere\n+\n+\t/**\n+\t * Called by RegistryBuilder, for modded registries.\n+\t * @param stage\n+\t * @param name\n+\t * @param builder\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n \t\tthis.name = name;\n-\t\tthis.vanilla = vanilla;\n-\t\tthis.superType = superType;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.allowOverrides = builder.getAllowOverrides();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n+\n+\t\tRegistry<V> vanilla = builder.getVanillaRegistry();\n+\n+\t\tif (vanilla == null) {\n+\t\t\t// Forge modded registry\n+\t\t\tthis.vanilla = new ExtendedVanillaRegistry<>(this);\n+\t\t\tRegistry.REGISTRIES.add(name, (MutableRegistry) this.vanilla);\n+\t\t\tthis.isVanilla = false;\n+\t\t} else {\n+\t\t\t// Vanilla registry\n+\t\t\tthis.vanilla = vanilla;\n+\t\t\t((VanillaRegistry) this.vanilla).setForgeRegistry(this);\n+\t\t\tthis.isVanilla = true;\n+\t\t}\n+\n+\t\t// Fabric hooks\n+\t\t// TODO: Some vanilla registry types are not patched yet, add this check to avoid crash", "originalCommit": "22f059b0959ec6b9079af40d4a5496f55aa0bdef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTc4OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439855789", "bodyText": "DimentionTypes\nand some vanilla registry should not be patched, e.g. custom_stat is Identifier", "author": "rikka0w0", "createdAt": "2020-06-14T18:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MzI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTkzNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439855936", "bodyText": "Perhaps we should leave them there for now, when we start working on the ModDimention, we can have a look at DimentionType registry together", "author": "rikka0w0", "createdAt": "2020-06-14T18:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MzI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzY5NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r439863694", "bodyText": "We can leave DimentionType for now, adding support for modded dimention is beyond this pr.", "author": "rikka0w0", "createdAt": "2020-06-14T20:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MzI3Mg=="}], "type": "inlineReview"}, {"oid": "12d10dd2abb12a01d4b7a3462ff8275db25fb716", "url": "https://github.com/PatchworkMC/patchwork-api/commit/12d10dd2abb12a01d4b7a3462ff8275db25fb716", "message": "Add Readme.md, add StructureFeature registration support", "committedDate": "2020-06-14T20:00:12Z", "type": "commit"}, {"oid": "7712b086e7c954dd884f538f22780375ad819ce6", "url": "https://github.com/PatchworkMC/patchwork-api/commit/7712b086e7c954dd884f538f22780375ad819ce6", "message": "code clean up", "committedDate": "2020-06-14T20:12:17Z", "type": "commit"}, {"oid": "5a92f04b672d5c880f1fc569b96cc56ac1c7e4a6", "url": "https://github.com/PatchworkMC/patchwork-api/commit/5a92f04b672d5c880f1fc569b96cc56ac1c7e4a6", "message": "Remove clear() on vanilla registry, impl remove() for Forge mod\nregistries", "committedDate": "2020-06-15T16:34:09Z", "type": "commit"}, {"oid": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "url": "https://github.com/PatchworkMC/patchwork-api/commit/61daff1caf8c46160db09199406bb5c4a95b8cc2", "message": "Add default registry entry support", "committedDate": "2020-06-15T17:27:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTA3OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441019079", "bodyText": "Perhaps there's a better name for this, since this is for removal / clearing and there's already a ModifiableRegistry in vanilla too.", "author": "coderbot16", "createdAt": "2020-06-16T17:24:37Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/ModifiableRegistry.java", "diffHunk": "@@ -19,6 +19,9 @@\n \n package net.patchworkmc.impl.registries;\n \n-public interface ClearableRegistry {\n+import net.minecraft.util.Identifier;\n+\n+public interface ModifiableRegistry<V> {", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3NDE2OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441774168", "bodyText": "rename to PatchworkModifiableRegistry?", "author": "rikka0w0", "createdAt": "2020-06-17T19:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3NzExNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441777115", "bodyText": "I'm not sure if modifiable is the best name, because in this case it's referring more to the ability to clear or remove from the registry.", "author": "coderbot16", "createdAt": "2020-06-17T19:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3ODc4MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441778780", "bodyText": "EditableRegistry is better", "author": "rikka0w0", "createdAt": "2020-06-17T19:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4MjEzMQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441782131", "bodyText": "Editable seems like a synonym of modifiable, perhaps ClearableRegistry or RemovableRegistry would work.", "author": "coderbot16", "createdAt": "2020-06-17T19:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwODA5Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441808096", "bodyText": "forge or vanilla already have ClearableRegistry, so i think we should use RemovableRegistry", "author": "rikka0w0", "createdAt": "2020-06-17T20:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MDkzMQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441040931", "bodyText": "Should probably move this to also the structure feature check, too.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tLOGGER.debug(\"Fabric added a Vanilla registry, no ForgeRegistry wrapper.\");\n          \n          \n            \n            \t\t\tLOGGER.warn(\"Detected an unknown Vanilla registry with no Patchwork equivalent: %s\", identifier);", "author": "coderbot16", "createdAt": "2020-06-16T18:01:34Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -216,10 +209,16 @@ public static Identifier checkPrefix(String name, boolean warnOverrides) {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic static <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> wrapVanilla(Identifier identifier, Registry<?> registry) {\n-\t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) GameData.getBuilder(identifier);\n+\t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) vanillaWrapperBuilders.get(identifier);\n+\n+\t\tif (builder == null) {\n+\t\t\tLOGGER.debug(\"Fabric added a Vanilla registry, no ForgeRegistry wrapper.\");", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MTI3NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441041274", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t// In Forge mods, StructureFeature are registered with IForgeRegistry<Feature>\n          \n          \n            \n            \t\t\t// In Forge mods, StructureFeatures are registered with IForgeRegistry<Feature>", "author": "coderbot16", "createdAt": "2020-06-16T18:02:12Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -216,10 +209,16 @@ public static Identifier checkPrefix(String name, boolean warnOverrides) {\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic static <V extends IForgeRegistryEntry<V>> IForgeRegistry<V> wrapVanilla(Identifier identifier, Registry<?> registry) {\n-\t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) GameData.getBuilder(identifier);\n+\t\tRegistryBuilder<V> builder = (RegistryBuilder<V>) vanillaWrapperBuilders.get(identifier);\n+\n+\t\tif (builder == null) {\n+\t\t\tLOGGER.debug(\"Fabric added a Vanilla registry, no ForgeRegistry wrapper.\");\n+\t\t\treturn null;\n+\t\t}\n \n-\t\tif (builder.getType().isAssignableFrom(StructureFeature.class)) {\n-\t\t\t// TODO: StructureFeature Needs slave map impl\n+\t\tif (StructureFeature.class.isAssignableFrom(builder.getType())) {\n+\t\t\t// In Forge mods, StructureFeature are registered with IForgeRegistry<Feature>", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MTQzOA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441041438", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tLOGGER.info(\"Potentially Dangerous alternative prefix `{}` for name `{}`, expected `{}`. This could be a intended override, but in most cases indicates a broken mod.\", oldPrefix, name, prefix);\n          \n          \n            \n            \t\t\tLOGGER.warn(\"Potentially Dangerous alternative prefix `{}` for name `{}`, expected `{}`. This could be a intended override, but in most cases indicates a broken mod.\", oldPrefix, name, prefix);", "author": "coderbot16", "createdAt": "2020-06-16T18:02:28Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java", "diffHunk": "@@ -207,7 +200,7 @@ public static Identifier checkPrefix(String name, boolean warnOverrides) {\n \t\tString prefix = ModLoadingContext.get().getActiveNamespace();\n \n \t\tif (warnOverrides && !oldPrefix.equals(prefix) && oldPrefix.length() > 0) {\n-\t\t\tLogManager.getLogger().info(\"Potentially Dangerous alternative prefix `{}` for name `{}`, expected `{}`. This could be a intended override, but in most cases indicates a broken mod.\", oldPrefix, name, prefix);\n+\t\t\tLOGGER.info(\"Potentially Dangerous alternative prefix `{}` for name `{}`, expected `{}`. This could be a intended override, but in most cases indicates a broken mod.\", oldPrefix, name, prefix);", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MTg3MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441041871", "bodyText": "Should probably have an instanceof check, to avoid class cast exceptions.", "author": "coderbot16", "createdAt": "2020-06-16T18:03:16Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -310,22 +343,32 @@ public void clear() {\n \t\t\tthrow new IllegalStateException(\"Attempted to clear the registry too late.\");\n \t\t}\n \n-\t\tif (this.isVanilla) {\n-\t\t\tLOGGER.debug(\"Vanilla registery {} is cleared!\", this.name);\n-\t\t}\n-\n \t\tif (this.clear != null) {\n \t\t\tthis.clear.onClear(this, stage);\n \t\t}\n \n-\t\tClearableRegistry reg = (ClearableRegistry) this.vanilla;\n-\t\treg.clear();\n+\t\t// If it is modifiable, it must be a forge mod registry, vanilla registries do not support clear().\n+\t\t((ModifiableRegistry<V>) this.vanilla).clear();\n \t}\n \n-\t// TODO: implement remove()\n \t@Override\n \tpublic V remove(Identifier key) {\n-\t\tthrow new UnsupportedOperationException(\"Remove() is not implemented\");\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to remove from a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to remove from the registry too late.\");\n+\t\t}\n+\n+\t\t// If it is modifiable, it must be a forge mod registry, vanilla registries do not support remove().\n+\t\tV removed = ((ModifiableRegistry<V>) this.vanilla).remove(key);", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3NjEyMQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441776121", "bodyText": "fixed", "author": "rikka0w0", "createdAt": "2020-06-17T19:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MTg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MjA3Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441042076", "bodyText": "Same comment here as on remove().", "author": "coderbot16", "createdAt": "2020-06-16T18:03:38Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -310,22 +343,32 @@ public void clear() {\n \t\t\tthrow new IllegalStateException(\"Attempted to clear the registry too late.\");\n \t\t}\n \n-\t\tif (this.isVanilla) {\n-\t\t\tLOGGER.debug(\"Vanilla registery {} is cleared!\", this.name);\n-\t\t}\n-\n \t\tif (this.clear != null) {\n \t\t\tthis.clear.onClear(this, stage);\n \t\t}\n \n-\t\tClearableRegistry reg = (ClearableRegistry) this.vanilla;\n-\t\treg.clear();\n+\t\t// If it is modifiable, it must be a forge mod registry, vanilla registries do not support clear().\n+\t\t((ModifiableRegistry<V>) this.vanilla).clear();", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1ODk3NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441058975", "bodyText": "I think this should be handled elsewhere instead of being hardcoded into the ForgeRegistry class. We might need our own callback made just for Forge mods adding stuff.", "author": "coderbot16", "createdAt": "2020-06-16T18:29:23Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -160,6 +176,23 @@ public void register(V value) {\n \t\t}\n \n \t\tRegistry.register(vanilla, identifier, value);\n+\n+\t\t// Handle StructureFeature\n+\t\tif (value instanceof StructureFeature) {\n+\t\t\tStructureFeature<?> structure = (StructureFeature<?>) value;\n+\t\t\tString key = structure.getName().toLowerCase(Locale.ROOT);\n+\t\t\tRegistry.register(Registry.STRUCTURE_FEATURE, key, structure);\n+\n+\t\t\tBiMap<String, StructureFeature<?>> map = StructureFeature.STRUCTURES;\n+\n+\t\t\tif (this.oldValue != null && this.oldValue instanceof StructureFeature) {\n+\t\t\t\tString oldName = ((StructureFeature) oldValue).getName();\n+\t\t\t\tmap.remove(oldName.toLowerCase(Locale.ROOT));\n+\t\t\t}\n+\n+\t\t\tmap.put(key, structure);\n+\t\t}", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3NzE0MA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441777140", "bodyText": "ForgeRegistry.register() is for forge mod only, vanilla and fabric won't use this function. I do agree that we should make our own callbacks.", "author": "rikka0w0", "createdAt": "2020-06-17T19:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1ODk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2ODI3NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441068275", "bodyText": "Why are you doing this? This is way more complex than necessary. All you need to do for removal logic is to remove the value from entries and indexedEntries, set randomEntries to null, and then potentially have logic to reuse removed raw IDs within add(). A bit set for that is kinda overkill, an IntArrayList for each removed item is fine. Maybe you can have an optimization to just decrement nextId if the entry is the last entry instead of adding it to the available IDs list, but I'm not sure how common that is.\nOverall, I'd like ForgeModRegistry / ForgeModRegistryImpl / ForgeModDefaultRegistry to be rewritten / rethought so that they're just lightweight extensions to vanilla registry classes. Also, you could probably call them RemovableSimpleRegistry and RemovableDefaultedRegistry, unless you have some better names.", "author": "coderbot16", "createdAt": "2020-06-16T18:45:51Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/ForgeModRegistryImpl.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.impl.registries;\n+\n+import java.util.BitSet;\n+\n+import org.apache.commons.lang3.Validate;\n+import com.google.common.collect.BiMap;\n+import net.minecraftforge.registries.IForgeRegistryEntry;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+/**\n+ * This interface is for avoiding duplicated implementation as much as possible\n+ * The vanilla field {@link net.minecraft.util.registry.SimpleRegistry#indexedEntries} is not used.\n+ * @author Rikka0w0\n+ */\n+public interface ForgeModRegistryImpl<V extends IForgeRegistryEntry<V>> extends ForgeRegistryProvider, ModifiableRegistry<V> {", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0NzY1Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441147656", "bodyText": "The \"entries\" is a BiMap<int, Object> implemented by vanilla, it is used in the registry system and other places. It supports put(named set in the code) and clear, but it does not support remove. There is an alternative implement, use mixin to add a remove() method for that class. Or we can implement our own bimap which extends the vanilla BiHashMap, and use mixin to replace the instance of \"entries\".\nI do agree that the bitset can be replaced by a nextId and a list of available Ids", "author": "rikka0w0", "createdAt": "2020-06-16T21:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2ODI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Mjc3OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441152779", "bodyText": "In that case, why not replace it in the constructor with an instance of a class extending Int2ObjectBiMap that does support removal (As you've said)?\n\nOr we can implement our own bimap which extends the vanilla BiHashMap, and use mixin to replace the instance of \"entries", "author": "coderbot16", "createdAt": "2020-06-16T21:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2ODI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwOTMyNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441809327", "bodyText": "I use mixin to add a method to the Int2ObjectBiMap, because that seems to be the easier. We need to access some private fields, extending the class won't help. I added only 1 method, no fields. BiMap and BitSet are removed.", "author": "rikka0w0", "createdAt": "2020-06-17T20:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2ODI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3OTE0NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441079144", "bodyText": "override is not enabled by default, so this is fine\nIt appears that it is enabled by default. It needs to be disabled on vanilla registries for now.", "author": "coderbot16", "createdAt": "2020-06-16T19:05:39Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.registries;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.logging.log4j.LogManager;\n+import com.google.common.collect.Lists;\n+import net.minecraftforge.registries.IForgeRegistry.AddCallback;\n+import net.minecraftforge.registries.IForgeRegistry.BakeCallback;\n+import net.minecraftforge.registries.IForgeRegistry.ClearCallback;\n+import net.minecraftforge.registries.IForgeRegistry.CreateCallback;\n+import net.minecraftforge.registries.IForgeRegistry.DummyFactory;\n+import net.minecraftforge.registries.IForgeRegistry.MissingFactory;\n+import net.minecraftforge.registries.IForgeRegistry.ValidateCallback;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+public class RegistryBuilder<T extends IForgeRegistryEntry<T>> {\n+\tprivate static final int MAX_ID = Integer.MAX_VALUE - 1;\n+\n+\tprivate Identifier registryName;\n+\tprivate Class<T> registryType;\n+\tprivate Identifier optionalDefaultKey;\n+\tprivate int minId = 0;\n+\tprivate int maxId = MAX_ID;\n+\tprivate List<AddCallback<T>> addCallback = Lists.newArrayList();\n+\tprivate List<ClearCallback<T>> clearCallback = Lists.newArrayList();\n+\tprivate List<CreateCallback<T>> createCallback = Lists.newArrayList();\n+\tprivate List<ValidateCallback<T>> validateCallback = Lists.newArrayList();\n+\tprivate List<BakeCallback<T>> bakeCallback = Lists.newArrayList();\n+\tprivate boolean saveToDisc = true;\n+\tprivate boolean sync = true;\n+\tprivate boolean allowOverrides = true;", "originalCommit": "61daff1caf8c46160db09199406bb5c4a95b8cc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTI3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r441135278", "bodyText": "I see, gonna to fix that in the next commit", "author": "rikka0w0", "createdAt": "2020-06-16T20:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3OTE0NA=="}], "type": "inlineReview"}, {"oid": "e41094365497a328137dd71a517a58f71c328ad4", "url": "https://github.com/PatchworkMC/patchwork-api/commit/e41094365497a328137dd71a517a58f71c328ad4", "message": "Fix problems", "committedDate": "2020-06-17T19:21:49Z", "type": "commit"}, {"oid": "ee1214be0f8ce4d18511dad560ca4129a69d8015", "url": "https://github.com/PatchworkMC/patchwork-api/commit/ee1214be0f8ce4d18511dad560ca4129a69d8015", "message": "Better removable registry impl", "committedDate": "2020-06-17T20:20:41Z", "type": "commit"}, {"oid": "71db5dec9f72f7a38cf1e3fec2b136d19999dbcd", "url": "https://github.com/PatchworkMC/patchwork-api/commit/71db5dec9f72f7a38cf1e3fec2b136d19999dbcd", "message": "Make the registry system inject less invasive", "committedDate": "2020-06-18T15:04:02Z", "type": "commit"}, {"oid": "05e948bb705dc23f4342b428ab28ba63547bba8e", "url": "https://github.com/PatchworkMC/patchwork-api/commit/05e948bb705dc23f4342b428ab28ba63547bba8e", "message": "Fix some potential compatibility problem in StructureFeature\nregistration and getSlaveMap()", "committedDate": "2020-06-18T16:16:18Z", "type": "commit"}, {"oid": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "url": "https://github.com/PatchworkMC/patchwork-api/commit/46a96ee43b1452c53c223f905e4f3ac09794cf1f", "message": "Update patchwork-registries/src/main/java/net/minecraftforge/registries/GameData.java\n\nCo-authored-by: coderbot <coderbot16@gmail.com>", "committedDate": "2020-06-18T16:19:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MDE0Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442580147", "bodyText": "Needs a version bump in the module.", "author": "TheGlitch76", "createdAt": "2020-06-19T01:13:10Z", "path": "patchwork-dispatcher/src/main/java/net/patchworkmc/impl/Patchwork.java", "diffHunk": "@@ -63,7 +64,10 @@ private static void dispatch(Map<ForgeInitializer, FMLModContainer> mods, Functi\n \t\tfor (FMLModContainer container : mods.values()) {\n \t\t\tModLoadingContext.get().setActiveContainer(container, new FMLJavaModLoadingContext(container));\n \n-\t\t\tcontainer.getEventBus().post(provider.apply(container));\n+\t\t\tEvent event = provider.apply(container);", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEyMjk3MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r443122971", "bodyText": "fixed", "author": "rikka0w0", "createdAt": "2020-06-20T11:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MDUwOA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442580508", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate V oldValue; // context of AddCallback, does not use elsewhere\n          \n          \n            \n            \tprivate V oldValue; // context of AddCallback, is not used elsewhere", "author": "TheGlitch76", "createdAt": "2020-06-19T01:14:43Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -35,27 +36,104 @@\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.Marker;\n import org.apache.logging.log4j.MarkerManager;\n+import com.google.common.collect.BiMap;\n \n import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.gen.feature.StructureFeature;\n+import net.minecraft.util.registry.MutableRegistry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+import net.patchworkmc.impl.registries.RemovableRegistry;\n+import net.patchworkmc.impl.registries.ForgeModDefaultRegistry;\n+import net.patchworkmc.impl.registries.ForgeModRegistry;\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements\n+\t\tIForgeRegistryModifiable<V>, IForgeRegistryInternal<V>, RegistryEntryAddedCallback<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final Identifier name;\t// The forge name\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = new HashMap<>();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tpublic final int min;\n+\tpublic final int max;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\tprivate V oldValue; // context of AddCallback, does not use elsewhere", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MDgwNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442580806", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn name;\t\t\t// The forge name of registry\n          \n          \n            \n            \t\treturn name; // The forge name of registry", "author": "TheGlitch76", "createdAt": "2020-06-19T01:15:48Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -35,27 +36,104 @@\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.Marker;\n import org.apache.logging.log4j.MarkerManager;\n+import com.google.common.collect.BiMap;\n \n import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.gen.feature.StructureFeature;\n+import net.minecraft.util.registry.MutableRegistry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+import net.patchworkmc.impl.registries.RemovableRegistry;\n+import net.patchworkmc.impl.registries.ForgeModDefaultRegistry;\n+import net.patchworkmc.impl.registries.ForgeModRegistry;\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements\n+\t\tIForgeRegistryModifiable<V>, IForgeRegistryInternal<V>, RegistryEntryAddedCallback<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final Identifier name;\t// The forge name\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = new HashMap<>();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tpublic final int min;\n+\tpublic final int max;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\tprivate V oldValue; // context of AddCallback, does not use elsewhere\n+\n+\t/**\n+\t * Called by RegistryBuilder, for modded registries.\n+\t * @param stage\n+\t * @param name the forge name\n+\t * @param builder\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n \t\tthis.name = name;\n-\t\tthis.vanilla = vanilla;\n-\t\tthis.superType = superType;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.min = builder.getMinId();\n+\t\tthis.max = builder.getMaxId();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.allowOverrides = builder.getAllowOverrides();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n+\n+\t\tRegistry<V> vanilla = builder.getVanillaRegistry();\n+\n+\t\tif (vanilla == null) {\n+\t\t\t// Forge modded registry\n+\t\t\tIdentifier defaultKey = builder.getDefault();\n+\t\t\tthis.vanilla = defaultKey == null ? new ForgeModRegistry<>(this, builder) : new ForgeModDefaultRegistry<>(this, builder);\n+\t\t\tRegistry.REGISTRIES.add(name, (MutableRegistry) this.vanilla);\n+\t\t\tthis.isVanilla = false;\n+\t\t} else {\n+\t\t\t// Vanilla registry\n+\t\t\tthis.vanilla = vanilla;\n+\t\t\t((VanillaRegistry) this.vanilla).setForgeRegistry(this);\n+\t\t\tthis.isVanilla = true;\n+\n+\t\t\t// Set the slave map for compatibility\n+\t\t\tthis.setSlaveMap(new Identifier(\"forge\", \"registry_defaulted_wrapper\"), vanilla);\n+\t\t}\n+\n+\t\t// Fabric hooks\n+\t\t// TODO: Some vanilla registry types are not patched yet, add this check to avoid crash\n+\t\tif (IForgeRegistryEntry.class.isAssignableFrom(this.superType)) {\n+\t\t\tRegistryEntryAddedCallback.event(this.vanilla).register(this);\n+\t\t}\n+\n+\t\tif (this.create != null) {\n+\t\t\tthis.create.onCreate(this, stage);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onEntryAdded(int rawId, Identifier id, V newValue) {\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(String.format(\"The object %s (name %s) is being added too late.\", newValue, id));\n+\t\t}\n+\n+\t\tif (this.add != null) {\n+\t\t\tthis.add.onAdd(this, this.stage, rawId, newValue, this.oldValue);\n+\t\t}\n \t}\n \n \t@Override\n \tpublic Identifier getRegistryName() {\n-\t\treturn name;\n+\t\treturn name;\t\t\t// The forge name of registry", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MTE1OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442581159", "bodyText": "These look connected.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// TODO: make a Patchwork callback\n          \n          \n            \n            \t\t// Handle StructureFeature\n          \n          \n            \n            \t\t// TODO: make a Patchwork callback\n          \n          \n            \n            \n          \n          \n            \n            \t\t// Handle StructureFeature", "author": "TheGlitch76", "createdAt": "2020-06-19T01:17:21Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -89,6 +173,25 @@ public void register(V value) {\n \t\t}\n \n \t\tRegistry.register(vanilla, identifier, value);\n+\n+\t\t// TODO: make a Patchwork callback\n+\t\t// Handle StructureFeature", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MTQxOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442581419", "bodyText": "if this is a feature that is possible in Forge but not in Patchwork please note it here", "author": "TheGlitch76", "createdAt": "2020-06-19T01:18:34Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -204,4 +315,81 @@ public int hashCode() {\n \t\t\treturn identifier.hashCode() * 33 + value.hashCode();\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used to control the times where people can modify this registry.\n+\t * Users should only ever register things in the Register<?> events!\n+\t */\n+\tpublic void freeze() {\n+\t\tthis.isFrozen = true;\n+\t}\n+\n+\tpublic void unfreeze() {\n+\t\tthis.isFrozen = false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isLocked() {\n+\t\treturn this.isFrozen;\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to clear a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to clear the registry too late.\");\n+\t\t}\n+\n+\t\tif (this.clear != null) {\n+\t\t\tthis.clear.onClear(this, stage);\n+\t\t}\n+\n+\t\t// If it is modifiable, it must be a forge mod registry, vanilla registries do not support clear().\n+\t\tif (this.vanilla instanceof RemovableRegistry) {\n+\t\t\t((RemovableRegistry<V>) this.vanilla).clear();\n+\t\t} else {\n+\t\t\tLOGGER.error(\"Attempted to clear a non-modifiable or vanilla registry\");\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic V remove(Identifier key) {\n+\t\tif (!this.isModifiable) {\n+\t\t\tthrow new UnsupportedOperationException(\"Attempted to remove from a non-modifiable Forge Registry\");\n+\t\t}\n+\n+\t\tif (this.isLocked()) {\n+\t\t\tthrow new IllegalStateException(\"Attempted to remove from the registry too late.\");\n+\t\t}\n+\n+\t\t// If it is modifiable, it must be a forge mod registry, vanilla registries do not support remove().", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEyMjQ4Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r443122486", "bodyText": "In forge, mod registries support remove (optional), vanilla registries only support insertion and replacement. In our impl, forge mod registries have the same behavior, but vanilla registries only support insertion not replacement. I have a note in the README.md.", "author": "rikka0w0", "createdAt": "2020-06-20T11:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MTQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MjQwNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442582404", "bodyText": "is not having saveToDisk going to corrupt/break anything? It would be wise to throw a big fat error/at least a log when someone potentially corrupts their world.", "author": "TheGlitch76", "createdAt": "2020-06-19T01:22:47Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryManager.java", "diffHunk": "@@ -20,21 +20,35 @@\n package net.minecraftforge.registries;\n \n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Sets.SetView;\n \n import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n \n-import net.patchworkmc.impl.registries.RegistryClassMapping;\n+import net.patchworkmc.impl.registries.ForgeRegistryProvider;\n \n+//TODO: unimplemented features: saveToDisk, legacyName, sync, dump", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MjQ4OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442582488", "bodyText": "In fact if this is world-corruptable it should go into its own branch until its resolved.", "author": "TheGlitch76", "createdAt": "2020-06-19T01:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEyMjM0Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r443122347", "bodyText": "We don't need saveToDisk feature, it is used in forge's vanilla replacement. Unlike forge, our registry impl is based on vanilla registry, so we don't need to worry about this. It won't corrupt the world.", "author": "rikka0w0", "createdAt": "2020-06-20T11:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc0NDA3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r446744078", "bodyText": "That includes modded registries?", "author": "TheGlitch76", "createdAt": "2020-06-29T02:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MjQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxNjc3OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r446916779", "bodyText": "Yes.\nThe vanilla registry handles the saveToDisk, and fabric handles sync.\nlegacyName allows forge mods to get the IForgeRegistry by name, now it seems to be deprecated, the only way for forge mod to obtain a IForgeRegistry instance is to call GameRegistry.findRegistry(<Class<?>).\ndump just prints the registry entry and its id.", "author": "rikka0w0", "createdAt": "2020-06-29T12:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4MjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4NTE4OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442585189", "bodyText": "same with the hashmap thing, sorry for the tiny nitpick but this needs to be new ArrayList<>();", "author": "TheGlitch76", "createdAt": "2020-06-19T01:34:24Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.registries;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.logging.log4j.LogManager;\n+import com.google.common.collect.Lists;\n+import net.minecraftforge.registries.IForgeRegistry.AddCallback;\n+import net.minecraftforge.registries.IForgeRegistry.BakeCallback;\n+import net.minecraftforge.registries.IForgeRegistry.ClearCallback;\n+import net.minecraftforge.registries.IForgeRegistry.CreateCallback;\n+import net.minecraftforge.registries.IForgeRegistry.DummyFactory;\n+import net.minecraftforge.registries.IForgeRegistry.MissingFactory;\n+import net.minecraftforge.registries.IForgeRegistry.ValidateCallback;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+public class RegistryBuilder<T extends IForgeRegistryEntry<T>> {\n+\tprivate static final int MAX_ID = Integer.MAX_VALUE - 1;\n+\n+\tprivate Identifier registryName;\n+\tprivate Class<T> registryType;\n+\tprivate Identifier optionalDefaultKey;\n+\tprivate int minId = 0;\n+\tprivate int maxId = MAX_ID;\n+\tprivate List<AddCallback<T>> addCallback = Lists.newArrayList();", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU4NTM5NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r442585394", "bodyText": "Cache this logger in a private static final LOGGER field", "author": "TheGlitch76", "createdAt": "2020-06-19T01:35:16Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.registries;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.logging.log4j.LogManager;\n+import com.google.common.collect.Lists;\n+import net.minecraftforge.registries.IForgeRegistry.AddCallback;\n+import net.minecraftforge.registries.IForgeRegistry.BakeCallback;\n+import net.minecraftforge.registries.IForgeRegistry.ClearCallback;\n+import net.minecraftforge.registries.IForgeRegistry.CreateCallback;\n+import net.minecraftforge.registries.IForgeRegistry.DummyFactory;\n+import net.minecraftforge.registries.IForgeRegistry.MissingFactory;\n+import net.minecraftforge.registries.IForgeRegistry.ValidateCallback;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+public class RegistryBuilder<T extends IForgeRegistryEntry<T>> {\n+\tprivate static final int MAX_ID = Integer.MAX_VALUE - 1;\n+\n+\tprivate Identifier registryName;\n+\tprivate Class<T> registryType;\n+\tprivate Identifier optionalDefaultKey;\n+\tprivate int minId = 0;\n+\tprivate int maxId = MAX_ID;\n+\tprivate List<AddCallback<T>> addCallback = Lists.newArrayList();\n+\tprivate List<ClearCallback<T>> clearCallback = Lists.newArrayList();\n+\tprivate List<CreateCallback<T>> createCallback = Lists.newArrayList();\n+\tprivate List<ValidateCallback<T>> validateCallback = Lists.newArrayList();\n+\tprivate List<BakeCallback<T>> bakeCallback = Lists.newArrayList();\n+\tprivate boolean saveToDisc = true;\n+\tprivate boolean sync = true;\n+\tprivate boolean allowOverrides = true;\n+\tprivate boolean allowModifications = false;\n+\tprivate DummyFactory<T> dummyFactory;\n+\tprivate MissingFactory<T> missingFactory;\n+\tprivate Set<Identifier> legacyNames = new HashSet<>();\n+\n+\tprivate Identifier vanillaId;\n+\n+\t/**\n+\t * Used by the Patchwork Vanilla Wrapper.\n+\t */\n+\tpublic RegistryBuilder<T> setVanillaRegistryId(Identifier vanillaId) {\n+\t\tthis.vanillaId = vanillaId;\n+\t\treturn this;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Registry<T> getVanillaRegistry() {\n+\t\treturn this.vanillaId == null ? null : (Registry<T>) Registry.REGISTRIES.get(this.vanillaId);\n+\t}\n+\n+\tpublic Identifier getVanillaId() {\n+\t\treturn this.vanillaId;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setName(Identifier name) {\n+\t\tthis.registryName = name;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setType(Class<T> type) {\n+\t\tif (type == null || type.isAssignableFrom(Object.class)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Registry type cannot be Object or null!\");\n+\t\t}\n+\n+\t\tthis.registryType = type;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setIDRange(int min, int max) {\n+\t\tthis.minId = Math.max(min, 0);\n+\t\tthis.maxId = Math.min(max, MAX_ID);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setMaxID(int max) {\n+\t\treturn this.setIDRange(0, max);\n+\t}\n+\n+\tpublic RegistryBuilder<T> setDefaultKey(Identifier key) {\n+\t\tthis.optionalDefaultKey = key;\n+\t\treturn this;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic RegistryBuilder<T> addCallback(Object inst) {\n+\t\tif (inst instanceof AddCallback) {\n+\t\t\tthis.add((AddCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof ClearCallback) {\n+\t\t\tthis.add((ClearCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof CreateCallback) {\n+\t\t\tthis.add((CreateCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof ValidateCallback) {\n+\t\t\tthis.add((ValidateCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof BakeCallback) {\n+\t\t\tthis.add((BakeCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof DummyFactory) {\n+\t\t\tthis.set((DummyFactory<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof MissingFactory) {\n+\t\t\tthis.set((MissingFactory<T>) inst);\n+\t\t}\n+\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(AddCallback<T> add) {\n+\t\tthis.addCallback.add(add);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(ClearCallback<T> clear) {\n+\t\tthis.clearCallback.add(clear);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(CreateCallback<T> create) {\n+\t\tthis.createCallback.add(create);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> add(ValidateCallback<T> validate) {\n+\t\tLogManager.getLogger(RegistryBuilder.class).warn(\"IForgeRegistry.ValidateCallback is not supported by Patchwork yet.\");", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyMzYzMA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r443023630", "bodyText": "Use a $ instead of a _ here: it's the style that's recommended by mixin", "author": "TheGlitch76", "createdAt": "2020-06-19T20:06:59Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/RemovableInt2ObjectBiMap.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.impl.registries;\n+\n+public interface RemovableInt2ObjectBiMap<K> {\n+\tint patchwork_remove(K object);", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyNDAwNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r443024005", "bodyText": "I don't think this exists in Forge, please use the patchwork$ prefix.", "author": "TheGlitch76", "createdAt": "2020-06-19T20:08:13Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/VanillaRegistry.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.impl.registries;\n+\n+import net.minecraftforge.registries.ForgeRegistry;\n+\n+public interface VanillaRegistry extends ForgeRegistryProvider {\n+\tboolean setForgeRegistry(ForgeRegistry forgeRegistry);", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAyNDI3Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r443024272", "bodyText": "If this isn't a forge-added method please use the patchwork$ prefix", "author": "TheGlitch76", "createdAt": "2020-06-19T20:09:05Z", "path": "patchwork-registries/src/main/java/net/patchworkmc/impl/registries/ForgeRegistryProvider.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.impl.registries;\n+\n+import net.minecraftforge.registries.ForgeRegistry;\n+\n+public interface ForgeRegistryProvider {\n+\tForgeRegistry getForgeRegistry();", "originalCommit": "46a96ee43b1452c53c223f905e4f3ac09794cf1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a58419ec9dbcd01999e60b466f1dc82fdad88f6", "url": "https://github.com/PatchworkMC/patchwork-api/commit/4a58419ec9dbcd01999e60b466f1dc82fdad88f6", "message": "Add patchwork$ prefix and code style fixes", "committedDate": "2020-06-20T11:15:11Z", "type": "commit"}, {"oid": "a7d02d73cfcdb381e05bffb89fc1611e1424d4ff", "url": "https://github.com/PatchworkMC/patchwork-api/commit/a7d02d73cfcdb381e05bffb89fc1611e1424d4ff", "message": "Merge branch 'master' of github.com:rikka0w0/patchwork-api", "committedDate": "2020-06-20T11:17:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc0Mjc0Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r446742747", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// TODO: Some vanilla registry types are not patched yet, add this check to avoid crash\n          \n          \n            \n            \t\t// TODO: Some vanilla registry types are not patched yet, this check is added to avoid a crash", "author": "TheGlitch76", "createdAt": "2020-06-29T02:41:39Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -39,23 +39,98 @@\n import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.registry.MutableRegistry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+import net.patchworkmc.impl.registries.RemovableRegistry;\n+import net.patchworkmc.impl.registries.ForgeModDefaultRegistry;\n+import net.patchworkmc.impl.registries.ForgeModRegistry;\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements\n+\t\tIForgeRegistryModifiable<V>, IForgeRegistryInternal<V>, RegistryEntryAddedCallback<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final Identifier name; // The forge name\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = new HashMap<>();\n+\tprivate final CreateCallback<V> create;\n+\tprivate final AddCallback<V> add;\n+\tprivate final ClearCallback<V> clear;\n+\tprivate final RegistryManager stage;\n+\tpublic final int min;\n+\tpublic final int max;\n+\tprivate final boolean allowOverrides;\n+\tprivate final boolean isModifiable;\n+\n+\tprivate boolean isFrozen = false;\n+\tprivate V oldValue; // context of AddCallback, is not used elsewhere\n+\n+\t/**\n+\t * Called by RegistryBuilder, for modded registries.\n+\t * @param stage\n+\t * @param name the forge name\n+\t * @param builder\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected ForgeRegistry(RegistryManager stage, Identifier name, RegistryBuilder<V> builder) {\n+\t\tthis.stage = stage;\n \t\tthis.name = name;\n-\t\tthis.vanilla = vanilla;\n-\t\tthis.superType = superType;\n+\t\tthis.superType = builder.getType();\n+\t\tthis.min = builder.getMinId();\n+\t\tthis.max = builder.getMaxId();\n+\t\tthis.create = builder.getCreate();\n+\t\tthis.add = builder.getAdd();\n+\t\tthis.clear = builder.getClear();\n+\t\tthis.allowOverrides = builder.getAllowOverrides();\n+\t\tthis.isModifiable = builder.getAllowModifications();\n+\n+\t\tRegistry<V> vanilla = builder.getVanillaRegistry();\n+\n+\t\tif (vanilla == null) {\n+\t\t\t// Forge modded registry\n+\t\t\tIdentifier defaultKey = builder.getDefault();\n+\t\t\tthis.vanilla = defaultKey == null ? new ForgeModRegistry<>(this, builder) : new ForgeModDefaultRegistry<>(this, builder);\n+\t\t\tRegistry.REGISTRIES.add(name, (MutableRegistry) this.vanilla);\n+\t\t\tthis.isVanilla = false;\n+\t\t} else {\n+\t\t\t// Vanilla registry\n+\t\t\tthis.vanilla = vanilla;\n+\t\t\t((VanillaRegistry) this.vanilla).patchwork$setForgeRegistry(this);\n+\t\t\tthis.isVanilla = true;\n+\n+\t\t\t// Set the slave map for compatibility\n+\t\t\tthis.setSlaveMap(new Identifier(\"forge\", \"registry_defaulted_wrapper\"), vanilla);\n+\t\t}\n+\n+\t\t// Fabric hooks\n+\t\t// TODO: Some vanilla registry types are not patched yet, add this check to avoid crash", "originalCommit": "a7d02d73cfcdb381e05bffb89fc1611e1424d4ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc0Mjk2Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r446742963", "bodyText": "all these callbacks could use a Callback suffix, so create -> createCallback etc. It makes the code a bit easier to follow", "author": "TheGlitch76", "createdAt": "2020-06-29T02:42:39Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java", "diffHunk": "@@ -39,23 +39,98 @@\n import net.minecraft.util.Identifier;\n import net.minecraft.util.registry.DefaultedRegistry;\n import net.minecraft.util.registry.Registry;\n+import net.minecraft.util.registry.MutableRegistry;\n \n-public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements IForgeRegistry<V> {\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+\n+import net.patchworkmc.impl.registries.RemovableRegistry;\n+import net.patchworkmc.impl.registries.ForgeModDefaultRegistry;\n+import net.patchworkmc.impl.registries.ForgeModRegistry;\n+import net.patchworkmc.impl.registries.VanillaRegistry;\n+\n+public class ForgeRegistry<V extends IForgeRegistryEntry<V>> implements\n+\t\tIForgeRegistryModifiable<V>, IForgeRegistryInternal<V>, RegistryEntryAddedCallback<V> {\n \tpublic static Marker REGISTRIES = MarkerManager.getMarker(\"REGISTRIES\");\n \tprivate static Logger LOGGER = LogManager.getLogger();\n-\tprivate Identifier name;\n-\tprivate Registry<V> vanilla;\n-\tprivate Class<V> superType;\n-\n-\tpublic ForgeRegistry(Identifier name, Registry<V> vanilla, Class<V> superType) {\n+\tprivate final Identifier name; // The forge name\n+\tprivate final boolean isVanilla;\n+\tprivate final Registry<V> vanilla;\n+\tprivate final Class<V> superType;\n+\tprivate final Map<Identifier, ?> slaves = new HashMap<>();\n+\tprivate final CreateCallback<V> create;", "originalCommit": "a7d02d73cfcdb381e05bffb89fc1611e1424d4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyODU1OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r446928559", "bodyText": "fixed", "author": "rikka0w0", "createdAt": "2020-06-29T12:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc0Mjk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc0MzM3Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/79#discussion_r446743372", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (inst instanceof AddCallback) {\n          \n          \n            \n            \t\t\tthis.add((AddCallback<T>) inst);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \n          \n          \n            \n            \t\tif (inst instanceof ClearCallback) {\n          \n          \n            \n            \t\t\tthis.add((ClearCallback<T>) inst);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \n          \n          \n            \n            \t\tif (inst instanceof CreateCallback) {\n          \n          \n            \n            \t\t\tthis.add((CreateCallback<T>) inst);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \n          \n          \n            \n            \t\tif (inst instanceof ValidateCallback) {\n          \n          \n            \n            \t\t\tthis.add((ValidateCallback<T>) inst);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \n          \n          \n            \n            \t\tif (inst instanceof BakeCallback) {\n          \n          \n            \n            \t\t\tthis.add((BakeCallback<T>) inst);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \n          \n          \n            \n            \t\tif (inst instanceof DummyFactory) {\n          \n          \n            \n            \t\t\tthis.set((DummyFactory<T>) inst);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \n          \n          \n            \n            \t\tif (inst instanceof MissingFactory) {\n          \n          \n            \n            \t\t\tthis.set((MissingFactory<T>) inst);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif (inst instanceof AddCallback) {\n          \n          \n            \n            \t\t\tthis.add((AddCallback<T>) inst);\n          \n          \n            \n            \t\t} else if (inst instanceof ClearCallback) {\n          \n          \n            \n            \t\t\tthis.add((ClearCallback<T>) inst);\n          \n          \n            \n            \t\t} else if (inst instanceof CreateCallback) {\n          \n          \n            \n            \t\t\tthis.add((CreateCallback<T>) inst);\n          \n          \n            \n            \t\t} else if (inst instanceof ValidateCallback) {\n          \n          \n            \n            \t\t\tthis.add((ValidateCallback<T>) inst);\n          \n          \n            \n            \t\t} else if (inst instanceof BakeCallback) {\n          \n          \n            \n            \t\t\tthis.add((BakeCallback<T>) inst);\n          \n          \n            \n            \t\t} else if (inst instanceof DummyFactory) {\n          \n          \n            \n            \t\t\tthis.set((DummyFactory<T>) inst);\n          \n          \n            \n            \t\t} else if (inst instanceof MissingFactory) {\n          \n          \n            \n            \t\t\tthis.set((MissingFactory<T>) inst);\n          \n          \n            \n            \t\t}", "author": "TheGlitch76", "createdAt": "2020-06-29T02:44:49Z", "path": "patchwork-registries/src/main/java/net/minecraftforge/registries/RegistryBuilder.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.registries;\n+\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import net.minecraftforge.registries.IForgeRegistry.AddCallback;\n+import net.minecraftforge.registries.IForgeRegistry.BakeCallback;\n+import net.minecraftforge.registries.IForgeRegistry.ClearCallback;\n+import net.minecraftforge.registries.IForgeRegistry.CreateCallback;\n+import net.minecraftforge.registries.IForgeRegistry.DummyFactory;\n+import net.minecraftforge.registries.IForgeRegistry.MissingFactory;\n+import net.minecraftforge.registries.IForgeRegistry.ValidateCallback;\n+\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+public class RegistryBuilder<T extends IForgeRegistryEntry<T>> {\n+\tprivate static final int MAX_ID = Integer.MAX_VALUE - 1;\n+\n+\tprivate Identifier registryName;\n+\tprivate Class<T> registryType;\n+\tprivate Identifier optionalDefaultKey;\n+\tprivate int minId = 0;\n+\tprivate int maxId = MAX_ID;\n+\tprivate List<AddCallback<T>> addCallback = new LinkedList<>();\n+\tprivate List<ClearCallback<T>> clearCallback = new LinkedList<>();\n+\tprivate List<CreateCallback<T>> createCallback = new LinkedList<>();\n+\tprivate List<ValidateCallback<T>> validateCallback = new LinkedList<>();\n+\tprivate List<BakeCallback<T>> bakeCallback = new LinkedList<>();\n+\tprivate boolean saveToDisc = true;\n+\tprivate boolean sync = true;\n+\tprivate boolean allowOverrides = true;\n+\tprivate boolean allowModifications = false;\n+\tprivate DummyFactory<T> dummyFactory;\n+\tprivate MissingFactory<T> missingFactory;\n+\tprivate Set<Identifier> legacyNames = new HashSet<>();\n+\n+\tprivate Identifier vanillaId;\n+\tprivate static final Logger LOGGER = LogManager.getLogger(RegistryBuilder.class);\n+\n+\t/**\n+\t * Used by the Patchwork Vanilla Wrapper.\n+\t */\n+\tpublic RegistryBuilder<T> setVanillaRegistryId(Identifier vanillaId) {\n+\t\tthis.vanillaId = vanillaId;\n+\t\treturn this;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Registry<T> getVanillaRegistry() {\n+\t\treturn this.vanillaId == null ? null : (Registry<T>) Registry.REGISTRIES.get(this.vanillaId);\n+\t}\n+\n+\tpublic Identifier getVanillaId() {\n+\t\treturn this.vanillaId;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setName(Identifier name) {\n+\t\tthis.registryName = name;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setType(Class<T> type) {\n+\t\tif (type == null || type.isAssignableFrom(Object.class)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Registry type cannot be Object or null!\");\n+\t\t}\n+\n+\t\tthis.registryType = type;\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setIDRange(int min, int max) {\n+\t\tthis.minId = Math.max(min, 0);\n+\t\tthis.maxId = Math.min(max, MAX_ID);\n+\t\treturn this;\n+\t}\n+\n+\tpublic RegistryBuilder<T> setMaxID(int max) {\n+\t\treturn this.setIDRange(0, max);\n+\t}\n+\n+\tpublic RegistryBuilder<T> setDefaultKey(Identifier key) {\n+\t\tthis.optionalDefaultKey = key;\n+\t\treturn this;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic RegistryBuilder<T> addCallback(Object inst) {\n+\t\tif (inst instanceof AddCallback) {\n+\t\t\tthis.add((AddCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof ClearCallback) {\n+\t\t\tthis.add((ClearCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof CreateCallback) {\n+\t\t\tthis.add((CreateCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof ValidateCallback) {\n+\t\t\tthis.add((ValidateCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof BakeCallback) {\n+\t\t\tthis.add((BakeCallback<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof DummyFactory) {\n+\t\t\tthis.set((DummyFactory<T>) inst);\n+\t\t}\n+\n+\t\tif (inst instanceof MissingFactory) {\n+\t\t\tthis.set((MissingFactory<T>) inst);\n+\t\t}", "originalCommit": "a7d02d73cfcdb381e05bffb89fc1611e1424d4ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6432e7a570419dc39a32ad958c0e47c50c2e61d", "url": "https://github.com/PatchworkMC/patchwork-api/commit/b6432e7a570419dc39a32ad958c0e47c50c2e61d", "message": "Update patchwork-registries/src/main/java/net/minecraftforge/registries/ForgeRegistry.java\n\nCo-authored-by: Glitch <glitchieproductionsofficial@gmail.com>", "committedDate": "2020-06-29T11:56:09Z", "type": "commit"}, {"oid": "28ae9f04f95e1466da3999c18c869a7ee7ded686", "url": "https://github.com/PatchworkMC/patchwork-api/commit/28ae9f04f95e1466da3999c18c869a7ee7ded686", "message": "Apply suggestions from code review\n\nCo-authored-by: Glitch <glitchieproductionsofficial@gmail.com>", "committedDate": "2020-06-29T12:04:54Z", "type": "commit"}, {"oid": "1f359665b255675641945b2d632e080ef6b3f9fb", "url": "https://github.com/PatchworkMC/patchwork-api/commit/1f359665b255675641945b2d632e080ef6b3f9fb", "message": "rename", "committedDate": "2020-06-29T12:22:32Z", "type": "commit"}, {"oid": "e36f5a07644ed56787b29a7f4af5c37131d9bf01", "url": "https://github.com/PatchworkMC/patchwork-api/commit/e36f5a07644ed56787b29a7f4af5c37131d9bf01", "message": "resolve collision", "committedDate": "2020-07-03T20:29:28Z", "type": "commit"}, {"oid": "5c29842cbedf93f3ef4cf13d38f18f6cac1e1a62", "url": "https://github.com/PatchworkMC/patchwork-api/commit/5c29842cbedf93f3ef4cf13d38f18f6cac1e1a62", "message": "resolve collision", "committedDate": "2020-07-03T20:31:07Z", "type": "commit"}, {"oid": "d1be8a8fb1745cbcc3a9c27afae17ec297ca6458", "url": "https://github.com/PatchworkMC/patchwork-api/commit/d1be8a8fb1745cbcc3a9c27afae17ec297ca6458", "message": "resolve collision, last time a wrong file was edited", "committedDate": "2020-07-03T20:34:49Z", "type": "commit"}]}