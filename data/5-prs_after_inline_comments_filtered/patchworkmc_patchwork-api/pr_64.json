{"pr_number": 64, "pr_title": "Feature/iforgeblock", "pr_createdAt": "2020-05-05T13:08:17Z", "pr_url": "https://github.com/PatchworkMC/patchwork-api/pull/64", "timeline": [{"oid": "9d6542c2dc4b30facb0a76c0d58b194d4eb3d4c7", "url": "https://github.com/PatchworkMC/patchwork-api/commit/9d6542c2dc4b30facb0a76c0d58b194d4eb3d4c7", "message": "patchwork-extensions-block created. listed calls in IForgeBlock", "committedDate": "2020-04-11T22:05:58Z", "type": "commit"}, {"oid": "37775b43969983923e067011b3854ab7dc77440a", "url": "https://github.com/PatchworkMC/patchwork-api/commit/37775b43969983923e067011b3854ab7dc77440a", "message": "fix some javadoc errors, remove MCP, add proper links", "committedDate": "2020-04-12T00:46:48Z", "type": "commit"}, {"oid": "9ca906168370ea9af7bae7b031e02083faebced6", "url": "https://github.com/PatchworkMC/patchwork-api/commit/9ca906168370ea9af7bae7b031e02083faebced6", "message": "more javadoc cleanup", "committedDate": "2020-04-12T13:45:14Z", "type": "commit"}, {"oid": "eb5a18921a2fe352f93a31f0a0219fdc33e6be70", "url": "https://github.com/PatchworkMC/patchwork-api/commit/eb5a18921a2fe352f93a31f0a0219fdc33e6be70", "message": "fix license on BlockTagsAccessor", "committedDate": "2020-05-05T12:57:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI2NDk1NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/64#discussion_r420264955", "bodyText": "This looks unused?", "author": "coderbot16", "createdAt": "2020-05-05T17:00:24Z", "path": "patchwork-extensions-block/src/main/java/net/patchworkmc/mixin/extensions/block/MixinBlock.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\r\n+ * Minecraft Forge, Patchwork Project\r\n+ * Copyright (c) 2016-2020, 2019-2020\r\n+ *\r\n+ * This library is free software; you can redistribute it and/or\r\n+ * modify it under the terms of the GNU Lesser General Public\r\n+ * License as published by the Free Software Foundation version 2.1\r\n+ * of the License.\r\n+ *\r\n+ * This library is distributed in the hope that it will be useful,\r\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+ * Lesser General Public License for more details.\r\n+ *\r\n+ * You should have received a copy of the GNU Lesser General Public\r\n+ * License along with this library; if not, write to the Free Software\r\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n+ */\r\n+\r\n+package net.patchworkmc.mixin.extensions.block;\r\n+\r\n+import java.util.HashSet;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.spongepowered.asm.mixin.Final;\r\n+import org.spongepowered.asm.mixin.Mixin;\r\n+import org.spongepowered.asm.mixin.Shadow;\r\n+import org.spongepowered.asm.mixin.Unique;\r\n+import net.minecraftforge.common.extensions.IForgeBlock;\r\n+\r\n+import net.minecraft.block.Block;\r\n+import net.minecraft.block.BlockState;\r\n+import net.minecraft.entity.Entity;\r\n+import net.minecraft.tag.BlockTags;\r\n+import net.minecraft.tag.Tag;\r\n+import net.minecraft.util.Identifier;\r\n+import net.minecraft.util.math.BlockPos;\r\n+import net.minecraft.world.CollisionView;\r\n+\r\n+@Mixin(Block.class)\r\n+public class MixinBlock implements IForgeBlock {\r\n+\t@Shadow\r\n+\t@Final\r\n+\tprivate float slipperiness;\r\n+\t@Shadow\r\n+\t@Final\r\n+\tprivate int harvestLevel;\r", "originalCommit": "eb5a18921a2fe352f93a31f0a0219fdc33e6be70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyODgzMQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/64#discussion_r420428831", "bodyText": "Many block classes override methods here, those should probably be documented too!", "author": "coderbot16", "createdAt": "2020-05-05T21:52:35Z", "path": "patchwork-extensions-block/src/main/java/net/minecraftforge/common/extensions/IForgeBlock.java", "diffHunk": "@@ -0,0 +1,1069 @@\n+/*\r\n+ * Minecraft Forge, Patchwork Project\r\n+ * Copyright (c) 2016-2020, 2019-2020\r\n+ *\r\n+ * This library is free software; you can redistribute it and/or\r\n+ * modify it under the terms of the GNU Lesser General Public\r\n+ * License as published by the Free Software Foundation version 2.1\r\n+ * of the License.\r\n+ *\r\n+ * This library is distributed in the hope that it will be useful,\r\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+ * Lesser General Public License for more details.\r\n+ *\r\n+ * You should have received a copy of the GNU Lesser General Public\r\n+ * License along with this library; if not, write to the Free Software\r\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n+ */\r\n+\r\n+package net.minecraftforge.common.extensions;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Optional;\r\n+import java.util.Set;\r\n+import java.util.function.Predicate;\r\n+\r\n+import javax.annotation.Nullable;\r\n+\r\n+import net.minecraft.block.BedBlock;\r\n+import net.minecraft.block.Block;\r\n+import net.minecraft.block.BlockEntityProvider;\r\n+import net.minecraft.block.BlockState;\r\n+import net.minecraft.block.Blocks;\r\n+import net.minecraft.block.FarmlandBlock;\r\n+import net.minecraft.block.FenceGateBlock;\r\n+import net.minecraft.block.HorizontalFacingBlock;\r\n+import net.minecraft.block.Material;\r\n+import net.minecraft.block.Stainable;\r\n+import net.minecraft.block.entity.BlockEntity;\r\n+import net.minecraft.block.enums.BedPart;\r\n+import net.minecraft.client.particle.ParticleManager;\r\n+import net.minecraft.client.render.RenderLayer;\r\n+import net.minecraft.enchantment.EnchantmentHelper;\r\n+import net.minecraft.entity.Entity;\r\n+import net.minecraft.entity.EntityType;\r\n+import net.minecraft.entity.LivingEntity;\r\n+import net.minecraft.entity.SpawnRestriction;\r\n+import net.minecraft.entity.ai.pathing.PathNodeType;\r\n+import net.minecraft.entity.boss.WitherEntity;\r\n+import net.minecraft.entity.boss.dragon.EnderDragonEntity;\r\n+import net.minecraft.entity.effect.StatusEffects;\r\n+import net.minecraft.entity.mob.MobEntity;\r\n+import net.minecraft.entity.player.PlayerEntity;\r\n+import net.minecraft.entity.projectile.WitherSkullEntity;\r\n+import net.minecraft.fluid.FluidState;\r\n+import net.minecraft.item.ItemStack;\r\n+import net.minecraft.server.world.ServerWorld;\r\n+import net.minecraft.sound.BlockSoundGroup;\r\n+import net.minecraft.state.property.Property;\r\n+import net.minecraft.tag.BlockTags;\r\n+import net.minecraft.util.BlockRotation;\r\n+import net.minecraft.util.DyeColor;\r\n+import net.minecraft.util.Hand;\r\n+import net.minecraft.util.Identifier;\r\n+import net.minecraft.util.hit.HitResult;\r\n+import net.minecraft.util.math.BlockPos;\r\n+import net.minecraft.util.math.Direction;\r\n+import net.minecraft.util.math.Vec3d;\r\n+import net.minecraft.world.BlockRenderView;\r\n+import net.minecraft.world.BlockView;\r\n+import net.minecraft.world.CollisionView;\r\n+import net.minecraft.world.IWorld;\r\n+import net.minecraft.world.ModifiableWorld;\r\n+import net.minecraft.world.World;\r\n+import net.minecraft.world.dimension.TheEndDimension;\r\n+import net.minecraft.world.explosion.Explosion;\r\n+\r\n+import net.fabricmc.api.EnvType;\r\n+import net.fabricmc.api.Environment;\r\n+\r\n+import net.patchworkmc.mixin.extensions.block.FireBlockAccessor;\r\n+\r\n+public interface IForgeBlock {\r", "originalCommit": "eb5a18921a2fe352f93a31f0a0219fdc33e6be70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc3MDA5Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/64#discussion_r421770096", "bodyText": "I'm not really sure how to do that without, uh, manually checking every single block class, which I'm definitely not doing.", "author": "TwilightFlower", "createdAt": "2020-05-07T20:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyODgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4ODcyNg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/64#discussion_r421888726", "bodyText": "It's not too difficult to hunt those down (Especially in IDEA) when doing the patches so it shouldn't be a show-stopper for this PR.", "author": "TheGlitch76", "createdAt": "2020-05-08T01:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyODgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyOTE2OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/64#discussion_r420429168", "bodyText": "This can be moved to a BedBlock mixin probably", "author": "coderbot16", "createdAt": "2020-05-05T21:53:20Z", "path": "patchwork-extensions-block/src/main/java/net/minecraftforge/common/extensions/IForgeBlock.java", "diffHunk": "@@ -0,0 +1,1069 @@\n+/*\r\n+ * Minecraft Forge, Patchwork Project\r\n+ * Copyright (c) 2016-2020, 2019-2020\r\n+ *\r\n+ * This library is free software; you can redistribute it and/or\r\n+ * modify it under the terms of the GNU Lesser General Public\r\n+ * License as published by the Free Software Foundation version 2.1\r\n+ * of the License.\r\n+ *\r\n+ * This library is distributed in the hope that it will be useful,\r\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+ * Lesser General Public License for more details.\r\n+ *\r\n+ * You should have received a copy of the GNU Lesser General Public\r\n+ * License along with this library; if not, write to the Free Software\r\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n+ */\r\n+\r\n+package net.minecraftforge.common.extensions;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Optional;\r\n+import java.util.Set;\r\n+import java.util.function.Predicate;\r\n+\r\n+import javax.annotation.Nullable;\r\n+\r\n+import net.minecraft.block.BedBlock;\r\n+import net.minecraft.block.Block;\r\n+import net.minecraft.block.BlockEntityProvider;\r\n+import net.minecraft.block.BlockState;\r\n+import net.minecraft.block.Blocks;\r\n+import net.minecraft.block.FarmlandBlock;\r\n+import net.minecraft.block.FenceGateBlock;\r\n+import net.minecraft.block.HorizontalFacingBlock;\r\n+import net.minecraft.block.Material;\r\n+import net.minecraft.block.Stainable;\r\n+import net.minecraft.block.entity.BlockEntity;\r\n+import net.minecraft.block.enums.BedPart;\r\n+import net.minecraft.client.particle.ParticleManager;\r\n+import net.minecraft.client.render.RenderLayer;\r\n+import net.minecraft.enchantment.EnchantmentHelper;\r\n+import net.minecraft.entity.Entity;\r\n+import net.minecraft.entity.EntityType;\r\n+import net.minecraft.entity.LivingEntity;\r\n+import net.minecraft.entity.SpawnRestriction;\r\n+import net.minecraft.entity.ai.pathing.PathNodeType;\r\n+import net.minecraft.entity.boss.WitherEntity;\r\n+import net.minecraft.entity.boss.dragon.EnderDragonEntity;\r\n+import net.minecraft.entity.effect.StatusEffects;\r\n+import net.minecraft.entity.mob.MobEntity;\r\n+import net.minecraft.entity.player.PlayerEntity;\r\n+import net.minecraft.entity.projectile.WitherSkullEntity;\r\n+import net.minecraft.fluid.FluidState;\r\n+import net.minecraft.item.ItemStack;\r\n+import net.minecraft.server.world.ServerWorld;\r\n+import net.minecraft.sound.BlockSoundGroup;\r\n+import net.minecraft.state.property.Property;\r\n+import net.minecraft.tag.BlockTags;\r\n+import net.minecraft.util.BlockRotation;\r\n+import net.minecraft.util.DyeColor;\r\n+import net.minecraft.util.Hand;\r\n+import net.minecraft.util.Identifier;\r\n+import net.minecraft.util.hit.HitResult;\r\n+import net.minecraft.util.math.BlockPos;\r\n+import net.minecraft.util.math.Direction;\r\n+import net.minecraft.util.math.Vec3d;\r\n+import net.minecraft.world.BlockRenderView;\r\n+import net.minecraft.world.BlockView;\r\n+import net.minecraft.world.CollisionView;\r\n+import net.minecraft.world.IWorld;\r\n+import net.minecraft.world.ModifiableWorld;\r\n+import net.minecraft.world.World;\r\n+import net.minecraft.world.dimension.TheEndDimension;\r\n+import net.minecraft.world.explosion.Explosion;\r\n+\r\n+import net.fabricmc.api.EnvType;\r\n+import net.fabricmc.api.Environment;\r\n+\r\n+import net.patchworkmc.mixin.extensions.block.FireBlockAccessor;\r\n+\r\n+public interface IForgeBlock {\r\n+\tdefault Block getBlock() {\r\n+\t\treturn (Block) this;\r\n+\t}\r\n+\r\n+\t// Asterisks indicate IForgeBlockState calls. All methods can be assumed to be called from IForgeBlockState.\r\n+\r\n+\t// TODO Call locations: Patches: FlyingEntity*, LivingEntity*, BoatEntity*, ExperienceOrbEntity*, ItemEntity*\r\n+\t/**\r\n+\t * Gets the slipperiness at the given location at the given state. Normally\r\n+\t * between 0 and 1.\r\n+\t *\r\n+\t * <p>Note that entities may reduce slipperiness by a certain factor of their own;\r\n+\t * for {@link LivingEntity}, this is {@code .91}.\r\n+\t * {@link net.minecraft.entity.ItemEntity} uses {@code .98}, and\r\n+\t * {@link net.minecraft.entity.projectile.FishingBobberEntity} uses {@code .92}.\r\n+\t *\r\n+\t * @param state  state of the block\r\n+\t * @param world  the world\r\n+\t * @param pos    the position in the world\r\n+\t * @param entity the entity in question\r\n+\t * @return the factor by which the entity's motion should be multiplied\r\n+\t */\r\n+\tfloat getSlipperiness(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity entity);\r\n+\r\n+\t// TODO Call locations: Patches: Block*, BlockModelRenderer*, World*, Chunk*\r\n+\t/**\r\n+\t * Get a light value for this block, taking into account the given state and coordinates, normal ranges are between 0 and 15.\r\n+\t *\r\n+\t * @param state\r\n+\t * @param world\r\n+\t * @param pos\r\n+\t * @return The light value\r\n+\t */\r\n+\tdefault int getLightValue(BlockState state, BlockRenderView world, BlockPos pos) {\r\n+\t\treturn state.getLuminance();\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Forge classes: ForgeHooks* (called in LivingEntity patch)\r\n+\t/**\r\n+\t * Checks if a player or entity can use this block to 'climb' like a ladder.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param world  The current world\r\n+\t * @param pos    Block position in world\r\n+\t * @param entity The entity trying to use the ladder, CAN be null.\r\n+\t * @return True if the block should act like a ladder\r\n+\t */\r\n+\tdefault boolean isLadder(BlockState state, CollisionView world, BlockPos pos, LivingEntity entity) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * note: do not bother implementing hooks, deprecated for removal in 1.15\r\n+\t * Check if the face of a block should block rendering.\r\n+\t *\r\n+\t * <p>Faces which are fully opaque should return true, faces with transparency\r\n+\t * or faces which do not span the full size of the block should return false.\r\n+\t *\r\n+\t * @param state The current block state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @param face  The side to check\r\n+\t * @return True if the block is opaque on the specified side.\r\n+\t * @deprecated This is no longer used for rendering logic.\r\n+\t */\r\n+\t@Deprecated\r\n+\tdefault boolean doesSideBlockRendering(BlockState state, BlockRenderView world, BlockPos pos, Direction face) {\r\n+\t\treturn state.isFullOpaque(world, pos);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: World*\r\n+\t/**\r\n+\t * Determines if this block should set fire and deal fire damage\r\n+\t * to entities coming into contact with it.\r\n+\t *\r\n+\t * @param state The current block state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return True if the block should deal damage\r\n+\t */\r\n+\tdefault boolean isBurning(BlockState state, BlockView world, BlockPos pos) {\r\n+\t\treturn this == Blocks.FIRE || this == Blocks.LAVA;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: Block, Block*, PistonBlock*, RepeaterBlock*, WorldRenderer*, ChunkRenderer*, BlockArgumentParser*, FallingBlockEntity*, ChestBlockEntity*, HopperBlockEntity*, Explosion*, World*, WorldChunk*, ChunkRegion*, ChunkHolder*, Forge classes: ForgeHooks, FluidUtil, ForgeHooks*, VanillaInventoryCodeHooks*\r\n+\t/**\r\n+\t * Called throughout the code as a replacement for {@code block instanceof} {@link BlockEntityProvider}.\r\n+\t * Allows for blocks to have a block entity conditionally based on block state.\r\n+\t *\r\n+\t * <p>Return true from this function to specify this block has a block entity.\r\n+\t *\r\n+\t * @param state State of the current block\r\n+\t * @return True if block has a block entity, false otherwise\r\n+\t */\r\n+\tdefault boolean hasTileEntity(BlockState state) {\r\n+\t\treturn this instanceof BlockEntityProvider;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: WorldChunk*, ChunkRegion*\r\n+\t/**\r\n+\t * Called throughout the code as a replacement for {@link BlockEntityProvider#createBlockEntity(BlockView)}\r\n+\t * Return the same thing you would from that function.\r\n+\t * This will fall back to {@link BlockEntityProvider#createBlockEntity(BlockView)} if this block is a {@link BlockEntityProvider}\r\n+\t *\r\n+\t * @param state The state of the current block\r\n+\t * @param world The world to create the BE in\r\n+\t * @return An instance of a class extending {@link BlockEntity}\r\n+\t */\r\n+\t@Nullable\r\n+\tdefault BlockEntity createTileEntity(BlockState state, BlockView world) {\r\n+\t\tif (getBlock() instanceof BlockEntityProvider) {\r\n+\t\t\treturn ((BlockEntityProvider) getBlock()).createBlockEntity(world);\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/* TODO IForgeBlock#canHarvestBlock indirectly requires ToolType (via ForgeHooks#canHarvestBlock)\r\n+\t/**\r\n+\t * Determines if the player can harvest this block, obtaining it's drops when the block is destroyed.\r\n+\t *\r\n+\t * @param world  The current world\r\n+\t * @param pos    The block's current position\r\n+\t * @param player The player damaging the block\r\n+\t * @return True to spawn the drops\r\n+\t *\r\n+\tdefault boolean canHarvestBlock(BlockState state, BlockView world, BlockPos pos, PlayerEntity player) {\r\n+\t\treturn ForgeHooks.canHarvestBlock(state, player, world, pos);\r\n+\t}*/\r\n+\r\n+\t// TODO Call locations: Patches: ServerPlayerInteractionManager*\r\n+\t/**\r\n+\t * Called when a player removes a block.  This is responsible for\r\n+\t * actually destroying the block, and the block is intact at time of call.\r\n+\t * This is called regardless of whether the player can harvest the block or\r\n+\t * not.\r\n+\t *\r\n+\t * <p>Return true if the block is actually destroyed.\r\n+\t *\r\n+\t * <p>Note: When used in multiplayer, this is called on both client and\r\n+\t * server sides!\r\n+\t *\r\n+\t * @param state       The current state.\r\n+\t * @param world       The current world\r\n+\t * @param pos         Block position in world\r\n+\t * @param player      The player damaging the block, may be null\r\n+\t * @param willHarvest True if {@link Block#onBroken(IWorld, BlockPos, BlockState)} will be called after this if this method returns true.\r\n+\t *                    Can be useful to delay the destruction of block entities till after onBroken\r\n+\t * @param fluid       The current fluid state at current position\r\n+\t * @return True if the block is actually destroyed.\r\n+\t */\r\n+\tdefault boolean removedByPlayer(BlockState state, World world, BlockPos pos, PlayerEntity player, boolean willHarvest, FluidState fluid) {\r\n+\t\tgetBlock().onBreak(world, pos, state, player);\r\n+\t\treturn world.removeBlock(pos, false);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: LivingEntity*, PlayerEntity*, Forge classes: ForgeEventFactory (called from LivingEntity patch)\r\n+\t/**\r\n+\t * Determines if this block is classified as a Bed, Allowing\r\n+\t * players to sleep in it, though the block has to specifically\r\n+\t * perform the sleeping functionality in it's activated event.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param world  The current world\r\n+\t * @param pos    Block position in world\r\n+\t * @param player The player or camera entity, null in some cases.\r\n+\t * @return True to treat this as a bed\r\n+\t */\r\n+\tdefault boolean isBed(BlockState state, BlockView world, BlockPos pos, @Nullable Entity player) {\r\n+\t\treturn this.getBlock() instanceof BedBlock;\r", "originalCommit": "eb5a18921a2fe352f93a31f0a0219fdc33e6be70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMjc0Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/64#discussion_r420432743", "bodyText": "This variable should probably be named something else. Maybe visibility? Respiration and Water Breathing appear to result in higher values.", "author": "coderbot16", "createdAt": "2020-05-05T22:01:03Z", "path": "patchwork-extensions-block/src/main/java/net/minecraftforge/common/extensions/IForgeBlock.java", "diffHunk": "@@ -0,0 +1,1069 @@\n+/*\r\n+ * Minecraft Forge, Patchwork Project\r\n+ * Copyright (c) 2016-2020, 2019-2020\r\n+ *\r\n+ * This library is free software; you can redistribute it and/or\r\n+ * modify it under the terms of the GNU Lesser General Public\r\n+ * License as published by the Free Software Foundation version 2.1\r\n+ * of the License.\r\n+ *\r\n+ * This library is distributed in the hope that it will be useful,\r\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+ * Lesser General Public License for more details.\r\n+ *\r\n+ * You should have received a copy of the GNU Lesser General Public\r\n+ * License along with this library; if not, write to the Free Software\r\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n+ */\r\n+\r\n+package net.minecraftforge.common.extensions;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.Optional;\r\n+import java.util.Set;\r\n+import java.util.function.Predicate;\r\n+\r\n+import javax.annotation.Nullable;\r\n+\r\n+import net.minecraft.block.BedBlock;\r\n+import net.minecraft.block.Block;\r\n+import net.minecraft.block.BlockEntityProvider;\r\n+import net.minecraft.block.BlockState;\r\n+import net.minecraft.block.Blocks;\r\n+import net.minecraft.block.FarmlandBlock;\r\n+import net.minecraft.block.FenceGateBlock;\r\n+import net.minecraft.block.HorizontalFacingBlock;\r\n+import net.minecraft.block.Material;\r\n+import net.minecraft.block.Stainable;\r\n+import net.minecraft.block.entity.BlockEntity;\r\n+import net.minecraft.block.enums.BedPart;\r\n+import net.minecraft.client.particle.ParticleManager;\r\n+import net.minecraft.client.render.RenderLayer;\r\n+import net.minecraft.enchantment.EnchantmentHelper;\r\n+import net.minecraft.entity.Entity;\r\n+import net.minecraft.entity.EntityType;\r\n+import net.minecraft.entity.LivingEntity;\r\n+import net.minecraft.entity.SpawnRestriction;\r\n+import net.minecraft.entity.ai.pathing.PathNodeType;\r\n+import net.minecraft.entity.boss.WitherEntity;\r\n+import net.minecraft.entity.boss.dragon.EnderDragonEntity;\r\n+import net.minecraft.entity.effect.StatusEffects;\r\n+import net.minecraft.entity.mob.MobEntity;\r\n+import net.minecraft.entity.player.PlayerEntity;\r\n+import net.minecraft.entity.projectile.WitherSkullEntity;\r\n+import net.minecraft.fluid.FluidState;\r\n+import net.minecraft.item.ItemStack;\r\n+import net.minecraft.server.world.ServerWorld;\r\n+import net.minecraft.sound.BlockSoundGroup;\r\n+import net.minecraft.state.property.Property;\r\n+import net.minecraft.tag.BlockTags;\r\n+import net.minecraft.util.BlockRotation;\r\n+import net.minecraft.util.DyeColor;\r\n+import net.minecraft.util.Hand;\r\n+import net.minecraft.util.Identifier;\r\n+import net.minecraft.util.hit.HitResult;\r\n+import net.minecraft.util.math.BlockPos;\r\n+import net.minecraft.util.math.Direction;\r\n+import net.minecraft.util.math.Vec3d;\r\n+import net.minecraft.world.BlockRenderView;\r\n+import net.minecraft.world.BlockView;\r\n+import net.minecraft.world.CollisionView;\r\n+import net.minecraft.world.IWorld;\r\n+import net.minecraft.world.ModifiableWorld;\r\n+import net.minecraft.world.World;\r\n+import net.minecraft.world.dimension.TheEndDimension;\r\n+import net.minecraft.world.explosion.Explosion;\r\n+\r\n+import net.fabricmc.api.EnvType;\r\n+import net.fabricmc.api.Environment;\r\n+\r\n+import net.patchworkmc.mixin.extensions.block.FireBlockAccessor;\r\n+\r\n+public interface IForgeBlock {\r\n+\tdefault Block getBlock() {\r\n+\t\treturn (Block) this;\r\n+\t}\r\n+\r\n+\t// Asterisks indicate IForgeBlockState calls. All methods can be assumed to be called from IForgeBlockState.\r\n+\r\n+\t// TODO Call locations: Patches: FlyingEntity*, LivingEntity*, BoatEntity*, ExperienceOrbEntity*, ItemEntity*\r\n+\t/**\r\n+\t * Gets the slipperiness at the given location at the given state. Normally\r\n+\t * between 0 and 1.\r\n+\t *\r\n+\t * <p>Note that entities may reduce slipperiness by a certain factor of their own;\r\n+\t * for {@link LivingEntity}, this is {@code .91}.\r\n+\t * {@link net.minecraft.entity.ItemEntity} uses {@code .98}, and\r\n+\t * {@link net.minecraft.entity.projectile.FishingBobberEntity} uses {@code .92}.\r\n+\t *\r\n+\t * @param state  state of the block\r\n+\t * @param world  the world\r\n+\t * @param pos    the position in the world\r\n+\t * @param entity the entity in question\r\n+\t * @return the factor by which the entity's motion should be multiplied\r\n+\t */\r\n+\tfloat getSlipperiness(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity entity);\r\n+\r\n+\t// TODO Call locations: Patches: Block*, BlockModelRenderer*, World*, Chunk*\r\n+\t/**\r\n+\t * Get a light value for this block, taking into account the given state and coordinates, normal ranges are between 0 and 15.\r\n+\t *\r\n+\t * @param state\r\n+\t * @param world\r\n+\t * @param pos\r\n+\t * @return The light value\r\n+\t */\r\n+\tdefault int getLightValue(BlockState state, BlockRenderView world, BlockPos pos) {\r\n+\t\treturn state.getLuminance();\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Forge classes: ForgeHooks* (called in LivingEntity patch)\r\n+\t/**\r\n+\t * Checks if a player or entity can use this block to 'climb' like a ladder.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param world  The current world\r\n+\t * @param pos    Block position in world\r\n+\t * @param entity The entity trying to use the ladder, CAN be null.\r\n+\t * @return True if the block should act like a ladder\r\n+\t */\r\n+\tdefault boolean isLadder(BlockState state, CollisionView world, BlockPos pos, LivingEntity entity) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * note: do not bother implementing hooks, deprecated for removal in 1.15\r\n+\t * Check if the face of a block should block rendering.\r\n+\t *\r\n+\t * <p>Faces which are fully opaque should return true, faces with transparency\r\n+\t * or faces which do not span the full size of the block should return false.\r\n+\t *\r\n+\t * @param state The current block state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @param face  The side to check\r\n+\t * @return True if the block is opaque on the specified side.\r\n+\t * @deprecated This is no longer used for rendering logic.\r\n+\t */\r\n+\t@Deprecated\r\n+\tdefault boolean doesSideBlockRendering(BlockState state, BlockRenderView world, BlockPos pos, Direction face) {\r\n+\t\treturn state.isFullOpaque(world, pos);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: World*\r\n+\t/**\r\n+\t * Determines if this block should set fire and deal fire damage\r\n+\t * to entities coming into contact with it.\r\n+\t *\r\n+\t * @param state The current block state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return True if the block should deal damage\r\n+\t */\r\n+\tdefault boolean isBurning(BlockState state, BlockView world, BlockPos pos) {\r\n+\t\treturn this == Blocks.FIRE || this == Blocks.LAVA;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: Block, Block*, PistonBlock*, RepeaterBlock*, WorldRenderer*, ChunkRenderer*, BlockArgumentParser*, FallingBlockEntity*, ChestBlockEntity*, HopperBlockEntity*, Explosion*, World*, WorldChunk*, ChunkRegion*, ChunkHolder*, Forge classes: ForgeHooks, FluidUtil, ForgeHooks*, VanillaInventoryCodeHooks*\r\n+\t/**\r\n+\t * Called throughout the code as a replacement for {@code block instanceof} {@link BlockEntityProvider}.\r\n+\t * Allows for blocks to have a block entity conditionally based on block state.\r\n+\t *\r\n+\t * <p>Return true from this function to specify this block has a block entity.\r\n+\t *\r\n+\t * @param state State of the current block\r\n+\t * @return True if block has a block entity, false otherwise\r\n+\t */\r\n+\tdefault boolean hasTileEntity(BlockState state) {\r\n+\t\treturn this instanceof BlockEntityProvider;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: WorldChunk*, ChunkRegion*\r\n+\t/**\r\n+\t * Called throughout the code as a replacement for {@link BlockEntityProvider#createBlockEntity(BlockView)}\r\n+\t * Return the same thing you would from that function.\r\n+\t * This will fall back to {@link BlockEntityProvider#createBlockEntity(BlockView)} if this block is a {@link BlockEntityProvider}\r\n+\t *\r\n+\t * @param state The state of the current block\r\n+\t * @param world The world to create the BE in\r\n+\t * @return An instance of a class extending {@link BlockEntity}\r\n+\t */\r\n+\t@Nullable\r\n+\tdefault BlockEntity createTileEntity(BlockState state, BlockView world) {\r\n+\t\tif (getBlock() instanceof BlockEntityProvider) {\r\n+\t\t\treturn ((BlockEntityProvider) getBlock()).createBlockEntity(world);\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t/* TODO IForgeBlock#canHarvestBlock indirectly requires ToolType (via ForgeHooks#canHarvestBlock)\r\n+\t/**\r\n+\t * Determines if the player can harvest this block, obtaining it's drops when the block is destroyed.\r\n+\t *\r\n+\t * @param world  The current world\r\n+\t * @param pos    The block's current position\r\n+\t * @param player The player damaging the block\r\n+\t * @return True to spawn the drops\r\n+\t *\r\n+\tdefault boolean canHarvestBlock(BlockState state, BlockView world, BlockPos pos, PlayerEntity player) {\r\n+\t\treturn ForgeHooks.canHarvestBlock(state, player, world, pos);\r\n+\t}*/\r\n+\r\n+\t// TODO Call locations: Patches: ServerPlayerInteractionManager*\r\n+\t/**\r\n+\t * Called when a player removes a block.  This is responsible for\r\n+\t * actually destroying the block, and the block is intact at time of call.\r\n+\t * This is called regardless of whether the player can harvest the block or\r\n+\t * not.\r\n+\t *\r\n+\t * <p>Return true if the block is actually destroyed.\r\n+\t *\r\n+\t * <p>Note: When used in multiplayer, this is called on both client and\r\n+\t * server sides!\r\n+\t *\r\n+\t * @param state       The current state.\r\n+\t * @param world       The current world\r\n+\t * @param pos         Block position in world\r\n+\t * @param player      The player damaging the block, may be null\r\n+\t * @param willHarvest True if {@link Block#onBroken(IWorld, BlockPos, BlockState)} will be called after this if this method returns true.\r\n+\t *                    Can be useful to delay the destruction of block entities till after onBroken\r\n+\t * @param fluid       The current fluid state at current position\r\n+\t * @return True if the block is actually destroyed.\r\n+\t */\r\n+\tdefault boolean removedByPlayer(BlockState state, World world, BlockPos pos, PlayerEntity player, boolean willHarvest, FluidState fluid) {\r\n+\t\tgetBlock().onBreak(world, pos, state, player);\r\n+\t\treturn world.removeBlock(pos, false);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: LivingEntity*, PlayerEntity*, Forge classes: ForgeEventFactory (called from LivingEntity patch)\r\n+\t/**\r\n+\t * Determines if this block is classified as a Bed, Allowing\r\n+\t * players to sleep in it, though the block has to specifically\r\n+\t * perform the sleeping functionality in it's activated event.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param world  The current world\r\n+\t * @param pos    Block position in world\r\n+\t * @param player The player or camera entity, null in some cases.\r\n+\t * @return True to treat this as a bed\r\n+\t */\r\n+\tdefault boolean isBed(BlockState state, BlockView world, BlockPos pos, @Nullable Entity player) {\r\n+\t\treturn this.getBlock() instanceof BedBlock;\r\n+\t}\r\n+\r\n+\t//TODO Call locations: Patches: SpawnHelper*\r\n+\t/**\r\n+\t * Determines if a specified mob type can spawn on this block, returning false will\r\n+\t * prevent any mob from spawning on the block.\r\n+\t *\r\n+\t * @param state        The current state\r\n+\t * @param world        The current world\r\n+\t * @param pos          Block position in world\r\n+\t * @param restriction  The location spawn restriction\r\n+\t * @param entityType   The type of entity attempting to spawn\r\n+\t * @return True to allow a mob of the specified category to spawn, false to prevent it.\r\n+\t */\r\n+\tdefault boolean canCreatureSpawn(BlockState state, BlockView world, BlockPos pos, SpawnRestriction.Location restriction, @Nullable EntityType<?> entityType) {\r\n+\t\treturn state.allowsSpawning(world, pos, entityType);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: LivingEntity*, PlayerEntity*\r\n+\t/**\r\n+\t * Returns the position that the sleeper is moved to upon\r\n+\t * waking up, or respawning at the bed.\r\n+\t *\r\n+\t * @param entityType the sleeper's entity type\r\n+\t * @param state      The current state\r\n+\t * @param world      The current world\r\n+\t * @param pos        Block position in world\r\n+\t * @param sleeper    The sleeper or camera entity, null in some cases.\r\n+\t * @return The spawn position\r\n+\t */\r\n+\tdefault Optional<Vec3d> getBedSpawnPosition(EntityType<?> entityType, BlockState state, CollisionView world, BlockPos pos, @Nullable LivingEntity sleeper) {\r\n+\t\tif (world instanceof World) {\r\n+\t\t\treturn BedBlock.findWakeUpPosition(entityType, world, pos, 0);\r\n+\t\t}\r\n+\r\n+\t\treturn Optional.empty();\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: LivingEntity*\r\n+\t/**\r\n+\t * Called when a user either starts or stops sleeping in the bed.\r\n+\t *\r\n+\t * @param state    The current state\r\n+\t * @param world    The current world\r\n+\t * @param pos      Block position in world\r\n+\t * @param sleeper  The sleeper or camera entity, null in some cases.\r\n+\t * @param occupied True if we are occupying the bed, or false if they are stopping use of the bed\r\n+\t */\r\n+\tdefault void setBedOccupied(BlockState state, CollisionView world, BlockPos pos, LivingEntity sleeper, boolean occupied) {\r\n+\t\tif (world instanceof ModifiableWorld) {\r\n+\t\t\t((ModifiableWorld) world).setBlockState(pos, state.with(BedBlock.OCCUPIED, occupied), 4);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: LivingEntity*\r\n+\t/**\r\n+\t * Returns the direction of the block. Same values that\r\n+\t * are returned by {@link net.minecraft.block.FacingBlock}. Called every frame tick for every living entity. Be VERY fast.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return Bed direction\r\n+\t */\r\n+\tdefault Direction getBedDirection(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t\treturn state.get(HorizontalFacingBlock.FACING);\r\n+\t}\r\n+\r\n+\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\r\n+\t/**\r\n+\t * Determines if the current block is the foot half of the bed.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return True if the current block is the foot side of a bed.\r\n+\t */\r\n+\tdefault boolean isBedFoot(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t\treturn state.get(BedBlock.PART) == BedPart.FOOT;\r\n+\t}\r\n+\r\n+\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\r\n+\t/**\r\n+\t * Called when a leaf should start its decay process.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t */\r\n+\tdefault void beginLeaveDecay(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t}\r\n+\r\n+\t// TODO This has 59 calls in patches, which I am not going to list here. Forge classes: FluidAttributes*, ForgeHooks*\r\n+\t/**\r\n+\t * Determines this block should be treated as an air block\r\n+\t * by the rest of the code. This method is primarily\r\n+\t * useful for creating pure logic-blocks that will be invisible\r\n+\t * to the player and otherwise interact as air would.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return True if the block considered air\r\n+\t */\r\n+\tdefault boolean isAir(BlockState state, BlockView world, BlockPos pos) {\r\n+\t\treturn state.getMaterial() == Material.AIR;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: AbstractTreeFeature*, HugeBrownMushroomFeature*, HugeRedMushroomFeature*\r\n+\t/**\r\n+\t * Used during tree growth to determine if newly generated leaves can replace this block.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return true if this block can be replaced by growing leaves.\r\n+\t */\r\n+\tdefault boolean canBeReplacedByLeaves(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t\treturn isAir(state, world, pos) || state.matches(BlockTags.LEAVES);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: AbstractTreeFeature*\r\n+\t/**\r\n+\t * Used during tree growth to determine if newly generated logs can replace this block.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return true if this block can be replaced by growing leaves.\r\n+\t */\r\n+\tdefault boolean canBeReplacedByLogs(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t\treturn (isAir(state, world, pos) || state.matches(BlockTags.LEAVES)) || this == Blocks.GRASS_BLOCK || Block.isNaturalDirt(getBlock())\r\n+\t\t\t\t|| getBlock().matches(BlockTags.LOGS) || getBlock().matches(BlockTags.SAPLINGS) || this == Blocks.VINE;\r\n+\t}\r\n+\r\n+\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\r\n+\t/**\r\n+\t * Determines if the current block is replaceable by ore veins during world generation.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param world  The current world\r\n+\t * @param pos    Block position in world\r\n+\t * @param target The generic target block the gen is looking for, usually stone\r\n+\t *               for overworld generation, and netherrack for the nether.\r\n+\t * @return True to allow this block to be replaced by a ore\r\n+\t */\r\n+\tdefault boolean isReplaceableOreGen(BlockState state, CollisionView world, BlockPos pos, Predicate<BlockState> target) {\r\n+\t\treturn target.test(state);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: Explosion*\r\n+\t/**\r\n+\t * Location sensitive version of getExplosionResistance.\r\n+\t *\r\n+\t * @param state     The current state\r\n+\t * @param world     The current world\r\n+\t * @param pos       Block position in world\r\n+\t * @param exploder  The entity that caused the explosion, can be null\r\n+\t * @param explosion The explosion\r\n+\t * @return The amount of the explosion absorbed.\r\n+\t */\r\n+\tdefault float getExplosionResistance(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity exploder, Explosion explosion) {\r\n+\t\treturn this.getBlock().getBlastResistance();\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: RedstoneWireBlock*\r\n+\t/**\r\n+\t * Determine if this block can make a redstone connection on the side provided,\r\n+\t * Useful to control which sides are inputs and outputs for redstone wires.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @param side  The side that is trying to make the connection, CAN BE NULL\r\n+\t * @return True to make the connection\r\n+\t */\r\n+\tdefault boolean canConnectRedstone(BlockState state, BlockView world, BlockPos pos, @Nullable Direction side) {\r\n+\t\treturn state.emitsRedstonePower() && side != null;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Forge classes: ForgeHooks\r\n+\t/**\r\n+\t * Called when a user uses the creative pick block button on this block.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param target The full target the player is looking at\r\n+\t * @param world  The world the block is in\r\n+\t * @param pos    The block's position\r\n+\t * @param player The player picking the block\r\n+\t * @return An {@link ItemStack} to add to the player's inventory, empty itemstack if nothing should be added.\r\n+\t */\r\n+\tdefault ItemStack getPickBlock(BlockState state, HitResult target, BlockView world, BlockPos pos, PlayerEntity player) {\r\n+\t\treturn this.getBlock().getPickStack(world, pos, state);\r\n+\t}\r\n+\r\n+\t// No call locations.\r\n+\t/**\r\n+\t * Forge javadoc only said where this was used. It isn't used anywhere, so there's really no way to document this.\r\n+\t */\r\n+\tdefault boolean isFoliage(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: LivingEntity*\r\n+\t/**\r\n+\t * Allows a block to override the standard {@link LivingEntity#fall} particles.\r\n+\t * This is a server side method that spawns particles with\r\n+\t * {@link ServerWorld#spawnParticles}\r\n+\t *\r\n+\t * @param state1            This block's state.\r\n+\t * @param serverworld       The {@link ServerWorld} this block is in.\r\n+\t * @param pos               The position of the block.\r\n+\t * @param state2            This block's state, but again.\r\n+\t * @param entity            The entity that landed on the block\r\n+\t * @param numberOfParticles Number of particles the vanilla version of this method would spawn.\r\n+\t * @return True to prevent vanilla landing particles from spawning\r\n+\t */\r\n+\tdefault boolean addLandingEffects(BlockState state1, ServerWorld serverworld, BlockPos pos, BlockState state2, LivingEntity entity, int numberOfParticles) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: Entity*\r\n+\t/**\r\n+\t * Allows a block to override the standard vanilla running particles.\r\n+\t * This is called from {@link Entity#spawnSprintingParticles} and is called both\r\n+\t * client and server side, it's up to the implementor to client check / server check.\r\n+\t * By default vanilla spawns particles only on the client and the server methods no-op.\r\n+\t *\r\n+\t * @param state  The state of this block.\r\n+\t * @param world  The world.\r\n+\t * @param pos    The position at the entity's feet.\r\n+\t * @param entity The entity running on the block.\r\n+\t * @return True to prevent vanilla running particles from spawning.\r\n+\t */\r\n+\tdefault boolean addRunningEffects(BlockState state, World world, BlockPos pos, Entity entity) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: ParticleManager*\r\n+\t/**\r\n+\t * Spawn a digging particle effect in the world, this is a wrapper\r\n+\t * around {@link ParticleManager.addBlockBreakParticles} to allow the block more\r\n+\t * control over the particles.\r\n+\t *\r\n+\t * @param state   The current state\r\n+\t * @param world   The current world\r\n+\t * @param target  The target the player is looking at {x/y/z/side/sub}\r\n+\t * @param manager A reference to the current particle manager.\r\n+\t * @return True to prevent vanilla digging particles form spawning.\r\n+\t */\r\n+\t@Environment(EnvType.CLIENT)\r\n+\tdefault boolean addHitEffects(BlockState state, World worldObj, HitResult target, ParticleManager manager) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: ParticleManager*\r\n+\t/**\r\n+\t * Spawn particles for when the block is destroyed. Due to the nature\r\n+\t * of how this is invoked, the x/y/z locations are not always guaranteed\r\n+\t * to host your block. So be sure to do proper sanity checks before assuming\r\n+\t * that the location is this block.\r\n+\t *\r\n+\t * @param state   This block's state\r\n+\t * @param world   The current world\r\n+\t * @param pos     Position to spawn the particle\r\n+\t * @param manager A reference to the current particle manager.\r\n+\t * @return True to prevent vanilla break particles from spawning.\r\n+\t */\r\n+\t@Environment(EnvType.CLIENT)\r\n+\tdefault boolean addDestroyEffects(BlockState state, World world, BlockPos pos, ParticleManager manager) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t/* TODO IForgeBlock#canSustainPlant requires IPlantable\r\n+\t/**\r\n+\t * Determines if this block can support the passed in plant, allowing it to be planted and grow.\r\n+\t * Some examples:\r\n+\t * Reeds check if its a reed, or if its sand/dirt/grass and adjacent to water\r\n+\t * Cacti checks if its a cacti, or if its sand\r\n+\t * Nether types check for soul sand\r\n+\t * Crops check for tilled soil\r\n+\t * Caves check if it's a solid surface\r\n+\t * Plains check if its grass or dirt\r\n+\t * Water check if its still water\r\n+\t *\r\n+\t * @param state     The Current state\r\n+\t * @param world     The current world\r\n+\t * @param facing    The direction relative to the given position the plant wants to be, typically its UP\r\n+\t * @param plantable The plant that wants to check\r\n+\t * @return True to allow the plant to be planted/stay.\r\n+\t *\r\n+\tboolean canSustainPlant(BlockState state, BlockView world, BlockPos pos, Direction facing, IPlantable plantable);*/\r\n+\r\n+\t// TODO Call locations: Patches: AbstractTreeFeature*\r\n+\t/**\r\n+\t * Called when a plant grows on this block.\r\n+\t * This does not use ForgeDirection, because large/huge trees can be located in non-representable direction,\r\n+\t * so the source location is specified.\r\n+\t * Currently this just changes the block to dirt if it was grass.\r\n+\t *\r\n+\t * <p>Note: This happens DURING the generation, the generation may not be complete when this is called.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param world  Current world\r\n+\t * @param pos    Block position in world\r\n+\t * @param source Source plant's position in world\r\n+\t */\r\n+\tdefault void onPlantGrow(BlockState state, IWorld world, BlockPos pos, BlockPos source) {\r\n+\t\tif (Block.isNaturalDirt(getBlock())) {\r\n+\t\t\tworld.setBlockState(pos, Blocks.DIRT.getDefaultState(), 2);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: CropBlock*\r\n+\t/**\r\n+\t * Checks if this soil is fertile, typically this means that growth rates\r\n+\t * of plants on this soil will be slightly sped up.\r\n+\t * Only vanilla case is tilledField when it is within range of water.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return True if the soil should be considered fertile.\r\n+\t */\r\n+\tdefault boolean isFertile(BlockState state, BlockView world, BlockPos pos) {\r\n+\t\tif (this.getBlock() == Blocks.FARMLAND) {\r\n+\t\t\treturn state.get(FarmlandBlock.MOISTURE) > 0;\r\n+\t\t}\r\n+\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: BeaconBlockEntity*\r\n+\t/**\r\n+\t * Determines if this block can be used as the base of a beacon.\r\n+\t *\r\n+\t * @param state  The current state\r\n+\t * @param world  The current world\r\n+\t * @param pos    Block position in world\r\n+\t * @param beacon Beacon position in world\r\n+\t * @return True, to support the beacon, and make it active with this block.\r\n+\t */\r\n+\tdefault boolean isBeaconBase(BlockState state, CollisionView world, BlockPos pos, BlockPos beacon) {\r\n+\t\t// TODO implement actual tag-based functionality\r\n+\t\treturn this == Blocks.EMERALD_BLOCK || this == Blocks.GOLD_BLOCK || this == Blocks.DIAMOND_BLOCK || this == Blocks.IRON_BLOCK;\r\n+\t\t// return Tags.Blocks.SUPPORTS_BEACON.contains(state.getBlock());\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Forge classes: BreakEvent*\r\n+\t/**\r\n+\t * Gathers how much experience this block drops when broken.\r\n+\t *\r\n+\t * @param state     The current state\r\n+\t * @param world     The world\r\n+\t * @param pos       Block position\r\n+\t * @param fortune   Level of fortune on the breaker's tool\r\n+\t * @param silktouch Level of silk touch on the breaker's tool\r\n+\t * @return Amount of XP from breaking this block.\r\n+\t */\r\n+\tdefault int getExpDrop(BlockState state, CollisionView world, BlockPos pos, int fortune, int silktouch) {\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: PistonBlock\r\n+\tdefault BlockState rotate(BlockState state, IWorld world, BlockPos pos, BlockRotation direction) {\r\n+\t\treturn state.rotate(direction);\r\n+\t}\r\n+\r\n+\t// No call locations\r\n+\t/**\r\n+\t * Get the rotations that can apply to the block at the specified coordinates. Null means no rotations are possible.\r\n+\t * Note, this is up to the block to decide. It may not be accurate or representative.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The world\r\n+\t * @param pos   Block position in world\r\n+\t * @return An array of valid axes to rotate around, or null for none or unknown\r\n+\t */\r\n+\t@Nullable\r\n+\tdefault Direction[] getValidRotations(BlockState state, BlockView world, BlockPos pos) {\r\n+\t\tfor (Property<?> prop : state.getProperties()) {\r\n+\t\t\tif ((prop.getName().equals(\"facing\") || prop.getName().equals(\"rotation\")) && prop.getType() == Direction.class) {\r\n+\t\t\t\t@SuppressWarnings(\"unchecked\")\r\n+\t\t\t\tCollection<Direction> values = ((Collection<Direction>) prop.getValues());\r\n+\t\t\t\treturn values.toArray(new Direction[values.size()]);\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: EnchantingTableBlock*, EnchantingTableContainer*\r\n+\t/**\r\n+\t * Determines the amount of enchanting power this block can provide to an enchanting table.\r\n+\t *\r\n+\t * @param world The world\r\n+\t * @param pos   Block position in world\r\n+\t * @return The amount of enchanting power this block produces.\r\n+\t */\r\n+\tdefault float getEnchantPowerBonus(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t\treturn this.getBlock() == Blocks.BOOKSHELF ? 1 : 0;\r\n+\t}\r\n+\r\n+\t// No call locations.\r\n+\t/**\r\n+\t * Re-colors this block in the world.\r\n+\t *\r\n+\t * @param state   The current state\r\n+\t * @param world   The world\r\n+\t * @param pos     Block position\r\n+\t * @param facing  ??? (this method has no usages)\r\n+\t * @param color   Color to recolor to.\r\n+\t * @return if the block was affected\r\n+\t */\r\n+\t@SuppressWarnings(\"unchecked\")\r\n+\tdefault boolean recolorBlock(BlockState state, IWorld world, BlockPos pos, Direction facing, DyeColor color) {\r\n+\t\tfor (Property<?> prop : state.getProperties()) {\r\n+\t\t\tif (prop.getName().equals(\"color\") && prop.getType() == DyeColor.class) {\r\n+\t\t\t\tDyeColor current = (DyeColor) state.get(prop);\r\n+\r\n+\t\t\t\tif (current != color && prop.getValues().contains(color)) {\r\n+\t\t\t\t\tworld.setBlockState(pos, state.with(((Property<DyeColor>) prop), color), 3);\r\n+\t\t\t\t\treturn true;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: World*\r\n+\t/**\r\n+\t * Called when a block entity on a side of this block changes is created or is destroyed.\r\n+\t *\r\n+\t * @param state    The state of this block\r\n+\t * @param world    The world\r\n+\t * @param pos      Block position in world\r\n+\t * @param neighbor Block position of neighbor\r\n+\t */\r\n+\tdefault void onNeighborChange(BlockState state, CollisionView world, BlockPos pos, BlockPos neighbor) {\r\n+\t}\r\n+\r\n+\t// No call locations.\r\n+\t/**\r\n+\t * Called on an Observer block whenever an update for an Observer is received.\r\n+\t *\r\n+\t * @param observerState   The Observer block's state.\r\n+\t * @param world           The current world.\r\n+\t * @param observerPos     The Observer block's position.\r\n+\t * @param changedBlock    The updated block.\r\n+\t * @param changedBlockPos The updated block's position.\r\n+\t */\r\n+\tdefault void observedNeighborChange(BlockState observerState, World world, BlockPos observerPos, Block changedBlock, BlockPos changedBlockPos) {\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: World*\r\n+\t/**\r\n+\t * Called to determine whether to allow the a block to handle its own indirect power rather than using the default rules.\r\n+\t *\r\n+\t * @param state This block's state\r\n+\t * @param world The world\r\n+\t * @param pos   Block position in world\r\n+\t * @param side  The INPUT side of the block to be powered - ie the opposite of this block's output side\r\n+\t * @return Whether weak power should be checked normally\r\n+\t */\r\n+\tdefault boolean shouldCheckWeakPower(BlockState state, CollisionView world, BlockPos pos, Direction side) {\r\n+\t\treturn state.isSimpleFullBlock(world, pos);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: World*\r\n+\t/**\r\n+\t * If this block should be notified of weak changes.\r\n+\t * Weak changes are changes 1 block away through a solid block.\r\n+\t * Similar to comparators.\r\n+\t *\r\n+\t * @param state The current state\r\n+\t * @param world The current world\r\n+\t * @param pos   Block position in world\r\n+\t * @return true To be notified of changes\r\n+\t */\r\n+\tdefault boolean getWeakChanges(BlockState state, CollisionView world, BlockPos pos) {\r\n+\t\treturn false;\r\n+\t}\r\n+\r\n+\t/* TODO IForgeBlock#getHarvestTool needs ToolType\r\n+\t/**\r\n+\t * Queries the class of tool required to harvest this block, if null is returned\r\n+\t * we assume that anything can harvest this block.\r\n+\t *\r\n+\tToolType getHarvestTool(BlockState state);*/\r\n+\r\n+\t// TODO Call locations: Patches: PickaxeItem*, Forge classes: ForgeHooks*\r\n+\t/**\r\n+\t * Queries the harvest level of this block.\r\n+\t *\r\n+\t * @return Harvest level, or -1 if tool is not required.\r\n+\t */\r\n+\tint getHarvestLevel(BlockState state);\r\n+\r\n+\t/* TODO IForgeBlock#isToolEffective needs ToolType\r\n+\t/**\r\n+\t * Checks if the specified tool type is efficient on this block,\r\n+\t * meaning that it digs at full speed.\r\n+\t *\r\n+\tdefault boolean isToolEffective(BlockState state, ToolType tool) {\r\n+\t\tif (tool == ToolType.PICKAXE && (this.getBlock() == Blocks.REDSTONE_ORE || this.getBlock() == Blocks.REDSTONE_LAMP || this.getBlock() == Blocks.OBSIDIAN)) {\r\n+\t\t\treturn false;\r\n+\t\t}\r\n+\r\n+\t\treturn tool == getHarvestTool(state);\r\n+\t}*/\r\n+\r\n+\t// TODO Call locations: Forge classes: ForgeHooksClient\r\n+\t/**\r\n+\t * Can return IExtendedBlockState.\r\n+\t */\r\n+\tdefault BlockState getExtendedState(BlockState state, BlockView world, BlockPos pos) {\r\n+\t\treturn state;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: ChunkRenderer*\r\n+\t/**\r\n+\t * Queries if this block should render in a given layer.\r\n+\t * A custom {@link net.minecraft.client.render.model.BakedModel} can use {@link net.minecraftforge.client.MinecraftForgeClient#getRenderLayer()} to alter the model based on layer.\r\n+\t */\r\n+\tdefault boolean canRenderInLayer(BlockState state, RenderLayer layer) {\r\n+\t\treturn this.getBlock().getRenderLayer() == layer;\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: ClientPlayerInteractionManager*, WorldRenderer*, Entity*, LivingEntity*, FoxEntity*, HorseBaseEntity*, LlamaEntity*, BlockItem*\r\n+\t/**\r\n+\t * Sensitive version of {@link Block#getSoundType}.\r\n+\t *\r\n+\t * @param state  The state\r\n+\t * @param world  The world\r\n+\t * @param pos    The position. Note that the world may not necessarily have {@code state} here!\r\n+\t * @param entity The entity that is breaking/stepping on/placing/hitting/falling on this block, or null if no entity is in this context\r\n+\t * @return A {@link BlockSoundGroup} to use\r\n+\t */\r\n+\tdefault BlockSoundGroup getSoundType(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity entity) {\r\n+\t\treturn this.getBlock().getSoundGroup(state);\r\n+\t}\r\n+\r\n+\t// TODO Call locations: Patches: BeaconBlockEntity*\r\n+\t/**\r\n+\t * @param state     The state\r\n+\t * @param world     The world\r\n+\t * @param pos       The position of this state\r\n+\t * @param beaconPos The position of the beacon\r\n+\t * @return A float RGB [0.0, 1.0] array to be averaged with a beacon's existing beam color, or null to do nothing to the beam\r\n+\t */\r\n+\t@Nullable\r\n+\tdefault float[] getBeaconColorMultiplier(BlockState state, CollisionView world, BlockPos pos, BlockPos beaconPos) {\r\n+\t\tif (getBlock() instanceof Stainable) {\r\n+\t\t\treturn ((Stainable) getBlock()).getColor().getColorComponents();\r\n+\t\t}\r\n+\r\n+\t\treturn null;\r\n+\t}\r\n+\r\n+\t// No call locations.\r\n+\t/**\r\n+\t * Use this to change the fog color used when the entity is \"inside\" a material.\r\n+\t * {@link Vec3d} is used here as \"r/g/b\" 0 - 1 values.\r\n+\t *\r\n+\t * @param state         The state at the entity viewport.\r\n+\t * @param world         The world.\r\n+\t * @param pos           The position at the entity viewport.\r\n+\t * @param entity        the entity\r\n+\t * @param originalColor The current fog color, You are not expected to use this, Return as the default if applicable.\r\n+\t * @return The new fog color.\r\n+\t */\r\n+\t@Environment(EnvType.CLIENT)\r\n+\tdefault Vec3d getFogColor(BlockState state, CollisionView world, BlockPos pos, Entity entity, Vec3d originalColor, float partialTicks) {\r\n+\t\tif (state.getMaterial() == Material.WATER) {\r\n+\t\t\tfloat f12 = 0.0F;\r", "originalCommit": "eb5a18921a2fe352f93a31f0a0219fdc33e6be70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d4c8b5328a202450ae89eff638e306cce47a597b", "url": "https://github.com/PatchworkMC/patchwork-api/commit/d4c8b5328a202450ae89eff638e306cce47a597b", "message": "changes from PR review", "committedDate": "2020-05-07T20:19:48Z", "type": "commit"}, {"oid": "62e5330aa4ca518d8839a0137c1390168fef9ec1", "url": "https://github.com/PatchworkMC/patchwork-api/commit/62e5330aa4ca518d8839a0137c1390168fef9ec1", "message": "add an override annotation and a comment about IForgeBlock overrides", "committedDate": "2020-05-07T21:58:49Z", "type": "commit"}]}