{"pr_number": 102, "pr_title": "Implement IPlantable and hooks surrounding it", "pr_createdAt": "2020-06-22T23:55:22Z", "pr_url": "https://github.com/PatchworkMC/patchwork-api/pull/102", "timeline": [{"oid": "e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "url": "https://github.com/PatchworkMC/patchwork-api/commit/e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "message": "Implement IPlantable and hooks surrounding it", "committedDate": "2020-06-22T23:53:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4ODY1Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443888656", "bodyText": "I'll see if I can fix the commit for the \\r\\n here, potential force push incoming :/", "author": "famous1622", "createdAt": "2020-06-23T00:03:27Z", "path": "patchwork-extensions-block/src/main/java/net/minecraftforge/common/extensions/IForgeBlock.java", "diffHunk": "@@ -1,1070 +1,1112 @@\n-/*\r\n- * Minecraft Forge, Patchwork Project\r\n- * Copyright (c) 2016-2020, 2019-2020\r\n- *\r\n- * This library is free software; you can redistribute it and/or\r\n- * modify it under the terms of the GNU Lesser General Public\r\n- * License as published by the Free Software Foundation version 2.1\r\n- * of the License.\r\n- *\r\n- * This library is distributed in the hope that it will be useful,\r\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n- * Lesser General Public License for more details.\r\n- *\r\n- * You should have received a copy of the GNU Lesser General Public\r\n- * License along with this library; if not, write to the Free Software\r\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n- */\r\n-\r\n-package net.minecraftforge.common.extensions;\r\n-\r\n-import java.util.Collection;\r\n-import java.util.Optional;\r\n-import java.util.Set;\r\n-import java.util.function.Predicate;\r\n-\r\n-import javax.annotation.Nullable;\r\n-\r\n-import net.minecraft.block.BedBlock;\r\n-import net.minecraft.block.Block;\r\n-import net.minecraft.block.BlockEntityProvider;\r\n-import net.minecraft.block.BlockState;\r\n-import net.minecraft.block.Blocks;\r\n-import net.minecraft.block.FarmlandBlock;\r\n-import net.minecraft.block.FenceGateBlock;\r\n-import net.minecraft.block.HorizontalFacingBlock;\r\n-import net.minecraft.block.Material;\r\n-import net.minecraft.block.Stainable;\r\n-import net.minecraft.block.entity.BlockEntity;\r\n-import net.minecraft.block.enums.BedPart;\r\n-import net.minecraft.client.particle.ParticleManager;\r\n-import net.minecraft.client.render.RenderLayer;\r\n-import net.minecraft.enchantment.EnchantmentHelper;\r\n-import net.minecraft.entity.Entity;\r\n-import net.minecraft.entity.EntityType;\r\n-import net.minecraft.entity.LivingEntity;\r\n-import net.minecraft.entity.SpawnRestriction;\r\n-import net.minecraft.entity.ai.pathing.PathNodeType;\r\n-import net.minecraft.entity.boss.WitherEntity;\r\n-import net.minecraft.entity.boss.dragon.EnderDragonEntity;\r\n-import net.minecraft.entity.effect.StatusEffects;\r\n-import net.minecraft.entity.mob.MobEntity;\r\n-import net.minecraft.entity.player.PlayerEntity;\r\n-import net.minecraft.entity.projectile.WitherSkullEntity;\r\n-import net.minecraft.fluid.FluidState;\r\n-import net.minecraft.item.ItemStack;\r\n-import net.minecraft.server.world.ServerWorld;\r\n-import net.minecraft.sound.BlockSoundGroup;\r\n-import net.minecraft.state.property.Property;\r\n-import net.minecraft.tag.BlockTags;\r\n-import net.minecraft.util.BlockRotation;\r\n-import net.minecraft.util.DyeColor;\r\n-import net.minecraft.util.Hand;\r\n-import net.minecraft.util.Identifier;\r\n-import net.minecraft.util.hit.HitResult;\r\n-import net.minecraft.util.math.BlockPos;\r\n-import net.minecraft.util.math.Direction;\r\n-import net.minecraft.util.math.Vec3d;\r\n-import net.minecraft.world.BlockRenderView;\r\n-import net.minecraft.world.BlockView;\r\n-import net.minecraft.world.CollisionView;\r\n-import net.minecraft.world.IWorld;\r\n-import net.minecraft.world.ModifiableWorld;\r\n-import net.minecraft.world.World;\r\n-import net.minecraft.world.dimension.TheEndDimension;\r\n-import net.minecraft.world.explosion.Explosion;\r\n-\r\n-import net.fabricmc.api.EnvType;\r\n-import net.fabricmc.api.Environment;\r\n-\r\n-import net.patchworkmc.mixin.extensions.block.FireBlockAccessor;\r\n-\r\n-public interface IForgeBlock {\r\n-\tdefault Block getBlock() {\r\n-\t\treturn (Block) this;\r\n-\t}\r\n-\r\n-\t// Asterisks indicate IForgeBlockState calls. All methods can be assumed to be called from IForgeBlockState.\r\n-\t// Note that some of these methods may be overridden in patches to vanilla blocks, but I can't figure out how to check for that easily. Just, well, check when you implement one.\r\n-\r\n-\t// TODO Call locations: Patches: FlyingEntity*, LivingEntity*, BoatEntity*, ExperienceOrbEntity*, ItemEntity*\r\n-\t/**\r\n-\t * Gets the slipperiness at the given location at the given state. Normally\r\n-\t * between 0 and 1.\r\n-\t *\r\n-\t * <p>Note that entities may reduce slipperiness by a certain factor of their own;\r\n-\t * for {@link LivingEntity}, this is {@code .91}.\r\n-\t * {@link net.minecraft.entity.ItemEntity} uses {@code .98}, and\r\n-\t * {@link net.minecraft.entity.projectile.FishingBobberEntity} uses {@code .92}.\r\n-\t *\r\n-\t * @param state  state of the block\r\n-\t * @param world  the world\r\n-\t * @param pos    the position in the world\r\n-\t * @param entity the entity in question\r\n-\t * @return the factor by which the entity's motion should be multiplied\r\n-\t */\r\n-\tfloat getSlipperiness(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity entity);\r\n-\r\n-\t// TODO Call locations: Patches: Block*, BlockModelRenderer*, World*, Chunk*\r\n-\t/**\r\n-\t * Get a light value for this block, taking into account the given state and coordinates, normal ranges are between 0 and 15.\r\n-\t *\r\n-\t * @param state\r\n-\t * @param world\r\n-\t * @param pos\r\n-\t * @return The light value\r\n-\t */\r\n-\tdefault int getLightValue(BlockState state, BlockRenderView world, BlockPos pos) {\r\n-\t\treturn state.getLuminance();\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Forge classes: ForgeHooks* (called in LivingEntity patch)\r\n-\t/**\r\n-\t * Checks if a player or entity can use this block to 'climb' like a ladder.\r\n-\t *\r\n-\t * @param state  The current state\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param entity The entity trying to use the ladder, CAN be null.\r\n-\t * @return True if the block should act like a ladder\r\n-\t */\r\n-\tdefault boolean isLadder(BlockState state, CollisionView world, BlockPos pos, LivingEntity entity) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * note: do not bother implementing hooks, deprecated for removal in 1.15\r\n-\t * Check if the face of a block should block rendering.\r\n-\t *\r\n-\t * <p>Faces which are fully opaque should return true, faces with transparency\r\n-\t * or faces which do not span the full size of the block should return false.\r\n-\t *\r\n-\t * @param state The current block state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The side to check\r\n-\t * @return True if the block is opaque on the specified side.\r\n-\t * @deprecated This is no longer used for rendering logic.\r\n-\t */\r\n-\t@Deprecated\r\n-\tdefault boolean doesSideBlockRendering(BlockState state, BlockRenderView world, BlockPos pos, Direction face) {\r\n-\t\treturn state.isFullOpaque(world, pos);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: World*\r\n-\t/**\r\n-\t * Determines if this block should set fire and deal fire damage\r\n-\t * to entities coming into contact with it.\r\n-\t *\r\n-\t * @param state The current block state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the block should deal damage\r\n-\t */\r\n-\tdefault boolean isBurning(BlockState state, BlockView world, BlockPos pos) {\r\n-\t\treturn this == Blocks.FIRE || this == Blocks.LAVA;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: Block, Block*, PistonBlock*, RepeaterBlock*, WorldRenderer*, ChunkRenderer*, BlockArgumentParser*, FallingBlockEntity*, ChestBlockEntity*, HopperBlockEntity*, Explosion*, World*, WorldChunk*, ChunkRegion*, ChunkHolder*, Forge classes: ForgeHooks, FluidUtil, ForgeHooks*, VanillaInventoryCodeHooks*\r\n-\t/**\r\n-\t * Called throughout the code as a replacement for {@code block instanceof} {@link BlockEntityProvider}.\r\n-\t * Allows for blocks to have a block entity conditionally based on block state.\r\n-\t *\r\n-\t * <p>Return true from this function to specify this block has a block entity.\r\n-\t *\r\n-\t * @param state State of the current block\r\n-\t * @return True if block has a block entity, false otherwise\r\n-\t */\r\n-\tdefault boolean hasTileEntity(BlockState state) {\r\n-\t\treturn this instanceof BlockEntityProvider;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: WorldChunk*, ChunkRegion*\r\n-\t/**\r\n-\t * Called throughout the code as a replacement for {@link BlockEntityProvider#createBlockEntity(BlockView)}\r\n-\t * Return the same thing you would from that function.\r\n-\t * This will fall back to {@link BlockEntityProvider#createBlockEntity(BlockView)} if this block is a {@link BlockEntityProvider}\r\n-\t *\r\n-\t * @param state The state of the current block\r\n-\t * @param world The world to create the BE in\r\n-\t * @return An instance of a class extending {@link BlockEntity}\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault BlockEntity createTileEntity(BlockState state, BlockView world) {\r\n-\t\tif (getBlock() instanceof BlockEntityProvider) {\r\n-\t\t\treturn ((BlockEntityProvider) getBlock()).createBlockEntity(world);\r\n-\t\t}\r\n-\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\t/* TODO IForgeBlock#canHarvestBlock indirectly requires ToolType (via ForgeHooks#canHarvestBlock)\r\n-\t/**\r\n-\t * Determines if the player can harvest this block, obtaining it's drops when the block is destroyed.\r\n-\t *\r\n-\t * @param world  The current world\r\n-\t * @param pos    The block's current position\r\n-\t * @param player The player damaging the block\r\n-\t * @return True to spawn the drops\r\n-\t *\r\n-\tdefault boolean canHarvestBlock(BlockState state, BlockView world, BlockPos pos, PlayerEntity player) {\r\n-\t\treturn ForgeHooks.canHarvestBlock(state, player, world, pos);\r\n-\t}*/\r\n-\r\n-\t// TODO Call locations: Patches: ServerPlayerInteractionManager*\r\n-\t/**\r\n-\t * Called when a player removes a block.  This is responsible for\r\n-\t * actually destroying the block, and the block is intact at time of call.\r\n-\t * This is called regardless of whether the player can harvest the block or\r\n-\t * not.\r\n-\t *\r\n-\t * <p>Return true if the block is actually destroyed.\r\n-\t *\r\n-\t * <p>Note: When used in multiplayer, this is called on both client and\r\n-\t * server sides!\r\n-\t *\r\n-\t * @param state       The current state.\r\n-\t * @param world       The current world\r\n-\t * @param pos         Block position in world\r\n-\t * @param player      The player damaging the block, may be null\r\n-\t * @param willHarvest True if {@link Block#onBroken(IWorld, BlockPos, BlockState)} will be called after this if this method returns true.\r\n-\t *                    Can be useful to delay the destruction of block entities till after onBroken\r\n-\t * @param fluid       The current fluid state at current position\r\n-\t * @return True if the block is actually destroyed.\r\n-\t */\r\n-\tdefault boolean removedByPlayer(BlockState state, World world, BlockPos pos, PlayerEntity player, boolean willHarvest, FluidState fluid) {\r\n-\t\tgetBlock().onBreak(world, pos, state, player);\r\n-\t\treturn world.removeBlock(pos, false);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: LivingEntity*, PlayerEntity*, Forge classes: ForgeEventFactory (called from LivingEntity patch)\r\n-\t/**\r\n-\t * Determines if this block is classified as a Bed, Allowing\r\n-\t * players to sleep in it, though the block has to specifically\r\n-\t * perform the sleeping functionality in it's activated event.\r\n-\t *\r\n-\t * @param state  The current state\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param player The player or camera entity, null in some cases.\r\n-\t * @return True to treat this as a bed\r\n-\t */\r\n-\tdefault boolean isBed(BlockState state, BlockView world, BlockPos pos, @Nullable Entity player) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t//TODO Call locations: Patches: SpawnHelper*\r\n-\t/**\r\n-\t * Determines if a specified mob type can spawn on this block, returning false will\r\n-\t * prevent any mob from spawning on the block.\r\n-\t *\r\n-\t * @param state        The current state\r\n-\t * @param world        The current world\r\n-\t * @param pos          Block position in world\r\n-\t * @param restriction  The location spawn restriction\r\n-\t * @param entityType   The type of entity attempting to spawn\r\n-\t * @return True to allow a mob of the specified category to spawn, false to prevent it.\r\n-\t */\r\n-\tdefault boolean canCreatureSpawn(BlockState state, BlockView world, BlockPos pos, SpawnRestriction.Location restriction, @Nullable EntityType<?> entityType) {\r\n-\t\treturn state.allowsSpawning(world, pos, entityType);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: LivingEntity*, PlayerEntity*\r\n-\t/**\r\n-\t * Returns the position that the sleeper is moved to upon\r\n-\t * waking up, or respawning at the bed.\r\n-\t *\r\n-\t * @param entityType the sleeper's entity type\r\n-\t * @param state      The current state\r\n-\t * @param world      The current world\r\n-\t * @param pos        Block position in world\r\n-\t * @param sleeper    The sleeper or camera entity, null in some cases.\r\n-\t * @return The spawn position\r\n-\t */\r\n-\tdefault Optional<Vec3d> getBedSpawnPosition(EntityType<?> entityType, BlockState state, CollisionView world, BlockPos pos, @Nullable LivingEntity sleeper) {\r\n-\t\tif (world instanceof World) {\r\n-\t\t\treturn BedBlock.findWakeUpPosition(entityType, world, pos, 0);\r\n-\t\t}\r\n-\r\n-\t\treturn Optional.empty();\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: LivingEntity*\r\n-\t/**\r\n-\t * Called when a user either starts or stops sleeping in the bed.\r\n-\t *\r\n-\t * @param state    The current state\r\n-\t * @param world    The current world\r\n-\t * @param pos      Block position in world\r\n-\t * @param sleeper  The sleeper or camera entity, null in some cases.\r\n-\t * @param occupied True if we are occupying the bed, or false if they are stopping use of the bed\r\n-\t */\r\n-\tdefault void setBedOccupied(BlockState state, CollisionView world, BlockPos pos, LivingEntity sleeper, boolean occupied) {\r\n-\t\tif (world instanceof ModifiableWorld) {\r\n-\t\t\t((ModifiableWorld) world).setBlockState(pos, state.with(BedBlock.OCCUPIED, occupied), 4);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: LivingEntity*\r\n-\t/**\r\n-\t * Returns the direction of the block. Same values that\r\n-\t * are returned by {@link net.minecraft.block.FacingBlock}. Called every frame tick for every living entity. Be VERY fast.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return Bed direction\r\n-\t */\r\n-\tdefault Direction getBedDirection(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t\treturn state.get(HorizontalFacingBlock.FACING);\r\n-\t}\r\n-\r\n-\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\r\n-\t/**\r\n-\t * Determines if the current block is the foot half of the bed.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the current block is the foot side of a bed.\r\n-\t */\r\n-\tdefault boolean isBedFoot(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t\treturn state.get(BedBlock.PART) == BedPart.FOOT;\r\n-\t}\r\n-\r\n-\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\r\n-\t/**\r\n-\t * Called when a leaf should start its decay process.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t */\r\n-\tdefault void beginLeaveDecay(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t}\r\n-\r\n-\t// TODO This has 59 calls in patches, which I am not going to list here. Forge classes: FluidAttributes*, ForgeHooks*\r\n-\t/**\r\n-\t * Determines this block should be treated as an air block\r\n-\t * by the rest of the code. This method is primarily\r\n-\t * useful for creating pure logic-blocks that will be invisible\r\n-\t * to the player and otherwise interact as air would.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the block considered air\r\n-\t */\r\n-\tdefault boolean isAir(BlockState state, BlockView world, BlockPos pos) {\r\n-\t\treturn state.getMaterial() == Material.AIR;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: AbstractTreeFeature*, HugeBrownMushroomFeature*, HugeRedMushroomFeature*\r\n-\t/**\r\n-\t * Used during tree growth to determine if newly generated leaves can replace this block.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return true if this block can be replaced by growing leaves.\r\n-\t */\r\n-\tdefault boolean canBeReplacedByLeaves(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t\treturn isAir(state, world, pos) || state.matches(BlockTags.LEAVES);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: AbstractTreeFeature*\r\n-\t/**\r\n-\t * Used during tree growth to determine if newly generated logs can replace this block.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return true if this block can be replaced by growing leaves.\r\n-\t */\r\n-\tdefault boolean canBeReplacedByLogs(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t\treturn (isAir(state, world, pos) || state.matches(BlockTags.LEAVES)) || this == Blocks.GRASS_BLOCK || Block.isNaturalDirt(getBlock())\r\n-\t\t\t\t|| getBlock().matches(BlockTags.LOGS) || getBlock().matches(BlockTags.SAPLINGS) || this == Blocks.VINE;\r\n-\t}\r\n-\r\n-\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\r\n-\t/**\r\n-\t * Determines if the current block is replaceable by ore veins during world generation.\r\n-\t *\r\n-\t * @param state  The current state\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param target The generic target block the gen is looking for, usually stone\r\n-\t *               for overworld generation, and netherrack for the nether.\r\n-\t * @return True to allow this block to be replaced by a ore\r\n-\t */\r\n-\tdefault boolean isReplaceableOreGen(BlockState state, CollisionView world, BlockPos pos, Predicate<BlockState> target) {\r\n-\t\treturn target.test(state);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: Explosion*\r\n-\t/**\r\n-\t * Location sensitive version of getExplosionResistance.\r\n-\t *\r\n-\t * @param state     The current state\r\n-\t * @param world     The current world\r\n-\t * @param pos       Block position in world\r\n-\t * @param exploder  The entity that caused the explosion, can be null\r\n-\t * @param explosion The explosion\r\n-\t * @return The amount of the explosion absorbed.\r\n-\t */\r\n-\tdefault float getExplosionResistance(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity exploder, Explosion explosion) {\r\n-\t\treturn this.getBlock().getBlastResistance();\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: RedstoneWireBlock*\r\n-\t/**\r\n-\t * Determine if this block can make a redstone connection on the side provided,\r\n-\t * Useful to control which sides are inputs and outputs for redstone wires.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param side  The side that is trying to make the connection, CAN BE NULL\r\n-\t * @return True to make the connection\r\n-\t */\r\n-\tdefault boolean canConnectRedstone(BlockState state, BlockView world, BlockPos pos, @Nullable Direction side) {\r\n-\t\treturn state.emitsRedstonePower() && side != null;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Forge classes: ForgeHooks\r\n-\t/**\r\n-\t * Called when a user uses the creative pick block button on this block.\r\n-\t *\r\n-\t * @param state  The current state\r\n-\t * @param target The full target the player is looking at\r\n-\t * @param world  The world the block is in\r\n-\t * @param pos    The block's position\r\n-\t * @param player The player picking the block\r\n-\t * @return An {@link ItemStack} to add to the player's inventory, empty itemstack if nothing should be added.\r\n-\t */\r\n-\tdefault ItemStack getPickBlock(BlockState state, HitResult target, BlockView world, BlockPos pos, PlayerEntity player) {\r\n-\t\treturn this.getBlock().getPickStack(world, pos, state);\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Forge javadoc only said where this was used. It isn't used anywhere, so there's really no way to document this.\r\n-\t */\r\n-\tdefault boolean isFoliage(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: LivingEntity*\r\n-\t/**\r\n-\t * Allows a block to override the standard {@link LivingEntity#fall} particles.\r\n-\t * This is a server side method that spawns particles with\r\n-\t * {@link ServerWorld#spawnParticles}\r\n-\t *\r\n-\t * @param state1            This block's state.\r\n-\t * @param serverworld       The {@link ServerWorld} this block is in.\r\n-\t * @param pos               The position of the block.\r\n-\t * @param state2            This block's state, but again.\r\n-\t * @param entity            The entity that landed on the block\r\n-\t * @param numberOfParticles Number of particles the vanilla version of this method would spawn.\r\n-\t * @return True to prevent vanilla landing particles from spawning\r\n-\t */\r\n-\tdefault boolean addLandingEffects(BlockState state1, ServerWorld serverworld, BlockPos pos, BlockState state2, LivingEntity entity, int numberOfParticles) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: Entity*\r\n-\t/**\r\n-\t * Allows a block to override the standard vanilla running particles.\r\n-\t * This is called from {@link Entity#spawnSprintingParticles} and is called both\r\n-\t * client and server side, it's up to the implementor to client check / server check.\r\n-\t * By default vanilla spawns particles only on the client and the server methods no-op.\r\n-\t *\r\n-\t * @param state  The state of this block.\r\n-\t * @param world  The world.\r\n-\t * @param pos    The position at the entity's feet.\r\n-\t * @param entity The entity running on the block.\r\n-\t * @return True to prevent vanilla running particles from spawning.\r\n-\t */\r\n-\tdefault boolean addRunningEffects(BlockState state, World world, BlockPos pos, Entity entity) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: ParticleManager*\r\n-\t/**\r\n-\t * Spawn a digging particle effect in the world, this is a wrapper\r\n-\t * around {@link ParticleManager.addBlockBreakParticles} to allow the block more\r\n-\t * control over the particles.\r\n-\t *\r\n-\t * @param state   The current state\r\n-\t * @param world   The current world\r\n-\t * @param target  The target the player is looking at {x/y/z/side/sub}\r\n-\t * @param manager A reference to the current particle manager.\r\n-\t * @return True to prevent vanilla digging particles form spawning.\r\n-\t */\r\n-\t@Environment(EnvType.CLIENT)\r\n-\tdefault boolean addHitEffects(BlockState state, World worldObj, HitResult target, ParticleManager manager) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: ParticleManager*\r\n-\t/**\r\n-\t * Spawn particles for when the block is destroyed. Due to the nature\r\n-\t * of how this is invoked, the x/y/z locations are not always guaranteed\r\n-\t * to host your block. So be sure to do proper sanity checks before assuming\r\n-\t * that the location is this block.\r\n-\t *\r\n-\t * @param state   This block's state\r\n-\t * @param world   The current world\r\n-\t * @param pos     Position to spawn the particle\r\n-\t * @param manager A reference to the current particle manager.\r\n-\t * @return True to prevent vanilla break particles from spawning.\r\n-\t */\r\n-\t@Environment(EnvType.CLIENT)\r\n-\tdefault boolean addDestroyEffects(BlockState state, World world, BlockPos pos, ParticleManager manager) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t/* TODO IForgeBlock#canSustainPlant requires IPlantable\r\n-\t/**\r\n-\t * Determines if this block can support the passed in plant, allowing it to be planted and grow.\r\n-\t * Some examples:\r\n-\t * Reeds check if its a reed, or if its sand/dirt/grass and adjacent to water\r\n-\t * Cacti checks if its a cacti, or if its sand\r\n-\t * Nether types check for soul sand\r\n-\t * Crops check for tilled soil\r\n-\t * Caves check if it's a solid surface\r\n-\t * Plains check if its grass or dirt\r\n-\t * Water check if its still water\r\n-\t *\r\n-\t * @param state     The Current state\r\n-\t * @param world     The current world\r\n-\t * @param facing    The direction relative to the given position the plant wants to be, typically its UP\r\n-\t * @param plantable The plant that wants to check\r\n-\t * @return True to allow the plant to be planted/stay.\r\n-\t *\r\n-\tboolean canSustainPlant(BlockState state, BlockView world, BlockPos pos, Direction facing, IPlantable plantable);*/\r\n-\r\n-\t// TODO Call locations: Patches: AbstractTreeFeature*\r\n-\t/**\r\n-\t * Called when a plant grows on this block.\r\n-\t * This does not use ForgeDirection, because large/huge trees can be located in non-representable direction,\r\n-\t * so the source location is specified.\r\n-\t * Currently this just changes the block to dirt if it was grass.\r\n-\t *\r\n-\t * <p>Note: This happens DURING the generation, the generation may not be complete when this is called.\r\n-\t *\r\n-\t * @param state  The current state\r\n-\t * @param world  Current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param source Source plant's position in world\r\n-\t */\r\n-\tdefault void onPlantGrow(BlockState state, IWorld world, BlockPos pos, BlockPos source) {\r\n-\t\tif (Block.isNaturalDirt(getBlock())) {\r\n-\t\t\tworld.setBlockState(pos, Blocks.DIRT.getDefaultState(), 2);\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: CropBlock*\r\n-\t/**\r\n-\t * Checks if this soil is fertile, typically this means that growth rates\r\n-\t * of plants on this soil will be slightly sped up.\r\n-\t * Only vanilla case is tilledField when it is within range of water.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the soil should be considered fertile.\r\n-\t */\r\n-\tdefault boolean isFertile(BlockState state, BlockView world, BlockPos pos) {\r\n-\t\tif (this.getBlock() == Blocks.FARMLAND) {\r\n-\t\t\treturn state.get(FarmlandBlock.MOISTURE) > 0;\r\n-\t\t}\r\n-\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: BeaconBlockEntity*\r\n-\t/**\r\n-\t * Determines if this block can be used as the base of a beacon.\r\n-\t *\r\n-\t * @param state  The current state\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param beacon Beacon position in world\r\n-\t * @return True, to support the beacon, and make it active with this block.\r\n-\t */\r\n-\tdefault boolean isBeaconBase(BlockState state, CollisionView world, BlockPos pos, BlockPos beacon) {\r\n-\t\t// TODO implement actual tag-based functionality\r\n-\t\treturn this == Blocks.EMERALD_BLOCK || this == Blocks.GOLD_BLOCK || this == Blocks.DIAMOND_BLOCK || this == Blocks.IRON_BLOCK;\r\n-\t\t// return Tags.Blocks.SUPPORTS_BEACON.contains(state.getBlock());\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Forge classes: BreakEvent*\r\n-\t/**\r\n-\t * Gathers how much experience this block drops when broken.\r\n-\t *\r\n-\t * @param state     The current state\r\n-\t * @param world     The world\r\n-\t * @param pos       Block position\r\n-\t * @param fortune   Level of fortune on the breaker's tool\r\n-\t * @param silktouch Level of silk touch on the breaker's tool\r\n-\t * @return Amount of XP from breaking this block.\r\n-\t */\r\n-\tdefault int getExpDrop(BlockState state, CollisionView world, BlockPos pos, int fortune, int silktouch) {\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: PistonBlock\r\n-\tdefault BlockState rotate(BlockState state, IWorld world, BlockPos pos, BlockRotation direction) {\r\n-\t\treturn state.rotate(direction);\r\n-\t}\r\n-\r\n-\t// No call locations\r\n-\t/**\r\n-\t * Get the rotations that can apply to the block at the specified coordinates. Null means no rotations are possible.\r\n-\t * Note, this is up to the block to decide. It may not be accurate or representative.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The world\r\n-\t * @param pos   Block position in world\r\n-\t * @return An array of valid axes to rotate around, or null for none or unknown\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault Direction[] getValidRotations(BlockState state, BlockView world, BlockPos pos) {\r\n-\t\tfor (Property<?> prop : state.getProperties()) {\r\n-\t\t\tif ((prop.getName().equals(\"facing\") || prop.getName().equals(\"rotation\")) && prop.getType() == Direction.class) {\r\n-\t\t\t\t@SuppressWarnings(\"unchecked\")\r\n-\t\t\t\tCollection<Direction> values = ((Collection<Direction>) prop.getValues());\r\n-\t\t\t\treturn values.toArray(new Direction[values.size()]);\r\n-\t\t\t}\r\n-\t\t}\r\n-\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: EnchantingTableBlock*, EnchantingTableContainer*\r\n-\t/**\r\n-\t * Determines the amount of enchanting power this block can provide to an enchanting table.\r\n-\t *\r\n-\t * @param world The world\r\n-\t * @param pos   Block position in world\r\n-\t * @return The amount of enchanting power this block produces.\r\n-\t */\r\n-\tdefault float getEnchantPowerBonus(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t\treturn this.getBlock() == Blocks.BOOKSHELF ? 1 : 0;\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Re-colors this block in the world.\r\n-\t *\r\n-\t * @param state   The current state\r\n-\t * @param world   The world\r\n-\t * @param pos     Block position\r\n-\t * @param facing  ??? (this method has no usages)\r\n-\t * @param color   Color to recolor to.\r\n-\t * @return if the block was affected\r\n-\t */\r\n-\t@SuppressWarnings(\"unchecked\")\r\n-\tdefault boolean recolorBlock(BlockState state, IWorld world, BlockPos pos, Direction facing, DyeColor color) {\r\n-\t\tfor (Property<?> prop : state.getProperties()) {\r\n-\t\t\tif (prop.getName().equals(\"color\") && prop.getType() == DyeColor.class) {\r\n-\t\t\t\tDyeColor current = (DyeColor) state.get(prop);\r\n-\r\n-\t\t\t\tif (current != color && prop.getValues().contains(color)) {\r\n-\t\t\t\t\tworld.setBlockState(pos, state.with(((Property<DyeColor>) prop), color), 3);\r\n-\t\t\t\t\treturn true;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\t\t}\r\n-\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: World*\r\n-\t/**\r\n-\t * Called when a block entity on a side of this block changes is created or is destroyed.\r\n-\t *\r\n-\t * @param state    The state of this block\r\n-\t * @param world    The world\r\n-\t * @param pos      Block position in world\r\n-\t * @param neighbor Block position of neighbor\r\n-\t */\r\n-\tdefault void onNeighborChange(BlockState state, CollisionView world, BlockPos pos, BlockPos neighbor) {\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Called on an Observer block whenever an update for an Observer is received.\r\n-\t *\r\n-\t * @param observerState   The Observer block's state.\r\n-\t * @param world           The current world.\r\n-\t * @param observerPos     The Observer block's position.\r\n-\t * @param changedBlock    The updated block.\r\n-\t * @param changedBlockPos The updated block's position.\r\n-\t */\r\n-\tdefault void observedNeighborChange(BlockState observerState, World world, BlockPos observerPos, Block changedBlock, BlockPos changedBlockPos) {\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: World*\r\n-\t/**\r\n-\t * Called to determine whether to allow the a block to handle its own indirect power rather than using the default rules.\r\n-\t *\r\n-\t * @param state This block's state\r\n-\t * @param world The world\r\n-\t * @param pos   Block position in world\r\n-\t * @param side  The INPUT side of the block to be powered - ie the opposite of this block's output side\r\n-\t * @return Whether weak power should be checked normally\r\n-\t */\r\n-\tdefault boolean shouldCheckWeakPower(BlockState state, CollisionView world, BlockPos pos, Direction side) {\r\n-\t\treturn state.isSimpleFullBlock(world, pos);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: World*\r\n-\t/**\r\n-\t * If this block should be notified of weak changes.\r\n-\t * Weak changes are changes 1 block away through a solid block.\r\n-\t * Similar to comparators.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return true To be notified of changes\r\n-\t */\r\n-\tdefault boolean getWeakChanges(BlockState state, CollisionView world, BlockPos pos) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t/* TODO IForgeBlock#getHarvestTool needs ToolType\r\n-\t/**\r\n-\t * Queries the class of tool required to harvest this block, if null is returned\r\n-\t * we assume that anything can harvest this block.\r\n-\t *\r\n-\tToolType getHarvestTool(BlockState state);*/\r\n-\r\n-\t// TODO Call locations: Patches: PickaxeItem*, Forge classes: ForgeHooks*\r\n-\t/**\r\n-\t * Queries the harvest level of this block.\r\n-\t *\r\n-\t * @return Harvest level, or -1 if tool is not required.\r\n-\t */\r\n-\tint getHarvestLevel(BlockState state);\r\n-\r\n-\t/* TODO IForgeBlock#isToolEffective needs ToolType\r\n-\t/**\r\n-\t * Checks if the specified tool type is efficient on this block,\r\n-\t * meaning that it digs at full speed.\r\n-\t *\r\n-\tdefault boolean isToolEffective(BlockState state, ToolType tool) {\r\n-\t\tif (tool == ToolType.PICKAXE && (this.getBlock() == Blocks.REDSTONE_ORE || this.getBlock() == Blocks.REDSTONE_LAMP || this.getBlock() == Blocks.OBSIDIAN)) {\r\n-\t\t\treturn false;\r\n-\t\t}\r\n-\r\n-\t\treturn tool == getHarvestTool(state);\r\n-\t}*/\r\n-\r\n-\t// TODO Call locations: Forge classes: ForgeHooksClient\r\n-\t/**\r\n-\t * Can return IExtendedBlockState.\r\n-\t */\r\n-\tdefault BlockState getExtendedState(BlockState state, BlockView world, BlockPos pos) {\r\n-\t\treturn state;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: ChunkRenderer*\r\n-\t/**\r\n-\t * Queries if this block should render in a given layer.\r\n-\t * A custom {@link net.minecraft.client.render.model.BakedModel} can use {@link net.minecraftforge.client.MinecraftForgeClient#getRenderLayer()} to alter the model based on layer.\r\n-\t */\r\n-\tdefault boolean canRenderInLayer(BlockState state, RenderLayer layer) {\r\n-\t\treturn this.getBlock().getRenderLayer() == layer;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: ClientPlayerInteractionManager*, WorldRenderer*, Entity*, LivingEntity*, FoxEntity*, HorseBaseEntity*, LlamaEntity*, BlockItem*\r\n-\t/**\r\n-\t * Sensitive version of {@link Block#getSoundType}.\r\n-\t *\r\n-\t * @param state  The state\r\n-\t * @param world  The world\r\n-\t * @param pos    The position. Note that the world may not necessarily have {@code state} here!\r\n-\t * @param entity The entity that is breaking/stepping on/placing/hitting/falling on this block, or null if no entity is in this context\r\n-\t * @return A {@link BlockSoundGroup} to use\r\n-\t */\r\n-\tdefault BlockSoundGroup getSoundType(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity entity) {\r\n-\t\treturn this.getBlock().getSoundGroup(state);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: BeaconBlockEntity*\r\n-\t/**\r\n-\t * @param state     The state\r\n-\t * @param world     The world\r\n-\t * @param pos       The position of this state\r\n-\t * @param beaconPos The position of the beacon\r\n-\t * @return A float RGB [0.0, 1.0] array to be averaged with a beacon's existing beam color, or null to do nothing to the beam\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault float[] getBeaconColorMultiplier(BlockState state, CollisionView world, BlockPos pos, BlockPos beaconPos) {\r\n-\t\tif (getBlock() instanceof Stainable) {\r\n-\t\t\treturn ((Stainable) getBlock()).getColor().getColorComponents();\r\n-\t\t}\r\n-\r\n-\t\treturn null;\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Use this to change the fog color used when the entity is \"inside\" a material.\r\n-\t * {@link Vec3d} is used here as \"r/g/b\" 0 - 1 values.\r\n-\t *\r\n-\t * @param state         The state at the entity viewport.\r\n-\t * @param world         The world.\r\n-\t * @param pos           The position at the entity viewport.\r\n-\t * @param entity        the entity\r\n-\t * @param originalColor The current fog color, You are not expected to use this, Return as the default if applicable.\r\n-\t * @return The new fog color.\r\n-\t */\r\n-\t@Environment(EnvType.CLIENT)\r\n-\tdefault Vec3d getFogColor(BlockState state, CollisionView world, BlockPos pos, Entity entity, Vec3d originalColor, float partialTicks) {\r\n-\t\tif (state.getMaterial() == Material.WATER) {\r\n-\t\t\tfloat visibility = 0.0F;\r\n-\r\n-\t\t\tif (entity instanceof LivingEntity) {\r\n-\t\t\t\tLivingEntity ent = (LivingEntity) entity;\r\n-\t\t\t\tvisibility = (float) EnchantmentHelper.getRespiration(ent) * 0.2F;\r\n-\r\n-\t\t\t\tif (ent.hasStatusEffect(StatusEffects.WATER_BREATHING)) {\r\n-\t\t\t\t\tvisibility = visibility * 0.3F + 0.6F;\r\n-\t\t\t\t}\r\n-\t\t\t}\r\n-\r\n-\t\t\treturn new Vec3d(0.02F + visibility, 0.02F + visibility, 0.2F + visibility);\r\n-\t\t} else if (state.getMaterial() == Material.LAVA) {\r\n-\t\t\treturn new Vec3d(0.6F, 0.1F, 0.0F);\r\n-\t\t}\r\n-\r\n-\t\treturn originalColor;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: Camera*\r\n-\t/**\r\n-\t * Used to determine the state 'viewed' by an entity.\r\n-\t * Can be used by fluid blocks to determine if the viewpoint is within the fluid or not.\r\n-\t *\r\n-\t * @param state     the state\r\n-\t * @param world     the world\r\n-\t * @param pos       the position\r\n-\t * @param viewpoint the viewpoint\r\n-\t * @return the block state that should be 'seen'\r\n-\t */\r\n-\tdefault BlockState getStateAtViewpoint(BlockState state, BlockView world, BlockPos pos, Vec3d viewpoint) {\r\n-\t\treturn state;\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Gets the {@link BlockState} to place.\r\n-\t *\r\n-\t * @param state  ??? (presumably this block's state, but it has not yet been placed?)\r\n-\t * @param facing The side the block is being placed on\r\n-\t * @param state2 ???\r\n-\t * @param world  The world the block is being placed in\r\n-\t * @param pos1   ??? (presumably where it's being placed)\r\n-\t * @param pos2   ???\r\n-\t * @param hand   The hand the block is being placed from\r\n-\t * @return The state to be placed in the world\r\n-\t */\r\n-\tdefault BlockState getStateForPlacement(BlockState state, Direction facing, BlockState state2, IWorld world, BlockPos pos1, BlockPos pos2, Hand hand) {\r\n-\t\treturn this.getBlock().getStateForNeighborUpdate(state, facing, state2, world, pos1, pos2);\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Determines if another block can connect to this block.\r\n-\t *\r\n-\t * @param state  This block's state\r\n-\t * @param world  The current world\r\n-\t * @param pos    The position of this block\r\n-\t * @param facing The side the connecting block is on\r\n-\t * @return True to allow another block to connect to this block\r\n-\t */\r\n-\tdefault boolean canBeConnectedTo(BlockState state, BlockView world, BlockPos pos, Direction facing) {\r\n-\t\treturn false;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: LandPathNodeMaker, LandPathNodeMaker*\r\n-\t/**\r\n-\t * Get the {@code PathNodeType} for this block. Return {@code null} for vanilla behavior.\r\n-\t *\r\n-\t * @return the PathNodeType\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault PathNodeType getAiPathNodeType(BlockState state, BlockView world, BlockPos pos, @Nullable MobEntity entity) {\r\n-\t\treturn ((IForgeBlockState) state).isBurning(world, pos) ? PathNodeType.DAMAGE_FIRE : null;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: PistonBlockEntity, PistonHandler*\r\n-\t/**\r\n-\t * @param state The state\r\n-\t * @return true if the block is sticky block which used for pull or push adjacent blocks (use by piston)\r\n-\t */\r\n-\tdefault boolean isStickyBlock(BlockState state) {\r\n-\t\treturn state.getBlock() == Blocks.SLIME_BLOCK;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: FireBlock*\r\n-\t/**\r\n-\t * Chance that fire will spread and consume this block.\r\n-\t * 300 being a 100% chance, 0, being a 0% chance.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The face that the fire is coming from\r\n-\t * @return A number ranging from 0 to 300 relating used to determine if the block will be consumed by fire\r\n-\t */\r\n-\tdefault int getFlammability(BlockState state, BlockView world, BlockPos pos, Direction face) {\r\n-\t\treturn ((FireBlockAccessor) Blocks.FIRE).invokeGetSpreadChance(state);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: FireBlock*, DispenserBehavior*\r\n-\t/**\r\n-\t * Called when fire is updating, checks if a block face can catch fire.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The face that the fire is coming from\r\n-\t * @return True if the face can be on fire, false otherwise.\r\n-\t */\r\n-\tdefault boolean isFlammable(BlockState state, BlockView world, BlockPos pos, Direction face) {\r\n-\t\treturn ((IForgeBlockState) state).getFlammability(world, pos, face) > 0;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: TNTBlock, FireBlock*, DispenserBehavior*\r\n-\t/**\r\n-\t * If the block is flammable, this is called when it gets lit on fire.\r\n-\t *\r\n-\t * @param state   The current state\r\n-\t * @param world   The current world\r\n-\t * @param pos     Block position in world\r\n-\t * @param face    The face that the fire is coming from\r\n-\t * @param igniter The entity that lit the fire\r\n-\t */\r\n-\tdefault void catchFire(BlockState state, World world, BlockPos pos, @Nullable Direction face, @Nullable LivingEntity igniter) {\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Called when fire is updating on a neighbor block.\r\n-\t * The higher the number returned, the faster fire will spread around this block.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The face that the fire is coming from\r\n-\t * @return A number that is used to determine the speed of fire growth around the block\r\n-\t */\r\n-\tdefault int getFireSpreadSpeed(BlockState state, BlockView world, BlockPos pos, Direction face) {\r\n-\t\treturn ((FireBlockAccessor) Blocks.FIRE).invokeGetBurnChance(state);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: FireBlock*\r\n-\t/**\r\n-\t * Currently only called by fire when it is on top of this block.\r\n-\t * Returning true will prevent the fire from naturally dying during updating.\r\n-\t * Also prevents firing from dying from rain.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param side  The face that the fire is coming from\r\n-\t * @return True if this block sustains fire, meaning it will never go out.\r\n-\t */\r\n-\tdefault boolean isFireSource(BlockState state, BlockView world, BlockPos pos, Direction side) {\r\n-\t\tif (side != Direction.UP) {\r\n-\t\t\treturn false;\r\n-\t\t}\r\n-\r\n-\t\tif (getBlock() == Blocks.NETHERRACK || getBlock() == Blocks.MAGMA_BLOCK) {\r\n-\t\t\treturn true;\r\n-\t\t}\r\n-\r\n-\t\treturn world instanceof CollisionView && ((CollisionView) world).getDimension() instanceof TheEndDimension && getBlock() == Blocks.BEDROCK;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: WitherEntity*, WitherSkullEntity*, Forge classes: ForgeHooks*\r\n-\t/**\r\n-\t * Determines if this block is can be destroyed by the specified entities normal behavior.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True to allow the entity to destroy this block\r\n-\t */\r\n-\tdefault boolean canEntityDestroy(BlockState state, BlockView world, BlockPos pos, Entity entity) {\r\n-\t\tif (entity instanceof EnderDragonEntity) {\r\n-\t\t\treturn !BlockTags.DRAGON_IMMUNE.contains(this.getBlock());\r\n-\t\t} else if ((entity instanceof WitherEntity) || (entity instanceof WitherSkullEntity)) {\r\n-\t\t\treturn ((IForgeBlockState) state).isAir(world, pos) || WitherEntity.canDestroy(state);\r\n-\t\t}\r\n-\r\n-\t\treturn true;\r\n-\t}\r\n-\r\n-\t// No call locations.\r\n-\t/**\r\n-\t * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit.\r\n-\t *\r\n-\t * @param state    The current state\r\n-\t * @param world    The current world\r\n-\t * @param pos      Block position in world\r\n-\t * @param start    The start vector\r\n-\t * @param end      The end vector\r\n-\t * @param original The original result from {@link Block#collisionRayTrace(IBlockState, World, BlockPos, Vec3d, Vec3d)}\r\n-\t * @return A result that suits your block\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault HitResult getRayTraceResult(BlockState state, World world, BlockPos pos, Vec3d start, Vec3d end, HitResult original) {\r\n-\t\treturn original;\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: Explosion*\r\n-\t/**\r\n-\t * Determines if this block should drop loot when exploded.\r\n-\t */\r\n-\tdefault boolean canDropFromExplosion(BlockState state, BlockView world, BlockPos pos, Explosion explosion) {\r\n-\t\treturn state.getBlock().shouldDropItemsOnExplosion(explosion);\r\n-\t}\r\n-\r\n-\t// Call locations: Patches: DebugHud (no todo because this works fine without it -- this method should never be overridden anyway.)\r\n-\t/**\r\n-\t * Retrieves a list of tags names this is known to be associated with.\r\n-\t * This should be used in favor of {@link net.minecraft.tag.TagContainer#getTagsFor}, as this caches the result.\r\n-\t */\r\n-\tSet<Identifier> getTags();\r\n-\r\n-\t// TODO Call locations: Patches: Explosion*\r\n-\t/**\r\n-\t * Called when the block is destroyed by an explosion.\r\n-\t * Useful for allowing the block to take into account block entities,\r\n-\t * state, etc. when exploded, before it is removed.\r\n-\t *\r\n-\t * @param world     The current world\r\n-\t * @param pos       Block position in world\r\n-\t * @param explosion The explosion instance affecting the block\r\n-\t */\r\n-\tdefault void onBlockExploded(BlockState state, World world, BlockPos pos, Explosion explosion) {\r\n-\t\tworld.setBlockState(pos, Blocks.AIR.getDefaultState(), 3);\r\n-\t\tgetBlock().onDestroyedByExplosion(world, pos, explosion);\r\n-\t}\r\n-\r\n-\t// TODO Call locations: Patches: Entity*, ServerPlayerEntity*\r\n-\t/**\r\n-\t * Determines if this block's collision box should be treated as though it can extend above its block space.\r\n-\t * Use this to replicate fence and wall behavior.\r\n-\t */\r\n-\tdefault boolean collisionExtendsVertically(BlockState state, BlockView world, BlockPos pos, Entity collidingEntity) {\r\n-\t\treturn getBlock().matches(BlockTags.FENCES) || getBlock().matches(BlockTags.WALLS) || getBlock() instanceof FenceGateBlock;\r\n-\t}\r\n-}\r\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import net.minecraftforge.common.IPlantable;\n+\n+import net.minecraft.block.BedBlock;\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockEntityProvider;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.Blocks;\n+import net.minecraft.block.FarmlandBlock;\n+import net.minecraft.block.FenceGateBlock;\n+import net.minecraft.block.GlazedTerracottaBlock;\n+import net.minecraft.block.HorizontalFacingBlock;\n+import net.minecraft.block.Material;\n+import net.minecraft.block.PlantBlock;\n+import net.minecraft.block.Stainable;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.block.enums.BedPart;\n+import net.minecraft.client.particle.ParticleManager;\n+import net.minecraft.client.render.RenderLayer;\n+import net.minecraft.enchantment.EnchantmentHelper;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.SpawnRestriction;\n+import net.minecraft.entity.ai.pathing.PathNodeType;\n+import net.minecraft.entity.boss.WitherEntity;\n+import net.minecraft.entity.boss.dragon.EnderDragonEntity;\n+import net.minecraft.entity.effect.StatusEffects;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.entity.projectile.WitherSkullEntity;\n+import net.minecraft.fluid.FluidState;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.sound.BlockSoundGroup;\n+import net.minecraft.state.property.Property;\n+import net.minecraft.tag.BlockTags;\n+import net.minecraft.util.BlockRotation;\n+import net.minecraft.util.DyeColor;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Direction;\n+import net.minecraft.util.math.Vec3d;\n+import net.minecraft.world.BlockRenderView;\n+import net.minecraft.world.BlockView;\n+import net.minecraft.world.CollisionView;\n+import net.minecraft.world.IWorld;\n+import net.minecraft.world.ModifiableWorld;\n+import net.minecraft.world.World;\n+import net.minecraft.world.dimension.TheEndDimension;\n+import net.minecraft.world.explosion.Explosion;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+\n+import net.patchworkmc.mixin.extensions.block.FireBlockAccessor;\n+import net.patchworkmc.mixin.extensions.block.PlantBlockAccessor;\n+\n+public interface IForgeBlock {\n+\tdefault Block getBlock() {\n+\t\treturn (Block) this;\n+\t}\n+\n+\t// Asterisks indicate IForgeBlockState calls. All methods can be assumed to be called from IForgeBlockState.\n+\t// Note that some of these methods may be overridden in patches to vanilla blocks, but I can't figure out how to check for that easily. Just, well, check when you implement one.\n+\n+\t// TODO Call locations: Patches: FlyingEntity*, LivingEntity*, BoatEntity*, ExperienceOrbEntity*, ItemEntity*\n+\t/**\n+\t * Gets the slipperiness at the given location at the given state. Normally\n+\t * between 0 and 1.\n+\t *\n+\t * <p>Note that entities may reduce slipperiness by a certain factor of their own;\n+\t * for {@link LivingEntity}, this is {@code .91}.\n+\t * {@link net.minecraft.entity.ItemEntity} uses {@code .98}, and\n+\t * {@link net.minecraft.entity.projectile.FishingBobberEntity} uses {@code .92}.\n+\t *\n+\t * @param state  state of the block\n+\t * @param world  the world\n+\t * @param pos    the position in the world\n+\t * @param entity the entity in question\n+\t * @return the factor by which the entity's motion should be multiplied\n+\t */\n+\tfloat getSlipperiness(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity entity);\n+\n+\t// TODO Call locations: Patches: Block*, BlockModelRenderer*, World*, Chunk*\n+\t/**\n+\t * Get a light value for this block, taking into account the given state and coordinates, normal ranges are between 0 and 15.\n+\t *\n+\t * @param state\n+\t * @param world\n+\t * @param pos\n+\t * @return The light value\n+\t */\n+\tdefault int getLightValue(BlockState state, BlockRenderView world, BlockPos pos) {\n+\t\treturn state.getLuminance();\n+\t}\n+\n+\t// TODO Call locations: Forge classes: ForgeHooks* (called in LivingEntity patch)\n+\t/**\n+\t * Checks if a player or entity can use this block to 'climb' like a ladder.\n+\t *\n+\t * @param state  The current state\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param entity The entity trying to use the ladder, CAN be null.\n+\t * @return True if the block should act like a ladder\n+\t */\n+\tdefault boolean isLadder(BlockState state, CollisionView world, BlockPos pos, LivingEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * note: do not bother implementing hooks, deprecated for removal in 1.15\n+\t * Check if the face of a block should block rendering.\n+\t *\n+\t * <p>Faces which are fully opaque should return true, faces with transparency\n+\t * or faces which do not span the full size of the block should return false.\n+\t *\n+\t * @param state The current block state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The side to check\n+\t * @return True if the block is opaque on the specified side.\n+\t * @deprecated This is no longer used for rendering logic.\n+\t */\n+\t@Deprecated\n+\tdefault boolean doesSideBlockRendering(BlockState state, BlockRenderView world, BlockPos pos, Direction face) {\n+\t\treturn state.isFullOpaque(world, pos);\n+\t}\n+\n+\t// TODO Call locations: Patches: World*\n+\t/**\n+\t * Determines if this block should set fire and deal fire damage\n+\t * to entities coming into contact with it.\n+\t *\n+\t * @param state The current block state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the block should deal damage\n+\t */\n+\tdefault boolean isBurning(BlockState state, BlockView world, BlockPos pos) {\n+\t\treturn this == Blocks.FIRE || this == Blocks.LAVA;\n+\t}\n+\n+\t// TODO Call locations: Patches: Block, Block*, PistonBlock*, RepeaterBlock*, WorldRenderer*, ChunkRenderer*, BlockArgumentParser*, FallingBlockEntity*, ChestBlockEntity*, HopperBlockEntity*, Explosion*, World*, WorldChunk*, ChunkRegion*, ChunkHolder*, Forge classes: ForgeHooks, FluidUtil, ForgeHooks*, VanillaInventoryCodeHooks*\n+\t/**\n+\t * Called throughout the code as a replacement for {@code block instanceof} {@link BlockEntityProvider}.\n+\t * Allows for blocks to have a block entity conditionally based on block state.\n+\t *\n+\t * <p>Return true from this function to specify this block has a block entity.\n+\t *\n+\t * @param state State of the current block\n+\t * @return True if block has a block entity, false otherwise\n+\t */\n+\tdefault boolean hasTileEntity(BlockState state) {\n+\t\treturn this instanceof BlockEntityProvider;\n+\t}\n+\n+\t// TODO Call locations: Patches: WorldChunk*, ChunkRegion*\n+\t/**\n+\t * Called throughout the code as a replacement for {@link BlockEntityProvider#createBlockEntity(BlockView)}\n+\t * Return the same thing you would from that function.\n+\t * This will fall back to {@link BlockEntityProvider#createBlockEntity(BlockView)} if this block is a {@link BlockEntityProvider}\n+\t *\n+\t * @param state The state of the current block\n+\t * @param world The world to create the BE in\n+\t * @return An instance of a class extending {@link BlockEntity}\n+\t */\n+\t@Nullable\n+\tdefault BlockEntity createTileEntity(BlockState state, BlockView world) {\n+\t\tif (getBlock() instanceof BlockEntityProvider) {\n+\t\t\treturn ((BlockEntityProvider) getBlock()).createBlockEntity(world);\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\t/* TODO IForgeBlock#canHarvestBlock indirectly requires ToolType (via ForgeHooks#canHarvestBlock)\n+\t/**\n+\t * Determines if the player can harvest this block, obtaining it's drops when the block is destroyed.\n+\t *\n+\t * @param world  The current world\n+\t * @param pos    The block's current position\n+\t * @param player The player damaging the block\n+\t * @return True to spawn the drops\n+\t *\n+\tdefault boolean canHarvestBlock(BlockState state, BlockView world, BlockPos pos, PlayerEntity player) {\n+\t\treturn ForgeHooks.canHarvestBlock(state, player, world, pos);\n+\t}*/\n+\n+\t// TODO Call locations: Patches: ServerPlayerInteractionManager*\n+\t/**\n+\t * Called when a player removes a block.  This is responsible for\n+\t * actually destroying the block, and the block is intact at time of call.\n+\t * This is called regardless of whether the player can harvest the block or\n+\t * not.\n+\t *\n+\t * <p>Return true if the block is actually destroyed.\n+\t *\n+\t * <p>Note: When used in multiplayer, this is called on both client and\n+\t * server sides!\n+\t *\n+\t * @param state       The current state.\n+\t * @param world       The current world\n+\t * @param pos         Block position in world\n+\t * @param player      The player damaging the block, may be null\n+\t * @param willHarvest True if {@link Block#onBroken(IWorld, BlockPos, BlockState)} will be called after this if this method returns true.\n+\t *                    Can be useful to delay the destruction of block entities till after onBroken\n+\t * @param fluid       The current fluid state at current position\n+\t * @return True if the block is actually destroyed.\n+\t */\n+\tdefault boolean removedByPlayer(BlockState state, World world, BlockPos pos, PlayerEntity player, boolean willHarvest, FluidState fluid) {\n+\t\tgetBlock().onBreak(world, pos, state, player);\n+\t\treturn world.removeBlock(pos, false);\n+\t}\n+\n+\t// TODO Call locations: Patches: LivingEntity*, PlayerEntity*, Forge classes: ForgeEventFactory (called from LivingEntity patch)\n+\t/**\n+\t * Determines if this block is classified as a Bed, Allowing\n+\t * players to sleep in it, though the block has to specifically\n+\t * perform the sleeping functionality in it's activated event.\n+\t *\n+\t * @param state  The current state\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param player The player or camera entity, null in some cases.\n+\t * @return True to treat this as a bed\n+\t */\n+\tdefault boolean isBed(BlockState state, BlockView world, BlockPos pos, @Nullable Entity player) {\n+\t\treturn false;\n+\t}\n+\n+\t//TODO Call locations: Patches: SpawnHelper*\n+\t/**\n+\t * Determines if a specified mob type can spawn on this block, returning false will\n+\t * prevent any mob from spawning on the block.\n+\t *\n+\t * @param state        The current state\n+\t * @param world        The current world\n+\t * @param pos          Block position in world\n+\t * @param restriction  The location spawn restriction\n+\t * @param entityType   The type of entity attempting to spawn\n+\t * @return True to allow a mob of the specified category to spawn, false to prevent it.\n+\t */\n+\tdefault boolean canCreatureSpawn(BlockState state, BlockView world, BlockPos pos, SpawnRestriction.Location restriction, @Nullable EntityType<?> entityType) {\n+\t\treturn state.allowsSpawning(world, pos, entityType);\n+\t}\n+\n+\t// TODO Call locations: Patches: LivingEntity*, PlayerEntity*\n+\t/**\n+\t * Returns the position that the sleeper is moved to upon\n+\t * waking up, or respawning at the bed.\n+\t *\n+\t * @param entityType the sleeper's entity type\n+\t * @param state      The current state\n+\t * @param world      The current world\n+\t * @param pos        Block position in world\n+\t * @param sleeper    The sleeper or camera entity, null in some cases.\n+\t * @return The spawn position\n+\t */\n+\tdefault Optional<Vec3d> getBedSpawnPosition(EntityType<?> entityType, BlockState state, CollisionView world, BlockPos pos, @Nullable LivingEntity sleeper) {\n+\t\tif (world instanceof World) {\n+\t\t\treturn BedBlock.findWakeUpPosition(entityType, world, pos, 0);\n+\t\t}\n+\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t// TODO Call locations: Patches: LivingEntity*\n+\t/**\n+\t * Called when a user either starts or stops sleeping in the bed.\n+\t *\n+\t * @param state    The current state\n+\t * @param world    The current world\n+\t * @param pos      Block position in world\n+\t * @param sleeper  The sleeper or camera entity, null in some cases.\n+\t * @param occupied True if we are occupying the bed, or false if they are stopping use of the bed\n+\t */\n+\tdefault void setBedOccupied(BlockState state, CollisionView world, BlockPos pos, LivingEntity sleeper, boolean occupied) {\n+\t\tif (world instanceof ModifiableWorld) {\n+\t\t\t((ModifiableWorld) world).setBlockState(pos, state.with(BedBlock.OCCUPIED, occupied), 4);\n+\t\t}\n+\t}\n+\n+\t// TODO Call locations: Patches: LivingEntity*\n+\t/**\n+\t * Returns the direction of the block. Same values that\n+\t * are returned by {@link net.minecraft.block.FacingBlock}. Called every frame tick for every living entity. Be VERY fast.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return Bed direction\n+\t */\n+\tdefault Direction getBedDirection(BlockState state, CollisionView world, BlockPos pos) {\n+\t\treturn state.get(HorizontalFacingBlock.FACING);\n+\t}\n+\n+\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\n+\t/**\n+\t * Determines if the current block is the foot half of the bed.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the current block is the foot side of a bed.\n+\t */\n+\tdefault boolean isBedFoot(BlockState state, CollisionView world, BlockPos pos) {\n+\t\treturn state.get(BedBlock.PART) == BedPart.FOOT;\n+\t}\n+\n+\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\n+\t/**\n+\t * Called when a leaf should start its decay process.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t */\n+\tdefault void beginLeaveDecay(BlockState state, CollisionView world, BlockPos pos) {\n+\t}\n+\n+\t// TODO This has 59 calls in patches, which I am not going to list here. Forge classes: FluidAttributes*, ForgeHooks*\n+\t/**\n+\t * Determines this block should be treated as an air block\n+\t * by the rest of the code. This method is primarily\n+\t * useful for creating pure logic-blocks that will be invisible\n+\t * to the player and otherwise interact as air would.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the block considered air\n+\t */\n+\tdefault boolean isAir(BlockState state, BlockView world, BlockPos pos) {\n+\t\treturn state.getMaterial() == Material.AIR;\n+\t}\n+\n+\t// TODO Call locations: Patches: AbstractTreeFeature*, HugeBrownMushroomFeature*, HugeRedMushroomFeature*\n+\t/**\n+\t * Used during tree growth to determine if newly generated leaves can replace this block.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return true if this block can be replaced by growing leaves.\n+\t */\n+\tdefault boolean canBeReplacedByLeaves(BlockState state, CollisionView world, BlockPos pos) {\n+\t\treturn isAir(state, world, pos) || state.matches(BlockTags.LEAVES);\n+\t}\n+\n+\t// TODO Call locations: Patches: AbstractTreeFeature*\n+\t/**\n+\t * Used during tree growth to determine if newly generated logs can replace this block.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return true if this block can be replaced by growing leaves.\n+\t */\n+\tdefault boolean canBeReplacedByLogs(BlockState state, CollisionView world, BlockPos pos) {\n+\t\treturn (isAir(state, world, pos) || state.matches(BlockTags.LEAVES)) || this == Blocks.GRASS_BLOCK || Block.isNaturalDirt(getBlock())\n+\t\t\t\t|| getBlock().matches(BlockTags.LOGS) || getBlock().matches(BlockTags.SAPLINGS) || this == Blocks.VINE;\n+\t}\n+\n+\t// This comment is here to note that I didn't miss getting the calls for this method, there just aren't any.\n+\t/**\n+\t * Determines if the current block is replaceable by ore veins during world generation.\n+\t *\n+\t * @param state  The current state\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param target The generic target block the gen is looking for, usually stone\n+\t *               for overworld generation, and netherrack for the nether.\n+\t * @return True to allow this block to be replaced by a ore\n+\t */\n+\tdefault boolean isReplaceableOreGen(BlockState state, CollisionView world, BlockPos pos, Predicate<BlockState> target) {\n+\t\treturn target.test(state);\n+\t}\n+\n+\t// TODO Call locations: Patches: Explosion*\n+\t/**\n+\t * Location sensitive version of getExplosionResistance.\n+\t *\n+\t * @param state     The current state\n+\t * @param world     The current world\n+\t * @param pos       Block position in world\n+\t * @param exploder  The entity that caused the explosion, can be null\n+\t * @param explosion The explosion\n+\t * @return The amount of the explosion absorbed.\n+\t */\n+\tdefault float getExplosionResistance(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity exploder, Explosion explosion) {\n+\t\treturn this.getBlock().getBlastResistance();\n+\t}\n+\n+\t// TODO Call locations: Patches: RedstoneWireBlock*\n+\t/**\n+\t * Determine if this block can make a redstone connection on the side provided,\n+\t * Useful to control which sides are inputs and outputs for redstone wires.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param side  The side that is trying to make the connection, CAN BE NULL\n+\t * @return True to make the connection\n+\t */\n+\tdefault boolean canConnectRedstone(BlockState state, BlockView world, BlockPos pos, @Nullable Direction side) {\n+\t\treturn state.emitsRedstonePower() && side != null;\n+\t}\n+\n+\t// TODO Call locations: Forge classes: ForgeHooks\n+\t/**\n+\t * Called when a user uses the creative pick block button on this block.\n+\t *\n+\t * @param state  The current state\n+\t * @param target The full target the player is looking at\n+\t * @param world  The world the block is in\n+\t * @param pos    The block's position\n+\t * @param player The player picking the block\n+\t * @return An {@link ItemStack} to add to the player's inventory, empty itemstack if nothing should be added.\n+\t */\n+\tdefault ItemStack getPickBlock(BlockState state, HitResult target, BlockView world, BlockPos pos, PlayerEntity player) {\n+\t\treturn this.getBlock().getPickStack(world, pos, state);\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Forge javadoc only said where this was used. It isn't used anywhere, so there's really no way to document this.\n+\t */\n+\tdefault boolean isFoliage(BlockState state, CollisionView world, BlockPos pos) {\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: LivingEntity*\n+\t/**\n+\t * Allows a block to override the standard {@link LivingEntity#fall} particles.\n+\t * This is a server side method that spawns particles with\n+\t * {@link ServerWorld#spawnParticles}\n+\t *\n+\t * @param state1            This block's state.\n+\t * @param serverworld       The {@link ServerWorld} this block is in.\n+\t * @param pos               The position of the block.\n+\t * @param state2            This block's state, but again.\n+\t * @param entity            The entity that landed on the block\n+\t * @param numberOfParticles Number of particles the vanilla version of this method would spawn.\n+\t * @return True to prevent vanilla landing particles from spawning\n+\t */\n+\tdefault boolean addLandingEffects(BlockState state1, ServerWorld serverworld, BlockPos pos, BlockState state2, LivingEntity entity, int numberOfParticles) {\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: Entity*\n+\t/**\n+\t * Allows a block to override the standard vanilla running particles.\n+\t * This is called from {@link Entity#spawnSprintingParticles} and is called both\n+\t * client and server side, it's up to the implementor to client check / server check.\n+\t * By default vanilla spawns particles only on the client and the server methods no-op.\n+\t *\n+\t * @param state  The state of this block.\n+\t * @param world  The world.\n+\t * @param pos    The position at the entity's feet.\n+\t * @param entity The entity running on the block.\n+\t * @return True to prevent vanilla running particles from spawning.\n+\t */\n+\tdefault boolean addRunningEffects(BlockState state, World world, BlockPos pos, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: ParticleManager*\n+\t/**\n+\t * Spawn a digging particle effect in the world, this is a wrapper\n+\t * around {@link ParticleManager.addBlockBreakParticles} to allow the block more\n+\t * control over the particles.\n+\t *\n+\t * @param state   The current state\n+\t * @param world   The current world\n+\t * @param target  The target the player is looking at {x/y/z/side/sub}\n+\t * @param manager A reference to the current particle manager.\n+\t * @return True to prevent vanilla digging particles form spawning.\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault boolean addHitEffects(BlockState state, World worldObj, HitResult target, ParticleManager manager) {\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: ParticleManager*\n+\t/**\n+\t * Spawn particles for when the block is destroyed. Due to the nature\n+\t * of how this is invoked, the x/y/z locations are not always guaranteed\n+\t * to host your block. So be sure to do proper sanity checks before assuming\n+\t * that the location is this block.\n+\t *\n+\t * @param state   This block's state\n+\t * @param world   The current world\n+\t * @param pos     Position to spawn the particle\n+\t * @param manager A reference to the current particle manager.\n+\t * @return True to prevent vanilla break particles from spawning.\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault boolean addDestroyEffects(BlockState state, World world, BlockPos pos, ParticleManager manager) {\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: AbstractTreeFeature*\n+\t/**\n+\t * Determines if this block can support the passed in plant, allowing it to be planted and grow.\n+\t * Some examples:\n+\t * Reeds check if its a reed, or if its sand/dirt/grass and adjacent to water\n+\t * Cacti checks if its a cacti, or if its sand\n+\t * Nether types check for soul sand\n+\t * Crops check for tilled soil\n+\t * Caves check if it's a solid surface\n+\t * Plains check if its grass or dirt\n+\t * Water check if its still water\n+\t *\n+\t * @param state     The Current state\n+\t * @param world     The current world\n+\t * @param facing    The direction relative to the given position the plant wants to be, typically its UP\n+\t * @param plantable The plant that wants to check\n+\t * @return True to allow the plant to be planted/stay.\n+\t */\n+\tdefault boolean canSustainPlant(BlockState state, BlockView world, BlockPos pos, Direction facing, IPlantable plantable) {\n+\t\tBlockState plant = plantable.getPlant(world, pos.offset(facing));\n+\n+\t\tif (plant.getBlock() == Blocks.CACTUS) {\n+\t\t\treturn this.getBlock() == Blocks.CACTUS || this.getBlock() == Blocks.SAND || this.getBlock() == Blocks.RED_SAND;\n+\t\t}\n+\n+\t\tif (plant.getBlock() == Blocks.SUGAR_CANE && this.getBlock() == Blocks.SUGAR_CANE) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (plantable instanceof PlantBlock && ((PlantBlockAccessor) plantable).invokeCanPlantOnTop(state, world, pos)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tswitch (plantable.getPlantType(world, pos)) {\n+\t\tcase Desert:\n+\t\t\treturn this.getBlock() == Blocks.SAND || this.getBlock() == Blocks.TERRACOTTA || this.getBlock() instanceof GlazedTerracottaBlock;\n+\t\tcase Nether:\n+\t\t\treturn this.getBlock() == Blocks.SOUL_SAND;\n+\t\tcase Crop:\n+\t\t\treturn this.getBlock() == Blocks.FARMLAND;\n+\t\tcase Cave:\n+\t\t\treturn Block.isSideSolidFullSquare(state, world, pos, Direction.UP);\n+\t\tcase Plains:\n+\t\t\treturn this.getBlock() == Blocks.GRASS_BLOCK || Block.isNaturalDirt(this.getBlock()) || this.getBlock() == Blocks.FARMLAND;\n+\t\tcase Water:\n+\t\t\treturn state.getMaterial() == Material.WATER;\n+\t\tcase Beach:\n+\t\t\tboolean isBeach = this.getBlock() == Blocks.GRASS_BLOCK || Block.isNaturalDirt(this.getBlock()) || this.getBlock() == Blocks.SAND;\n+\t\t\tboolean hasWater = (world.getBlockState(pos.east()).getMaterial() == Material.WATER\n+\t\t\t\t\t|| world.getBlockState(pos.west()).getMaterial() == Material.WATER\n+\t\t\t\t\t|| world.getBlockState(pos.north()).getMaterial() == Material.WATER\n+\t\t\t\t\t|| world.getBlockState(pos.south()).getMaterial() == Material.WATER);\n+\t\t\treturn isBeach && hasWater;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: AbstractTreeFeature*\n+\t/**\n+\t * Called when a plant grows on this block.\n+\t * This does not use ForgeDirection, because large/huge trees can be located in non-representable direction,\n+\t * so the source location is specified.\n+\t * Currently this just changes the block to dirt if it was grass.\n+\t *\n+\t * <p>Note: This happens DURING the generation, the generation may not be complete when this is called.\n+\t *\n+\t * @param state  The current state\n+\t * @param world  Current world\n+\t * @param pos    Block position in world\n+\t * @param source Source plant's position in world\n+\t */\n+\tdefault void onPlantGrow(BlockState state, IWorld world, BlockPos pos, BlockPos source) {\n+\t\tif (Block.isNaturalDirt(getBlock())) {\n+\t\t\tworld.setBlockState(pos, Blocks.DIRT.getDefaultState(), 2);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Checks if this soil is fertile, typically this means that growth rates\n+\t * of plants on this soil will be slightly sped up.\n+\t * Only vanilla case is tilledField when it is within range of water.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the soil should be considered fertile.\n+\t */\n+\tdefault boolean isFertile(BlockState state, BlockView world, BlockPos pos) {\n+\t\tif (this.getBlock() == Blocks.FARMLAND) {\n+\t\t\treturn state.get(FarmlandBlock.MOISTURE) > 0;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: BeaconBlockEntity*\n+\t/**\n+\t * Determines if this block can be used as the base of a beacon.\n+\t *\n+\t * @param state  The current state\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param beacon Beacon position in world\n+\t * @return True, to support the beacon, and make it active with this block.\n+\t */\n+\tdefault boolean isBeaconBase(BlockState state, CollisionView world, BlockPos pos, BlockPos beacon) {\n+\t\t// TODO implement actual tag-based functionality\n+\t\treturn this == Blocks.EMERALD_BLOCK || this == Blocks.GOLD_BLOCK || this == Blocks.DIAMOND_BLOCK || this == Blocks.IRON_BLOCK;\n+\t\t// return Tags.Blocks.SUPPORTS_BEACON.contains(state.getBlock());\n+\t}\n+\n+\t// TODO Call locations: Forge classes: BreakEvent*\n+\t/**\n+\t * Gathers how much experience this block drops when broken.\n+\t *\n+\t * @param state     The current state\n+\t * @param world     The world\n+\t * @param pos       Block position\n+\t * @param fortune   Level of fortune on the breaker's tool\n+\t * @param silktouch Level of silk touch on the breaker's tool\n+\t * @return Amount of XP from breaking this block.\n+\t */\n+\tdefault int getExpDrop(BlockState state, CollisionView world, BlockPos pos, int fortune, int silktouch) {\n+\t\treturn 0;\n+\t}\n+\n+\t// TODO Call locations: Patches: PistonBlock\n+\tdefault BlockState rotate(BlockState state, IWorld world, BlockPos pos, BlockRotation direction) {\n+\t\treturn state.rotate(direction);\n+\t}\n+\n+\t// No call locations\n+\t/**\n+\t * Get the rotations that can apply to the block at the specified coordinates. Null means no rotations are possible.\n+\t * Note, this is up to the block to decide. It may not be accurate or representative.\n+\t *\n+\t * @param state The current state\n+\t * @param world The world\n+\t * @param pos   Block position in world\n+\t * @return An array of valid axes to rotate around, or null for none or unknown\n+\t */\n+\t@Nullable\n+\tdefault Direction[] getValidRotations(BlockState state, BlockView world, BlockPos pos) {\n+\t\tfor (Property<?> prop : state.getProperties()) {\n+\t\t\tif ((prop.getName().equals(\"facing\") || prop.getName().equals(\"rotation\")) && prop.getType() == Direction.class) {\n+\t\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\t\tCollection<Direction> values = ((Collection<Direction>) prop.getValues());\n+\t\t\t\treturn values.toArray(new Direction[values.size()]);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\t// TODO Call locations: Patches: EnchantingTableBlock*, EnchantingTableContainer*\n+\t/**\n+\t * Determines the amount of enchanting power this block can provide to an enchanting table.\n+\t *\n+\t * @param world The world\n+\t * @param pos   Block position in world\n+\t * @return The amount of enchanting power this block produces.\n+\t */\n+\tdefault float getEnchantPowerBonus(BlockState state, CollisionView world, BlockPos pos) {\n+\t\treturn this.getBlock() == Blocks.BOOKSHELF ? 1 : 0;\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Re-colors this block in the world.\n+\t *\n+\t * @param state   The current state\n+\t * @param world   The world\n+\t * @param pos     Block position\n+\t * @param facing  ??? (this method has no usages)\n+\t * @param color   Color to recolor to.\n+\t * @return if the block was affected\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tdefault boolean recolorBlock(BlockState state, IWorld world, BlockPos pos, Direction facing, DyeColor color) {\n+\t\tfor (Property<?> prop : state.getProperties()) {\n+\t\t\tif (prop.getName().equals(\"color\") && prop.getType() == DyeColor.class) {\n+\t\t\t\tDyeColor current = (DyeColor) state.get(prop);\n+\n+\t\t\t\tif (current != color && prop.getValues().contains(color)) {\n+\t\t\t\t\tworld.setBlockState(pos, state.with(((Property<DyeColor>) prop), color), 3);\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: World*\n+\t/**\n+\t * Called when a block entity on a side of this block changes is created or is destroyed.\n+\t *\n+\t * @param state    The state of this block\n+\t * @param world    The world\n+\t * @param pos      Block position in world\n+\t * @param neighbor Block position of neighbor\n+\t */\n+\tdefault void onNeighborChange(BlockState state, CollisionView world, BlockPos pos, BlockPos neighbor) {\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Called on an Observer block whenever an update for an Observer is received.\n+\t *\n+\t * @param observerState   The Observer block's state.\n+\t * @param world           The current world.\n+\t * @param observerPos     The Observer block's position.\n+\t * @param changedBlock    The updated block.\n+\t * @param changedBlockPos The updated block's position.\n+\t */\n+\tdefault void observedNeighborChange(BlockState observerState, World world, BlockPos observerPos, Block changedBlock, BlockPos changedBlockPos) {\n+\t}\n+\n+\t// TODO Call locations: Patches: World*\n+\t/**\n+\t * Called to determine whether to allow the a block to handle its own indirect power rather than using the default rules.\n+\t *\n+\t * @param state This block's state\n+\t * @param world The world\n+\t * @param pos   Block position in world\n+\t * @param side  The INPUT side of the block to be powered - ie the opposite of this block's output side\n+\t * @return Whether weak power should be checked normally\n+\t */\n+\tdefault boolean shouldCheckWeakPower(BlockState state, CollisionView world, BlockPos pos, Direction side) {\n+\t\treturn state.isSimpleFullBlock(world, pos);\n+\t}\n+\n+\t// TODO Call locations: Patches: World*\n+\t/**\n+\t * If this block should be notified of weak changes.\n+\t * Weak changes are changes 1 block away through a solid block.\n+\t * Similar to comparators.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return true To be notified of changes\n+\t */\n+\tdefault boolean getWeakChanges(BlockState state, CollisionView world, BlockPos pos) {\n+\t\treturn false;\n+\t}\n+\n+\t/* TODO IForgeBlock#getHarvestTool needs ToolType\n+\t/**\n+\t * Queries the class of tool required to harvest this block, if null is returned\n+\t * we assume that anything can harvest this block.\n+\t *\n+\tToolType getHarvestTool(BlockState state);*/\n+\n+\t// TODO Call locations: Patches: PickaxeItem*, Forge classes: ForgeHooks*\n+\t/**\n+\t * Queries the harvest level of this block.\n+\t *\n+\t * @return Harvest level, or -1 if tool is not required.\n+\t */\n+\tint getHarvestLevel(BlockState state);\n+\n+\t/* TODO IForgeBlock#isToolEffective needs ToolType\n+\t/**\n+\t * Checks if the specified tool type is efficient on this block,\n+\t * meaning that it digs at full speed.\n+\t *\n+\tdefault boolean isToolEffective(BlockState state, ToolType tool) {\n+\t\tif (tool == ToolType.PICKAXE && (this.getBlock() == Blocks.REDSTONE_ORE || this.getBlock() == Blocks.REDSTONE_LAMP || this.getBlock() == Blocks.OBSIDIAN)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn tool == getHarvestTool(state);\n+\t}*/\n+\n+\t// TODO Call locations: Forge classes: ForgeHooksClient\n+\t/**\n+\t * Can return IExtendedBlockState.\n+\t */\n+\tdefault BlockState getExtendedState(BlockState state, BlockView world, BlockPos pos) {\n+\t\treturn state;\n+\t}\n+\n+\t// TODO Call locations: Patches: ChunkRenderer*\n+\t/**\n+\t * Queries if this block should render in a given layer.\n+\t * A custom {@link net.minecraft.client.render.model.BakedModel} can use {@link net.minecraftforge.client.MinecraftForgeClient#getRenderLayer()} to alter the model based on layer.\n+\t */\n+\tdefault boolean canRenderInLayer(BlockState state, RenderLayer layer) {\n+\t\treturn this.getBlock().getRenderLayer() == layer;\n+\t}\n+\n+\t// TODO Call locations: Patches: ClientPlayerInteractionManager*, WorldRenderer*, Entity*, LivingEntity*, FoxEntity*, HorseBaseEntity*, LlamaEntity*, BlockItem*\n+\t/**\n+\t * Sensitive version of {@link Block#getSoundType}.\n+\t *\n+\t * @param state  The state\n+\t * @param world  The world\n+\t * @param pos    The position. Note that the world may not necessarily have {@code state} here!\n+\t * @param entity The entity that is breaking/stepping on/placing/hitting/falling on this block, or null if no entity is in this context\n+\t * @return A {@link BlockSoundGroup} to use\n+\t */\n+\tdefault BlockSoundGroup getSoundType(BlockState state, CollisionView world, BlockPos pos, @Nullable Entity entity) {\n+\t\treturn this.getBlock().getSoundGroup(state);\n+\t}\n+\n+\t// TODO Call locations: Patches: BeaconBlockEntity*\n+\t/**\n+\t * @param state     The state\n+\t * @param world     The world\n+\t * @param pos       The position of this state\n+\t * @param beaconPos The position of the beacon\n+\t * @return A float RGB [0.0, 1.0] array to be averaged with a beacon's existing beam color, or null to do nothing to the beam\n+\t */\n+\t@Nullable\n+\tdefault float[] getBeaconColorMultiplier(BlockState state, CollisionView world, BlockPos pos, BlockPos beaconPos) {\n+\t\tif (getBlock() instanceof Stainable) {\n+\t\t\treturn ((Stainable) getBlock()).getColor().getColorComponents();\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Use this to change the fog color used when the entity is \"inside\" a material.\n+\t * {@link Vec3d} is used here as \"r/g/b\" 0 - 1 values.\n+\t *\n+\t * @param state         The state at the entity viewport.\n+\t * @param world         The world.\n+\t * @param pos           The position at the entity viewport.\n+\t * @param entity        the entity\n+\t * @param originalColor The current fog color, You are not expected to use this, Return as the default if applicable.\n+\t * @return The new fog color.\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault Vec3d getFogColor(BlockState state, CollisionView world, BlockPos pos, Entity entity, Vec3d originalColor, float partialTicks) {\n+\t\tif (state.getMaterial() == Material.WATER) {\n+\t\t\tfloat visibility = 0.0F;\n+\n+\t\t\tif (entity instanceof LivingEntity) {\n+\t\t\t\tLivingEntity ent = (LivingEntity) entity;\n+\t\t\t\tvisibility = (float) EnchantmentHelper.getRespiration(ent) * 0.2F;\n+\n+\t\t\t\tif (ent.hasStatusEffect(StatusEffects.WATER_BREATHING)) {\n+\t\t\t\t\tvisibility = visibility * 0.3F + 0.6F;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn new Vec3d(0.02F + visibility, 0.02F + visibility, 0.2F + visibility);\n+\t\t} else if (state.getMaterial() == Material.LAVA) {\n+\t\t\treturn new Vec3d(0.6F, 0.1F, 0.0F);\n+\t\t}\n+\n+\t\treturn originalColor;\n+\t}\n+\n+\t// TODO Call locations: Patches: Camera*\n+\t/**\n+\t * Used to determine the state 'viewed' by an entity.\n+\t * Can be used by fluid blocks to determine if the viewpoint is within the fluid or not.\n+\t *\n+\t * @param state     the state\n+\t * @param world     the world\n+\t * @param pos       the position\n+\t * @param viewpoint the viewpoint\n+\t * @return the block state that should be 'seen'\n+\t */\n+\tdefault BlockState getStateAtViewpoint(BlockState state, BlockView world, BlockPos pos, Vec3d viewpoint) {\n+\t\treturn state;\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Gets the {@link BlockState} to place.\n+\t *\n+\t * @param state  ??? (presumably this block's state, but it has not yet been placed?)\n+\t * @param facing The side the block is being placed on\n+\t * @param state2 ???\n+\t * @param world  The world the block is being placed in\n+\t * @param pos1   ??? (presumably where it's being placed)\n+\t * @param pos2   ???\n+\t * @param hand   The hand the block is being placed from\n+\t * @return The state to be placed in the world\n+\t */\n+\tdefault BlockState getStateForPlacement(BlockState state, Direction facing, BlockState state2, IWorld world, BlockPos pos1, BlockPos pos2, Hand hand) {\n+\t\treturn this.getBlock().getStateForNeighborUpdate(state, facing, state2, world, pos1, pos2);\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Determines if another block can connect to this block.\n+\t *\n+\t * @param state  This block's state\n+\t * @param world  The current world\n+\t * @param pos    The position of this block\n+\t * @param facing The side the connecting block is on\n+\t * @return True to allow another block to connect to this block\n+\t */\n+\tdefault boolean canBeConnectedTo(BlockState state, BlockView world, BlockPos pos, Direction facing) {\n+\t\treturn false;\n+\t}\n+\n+\t// TODO Call locations: Patches: LandPathNodeMaker, LandPathNodeMaker*\n+\t/**\n+\t * Get the {@code PathNodeType} for this block. Return {@code null} for vanilla behavior.\n+\t *\n+\t * @return the PathNodeType\n+\t */\n+\t@Nullable\n+\tdefault PathNodeType getAiPathNodeType(BlockState state, BlockView world, BlockPos pos, @Nullable MobEntity entity) {\n+\t\treturn ((IForgeBlockState) state).isBurning(world, pos) ? PathNodeType.DAMAGE_FIRE : null;\n+\t}\n+\n+\t// TODO Call locations: Patches: PistonBlockEntity, PistonHandler*\n+\t/**\n+\t * @param state The state\n+\t * @return true if the block is sticky block which used for pull or push adjacent blocks (use by piston)\n+\t */\n+\tdefault boolean isStickyBlock(BlockState state) {\n+\t\treturn state.getBlock() == Blocks.SLIME_BLOCK;\n+\t}\n+\n+\t// TODO Call locations: Patches: FireBlock*\n+\t/**\n+\t * Chance that fire will spread and consume this block.\n+\t * 300 being a 100% chance, 0, being a 0% chance.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The face that the fire is coming from\n+\t * @return A number ranging from 0 to 300 relating used to determine if the block will be consumed by fire\n+\t */\n+\tdefault int getFlammability(BlockState state, BlockView world, BlockPos pos, Direction face) {\n+\t\treturn ((FireBlockAccessor) Blocks.FIRE).invokeGetSpreadChance(state);\n+\t}\n+\n+\t// TODO Call locations: Patches: FireBlock*, DispenserBehavior*\n+\t/**\n+\t * Called when fire is updating, checks if a block face can catch fire.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The face that the fire is coming from\n+\t * @return True if the face can be on fire, false otherwise.\n+\t */\n+\tdefault boolean isFlammable(BlockState state, BlockView world, BlockPos pos, Direction face) {\n+\t\treturn ((IForgeBlockState) state).getFlammability(world, pos, face) > 0;\n+\t}\n+\n+\t// TODO Call locations: Patches: TNTBlock, FireBlock*, DispenserBehavior*\n+\t/**\n+\t * If the block is flammable, this is called when it gets lit on fire.\n+\t *\n+\t * @param state   The current state\n+\t * @param world   The current world\n+\t * @param pos     Block position in world\n+\t * @param face    The face that the fire is coming from\n+\t * @param igniter The entity that lit the fire\n+\t */\n+\tdefault void catchFire(BlockState state, World world, BlockPos pos, @Nullable Direction face, @Nullable LivingEntity igniter) {\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Called when fire is updating on a neighbor block.\n+\t * The higher the number returned, the faster fire will spread around this block.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The face that the fire is coming from\n+\t * @return A number that is used to determine the speed of fire growth around the block\n+\t */\n+\tdefault int getFireSpreadSpeed(BlockState state, BlockView world, BlockPos pos, Direction face) {\n+\t\treturn ((FireBlockAccessor) Blocks.FIRE).invokeGetBurnChance(state);\n+\t}\n+\n+\t// TODO Call locations: Patches: FireBlock*\n+\t/**\n+\t * Currently only called by fire when it is on top of this block.\n+\t * Returning true will prevent the fire from naturally dying during updating.\n+\t * Also prevents firing from dying from rain.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param side  The face that the fire is coming from\n+\t * @return True if this block sustains fire, meaning it will never go out.\n+\t */\n+\tdefault boolean isFireSource(BlockState state, BlockView world, BlockPos pos, Direction side) {\n+\t\tif (side != Direction.UP) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (getBlock() == Blocks.NETHERRACK || getBlock() == Blocks.MAGMA_BLOCK) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn world instanceof CollisionView && ((CollisionView) world).getDimension() instanceof TheEndDimension && getBlock() == Blocks.BEDROCK;\n+\t}\n+\n+\t// TODO Call locations: Patches: WitherEntity*, WitherSkullEntity*, Forge classes: ForgeHooks*\n+\t/**\n+\t * Determines if this block is can be destroyed by the specified entities normal behavior.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True to allow the entity to destroy this block\n+\t */\n+\tdefault boolean canEntityDestroy(BlockState state, BlockView world, BlockPos pos, Entity entity) {\n+\t\tif (entity instanceof EnderDragonEntity) {\n+\t\t\treturn !BlockTags.DRAGON_IMMUNE.contains(this.getBlock());\n+\t\t} else if ((entity instanceof WitherEntity) || (entity instanceof WitherSkullEntity)) {\n+\t\t\treturn ((IForgeBlockState) state).isAir(world, pos) || WitherEntity.canDestroy(state);\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t// No call locations.\n+\t/**\n+\t * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit.\n+\t *\n+\t * @param state    The current state\n+\t * @param world    The current world\n+\t * @param pos      Block position in world\n+\t * @param start    The start vector\n+\t * @param end      The end vector\n+\t * @param original The original result from {@link Block#collisionRayTrace(IBlockState, World, BlockPos, Vec3d, Vec3d)}\n+\t * @return A result that suits your block\n+\t */\n+\t@Nullable\n+\tdefault HitResult getRayTraceResult(BlockState state, World world, BlockPos pos, Vec3d start, Vec3d end, HitResult original) {\n+\t\treturn original;\n+\t}\n+\n+\t// TODO Call locations: Patches: Explosion*\n+\t/**\n+\t * Determines if this block should drop loot when exploded.\n+\t */\n+\tdefault boolean canDropFromExplosion(BlockState state, BlockView world, BlockPos pos, Explosion explosion) {\n+\t\treturn state.getBlock().shouldDropItemsOnExplosion(explosion);\n+\t}\n+\n+\t// Call locations: Patches: DebugHud (no todo because this works fine without it -- this method should never be overridden anyway.)\n+\t/**\n+\t * Retrieves a list of tags names this is known to be associated with.\n+\t * This should be used in favor of {@link net.minecraft.tag.TagContainer#getTagsFor}, as this caches the result.\n+\t */\n+\tSet<Identifier> getTags();\n+\n+\t// TODO Call locations: Patches: Explosion*\n+\t/**\n+\t * Called when the block is destroyed by an explosion.\n+\t * Useful for allowing the block to take into account block entities,\n+\t * state, etc. when exploded, before it is removed.\n+\t *\n+\t * @param world     The current world\n+\t * @param pos       Block position in world\n+\t * @param explosion The explosion instance affecting the block\n+\t */\n+\tdefault void onBlockExploded(BlockState state, World world, BlockPos pos, Explosion explosion) {\n+\t\tworld.setBlockState(pos, Blocks.AIR.getDefaultState(), 3);\n+\t\tgetBlock().onDestroyedByExplosion(world, pos, explosion);\n+\t}\n+\n+\t// TODO Call locations: Patches: Entity*, ServerPlayerEntity*\n+\t/**\n+\t * Determines if this block's collision box should be treated as though it can extend above its block space.\n+\t * Use this to replicate fence and wall behavior.\n+\t */\n+\tdefault boolean collisionExtendsVertically(BlockState state, BlockView world, BlockPos pos, Entity collidingEntity) {\n+\t\treturn getBlock().matches(BlockTags.FENCES) || getBlock().matches(BlockTags.WALLS) || getBlock() instanceof FenceGateBlock;\n+\t}\n+}", "originalCommit": "e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5OTY3OQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443899679", "bodyText": "Let me know when the force-push is done and I'll review", "author": "ZNixian", "createdAt": "2020-06-23T00:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4ODY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4ODc3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443888778", "bodyText": "Same issue here", "author": "famous1622", "createdAt": "2020-06-23T00:03:52Z", "path": "patchwork-extensions-block/src/main/java/net/minecraftforge/common/extensions/IForgeBlockState.java", "diffHunk": "@@ -1,845 +1,846 @@\n-/*\r\n- * Minecraft Forge, Patchwork Project\r\n- * Copyright (c) 2016-2020, 2019-2020\r\n- *\r\n- * This library is free software; you can redistribute it and/or\r\n- * modify it under the terms of the GNU Lesser General Public\r\n- * License as published by the Free Software Foundation version 2.1\r\n- * of the License.\r\n- *\r\n- * This library is distributed in the hope that it will be useful,\r\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n- * Lesser General Public License for more details.\r\n- *\r\n- * You should have received a copy of the GNU Lesser General Public\r\n- * License along with this library; if not, write to the Free Software\r\n- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n- */\r\n-\r\n-package net.minecraftforge.common.extensions;\r\n-\r\n-import java.util.Optional;\r\n-import java.util.function.Predicate;\r\n-\r\n-import javax.annotation.Nullable;\r\n-\r\n-import net.minecraft.block.Block;\r\n-import net.minecraft.block.BlockEntityProvider;\r\n-import net.minecraft.block.BlockState;\r\n-import net.minecraft.block.entity.BlockEntity;\r\n-import net.minecraft.client.particle.ParticleManager;\r\n-import net.minecraft.client.render.RenderLayer;\r\n-import net.minecraft.entity.Entity;\r\n-import net.minecraft.entity.EntityType;\r\n-import net.minecraft.entity.LivingEntity;\r\n-import net.minecraft.entity.SpawnRestriction.Location;\r\n-import net.minecraft.entity.ai.pathing.PathNodeType;\r\n-import net.minecraft.entity.mob.MobEntity;\r\n-import net.minecraft.entity.player.PlayerEntity;\r\n-import net.minecraft.fluid.FluidState;\r\n-import net.minecraft.item.ItemStack;\r\n-import net.minecraft.server.world.ServerWorld;\r\n-import net.minecraft.sound.BlockSoundGroup;\r\n-import net.minecraft.util.BlockRotation;\r\n-import net.minecraft.util.DyeColor;\r\n-import net.minecraft.util.Hand;\r\n-import net.minecraft.util.hit.HitResult;\r\n-import net.minecraft.util.math.BlockPos;\r\n-import net.minecraft.util.math.Direction;\r\n-import net.minecraft.util.math.Vec3d;\r\n-import net.minecraft.world.BlockRenderView;\r\n-import net.minecraft.world.BlockView;\r\n-import net.minecraft.world.CollisionView;\r\n-import net.minecraft.world.IWorld;\r\n-import net.minecraft.world.World;\r\n-import net.minecraft.world.explosion.Explosion;\r\n-\r\n-import net.fabricmc.api.EnvType;\r\n-import net.fabricmc.api.Environment;\r\n-\r\n-public interface IForgeBlockState {\r\n-\tdefault BlockState getBlockState() {\r\n-\t\treturn (BlockState) this;\r\n-\t}\r\n-\r\n-\tdefault IForgeBlock patchwork$getForgeBlock() {\r\n-\t\treturn (IForgeBlock) getBlockState().getBlock();\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Gets the slipperiness at the given location of this state. Normally\r\n-\t * between 0 and 1.\r\n-\t *\r\n-\t * <p>Note that entities may reduce slipperiness by a certain factor of their own;\r\n-\t * for {@link LivingEntity}, this is {@code .91}.\r\n-\t * {@link net.minecraft.entity.ItemEntity} uses {@code .98}, and\r\n-\t * {@link net.minecraft.entity.projectile.FishingBobberEntity} uses {@code .92}.\r\n-\t *\r\n-\t * @param world  the world\r\n-\t * @param pos    the position in the world\r\n-\t * @param entity the entity in question\r\n-\t * @return the factor by which the entity's motion should be multiplied\r\n-\t */\r\n-\tdefault float getSlipperiness(CollisionView world, BlockPos pos, @Nullable Entity entity) {\r\n-\t\treturn patchwork$getForgeBlock().getSlipperiness(getBlockState(), world, pos, entity);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Get a light value for this block, taking into account the state and coordinates, normal ranges are between 0 and 15.\r\n-\t */\r\n-\tdefault int getLightValue(BlockRenderView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().getLightValue(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Checks if a player or entity can use this block to 'climb' like a ladder.\r\n-\t *\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param entity The entity trying to use the ladder, CAN be null.\r\n-\t * @return True if the block should act like a ladder\r\n-\t */\r\n-\tdefault boolean isLadder(CollisionView world, BlockPos pos, LivingEntity entity) {\r\n-\t\treturn patchwork$getForgeBlock().isLadder(getBlockState(), world, pos, entity);\r\n-\t}\r\n-\r\n-\t// deprecated for removal in 1.15, don't bother implementing\r\n-\t/**\r\n-\t * Check if the face of a block should block rendering.\r\n-\t *\r\n-\t * <p>Faces which are fully opaque should return true, faces with transparency\r\n-\t * or faces which do not span the full size of the block should return false.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The side to check\r\n-\t * @return True if the block is opaque on the specified side.\r\n-\t * @deprecated This is no longer used for rendering logic.\r\n-\t */\r\n-\t@Deprecated\r\n-\tdefault boolean doesSideBlockRendering(BlockRenderView world, BlockPos pos, Direction face) {\r\n-\t\treturn patchwork$getForgeBlock().doesSideBlockRendering(getBlockState(), world, pos, face);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called throughout the code as a replacement for {@code block instanceof} {@link BlockEntityProvider}.\r\n-\t * Allows for blocks to have a block entity conditionally based on block state.\r\n-\t *\r\n-\t * <p>Return true from this function to specify this block has a block entity.\r\n-\t *\r\n-\t * @return True if block has a block entity, false otherwise\r\n-\t */\r\n-\tdefault boolean hasTileEntity() {\r\n-\t\treturn patchwork$getForgeBlock().hasTileEntity(getBlockState());\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called throughout the code as a replacement for {@link BlockEntityProvider#createBlockEntity(BlockView)}\r\n-\t * Return the same thing you would from that function.\r\n-\t * This will fall back to {@link BlockEntityProvider#createBlockEntity(BlockView)} if this block is a {@link BlockEntityProvider}\r\n-\t *\r\n-\t * @param world The world to create the BE in\r\n-\t * @return An instance of a class extending {@link BlockEntity}\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault BlockEntity createTileEntity(BlockView world) {\r\n-\t\treturn patchwork$getForgeBlock().createTileEntity(getBlockState(), world);\r\n-\t}\r\n-\r\n-\t/* TODO IForgeBlockState#canHarvestBlock indirectly requires ToolType\r\n-\t/**\r\n-\t * Determines if the player can harvest this block, obtaining it's drops when the block is destroyed.\r\n-\t *\r\n-\t * @param world  The current world\r\n-\t * @param pos    The block's current position\r\n-\t * @param player The player damaging the block\r\n-\t * @return True to spawn the drops\r\n-\t *\r\n-\tdefault boolean canHarvestBlock(BlockView world, BlockPos pos, PlayerEntity player) {\r\n-\t\treturn patchwork$getForgeBlock().canHarvestBlock(getBlockState(), world, pos, player);\r\n-\t}*/\r\n-\r\n-\t/**\r\n-\t * Called when a player removes a block.  This is responsible for\r\n-\t * actually destroying the block, and the block is intact at time of call.\r\n-\t * This is called regardless of whether the player can harvest the block or\r\n-\t * not.\r\n-\t *\r\n-\t * <p>Return true if the block is actually destroyed.\r\n-\t *\r\n-\t * <p>Note: When used in multiplayer, this is called on both client and\r\n-\t * server sides!\r\n-\t *\r\n-\t * @param world       The current world\r\n-\t * @param pos         Block position in world\r\n-\t * @param player      The player damaging the block, may be null\r\n-\t * @param willHarvest True if {@link Block#onBroken(IWorld, BlockPos, BlockState)} will be called after this if this method returns true.\r\n-\t *                    Can be useful to delay the destruction of block entities till after onBroken\r\n-\t * @param fluid       The current fluid state at current position\r\n-\t * @return True if the block is actually destroyed.\r\n-\t */\r\n-\tdefault boolean removedByPlayer(World world, BlockPos pos, PlayerEntity player, boolean willHarvest, FluidState fluid) {\r\n-\t\treturn patchwork$getForgeBlock().removedByPlayer(getBlockState(), world, pos, player, willHarvest, fluid);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if this block is classified as a Bed, Allowing\r\n-\t * players to sleep in it, though the block has to specifically\r\n-\t * perform the sleeping functionality in it's activated event.\r\n-\t *\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param player The player or camera entity, null in some cases.\r\n-\t * @return True to treat this as a bed\r\n-\t */\r\n-\tdefault boolean isBed(BlockView world, BlockPos pos, @Nullable LivingEntity player) {\r\n-\t\treturn patchwork$getForgeBlock().isBed(getBlockState(), world, pos, player);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if a specified mob type can spawn on this block, returning false will\r\n-\t * prevent any mob from spawning on the block.\r\n-\t *\r\n-\t * @param world        The current world\r\n-\t * @param pos          Block position in world\r\n-\t * @param restriction  The location spawn restriction\r\n-\t * @param entityType   The type of entity attempting to spawn\r\n-\t * @return True to allow a mob of the specified category to spawn, false to prevent it.\r\n-\t */\r\n-\tdefault boolean canCreatureSpawn(CollisionView world, BlockPos pos, Location restriction, EntityType<?> entityType) {\r\n-\t\treturn patchwork$getForgeBlock().canCreatureSpawn(getBlockState(), world, pos, restriction, entityType);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the position that the sleeper is moved to upon\r\n-\t * waking up, or respawning at the bed.\r\n-\t *\r\n-\t * @param entityType the sleeper's entity type\r\n-\t * @param world      The current world\r\n-\t * @param pos        Block position in world\r\n-\t * @param sleeper    The sleeper or camera entity, null in some cases.\r\n-\t * @return The spawn position\r\n-\t */\r\n-\tdefault Optional<Vec3d> getBedSpawnPosition(EntityType<?> type, CollisionView world, BlockPos pos, @Nullable LivingEntity sleeper) {\r\n-\t\treturn patchwork$getForgeBlock().getBedSpawnPosition(type, getBlockState(), world, pos, sleeper);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when a user either starts or stops sleeping in the bed.\r\n-\t *\r\n-\t * @param world    The current world\r\n-\t * @param pos      Block position in world\r\n-\t * @param sleeper  The sleeper or camera entity, null in some cases.\r\n-\t * @param occupied True if we are occupying the bed, or false if they are stopping use of the bed\r\n-\t */\r\n-\tdefault void setBedOccupied(CollisionView world, BlockPos pos, LivingEntity sleeper, boolean occupied) {\r\n-\t\tpatchwork$getForgeBlock().setBedOccupied(getBlockState(), world, pos, sleeper, occupied);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Returns the direction of the block. Same values that\r\n-\t * are returned by {@link net.minecraft.block.FacingBlock}. Called every frame tick for every living entity. Be VERY fast.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return Bed direction\r\n-\t */\r\n-\tdefault Direction getBedDirection(CollisionView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().getBedDirection(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if the current block is the foot half of the bed.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the current block is the foot side of a bed.\r\n-\t */\r\n-\tdefault boolean isBedFoot(CollisionView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().isBedFoot(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when a leaf should start its decay process.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t */\r\n-\tdefault void beginLeaveDecay(CollisionView world, BlockPos pos) {\r\n-\t\tpatchwork$getForgeBlock().beginLeaveDecay(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines this block should be treated as an air block\r\n-\t * by the rest of the code. This method is primarily\r\n-\t * useful for creating pure logic-blocks that will be invisible\r\n-\t * to the player and otherwise interact as air would.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the block considered air\r\n-\t */\r\n-\tdefault boolean isAir(BlockView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().isAir(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Used during tree growth to determine if newly generated leaves can replace this block.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return true if this block can be replaced by growing leaves.\r\n-\t */\r\n-\tdefault boolean canBeReplacedByLeaves(CollisionView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().canBeReplacedByLeaves(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Used during tree growth to determine if newly generated logs can replace this block.\r\n-\t *\r\n-\t * @param state The current state\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return true if this block can be replaced by growing leaves.\r\n-\t */\r\n-\tdefault boolean canBeReplacedByLogs(CollisionView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().canBeReplacedByLogs(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if the current block is replaceable by ore veins during world generation.\r\n-\t *\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param target The generic target block the gen is looking for, usually stone\r\n-\t *               for overworld generation, and netherrack for the nether.\r\n-\t * @return True to allow this block to be replaced by a ore\r\n-\t */\r\n-\tdefault boolean isReplaceableOreGen(CollisionView world, BlockPos pos, Predicate<BlockState> target) {\r\n-\t\treturn patchwork$getForgeBlock().isReplaceableOreGen(getBlockState(), world, pos, target);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Location sensitive version of getExplosionResistance.\r\n-\t *\r\n-\t * @param world     The current world\r\n-\t * @param pos       Block position in world\r\n-\t * @param exploder  The entity that caused the explosion, can be null\r\n-\t * @param explosion The explosion\r\n-\t * @return The amount of the explosion absorbed.\r\n-\t */\r\n-\tdefault float getExplosionResistance(CollisionView world, BlockPos pos, @Nullable Entity exploder, Explosion explosion) {\r\n-\t\treturn patchwork$getForgeBlock().getExplosionResistance(getBlockState(), world, pos, exploder, explosion);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determine if this block can make a redstone connection on the side provided,\r\n-\t * Useful to control which sides are inputs and outputs for redstone wires.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param side  The side that is trying to make the connection, CAN BE NULL\r\n-\t * @return True to make the connection\r\n-\t */\r\n-\tdefault boolean canConnectRedstone(BlockView world, BlockPos pos, @Nullable Direction side) {\r\n-\t\treturn patchwork$getForgeBlock().canConnectRedstone(getBlockState(), world, pos, side);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when a user uses the creative pick block button on this block.\r\n-\t *\r\n-\t * @param target The full target the player is looking at\r\n-\t * @param world  The world the block is in\r\n-\t * @param pos    The block's position\r\n-\t * @param player The player picking the block\r\n-\t * @return An {@link ItemStack} to add to the player's inventory, empty itemstack if nothing should be added.\r\n-\t */\r\n-\tdefault ItemStack getPickBlock(HitResult target, BlockView world, BlockPos pos, PlayerEntity player) {\r\n-\t\treturn patchwork$getForgeBlock().getPickBlock(getBlockState(), target, world, pos, player);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Forge javadoc only said where this was used. It isn't used anywhere, so there's really no way to document this.\r\n-\t */\r\n-\tdefault boolean isFoliage(CollisionView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().isFoliage(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Allows a block to override the standard {@link LivingEntity#fall} particles.\r\n-\t * This is a server side method that spawns particles with\r\n-\t * {@link ServerWorld#spawnParticles}\r\n-\t *\r\n-\t * @param serverworld       The {@link ServerWorld} this block is in.\r\n-\t * @param pos               The position of the block.\r\n-\t * @param state2            This block's state, but again.\r\n-\t * @param entity            The entity that landed on the block\r\n-\t * @param numberOfParticles Number of particles the vanilla version of this method would spawn.\r\n-\t * @return True to prevent vanilla landing particles from spawning\r\n-\t */\r\n-\tdefault boolean addLandingEffects(ServerWorld worldserver, BlockPos pos, BlockState state2, LivingEntity entity, int numberOfParticles) {\r\n-\t\treturn patchwork$getForgeBlock().addLandingEffects(getBlockState(), worldserver, pos, state2, entity, numberOfParticles);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Allows a block to override the standard vanilla running particles.\r\n-\t * This is called from {@link Entity#spawnSprintingParticles} and is called both\r\n-\t * client and server side, it's up to the implementor to client check / server check.\r\n-\t * By default vanilla spawns particles only on the client and the server methods no-op.\r\n-\t *\r\n-\t * @param world  The world.\r\n-\t * @param pos    The position at the entity's feet.\r\n-\t * @param entity The entity running on the block.\r\n-\t * @return True to prevent vanilla running particles from spawning.\r\n-\t */\r\n-\tdefault boolean addRunningEffects(World world, BlockPos pos, Entity entity) {\r\n-\t\treturn patchwork$getForgeBlock().addRunningEffects(getBlockState(), world, pos, entity);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Spawn a digging particle effect in the world, this is a wrapper\r\n-\t * around {@link ParticleManager.addBlockBreakParticles} to allow the block more\r\n-\t * control over the particles.\r\n-\t *\r\n-\t * @param world   The current world\r\n-\t * @param target  The target the player is looking at {x/y/z/side/sub}\r\n-\t * @param manager A reference to the current particle manager.\r\n-\t * @return True to prevent vanilla digging particles form spawning.\r\n-\t */\r\n-\t@Environment(EnvType.CLIENT)\r\n-\tdefault boolean addHitEffects(World world, HitResult target, ParticleManager manager) {\r\n-\t\treturn patchwork$getForgeBlock().addHitEffects(getBlockState(), world, target, manager);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Spawn particles for when the block is destroyed. Due to the nature\r\n-\t * of how this is invoked, the x/y/z locations are not always guaranteed\r\n-\t * to host your block. So be sure to do proper sanity checks before assuming\r\n-\t * that the location is this block.\r\n-\t *\r\n-\t * @param world   The current world\r\n-\t * @param pos     Position to spawn the particle\r\n-\t * @param manager A reference to the current particle manager.\r\n-\t * @return True to prevent vanilla break particles from spawning.\r\n-\t */\r\n-\t@Environment(EnvType.CLIENT)\r\n-\tdefault boolean addDestroyEffects(World world, BlockPos pos, ParticleManager manager) {\r\n-\t\treturn patchwork$getForgeBlock().addDestroyEffects(getBlockState(), world, pos, manager);\r\n-\t}\r\n-\r\n-\t/* TODO IForgeBlockState#canSustainPlant requires IPlantable\r\n-\t/**\r\n-\t * Determines if this block can support the passed in plant, allowing it to be planted and grow.\r\n-\t * Some examples:\r\n-\t * Reeds check if its a reed, or if its sand/dirt/grass and adjacent to water\r\n-\t * Cacti checks if its a cacti, or if its sand\r\n-\t * Nether types check for soul sand\r\n-\t * Crops check for tilled soil\r\n-\t * Caves check if it's a solid surface\r\n-\t * Plains check if its grass or dirt\r\n-\t * Water check if its still water\r\n-\t *\r\n-\t * @param world     The current world\r\n-\t * @param facing    The direction relative to the given position the plant wants to be, typically its UP\r\n-\t * @param plantable The plant that wants to check\r\n-\t * @return True to allow the plant to be planted/stay.\r\n-\t *\r\n-\tdefault boolean canSustainPlant(BlockView world, BlockPos pos, Direction facing, IPlantable plantable) {\r\n-\t\treturn patchwork$getForgeBlock().canSustainPlant(getBlockState(), world, pos, facing, plantable);\r\n-\t}*/\r\n-\r\n-\t/**\r\n-\t * Called when a plant grows on this block.\r\n-\t * This does not use ForgeDirection, because large/huge trees can be located in non-representable direction,\r\n-\t * so the source location is specified.\r\n-\t * Currently this just changes the block to dirt if it was grass.\r\n-\t *\r\n-\t * <p>Note: This happens DURING the generation, the generation may not be complete when this is called.\r\n-\t *\r\n-\t * @param world  Current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param source Source plant's position in world\r\n-\t */\r\n-\tdefault void onPlantGrow(IWorld world, BlockPos pos, BlockPos source) {\r\n-\t\tpatchwork$getForgeBlock().onPlantGrow(getBlockState(), world, pos, source);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Checks if this soil is fertile, typically this means that growth rates\r\n-\t * of plants on this soil will be slightly sped up.\r\n-\t * Only vanilla case is tilledField when it is within range of water.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the soil should be considered fertile.\r\n-\t */\r\n-\tdefault boolean isFertile(BlockView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().isFertile(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if this block can be used as the base of a beacon.\r\n-\t *\r\n-\t * @param world  The current world\r\n-\t * @param pos    Block position in world\r\n-\t * @param beacon Beacon position in world\r\n-\t * @return True, to support the beacon, and make it active with this block.\r\n-\t */\r\n-\tdefault boolean isBeaconBase(CollisionView world, BlockPos pos, BlockPos beacon) {\r\n-\t\treturn patchwork$getForgeBlock().isBeaconBase(getBlockState(), world, pos, beacon);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Gathers how much experience this block drops when broken.\r\n-\t *\r\n-\t * @param world     The world\r\n-\t * @param pos       Block position\r\n-\t * @param fortune   Level of fortune on the breaker's tool\r\n-\t * @param silktouch Level of silk touch on the breaker's tool\r\n-\t * @return Amount of XP from breaking this block.\r\n-\t */\r\n-\tdefault int getExpDrop(CollisionView world, BlockPos pos, int fortune, int silktouch) {\r\n-\t\treturn patchwork$getForgeBlock().getExpDrop(getBlockState(), world, pos, fortune, silktouch);\r\n-\t}\r\n-\r\n-\tdefault BlockState rotate(IWorld world, BlockPos pos, BlockRotation direction) {\r\n-\t\treturn patchwork$getForgeBlock().rotate(getBlockState(), world, pos, direction);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines the amount of enchanting power this block can provide to an enchanting table.\r\n-\t *\r\n-\t * @param world The World\r\n-\t * @param pos   Block position in world\r\n-\t * @return The amount of enchanting power this block produces.\r\n-\t */\r\n-\tdefault float getEnchantPowerBonus(CollisionView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().getEnchantPowerBonus(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Re-colors this block in the world.\r\n-\t *\r\n-\t * @param state   The current state\r\n-\t * @param world   The world\r\n-\t * @param pos     Block position\r\n-\t * @param facing  ??? (this method has no usages)\r\n-\t * @param color   Color to recolor to.\r\n-\t * @return if the block was affected\r\n-\t */\r\n-\tdefault boolean recolorBlock(IWorld world, BlockPos pos, Direction facing, DyeColor color) {\r\n-\t\treturn patchwork$getForgeBlock().recolorBlock(getBlockState(), world, pos, facing, color);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when a block entity on a side of this block changes is created or is destroyed.\r\n-\t *\r\n-\t * @param world    The world\r\n-\t * @param pos      Block position in world\r\n-\t * @param neighbor Block position of neighbor\r\n-\t */\r\n-\tdefault void onNeighborChange(CollisionView world, BlockPos pos, BlockPos neighbor) {\r\n-\t\tpatchwork$getForgeBlock().onNeighborChange(getBlockState(), world, pos, neighbor);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called on an Observer block whenever an update for an Observer is received.\r\n-\t *\r\n-\t * @param observerState The Observer block's state.\r\n-\t * @param world         The current world.\r\n-\t * @param pos           The Observer block's position.\r\n-\t * @param changed       The updated block.\r\n-\t * @param changedPos    The updated block's position.\r\n-\t */\r\n-\tdefault void observedNeighborChange(World world, BlockPos pos, Block changed, BlockPos changedPos) {\r\n-\t\tpatchwork$getForgeBlock().observedNeighborChange(getBlockState(), world, pos, changed, changedPos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called to determine whether to allow the a block to handle its own indirect power rather than using the default rules.\r\n-\t *\r\n-\t * @param world The world\r\n-\t * @param pos   Block position in world\r\n-\t * @param side  The INPUT side of the block to be powered - ie the opposite of this block's output side\r\n-\t * @return Whether Block#isProvidingWeakPower should be called when determining indirect power\r\n-\t */\r\n-\tdefault boolean shouldCheckWeakPower(CollisionView world, BlockPos pos, Direction side) {\r\n-\t\treturn patchwork$getForgeBlock().shouldCheckWeakPower(getBlockState(), world, pos, side);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * If this block should be notified of weak changes.\r\n-\t * Weak changes are changes 1 block away through a solid block.\r\n-\t * Similar to comparators.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return true To be notified of changes\r\n-\t */\r\n-\tdefault boolean getWeakChanges(CollisionView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().getWeakChanges(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/* TODO IForgeBlockState#getHarvestTool needs ToolType\r\n-\t/**\r\n-\t * Queries the class of tool required to harvest this block, if null is returned\r\n-\t * we assume that anything can harvest this block.\r\n-\t *\r\n-\tdefault ToolType getHarvestTool() {\r\n-\t\treturn patchwork$getForgeBlock().getHarvestTool(getBlockState());\r\n-\t}*/\r\n-\r\n-\tdefault int getHarvestLevel() {\r\n-\t\treturn patchwork$getForgeBlock().getHarvestLevel(getBlockState());\r\n-\t}\r\n-\r\n-\t/* TODO IForgeBlockState#isToolEffective needs ToolType\r\n-\t/**\r\n-\t * Checks if the specified tool type is efficient on this block,\r\n-\t * meaning that it digs at full speed.\r\n-\t *\r\n-\tdefault boolean isToolEffective(ToolType tool) {\r\n-\t\treturn patchwork$getForgeBlock().isToolEffective(getBlockState(), tool);\r\n-\t}*/\r\n-\r\n-\t/**\r\n-\t * Can return IExtendedBlockState.\r\n-\t */\r\n-\tdefault BlockState getExtendedState(BlockView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().getExtendedState(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Queries if this block should render in a given layer.\r\n-\t * A custom {@link net.minecraft.client.render.model.BakedModel} can use {@link net.minecraftforge.client.MinecraftForgeClient#getRenderLayer()} to alter the model based on layer.\r\n-\t */\r\n-\tdefault boolean canRenderInLayer(RenderLayer layer) {\r\n-\t\treturn patchwork$getForgeBlock().canRenderInLayer(getBlockState(), layer);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Sensitive version of {@link Block#getSoundType}.\r\n-\t *\r\n-\t * @param world  The world\r\n-\t * @param pos    The position. Note that the world may not necessarily have {@code state} here!\r\n-\t * @param entity The entity that is breaking/stepping on/placing/hitting/falling on this block, or null if no entity is in this context\r\n-\t * @return A {@link BlockSoundGroup} to use\r\n-\t */\r\n-\tdefault BlockSoundGroup getSoundType(CollisionView world, BlockPos pos, @Nullable Entity entity) {\r\n-\t\treturn patchwork$getForgeBlock().getSoundType(getBlockState(), world, pos, entity);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * @param world     The world\r\n-\t * @param pos       The position of this state\r\n-\t * @param beaconPos The position of the beacon\r\n-\t * @return A float RGB [0.0, 1.0] array to be averaged with a beacon's existing beam color, or null to do nothing to the beam\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault float[] getBeaconColorMultiplier(CollisionView world, BlockPos pos, BlockPos beacon) {\r\n-\t\treturn patchwork$getForgeBlock().getBeaconColorMultiplier(getBlockState(), world, pos, beacon);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Use this to change the fog color used when the entity is \"inside\" a material.\r\n-\t * {@link Vec3d} is used here as \"r/g/b\" 0 - 1 values.\r\n-\t *\r\n-\t * @param world         The world.\r\n-\t * @param pos           The position at the entity viewport.\r\n-\t * @param entity        the entity\r\n-\t * @param originalColor The current fog color, You are not expected to use this, Return as the default if applicable.\r\n-\t * @return The new fog color.\r\n-\t */\r\n-\t@Environment(EnvType.CLIENT)\r\n-\tdefault Vec3d getFogColor(CollisionView world, BlockPos pos, Entity entity, Vec3d originalColor, float partialTicks) {\r\n-\t\treturn patchwork$getForgeBlock().getFogColor(getBlockState(), world, pos, entity, originalColor, partialTicks);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Used to determine the state 'viewed' by an entity.\r\n-\t * Can be used by fluid blocks to determine if the viewpoint is within the fluid or not.\r\n-\t *\r\n-\t * @param world     the world\r\n-\t * @param pos       the position\r\n-\t * @param viewpoint the viewpoint\r\n-\t * @return the block state that should be 'seen'\r\n-\t */\r\n-\tdefault BlockState getStateAtViewpoint(BlockView world, BlockPos pos, Vec3d viewpoint) {\r\n-\t\treturn patchwork$getForgeBlock().getStateAtViewpoint(getBlockState(), world, pos, viewpoint);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Gets the {@link BlockState} to place.\r\n-\t *\r\n-\t * @param state  ??? (presumably this block's state, but it has not yet been placed?)\r\n-\t * @param facing The side the block is being placed on\r\n-\t * @param state2 ???\r\n-\t * @param world  The world the block is being placed in\r\n-\t * @param pos1   ??? (presumably where it's being placed)\r\n-\t * @param pos2   ???\r\n-\t * @param hand   The hand the block is being placed from\r\n-\t * @return The state to be placed in the world\r\n-\t */\r\n-\tdefault BlockState getStateForPlacement(Direction facing, BlockState state2, IWorld world, BlockPos pos1, BlockPos pos2, Hand hand) {\r\n-\t\treturn patchwork$getForgeBlock().getStateForPlacement(getBlockState(), facing, state2, world, pos1, pos2, hand);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if another block can connect to this block.\r\n-\t *\r\n-\t * @param world  The current world\r\n-\t * @param pos    The position of this block\r\n-\t * @param facing The side the connecting block is on\r\n-\t * @return True to allow another block to connect to this block\r\n-\t */\r\n-\tdefault boolean canBeConnectedTo(BlockView world, BlockPos pos, Direction facing) {\r\n-\t\treturn patchwork$getForgeBlock().canBeConnectedTo(getBlockState(), world, pos, facing);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * @param state The state\r\n-\t * @return true if the block is sticky block which used for pull or push adjacent blocks (use by piston)\r\n-\t */\r\n-\tdefault boolean isStickyBlock() {\r\n-\t\treturn patchwork$getForgeBlock().isStickyBlock(getBlockState());\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Chance that fire will spread and consume this block.\r\n-\t * 300 being a 100% chance, 0, being a 0% chance.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The face that the fire is coming from\r\n-\t * @return A number ranging from 0 to 300 relating used to determine if the block will be consumed by fire\r\n-\t */\r\n-\tdefault int getFlammability(BlockView world, BlockPos pos, Direction face) {\r\n-\t\treturn patchwork$getForgeBlock().getFlammability(getBlockState(), world, pos, face);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when fire is updating, checks if a block face can catch fire.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The face that the fire is coming from\r\n-\t * @return True if the face can be on fire, false otherwise.\r\n-\t */\r\n-\tdefault boolean isFlammable(BlockView world, BlockPos pos, Direction face) {\r\n-\t\treturn patchwork$getForgeBlock().isFlammable(getBlockState(), world, pos, face);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * If the block is flammable, this is called when it gets lit on fire.\r\n-\t *\r\n-\t * @param world   The current world\r\n-\t * @param pos     Block position in world\r\n-\t * @param face    The face that the fire is coming from\r\n-\t * @param igniter The entity that lit the fire\r\n-\t */\r\n-\tdefault void catchFire(World world, BlockPos pos, @Nullable Direction face, @Nullable LivingEntity igniter) {\r\n-\t\tpatchwork$getForgeBlock().catchFire(getBlockState(), world, pos, face, igniter);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when fire is updating on a neighbor block.\r\n-\t * The higher the number returned, the faster fire will spread around this block.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param face  The face that the fire is coming from\r\n-\t * @return A number that is used to determine the speed of fire growth around the block\r\n-\t */\r\n-\tdefault int getFireSpreadSpeed(BlockView world, BlockPos pos, Direction face) {\r\n-\t\treturn patchwork$getForgeBlock().getFireSpreadSpeed(getBlockState(), world, pos, face);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Currently only called by fire when it is on top of this block.\r\n-\t * Returning true will prevent the fire from naturally dying during updating.\r\n-\t * Also prevents firing from dying from rain.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @param side  The face that the fire is coming from\r\n-\t * @return True if this block sustains fire, meaning it will never go out.\r\n-\t */\r\n-\tdefault boolean isFireSource(BlockView world, BlockPos pos, Direction side) {\r\n-\t\treturn patchwork$getForgeBlock().isFireSource(getBlockState(), world, pos, side);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if this block is can be destroyed by the specified entities normal behavior.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True to allow the ender dragon to destroy this block\r\n-\t */\r\n-\tdefault boolean canEntityDestroy(BlockView world, BlockPos pos, Entity entity) {\r\n-\t\treturn patchwork$getForgeBlock().canEntityDestroy(getBlockState(), world, pos, entity);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Get the rotations that can apply to the block at the specified coordinates. Null means no rotations are possible.\r\n-\t * Note, this is up to the block to decide. It may not be accurate or representative.\r\n-\t *\r\n-\t * @param world The world\r\n-\t * @param pos   Block position in world\r\n-\t * @return An array of valid axes to rotate around, or null for none or unknown\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault Direction[] getValidRotations(BlockView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().getValidRotations(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if this block should set fire and deal fire damage\r\n-\t * to entities coming into contact with it.\r\n-\t *\r\n-\t * @param world The current world\r\n-\t * @param pos   Block position in world\r\n-\t * @return True if the block should deal damage\r\n-\t */\r\n-\tdefault boolean isBurning(BlockView world, BlockPos pos) {\r\n-\t\treturn patchwork$getForgeBlock().isBurning(getBlockState(), world, pos);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Get the {@link PathNodeType} for this block. Return {@code null} for vanilla behavior.\r\n-\t *\r\n-\t * @return the {@link PathNodeType}\r\n-\t */\r\n-\t@Nullable\r\n-\tdefault PathNodeType getAiPathNodeType(BlockView world, BlockPos pos, @Nullable MobEntity entity) {\r\n-\t\treturn patchwork$getForgeBlock().getAiPathNodeType(getBlockState(), world, pos, entity);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if this block should drop loot when exploded.\r\n-\t */\r\n-\tdefault boolean canDropFromExplosion(BlockView world, BlockPos pos, Explosion explosion) {\r\n-\t\treturn patchwork$getForgeBlock().canDropFromExplosion(getBlockState(), world, pos, explosion);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Called when the block is destroyed by an explosion.\r\n-\t * Useful for allowing the block to take into account tile entities,\r\n-\t * state, etc. when exploded, before it is removed.\r\n-\t *\r\n-\t * @param world     The current world\r\n-\t * @param pos       Block position in world\r\n-\t * @param explosion The explosion instance affecting the block\r\n-\t */\r\n-\tdefault void onBlockExploded(World world, BlockPos pos, Explosion explosion) {\r\n-\t\tpatchwork$getForgeBlock().onBlockExploded(getBlockState(), world, pos, explosion);\r\n-\t}\r\n-\r\n-\t/**\r\n-\t * Determines if this block's collision box should be treated as though it can extend above its block space.\r\n-\t * This can be used to replicate fence and wall behavior.\r\n-\t */\r\n-\tdefault boolean collisionExtendsVertically(BlockView world, BlockPos pos, Entity collidingEntity) {\r\n-\t\treturn patchwork$getForgeBlock().collisionExtendsVertically(getBlockState(), world, pos, collidingEntity);\r\n-\t}\r\n-}\r\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import net.minecraftforge.common.IPlantable;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockEntityProvider;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.entity.BlockEntity;\n+import net.minecraft.client.particle.ParticleManager;\n+import net.minecraft.client.render.RenderLayer;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.SpawnRestriction.Location;\n+import net.minecraft.entity.ai.pathing.PathNodeType;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.fluid.FluidState;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.server.world.ServerWorld;\n+import net.minecraft.sound.BlockSoundGroup;\n+import net.minecraft.util.BlockRotation;\n+import net.minecraft.util.DyeColor;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Direction;\n+import net.minecraft.util.math.Vec3d;\n+import net.minecraft.world.BlockRenderView;\n+import net.minecraft.world.BlockView;\n+import net.minecraft.world.CollisionView;\n+import net.minecraft.world.IWorld;\n+import net.minecraft.world.World;\n+import net.minecraft.world.explosion.Explosion;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+\n+public interface IForgeBlockState {\n+\tdefault BlockState getBlockState() {\n+\t\treturn (BlockState) this;\n+\t}\n+\n+\tdefault IForgeBlock patchwork$getForgeBlock() {\n+\t\treturn (IForgeBlock) getBlockState().getBlock();\n+\t}\n+\n+\t/**\n+\t * Gets the slipperiness at the given location of this state. Normally\n+\t * between 0 and 1.\n+\t *\n+\t * <p>Note that entities may reduce slipperiness by a certain factor of their own;\n+\t * for {@link LivingEntity}, this is {@code .91}.\n+\t * {@link net.minecraft.entity.ItemEntity} uses {@code .98}, and\n+\t * {@link net.minecraft.entity.projectile.FishingBobberEntity} uses {@code .92}.\n+\t *\n+\t * @param world  the world\n+\t * @param pos    the position in the world\n+\t * @param entity the entity in question\n+\t * @return the factor by which the entity's motion should be multiplied\n+\t */\n+\tdefault float getSlipperiness(CollisionView world, BlockPos pos, @Nullable Entity entity) {\n+\t\treturn patchwork$getForgeBlock().getSlipperiness(getBlockState(), world, pos, entity);\n+\t}\n+\n+\t/**\n+\t * Get a light value for this block, taking into account the state and coordinates, normal ranges are between 0 and 15.\n+\t */\n+\tdefault int getLightValue(BlockRenderView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().getLightValue(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Checks if a player or entity can use this block to 'climb' like a ladder.\n+\t *\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param entity The entity trying to use the ladder, CAN be null.\n+\t * @return True if the block should act like a ladder\n+\t */\n+\tdefault boolean isLadder(CollisionView world, BlockPos pos, LivingEntity entity) {\n+\t\treturn patchwork$getForgeBlock().isLadder(getBlockState(), world, pos, entity);\n+\t}\n+\n+\t// deprecated for removal in 1.15, don't bother implementing\n+\t/**\n+\t * Check if the face of a block should block rendering.\n+\t *\n+\t * <p>Faces which are fully opaque should return true, faces with transparency\n+\t * or faces which do not span the full size of the block should return false.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The side to check\n+\t * @return True if the block is opaque on the specified side.\n+\t * @deprecated This is no longer used for rendering logic.\n+\t */\n+\t@Deprecated\n+\tdefault boolean doesSideBlockRendering(BlockRenderView world, BlockPos pos, Direction face) {\n+\t\treturn patchwork$getForgeBlock().doesSideBlockRendering(getBlockState(), world, pos, face);\n+\t}\n+\n+\t/**\n+\t * Called throughout the code as a replacement for {@code block instanceof} {@link BlockEntityProvider}.\n+\t * Allows for blocks to have a block entity conditionally based on block state.\n+\t *\n+\t * <p>Return true from this function to specify this block has a block entity.\n+\t *\n+\t * @return True if block has a block entity, false otherwise\n+\t */\n+\tdefault boolean hasTileEntity() {\n+\t\treturn patchwork$getForgeBlock().hasTileEntity(getBlockState());\n+\t}\n+\n+\t/**\n+\t * Called throughout the code as a replacement for {@link BlockEntityProvider#createBlockEntity(BlockView)}\n+\t * Return the same thing you would from that function.\n+\t * This will fall back to {@link BlockEntityProvider#createBlockEntity(BlockView)} if this block is a {@link BlockEntityProvider}\n+\t *\n+\t * @param world The world to create the BE in\n+\t * @return An instance of a class extending {@link BlockEntity}\n+\t */\n+\t@Nullable\n+\tdefault BlockEntity createTileEntity(BlockView world) {\n+\t\treturn patchwork$getForgeBlock().createTileEntity(getBlockState(), world);\n+\t}\n+\n+\t/* TODO IForgeBlockState#canHarvestBlock indirectly requires ToolType\n+\t/**\n+\t * Determines if the player can harvest this block, obtaining it's drops when the block is destroyed.\n+\t *\n+\t * @param world  The current world\n+\t * @param pos    The block's current position\n+\t * @param player The player damaging the block\n+\t * @return True to spawn the drops\n+\t *\n+\tdefault boolean canHarvestBlock(BlockView world, BlockPos pos, PlayerEntity player) {\n+\t\treturn patchwork$getForgeBlock().canHarvestBlock(getBlockState(), world, pos, player);\n+\t}*/\n+\n+\t/**\n+\t * Called when a player removes a block.  This is responsible for\n+\t * actually destroying the block, and the block is intact at time of call.\n+\t * This is called regardless of whether the player can harvest the block or\n+\t * not.\n+\t *\n+\t * <p>Return true if the block is actually destroyed.\n+\t *\n+\t * <p>Note: When used in multiplayer, this is called on both client and\n+\t * server sides!\n+\t *\n+\t * @param world       The current world\n+\t * @param pos         Block position in world\n+\t * @param player      The player damaging the block, may be null\n+\t * @param willHarvest True if {@link Block#onBroken(IWorld, BlockPos, BlockState)} will be called after this if this method returns true.\n+\t *                    Can be useful to delay the destruction of block entities till after onBroken\n+\t * @param fluid       The current fluid state at current position\n+\t * @return True if the block is actually destroyed.\n+\t */\n+\tdefault boolean removedByPlayer(World world, BlockPos pos, PlayerEntity player, boolean willHarvest, FluidState fluid) {\n+\t\treturn patchwork$getForgeBlock().removedByPlayer(getBlockState(), world, pos, player, willHarvest, fluid);\n+\t}\n+\n+\t/**\n+\t * Determines if this block is classified as a Bed, Allowing\n+\t * players to sleep in it, though the block has to specifically\n+\t * perform the sleeping functionality in it's activated event.\n+\t *\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param player The player or camera entity, null in some cases.\n+\t * @return True to treat this as a bed\n+\t */\n+\tdefault boolean isBed(BlockView world, BlockPos pos, @Nullable LivingEntity player) {\n+\t\treturn patchwork$getForgeBlock().isBed(getBlockState(), world, pos, player);\n+\t}\n+\n+\t/**\n+\t * Determines if a specified mob type can spawn on this block, returning false will\n+\t * prevent any mob from spawning on the block.\n+\t *\n+\t * @param world        The current world\n+\t * @param pos          Block position in world\n+\t * @param restriction  The location spawn restriction\n+\t * @param entityType   The type of entity attempting to spawn\n+\t * @return True to allow a mob of the specified category to spawn, false to prevent it.\n+\t */\n+\tdefault boolean canCreatureSpawn(CollisionView world, BlockPos pos, Location restriction, EntityType<?> entityType) {\n+\t\treturn patchwork$getForgeBlock().canCreatureSpawn(getBlockState(), world, pos, restriction, entityType);\n+\t}\n+\n+\t/**\n+\t * Returns the position that the sleeper is moved to upon\n+\t * waking up, or respawning at the bed.\n+\t *\n+\t * @param entityType the sleeper's entity type\n+\t * @param world      The current world\n+\t * @param pos        Block position in world\n+\t * @param sleeper    The sleeper or camera entity, null in some cases.\n+\t * @return The spawn position\n+\t */\n+\tdefault Optional<Vec3d> getBedSpawnPosition(EntityType<?> type, CollisionView world, BlockPos pos, @Nullable LivingEntity sleeper) {\n+\t\treturn patchwork$getForgeBlock().getBedSpawnPosition(type, getBlockState(), world, pos, sleeper);\n+\t}\n+\n+\t/**\n+\t * Called when a user either starts or stops sleeping in the bed.\n+\t *\n+\t * @param world    The current world\n+\t * @param pos      Block position in world\n+\t * @param sleeper  The sleeper or camera entity, null in some cases.\n+\t * @param occupied True if we are occupying the bed, or false if they are stopping use of the bed\n+\t */\n+\tdefault void setBedOccupied(CollisionView world, BlockPos pos, LivingEntity sleeper, boolean occupied) {\n+\t\tpatchwork$getForgeBlock().setBedOccupied(getBlockState(), world, pos, sleeper, occupied);\n+\t}\n+\n+\t/**\n+\t * Returns the direction of the block. Same values that\n+\t * are returned by {@link net.minecraft.block.FacingBlock}. Called every frame tick for every living entity. Be VERY fast.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return Bed direction\n+\t */\n+\tdefault Direction getBedDirection(CollisionView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().getBedDirection(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Determines if the current block is the foot half of the bed.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the current block is the foot side of a bed.\n+\t */\n+\tdefault boolean isBedFoot(CollisionView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().isBedFoot(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Called when a leaf should start its decay process.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t */\n+\tdefault void beginLeaveDecay(CollisionView world, BlockPos pos) {\n+\t\tpatchwork$getForgeBlock().beginLeaveDecay(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Determines this block should be treated as an air block\n+\t * by the rest of the code. This method is primarily\n+\t * useful for creating pure logic-blocks that will be invisible\n+\t * to the player and otherwise interact as air would.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the block considered air\n+\t */\n+\tdefault boolean isAir(BlockView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().isAir(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Used during tree growth to determine if newly generated leaves can replace this block.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return true if this block can be replaced by growing leaves.\n+\t */\n+\tdefault boolean canBeReplacedByLeaves(CollisionView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().canBeReplacedByLeaves(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Used during tree growth to determine if newly generated logs can replace this block.\n+\t *\n+\t * @param state The current state\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return true if this block can be replaced by growing leaves.\n+\t */\n+\tdefault boolean canBeReplacedByLogs(CollisionView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().canBeReplacedByLogs(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Determines if the current block is replaceable by ore veins during world generation.\n+\t *\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param target The generic target block the gen is looking for, usually stone\n+\t *               for overworld generation, and netherrack for the nether.\n+\t * @return True to allow this block to be replaced by a ore\n+\t */\n+\tdefault boolean isReplaceableOreGen(CollisionView world, BlockPos pos, Predicate<BlockState> target) {\n+\t\treturn patchwork$getForgeBlock().isReplaceableOreGen(getBlockState(), world, pos, target);\n+\t}\n+\n+\t/**\n+\t * Location sensitive version of getExplosionResistance.\n+\t *\n+\t * @param world     The current world\n+\t * @param pos       Block position in world\n+\t * @param exploder  The entity that caused the explosion, can be null\n+\t * @param explosion The explosion\n+\t * @return The amount of the explosion absorbed.\n+\t */\n+\tdefault float getExplosionResistance(CollisionView world, BlockPos pos, @Nullable Entity exploder, Explosion explosion) {\n+\t\treturn patchwork$getForgeBlock().getExplosionResistance(getBlockState(), world, pos, exploder, explosion);\n+\t}\n+\n+\t/**\n+\t * Determine if this block can make a redstone connection on the side provided,\n+\t * Useful to control which sides are inputs and outputs for redstone wires.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param side  The side that is trying to make the connection, CAN BE NULL\n+\t * @return True to make the connection\n+\t */\n+\tdefault boolean canConnectRedstone(BlockView world, BlockPos pos, @Nullable Direction side) {\n+\t\treturn patchwork$getForgeBlock().canConnectRedstone(getBlockState(), world, pos, side);\n+\t}\n+\n+\t/**\n+\t * Called when a user uses the creative pick block button on this block.\n+\t *\n+\t * @param target The full target the player is looking at\n+\t * @param world  The world the block is in\n+\t * @param pos    The block's position\n+\t * @param player The player picking the block\n+\t * @return An {@link ItemStack} to add to the player's inventory, empty itemstack if nothing should be added.\n+\t */\n+\tdefault ItemStack getPickBlock(HitResult target, BlockView world, BlockPos pos, PlayerEntity player) {\n+\t\treturn patchwork$getForgeBlock().getPickBlock(getBlockState(), target, world, pos, player);\n+\t}\n+\n+\t/**\n+\t * Forge javadoc only said where this was used. It isn't used anywhere, so there's really no way to document this.\n+\t */\n+\tdefault boolean isFoliage(CollisionView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().isFoliage(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Allows a block to override the standard {@link LivingEntity#fall} particles.\n+\t * This is a server side method that spawns particles with\n+\t * {@link ServerWorld#spawnParticles}\n+\t *\n+\t * @param serverworld       The {@link ServerWorld} this block is in.\n+\t * @param pos               The position of the block.\n+\t * @param state2            This block's state, but again.\n+\t * @param entity            The entity that landed on the block\n+\t * @param numberOfParticles Number of particles the vanilla version of this method would spawn.\n+\t * @return True to prevent vanilla landing particles from spawning\n+\t */\n+\tdefault boolean addLandingEffects(ServerWorld worldserver, BlockPos pos, BlockState state2, LivingEntity entity, int numberOfParticles) {\n+\t\treturn patchwork$getForgeBlock().addLandingEffects(getBlockState(), worldserver, pos, state2, entity, numberOfParticles);\n+\t}\n+\n+\t/**\n+\t * Allows a block to override the standard vanilla running particles.\n+\t * This is called from {@link Entity#spawnSprintingParticles} and is called both\n+\t * client and server side, it's up to the implementor to client check / server check.\n+\t * By default vanilla spawns particles only on the client and the server methods no-op.\n+\t *\n+\t * @param world  The world.\n+\t * @param pos    The position at the entity's feet.\n+\t * @param entity The entity running on the block.\n+\t * @return True to prevent vanilla running particles from spawning.\n+\t */\n+\tdefault boolean addRunningEffects(World world, BlockPos pos, Entity entity) {\n+\t\treturn patchwork$getForgeBlock().addRunningEffects(getBlockState(), world, pos, entity);\n+\t}\n+\n+\t/**\n+\t * Spawn a digging particle effect in the world, this is a wrapper\n+\t * around {@link ParticleManager.addBlockBreakParticles} to allow the block more\n+\t * control over the particles.\n+\t *\n+\t * @param world   The current world\n+\t * @param target  The target the player is looking at {x/y/z/side/sub}\n+\t * @param manager A reference to the current particle manager.\n+\t * @return True to prevent vanilla digging particles form spawning.\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault boolean addHitEffects(World world, HitResult target, ParticleManager manager) {\n+\t\treturn patchwork$getForgeBlock().addHitEffects(getBlockState(), world, target, manager);\n+\t}\n+\n+\t/**\n+\t * Spawn particles for when the block is destroyed. Due to the nature\n+\t * of how this is invoked, the x/y/z locations are not always guaranteed\n+\t * to host your block. So be sure to do proper sanity checks before assuming\n+\t * that the location is this block.\n+\t *\n+\t * @param world   The current world\n+\t * @param pos     Position to spawn the particle\n+\t * @param manager A reference to the current particle manager.\n+\t * @return True to prevent vanilla break particles from spawning.\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault boolean addDestroyEffects(World world, BlockPos pos, ParticleManager manager) {\n+\t\treturn patchwork$getForgeBlock().addDestroyEffects(getBlockState(), world, pos, manager);\n+\t}\n+\n+\t/**\n+\t * Determines if this block can support the passed in plant, allowing it to be planted and grow.\n+\t * Some examples:\n+\t * Reeds check if its a reed, or if its sand/dirt/grass and adjacent to water\n+\t * Cacti checks if its a cacti, or if its sand\n+\t * Nether types check for soul sand\n+\t * Crops check for tilled soil\n+\t * Caves check if it's a solid surface\n+\t * Plains check if its grass or dirt\n+\t * Water check if its still water\n+\t *\n+\t * @param world     The current world\n+\t * @param facing    The direction relative to the given position the plant wants to be, typically its UP\n+\t * @param plantable The plant that wants to check\n+\t * @return True to allow the plant to be planted/stay.\n+\t */\n+\tdefault boolean canSustainPlant(BlockView world, BlockPos pos, Direction facing, IPlantable plantable) {\n+\t\treturn patchwork$getForgeBlock().canSustainPlant(getBlockState(), world, pos, facing, plantable);\n+\t}\n+\n+\t/**\n+\t * Called when a plant grows on this block.\n+\t * This does not use ForgeDirection, because large/huge trees can be located in non-representable direction,\n+\t * so the source location is specified.\n+\t * Currently this just changes the block to dirt if it was grass.\n+\t *\n+\t * <p>Note: This happens DURING the generation, the generation may not be complete when this is called.\n+\t *\n+\t * @param world  Current world\n+\t * @param pos    Block position in world\n+\t * @param source Source plant's position in world\n+\t */\n+\tdefault void onPlantGrow(IWorld world, BlockPos pos, BlockPos source) {\n+\t\tpatchwork$getForgeBlock().onPlantGrow(getBlockState(), world, pos, source);\n+\t}\n+\n+\t/**\n+\t * Checks if this soil is fertile, typically this means that growth rates\n+\t * of plants on this soil will be slightly sped up.\n+\t * Only vanilla case is tilledField when it is within range of water.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the soil should be considered fertile.\n+\t */\n+\tdefault boolean isFertile(BlockView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().isFertile(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Determines if this block can be used as the base of a beacon.\n+\t *\n+\t * @param world  The current world\n+\t * @param pos    Block position in world\n+\t * @param beacon Beacon position in world\n+\t * @return True, to support the beacon, and make it active with this block.\n+\t */\n+\tdefault boolean isBeaconBase(CollisionView world, BlockPos pos, BlockPos beacon) {\n+\t\treturn patchwork$getForgeBlock().isBeaconBase(getBlockState(), world, pos, beacon);\n+\t}\n+\n+\t/**\n+\t * Gathers how much experience this block drops when broken.\n+\t *\n+\t * @param world     The world\n+\t * @param pos       Block position\n+\t * @param fortune   Level of fortune on the breaker's tool\n+\t * @param silktouch Level of silk touch on the breaker's tool\n+\t * @return Amount of XP from breaking this block.\n+\t */\n+\tdefault int getExpDrop(CollisionView world, BlockPos pos, int fortune, int silktouch) {\n+\t\treturn patchwork$getForgeBlock().getExpDrop(getBlockState(), world, pos, fortune, silktouch);\n+\t}\n+\n+\tdefault BlockState rotate(IWorld world, BlockPos pos, BlockRotation direction) {\n+\t\treturn patchwork$getForgeBlock().rotate(getBlockState(), world, pos, direction);\n+\t}\n+\n+\t/**\n+\t * Determines the amount of enchanting power this block can provide to an enchanting table.\n+\t *\n+\t * @param world The World\n+\t * @param pos   Block position in world\n+\t * @return The amount of enchanting power this block produces.\n+\t */\n+\tdefault float getEnchantPowerBonus(CollisionView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().getEnchantPowerBonus(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Re-colors this block in the world.\n+\t *\n+\t * @param state   The current state\n+\t * @param world   The world\n+\t * @param pos     Block position\n+\t * @param facing  ??? (this method has no usages)\n+\t * @param color   Color to recolor to.\n+\t * @return if the block was affected\n+\t */\n+\tdefault boolean recolorBlock(IWorld world, BlockPos pos, Direction facing, DyeColor color) {\n+\t\treturn patchwork$getForgeBlock().recolorBlock(getBlockState(), world, pos, facing, color);\n+\t}\n+\n+\t/**\n+\t * Called when a block entity on a side of this block changes is created or is destroyed.\n+\t *\n+\t * @param world    The world\n+\t * @param pos      Block position in world\n+\t * @param neighbor Block position of neighbor\n+\t */\n+\tdefault void onNeighborChange(CollisionView world, BlockPos pos, BlockPos neighbor) {\n+\t\tpatchwork$getForgeBlock().onNeighborChange(getBlockState(), world, pos, neighbor);\n+\t}\n+\n+\t/**\n+\t * Called on an Observer block whenever an update for an Observer is received.\n+\t *\n+\t * @param observerState The Observer block's state.\n+\t * @param world         The current world.\n+\t * @param pos           The Observer block's position.\n+\t * @param changed       The updated block.\n+\t * @param changedPos    The updated block's position.\n+\t */\n+\tdefault void observedNeighborChange(World world, BlockPos pos, Block changed, BlockPos changedPos) {\n+\t\tpatchwork$getForgeBlock().observedNeighborChange(getBlockState(), world, pos, changed, changedPos);\n+\t}\n+\n+\t/**\n+\t * Called to determine whether to allow the a block to handle its own indirect power rather than using the default rules.\n+\t *\n+\t * @param world The world\n+\t * @param pos   Block position in world\n+\t * @param side  The INPUT side of the block to be powered - ie the opposite of this block's output side\n+\t * @return Whether Block#isProvidingWeakPower should be called when determining indirect power\n+\t */\n+\tdefault boolean shouldCheckWeakPower(CollisionView world, BlockPos pos, Direction side) {\n+\t\treturn patchwork$getForgeBlock().shouldCheckWeakPower(getBlockState(), world, pos, side);\n+\t}\n+\n+\t/**\n+\t * If this block should be notified of weak changes.\n+\t * Weak changes are changes 1 block away through a solid block.\n+\t * Similar to comparators.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return true To be notified of changes\n+\t */\n+\tdefault boolean getWeakChanges(CollisionView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().getWeakChanges(getBlockState(), world, pos);\n+\t}\n+\n+\t/* TODO IForgeBlockState#getHarvestTool needs ToolType\n+\t/**\n+\t * Queries the class of tool required to harvest this block, if null is returned\n+\t * we assume that anything can harvest this block.\n+\t *\n+\tdefault ToolType getHarvestTool() {\n+\t\treturn patchwork$getForgeBlock().getHarvestTool(getBlockState());\n+\t}*/\n+\n+\tdefault int getHarvestLevel() {\n+\t\treturn patchwork$getForgeBlock().getHarvestLevel(getBlockState());\n+\t}\n+\n+\t/* TODO IForgeBlockState#isToolEffective needs ToolType\n+\t/**\n+\t * Checks if the specified tool type is efficient on this block,\n+\t * meaning that it digs at full speed.\n+\t *\n+\tdefault boolean isToolEffective(ToolType tool) {\n+\t\treturn patchwork$getForgeBlock().isToolEffective(getBlockState(), tool);\n+\t}*/\n+\n+\t/**\n+\t * Can return IExtendedBlockState.\n+\t */\n+\tdefault BlockState getExtendedState(BlockView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().getExtendedState(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Queries if this block should render in a given layer.\n+\t * A custom {@link net.minecraft.client.render.model.BakedModel} can use {@link net.minecraftforge.client.MinecraftForgeClient#getRenderLayer()} to alter the model based on layer.\n+\t */\n+\tdefault boolean canRenderInLayer(RenderLayer layer) {\n+\t\treturn patchwork$getForgeBlock().canRenderInLayer(getBlockState(), layer);\n+\t}\n+\n+\t/**\n+\t * Sensitive version of {@link Block#getSoundType}.\n+\t *\n+\t * @param world  The world\n+\t * @param pos    The position. Note that the world may not necessarily have {@code state} here!\n+\t * @param entity The entity that is breaking/stepping on/placing/hitting/falling on this block, or null if no entity is in this context\n+\t * @return A {@link BlockSoundGroup} to use\n+\t */\n+\tdefault BlockSoundGroup getSoundType(CollisionView world, BlockPos pos, @Nullable Entity entity) {\n+\t\treturn patchwork$getForgeBlock().getSoundType(getBlockState(), world, pos, entity);\n+\t}\n+\n+\t/**\n+\t * @param world     The world\n+\t * @param pos       The position of this state\n+\t * @param beaconPos The position of the beacon\n+\t * @return A float RGB [0.0, 1.0] array to be averaged with a beacon's existing beam color, or null to do nothing to the beam\n+\t */\n+\t@Nullable\n+\tdefault float[] getBeaconColorMultiplier(CollisionView world, BlockPos pos, BlockPos beacon) {\n+\t\treturn patchwork$getForgeBlock().getBeaconColorMultiplier(getBlockState(), world, pos, beacon);\n+\t}\n+\n+\t/**\n+\t * Use this to change the fog color used when the entity is \"inside\" a material.\n+\t * {@link Vec3d} is used here as \"r/g/b\" 0 - 1 values.\n+\t *\n+\t * @param world         The world.\n+\t * @param pos           The position at the entity viewport.\n+\t * @param entity        the entity\n+\t * @param originalColor The current fog color, You are not expected to use this, Return as the default if applicable.\n+\t * @return The new fog color.\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault Vec3d getFogColor(CollisionView world, BlockPos pos, Entity entity, Vec3d originalColor, float partialTicks) {\n+\t\treturn patchwork$getForgeBlock().getFogColor(getBlockState(), world, pos, entity, originalColor, partialTicks);\n+\t}\n+\n+\t/**\n+\t * Used to determine the state 'viewed' by an entity.\n+\t * Can be used by fluid blocks to determine if the viewpoint is within the fluid or not.\n+\t *\n+\t * @param world     the world\n+\t * @param pos       the position\n+\t * @param viewpoint the viewpoint\n+\t * @return the block state that should be 'seen'\n+\t */\n+\tdefault BlockState getStateAtViewpoint(BlockView world, BlockPos pos, Vec3d viewpoint) {\n+\t\treturn patchwork$getForgeBlock().getStateAtViewpoint(getBlockState(), world, pos, viewpoint);\n+\t}\n+\n+\t/**\n+\t * Gets the {@link BlockState} to place.\n+\t *\n+\t * @param state  ??? (presumably this block's state, but it has not yet been placed?)\n+\t * @param facing The side the block is being placed on\n+\t * @param state2 ???\n+\t * @param world  The world the block is being placed in\n+\t * @param pos1   ??? (presumably where it's being placed)\n+\t * @param pos2   ???\n+\t * @param hand   The hand the block is being placed from\n+\t * @return The state to be placed in the world\n+\t */\n+\tdefault BlockState getStateForPlacement(Direction facing, BlockState state2, IWorld world, BlockPos pos1, BlockPos pos2, Hand hand) {\n+\t\treturn patchwork$getForgeBlock().getStateForPlacement(getBlockState(), facing, state2, world, pos1, pos2, hand);\n+\t}\n+\n+\t/**\n+\t * Determines if another block can connect to this block.\n+\t *\n+\t * @param world  The current world\n+\t * @param pos    The position of this block\n+\t * @param facing The side the connecting block is on\n+\t * @return True to allow another block to connect to this block\n+\t */\n+\tdefault boolean canBeConnectedTo(BlockView world, BlockPos pos, Direction facing) {\n+\t\treturn patchwork$getForgeBlock().canBeConnectedTo(getBlockState(), world, pos, facing);\n+\t}\n+\n+\t/**\n+\t * @param state The state\n+\t * @return true if the block is sticky block which used for pull or push adjacent blocks (use by piston)\n+\t */\n+\tdefault boolean isStickyBlock() {\n+\t\treturn patchwork$getForgeBlock().isStickyBlock(getBlockState());\n+\t}\n+\n+\t/**\n+\t * Chance that fire will spread and consume this block.\n+\t * 300 being a 100% chance, 0, being a 0% chance.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The face that the fire is coming from\n+\t * @return A number ranging from 0 to 300 relating used to determine if the block will be consumed by fire\n+\t */\n+\tdefault int getFlammability(BlockView world, BlockPos pos, Direction face) {\n+\t\treturn patchwork$getForgeBlock().getFlammability(getBlockState(), world, pos, face);\n+\t}\n+\n+\t/**\n+\t * Called when fire is updating, checks if a block face can catch fire.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The face that the fire is coming from\n+\t * @return True if the face can be on fire, false otherwise.\n+\t */\n+\tdefault boolean isFlammable(BlockView world, BlockPos pos, Direction face) {\n+\t\treturn patchwork$getForgeBlock().isFlammable(getBlockState(), world, pos, face);\n+\t}\n+\n+\t/**\n+\t * If the block is flammable, this is called when it gets lit on fire.\n+\t *\n+\t * @param world   The current world\n+\t * @param pos     Block position in world\n+\t * @param face    The face that the fire is coming from\n+\t * @param igniter The entity that lit the fire\n+\t */\n+\tdefault void catchFire(World world, BlockPos pos, @Nullable Direction face, @Nullable LivingEntity igniter) {\n+\t\tpatchwork$getForgeBlock().catchFire(getBlockState(), world, pos, face, igniter);\n+\t}\n+\n+\t/**\n+\t * Called when fire is updating on a neighbor block.\n+\t * The higher the number returned, the faster fire will spread around this block.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param face  The face that the fire is coming from\n+\t * @return A number that is used to determine the speed of fire growth around the block\n+\t */\n+\tdefault int getFireSpreadSpeed(BlockView world, BlockPos pos, Direction face) {\n+\t\treturn patchwork$getForgeBlock().getFireSpreadSpeed(getBlockState(), world, pos, face);\n+\t}\n+\n+\t/**\n+\t * Currently only called by fire when it is on top of this block.\n+\t * Returning true will prevent the fire from naturally dying during updating.\n+\t * Also prevents firing from dying from rain.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @param side  The face that the fire is coming from\n+\t * @return True if this block sustains fire, meaning it will never go out.\n+\t */\n+\tdefault boolean isFireSource(BlockView world, BlockPos pos, Direction side) {\n+\t\treturn patchwork$getForgeBlock().isFireSource(getBlockState(), world, pos, side);\n+\t}\n+\n+\t/**\n+\t * Determines if this block is can be destroyed by the specified entities normal behavior.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True to allow the ender dragon to destroy this block\n+\t */\n+\tdefault boolean canEntityDestroy(BlockView world, BlockPos pos, Entity entity) {\n+\t\treturn patchwork$getForgeBlock().canEntityDestroy(getBlockState(), world, pos, entity);\n+\t}\n+\n+\t/**\n+\t * Get the rotations that can apply to the block at the specified coordinates. Null means no rotations are possible.\n+\t * Note, this is up to the block to decide. It may not be accurate or representative.\n+\t *\n+\t * @param world The world\n+\t * @param pos   Block position in world\n+\t * @return An array of valid axes to rotate around, or null for none or unknown\n+\t */\n+\t@Nullable\n+\tdefault Direction[] getValidRotations(BlockView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().getValidRotations(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Determines if this block should set fire and deal fire damage\n+\t * to entities coming into contact with it.\n+\t *\n+\t * @param world The current world\n+\t * @param pos   Block position in world\n+\t * @return True if the block should deal damage\n+\t */\n+\tdefault boolean isBurning(BlockView world, BlockPos pos) {\n+\t\treturn patchwork$getForgeBlock().isBurning(getBlockState(), world, pos);\n+\t}\n+\n+\t/**\n+\t * Get the {@link PathNodeType} for this block. Return {@code null} for vanilla behavior.\n+\t *\n+\t * @return the {@link PathNodeType}\n+\t */\n+\t@Nullable\n+\tdefault PathNodeType getAiPathNodeType(BlockView world, BlockPos pos, @Nullable MobEntity entity) {\n+\t\treturn patchwork$getForgeBlock().getAiPathNodeType(getBlockState(), world, pos, entity);\n+\t}\n+\n+\t/**\n+\t * Determines if this block should drop loot when exploded.\n+\t */\n+\tdefault boolean canDropFromExplosion(BlockView world, BlockPos pos, Explosion explosion) {\n+\t\treturn patchwork$getForgeBlock().canDropFromExplosion(getBlockState(), world, pos, explosion);\n+\t}\n+\n+\t/**\n+\t * Called when the block is destroyed by an explosion.\n+\t * Useful for allowing the block to take into account tile entities,\n+\t * state, etc. when exploded, before it is removed.\n+\t *\n+\t * @param world     The current world\n+\t * @param pos       Block position in world\n+\t * @param explosion The explosion instance affecting the block\n+\t */\n+\tdefault void onBlockExploded(World world, BlockPos pos, Explosion explosion) {\n+\t\tpatchwork$getForgeBlock().onBlockExploded(getBlockState(), world, pos, explosion);\n+\t}\n+\n+\t/**\n+\t * Determines if this block's collision box should be treated as though it can extend above its block space.\n+\t * This can be used to replicate fence and wall behavior.\n+\t */\n+\tdefault boolean collisionExtendsVertically(BlockView world, BlockPos pos, Entity collidingEntity) {\n+\t\treturn patchwork$getForgeBlock().collisionExtendsVertically(getBlockState(), world, pos, collidingEntity);\n+\t}\n+}", "originalCommit": "e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjI3NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443916275", "bodyText": "forge, wtf is this capitalization", "author": "TheGlitch76", "createdAt": "2020-06-23T01:51:12Z", "path": "patchwork-extensions-block/src/main/java/net/minecraftforge/common/PlantType.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Direction;\n+import net.minecraft.world.BlockView;\n+\n+import net.patchworkmc.api.enumhacks.EnumHacks;\n+import net.patchworkmc.mixin.extensions.block.PlantTypeAccessor;\n+\n+public enum PlantType {\n+\tPlains,", "originalCommit": "e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzNDYwOA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443934608", "bodyText": "Thanks for not having checkstyle complain about it", "author": "famous1622", "createdAt": "2020-06-23T03:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzU5NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443917594", "bodyText": "Expand this if statement to have braces--we're not a patch file.", "author": "TheGlitch76", "createdAt": "2020-06-23T01:55:56Z", "path": "patchwork-extensions-block/src/main/java/net/patchworkmc/mixin/extensions/block/MixinPlantBlock.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.mixin.extensions.block;\n+\n+import net.minecraftforge.common.IPlantable;\n+import net.minecraftforge.common.extensions.IForgeBlockState;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.PlantBlock;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Direction;\n+import net.minecraft.world.BlockView;\n+import net.minecraft.world.CollisionView;\n+\n+@Mixin(PlantBlock.class)\n+public class MixinPlantBlock implements IPlantable {\n+\t@Inject(method = \"canPlaceAt\", at = @At(\"HEAD\"), cancellable = true)\n+\tprivate void onCanPlaceAt(BlockState state, CollisionView world, BlockPos pos, CallbackInfoReturnable<Boolean> cir) {\n+\t\tif (state.getBlock() == (Object) this) {\n+\t\t\tcir.setReturnValue(((IForgeBlockState) world.getBlockState(pos.down())).canSustainPlant(world, pos, Direction.UP, this));\n+\t\t\tcir.cancel();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic BlockState getPlant(BlockView world, BlockPos pos) {\n+\t\tfinal BlockState blockState = world.getBlockState(pos);\n+\t\tif (blockState.getBlock() != (Object) this) return ((Block) (Object) this).getDefaultState();", "originalCommit": "e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODA3Mw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443918073", "bodyText": "Would this ever need to be called in mod code? If it is, just use an AW.", "author": "TheGlitch76", "createdAt": "2020-06-23T01:57:43Z", "path": "patchwork-extensions-block/src/main/java/net/patchworkmc/mixin/extensions/block/PlantTypeAccessor.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.mixin.extensions.block;\n+\n+import net.minecraftforge.common.PlantType;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.gen.Invoker;\n+\n+@Mixin(PlantType.class)\n+public interface PlantTypeAccessor {\n+\t@Invoker(\"<init>\")\n+\tstatic PlantType invokeConstructor(String constantName, int index) {", "originalCommit": "e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzNDMwOQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443934309", "bodyText": "This is the constructor on an enum. It is used for the Enum hack on our own class.", "author": "famous1622", "createdAt": "2020-06-23T03:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODIxMQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443918211", "bodyText": "If this is needed to be called in mod code just use an AW", "author": "TheGlitch76", "createdAt": "2020-06-23T01:58:11Z", "path": "patchwork-extensions-block/src/main/java/net/patchworkmc/mixin/extensions/block/PlantBlockAccessor.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.patchworkmc.mixin.extensions.block;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.gen.Invoker;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.block.PlantBlock;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.BlockView;\n+\n+@Mixin(PlantBlock.class)\n+public interface PlantBlockAccessor {\n+\t@Invoker\n+\tboolean invokeCanPlantOnTop(BlockState floor, BlockView view, BlockPos pos);", "originalCommit": "e01640067f9dfa2350e7a323ef7b5bc7da79d12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzMTk1OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/102#discussion_r443931958", "bodyText": "This is still protected in Forge, we need the Invoker because of the way that we implement IForgeBlock", "author": "famous1622", "createdAt": "2020-06-23T02:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODIxMQ=="}], "type": "inlineReview"}, {"oid": "6844d6faabe9c6e2549d4cd4c657c9f39e2b1fe1", "url": "https://github.com/PatchworkMC/patchwork-api/commit/6844d6faabe9c6e2549d4cd4c657c9f39e2b1fe1", "message": "We're not a patch file", "committedDate": "2020-06-23T03:03:11Z", "type": "commit"}, {"oid": "e5e14733fb81de65d454346c6ff2db98f22a15d6", "url": "https://github.com/PatchworkMC/patchwork-api/commit/e5e14733fb81de65d454346c6ff2db98f22a15d6", "message": "Whitespace", "committedDate": "2020-06-23T03:11:32Z", "type": "commit"}]}