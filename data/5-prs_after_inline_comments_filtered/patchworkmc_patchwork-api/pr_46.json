{"pr_number": 46, "pr_title": "IForgeItem", "pr_createdAt": "2020-02-22T23:08:12Z", "pr_url": "https://github.com/PatchworkMC/patchwork-api/pull/46", "timeline": [{"oid": "7adca88b5cf87bc91c5609665390dd950cb8b2a1", "url": "https://github.com/PatchworkMC/patchwork-api/commit/7adca88b5cf87bc91c5609665390dd950cb8b2a1", "message": "IForgeItem\n\nTasks to resolve later:\n- `getToolTypes` and `getHarvestLevel` once `ToolType` is implemented\n- Use tag from Forge Tags class in `isBeaconPayment` once implemented\n- `initCapabilities` once `ICapabilityProvider` is added\n- `getAnimationParameters` once `ITimeValue` is added\n- Move contents of `getCreatorModId` to `ForgeHooksClient`?", "committedDate": "2020-02-22T21:29:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MjgxMw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r382952813", "bodyText": "instead instead :p\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Forge does this through patching the constructor instead, we just add methods\n          \n          \n            \n             * Forge does this through patching the constructor, we just add methods", "author": "coderbot16", "createdAt": "2020-02-23T00:33:33Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/impl/extension/PatchworkItemSettingsExtensions.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.extension;\n+\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.item.Item;\n+\n+/**\n+ * Forge does this through patching the constructor instead, we just add methods", "originalCommit": "7adca88b5cf87bc91c5609665390dd950cb8b2a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MjgyNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r382952824", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tMap<Object /* ToolType */, Integer> getToolClasses();\n          \n          \n            \n            \tMap<Object /* TODO: ToolType */, Integer> getToolClasses();", "author": "coderbot16", "createdAt": "2020-02-23T00:33:53Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/impl/extension/PatchworkItemSettingsExtensions.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.extension;\n+\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.item.Item;\n+\n+/**\n+ * Forge does this through patching the constructor instead, we just add methods\n+ * with mixins instead.\n+ */\n+public interface PatchworkItemSettingsExtensions {\n+\tItem.Settings setNoRepair();\n+\n+\tItem.Settings addToolType(Object /* ToolType */ type, int level);\n+\n+\tItem.Settings setTEISR(Supplier<Callable<ItemDynamicRenderer>> teisr);\n+\n+\tboolean canRepair();\n+\n+\tMap<Object /* ToolType */, Integer> getToolClasses();", "originalCommit": "7adca88b5cf87bc91c5609665390dd950cb8b2a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MjgzMA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r382952830", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tItem.Settings addToolType(Object /* ToolType */ type, int level);\n          \n          \n            \n            \tItem.Settings addToolType(Object /* TODO: ToolType */ type, int level);", "author": "coderbot16", "createdAt": "2020-02-23T00:34:02Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/impl/extension/PatchworkItemSettingsExtensions.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.extension;\n+\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.item.Item;\n+\n+/**\n+ * Forge does this through patching the constructor instead, we just add methods\n+ * with mixins instead.\n+ */\n+public interface PatchworkItemSettingsExtensions {\n+\tItem.Settings setNoRepair();\n+\n+\tItem.Settings addToolType(Object /* ToolType */ type, int level);", "originalCommit": "7adca88b5cf87bc91c5609665390dd950cb8b2a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDU4Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r382954587", "bodyText": "Is it possible to remove all of these old MCP names?", "author": "coderbot16", "createdAt": "2020-02-23T01:14:52Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of getItemAttributeModifiers.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Called by CraftingManager to determine if an item is reparable.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * NBTTagCompound nbtShare1 = item.getNBTShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * NBTTagCompound nbtShare2 = item.getNBTShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getNBTShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of getContainerItem. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of hasContainerItem.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a 'container'\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as a EntityItem. This is in ticks, standard result is 6000, or 5 mins.", "originalCommit": "7adca88b5cf87bc91c5609665390dd950cb8b2a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDczMg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r382954732", "bodyText": "Wouldn't this always be on the client? I don't understand what the point of this code block is...", "author": "coderbot16", "createdAt": "2020-02-23T01:18:13Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/client/MixinItem.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension.client;\n+\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Unique;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import net.minecraftforge.api.distmarker.Dist;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+import net.minecraftforge.fml.DistExecutor;\n+\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.item.Item;\n+\n+import com.patchworkmc.impl.extension.PatchworkItemSettingsExtensions;\n+\n+@Mixin(Item.class)\n+public abstract class MixinItem implements IForgeItem {\n+\t@Unique\n+\t@Nullable\n+\tprivate Supplier<ItemDynamicRenderer> teisr;\n+\n+\t@Inject(at = @At(\"RETURN\"), method = \"<init>\")\n+\tprivate void onConstruct(Item.Settings settings, CallbackInfo info) {\n+\t\tfinal PatchworkItemSettingsExtensions extension = (PatchworkItemSettingsExtensions) settings;\n+\n+\t\tfinal Object tmp = extension.getTeisr() == null ? null : DistExecutor.callWhenOn(Dist.CLIENT, extension.getTeisr());", "originalCommit": "7adca88b5cf87bc91c5609665390dd950cb8b2a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDc0NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r382954745", "bodyText": "Why is a supplier needed here? Why not just use a field instead?", "author": "coderbot16", "createdAt": "2020-02-23T01:18:29Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/client/MixinItem.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension.client;\n+\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Unique;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import net.minecraftforge.api.distmarker.Dist;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+import net.minecraftforge.fml.DistExecutor;\n+\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.item.Item;\n+\n+import com.patchworkmc.impl.extension.PatchworkItemSettingsExtensions;\n+\n+@Mixin(Item.class)\n+public abstract class MixinItem implements IForgeItem {\n+\t@Unique\n+\t@Nullable\n+\tprivate Supplier<ItemDynamicRenderer> teisr;\n+\n+\t@Inject(at = @At(\"RETURN\"), method = \"<init>\")\n+\tprivate void onConstruct(Item.Settings settings, CallbackInfo info) {\n+\t\tfinal PatchworkItemSettingsExtensions extension = (PatchworkItemSettingsExtensions) settings;\n+\n+\t\tfinal Object tmp = extension.getTeisr() == null ? null : DistExecutor.callWhenOn(Dist.CLIENT, extension.getTeisr());\n+\t\tthis.teisr = tmp == null ? null : () -> (ItemDynamicRenderer) tmp;\n+\t}\n+\n+\t@Override\n+\tpublic final ItemDynamicRenderer getTileEntityItemStackRenderer() {\n+\t\tItemDynamicRenderer renderer = teisr != null ? teisr.get() : null;", "originalCommit": "7adca88b5cf87bc91c5609665390dd950cb8b2a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f3e03c145274e06277f10785bc9f791b51d2c6f", "url": "https://github.com/PatchworkMC/patchwork-api/commit/5f3e03c145274e06277f10785bc9f791b51d2c6f", "message": "Update comments", "committedDate": "2020-02-23T16:19:33Z", "type": "commit"}, {"oid": "421718d6cbbd6c2afaebb506657ee7b60c444dba", "url": "https://github.com/PatchworkMC/patchwork-api/commit/421718d6cbbd6c2afaebb506657ee7b60c444dba", "message": "ItemDynamicRenderer tweaks", "committedDate": "2020-02-23T17:48:20Z", "type": "commit"}, {"oid": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "url": "https://github.com/PatchworkMC/patchwork-api/commit/20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "message": "Tweak javadocs from YarnForge, replace old names", "committedDate": "2020-02-23T17:48:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1NDc2NA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383054764", "bodyText": "This is protected in Forge, if we make it protected it cannot be @Unique either.", "author": "coderbot16", "createdAt": "2020-02-24T00:24:36Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinItem.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.asm.mixin.Unique;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import com.google.common.collect.Maps;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.ItemTags;\n+import net.minecraft.util.Identifier;\n+\n+import com.patchworkmc.impl.extension.PatchworkItemSettingsExtensions;\n+\n+@Mixin(Item.class)\n+public abstract class MixinItem implements IForgeItem {\n+\t@Unique private Map<Object /* TODO: ToolType */, Integer> toolClasses;\n+\t@Unique private boolean canRepair;", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1NTA5Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383055097", "bodyText": "I'd like all of the methods that are not implemented (most if not all of them) to be annotated with a TODO, so we can keep track of which ones are and are not implemented.", "author": "coderbot16", "createdAt": "2020-02-24T00:28:00Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1NTQ5MQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383055491", "bodyText": ":voldethonk:", "author": "coderbot16", "createdAt": "2020-02-24T00:32:01Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getModifiers}.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Determines if an item is reparable, used by Repair recipes and Grindstone.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * CompoundTag nbtShare1 = item.getShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * CompoundTag nbtShare2 = item.getShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getRecipeRemainder()}. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#hasRecipeRemainder()}.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a recipe remainder\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as an {@link ItemEntity}. This is in ticks, standard result is 6000, or 5 mins.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @param world     The world the entity is in\n+\t * @return The normal lifespan in ticks.\n+\t */\n+\tdefault int getEntityLifespan(ItemStack itemStack, World world) {\n+\t\treturn 6000;\n+\t}\n+\n+\t/**\n+\t * Determines if this {@link Item} has a special entity for when it is in the world.\n+\t * Is called when an {@link ItemEntity} is spawned in the world, if true and\n+\t * {@link #createEntity(World, Entity, ItemStack)} returns non null, the ItemEntity will be destroyed\n+\t * and the new Entity will be added to the world.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True of the item has a custom entity, If true,\n+\t * {@link #createEntity(World, Entity, ItemStack)} will be called\n+\t */\n+\tdefault boolean hasCustomEntity(ItemStack stack) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * This function should return a new entity to replace the dropped item.\n+\t * Returning null here will not kill the ItemEntity and will leave it to\n+\t * function normally. Called when the item is spawned in a world.\n+\t *\n+\t * @param world     The world object\n+\t * @param location  The ItemEntity object, useful for getting the position of\n+\t *                  the entity\n+\t * @param itemstack The current item stack\n+\t * @return A new Entity object to spawn or null\n+\t */\n+\t@Nullable\n+\tdefault Entity createEntity(World world, Entity location, ItemStack itemstack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called by the default implemetation of {@link ItemEntity#tick()}, allowing\n+\t * for cleaner control over the update of the item without having to write a\n+\t * subclass.\n+\t *\n+\t * @param entity The entity Item\n+\t * @return Return true to skip any further update code.\n+\t */\n+\tdefault boolean onEntityItemUpdate(ItemStack stack, ItemEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Gets a list of tabs that items belonging to this class can display on,\n+\t * combined properly with {@link Item#getGroup()} allows for a single item to span many\n+\t * sub-items across many tabs.\n+\t *\n+\t * @return A list of all tabs that this item could possibly be one.\n+\t */\n+\tdefault Collection<ItemGroup> getCreativeTabs() {\n+\t\treturn Collections.singletonList(getItem().getGroup());\n+\t}\n+\n+\t/**\n+\t * Determines the base experience for a player when they remove this item from a\n+\t * furnace slot. This number must be between 0 and 1 for it to be valid. This\n+\t * number will be multiplied by the stack size to get the total experience.\n+\t *\n+\t * @param item The item stack the player is picking up.\n+\t * @return The amount to award for each item.\n+\t */\n+\tdefault float getSmeltingExperience(ItemStack item) {\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Should this item, when held, allow sneak-clicks to pass through to the\n+\t * underlying block?\n+\t *\n+\t * @param world  The world\n+\t * @param pos    Block position in world\n+\t * @param player The Player that is wielding the item\n+\t * @return\n+\t */\n+\tdefault boolean doesSneakBypassUse(ItemStack stack, ViewableWorld world, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called to tick armor in the armor slot. Override to do something\n+\t */\n+\tdefault void onArmorTick(ItemStack stack, World world, PlayerEntity player) {\n+\t}\n+\n+\t/**\n+\t * Determines if the specific ItemStack can be placed in the specified armor\n+\t * slot, for the entity.\n+\t *\n+\t * @param stack     The ItemStack\n+\t * @param armorType Equipment slot to be verified.\n+\t * @param entity    The entity trying to equip the armor\n+\t * @return True if the given ItemStack can be inserted in the slot\n+\t */\n+\tdefault boolean canEquip(ItemStack stack, EquipmentSlot armorType, Entity entity) {\n+\t\treturn MobEntity.getPreferredEquipmentSlot(stack) == armorType;\n+\t}\n+\n+\t/**\n+\t * Override this to set a non-default armor slot for an ItemStack, but <em>do\n+\t * not use this to get the armor slot of said stack; for that, use\n+\t * {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}.</em>\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return the armor slot of the ItemStack, or {@code null} to let the default\n+\t * vanilla logic as per {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}\n+\t * decide\n+\t */\n+\t@Nullable\n+\tdefault EquipmentSlot getEquipmentSlot(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Allow or forbid the specific book/item combination as an anvil enchant.\n+\t *\n+\t * @param stack The item\n+\t * @param book  The book\n+\t * @return if the enchantment is allowed\n+\t */\n+\tdefault boolean isBookEnchantable(ItemStack stack, ItemStack book) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Called to determine the armor texture that should be use for the currently\n+\t * equipped item. This will only be called on instances of ArmorItem\n+\t *\n+\t * <p>Returning null from this function will use the default value.\n+\t *\n+\t * @param stack  ItemStack for the equipped armor\n+\t * @param entity The entity wearing the armor\n+\t * @param slot   The slot the armor is in\n+\t * @param type   The subtype, can be null or \"overlay\"\n+\t * @return Path of texture to bind, or null to use default\n+\t */\n+\t@Nullable\n+\tdefault String getArmorTexture(ItemStack stack, Entity entity, EquipmentSlot slot, String type) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Returns the text renderer used to render tooltips and overlays for this item.\n+\t * Returning null will use the standard text renderer.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return A instance of TextRenderer or null to use default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault TextRenderer getFontRenderer(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Override this method to have an item handle its own armor rendering.\n+\t *\n+\t * @param entityLiving The entity wearing the armor\n+\t * @param itemStack    The itemStack to render the model of\n+\t * @param armorSlot    The slot the armor is in\n+\t * @param _default     Original armor model. Will have attributes set.\n+\t * @return A BipedEntityModel to render instead of the default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault <A extends BipedEntityModel<?>> A getArmorModel(LivingEntity entityLiving, ItemStack itemStack, EquipmentSlot armorSlot, A _default) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called when a entity tries to play the 'swing' animation.\n+\t *\n+\t * @param entity The entity swinging the item.\n+\t * @return True to cancel any further processing by LivingEntity\n+\t */\n+\tdefault boolean onEntitySwing(ItemStack stack, LivingEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called when the client starts rendering the HUD, for whatever item the player\n+\t * currently has as a helmet. This is where pumpkins would render there overlay.\n+\t *\n+\t * @param stack        The ItemStack that is equipped\n+\t * @param player       Reference to the current client entity\n+\t * @param resolution   Resolution information about the current viewport and\n+\t *                     configured GUI Scale\n+\t * @param partialTicks Partial ticks for the renderer, useful for interpolation\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault void renderHelmetOverlay(ItemStack stack, PlayerEntity player, int width, int height, float partialTicks) {\n+\t}\n+\n+\t/**\n+\t * Return the itemDamage represented by this ItemStack. Defaults to the Damage\n+\t * entry in the stack NBT, but can be overridden here for other sources.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getDamage(ItemStack stack) {\n+\t\treturn !stack.hasTag() ? 0 : stack.getTag().getInt(\"Damage\");\n+\t}\n+\n+\t/**\n+\t * Determines if the durability bar should be rendered for this item. Defaults\n+\t * to vanilla {@link ItemStack#isDamaged()} behavior. But modders can use this\n+\t * for any data they wish.\n+\t *\n+\t * @param stack The current Item Stack\n+\t * @return True if it should render the 'durability' bar.\n+\t */\n+\tdefault boolean showDurabilityBar(ItemStack stack) {\n+\t\treturn stack.isDamaged();\n+\t}\n+\n+\t/**\n+\t * Queries the percentage of the 'Durability' bar that should be drawn.\n+\t *\n+\t * @param stack The current ItemStack\n+\t * @return 0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged /\n+\t * empty bar)\n+\t */\n+\tdefault double getDurabilityForDisplay(ItemStack stack) {\n+\t\treturn (double) stack.getDamage() / (double) stack.getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Returns the packed int RGB value used to render the durability bar in the\n+\t * GUI. Defaults to a value based on the hue scaled based on\n+\t * {@link #getDurabilityForDisplay}, but can be overriden.\n+\t *\n+\t * @param stack Stack to get durability from\n+\t * @return A packed RGB value for the durability colour (0x00RRGGBB)\n+\t */\n+\tdefault int getRGBDurabilityForDisplay(ItemStack stack) {\n+\t\treturn MathHelper.hsvToRgb(Math.max(0.0F, (float) (1.0F - getDurabilityForDisplay(stack))) / 3.0F, 1.0F, 1.0F);\n+\t}\n+\n+\t/**\n+\t * Return the maxDamage for this ItemStack. Defaults to the maxDamage field in\n+\t * this item, but can be overridden here for other sources such as NBT.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getMaxDamage(ItemStack stack) {\n+\t\treturn getItem().getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Return if this itemstack is damaged. Note only called if\n+\t * {@link Item#isDamageable()} is true.\n+\t *\n+\t * @param stack the stack\n+\t * @return if the stack is damaged\n+\t */\n+\tdefault boolean isDamaged(ItemStack stack) {\n+\t\treturn stack.getDamage() > 0;\n+\t}\n+\n+\t/**\n+\t * Set the damage for this itemstack. Note, this method is responsible for zero\n+\t * checking.\n+\t *\n+\t * @param stack  the stack\n+\t * @param damage the new damage value\n+\t */\n+\tdefault void setDamage(ItemStack stack, int damage) {\n+\t\tstack.getOrCreateTag().putInt(\"Damage\", Math.max(0, damage));\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#isEffectiveOn(BlockState)}.\n+\t *\n+\t * @param stack The itemstack used to harvest the block\n+\t * @param state The block trying to harvest\n+\t * @return true if can harvest the block\n+\t */\n+\tdefault boolean canHarvestBlock(ItemStack stack, BlockState state) {\n+\t\treturn getItem().isEffectiveOn(state);\n+\t}\n+\n+\t/**\n+\t * Gets the maximum number of items that this stack should be able to hold. This\n+\t * is a ItemStack (and thus NBT) sensitive version of {@link Item#getMaxCount()}\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return The maximum number this item can be stacked to\n+\t */\n+\tdefault int getItemStackLimit(ItemStack stack) {\n+\t\treturn getItem().getMaxCount();\n+\t}\n+\n+\tSet<Object /* TODO: ToolType */> getToolTypes(ItemStack stack);\n+\n+\t/**\n+\t * Queries the harvest level of this item stack for the specified tool type,\n+\t * Returns -1 if this tool is not of the specified type.\n+\t *\n+\t * @param stack      This item stack instance\n+\t * @param tool       Tool type\n+\t * @param player     The player trying to harvest the given blockstate\n+\t * @param blockState The block to harvest\n+\t * @return Harvest level, or -1 if not the specified tool type.\n+\t */\n+\tint getHarvestLevel(ItemStack stack, Object /* TODO: ToolType */ tool, @Nullable PlayerEntity player, @Nullable BlockState blockState);\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getEnchantability()}.\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return the item echantability value\n+\t */\n+\tdefault int getItemEnchantability(ItemStack stack) {\n+\t\treturn getItem().getEnchantability();\n+\t}\n+\n+\t/**\n+\t * Checks whether an item can be enchanted with a certain enchantment. This\n+\t * applies specifically to enchanting an item in the enchanting table and is\n+\t * called when retrieving the list of possible enchantments for an item.\n+\t * Enchantments may additionally (or exclusively) be doing their own checks in\n+\t * {@link net.minecraft.enchantment.Enchantment#isAcceptableItem(ItemStack)};\n+\t * check the individual implementation for reference. By default this will check\n+\t * if the enchantment type is valid for this item type.\n+\t *\n+\t * @param stack       the item stack to be enchanted\n+\t * @param enchantment the enchantment to be applied\n+\t * @return true if the enchantment can be applied to this item\n+\t */\n+\tdefault boolean canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment) {\n+\t\treturn enchantment.type.isAcceptableItem(stack.getItem());\n+\t}\n+\n+\t@Deprecated // TODO move once net.minecraftforge.common.Tags is added\n+\tTag<Item> BEACON_PAYMENT = TagRegistry.item(new Identifier(\"forge\", \"beacon_payment\"));\n+\n+\t/**\n+\t * Whether this Item can be used as a payment to activate the vanilla beacon.\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return true if this Item can be used\n+\t */\n+\tdefault boolean isBeaconPayment(ItemStack stack) {\n+\t\treturn BEACON_PAYMENT.contains(stack.getItem());\n+\t}\n+\n+\t/**\n+\t * Determine if the player switching between these two item stacks.\n+\t *\n+\t * @param oldStack    The old stack that was equipped\n+\t * @param newStack    The new stack\n+\t * @param slotChanged If the current equipped slot was changed, Vanilla does not\n+\t *                    play the animation if you switch between two slots that\n+\t *                    hold the exact same item.\n+\t * @return True to play the item change animation\n+\t */\n+\tdefault boolean shouldCauseReequipAnimation(ItemStack oldStack, ItemStack newStack, boolean slotChanged) {\n+\t\treturn !oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called when the player is mining a block and the item in his hand changes.\n+\t * Allows to not reset block breaking if only NBT or similar changes.\n+\t *\n+\t * @param oldStack The old stack that was used for mining. Item in players main\n+\t *                 hand\n+\t * @param newStack The new stack\n+\t * @return True to reset block break progress\n+\t */\n+\tdefault boolean shouldCauseBlockBreakReset(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn !(newStack.getItem() == oldStack.getItem() && ItemStack.areTagsEqual(newStack, oldStack)\n+\t\t\t&& (newStack.isDamageable() || newStack.getDamage() == oldStack.getDamage()));\n+\t}\n+\n+\t/**\n+\t * Called while an item is in 'active' use to determine if usage should\n+\t * continue. Allows items to continue being used while sustaining damage, for\n+\t * example.\n+\t *\n+\t * @param oldStack the previous 'active' stack\n+\t * @param newStack the stack currently in the active hand\n+\t * @return true to set the new stack to active and continue using it\n+\t */\n+\tdefault boolean canContinueUsing(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called to get the Mod ID of the mod that *created* the ItemStack, instead of\n+\t * the real Mod ID that *registered* it.\n+\t *\n+\t * <p>For example the Forge Universal Bucket creates a subitem for each modded\n+\t * fluid, and it returns the modded fluid's Mod ID here.\n+\t *\n+\t * <p>Mods that register subitems for other mods can override this. Informational\n+\t * mods can call it to show the mod that created the item.\n+\t *\n+\t * @param itemStack the ItemStack to check\n+\t * @return the Mod ID for the ItemStack, or null when there is no specially\n+\t * associated mod and {@link Registry#getId(Item)} would return null.\n+\t */\n+\t@Nullable\n+\tdefault String getCreatorModId(ItemStack itemStack) {\n+\t\tItem item = itemStack.getItem();\n+\t\tIdentifier registryName = Registry.ITEM.getId(item);\n+\t\tString modId = registryName == null ? null : registryName.getNamespace();\n+\n+\t\tif (\"minecraft\".equals(modId)) {\n+\t\t\tif (item instanceof EnchantedBookItem) {\n+\t\t\t\tListTag enchantmentsNbt = EnchantedBookItem.getEnchantmentTag(itemStack);\n+\n+\t\t\t\tif (enchantmentsNbt.size() == 1) {\n+\t\t\t\t\tCompoundTag nbttagcompound = enchantmentsNbt.getCompoundTag(0);", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1NjExNA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383056114", "bodyText": "I think we should just add this stuff to mixins to each class instead. The reason Forge does it like this is likely to reduce the size of patches.", "author": "coderbot16", "createdAt": "2020-02-24T00:38:55Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getModifiers}.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Determines if an item is reparable, used by Repair recipes and Grindstone.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * CompoundTag nbtShare1 = item.getShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * CompoundTag nbtShare2 = item.getShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getRecipeRemainder()}. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#hasRecipeRemainder()}.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a recipe remainder\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as an {@link ItemEntity}. This is in ticks, standard result is 6000, or 5 mins.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @param world     The world the entity is in\n+\t * @return The normal lifespan in ticks.\n+\t */\n+\tdefault int getEntityLifespan(ItemStack itemStack, World world) {\n+\t\treturn 6000;\n+\t}\n+\n+\t/**\n+\t * Determines if this {@link Item} has a special entity for when it is in the world.\n+\t * Is called when an {@link ItemEntity} is spawned in the world, if true and\n+\t * {@link #createEntity(World, Entity, ItemStack)} returns non null, the ItemEntity will be destroyed\n+\t * and the new Entity will be added to the world.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True of the item has a custom entity, If true,\n+\t * {@link #createEntity(World, Entity, ItemStack)} will be called\n+\t */\n+\tdefault boolean hasCustomEntity(ItemStack stack) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * This function should return a new entity to replace the dropped item.\n+\t * Returning null here will not kill the ItemEntity and will leave it to\n+\t * function normally. Called when the item is spawned in a world.\n+\t *\n+\t * @param world     The world object\n+\t * @param location  The ItemEntity object, useful for getting the position of\n+\t *                  the entity\n+\t * @param itemstack The current item stack\n+\t * @return A new Entity object to spawn or null\n+\t */\n+\t@Nullable\n+\tdefault Entity createEntity(World world, Entity location, ItemStack itemstack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called by the default implemetation of {@link ItemEntity#tick()}, allowing\n+\t * for cleaner control over the update of the item without having to write a\n+\t * subclass.\n+\t *\n+\t * @param entity The entity Item\n+\t * @return Return true to skip any further update code.\n+\t */\n+\tdefault boolean onEntityItemUpdate(ItemStack stack, ItemEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Gets a list of tabs that items belonging to this class can display on,\n+\t * combined properly with {@link Item#getGroup()} allows for a single item to span many\n+\t * sub-items across many tabs.\n+\t *\n+\t * @return A list of all tabs that this item could possibly be one.\n+\t */\n+\tdefault Collection<ItemGroup> getCreativeTabs() {\n+\t\treturn Collections.singletonList(getItem().getGroup());\n+\t}\n+\n+\t/**\n+\t * Determines the base experience for a player when they remove this item from a\n+\t * furnace slot. This number must be between 0 and 1 for it to be valid. This\n+\t * number will be multiplied by the stack size to get the total experience.\n+\t *\n+\t * @param item The item stack the player is picking up.\n+\t * @return The amount to award for each item.\n+\t */\n+\tdefault float getSmeltingExperience(ItemStack item) {\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Should this item, when held, allow sneak-clicks to pass through to the\n+\t * underlying block?\n+\t *\n+\t * @param world  The world\n+\t * @param pos    Block position in world\n+\t * @param player The Player that is wielding the item\n+\t * @return\n+\t */\n+\tdefault boolean doesSneakBypassUse(ItemStack stack, ViewableWorld world, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called to tick armor in the armor slot. Override to do something\n+\t */\n+\tdefault void onArmorTick(ItemStack stack, World world, PlayerEntity player) {\n+\t}\n+\n+\t/**\n+\t * Determines if the specific ItemStack can be placed in the specified armor\n+\t * slot, for the entity.\n+\t *\n+\t * @param stack     The ItemStack\n+\t * @param armorType Equipment slot to be verified.\n+\t * @param entity    The entity trying to equip the armor\n+\t * @return True if the given ItemStack can be inserted in the slot\n+\t */\n+\tdefault boolean canEquip(ItemStack stack, EquipmentSlot armorType, Entity entity) {\n+\t\treturn MobEntity.getPreferredEquipmentSlot(stack) == armorType;\n+\t}\n+\n+\t/**\n+\t * Override this to set a non-default armor slot for an ItemStack, but <em>do\n+\t * not use this to get the armor slot of said stack; for that, use\n+\t * {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}.</em>\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return the armor slot of the ItemStack, or {@code null} to let the default\n+\t * vanilla logic as per {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}\n+\t * decide\n+\t */\n+\t@Nullable\n+\tdefault EquipmentSlot getEquipmentSlot(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Allow or forbid the specific book/item combination as an anvil enchant.\n+\t *\n+\t * @param stack The item\n+\t * @param book  The book\n+\t * @return if the enchantment is allowed\n+\t */\n+\tdefault boolean isBookEnchantable(ItemStack stack, ItemStack book) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Called to determine the armor texture that should be use for the currently\n+\t * equipped item. This will only be called on instances of ArmorItem\n+\t *\n+\t * <p>Returning null from this function will use the default value.\n+\t *\n+\t * @param stack  ItemStack for the equipped armor\n+\t * @param entity The entity wearing the armor\n+\t * @param slot   The slot the armor is in\n+\t * @param type   The subtype, can be null or \"overlay\"\n+\t * @return Path of texture to bind, or null to use default\n+\t */\n+\t@Nullable\n+\tdefault String getArmorTexture(ItemStack stack, Entity entity, EquipmentSlot slot, String type) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Returns the text renderer used to render tooltips and overlays for this item.\n+\t * Returning null will use the standard text renderer.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return A instance of TextRenderer or null to use default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault TextRenderer getFontRenderer(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Override this method to have an item handle its own armor rendering.\n+\t *\n+\t * @param entityLiving The entity wearing the armor\n+\t * @param itemStack    The itemStack to render the model of\n+\t * @param armorSlot    The slot the armor is in\n+\t * @param _default     Original armor model. Will have attributes set.\n+\t * @return A BipedEntityModel to render instead of the default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault <A extends BipedEntityModel<?>> A getArmorModel(LivingEntity entityLiving, ItemStack itemStack, EquipmentSlot armorSlot, A _default) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called when a entity tries to play the 'swing' animation.\n+\t *\n+\t * @param entity The entity swinging the item.\n+\t * @return True to cancel any further processing by LivingEntity\n+\t */\n+\tdefault boolean onEntitySwing(ItemStack stack, LivingEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called when the client starts rendering the HUD, for whatever item the player\n+\t * currently has as a helmet. This is where pumpkins would render there overlay.\n+\t *\n+\t * @param stack        The ItemStack that is equipped\n+\t * @param player       Reference to the current client entity\n+\t * @param resolution   Resolution information about the current viewport and\n+\t *                     configured GUI Scale\n+\t * @param partialTicks Partial ticks for the renderer, useful for interpolation\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault void renderHelmetOverlay(ItemStack stack, PlayerEntity player, int width, int height, float partialTicks) {\n+\t}\n+\n+\t/**\n+\t * Return the itemDamage represented by this ItemStack. Defaults to the Damage\n+\t * entry in the stack NBT, but can be overridden here for other sources.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getDamage(ItemStack stack) {\n+\t\treturn !stack.hasTag() ? 0 : stack.getTag().getInt(\"Damage\");\n+\t}\n+\n+\t/**\n+\t * Determines if the durability bar should be rendered for this item. Defaults\n+\t * to vanilla {@link ItemStack#isDamaged()} behavior. But modders can use this\n+\t * for any data they wish.\n+\t *\n+\t * @param stack The current Item Stack\n+\t * @return True if it should render the 'durability' bar.\n+\t */\n+\tdefault boolean showDurabilityBar(ItemStack stack) {\n+\t\treturn stack.isDamaged();\n+\t}\n+\n+\t/**\n+\t * Queries the percentage of the 'Durability' bar that should be drawn.\n+\t *\n+\t * @param stack The current ItemStack\n+\t * @return 0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged /\n+\t * empty bar)\n+\t */\n+\tdefault double getDurabilityForDisplay(ItemStack stack) {\n+\t\treturn (double) stack.getDamage() / (double) stack.getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Returns the packed int RGB value used to render the durability bar in the\n+\t * GUI. Defaults to a value based on the hue scaled based on\n+\t * {@link #getDurabilityForDisplay}, but can be overriden.\n+\t *\n+\t * @param stack Stack to get durability from\n+\t * @return A packed RGB value for the durability colour (0x00RRGGBB)\n+\t */\n+\tdefault int getRGBDurabilityForDisplay(ItemStack stack) {\n+\t\treturn MathHelper.hsvToRgb(Math.max(0.0F, (float) (1.0F - getDurabilityForDisplay(stack))) / 3.0F, 1.0F, 1.0F);\n+\t}\n+\n+\t/**\n+\t * Return the maxDamage for this ItemStack. Defaults to the maxDamage field in\n+\t * this item, but can be overridden here for other sources such as NBT.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getMaxDamage(ItemStack stack) {\n+\t\treturn getItem().getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Return if this itemstack is damaged. Note only called if\n+\t * {@link Item#isDamageable()} is true.\n+\t *\n+\t * @param stack the stack\n+\t * @return if the stack is damaged\n+\t */\n+\tdefault boolean isDamaged(ItemStack stack) {\n+\t\treturn stack.getDamage() > 0;\n+\t}\n+\n+\t/**\n+\t * Set the damage for this itemstack. Note, this method is responsible for zero\n+\t * checking.\n+\t *\n+\t * @param stack  the stack\n+\t * @param damage the new damage value\n+\t */\n+\tdefault void setDamage(ItemStack stack, int damage) {\n+\t\tstack.getOrCreateTag().putInt(\"Damage\", Math.max(0, damage));\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#isEffectiveOn(BlockState)}.\n+\t *\n+\t * @param stack The itemstack used to harvest the block\n+\t * @param state The block trying to harvest\n+\t * @return true if can harvest the block\n+\t */\n+\tdefault boolean canHarvestBlock(ItemStack stack, BlockState state) {\n+\t\treturn getItem().isEffectiveOn(state);\n+\t}\n+\n+\t/**\n+\t * Gets the maximum number of items that this stack should be able to hold. This\n+\t * is a ItemStack (and thus NBT) sensitive version of {@link Item#getMaxCount()}\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return The maximum number this item can be stacked to\n+\t */\n+\tdefault int getItemStackLimit(ItemStack stack) {\n+\t\treturn getItem().getMaxCount();\n+\t}\n+\n+\tSet<Object /* TODO: ToolType */> getToolTypes(ItemStack stack);\n+\n+\t/**\n+\t * Queries the harvest level of this item stack for the specified tool type,\n+\t * Returns -1 if this tool is not of the specified type.\n+\t *\n+\t * @param stack      This item stack instance\n+\t * @param tool       Tool type\n+\t * @param player     The player trying to harvest the given blockstate\n+\t * @param blockState The block to harvest\n+\t * @return Harvest level, or -1 if not the specified tool type.\n+\t */\n+\tint getHarvestLevel(ItemStack stack, Object /* TODO: ToolType */ tool, @Nullable PlayerEntity player, @Nullable BlockState blockState);\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getEnchantability()}.\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return the item echantability value\n+\t */\n+\tdefault int getItemEnchantability(ItemStack stack) {\n+\t\treturn getItem().getEnchantability();\n+\t}\n+\n+\t/**\n+\t * Checks whether an item can be enchanted with a certain enchantment. This\n+\t * applies specifically to enchanting an item in the enchanting table and is\n+\t * called when retrieving the list of possible enchantments for an item.\n+\t * Enchantments may additionally (or exclusively) be doing their own checks in\n+\t * {@link net.minecraft.enchantment.Enchantment#isAcceptableItem(ItemStack)};\n+\t * check the individual implementation for reference. By default this will check\n+\t * if the enchantment type is valid for this item type.\n+\t *\n+\t * @param stack       the item stack to be enchanted\n+\t * @param enchantment the enchantment to be applied\n+\t * @return true if the enchantment can be applied to this item\n+\t */\n+\tdefault boolean canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment) {\n+\t\treturn enchantment.type.isAcceptableItem(stack.getItem());\n+\t}\n+\n+\t@Deprecated // TODO move once net.minecraftforge.common.Tags is added\n+\tTag<Item> BEACON_PAYMENT = TagRegistry.item(new Identifier(\"forge\", \"beacon_payment\"));\n+\n+\t/**\n+\t * Whether this Item can be used as a payment to activate the vanilla beacon.\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return true if this Item can be used\n+\t */\n+\tdefault boolean isBeaconPayment(ItemStack stack) {\n+\t\treturn BEACON_PAYMENT.contains(stack.getItem());\n+\t}\n+\n+\t/**\n+\t * Determine if the player switching between these two item stacks.\n+\t *\n+\t * @param oldStack    The old stack that was equipped\n+\t * @param newStack    The new stack\n+\t * @param slotChanged If the current equipped slot was changed, Vanilla does not\n+\t *                    play the animation if you switch between two slots that\n+\t *                    hold the exact same item.\n+\t * @return True to play the item change animation\n+\t */\n+\tdefault boolean shouldCauseReequipAnimation(ItemStack oldStack, ItemStack newStack, boolean slotChanged) {\n+\t\treturn !oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called when the player is mining a block and the item in his hand changes.\n+\t * Allows to not reset block breaking if only NBT or similar changes.\n+\t *\n+\t * @param oldStack The old stack that was used for mining. Item in players main\n+\t *                 hand\n+\t * @param newStack The new stack\n+\t * @return True to reset block break progress\n+\t */\n+\tdefault boolean shouldCauseBlockBreakReset(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn !(newStack.getItem() == oldStack.getItem() && ItemStack.areTagsEqual(newStack, oldStack)\n+\t\t\t&& (newStack.isDamageable() || newStack.getDamage() == oldStack.getDamage()));\n+\t}\n+\n+\t/**\n+\t * Called while an item is in 'active' use to determine if usage should\n+\t * continue. Allows items to continue being used while sustaining damage, for\n+\t * example.\n+\t *\n+\t * @param oldStack the previous 'active' stack\n+\t * @param newStack the stack currently in the active hand\n+\t * @return true to set the new stack to active and continue using it\n+\t */\n+\tdefault boolean canContinueUsing(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called to get the Mod ID of the mod that *created* the ItemStack, instead of\n+\t * the real Mod ID that *registered* it.\n+\t *\n+\t * <p>For example the Forge Universal Bucket creates a subitem for each modded\n+\t * fluid, and it returns the modded fluid's Mod ID here.\n+\t *\n+\t * <p>Mods that register subitems for other mods can override this. Informational\n+\t * mods can call it to show the mod that created the item.\n+\t *\n+\t * @param itemStack the ItemStack to check\n+\t * @return the Mod ID for the ItemStack, or null when there is no specially\n+\t * associated mod and {@link Registry#getId(Item)} would return null.\n+\t */\n+\t@Nullable\n+\tdefault String getCreatorModId(ItemStack itemStack) {\n+\t\tItem item = itemStack.getItem();\n+\t\tIdentifier registryName = Registry.ITEM.getId(item);\n+\t\tString modId = registryName == null ? null : registryName.getNamespace();\n+\n+\t\tif (\"minecraft\".equals(modId)) {\n+\t\t\tif (item instanceof EnchantedBookItem) {", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA1NjY3Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383056676", "bodyText": "Not responsible for any?", "author": "coderbot16", "createdAt": "2020-02-24T00:45:06Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getModifiers}.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Determines if an item is reparable, used by Repair recipes and Grindstone.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * CompoundTag nbtShare1 = item.getShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * CompoundTag nbtShare2 = item.getShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getRecipeRemainder()}. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#hasRecipeRemainder()}.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a recipe remainder\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as an {@link ItemEntity}. This is in ticks, standard result is 6000, or 5 mins.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @param world     The world the entity is in\n+\t * @return The normal lifespan in ticks.\n+\t */\n+\tdefault int getEntityLifespan(ItemStack itemStack, World world) {\n+\t\treturn 6000;\n+\t}\n+\n+\t/**\n+\t * Determines if this {@link Item} has a special entity for when it is in the world.\n+\t * Is called when an {@link ItemEntity} is spawned in the world, if true and\n+\t * {@link #createEntity(World, Entity, ItemStack)} returns non null, the ItemEntity will be destroyed\n+\t * and the new Entity will be added to the world.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True of the item has a custom entity, If true,\n+\t * {@link #createEntity(World, Entity, ItemStack)} will be called\n+\t */\n+\tdefault boolean hasCustomEntity(ItemStack stack) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * This function should return a new entity to replace the dropped item.\n+\t * Returning null here will not kill the ItemEntity and will leave it to\n+\t * function normally. Called when the item is spawned in a world.\n+\t *\n+\t * @param world     The world object\n+\t * @param location  The ItemEntity object, useful for getting the position of\n+\t *                  the entity\n+\t * @param itemstack The current item stack\n+\t * @return A new Entity object to spawn or null\n+\t */\n+\t@Nullable\n+\tdefault Entity createEntity(World world, Entity location, ItemStack itemstack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called by the default implemetation of {@link ItemEntity#tick()}, allowing\n+\t * for cleaner control over the update of the item without having to write a\n+\t * subclass.\n+\t *\n+\t * @param entity The entity Item\n+\t * @return Return true to skip any further update code.\n+\t */\n+\tdefault boolean onEntityItemUpdate(ItemStack stack, ItemEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Gets a list of tabs that items belonging to this class can display on,\n+\t * combined properly with {@link Item#getGroup()} allows for a single item to span many\n+\t * sub-items across many tabs.\n+\t *\n+\t * @return A list of all tabs that this item could possibly be one.\n+\t */\n+\tdefault Collection<ItemGroup> getCreativeTabs() {\n+\t\treturn Collections.singletonList(getItem().getGroup());\n+\t}\n+\n+\t/**\n+\t * Determines the base experience for a player when they remove this item from a\n+\t * furnace slot. This number must be between 0 and 1 for it to be valid. This\n+\t * number will be multiplied by the stack size to get the total experience.\n+\t *\n+\t * @param item The item stack the player is picking up.\n+\t * @return The amount to award for each item.\n+\t */\n+\tdefault float getSmeltingExperience(ItemStack item) {\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Should this item, when held, allow sneak-clicks to pass through to the\n+\t * underlying block?\n+\t *\n+\t * @param world  The world\n+\t * @param pos    Block position in world\n+\t * @param player The Player that is wielding the item\n+\t * @return\n+\t */\n+\tdefault boolean doesSneakBypassUse(ItemStack stack, ViewableWorld world, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called to tick armor in the armor slot. Override to do something\n+\t */\n+\tdefault void onArmorTick(ItemStack stack, World world, PlayerEntity player) {\n+\t}\n+\n+\t/**\n+\t * Determines if the specific ItemStack can be placed in the specified armor\n+\t * slot, for the entity.\n+\t *\n+\t * @param stack     The ItemStack\n+\t * @param armorType Equipment slot to be verified.\n+\t * @param entity    The entity trying to equip the armor\n+\t * @return True if the given ItemStack can be inserted in the slot\n+\t */\n+\tdefault boolean canEquip(ItemStack stack, EquipmentSlot armorType, Entity entity) {\n+\t\treturn MobEntity.getPreferredEquipmentSlot(stack) == armorType;\n+\t}\n+\n+\t/**\n+\t * Override this to set a non-default armor slot for an ItemStack, but <em>do\n+\t * not use this to get the armor slot of said stack; for that, use\n+\t * {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}.</em>\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return the armor slot of the ItemStack, or {@code null} to let the default\n+\t * vanilla logic as per {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}\n+\t * decide\n+\t */\n+\t@Nullable\n+\tdefault EquipmentSlot getEquipmentSlot(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Allow or forbid the specific book/item combination as an anvil enchant.\n+\t *\n+\t * @param stack The item\n+\t * @param book  The book\n+\t * @return if the enchantment is allowed\n+\t */\n+\tdefault boolean isBookEnchantable(ItemStack stack, ItemStack book) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Called to determine the armor texture that should be use for the currently\n+\t * equipped item. This will only be called on instances of ArmorItem\n+\t *\n+\t * <p>Returning null from this function will use the default value.\n+\t *\n+\t * @param stack  ItemStack for the equipped armor\n+\t * @param entity The entity wearing the armor\n+\t * @param slot   The slot the armor is in\n+\t * @param type   The subtype, can be null or \"overlay\"\n+\t * @return Path of texture to bind, or null to use default\n+\t */\n+\t@Nullable\n+\tdefault String getArmorTexture(ItemStack stack, Entity entity, EquipmentSlot slot, String type) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Returns the text renderer used to render tooltips and overlays for this item.\n+\t * Returning null will use the standard text renderer.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return A instance of TextRenderer or null to use default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault TextRenderer getFontRenderer(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Override this method to have an item handle its own armor rendering.\n+\t *\n+\t * @param entityLiving The entity wearing the armor\n+\t * @param itemStack    The itemStack to render the model of\n+\t * @param armorSlot    The slot the armor is in\n+\t * @param _default     Original armor model. Will have attributes set.\n+\t * @return A BipedEntityModel to render instead of the default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault <A extends BipedEntityModel<?>> A getArmorModel(LivingEntity entityLiving, ItemStack itemStack, EquipmentSlot armorSlot, A _default) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called when a entity tries to play the 'swing' animation.\n+\t *\n+\t * @param entity The entity swinging the item.\n+\t * @return True to cancel any further processing by LivingEntity\n+\t */\n+\tdefault boolean onEntitySwing(ItemStack stack, LivingEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called when the client starts rendering the HUD, for whatever item the player\n+\t * currently has as a helmet. This is where pumpkins would render there overlay.\n+\t *\n+\t * @param stack        The ItemStack that is equipped\n+\t * @param player       Reference to the current client entity\n+\t * @param resolution   Resolution information about the current viewport and\n+\t *                     configured GUI Scale\n+\t * @param partialTicks Partial ticks for the renderer, useful for interpolation\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault void renderHelmetOverlay(ItemStack stack, PlayerEntity player, int width, int height, float partialTicks) {\n+\t}\n+\n+\t/**\n+\t * Return the itemDamage represented by this ItemStack. Defaults to the Damage\n+\t * entry in the stack NBT, but can be overridden here for other sources.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getDamage(ItemStack stack) {\n+\t\treturn !stack.hasTag() ? 0 : stack.getTag().getInt(\"Damage\");\n+\t}\n+\n+\t/**\n+\t * Determines if the durability bar should be rendered for this item. Defaults\n+\t * to vanilla {@link ItemStack#isDamaged()} behavior. But modders can use this\n+\t * for any data they wish.\n+\t *\n+\t * @param stack The current Item Stack\n+\t * @return True if it should render the 'durability' bar.\n+\t */\n+\tdefault boolean showDurabilityBar(ItemStack stack) {\n+\t\treturn stack.isDamaged();\n+\t}\n+\n+\t/**\n+\t * Queries the percentage of the 'Durability' bar that should be drawn.\n+\t *\n+\t * @param stack The current ItemStack\n+\t * @return 0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged /\n+\t * empty bar)\n+\t */\n+\tdefault double getDurabilityForDisplay(ItemStack stack) {\n+\t\treturn (double) stack.getDamage() / (double) stack.getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Returns the packed int RGB value used to render the durability bar in the\n+\t * GUI. Defaults to a value based on the hue scaled based on\n+\t * {@link #getDurabilityForDisplay}, but can be overriden.\n+\t *\n+\t * @param stack Stack to get durability from\n+\t * @return A packed RGB value for the durability colour (0x00RRGGBB)\n+\t */\n+\tdefault int getRGBDurabilityForDisplay(ItemStack stack) {\n+\t\treturn MathHelper.hsvToRgb(Math.max(0.0F, (float) (1.0F - getDurabilityForDisplay(stack))) / 3.0F, 1.0F, 1.0F);\n+\t}\n+\n+\t/**\n+\t * Return the maxDamage for this ItemStack. Defaults to the maxDamage field in\n+\t * this item, but can be overridden here for other sources such as NBT.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getMaxDamage(ItemStack stack) {\n+\t\treturn getItem().getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Return if this itemstack is damaged. Note only called if\n+\t * {@link Item#isDamageable()} is true.\n+\t *\n+\t * @param stack the stack\n+\t * @return if the stack is damaged\n+\t */\n+\tdefault boolean isDamaged(ItemStack stack) {\n+\t\treturn stack.getDamage() > 0;\n+\t}\n+\n+\t/**\n+\t * Set the damage for this itemstack. Note, this method is responsible for zero", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2MDAwMQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383060001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * equipped item. This will only be called on instances of ArmorItem\n          \n          \n            \n            \t * equipped item. This will only be called on instances of {@link ArmorItem}", "author": "coderbot16", "createdAt": "2020-02-24T01:17:21Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getModifiers}.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Determines if an item is reparable, used by Repair recipes and Grindstone.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * CompoundTag nbtShare1 = item.getShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * CompoundTag nbtShare2 = item.getShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getRecipeRemainder()}. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#hasRecipeRemainder()}.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a recipe remainder\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as an {@link ItemEntity}. This is in ticks, standard result is 6000, or 5 mins.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @param world     The world the entity is in\n+\t * @return The normal lifespan in ticks.\n+\t */\n+\tdefault int getEntityLifespan(ItemStack itemStack, World world) {\n+\t\treturn 6000;\n+\t}\n+\n+\t/**\n+\t * Determines if this {@link Item} has a special entity for when it is in the world.\n+\t * Is called when an {@link ItemEntity} is spawned in the world, if true and\n+\t * {@link #createEntity(World, Entity, ItemStack)} returns non null, the ItemEntity will be destroyed\n+\t * and the new Entity will be added to the world.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True of the item has a custom entity, If true,\n+\t * {@link #createEntity(World, Entity, ItemStack)} will be called\n+\t */\n+\tdefault boolean hasCustomEntity(ItemStack stack) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * This function should return a new entity to replace the dropped item.\n+\t * Returning null here will not kill the ItemEntity and will leave it to\n+\t * function normally. Called when the item is spawned in a world.\n+\t *\n+\t * @param world     The world object\n+\t * @param location  The ItemEntity object, useful for getting the position of\n+\t *                  the entity\n+\t * @param itemstack The current item stack\n+\t * @return A new Entity object to spawn or null\n+\t */\n+\t@Nullable\n+\tdefault Entity createEntity(World world, Entity location, ItemStack itemstack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called by the default implemetation of {@link ItemEntity#tick()}, allowing\n+\t * for cleaner control over the update of the item without having to write a\n+\t * subclass.\n+\t *\n+\t * @param entity The entity Item\n+\t * @return Return true to skip any further update code.\n+\t */\n+\tdefault boolean onEntityItemUpdate(ItemStack stack, ItemEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Gets a list of tabs that items belonging to this class can display on,\n+\t * combined properly with {@link Item#getGroup()} allows for a single item to span many\n+\t * sub-items across many tabs.\n+\t *\n+\t * @return A list of all tabs that this item could possibly be one.\n+\t */\n+\tdefault Collection<ItemGroup> getCreativeTabs() {\n+\t\treturn Collections.singletonList(getItem().getGroup());\n+\t}\n+\n+\t/**\n+\t * Determines the base experience for a player when they remove this item from a\n+\t * furnace slot. This number must be between 0 and 1 for it to be valid. This\n+\t * number will be multiplied by the stack size to get the total experience.\n+\t *\n+\t * @param item The item stack the player is picking up.\n+\t * @return The amount to award for each item.\n+\t */\n+\tdefault float getSmeltingExperience(ItemStack item) {\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Should this item, when held, allow sneak-clicks to pass through to the\n+\t * underlying block?\n+\t *\n+\t * @param world  The world\n+\t * @param pos    Block position in world\n+\t * @param player The Player that is wielding the item\n+\t * @return\n+\t */\n+\tdefault boolean doesSneakBypassUse(ItemStack stack, ViewableWorld world, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called to tick armor in the armor slot. Override to do something\n+\t */\n+\tdefault void onArmorTick(ItemStack stack, World world, PlayerEntity player) {\n+\t}\n+\n+\t/**\n+\t * Determines if the specific ItemStack can be placed in the specified armor\n+\t * slot, for the entity.\n+\t *\n+\t * @param stack     The ItemStack\n+\t * @param armorType Equipment slot to be verified.\n+\t * @param entity    The entity trying to equip the armor\n+\t * @return True if the given ItemStack can be inserted in the slot\n+\t */\n+\tdefault boolean canEquip(ItemStack stack, EquipmentSlot armorType, Entity entity) {\n+\t\treturn MobEntity.getPreferredEquipmentSlot(stack) == armorType;\n+\t}\n+\n+\t/**\n+\t * Override this to set a non-default armor slot for an ItemStack, but <em>do\n+\t * not use this to get the armor slot of said stack; for that, use\n+\t * {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}.</em>\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return the armor slot of the ItemStack, or {@code null} to let the default\n+\t * vanilla logic as per {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}\n+\t * decide\n+\t */\n+\t@Nullable\n+\tdefault EquipmentSlot getEquipmentSlot(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Allow or forbid the specific book/item combination as an anvil enchant.\n+\t *\n+\t * @param stack The item\n+\t * @param book  The book\n+\t * @return if the enchantment is allowed\n+\t */\n+\tdefault boolean isBookEnchantable(ItemStack stack, ItemStack book) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Called to determine the armor texture that should be use for the currently\n+\t * equipped item. This will only be called on instances of ArmorItem", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2MjA4Mg==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383062082", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @param entity The entity Item\n          \n          \n            \n            \t * @param entity The item entity", "author": "coderbot16", "createdAt": "2020-02-24T01:40:37Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getModifiers}.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Determines if an item is reparable, used by Repair recipes and Grindstone.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * CompoundTag nbtShare1 = item.getShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * CompoundTag nbtShare2 = item.getShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getRecipeRemainder()}. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#hasRecipeRemainder()}.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a recipe remainder\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as an {@link ItemEntity}. This is in ticks, standard result is 6000, or 5 mins.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @param world     The world the entity is in\n+\t * @return The normal lifespan in ticks.\n+\t */\n+\tdefault int getEntityLifespan(ItemStack itemStack, World world) {\n+\t\treturn 6000;\n+\t}\n+\n+\t/**\n+\t * Determines if this {@link Item} has a special entity for when it is in the world.\n+\t * Is called when an {@link ItemEntity} is spawned in the world, if true and\n+\t * {@link #createEntity(World, Entity, ItemStack)} returns non null, the ItemEntity will be destroyed\n+\t * and the new Entity will be added to the world.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True of the item has a custom entity, If true,\n+\t * {@link #createEntity(World, Entity, ItemStack)} will be called\n+\t */\n+\tdefault boolean hasCustomEntity(ItemStack stack) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * This function should return a new entity to replace the dropped item.\n+\t * Returning null here will not kill the ItemEntity and will leave it to\n+\t * function normally. Called when the item is spawned in a world.\n+\t *\n+\t * @param world     The world object\n+\t * @param location  The ItemEntity object, useful for getting the position of\n+\t *                  the entity\n+\t * @param itemstack The current item stack\n+\t * @return A new Entity object to spawn or null\n+\t */\n+\t@Nullable\n+\tdefault Entity createEntity(World world, Entity location, ItemStack itemstack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called by the default implemetation of {@link ItemEntity#tick()}, allowing\n+\t * for cleaner control over the update of the item without having to write a\n+\t * subclass.\n+\t *\n+\t * @param entity The entity Item", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2MjIyMQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383062221", "bodyText": "This should return true in an AxeEntity mixin, and return false here.", "author": "coderbot16", "createdAt": "2020-02-24T01:41:49Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getModifiers}.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Determines if an item is reparable, used by Repair recipes and Grindstone.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * CompoundTag nbtShare1 = item.getShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * CompoundTag nbtShare2 = item.getShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getRecipeRemainder()}. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#hasRecipeRemainder()}.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a recipe remainder\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as an {@link ItemEntity}. This is in ticks, standard result is 6000, or 5 mins.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @param world     The world the entity is in\n+\t * @return The normal lifespan in ticks.\n+\t */\n+\tdefault int getEntityLifespan(ItemStack itemStack, World world) {\n+\t\treturn 6000;\n+\t}\n+\n+\t/**\n+\t * Determines if this {@link Item} has a special entity for when it is in the world.\n+\t * Is called when an {@link ItemEntity} is spawned in the world, if true and\n+\t * {@link #createEntity(World, Entity, ItemStack)} returns non null, the ItemEntity will be destroyed\n+\t * and the new Entity will be added to the world.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True of the item has a custom entity, If true,\n+\t * {@link #createEntity(World, Entity, ItemStack)} will be called\n+\t */\n+\tdefault boolean hasCustomEntity(ItemStack stack) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * This function should return a new entity to replace the dropped item.\n+\t * Returning null here will not kill the ItemEntity and will leave it to\n+\t * function normally. Called when the item is spawned in a world.\n+\t *\n+\t * @param world     The world object\n+\t * @param location  The ItemEntity object, useful for getting the position of\n+\t *                  the entity\n+\t * @param itemstack The current item stack\n+\t * @return A new Entity object to spawn or null\n+\t */\n+\t@Nullable\n+\tdefault Entity createEntity(World world, Entity location, ItemStack itemstack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called by the default implemetation of {@link ItemEntity#tick()}, allowing\n+\t * for cleaner control over the update of the item without having to write a\n+\t * subclass.\n+\t *\n+\t * @param entity The entity Item\n+\t * @return Return true to skip any further update code.\n+\t */\n+\tdefault boolean onEntityItemUpdate(ItemStack stack, ItemEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Gets a list of tabs that items belonging to this class can display on,\n+\t * combined properly with {@link Item#getGroup()} allows for a single item to span many\n+\t * sub-items across many tabs.\n+\t *\n+\t * @return A list of all tabs that this item could possibly be one.\n+\t */\n+\tdefault Collection<ItemGroup> getCreativeTabs() {\n+\t\treturn Collections.singletonList(getItem().getGroup());\n+\t}\n+\n+\t/**\n+\t * Determines the base experience for a player when they remove this item from a\n+\t * furnace slot. This number must be between 0 and 1 for it to be valid. This\n+\t * number will be multiplied by the stack size to get the total experience.\n+\t *\n+\t * @param item The item stack the player is picking up.\n+\t * @return The amount to award for each item.\n+\t */\n+\tdefault float getSmeltingExperience(ItemStack item) {\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Should this item, when held, allow sneak-clicks to pass through to the\n+\t * underlying block?\n+\t *\n+\t * @param world  The world\n+\t * @param pos    Block position in world\n+\t * @param player The Player that is wielding the item\n+\t * @return\n+\t */\n+\tdefault boolean doesSneakBypassUse(ItemStack stack, ViewableWorld world, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called to tick armor in the armor slot. Override to do something\n+\t */\n+\tdefault void onArmorTick(ItemStack stack, World world, PlayerEntity player) {\n+\t}\n+\n+\t/**\n+\t * Determines if the specific ItemStack can be placed in the specified armor\n+\t * slot, for the entity.\n+\t *\n+\t * @param stack     The ItemStack\n+\t * @param armorType Equipment slot to be verified.\n+\t * @param entity    The entity trying to equip the armor\n+\t * @return True if the given ItemStack can be inserted in the slot\n+\t */\n+\tdefault boolean canEquip(ItemStack stack, EquipmentSlot armorType, Entity entity) {\n+\t\treturn MobEntity.getPreferredEquipmentSlot(stack) == armorType;\n+\t}\n+\n+\t/**\n+\t * Override this to set a non-default armor slot for an ItemStack, but <em>do\n+\t * not use this to get the armor slot of said stack; for that, use\n+\t * {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}.</em>\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return the armor slot of the ItemStack, or {@code null} to let the default\n+\t * vanilla logic as per {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}\n+\t * decide\n+\t */\n+\t@Nullable\n+\tdefault EquipmentSlot getEquipmentSlot(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Allow or forbid the specific book/item combination as an anvil enchant.\n+\t *\n+\t * @param stack The item\n+\t * @param book  The book\n+\t * @return if the enchantment is allowed\n+\t */\n+\tdefault boolean isBookEnchantable(ItemStack stack, ItemStack book) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Called to determine the armor texture that should be use for the currently\n+\t * equipped item. This will only be called on instances of ArmorItem\n+\t *\n+\t * <p>Returning null from this function will use the default value.\n+\t *\n+\t * @param stack  ItemStack for the equipped armor\n+\t * @param entity The entity wearing the armor\n+\t * @param slot   The slot the armor is in\n+\t * @param type   The subtype, can be null or \"overlay\"\n+\t * @return Path of texture to bind, or null to use default\n+\t */\n+\t@Nullable\n+\tdefault String getArmorTexture(ItemStack stack, Entity entity, EquipmentSlot slot, String type) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Returns the text renderer used to render tooltips and overlays for this item.\n+\t * Returning null will use the standard text renderer.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return A instance of TextRenderer or null to use default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault TextRenderer getFontRenderer(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Override this method to have an item handle its own armor rendering.\n+\t *\n+\t * @param entityLiving The entity wearing the armor\n+\t * @param itemStack    The itemStack to render the model of\n+\t * @param armorSlot    The slot the armor is in\n+\t * @param _default     Original armor model. Will have attributes set.\n+\t * @return A BipedEntityModel to render instead of the default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault <A extends BipedEntityModel<?>> A getArmorModel(LivingEntity entityLiving, ItemStack itemStack, EquipmentSlot armorSlot, A _default) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called when a entity tries to play the 'swing' animation.\n+\t *\n+\t * @param entity The entity swinging the item.\n+\t * @return True to cancel any further processing by LivingEntity\n+\t */\n+\tdefault boolean onEntitySwing(ItemStack stack, LivingEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called when the client starts rendering the HUD, for whatever item the player\n+\t * currently has as a helmet. This is where pumpkins would render there overlay.\n+\t *\n+\t * @param stack        The ItemStack that is equipped\n+\t * @param player       Reference to the current client entity\n+\t * @param resolution   Resolution information about the current viewport and\n+\t *                     configured GUI Scale\n+\t * @param partialTicks Partial ticks for the renderer, useful for interpolation\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault void renderHelmetOverlay(ItemStack stack, PlayerEntity player, int width, int height, float partialTicks) {\n+\t}\n+\n+\t/**\n+\t * Return the itemDamage represented by this ItemStack. Defaults to the Damage\n+\t * entry in the stack NBT, but can be overridden here for other sources.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getDamage(ItemStack stack) {\n+\t\treturn !stack.hasTag() ? 0 : stack.getTag().getInt(\"Damage\");\n+\t}\n+\n+\t/**\n+\t * Determines if the durability bar should be rendered for this item. Defaults\n+\t * to vanilla {@link ItemStack#isDamaged()} behavior. But modders can use this\n+\t * for any data they wish.\n+\t *\n+\t * @param stack The current Item Stack\n+\t * @return True if it should render the 'durability' bar.\n+\t */\n+\tdefault boolean showDurabilityBar(ItemStack stack) {\n+\t\treturn stack.isDamaged();\n+\t}\n+\n+\t/**\n+\t * Queries the percentage of the 'Durability' bar that should be drawn.\n+\t *\n+\t * @param stack The current ItemStack\n+\t * @return 0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged /\n+\t * empty bar)\n+\t */\n+\tdefault double getDurabilityForDisplay(ItemStack stack) {\n+\t\treturn (double) stack.getDamage() / (double) stack.getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Returns the packed int RGB value used to render the durability bar in the\n+\t * GUI. Defaults to a value based on the hue scaled based on\n+\t * {@link #getDurabilityForDisplay}, but can be overriden.\n+\t *\n+\t * @param stack Stack to get durability from\n+\t * @return A packed RGB value for the durability colour (0x00RRGGBB)\n+\t */\n+\tdefault int getRGBDurabilityForDisplay(ItemStack stack) {\n+\t\treturn MathHelper.hsvToRgb(Math.max(0.0F, (float) (1.0F - getDurabilityForDisplay(stack))) / 3.0F, 1.0F, 1.0F);\n+\t}\n+\n+\t/**\n+\t * Return the maxDamage for this ItemStack. Defaults to the maxDamage field in\n+\t * this item, but can be overridden here for other sources such as NBT.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getMaxDamage(ItemStack stack) {\n+\t\treturn getItem().getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Return if this itemstack is damaged. Note only called if\n+\t * {@link Item#isDamageable()} is true.\n+\t *\n+\t * @param stack the stack\n+\t * @return if the stack is damaged\n+\t */\n+\tdefault boolean isDamaged(ItemStack stack) {\n+\t\treturn stack.getDamage() > 0;\n+\t}\n+\n+\t/**\n+\t * Set the damage for this itemstack. Note, this method is responsible for zero\n+\t * checking.\n+\t *\n+\t * @param stack  the stack\n+\t * @param damage the new damage value\n+\t */\n+\tdefault void setDamage(ItemStack stack, int damage) {\n+\t\tstack.getOrCreateTag().putInt(\"Damage\", Math.max(0, damage));\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#isEffectiveOn(BlockState)}.\n+\t *\n+\t * @param stack The itemstack used to harvest the block\n+\t * @param state The block trying to harvest\n+\t * @return true if can harvest the block\n+\t */\n+\tdefault boolean canHarvestBlock(ItemStack stack, BlockState state) {\n+\t\treturn getItem().isEffectiveOn(state);\n+\t}\n+\n+\t/**\n+\t * Gets the maximum number of items that this stack should be able to hold. This\n+\t * is a ItemStack (and thus NBT) sensitive version of {@link Item#getMaxCount()}\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return The maximum number this item can be stacked to\n+\t */\n+\tdefault int getItemStackLimit(ItemStack stack) {\n+\t\treturn getItem().getMaxCount();\n+\t}\n+\n+\tSet<Object /* TODO: ToolType */> getToolTypes(ItemStack stack);\n+\n+\t/**\n+\t * Queries the harvest level of this item stack for the specified tool type,\n+\t * Returns -1 if this tool is not of the specified type.\n+\t *\n+\t * @param stack      This item stack instance\n+\t * @param tool       Tool type\n+\t * @param player     The player trying to harvest the given blockstate\n+\t * @param blockState The block to harvest\n+\t * @return Harvest level, or -1 if not the specified tool type.\n+\t */\n+\tint getHarvestLevel(ItemStack stack, Object /* TODO: ToolType */ tool, @Nullable PlayerEntity player, @Nullable BlockState blockState);\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getEnchantability()}.\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return the item echantability value\n+\t */\n+\tdefault int getItemEnchantability(ItemStack stack) {\n+\t\treturn getItem().getEnchantability();\n+\t}\n+\n+\t/**\n+\t * Checks whether an item can be enchanted with a certain enchantment. This\n+\t * applies specifically to enchanting an item in the enchanting table and is\n+\t * called when retrieving the list of possible enchantments for an item.\n+\t * Enchantments may additionally (or exclusively) be doing their own checks in\n+\t * {@link net.minecraft.enchantment.Enchantment#isAcceptableItem(ItemStack)};\n+\t * check the individual implementation for reference. By default this will check\n+\t * if the enchantment type is valid for this item type.\n+\t *\n+\t * @param stack       the item stack to be enchanted\n+\t * @param enchantment the enchantment to be applied\n+\t * @return true if the enchantment can be applied to this item\n+\t */\n+\tdefault boolean canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment) {\n+\t\treturn enchantment.type.isAcceptableItem(stack.getItem());\n+\t}\n+\n+\t@Deprecated // TODO move once net.minecraftforge.common.Tags is added\n+\tTag<Item> BEACON_PAYMENT = TagRegistry.item(new Identifier(\"forge\", \"beacon_payment\"));\n+\n+\t/**\n+\t * Whether this Item can be used as a payment to activate the vanilla beacon.\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return true if this Item can be used\n+\t */\n+\tdefault boolean isBeaconPayment(ItemStack stack) {\n+\t\treturn BEACON_PAYMENT.contains(stack.getItem());\n+\t}\n+\n+\t/**\n+\t * Determine if the player switching between these two item stacks.\n+\t *\n+\t * @param oldStack    The old stack that was equipped\n+\t * @param newStack    The new stack\n+\t * @param slotChanged If the current equipped slot was changed, Vanilla does not\n+\t *                    play the animation if you switch between two slots that\n+\t *                    hold the exact same item.\n+\t * @return True to play the item change animation\n+\t */\n+\tdefault boolean shouldCauseReequipAnimation(ItemStack oldStack, ItemStack newStack, boolean slotChanged) {\n+\t\treturn !oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called when the player is mining a block and the item in his hand changes.\n+\t * Allows to not reset block breaking if only NBT or similar changes.\n+\t *\n+\t * @param oldStack The old stack that was used for mining. Item in players main\n+\t *                 hand\n+\t * @param newStack The new stack\n+\t * @return True to reset block break progress\n+\t */\n+\tdefault boolean shouldCauseBlockBreakReset(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn !(newStack.getItem() == oldStack.getItem() && ItemStack.areTagsEqual(newStack, oldStack)\n+\t\t\t&& (newStack.isDamageable() || newStack.getDamage() == oldStack.getDamage()));\n+\t}\n+\n+\t/**\n+\t * Called while an item is in 'active' use to determine if usage should\n+\t * continue. Allows items to continue being used while sustaining damage, for\n+\t * example.\n+\t *\n+\t * @param oldStack the previous 'active' stack\n+\t * @param newStack the stack currently in the active hand\n+\t * @return true to set the new stack to active and continue using it\n+\t */\n+\tdefault boolean canContinueUsing(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called to get the Mod ID of the mod that *created* the ItemStack, instead of\n+\t * the real Mod ID that *registered* it.\n+\t *\n+\t * <p>For example the Forge Universal Bucket creates a subitem for each modded\n+\t * fluid, and it returns the modded fluid's Mod ID here.\n+\t *\n+\t * <p>Mods that register subitems for other mods can override this. Informational\n+\t * mods can call it to show the mod that created the item.\n+\t *\n+\t * @param itemStack the ItemStack to check\n+\t * @return the Mod ID for the ItemStack, or null when there is no specially\n+\t * associated mod and {@link Registry#getId(Item)} would return null.\n+\t */\n+\t@Nullable\n+\tdefault String getCreatorModId(ItemStack itemStack) {\n+\t\tItem item = itemStack.getItem();\n+\t\tIdentifier registryName = Registry.ITEM.getId(item);\n+\t\tString modId = registryName == null ? null : registryName.getNamespace();\n+\n+\t\tif (\"minecraft\".equals(modId)) {\n+\t\t\tif (item instanceof EnchantedBookItem) {\n+\t\t\t\tListTag enchantmentsNbt = EnchantedBookItem.getEnchantmentTag(itemStack);\n+\n+\t\t\t\tif (enchantmentsNbt.size() == 1) {\n+\t\t\t\t\tCompoundTag nbttagcompound = enchantmentsNbt.getCompoundTag(0);\n+\t\t\t\t\tIdentifier resourceLocation = Identifier.tryParse(nbttagcompound.getString(\"id\"));\n+\n+\t\t\t\t\tif (resourceLocation != null && Registry.ENCHANTMENT.containsId(resourceLocation)) {\n+\t\t\t\t\t\treturn resourceLocation.getNamespace();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (item instanceof PotionItem || item instanceof TippedArrowItem) {\n+\t\t\t\tPotion potionType = PotionUtil.getPotion(itemStack);\n+\t\t\t\tIdentifier resourceLocation = Registry.POTION.getId(potionType);\n+\n+\t\t\t\tif (resourceLocation != null) {\n+\t\t\t\t\treturn resourceLocation.getNamespace();\n+\t\t\t\t}\n+\t\t\t} else if (item instanceof SpawnEggItem) {\n+\t\t\t\tIdentifier resourceLocation = Registry.ENTITY_TYPE.getId(((SpawnEggItem) item).getEntityType(null));\n+\n+\t\t\t\tif (resourceLocation != null) {\n+\t\t\t\t\treturn resourceLocation.getNamespace();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn modId;\n+\t}\n+\n+\t/**\n+\t * Called from {@link ItemStack#ItemStack}, will hold extra data for the life of this\n+\t * ItemStack. Can be retrieved from stack.getCapabilities() The NBT can be null\n+\t * if this is not called from readNBT or if the item the stack is changing FROM\n+\t * is different then this item, or the previous item had no capabilities.\n+\t *\n+\t * <p>This is called BEFORE the stacks item is set so you can use stack.getItem()\n+\t * to see the OLD item. Remember that getItem CAN return null.\n+\t *\n+\t * @param stack The ItemStack\n+\t * @param nbt   NBT of this item serialized, or null.\n+\t * @return A holder instance associated with this ItemStack where you can hold\n+\t * capabilities for the life of this item.\n+\t */\n+\t@Nullable\n+\tdefault Object /* TODO: ICapabilityProvider */ initCapabilities(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\treturn null;\n+\t}\n+\n+\tMap<Identifier, ItemPropertyGetter> patchwork_getPropertyGetters();\n+\n+\tdefault ImmutableMap<String, UnaryOperator<Float>/* TODO: ITimeValue */> getAnimationParameters(final ItemStack stack, final World world, final LivingEntity entity) {\n+\t\tImmutableMap.Builder<String, UnaryOperator<Float>/* TODO: ITimeValue */> builder = ImmutableMap.builder();\n+\t\tpatchwork_getPropertyGetters().forEach((k, v) -> builder.put(k.toString(), input -> v.call(stack, world, entity)));\n+\t\treturn builder.build();\n+\t}\n+\n+\t/**\n+\t * Can this Item disable a shield.\n+\t *\n+\t * @param stack    The ItemStack\n+\t * @param shield   The shield in question\n+\t * @param entity   The LivingEntity holding the shield\n+\t * @param attacker The LivingEntity holding the ItemStack\n+\t * @return True if this ItemStack can disable the shield in question.\n+\t */\n+\tdefault boolean canDisableShield(ItemStack stack, ItemStack shield, LivingEntity entity, LivingEntity attacker) {\n+\t\treturn this instanceof AxeItem;", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2MjI0NQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383062245", "bodyText": "Maybe move this to ShieldItem?", "author": "coderbot16", "createdAt": "2020-02-24T01:42:07Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -0,0 +1,781 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.common.extensions;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Multimap;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.font.TextRenderer;\n+import net.minecraft.client.render.entity.model.BipedEntityModel;\n+import net.minecraft.client.render.item.ItemDynamicRenderer;\n+import net.minecraft.enchantment.Enchantment;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.entity.EquipmentSlot;\n+import net.minecraft.entity.ItemEntity;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.entity.attribute.EntityAttributeModifier;\n+import net.minecraft.entity.mob.MobEntity;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ItemUsageContext;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.MathHelper;\n+import net.minecraft.util.registry.Registry;\n+import net.minecraft.world.ViewableWorld;\n+import net.minecraft.world.World;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.tag.TagRegistry;\n+\n+public interface IForgeItem {\n+\tdefault Item getItem() {\n+\t\treturn (Item) this;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getModifiers}.\n+\t */\n+\tdefault Multimap<String, EntityAttributeModifier> getAttributeModifiers(EquipmentSlot slot, ItemStack stack) {\n+\t\treturn getItem().getModifiers(slot);\n+\t}\n+\n+\t/**\n+\t * Called when a player drops the item into the world, returning false from this\n+\t * will prevent the item from being removed from the players inventory and\n+\t * spawning in the world.\n+\t *\n+\t * @param player The player that dropped the item\n+\t * @param item   The item stack, before the item is removed.\n+\t */\n+\tdefault boolean onDroppedByPlayer(ItemStack item, PlayerEntity player) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Allow the item one last chance to modify its name used for the tool highlight\n+\t * useful for adding something extra that can't be removed by a user in the\n+\t * displayed name, such as a mode of operation.\n+\t *\n+\t * @param item        the ItemStack for the item.\n+\t * @param displayName the name that will be displayed unless it is changed in\n+\t *                    this method.\n+\t */\n+\tdefault String getHighlightTip(ItemStack item, String displayName) {\n+\t\treturn displayName;\n+\t}\n+\n+\t/**\n+\t * This is called when the item is used, before the block is activated.\n+\t *\n+\t * @return Return PASS to allow vanilla handling, any other to skip normal code.\n+\t */\n+\tdefault ActionResult onItemUseFirst(ItemStack stack, ItemUsageContext context) {\n+\t\treturn ActionResult.PASS;\n+\t}\n+\n+\t/**\n+\t * Determines if an item is reparable, used by Repair recipes and Grindstone.\n+\t *\n+\t * @return True if reparable\n+\t */\n+\tboolean isRepairable(ItemStack stack);\n+\n+\t/**\n+\t * Determines the amount of durability the mending enchantment\n+\t * will repair, on average, per point of experience.\n+\t */\n+\tdefault float getXpRepairRatio(ItemStack stack) {\n+\t\treturn 2f;\n+\t}\n+\n+\t/**\n+\t * Override this method to change the NBT data being sent to the client. You\n+\t * should ONLY override this when you have no other choice, as this might change\n+\t * behavior client side!\n+\t *\n+\t * <p>Note that this will sometimes be applied multiple times, the following MUST\n+\t * be supported:\n+\t * Item item = stack.getItem();\n+\t * CompoundTag nbtShare1 = item.getShareTag(stack);\n+\t * stack.setTagCompound(nbtShare1);\n+\t * CompoundTag nbtShare2 = item.getShareTag(stack);\n+\t * assert nbtShare1.equals(nbtShare2);\n+\t *\n+\t * @param stack The stack to send the NBT tag for\n+\t * @return The NBT tag\n+\t */\n+\t@Nullable\n+\tdefault CompoundTag getShareTag(ItemStack stack) {\n+\t\treturn stack.getTag();\n+\t}\n+\n+\t/**\n+\t * Override this method to decide what to do with the NBT data received from\n+\t * getShareTag().\n+\t *\n+\t * @param stack The stack that received NBT\n+\t * @param nbt   Received NBT, can be null\n+\t */\n+\tdefault void readShareTag(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\tstack.setTag(nbt);\n+\t}\n+\n+\t/**\n+\t * Called before a block is broken. Return true to prevent default block\n+\t * harvesting.\n+\t *\n+\t * <p>Note: In SMP, this is called on both client and server sides!\n+\t *\n+\t * @param itemstack The current ItemStack\n+\t * @param pos       Block's position in world\n+\t * @param player    The Player that is wielding the item\n+\t * @return True to prevent harvesting, false to continue as normal\n+\t */\n+\tdefault boolean onBlockStartBreak(ItemStack itemstack, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called each tick while using an item.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The Player using the item\n+\t * @param count  The amount of time in tick the item has been used for\n+\t *               continuously\n+\t */\n+\tdefault void onUsingTick(ItemStack stack, LivingEntity player, int count) {\n+\t}\n+\n+\t/**\n+\t * Called when the player Left Clicks (attacks) an entity. Processed before\n+\t * damage is done, if return value is true further processing is canceled and\n+\t * the entity is not attacked.\n+\t *\n+\t * @param stack  The Item being used\n+\t * @param player The player that is attacking\n+\t * @param entity The entity being attacked\n+\t * @return True to cancel the rest of the interaction.\n+\t */\n+\tdefault boolean onLeftClickEntity(ItemStack stack, PlayerEntity player, Entity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getRecipeRemainder()}. Returns a full ItemStack\n+\t * instance of the result.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @return The resulting ItemStack\n+\t */\n+\tdefault ItemStack getContainerItem(ItemStack itemStack) {\n+\t\tif (!hasContainerItem(itemStack)) {\n+\t\t\treturn ItemStack.EMPTY;\n+\t\t}\n+\n+\t\treturn new ItemStack(getItem().getRecipeRemainder());\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#hasRecipeRemainder()}.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True if this item has a recipe remainder\n+\t */\n+\tdefault boolean hasContainerItem(ItemStack stack) {\n+\t\treturn getItem().hasRecipeRemainder();\n+\t}\n+\n+\t/**\n+\t * Retrieves the normal 'lifespan' of this item when it is dropped on the ground\n+\t * as an {@link ItemEntity}. This is in ticks, standard result is 6000, or 5 mins.\n+\t *\n+\t * @param itemStack The current ItemStack\n+\t * @param world     The world the entity is in\n+\t * @return The normal lifespan in ticks.\n+\t */\n+\tdefault int getEntityLifespan(ItemStack itemStack, World world) {\n+\t\treturn 6000;\n+\t}\n+\n+\t/**\n+\t * Determines if this {@link Item} has a special entity for when it is in the world.\n+\t * Is called when an {@link ItemEntity} is spawned in the world, if true and\n+\t * {@link #createEntity(World, Entity, ItemStack)} returns non null, the ItemEntity will be destroyed\n+\t * and the new Entity will be added to the world.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return True of the item has a custom entity, If true,\n+\t * {@link #createEntity(World, Entity, ItemStack)} will be called\n+\t */\n+\tdefault boolean hasCustomEntity(ItemStack stack) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * This function should return a new entity to replace the dropped item.\n+\t * Returning null here will not kill the ItemEntity and will leave it to\n+\t * function normally. Called when the item is spawned in a world.\n+\t *\n+\t * @param world     The world object\n+\t * @param location  The ItemEntity object, useful for getting the position of\n+\t *                  the entity\n+\t * @param itemstack The current item stack\n+\t * @return A new Entity object to spawn or null\n+\t */\n+\t@Nullable\n+\tdefault Entity createEntity(World world, Entity location, ItemStack itemstack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called by the default implemetation of {@link ItemEntity#tick()}, allowing\n+\t * for cleaner control over the update of the item without having to write a\n+\t * subclass.\n+\t *\n+\t * @param entity The entity Item\n+\t * @return Return true to skip any further update code.\n+\t */\n+\tdefault boolean onEntityItemUpdate(ItemStack stack, ItemEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Gets a list of tabs that items belonging to this class can display on,\n+\t * combined properly with {@link Item#getGroup()} allows for a single item to span many\n+\t * sub-items across many tabs.\n+\t *\n+\t * @return A list of all tabs that this item could possibly be one.\n+\t */\n+\tdefault Collection<ItemGroup> getCreativeTabs() {\n+\t\treturn Collections.singletonList(getItem().getGroup());\n+\t}\n+\n+\t/**\n+\t * Determines the base experience for a player when they remove this item from a\n+\t * furnace slot. This number must be between 0 and 1 for it to be valid. This\n+\t * number will be multiplied by the stack size to get the total experience.\n+\t *\n+\t * @param item The item stack the player is picking up.\n+\t * @return The amount to award for each item.\n+\t */\n+\tdefault float getSmeltingExperience(ItemStack item) {\n+\t\treturn -1;\n+\t}\n+\n+\t/**\n+\t * Should this item, when held, allow sneak-clicks to pass through to the\n+\t * underlying block?\n+\t *\n+\t * @param world  The world\n+\t * @param pos    Block position in world\n+\t * @param player The Player that is wielding the item\n+\t * @return\n+\t */\n+\tdefault boolean doesSneakBypassUse(ItemStack stack, ViewableWorld world, BlockPos pos, PlayerEntity player) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called to tick armor in the armor slot. Override to do something\n+\t */\n+\tdefault void onArmorTick(ItemStack stack, World world, PlayerEntity player) {\n+\t}\n+\n+\t/**\n+\t * Determines if the specific ItemStack can be placed in the specified armor\n+\t * slot, for the entity.\n+\t *\n+\t * @param stack     The ItemStack\n+\t * @param armorType Equipment slot to be verified.\n+\t * @param entity    The entity trying to equip the armor\n+\t * @return True if the given ItemStack can be inserted in the slot\n+\t */\n+\tdefault boolean canEquip(ItemStack stack, EquipmentSlot armorType, Entity entity) {\n+\t\treturn MobEntity.getPreferredEquipmentSlot(stack) == armorType;\n+\t}\n+\n+\t/**\n+\t * Override this to set a non-default armor slot for an ItemStack, but <em>do\n+\t * not use this to get the armor slot of said stack; for that, use\n+\t * {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}.</em>\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return the armor slot of the ItemStack, or {@code null} to let the default\n+\t * vanilla logic as per {@link MobEntity#getPreferredEquipmentSlot(ItemStack)}\n+\t * decide\n+\t */\n+\t@Nullable\n+\tdefault EquipmentSlot getEquipmentSlot(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Allow or forbid the specific book/item combination as an anvil enchant.\n+\t *\n+\t * @param stack The item\n+\t * @param book  The book\n+\t * @return if the enchantment is allowed\n+\t */\n+\tdefault boolean isBookEnchantable(ItemStack stack, ItemStack book) {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Called to determine the armor texture that should be use for the currently\n+\t * equipped item. This will only be called on instances of ArmorItem\n+\t *\n+\t * <p>Returning null from this function will use the default value.\n+\t *\n+\t * @param stack  ItemStack for the equipped armor\n+\t * @param entity The entity wearing the armor\n+\t * @param slot   The slot the armor is in\n+\t * @param type   The subtype, can be null or \"overlay\"\n+\t * @return Path of texture to bind, or null to use default\n+\t */\n+\t@Nullable\n+\tdefault String getArmorTexture(ItemStack stack, Entity entity, EquipmentSlot slot, String type) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Returns the text renderer used to render tooltips and overlays for this item.\n+\t * Returning null will use the standard text renderer.\n+\t *\n+\t * @param stack The current item stack\n+\t * @return A instance of TextRenderer or null to use default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault TextRenderer getFontRenderer(ItemStack stack) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Override this method to have an item handle its own armor rendering.\n+\t *\n+\t * @param entityLiving The entity wearing the armor\n+\t * @param itemStack    The itemStack to render the model of\n+\t * @param armorSlot    The slot the armor is in\n+\t * @param _default     Original armor model. Will have attributes set.\n+\t * @return A BipedEntityModel to render instead of the default\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\t@Nullable\n+\tdefault <A extends BipedEntityModel<?>> A getArmorModel(LivingEntity entityLiving, ItemStack itemStack, EquipmentSlot armorSlot, A _default) {\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Called when a entity tries to play the 'swing' animation.\n+\t *\n+\t * @param entity The entity swinging the item.\n+\t * @return True to cancel any further processing by LivingEntity\n+\t */\n+\tdefault boolean onEntitySwing(ItemStack stack, LivingEntity entity) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Called when the client starts rendering the HUD, for whatever item the player\n+\t * currently has as a helmet. This is where pumpkins would render there overlay.\n+\t *\n+\t * @param stack        The ItemStack that is equipped\n+\t * @param player       Reference to the current client entity\n+\t * @param resolution   Resolution information about the current viewport and\n+\t *                     configured GUI Scale\n+\t * @param partialTicks Partial ticks for the renderer, useful for interpolation\n+\t */\n+\t@Environment(EnvType.CLIENT)\n+\tdefault void renderHelmetOverlay(ItemStack stack, PlayerEntity player, int width, int height, float partialTicks) {\n+\t}\n+\n+\t/**\n+\t * Return the itemDamage represented by this ItemStack. Defaults to the Damage\n+\t * entry in the stack NBT, but can be overridden here for other sources.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getDamage(ItemStack stack) {\n+\t\treturn !stack.hasTag() ? 0 : stack.getTag().getInt(\"Damage\");\n+\t}\n+\n+\t/**\n+\t * Determines if the durability bar should be rendered for this item. Defaults\n+\t * to vanilla {@link ItemStack#isDamaged()} behavior. But modders can use this\n+\t * for any data they wish.\n+\t *\n+\t * @param stack The current Item Stack\n+\t * @return True if it should render the 'durability' bar.\n+\t */\n+\tdefault boolean showDurabilityBar(ItemStack stack) {\n+\t\treturn stack.isDamaged();\n+\t}\n+\n+\t/**\n+\t * Queries the percentage of the 'Durability' bar that should be drawn.\n+\t *\n+\t * @param stack The current ItemStack\n+\t * @return 0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged /\n+\t * empty bar)\n+\t */\n+\tdefault double getDurabilityForDisplay(ItemStack stack) {\n+\t\treturn (double) stack.getDamage() / (double) stack.getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Returns the packed int RGB value used to render the durability bar in the\n+\t * GUI. Defaults to a value based on the hue scaled based on\n+\t * {@link #getDurabilityForDisplay}, but can be overriden.\n+\t *\n+\t * @param stack Stack to get durability from\n+\t * @return A packed RGB value for the durability colour (0x00RRGGBB)\n+\t */\n+\tdefault int getRGBDurabilityForDisplay(ItemStack stack) {\n+\t\treturn MathHelper.hsvToRgb(Math.max(0.0F, (float) (1.0F - getDurabilityForDisplay(stack))) / 3.0F, 1.0F, 1.0F);\n+\t}\n+\n+\t/**\n+\t * Return the maxDamage for this ItemStack. Defaults to the maxDamage field in\n+\t * this item, but can be overridden here for other sources such as NBT.\n+\t *\n+\t * @param stack The itemstack that is damaged\n+\t * @return the damage value\n+\t */\n+\tdefault int getMaxDamage(ItemStack stack) {\n+\t\treturn getItem().getMaxDamage();\n+\t}\n+\n+\t/**\n+\t * Return if this itemstack is damaged. Note only called if\n+\t * {@link Item#isDamageable()} is true.\n+\t *\n+\t * @param stack the stack\n+\t * @return if the stack is damaged\n+\t */\n+\tdefault boolean isDamaged(ItemStack stack) {\n+\t\treturn stack.getDamage() > 0;\n+\t}\n+\n+\t/**\n+\t * Set the damage for this itemstack. Note, this method is responsible for zero\n+\t * checking.\n+\t *\n+\t * @param stack  the stack\n+\t * @param damage the new damage value\n+\t */\n+\tdefault void setDamage(ItemStack stack, int damage) {\n+\t\tstack.getOrCreateTag().putInt(\"Damage\", Math.max(0, damage));\n+\t}\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#isEffectiveOn(BlockState)}.\n+\t *\n+\t * @param stack The itemstack used to harvest the block\n+\t * @param state The block trying to harvest\n+\t * @return true if can harvest the block\n+\t */\n+\tdefault boolean canHarvestBlock(ItemStack stack, BlockState state) {\n+\t\treturn getItem().isEffectiveOn(state);\n+\t}\n+\n+\t/**\n+\t * Gets the maximum number of items that this stack should be able to hold. This\n+\t * is a ItemStack (and thus NBT) sensitive version of {@link Item#getMaxCount()}\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return The maximum number this item can be stacked to\n+\t */\n+\tdefault int getItemStackLimit(ItemStack stack) {\n+\t\treturn getItem().getMaxCount();\n+\t}\n+\n+\tSet<Object /* TODO: ToolType */> getToolTypes(ItemStack stack);\n+\n+\t/**\n+\t * Queries the harvest level of this item stack for the specified tool type,\n+\t * Returns -1 if this tool is not of the specified type.\n+\t *\n+\t * @param stack      This item stack instance\n+\t * @param tool       Tool type\n+\t * @param player     The player trying to harvest the given blockstate\n+\t * @param blockState The block to harvest\n+\t * @return Harvest level, or -1 if not the specified tool type.\n+\t */\n+\tint getHarvestLevel(ItemStack stack, Object /* TODO: ToolType */ tool, @Nullable PlayerEntity player, @Nullable BlockState blockState);\n+\n+\t/**\n+\t * ItemStack sensitive version of {@link Item#getEnchantability()}.\n+\t *\n+\t * @param stack The ItemStack\n+\t * @return the item echantability value\n+\t */\n+\tdefault int getItemEnchantability(ItemStack stack) {\n+\t\treturn getItem().getEnchantability();\n+\t}\n+\n+\t/**\n+\t * Checks whether an item can be enchanted with a certain enchantment. This\n+\t * applies specifically to enchanting an item in the enchanting table and is\n+\t * called when retrieving the list of possible enchantments for an item.\n+\t * Enchantments may additionally (or exclusively) be doing their own checks in\n+\t * {@link net.minecraft.enchantment.Enchantment#isAcceptableItem(ItemStack)};\n+\t * check the individual implementation for reference. By default this will check\n+\t * if the enchantment type is valid for this item type.\n+\t *\n+\t * @param stack       the item stack to be enchanted\n+\t * @param enchantment the enchantment to be applied\n+\t * @return true if the enchantment can be applied to this item\n+\t */\n+\tdefault boolean canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment) {\n+\t\treturn enchantment.type.isAcceptableItem(stack.getItem());\n+\t}\n+\n+\t@Deprecated // TODO move once net.minecraftforge.common.Tags is added\n+\tTag<Item> BEACON_PAYMENT = TagRegistry.item(new Identifier(\"forge\", \"beacon_payment\"));\n+\n+\t/**\n+\t * Whether this Item can be used as a payment to activate the vanilla beacon.\n+\t *\n+\t * @param stack the ItemStack\n+\t * @return true if this Item can be used\n+\t */\n+\tdefault boolean isBeaconPayment(ItemStack stack) {\n+\t\treturn BEACON_PAYMENT.contains(stack.getItem());\n+\t}\n+\n+\t/**\n+\t * Determine if the player switching between these two item stacks.\n+\t *\n+\t * @param oldStack    The old stack that was equipped\n+\t * @param newStack    The new stack\n+\t * @param slotChanged If the current equipped slot was changed, Vanilla does not\n+\t *                    play the animation if you switch between two slots that\n+\t *                    hold the exact same item.\n+\t * @return True to play the item change animation\n+\t */\n+\tdefault boolean shouldCauseReequipAnimation(ItemStack oldStack, ItemStack newStack, boolean slotChanged) {\n+\t\treturn !oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called when the player is mining a block and the item in his hand changes.\n+\t * Allows to not reset block breaking if only NBT or similar changes.\n+\t *\n+\t * @param oldStack The old stack that was used for mining. Item in players main\n+\t *                 hand\n+\t * @param newStack The new stack\n+\t * @return True to reset block break progress\n+\t */\n+\tdefault boolean shouldCauseBlockBreakReset(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn !(newStack.getItem() == oldStack.getItem() && ItemStack.areTagsEqual(newStack, oldStack)\n+\t\t\t&& (newStack.isDamageable() || newStack.getDamage() == oldStack.getDamage()));\n+\t}\n+\n+\t/**\n+\t * Called while an item is in 'active' use to determine if usage should\n+\t * continue. Allows items to continue being used while sustaining damage, for\n+\t * example.\n+\t *\n+\t * @param oldStack the previous 'active' stack\n+\t * @param newStack the stack currently in the active hand\n+\t * @return true to set the new stack to active and continue using it\n+\t */\n+\tdefault boolean canContinueUsing(ItemStack oldStack, ItemStack newStack) {\n+\t\treturn oldStack.equals(newStack);\n+\t}\n+\n+\t/**\n+\t * Called to get the Mod ID of the mod that *created* the ItemStack, instead of\n+\t * the real Mod ID that *registered* it.\n+\t *\n+\t * <p>For example the Forge Universal Bucket creates a subitem for each modded\n+\t * fluid, and it returns the modded fluid's Mod ID here.\n+\t *\n+\t * <p>Mods that register subitems for other mods can override this. Informational\n+\t * mods can call it to show the mod that created the item.\n+\t *\n+\t * @param itemStack the ItemStack to check\n+\t * @return the Mod ID for the ItemStack, or null when there is no specially\n+\t * associated mod and {@link Registry#getId(Item)} would return null.\n+\t */\n+\t@Nullable\n+\tdefault String getCreatorModId(ItemStack itemStack) {\n+\t\tItem item = itemStack.getItem();\n+\t\tIdentifier registryName = Registry.ITEM.getId(item);\n+\t\tString modId = registryName == null ? null : registryName.getNamespace();\n+\n+\t\tif (\"minecraft\".equals(modId)) {\n+\t\t\tif (item instanceof EnchantedBookItem) {\n+\t\t\t\tListTag enchantmentsNbt = EnchantedBookItem.getEnchantmentTag(itemStack);\n+\n+\t\t\t\tif (enchantmentsNbt.size() == 1) {\n+\t\t\t\t\tCompoundTag nbttagcompound = enchantmentsNbt.getCompoundTag(0);\n+\t\t\t\t\tIdentifier resourceLocation = Identifier.tryParse(nbttagcompound.getString(\"id\"));\n+\n+\t\t\t\t\tif (resourceLocation != null && Registry.ENCHANTMENT.containsId(resourceLocation)) {\n+\t\t\t\t\t\treturn resourceLocation.getNamespace();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} else if (item instanceof PotionItem || item instanceof TippedArrowItem) {\n+\t\t\t\tPotion potionType = PotionUtil.getPotion(itemStack);\n+\t\t\t\tIdentifier resourceLocation = Registry.POTION.getId(potionType);\n+\n+\t\t\t\tif (resourceLocation != null) {\n+\t\t\t\t\treturn resourceLocation.getNamespace();\n+\t\t\t\t}\n+\t\t\t} else if (item instanceof SpawnEggItem) {\n+\t\t\t\tIdentifier resourceLocation = Registry.ENTITY_TYPE.getId(((SpawnEggItem) item).getEntityType(null));\n+\n+\t\t\t\tif (resourceLocation != null) {\n+\t\t\t\t\treturn resourceLocation.getNamespace();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn modId;\n+\t}\n+\n+\t/**\n+\t * Called from {@link ItemStack#ItemStack}, will hold extra data for the life of this\n+\t * ItemStack. Can be retrieved from stack.getCapabilities() The NBT can be null\n+\t * if this is not called from readNBT or if the item the stack is changing FROM\n+\t * is different then this item, or the previous item had no capabilities.\n+\t *\n+\t * <p>This is called BEFORE the stacks item is set so you can use stack.getItem()\n+\t * to see the OLD item. Remember that getItem CAN return null.\n+\t *\n+\t * @param stack The ItemStack\n+\t * @param nbt   NBT of this item serialized, or null.\n+\t * @return A holder instance associated with this ItemStack where you can hold\n+\t * capabilities for the life of this item.\n+\t */\n+\t@Nullable\n+\tdefault Object /* TODO: ICapabilityProvider */ initCapabilities(ItemStack stack, @Nullable CompoundTag nbt) {\n+\t\treturn null;\n+\t}\n+\n+\tMap<Identifier, ItemPropertyGetter> patchwork_getPropertyGetters();\n+\n+\tdefault ImmutableMap<String, UnaryOperator<Float>/* TODO: ITimeValue */> getAnimationParameters(final ItemStack stack, final World world, final LivingEntity entity) {\n+\t\tImmutableMap.Builder<String, UnaryOperator<Float>/* TODO: ITimeValue */> builder = ImmutableMap.builder();\n+\t\tpatchwork_getPropertyGetters().forEach((k, v) -> builder.put(k.toString(), input -> v.call(stack, world, entity)));\n+\t\treturn builder.build();\n+\t}\n+\n+\t/**\n+\t * Can this Item disable a shield.\n+\t *\n+\t * @param stack    The ItemStack\n+\t * @param shield   The shield in question\n+\t * @param entity   The LivingEntity holding the shield\n+\t * @param attacker The LivingEntity holding the ItemStack\n+\t * @return True if this ItemStack can disable the shield in question.\n+\t */\n+\tdefault boolean canDisableShield(ItemStack stack, ItemStack shield, LivingEntity entity, LivingEntity attacker) {\n+\t\treturn this instanceof AxeItem;\n+\t}\n+\n+\t/**\n+\t * Is this Item a shield.\n+\t *\n+\t * @param stack  The ItemStack\n+\t * @param entity The Entity holding the ItemStack\n+\t * @return True if the ItemStack is considered a shield\n+\t */\n+\tdefault boolean isShield(ItemStack stack, @Nullable LivingEntity entity) {\n+\t\treturn stack.getItem() == Items.SHIELD;", "originalCommit": "20d8585fc2c8cc7ac96a053b9b7a1b4555b36a3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bd5afcfbbf1902d4518a2e3a66a3f3f0ff90ddbd", "url": "https://github.com/PatchworkMC/patchwork-api/commit/bd5afcfbbf1902d4518a2e3a66a3f3f0ff90ddbd", "message": "Mixins of remaining Item patches", "committedDate": "2020-02-24T15:32:51Z", "type": "commit"}, {"oid": "b19eefb6ef2eda2f6aa1c9e5b31dbcbb4e6fd243", "url": "https://github.com/PatchworkMC/patchwork-api/commit/b19eefb6ef2eda2f6aa1c9e5b31dbcbb4e6fd243", "message": "Missed a static", "committedDate": "2020-02-24T15:34:41Z", "type": "commit"}, {"oid": "d7c85712868850ece67723215998a77e0b2abfa0", "url": "https://github.com/PatchworkMC/patchwork-api/commit/d7c85712868850ece67723215998a77e0b2abfa0", "message": "Forge Javadoc typos", "committedDate": "2020-02-24T15:34:47Z", "type": "commit"}, {"oid": "77223d71d5fd64bf247b78047b31d2ab41d49645", "url": "https://github.com/PatchworkMC/patchwork-api/commit/77223d71d5fd64bf247b78047b31d2ab41d49645", "message": "TODOs of NYI call locations", "committedDate": "2020-02-24T15:34:49Z", "type": "commit"}, {"oid": "d786787f3ccea02a36eda9b8cbf0c426e18e8401", "url": "https://github.com/PatchworkMC/patchwork-api/commit/d786787f3ccea02a36eda9b8cbf0c426e18e8401", "message": "Comments", "committedDate": "2020-02-24T15:34:51Z", "type": "commit"}, {"oid": "7ad36bc56c43383a27f96149eb1d77e1ddf8b33c", "url": "https://github.com/PatchworkMC/patchwork-api/commit/7ad36bc56c43383a27f96149eb1d77e1ddf8b33c", "message": "Fix field visibility", "committedDate": "2020-02-24T15:34:56Z", "type": "commit"}, {"oid": "9452c35ab3965a04f16944ba9787e7310cb2ba7c", "url": "https://github.com/PatchworkMC/patchwork-api/commit/9452c35ab3965a04f16944ba9787e7310cb2ba7c", "message": "Don't call getTagsFor since it's client-only", "committedDate": "2020-02-24T15:34:59Z", "type": "commit"}, {"oid": "44fa52156e6921b8d28442cca9ffde6d98e12aac", "url": "https://github.com/PatchworkMC/patchwork-api/commit/44fa52156e6921b8d28442cca9ffde6d98e12aac", "message": "Clean up getCreatorModId for moving to ForgeHooks later", "committedDate": "2020-02-24T15:35:02Z", "type": "commit"}, {"oid": "efbc1fd01c25cd93b27d7f4e8f6027bc8136003f", "url": "https://github.com/PatchworkMC/patchwork-api/commit/efbc1fd01c25cd93b27d7f4e8f6027bc8136003f", "message": "Tweaks since DefaultedRegistry#getId is Nonnull", "committedDate": "2020-02-24T15:35:06Z", "type": "commit"}, {"oid": "6580bc0459eddca1ebb29480d67915fd97c792b0", "url": "https://github.com/PatchworkMC/patchwork-api/commit/6580bc0459eddca1ebb29480d67915fd97c792b0", "message": "Move getCreatorModId impl to mixins of subclasses", "committedDate": "2020-02-24T15:40:52Z", "type": "commit"}, {"oid": "068e339808666d2988e66e5f269855bffd8f7ced", "url": "https://github.com/PatchworkMC/patchwork-api/commit/068e339808666d2988e66e5f269855bffd8f7ced", "message": "Move default canDisableShield impl to AxeItem", "committedDate": "2020-02-24T16:05:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MDkyNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383650927", "bodyText": "This looks suspicious...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (!itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id)) {\n          \n          \n            \n            \t\tif (itemStack.isEmpty() || Registry.ITEM.getDefaultId().equals(id)) {", "author": "coderbot16", "createdAt": "2020-02-25T04:18:57Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinEnchantedBookItem.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+\n+import net.minecraft.item.EnchantedBookItem;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.nbt.ListTag;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+@Mixin(EnchantedBookItem.class)\n+public abstract class MixinEnchantedBookItem implements IForgeItem {\n+\t@Override\n+\tpublic String getCreatorModId(ItemStack itemStack) {\n+\t\tfinal Identifier id = Registry.ITEM.getId(itemStack.getItem());\n+\n+\t\tif (!itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id)) {", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MTU3OA==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383651578", "bodyText": "Is this part of IForgeItem? It looks like something separate. This is probably more appropriate for a different module.", "author": "coderbot16", "createdAt": "2020-02-25T04:22:37Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinItem.java", "diffHunk": "@@ -60,6 +67,24 @@ private void onConstruct(Item.Settings settings, CallbackInfo info) {\n \t\ttoolClasses.putAll(extension.getToolClasses());\n \t}\n \n+\t@Redirect(method = \"isEnchantable(Lnet/minecraft/item/ItemStack;)Z\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/item/Item;getMaxCount()I\"))\n+\tprivate int getMaxCountForStack(Item item, ItemStack stack) {\n+\t\treturn getItemStackLimit(stack);\n+\t}\n+\n+\t@ModifyConstant(method = \"rayTrace(Lnet/minecraft/world/World;Lnet/minecraft/entity/player/PlayerEntity;Lnet/minecraft/world/RayTraceContext$FluidHandling;)Lnet/minecraft/util/hit/HitResult;\", constant = @Constant(doubleValue = 5.0D))\n+\tprivate static double modifyReachDistance(double originalDist, World world, PlayerEntity player, RayTraceContext.FluidHandling fluidHandling) {\n+\t\t// TODO: return player.getAttributeInstance(REACH_DISTANCE).getValue();", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MTc1Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383651757", "bodyText": "Why the change from getTagsFor? This seems like it would be a lot slower.", "author": "coderbot16", "createdAt": "2020-02-25T04:23:31Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinItem.java", "diffHunk": "@@ -89,7 +114,14 @@ public int getHarvestLevel(ItemStack stack, Object /* TODO: ToolType */ tool, @N\n \t@Override\n \tpublic Set<Identifier> getTags() {\n \t\tif (cachedTags == null || tagVersion != ItemTagsAccessor.getLatestVersion()) {\n-\t\t\tthis.cachedTags = Collections.unmodifiableSet(new HashSet<>(ItemTags.getContainer().getTagsFor(getItem())));\n+\t\t\tthis.cachedTags = new HashSet<>();\n+\n+\t\t\tfor (final Map.Entry<Identifier, Tag<Item>> entry : ItemTags.getContainer().getEntries().entrySet()) {", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MTkyNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383651927", "bodyText": "Similarly suspicious logic\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (!itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id)) {\n          \n          \n            \n            \t\tif (itemStack.isEmpty() || Registry.ITEM.getDefaultId().equals(id)) {", "author": "coderbot16", "createdAt": "2020-02-25T04:24:23Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinPotionItems.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.PotionItem;\n+import net.minecraft.item.TippedArrowItem;\n+import net.minecraft.potion.Potion;\n+import net.minecraft.potion.PotionUtil;\n+import net.minecraft.potion.Potions;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+@Mixin({ PotionItem.class, TippedArrowItem.class })\n+public abstract class MixinPotionItems implements IForgeItem {\n+\t@Override\n+\tpublic String getCreatorModId(ItemStack itemStack) {\n+\t\tIdentifier id = Registry.ITEM.getId(itemStack.getItem());\n+\n+\t\tif (!itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id)) {", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MjA2Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383652067", "bodyText": "Ditto\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (!itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id)) {\n          \n          \n            \n            \t\tif (itemStack.isEmpty() || Registry.ITEM.getDefaultId().equals(id)) {", "author": "coderbot16", "createdAt": "2020-02-25T04:25:14Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinSpawnEggItem.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+@Mixin(SpawnEggItem.class)\n+public abstract class MixinSpawnEggItem implements IForgeItem {\n+\t@Override\n+\tpublic String getCreatorModId(ItemStack itemStack) {\n+\t\tfinal Item item = itemStack.getItem();\n+\t\tIdentifier id = Registry.ITEM.getId(item);\n+\n+\t\tif (!itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id)) {", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MjIxNw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383652217", "bodyText": "This null looks a tad bit suspicious here.", "author": "coderbot16", "createdAt": "2020-02-25T04:25:55Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinSpawnEggItem.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.SpawnEggItem;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+@Mixin(SpawnEggItem.class)\n+public abstract class MixinSpawnEggItem implements IForgeItem {\n+\t@Override\n+\tpublic String getCreatorModId(ItemStack itemStack) {\n+\t\tfinal Item item = itemStack.getItem();\n+\t\tIdentifier id = Registry.ITEM.getId(item);\n+\n+\t\tif (!itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id)) {\n+\t\t\treturn null;\n+\t\t} else {\n+\t\t\tfinal String namespace = id.getNamespace();\n+\n+\t\t\tif (\"minecraft\".equals(namespace)) {\n+\t\t\t\tfinal EntityType<?> type = ((SpawnEggItem) item).getEntityType(null);", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MjQ0Nw==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383652447", "bodyText": "Wow, this is thorough. Thanks so much for this!", "author": "coderbot16", "createdAt": "2020-02-25T04:27:05Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -76,13 +68,17 @@ default Item getItem() {\n \t\treturn (Item) this;\n \t}\n \n+\t// For call location TODOs, asterisks indicate calling the ItemStack or IForgeItemStack version of a method\n+\n+\t// TODO: Call locations: Patches: LivingEntity, ItemStack", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MzI3Ng==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r383653276", "bodyText": "Shouldn't this be an || because the item not existing or the stack being empty would be conditions for returning null?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn !itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id) ? null : id.getNamespace();\n          \n          \n            \n            \t\treturn itemStack.isEmpty() || Registry.ITEM.getDefaultId().equals(id) ? null : id.getNamespace();", "author": "coderbot16", "createdAt": "2020-02-25T04:31:04Z", "path": "patchwork-extensions/src/main/java/net/minecraftforge/common/extensions/IForgeItem.java", "diffHunk": "@@ -645,41 +682,11 @@ default boolean canContinueUsing(ItemStack oldStack, ItemStack newStack) {\n \t */\n \t@Nullable\n \tdefault String getCreatorModId(ItemStack itemStack) {\n-\t\tItem item = itemStack.getItem();\n-\t\tIdentifier registryName = Registry.ITEM.getId(item);\n-\t\tString modId = registryName == null ? null : registryName.getNamespace();\n-\n-\t\tif (\"minecraft\".equals(modId)) {\n-\t\t\tif (item instanceof EnchantedBookItem) {\n-\t\t\t\tListTag enchantmentsNbt = EnchantedBookItem.getEnchantmentTag(itemStack);\n-\n-\t\t\t\tif (enchantmentsNbt.size() == 1) {\n-\t\t\t\t\tCompoundTag nbttagcompound = enchantmentsNbt.getCompoundTag(0);\n-\t\t\t\t\tIdentifier resourceLocation = Identifier.tryParse(nbttagcompound.getString(\"id\"));\n-\n-\t\t\t\t\tif (resourceLocation != null && Registry.ENCHANTMENT.containsId(resourceLocation)) {\n-\t\t\t\t\t\treturn resourceLocation.getNamespace();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} else if (item instanceof PotionItem || item instanceof TippedArrowItem) {\n-\t\t\t\tPotion potionType = PotionUtil.getPotion(itemStack);\n-\t\t\t\tIdentifier resourceLocation = Registry.POTION.getId(potionType);\n-\n-\t\t\t\tif (resourceLocation != null) {\n-\t\t\t\t\treturn resourceLocation.getNamespace();\n-\t\t\t\t}\n-\t\t\t} else if (item instanceof SpawnEggItem) {\n-\t\t\t\tIdentifier resourceLocation = Registry.ENTITY_TYPE.getId(((SpawnEggItem) item).getEntityType(null));\n-\n-\t\t\t\tif (resourceLocation != null) {\n-\t\t\t\t\treturn resourceLocation.getNamespace();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn modId;\n+\t\tfinal Identifier id = Registry.ITEM.getId(itemStack.getItem());\n+\t\treturn !itemStack.isEmpty() && Registry.ITEM.getDefaultId().equals(id) ? null : id.getNamespace();", "originalCommit": "068e339808666d2988e66e5f269855bffd8f7ced", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "430eb8e31ed2a63123d54f1dbc4ea5c80b880d2e", "url": "https://github.com/PatchworkMC/patchwork-api/commit/430eb8e31ed2a63123d54f1dbc4ea5c80b880d2e", "message": "Replace empty check with default entry comparison", "committedDate": "2020-02-25T14:34:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0MzAyNQ==", "url": "https://github.com/PatchworkMC/patchwork-api/pull/46#discussion_r385343025", "bodyText": "I think we should remove this @ModifyConstant and instead just make a tracking issue for REACH_DISTANCE implementation. This is out of scope for IForgeItem.", "author": "coderbot16", "createdAt": "2020-02-27T20:05:44Z", "path": "patchwork-extensions/src/main/java/com/patchworkmc/mixin/extension/MixinItem.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.mixin.extension;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n+import org.spongepowered.asm.mixin.Unique;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Constant;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.ModifyConstant;\n+import org.spongepowered.asm.mixin.injection.Redirect;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;\n+import com.google.common.collect.Maps;\n+import net.minecraftforge.common.extensions.IForgeItem;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemGroup;\n+import net.minecraft.item.ItemPropertyGetter;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.ItemTags;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.world.RayTraceContext;\n+import net.minecraft.world.World;\n+\n+import com.patchworkmc.impl.extension.PatchworkItemSettingsExtensions;\n+\n+@Mixin(Item.class)\n+public abstract class MixinItem implements IForgeItem {\n+\t@Unique private Map<Object /* TODO: ToolType */, Integer> toolClasses;\n+\tprotected boolean canRepair;\n+\n+\t@Inject(at = @At(\"RETURN\"), method = \"<init>\")\n+\tprivate void onConstruct(Item.Settings settings, CallbackInfo info) {\n+\t\tfinal PatchworkItemSettingsExtensions extension = (PatchworkItemSettingsExtensions) settings;\n+\n+\t\tcanRepair = extension.canRepair();\n+\n+\t\ttoolClasses = Maps.newHashMap();\n+\t\ttoolClasses.putAll(extension.getToolClasses());\n+\t}\n+\n+\t@Redirect(method = \"isEnchantable(Lnet/minecraft/item/ItemStack;)Z\", at = @At(value = \"INVOKE\", target = \"Lnet/minecraft/item/Item;getMaxCount()I\"))\n+\tprivate int getMaxCountForStack(Item item, ItemStack stack) {\n+\t\treturn getItemStackLimit(stack);\n+\t}\n+\n+\t@ModifyConstant(method = \"rayTrace(Lnet/minecraft/world/World;Lnet/minecraft/entity/player/PlayerEntity;Lnet/minecraft/world/RayTraceContext$FluidHandling;)Lnet/minecraft/util/hit/HitResult;\", constant = @Constant(doubleValue = 5.0D))\n+\tprivate static double modifyReachDistance(double originalDist, World world, PlayerEntity player, RayTraceContext.FluidHandling fluidHandling) {\n+\t\t// TODO: return player.getAttributeInstance(REACH_DISTANCE).getValue();\n+\t\treturn originalDist;\n+\t}", "originalCommit": "430eb8e31ed2a63123d54f1dbc4ea5c80b880d2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9fe50ae6bdb2ab46d5f46818862ac1d2f721759b", "url": "https://github.com/PatchworkMC/patchwork-api/commit/9fe50ae6bdb2ab46d5f46818862ac1d2f721759b", "message": "Remove reach distance ModifyConstant", "committedDate": "2020-02-28T00:29:45Z", "type": "commit"}, {"oid": "6f189daecc3ed27848ea4f594a91db410e47177c", "url": "https://github.com/PatchworkMC/patchwork-api/commit/6f189daecc3ed27848ea4f594a91db410e47177c", "message": "Move to patchwork-extensions-item module", "committedDate": "2020-02-28T00:29:53Z", "type": "commit"}, {"oid": "8790bfa137e87928dba645033aca5e2888b0e562", "url": "https://github.com/PatchworkMC/patchwork-api/commit/8790bfa137e87928dba645033aca5e2888b0e562", "message": "Add README", "committedDate": "2020-02-28T10:56:47Z", "type": "commit"}, {"oid": "7e684591f392d9b74dfc05b1ccb43510bc0e9cfb", "url": "https://github.com/PatchworkMC/patchwork-api/commit/7e684591f392d9b74dfc05b1ccb43510bc0e9cfb", "message": "Commit to rerun CI checks", "committedDate": "2020-02-28T11:27:42Z", "type": "commit"}, {"oid": "553068e9496a41e7d127adbf66caf684855d79d9", "url": "https://github.com/PatchworkMC/patchwork-api/commit/553068e9496a41e7d127adbf66caf684855d79d9", "message": "Remove patchwork-fml dependency", "committedDate": "2020-03-07T12:37:06Z", "type": "commit"}]}