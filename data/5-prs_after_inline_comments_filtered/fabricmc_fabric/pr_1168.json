{"pr_number": 1168, "pr_title": "Fix MC-202036 - Shifting biome IDs", "pr_createdAt": "2020-11-17T21:06:34Z", "pr_url": "https://github.com/FabricMC/fabric/pull/1168", "timeline": [{"oid": "9876f7f08883893ec6cb9c86eadb9dca5e680a40", "url": "https://github.com/FabricMC/fabric/commit/9876f7f08883893ec6cb9c86eadb9dca5e680a40", "message": "First pass on PersistentDynamicRegistryHandler, not tested", "committedDate": "2020-11-17T21:02:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTU1NA==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525525554", "bodyText": "Just a few locals ;)", "author": "modmuss50", "createdAt": "2020-11-17T21:08:37Z", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/MixinMain.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package net.fabricmc.fabric.mixin.registry.sync;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.concurrent.CompletableFuture;\n+\n+import joptsimple.OptionParser;\n+import joptsimple.OptionSet;\n+import joptsimple.OptionSpec;\n+import com.mojang.authlib.GameProfileRepository;\n+import com.mojang.authlib.minecraft.MinecraftSessionService;\n+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;\n+import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.Inject;\n+import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n+import org.spongepowered.asm.mixin.injection.callback.LocalCapture;\n+\n+import net.minecraft.resource.DataPackSettings;\n+import net.minecraft.resource.ResourcePackManager;\n+import net.minecraft.resource.ServerResourceManager;\n+import net.minecraft.server.Main;\n+import net.minecraft.server.dedicated.EulaReader;\n+import net.minecraft.server.dedicated.ServerPropertiesLoader;\n+import net.minecraft.util.UserCache;\n+import net.minecraft.util.dynamic.RegistryOps;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.world.level.storage.LevelStorage;\n+\n+import net.fabricmc.fabric.impl.registry.sync.PersistentDynamicRegistryHandler;\n+\n+@Mixin(Main.class)\n+public class MixinMain {\n+\t@SuppressWarnings(\"rawtypes\")\n+\t@Inject(method = \"main\", at = @At(value = \"INVOKE_ASSIGN\", target = \"Lnet/minecraft/util/dynamic/RegistryOps;of(Lcom/mojang/serialization/DynamicOps;Lnet/minecraft/resource/ResourceManager;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;)Lnet/minecraft/util/dynamic/RegistryOps;\"), locals = LocalCapture.CAPTURE_FAILHARD)\n+\tprivate static void main(String[] args, CallbackInfo ci, OptionParser optionParser, OptionSpec optionSpec, OptionSpec optionSpec2, OptionSpec optionSpec3, OptionSpec optionSpec4, OptionSpec optionSpec5, OptionSpec optionSpec6, OptionSpec optionSpec7, OptionSpec optionSpec8, OptionSpec optionSpec9, OptionSpec optionSpec10, OptionSpec optionSpec11, OptionSpec optionSpec12, OptionSpec optionSpec13, OptionSpec optionSpec14, OptionSet optionSet, DynamicRegistryManager.Impl impl, Path path, ServerPropertiesLoader serverPropertiesLoader, Path path2, EulaReader eulaReader, File file, YggdrasilAuthenticationService yggdrasilAuthenticationService, MinecraftSessionService minecraftSessionService, GameProfileRepository gameProfileRepository, UserCache userCache, String string, LevelStorage levelStorage, LevelStorage.Session session, DataPackSettings dataPackSettings, boolean bl, ResourcePackManager resourcePackManager, DataPackSettings dataPackSettings2, CompletableFuture completableFuture, ServerResourceManager serverResourceManager2, RegistryOps registryOps) {", "originalCommit": "9876f7f08883893ec6cb9c86eadb9dca5e680a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzAxMA==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525543010", "bodyText": "o p t i o n s p e c", "author": "i509VCB", "createdAt": "2020-11-17T21:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MDEwMQ==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r526480101", "bodyText": "It might not be a bad idea to look at using a redirect here, or a ModifyArg as this mixin is going to be super fragile to updates.", "author": "modmuss50", "createdAt": "2020-11-18T23:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxODg2Mg==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r526518862", "bodyText": "Yeah I had a similar thing in the server world load event. The local variable are insanity. If you do choose that please note with a comment about how the redirect is easier to maintain than a modify arg due to large amount of local variables.", "author": "i509VCB", "createdAt": "2020-11-19T00:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODE5Mzc4NQ==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r528193785", "bodyText": "I have moved to 2 redirects.", "author": "modmuss50", "createdAt": "2020-11-21T12:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MTkxOQ==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525541919", "bodyText": "Maybe put the ID of the registry in the exception", "author": "i509VCB", "createdAt": "2020-11-17T21:39:14Z", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, existingTag);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;\n+\t}\n+\n+\t/**\n+\t * Remaps a registry if existing data is passed in.\n+\t * Then writes out the ids in the registry (remapped or a new world).\n+\t * Keeps hold of the orphaned registry entries as to not overwrite them.\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate static CompoundTag remapRegistry(Identifier registryId, MutableRegistry registry, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tif (!(registry instanceof RemappableRegistry)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Cannot remap un re-mappable registry\");", "originalCommit": "9876f7f08883893ec6cb9c86eadb9dca5e680a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MzMxMg==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r525543312", "bodyText": "Maybe quote what player said about this injection here on discord?", "author": "i509VCB", "createdAt": "2020-11-17T21:41:50Z", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/mixin/registry/sync/client/MixinMinecraftClient.java", "diffHunk": "@@ -44,4 +56,17 @@ public void disconnectAfter(Screen screen_1, CallbackInfo info) {\n \t\t\tFABRIC_LOGGER.warn(\"Failed to unmap Fabric registries!\", e);\n \t\t}\n \t}\n+\n+\t@Inject(method = \"createSaveProperties\", at = @At(value = \"INVOKE_ASSIGN\", target = \"Lnet/minecraft/util/dynamic/RegistryOps;of(Lcom/mojang/serialization/DynamicOps;Lnet/minecraft/resource/ResourceManager;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;)Lnet/minecraft/util/dynamic/RegistryOps;\"))\n+\tprivate static void createSaveProperties(LevelStorage.Session session, DynamicRegistryManager.Impl impl, ResourceManager resourceManager, DataPackSettings dataPackSettings, CallbackInfoReturnable<SaveProperties> cir) {\n+\t\tPath saveDir = ((AccessorLevelStorageSession) session).getDirectory();\n+\t\tPersistentDynamicRegistryHandler.remapDynamicRegistries(impl, saveDir);\n+\t}\n+\n+\t// synthetic in method_29607\n+\t@Inject(method = \"method_31125\", at = @At(value = \"INVOKE_ASSIGN\", target = \"Lnet/minecraft/util/dynamic/RegistryOps;of(Lcom/mojang/serialization/DynamicOps;Lnet/minecraft/resource/ResourceManager;Lnet/minecraft/util/registry/DynamicRegistryManager$Impl;)Lnet/minecraft/util/dynamic/RegistryOps;\"))", "originalCommit": "9876f7f08883893ec6cb9c86eadb9dca5e680a40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b33b50a67418baccae967869557cf24709c2c078", "url": "https://github.com/FabricMC/fabric/commit/b33b50a67418baccae967869557cf24709c2c078", "message": "Extra debugging + fix it not working", "committedDate": "2020-11-18T20:01:16Z", "type": "commit"}, {"oid": "145b8306b66958e8ec0b9642aa47e8973db91483", "url": "https://github.com/FabricMC/fabric/commit/145b8306b66958e8ec0b9642aa47e8973db91483", "message": "Fix build", "committedDate": "2020-11-18T20:24:08Z", "type": "commit"}, {"oid": "3a83d4adfc9db78a0fe095a1fec8a2bafd50f3ff", "url": "https://github.com/FabricMC/fabric/commit/3a83d4adfc9db78a0fe095a1fec8a2bafd50f3ff", "message": "Minor tweaks", "committedDate": "2020-11-18T20:28:26Z", "type": "commit"}, {"oid": "2b8a25496995114b2daaf749ecd79d33ddd54f2e", "url": "https://github.com/FabricMC/fabric/commit/2b8a25496995114b2daaf749ecd79d33ddd54f2e", "message": "checkstyle ;)", "committedDate": "2020-11-18T20:35:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NzgwNg==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527147806", "bodyText": "This completely ignores outputTag. I'd move the version wrapping to read/writeCompoundTag.", "author": "sfPlayer1", "createdAt": "2020-11-19T19:36:00Z", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tCompoundTag biomeRegistryData = null;\n+\n+\t\tif (existingTag != null) {\n+\t\t\tbiomeRegistryData = existingTag.getCompound(Registry.BIOME_KEY.getValue().toString());\n+\t\t}\n+\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, biomeRegistryData);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;", "originalCommit": "2b8a25496995114b2daaf749ecd79d33ddd54f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1NjE1NA==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527156154", "bodyText": "Good idea. Yes.", "author": "modmuss50", "createdAt": "2020-11-19T19:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NzgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0ODY0OA==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527148648", "bodyText": "It may be desirable to fix the bug with vanilla datapacks too?", "author": "sfPlayer1", "createdAt": "2020-11-19T19:37:32Z", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tCompoundTag biomeRegistryData = null;\n+\n+\t\tif (existingTag != null) {\n+\t\t\tbiomeRegistryData = existingTag.getCompound(Registry.BIOME_KEY.getValue().toString());\n+\t\t}\n+\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, biomeRegistryData);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;\n+\t}\n+\n+\t/**\n+\t * Remaps a registry if existing data is passed in.\n+\t * Then writes out the ids in the registry (remapped or a new world).\n+\t * Keeps hold of the orphaned registry entries as to not overwrite them.\n+\t */\n+\tprivate static <T> CompoundTag remapRegistry(Identifier registryId, MutableRegistry<T> registry, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tif (!(registry instanceof RemappableRegistry)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Cannot remap un re-mappable registry: \" + registryId.toString());\n+\t\t}\n+\n+\t\tboolean isModded = registry.getIds().stream().anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\n+\t\t// The current registry might not be modded, but we might have previous changed vanilla ids that we should try and remap\n+\t\tif (existingTag != null && !isModded) {\n+\t\t\tisModded = existingTag.getKeys().stream()\n+\t\t\t\t\t.map(existingTag::getString)\n+\t\t\t\t\t.map(Identifier::new)\n+\t\t\t\t\t.anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\t\t}\n+\n+\t\tif (LOGGER.isDebugEnabled()) {\n+\t\t\tif (existingTag == null) {\n+\t\t\t\tLOGGER.debug(\"No existing data found, assuming new registry with {} entries. modded = {}\", registry.getIds().size(), isModded);\n+\t\t\t} else {\n+\t\t\t\tLOGGER.debug(\"Existing registry data found. modded = {}\", isModded);\n+\n+\t\t\t\tfor (T entry : registry) {\n+\t\t\t\t\t//noinspection unchecked\n+\t\t\t\t\tIdentifier id = registry.getId(entry);\n+\t\t\t\t\tint rawId = registry.getRawId(entry);\n+\n+\t\t\t\t\tif (id == null) continue;\n+\n+\t\t\t\t\tif (existingTag.getKeys().contains(id.toString())) {\n+\t\t\t\t\t\tint existingRawId = existingTag.getInt(id.toString());\n+\n+\t\t\t\t\t\tif (rawId != existingRawId) {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Remapping {} {} -> {}\", id.toString(), rawId, existingRawId);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Using existing id for {} {}\", id.toString(), rawId);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tLOGGER.debug(\"Found new registry entry {}\", id.toString());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If we have some existing ids and the registry contains modded/datapack entries we remap the registry with those\n+\t\tif (existingTag != null && isModded) {", "originalCommit": "2b8a25496995114b2daaf749ecd79d33ddd54f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1NTgzMg==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527155832", "bodyText": "isModded in this case means any registry entry that contains an entry not in the minecraft namespace. The datapack I was testing with used its own namespace. I might be wrong but I would assume all custom biomes to not use the minecraft namespace?", "author": "modmuss50", "createdAt": "2020-11-19T19:49:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0ODY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzI1OQ==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527167259", "bodyText": "Right, that's fine IMO. Maybe clarify the comment a little?", "author": "sfPlayer1", "createdAt": "2020-11-19T20:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0ODY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0OTQwOA==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527149408", "bodyText": "Do we want to validate rawId too? (skip < 0)", "author": "sfPlayer1", "createdAt": "2020-11-19T19:38:57Z", "path": "fabric-registry-sync-v0/src/main/java/net/fabricmc/fabric/impl/registry/sync/PersistentDynamicRegistryHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.registry.sync;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.nbt.CompoundTag;\n+import net.minecraft.nbt.NbtIo;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.DynamicRegistryManager;\n+import net.minecraft.util.registry.MutableRegistry;\n+import net.minecraft.util.registry.Registry;\n+\n+public class PersistentDynamicRegistryHandler {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\n+\tpublic static void remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, Path saveDir) {\n+\t\tLOGGER.debug(\"Starting registry remap\");\n+\n+\t\tCompoundTag registryData;\n+\n+\t\ttry {\n+\t\t\tregistryData = remapDynamicRegistries(dynamicRegistryManager, readCompoundTag(getDataPath(saveDir)));\n+\t\t} catch (RemapException | IOException e) {\n+\t\t\t// TODO try the backups here?\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\n+\t\twriteCompoundTag(registryData, getDataPath(saveDir));\n+\t}\n+\n+\t@NotNull\n+\tprivate static CompoundTag remapDynamicRegistries(DynamicRegistryManager.Impl dynamicRegistryManager, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tCompoundTag registries = new CompoundTag();\n+\n+\t\t// For now we only care about biomes, but lets keep our options open\n+\t\tCompoundTag biomeRegistryData = null;\n+\n+\t\tif (existingTag != null) {\n+\t\t\tbiomeRegistryData = existingTag.getCompound(Registry.BIOME_KEY.getValue().toString());\n+\t\t}\n+\n+\t\tMutableRegistry<?> registry = dynamicRegistryManager.get(Registry.BIOME_KEY);\n+\t\tCompoundTag biomeIdMap = remapRegistry(Registry.BIOME_KEY.getValue(), registry, biomeRegistryData);\n+\t\tregistries.put(Registry.BIOME_KEY.getValue().toString(), biomeIdMap);\n+\n+\t\tCompoundTag outputTag = new CompoundTag();\n+\t\toutputTag.putInt(\"version\", 1);\n+\t\toutputTag.put(\"registries\", registries);\n+\t\treturn registries;\n+\t}\n+\n+\t/**\n+\t * Remaps a registry if existing data is passed in.\n+\t * Then writes out the ids in the registry (remapped or a new world).\n+\t * Keeps hold of the orphaned registry entries as to not overwrite them.\n+\t */\n+\tprivate static <T> CompoundTag remapRegistry(Identifier registryId, MutableRegistry<T> registry, @Nullable CompoundTag existingTag) throws RemapException {\n+\t\tif (!(registry instanceof RemappableRegistry)) {\n+\t\t\tthrow new UnsupportedOperationException(\"Cannot remap un re-mappable registry: \" + registryId.toString());\n+\t\t}\n+\n+\t\tboolean isModded = registry.getIds().stream().anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\n+\t\t// The current registry might not be modded, but we might have previous changed vanilla ids that we should try and remap\n+\t\tif (existingTag != null && !isModded) {\n+\t\t\tisModded = existingTag.getKeys().stream()\n+\t\t\t\t\t.map(existingTag::getString)\n+\t\t\t\t\t.map(Identifier::new)\n+\t\t\t\t\t.anyMatch(id -> !id.getNamespace().equals(\"minecraft\"));\n+\t\t}\n+\n+\t\tif (LOGGER.isDebugEnabled()) {\n+\t\t\tif (existingTag == null) {\n+\t\t\t\tLOGGER.debug(\"No existing data found, assuming new registry with {} entries. modded = {}\", registry.getIds().size(), isModded);\n+\t\t\t} else {\n+\t\t\t\tLOGGER.debug(\"Existing registry data found. modded = {}\", isModded);\n+\n+\t\t\t\tfor (T entry : registry) {\n+\t\t\t\t\t//noinspection unchecked\n+\t\t\t\t\tIdentifier id = registry.getId(entry);\n+\t\t\t\t\tint rawId = registry.getRawId(entry);\n+\n+\t\t\t\t\tif (id == null) continue;\n+\n+\t\t\t\t\tif (existingTag.getKeys().contains(id.toString())) {\n+\t\t\t\t\t\tint existingRawId = existingTag.getInt(id.toString());\n+\n+\t\t\t\t\t\tif (rawId != existingRawId) {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Remapping {} {} -> {}\", id.toString(), rawId, existingRawId);\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tLOGGER.debug(\"Using existing id for {} {}\", id.toString(), rawId);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tLOGGER.debug(\"Found new registry entry {}\", id.toString());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If we have some existing ids and the registry contains modded/datapack entries we remap the registry with those\n+\t\tif (existingTag != null && isModded) {\n+\t\t\tLOGGER.debug(\"Remapping {} with {} entries\", registryId, registry.getIds().size());\n+\t\t\tObject2IntMap<Identifier> idMap = new Object2IntOpenHashMap<>();\n+\n+\t\t\tfor (String key : existingTag.getKeys()) {\n+\t\t\t\tidMap.put(new Identifier(key), existingTag.getInt(key));\n+\t\t\t}\n+\n+\t\t\t((RemappableRegistry) registry).remap(registryId.toString(), idMap, RemappableRegistry.RemapMode.AUTHORITATIVE);\n+\t\t} else {\n+\t\t\tLOGGER.debug(\"Skipping remap of {}\", registryId);\n+\t\t}\n+\n+\t\t// Now start to build up what we are going to save out\n+\t\tCompoundTag registryTag = new CompoundTag();\n+\n+\t\t// Save all ids as they appear in the remapped, or new registry to disk even if not modded.\n+\t\tfor (T entry : registry) {\n+\t\t\t//noinspection unchecked\n+\t\t\tIdentifier id = registry.getId(entry);\n+\n+\t\t\tif (id == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tint rawId = registry.getRawId(entry);", "originalCommit": "2b8a25496995114b2daaf749ecd79d33ddd54f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1MjY2OA==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527152668", "bodyText": "I think the registry is gonna give you -1 if the object is not keyed in registry", "author": "i509VCB", "createdAt": "2020-11-19T19:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0OTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1NTk2Nw==", "url": "https://github.com/FabricMC/fabric/pull/1168#discussion_r527155967", "bodyText": "Good idea, might as well.", "author": "modmuss50", "createdAt": "2020-11-19T19:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0OTQwOA=="}], "type": "inlineReview"}, {"oid": "6ddde2ee51d972b43222a0c76dc0e215fe1cbd3a", "url": "https://github.com/FabricMC/fabric/commit/6ddde2ee51d972b43222a0c76dc0e215fe1cbd3a", "message": "Improve comments + fix issues with tag reading/writing", "committedDate": "2020-11-20T19:54:53Z", "type": "commit"}, {"oid": "f8dc85628a718803640695f67d71df9674bb2700", "url": "https://github.com/FabricMC/fabric/commit/f8dc85628a718803640695f67d71df9674bb2700", "message": "Simplify mixin", "committedDate": "2020-11-21T12:58:52Z", "type": "commit"}]}