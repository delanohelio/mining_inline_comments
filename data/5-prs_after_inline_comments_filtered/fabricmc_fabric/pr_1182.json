{"pr_number": 1182, "pr_title": "Add WorldRenderEvents", "pr_createdAt": "2020-11-25T09:29:55Z", "pr_url": "https://github.com/FabricMC/fabric/pull/1182", "timeline": [{"oid": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d", "url": "https://github.com/FabricMC/fabric/commit/e2a6ec281b4af1256536ea6ada93f9e2aae09c4d", "message": "Add WorldRenderEvents", "committedDate": "2020-11-25T09:11:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4ODU0OQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r530288549", "bodyText": "Typo", "author": "ramidzkh", "createdAt": "2020-11-25T11:04:30Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/mixin/client/rendering/MixinWorldRenderer.java", "diffHunk": "@@ -17,16 +17,152 @@\n package net.fabricmc.fabric.mixin.client.rendering;\n \n import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.At.Shift;\n import org.spongepowered.asm.mixin.injection.Inject;\n import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n \n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gl.ShaderEffect;\n+import net.minecraft.client.render.BufferBuilderStorage;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n \n import net.fabricmc.fabric.api.client.rendering.v1.InvalidateRenderStateCallback;\n+import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;\n+import net.fabricmc.fabric.impl.client.rendering.WorldRenderContextImpl;\n \n @Mixin(WorldRenderer.class)\n public abstract class MixinWorldRenderer {\n+\t@Shadow private BufferBuilderStorage bufferBuilders;\n+\t@Shadow private ClientWorld world;\n+\t@Shadow private ShaderEffect transparencyShader;\n+\t@Shadow private MinecraftClient client;\n+\tprivate final WorldRenderContextImpl context = new WorldRenderContextImpl();\n+\tprivate boolean didRenderParticles;\n+\n+\t@Inject(method = \"render\", at = @At(\"HEAD\"))\n+\tprivate void beforeRender(MatrixStack matrices, float tickDelta, long limitTime, boolean renderBlockOutline, Camera camera, GameRenderer gameRenderer, LightmapTextureManager lightmapTextureManager, Matrix4f matrix4f, CallbackInfo ci) {\n+\t\tcontext.prepare((WorldRenderer) (Object) this, matrices, tickDelta, limitTime, renderBlockOutline, camera, gameRenderer, lightmapTextureManager, matrix4f, bufferBuilders.getEntityVertexConsumers(), world.getProfiler(), transparencyShader != null, world);\n+\t\tWorldRenderEvents.START.invoker().onStart(context);\n+\t\tdidRenderParticles = false;\n+\t}\n+\n+\t@Inject(method = \"setupTerrain\", at = @At(\"RETURN\"))\n+\tprivate void afterTerrainSetup(Camera camera, Frustum frustum, boolean hasForcedFrustum, int frame, boolean spectator, CallbackInfo ci) {\n+\t\tcontext.setFrustum(frustum);\n+\t\tWorldRenderEvents.AFTER_SETUP.invoker().afterSetup(context);\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/render/WorldRenderer;renderLayer(Lnet/minecraft/client/render/RenderLayer;Lnet/minecraft/client/util/math/MatrixStack;DDD)V\",\n+\t\t\t\tordinal = 2,\n+\t\t\t\tshift = Shift.AFTER\n+\t\t\t)\n+\t)\n+\tprivate void afterTerrainSolid(CallbackInfo ci) {\n+\t\tWorldRenderEvents.BEFORE_ENTITIES.invoker().beforeEntities(context);\n+\t}\n+\n+\t@Inject(method = \"render\", at = @At(value = \"CONSTANT\", args = \"stringValue=blockentities\", ordinal = 0))\n+\tprivate void afterEntities(CallbackInfo ci) {\n+\t\tWorldRenderEvents.AFTER_ENTITIES.invoker().afterEntities(context);\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"FIELD\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/MinecraftClient;crosshairTarget:Lnet/minecraft/util/hit/HitResult;\",\n+\t\t\t\tshift = At.Shift.AFTER,\n+\t\t\t\tordinal = 1\n+\t\t\t)\n+\t)\n+\tprivate void beforeRenderOutline(CallbackInfo ci) {\n+\t\tcontext.setHitResult(client.crosshairTarget);\n+\t\tWorldRenderEvents.BEFORE_BLOCK_OUTLINE.invoker().beforeBlockOutline(context);\n+\t}\n+\n+\t@Inject(method = \"drawBlockOutline\", at = @At(\"HEAD\"), cancellable = true)\n+\tprivate void onDrawBlockOutline(MatrixStack matrixStack, VertexConsumer vertexConsumer, Entity entity, double cameraX, double cameraY, double cameraZ, BlockPos blockPos, BlockState blockState, CallbackInfo ci) {\n+\t\tif (context.didCancelDefaultBlockOutline()) {\n+\t\t\t// Was cancelled before we got here, so does not count as\n+\t\t\t// cancelled in later events, per contract of the API.\n+\t\t\tcontext.resetDefaultBlockOutline();\n+\t\t\tci.cancel();\n+\t\t} else {\n+\t\t\tcontext.prepareBlockOutline(vertexConsumer, entity, cameraX, cameraY, cameraZ, blockPos, blockState);\n+\t\t\tWorldRenderEvents.BLOCK_OUTLINE.invoker().onBlockOutline(context);\n+\n+\t\t\t// If default outline render was cancelled we leave that indicator intact\n+\t\t\tif (context.didCancelDefaultBlockOutline()) {\n+\t\t\t\tci.cancel();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/render/debug/DebugRenderer;render(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/VertexConsumerProvider$Immediate;DDD)V\",\n+\t\t\t\tordinal = 0\n+\t\t\t)\n+\t)\n+\tprivate void beforeDebugRender(CallbackInfo ci) {\n+\t\tWorldRenderEvents.BEFORE_DEBUG_RENDER.invoker().beforeDebugRender(context);\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/particle/ParticleManager;renderParticles(Lnet/minecraft/client/util/math/MatrixStack;Lnet/minecraft/client/render/VertexConsumerProvider$Immediate;Lnet/minecraft/client/render/LightmapTextureManager;Lnet/minecraft/client/render/Camera;F)V\"\n+\t\t\t)\n+\t)\n+\tprivate void onRenderParticles(CallbackInfo ci) {\n+\t\t// set a flag so we know the next pushMatrix call is after particles\n+\t\tdidRenderParticles = true;\n+\t}\n+\n+\t@Inject(method = \"render\", at = @At(value = \"INVOKE\", target = \"Lcom/mojang/blaze3d/systems/RenderSystem;pushMatrix()V\"))\n+\tprivate void beforeClouds(CallbackInfo ci) {\n+\t\tif (didRenderParticles) {\n+\t\t\tdidRenderParticles = false;\n+\t\t\tWorldRenderEvents.AFTER_TRANSLUCENT.invoker().afterTranslucent(context);\n+\t\t}\n+\t}\n+\n+\t@Inject(\n+\t\t\tmethod = \"render\",\n+\t\t\tat = @At(\n+\t\t\t\tvalue = \"INVOKE\",\n+\t\t\t\ttarget = \"Lnet/minecraft/client/render/WorldRenderer;renderChunkDebugInfo(Lnet/minecraft/client/render/Camera;)V\"\n+\t\t\t)\n+\t)\n+\tprivate void onChunkDebugRender(CallbackInfo ci) {\n+\t\tWorldRenderEvents.LAST.invoker().onLast(context);\n+\t}\n+\n+\t@Inject(method = \"render\", at = @At(\"RETURN\"))\n+\tprivate void afternRender(CallbackInfo ci) {", "originalCommit": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI5MDc3MQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r530290771", "bodyText": "typo", "author": "BoogieMonster1O1", "createdAt": "2020-11-25T11:08:02Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_REDER} this prevents the default outline render", "originalCommit": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMxMjc5MQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r530312791", "bodyText": "Typo :)", "author": "leocth", "createdAt": "2020-11-25T11:45:16Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_REDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code Worldrenderer.drawBlockOutline}.", "originalCommit": "e2a6ec281b4af1256536ea6ada93f9e2aae09c4d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "url": "https://github.com/FabricMC/fabric/commit/bfeeffa72cb53676a7f849ba488574474df9b6c7", "message": "Fix typos", "committedDate": "2020-11-25T16:15:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5MzkwOA==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531793908", "bodyText": "Add @unique on added fields.", "author": "modmuss50", "createdAt": "2020-11-27T21:53:49Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/mixin/client/rendering/MixinWorldRenderer.java", "diffHunk": "@@ -17,16 +17,152 @@\n package net.fabricmc.fabric.mixin.client.rendering;\n \n import org.spongepowered.asm.mixin.Mixin;\n+import org.spongepowered.asm.mixin.Shadow;\n import org.spongepowered.asm.mixin.injection.At;\n+import org.spongepowered.asm.mixin.injection.At.Shift;\n import org.spongepowered.asm.mixin.injection.Inject;\n import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n \n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.gl.ShaderEffect;\n+import net.minecraft.client.render.BufferBuilderStorage;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n \n import net.fabricmc.fabric.api.client.rendering.v1.InvalidateRenderStateCallback;\n+import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;\n+import net.fabricmc.fabric.impl.client.rendering.WorldRenderContextImpl;\n \n @Mixin(WorldRenderer.class)\n public abstract class MixinWorldRenderer {\n+\t@Shadow private BufferBuilderStorage bufferBuilders;\n+\t@Shadow private ClientWorld world;\n+\t@Shadow private ShaderEffect transparencyShader;\n+\t@Shadow private MinecraftClient client;\n+\tprivate final WorldRenderContextImpl context = new WorldRenderContextImpl();\n+\tprivate boolean didRenderParticles;", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMjA0OQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532102049", "bodyText": "Done", "author": "grondag", "createdAt": "2020-11-28T20:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5MzkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5NTM2OQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531795369", "bodyText": "AfterBlockOutline?", "author": "i509VCB", "createdAt": "2020-11-27T22:03:03Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import net.minecraft.client.render.WorldRenderer;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Mods should use these events to introduce custom rendering during {@link WorldRenderer#render(net.minecraft.client.util.math.MatrixStack, float, long, boolean, net.minecraft.client.render.Camera, net.minecraft.client.render.GameRenderer, net.minecraft.client.render.LightmapTextureManager, net.minecraft.util.math.Matrix4f)}\n+ * without adding complicated and conflict-prone injections there.  Using these events also enables 3rd-party renderers\n+ * that make large-scale changes to rendering maintain compatibility by calling any broken even invokers directly.\n+ *\n+ * <p>These events are not dependent on the Fabric rendering API or Indigo but work when those are present.\n+ */\n+public final class WorldRenderEvents {\n+\tprivate WorldRenderEvents() { }\n+\n+\t/**\n+\t * Called before world rendering executes. Input parameters are available but frustum is not.\n+\t * Use this event instead of injecting to the HEAD of {@link WorldRenderer#render} to avoid\n+\t * compatibility problems with 3rd-party renderer implementations.\n+\t *\n+\t * <p>Use for setup of state that is needed during the world render call that\n+\t * does not depend on the view frustum.\n+\t */\n+\tpublic static final Event<Start> START = EventFactory.createArrayBacked(Start.class, callbacks -> context -> {\n+\t\tfor (final Start callback : callbacks) {\n+\t\t\tcallback.onStart(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after view Frustum is computed and all render chunks to be rendered are\n+\t * identified and rebuilt but before chunks are uploaded to GPU.\n+\t *\n+\t * <p>Use for setup of state that depends on view frustum.\n+\t */\n+\tpublic static final Event<AfterSetup> AFTER_SETUP = EventFactory.createArrayBacked(AfterSetup.class, callbacks -> context -> {\n+\t\tfor (final AfterSetup callback : callbacks) {\n+\t\t\tcallback.afterSetup(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after the Solid, Cutout and Cutout Mipped terrain layers have been output to the framebuffer.\n+\t *\n+\t * <p>Use to render non-translucent terrain to the framebuffer.\n+\t *\n+\t * <p>Note that 3rd-party renderers may combine these passes or otherwise alter the\n+\t * rendering pipeline for sake of performance or features. This can break direct writes to the\n+\t * framebuffer.  Use this event for cases that cannot be satisfied by FabricBakedModel,\n+\t * BlockEntityRenderer or other existing abstraction. If at all possible, use an existing terrain\n+\t * RenderLayer instead of outputting to the framebuffer directly with GL calls.\n+\t *\n+\t * <p>The consumer is responsible for setup and tear down of GL state appropriate for the intended output.\n+\t *\n+\t * <p>Because solid and cutout quads are depth-tested, order of output does not matter except to improve\n+\t * culling performance, which should not be significant after primary terrain rendering. This means\n+\t * mods that currently hook calls to individual render layers can simply execute them all at once when\n+\t * the event is called.\n+\t *\n+\t * <p>This event fires before entities and block entities are rendered and may be useful to prepare them.\n+\t */\n+\tpublic static final Event<BeforeEntities> BEFORE_ENTITIES = EventFactory.createArrayBacked(BeforeEntities.class, callbacks -> context -> {\n+\t\tfor (final BeforeEntities callback : callbacks) {\n+\t\t\tcallback.beforeEntities(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after entities are rendered and solid entity layers\n+\t * have been drawn to the main frame buffer target, before\n+\t * block entity rendering begins.\n+\t *\n+\t * <p>Use for global block entity render setup, or\n+\t * to append block-related quads to the entity consumers using the\n+\t * {@VertexConsumerProvider} from the provided context. This\n+\t * will generally give better (if not perfect) results\n+\t * for non-terrain translucency vs. drawing directly later on.\n+\t */\n+\tpublic static final Event<AfterEntities> AFTER_ENTITIES = EventFactory.createArrayBacked(AfterEntities.class, callbacks -> context -> {\n+\t\tfor (final AfterEntities callback : callbacks) {\n+\t\t\tcallback.afterEntities(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called before default block outline rendering and before checks are\n+\t * done to determine if it should happen. Can optionally cancel the default\n+\t * rendering but all event handlers will always be called.\n+\t *\n+\t * <p>Use this to decorate or replace the default block outline rendering\n+\t * for specific modded blocks or when the need for a block outline render\n+\t * would not be detected.  Normally, outline rendering will not happen for\n+\t * entities or other game objects that do not register a block-type hit.\n+\t *\n+\t * <p>Canceling the default block outline render has no effect on other\n+\t * event subscribers - all subscribers will always be called. Generally, modded\n+\t * block outline renders are specific to that mod's content or additive\n+\t * and thus should not interfere with each other.\n+\t *\n+\t * <p>This event should NOT be used for general-purpose replacement of\n+\t * the default block outline rendering because it will interfere with mod-specific\n+\t * renders.  Mods that replace the default block outline should instead\n+\t * subscribe to {@link #BLOCK_OUTLINE}.\n+\t */\n+\tpublic static final Event<BeforeBlockOutline> BEFORE_BLOCK_OUTLINE = EventFactory.createArrayBacked(BeforeBlockOutline.class, callbacks -> context -> {\n+\t\tfor (final BeforeBlockOutline callback : callbacks) {\n+\t\t\tcallback.beforeBlockOutline(context);\n+\t\t}\n+\t});\n+\n+\t/**\n+\t * Called after block outline render checks are made and before the\n+\t * default block outline render runs.  Will NOT be called if the default outline\n+\t * render was cancelled in {@link #BEFORE_BLOCK_OUTLINE}.\n+\t *\n+\t * <p>Use this to replace the default block outline rendering entirely.\n+\t * Canceling the default outline render here avoids interfering\n+\t * with mod-specific outline renders that cannot be well-handled by a\n+\t * general-purpose outline renderer.\n+\t *\n+\t * <p>Default block outline rendering does not have to happen here.  If a custom\n+\t * default outline effect benefits from being drawn at a later stage it can\n+\t * be cancelled here and then drawn in {@link #AFTER_TRANSLUCENT} or {@link #LAST}\n+\t * if desired. To facilitate this pattern, those events can check\n+\t * {@link WorldRenderContext.AfterBlockOutline#didCancelDefaultBlockOutline()}.\n+\t */\n+\tpublic static final Event<BlockOutline> BLOCK_OUTLINE = EventFactory.createArrayBacked(BlockOutline.class, callbacks -> context -> {", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMjAyMQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532102021", "bodyText": "Changed to referr to the context instead of the interface.", "author": "grondag", "createdAt": "2020-11-28T20:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5NTM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5NjU0OA==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531796548", "bodyText": "Could all the classes be marked as client only? @Environment(EnvType.CLIENT)", "author": "i509VCB", "createdAt": "2020-11-27T22:10:25Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMjA3MQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532102071", "bodyText": "Done", "author": "grondag", "createdAt": "2020-11-28T20:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5NjU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzAzOQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807039", "bodyText": "I think the naming should be more explicit being like getWorldRenderer.", "author": "i509VCB", "createdAt": "2020-11-27T23:30:56Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMTk3Mw==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532101973", "bodyText": "Ugh. None of these are settable properties.  I'll do it if you make me but I don't see a need for it here.\nEven cancelDefaultBlockOutline is not a property - it's an action you can take but it can't be inspected in the same way a property could.  Later on there is a read-only property to inspect if the action did occur during a specific event, but to me that's not the same thing.", "author": "grondag", "createdAt": "2020-11-28T20:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzEyNQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807125", "bodyText": "shouldCancelDefaultBlockOutline", "author": "i509VCB", "createdAt": "2020-11-27T23:31:43Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutline {\n+\t\tVertexConsumer vertexConsumer();\n+\n+\t\tEntity entity();\n+\n+\t\tdouble cameraX();\n+\n+\t\tdouble cameraY();\n+\n+\t\tdouble cameraZ();\n+\n+\t\tBlockPos blockPos();\n+\n+\t\tBlockState blockState();\n+\t}\n+\n+\t/**\n+\t * Used after the block outline events to test if {@link #cancelDefaultBlockOutline()}\n+\t * was called during the {@code BLOCK_OUTLINE} event.\n+\t */\n+\tpublic interface AfterBlockOutline {\n+\t\t/**\n+\t\t * Tests if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t *\n+\t\t * <p>Will NOT be true if the outline was cancelled during {@code BEFORE_BLOCK_OUTLINE}.\n+\t\t *\n+\t\t * @return {@code true} if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t */\n+\t\tboolean didCancelDefaultBlockOutline();", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMDc2NQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532100765", "bodyText": "That's not necessarily what it means.  It means the block outline was cancelled during the BLOCK_OUTLINE event.  The event consumer can do whatever they want with that information, which might mean not rendering the block outline event if they  are replacing the default outline renderer, but that could have been handled during the event depending on how it is renderers.  Consumers of this may want it to decide if they should render some kind of additive information, etc.", "author": "grondag", "createdAt": "2020-11-28T20:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMzQ0Ng==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532103446", "bodyText": "To elaborate a bit more, if cancelDefaultBlockOutline is called during the BLOCK_RENDER event then this PR ensures drawBlockOutline also exits before the vanilla rendering code runs.  If a mod has done mixins downstream of that to change outline rendering, then they don't need to do anything to cancel their render.  But at least one mod cancels the vanilla outline render in all cases and instead renders it later during world rendering, so they need to know at that later time if it was cancelled.", "author": "grondag", "createdAt": "2020-11-28T20:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzMwNg==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807306", "bodyText": "I feel the Context on the end of these nested interfaces may be redundant. At the same time WorldRenderContext.Frustrum could be a bit weird, so this needs a bit of an evaluation.", "author": "i509VCB", "createdAt": "2020-11-27T23:33:38Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutline {\n+\t\tVertexConsumer vertexConsumer();\n+\n+\t\tEntity entity();\n+\n+\t\tdouble cameraX();\n+\n+\t\tdouble cameraY();\n+\n+\t\tdouble cameraZ();\n+\n+\t\tBlockPos blockPos();\n+\n+\t\tBlockState blockState();\n+\t}\n+\n+\t/**\n+\t * Used after the block outline events to test if {@link #cancelDefaultBlockOutline()}\n+\t * was called during the {@code BLOCK_OUTLINE} event.\n+\t */\n+\tpublic interface AfterBlockOutline {\n+\t\t/**\n+\t\t * Tests if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t *\n+\t\t * <p>Will NOT be true if the outline was cancelled during {@code BEFORE_BLOCK_OUTLINE}.\n+\t\t *\n+\t\t * @return {@code true} if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t */\n+\t\tboolean didCancelDefaultBlockOutline();\n+\t}\n+\n+\tpublic interface FrustumContext extends WorldRenderContext, AfterFrustum { }", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMTU3Ng==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532101576", "bodyText": "Not a hill I'm prepared to die on, but absent some specific direction leaving as is.", "author": "grondag", "createdAt": "2020-11-28T20:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzQyNA==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807424", "bodyText": "Considering the FrustrumContext is only used twice, it may be neater to just specify the method across both interface impls. May want to consider this as to reduce the amount of interfaces sub implementing eachother.", "author": "i509VCB", "createdAt": "2020-11-27T23:34:26Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();\n+\t}\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutline {\n+\t\tVertexConsumer vertexConsumer();\n+\n+\t\tEntity entity();\n+\n+\t\tdouble cameraX();\n+\n+\t\tdouble cameraY();\n+\n+\t\tdouble cameraZ();\n+\n+\t\tBlockPos blockPos();\n+\n+\t\tBlockState blockState();\n+\t}\n+\n+\t/**\n+\t * Used after the block outline events to test if {@link #cancelDefaultBlockOutline()}\n+\t * was called during the {@code BLOCK_OUTLINE} event.\n+\t */\n+\tpublic interface AfterBlockOutline {\n+\t\t/**\n+\t\t * Tests if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t *\n+\t\t * <p>Will NOT be true if the outline was cancelled during {@code BEFORE_BLOCK_OUTLINE}.\n+\t\t *\n+\t\t * @return {@code true} if the default block outline render was cancelled in the {@code BLOCK_OUTLINE} event.\n+\t\t */\n+\t\tboolean didCancelDefaultBlockOutline();\n+\t}\n+\n+\tpublic interface FrustumContext extends WorldRenderContext, AfterFrustum { }", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMTQ1NQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532101455", "bodyText": "Not following what \"both\" refers to.  FrustumContext is the parent super type for every context other than the starting one.", "author": "grondag", "createdAt": "2020-11-28T20:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwMDY0Mg==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r533700642", "bodyText": "IMO some nullable getters wouldn't hurt, e.g. adding nullable frustum() to WorldRenderContext allows dropping both AfterFrustum and FrustumContext. Nullable consumers in WorldRenderContext further removes Drawable and MainContext. AfterBlockOutline can IMO also be in WorldRenderContext without much potential for confusion. BlockOutline could be passed to the appropriate event as a separate parameter (even if it has the same backing object).\nWith all of the above changes we'd have a single context type everywhere, WorldRenderContext, at the cost of a few nullable methods that only yield a proper result in some documented scenarios.\nDrawable (actually VertexConsumerProvider then) may be nicer to pass in the event signature similar to what i proposed for BlockOutline above.", "author": "sfPlayer1", "createdAt": "2020-12-01T20:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMTU0MQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r534401541", "bodyText": "I'm fine with using @Nullable instead of separate instances interfaces if that is preferable.\nI don't like varying the method signature because I think what may be needed by consumers of these events is still likely to change over time and having everything in the context avoids the need for breaking changes and/or hanging on to deprecated event signatures.  The context is also a more robust extension point for Canvas or others that want to go there.", "author": "grondag", "createdAt": "2020-12-02T18:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ0NDM5Ng==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r534444396", "bodyText": "I am not talking about varying the signature everywhere, but passing the big differentiators (BlockOutline and VertexConsumerProvider) directly where it is appropriate, next to the regular context that captures all the generic info.", "author": "sfPlayer1", "createdAt": "2020-12-02T19:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MzQ4OA==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r543843488", "bodyText": "VertexConsumerProvider is specifically one I'd like to keep out of the method signature to better support extension use cases where it (along with the context itself) may be sub-typed. I'd prefer to make it nullable.", "author": "grondag", "createdAt": "2020-12-16T02:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzcyNQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r531807725", "bodyText": "Player raised a concern here about this context in use mixing up the cancellation + notification handling.", "author": "i509VCB", "createdAt": "2020-11-27T23:36:48Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.hit.HitResult;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\tpublic interface Drawable {\n+\t\t/**\n+\t\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t\t * incrementally and then drawn all at once by the world renderer.\n+\t\t *\n+\t\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t\t * possible, caller should use a separate \"immediate\" instance.\n+\t\t *\n+\t\t * <p>This property is not exposed before {@link WorldRenderEvents#BEFORE_ENTITIES} or after\n+\t\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t\t * overdrawn or cleared.\n+\t\t */\n+\t\tVertexConsumerProvider consumers();\n+\t}\n+\n+\t/**\n+\t * Conveys WorldRenderer state to event handlers after invocation.\n+\t * Includes view frustum, which is not available then.\n+\t */\n+\tpublic interface AfterFrustum {\n+\t\tFrustum frustum();\n+\t}\n+\n+\t/**\n+\t * Used in the block breaking callback to convey information on\n+\t * ray trace hit and accept cancellation of default outline render.\n+\t */\n+\tpublic interface PreBlockOutline {\n+\t\t/**\n+\t\t * The game object currently under the crosshair target. Normally\n+\t\t * equivalent to {@link MinecraftClient#crosshairTarget}.\n+\t\t * Provided for convenience.\n+\t\t */\n+\t\t@Nullable HitResult hitResult();\n+\n+\t\t/**\n+\t\t * Call to prevent the default block outline from rendering.\n+\t\t * Use this for event handlers that fully replace the vanilla\n+\t\t * block outline render.\n+\t\t *\n+\t\t * <p>The effect of this method depends on the event from which it is called:\n+\t\t *\n+\t\t * <p>In {@code BEFORE_BLOCK_RENDER} this prevents invocation of\n+\t\t * the {@code BLOCK_RENDER} event and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code false} in later-stage event invocations. It (obviously)\n+\t\t * also prevents the default outline render from running.\n+\t\t *\n+\t\t * <p>In {@code BLOCK_RENDER} this prevents the default outline render\n+\t\t * from running and {@link AfterBlockOutline#didCancelDefaultBlockOutline()}\n+\t\t * will be {@code true} in later-stage event invocations.\n+\t\t *\n+\t\t * <p>In both cases, this method is idempotent - calling it from more\n+\t\t * than one event subscriber has the same effect as calling it once.\n+\t\t * All event handlers within the same event invocation will always\n+\t\t * execute and the cancellation status cannot be inspected during the\n+\t\t * block outline render events.\n+\t\t */\n+\t\tvoid cancelDefaultBlockOutline();", "originalCommit": "bfeeffa72cb53676a7f849ba488574474df9b6c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEwMDkzOA==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r532100938", "bodyText": "I'll need a little more elaboration to understand what the problem is here.", "author": "grondag", "createdAt": "2020-11-28T20:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY4OTI0MA==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r533689240", "bodyText": "We want to avoid mixing notification and cancellation in the same event since that'd incorrectly notify some subscribers. If the 2nd subscriber happened to cancel, the 1st one would never know that the notified action won't actually happen with inline cancellation.\nSo e.g. instead of\nforeach (subscriber) {\n  if (!subscriber.onBeforeX()) return;\n}\n\n<vanilla logic>\n\nforeach (subscriber) {\n  subscriber.onAfterX();\n}\n\nit should do\nboolean cancelled = false;\n\nforeach (subscriber) {\n  if (!subscriber.shouldDoX()) {\n    cancelled = true;\n    break;\n  }\n}\n\nif (!cancelled) {\n  foreach (subscriber) {\n    subscriber.onBeforeX();\n  }\n\n  <vanilla logic>\n\n  foreach (subscriber) {\n    subscriber.onAfterX();\n  }\n} else {\n  foreach (subscriber) {\n    subscriber.onXCancelled();\n  }\n}\n\nfor an example with the full set of notifications (a real case would only provide those that are reasonable)", "author": "sfPlayer1", "createdAt": "2020-12-01T20:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwMzI4NQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r534403285", "bodyText": "That helps, thank you.  I'll need to think about how it applies here.", "author": "grondag", "createdAt": "2020-12-02T18:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5OTM2Nw==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r543899367", "bodyText": "I've considered this some more.  The main problem seems to be the API causes confusion.\nFirst, the behavior is not like this:\n\nWe want to avoid mixing notification and cancellation in the same event since that'd incorrectly notify some subscribers. If the 2nd subscriber happened to cancel, the 1st one would never know that the notified action won't actually happen with inline cancellation.\n\nThe block render events cannot cancel an event for any peer subscriber.  Ever.  This is clearly stated in the docs:\n\n... [cancelDefaultBlockOutline()] is idempotent - calling it from more than one event subscriber has the same effect as calling it once. All event handlers within the same event invocation will always execute and the cancellation status cannot be inspected during the block outline render events.\n\nThe \"cannot be inspected\" is specifically meant to prohibit subscribers from trying to compete with or depend on each other.  The order of calling is not deterministic and they don't directly affect each other, so that would only cause problems.\nWhat it cancels depends on usage.\n\nIn BEFORE_BLOCK_RENDER it prevents the block outline render entirely. BLOCK_RENDER will not be called.\nIn BLOCK_RENDER it prevents the vanilla block outline render from running but has no effect on other subscribers.\n\nLet's cover each in more detail.\nBEFORE_BLOCK_RENDER\nThe primary use here is when the player is looking at something like a fluid or entity that wants to mimic block behavior and display an outline. A fluid or entity would never register as a hit for block outline rendering, so this provides a way to detect those special hits and render if appropriate.\nIf the block outline render isn't cancelled here, then depending on circumstance two outlines will be rendered.   The desired behavior is to pretend there was never a block hit in the first place, and so the entire block outline handling is cancelled and BLOCK_RENDER never fires, which is exactly what should normally happen if the player isn't targeting a block.\nThe BEFORE_BLOCK_RENDER is also potentially useful for rendering in-world information that doesn't necessarily care about whether or not block outline rendering occurs.  Subscribers with this use case can rely on being called every frame even if the block outline render is cancelled.\nWhat happens if an entity with a special bounding box is standing in a fluid that also has a special bounding box?   Both boxes will render. Any other answer would make this much more elaborate than it needs to be for the vast majority of cases.\nBLOCK_RENDER\nThis is called when a conventional block outline render would normally happen - when the player is targeting a nearby block and we aren't pretending otherwise because some mod is faking a hit.\nThis is where mods that want to replace block outline rendering for specific blocks should subscribe.  Every subscriber gets called, and every mod that wants to can render.  Exotic Blocks, for example, has many non-cubic shapes that would not render well with a conventional outline renderer so it can use this event instead of a mixin to do that.\nAgain, the subscribers here cannot cancel each other - they can only cancel the default block outline render that would normally come after.\nThis event is not a good solution for mods that want to replace the default outline renderer for all blocks.  First, such a mod should probably not render an outline if a subscriber to BLOCK_RENDER has cancelled it.  Presumably a more specific outline renderer will do a better job and should be allowed to do it.\nI assumed a general-purpose outline mod would not use the BLOCK_RENDER event and instead mix in to drawShapeOutline, which will not be called if BLOCK_RENDER is cancelled. That's a nice, clean target and generally only one mod is going to be able to replace it fully.\nHowever, at least one such mod (Custom Selection Box) doesn't want to render at that point because it is going to employ translucency that wouldn't render correctly until later in the frame.  It is going to NOOP the drawShapeOutline and render the outline in a later WorldRenderEvent.\nHowever, such a mod needs a way to know if drawShapeOutline was ever called.  It could set some state there and then reference it a few microseconds later, but for convenience I added didCancelDefaultBlockOutline() to the context so it can check directly.  But that's a false economy because said mod still needs to mix in to drawShapeOutline to prevent it from doing anything.\nAnd the larger problem is that the overall scheme around block outline rendering is very confusing.\nI think it may be best to simplify the two block outline events and remove didCancelDefaultBlockOutline().  General-purpose block outline replacements can fend for themselves using the usual and customary methods. More robust support for a general-purpose outline replacement would require another event, at least one more mixin, or perhaps some kind of BlockOutlineRendererPlugIn API, all of which seems well outside the scope of this PR, and probably outside the scope of Fabric API generally.", "author": "grondag", "createdAt": "2020-12-16T03:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTgwNzcyNQ=="}], "type": "inlineReview"}, {"oid": "caaffdddb3a90c20843f32d4704ab1128c6c10a0", "url": "https://github.com/FabricMC/fabric/commit/caaffdddb3a90c20843f32d4704ab1128c6c10a0", "message": "Incorporate PR feedback", "committedDate": "2020-11-28T20:23:22Z", "type": "commit"}, {"oid": "d44ecf2ff94a2b2d94946539ac57d719921d0498", "url": "https://github.com/FabricMC/fabric/commit/d44ecf2ff94a2b2d94946539ac57d719921d0498", "message": "Simplify context and block outline events", "committedDate": "2020-12-16T04:57:46Z", "type": "commit"}, {"oid": "cb4cbec2ad0f7be5eabf52cd4ae0c3b157eef232", "url": "https://github.com/FabricMC/fabric/commit/cb4cbec2ad0f7be5eabf52cd4ae0c3b157eef232", "message": "Update implementation", "committedDate": "2020-12-16T05:11:11Z", "type": "commit"}, {"oid": "9663839baab54e18179d85297d791f5c87a38767", "url": "https://github.com/FabricMC/fabric/commit/9663839baab54e18179d85297d791f5c87a38767", "message": "Ensure the BLOCK_OUTLINE mixin does nothing if BEFORE_BLOCK_OUTLINE mixin is disabled", "committedDate": "2020-12-16T05:49:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNzU4Mw==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r544137583", "bodyText": "Is there a reason you are specifying the empty invoker impl for the events?", "author": "i509VCB", "createdAt": "2020-12-16T09:21:18Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java", "diffHunk": "@@ -213,7 +237,7 @@ private WorldRenderEvents() { }\n \t * down transient state in event handlers or as a hook that precedes hand/held item\n \t * and GUI rendering.\n \t */\n-\tpublic static final Event<End> END = EventFactory.createArrayBacked(End.class, callbacks -> context -> {\n+\tpublic static final Event<End> END = EventFactory.createArrayBacked(End.class, context -> { }, callbacks -> context -> {", "originalCommit": "d44ecf2ff94a2b2d94946539ac57d719921d0498", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQzMDY3OQ==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r544430679", "bodyText": "Per the Fabric docs, it makes a small performance difference and these events are called every frame and there are several of them.", "author": "grondag", "createdAt": "2020-12-16T16:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNzU4Mw=="}], "type": "inlineReview"}, {"oid": "b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471", "url": "https://github.com/FabricMC/fabric/commit/b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471", "message": "Document event order in class header", "committedDate": "2020-12-16T16:26:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ2NzYzNg==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r544467636", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * that make large-scale changes to rendering maintain compatibility by calling any broken even invokers directly.\n          \n          \n            \n             * that make large-scale changes to rendering maintain compatibility by calling any broken event invokers directly.", "author": "Juuxel", "createdAt": "2020-12-16T17:03:18Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.client.MinecraftClient;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.util.hit.HitResult;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderContext.BlockOutlineContext;\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+\n+/**\n+ * Mods should use these events to introduce custom rendering during {@link WorldRenderer#render(net.minecraft.client.util.math.MatrixStack, float, long, boolean, net.minecraft.client.render.Camera, net.minecraft.client.render.GameRenderer, net.minecraft.client.render.LightmapTextureManager, net.minecraft.util.math.Matrix4f)}\n+ * without adding complicated and conflict-prone injections there.  Using these events also enables 3rd-party renderers\n+ * that make large-scale changes to rendering maintain compatibility by calling any broken even invokers directly.", "originalCommit": "b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQ2ODE4OA==", "url": "https://github.com/FabricMC/fabric/pull/1182#discussion_r544468188", "bodyText": "I don't think the @Environment propagates to nested types, so this needs it as well.", "author": "Juuxel", "createdAt": "2020-12-16T17:04:05Z", "path": "fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderContext.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.client.rendering.v1;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.client.render.Camera;\n+import net.minecraft.client.render.Frustum;\n+import net.minecraft.client.render.GameRenderer;\n+import net.minecraft.client.render.LightmapTextureManager;\n+import net.minecraft.client.render.VertexConsumer;\n+import net.minecraft.client.render.VertexConsumerProvider;\n+import net.minecraft.client.render.WorldRenderer;\n+import net.minecraft.client.util.math.MatrixStack;\n+import net.minecraft.client.world.ClientWorld;\n+import net.minecraft.entity.Entity;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.Matrix4f;\n+import net.minecraft.util.profiler.Profiler;\n+\n+import net.fabricmc.api.EnvType;\n+import net.fabricmc.api.Environment;\n+\n+/**\n+ * Except as noted below, the properties exposed here match the parameters passed to\n+ * {@link WorldRenderer#render(MatrixStack, float, long, boolean, Camera, GameRenderer, LightmapTextureManager, Matrix4f)}.\n+ */\n+@Environment(EnvType.CLIENT)\n+public interface WorldRenderContext {\n+\t/**\n+\t * The world renderer instance doing the rendering and invoking the event.\n+\t *\n+\t * @return WorldRenderer instance invoking the event\n+\t */\n+\tWorldRenderer worldRenderer();\n+\n+\tMatrixStack matrixStack();\n+\n+\tfloat tickDelta();\n+\n+\tlong limitTime();\n+\n+\tboolean blockOutlines();\n+\n+\tCamera camera();\n+\n+\tGameRenderer gameRenderer();\n+\n+\tLightmapTextureManager lightmapTextureManager();\n+\n+\tMatrix4f projectionMatrix();\n+\n+\t/**\n+\t * Convenient access to {WorldRenderer.world}.\n+\t *\n+\t * @return world renderer's client world instance\n+\t */\n+\tClientWorld world();\n+\n+\t/**\n+\t * Convenient access to game performance profiler.\n+\t *\n+\t * @return the active profiler\n+\t */\n+\tProfiler profiler();\n+\n+\t/**\n+\t * Test to know if \"fabulous\" graphics mode is enabled.\n+\t *\n+\t * <p>Use this for renders that need to render on top of all translucency to activate or deactivate different\n+\t * event handlers to get optimal depth testing results. When fabulous is off, it may be better to render\n+\t * during {@code WorldRenderLastCallback} after clouds and weather are drawn. Conversely, when fabulous mode is on,\n+\t * it may be better to draw during {@code WorldRenderPostTranslucentCallback}, before the fabulous mode composite\n+\t * shader runs, depending on which translucent buffer is being targeted.\n+\t *\n+\t * @return {@code true} when \"fabulous\" graphics mode is enabled.\n+\t */\n+\tboolean advancedTranslucency();\n+\n+\t/**\n+\t * The {@code VertexConsumerProvider} instance being used by the world renderer for most non-terrain renders.\n+\t * Generally this will be better for most use cases because quads for the same layer can be buffered\n+\t * incrementally and then drawn all at once by the world renderer.\n+\t *\n+\t * <p>IMPORTANT - all vertex coordinates sent to consumers should be relative to the camera to\n+\t * be consistent with other quads emitted by the world renderer and other mods.  If this isn't\n+\t * possible, caller should use a separate \"immediate\" instance.\n+\t *\n+\t * <p>This property is {@code null} before {@link WorldRenderEvents#BEFORE_ENTITIES} and after\n+\t * {@link WorldRenderEvents#BEFORE_DEBUG_RENDER} because the consumer buffers are not available before or\n+\t * drawn after that in vanilla world rendering.  Renders that cannot draw in one of the supported events\n+\t * must be drawn directly to the frame buffer, preferably in {@link WorldRenderEvents#LAST} to avoid being\n+\t * overdrawn or cleared.\n+\t */\n+\t@Nullable VertexConsumerProvider consumers();\n+\n+\t/**\n+\t * View frustum, after it is initialized. Will be {@code null} during\n+\t * {@link WorldRenderEvents#START}.\n+\t */\n+\t@Nullable Frustum frustum();\n+\n+\t/**\n+\t * Used in {@code BLOCK_OUTLINE} to convey the parameters normally sent to\n+\t * {@code WorldRenderer.drawBlockOutline}.\n+\t */\n+\tpublic interface BlockOutlineContext {", "originalCommit": "b3fd84ca9f46cf93ff0ba1ba2abc2f93cec8e471", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "665af331d5a316104a92f66c07aa15ee77871b43", "url": "https://github.com/FabricMC/fabric/commit/665af331d5a316104a92f66c07aa15ee77871b43", "message": "Update fabric-rendering-v1/src/main/java/net/fabricmc/fabric/api/client/rendering/v1/WorldRenderEvents.java\n\nCo-authored-by: Juuxel <6596629+Juuxel@users.noreply.github.com>", "committedDate": "2020-12-16T17:17:58Z", "type": "commit"}, {"oid": "834c9f07470999dd4e297184ab7dd3e690dff93f", "url": "https://github.com/FabricMC/fabric/commit/834c9f07470999dd4e297184ab7dd3e690dff93f", "message": "Add environment tag to nested type", "committedDate": "2020-12-16T17:19:49Z", "type": "commit"}, {"oid": "eb8a366ce321e2d20cecef6c2128ec0d620b287b", "url": "https://github.com/FabricMC/fabric/commit/eb8a366ce321e2d20cecef6c2128ec0d620b287b", "message": "Merge branch 'WorldRenderEvents' of https://github.com/grondag/fabric into WorldRenderEvents", "committedDate": "2020-12-16T17:20:00Z", "type": "commit"}, {"oid": "0dd3702a9d8c419d85112771288d9649a5b36bc4", "url": "https://github.com/FabricMC/fabric/commit/0dd3702a9d8c419d85112771288d9649a5b36bc4", "message": "More envionment tags", "committedDate": "2020-12-18T01:11:58Z", "type": "commit"}]}