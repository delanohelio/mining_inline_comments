{"pr_number": 589, "pr_title": "tool attribute 1.1", "pr_createdAt": "2020-04-22T08:08:31Z", "pr_url": "https://github.com/FabricMC/fabric/pull/589", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NzEyNQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412797125", "bodyText": "injector can be private", "author": "liach", "createdAt": "2020-04-22T08:52:02Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/mixin/tool/attribute/MixinPlayerInventory.java", "diffHunk": "@@ -63,7 +63,7 @@ public void actMiningLevel(BlockState state, CallbackInfoReturnable<Boolean> inf\n \t}\n \n \t@Inject(method = \"getBlockBreakingSpeed\", at = @At(\"HEAD\"), cancellable = true)\n-\tpublic void actMiningSleed(BlockState state, CallbackInfoReturnable<Float> info) {\n+\tpublic void actMiningSpeed(BlockState state, CallbackInfoReturnable<Float> info) {", "originalCommit": "e1f5c174c11283c69463f054a102060db59ce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a086ddde857c6cf06a9e3850f65e00ce1a0d0a80", "url": "https://github.com/FabricMC/fabric/commit/a086ddde857c6cf06a9e3850f65e00ce1a0d0a80", "message": "Actual support", "committedDate": "2020-04-22T10:18:20Z", "type": "commit"}, {"oid": "a086ddde857c6cf06a9e3850f65e00ce1a0d0a80", "url": "https://github.com/FabricMC/fabric/commit/a086ddde857c6cf06a9e3850f65e00ce1a0d0a80", "message": "Actual support", "committedDate": "2020-04-22T10:18:20Z", "type": "forcePushed"}, {"oid": "f406acf786eea94b7a65d77b1738a53838b8176a", "url": "https://github.com/FabricMC/fabric/commit/f406acf786eea94b7a65d77b1738a53838b8176a", "message": "Remove this useless mixin", "committedDate": "2020-04-22T10:24:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NDQ4MQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412864481", "bodyText": "is this really necessary if we have the registerBlockSupport call above? The other pick mining levels are definitely necessary, but this one seems redundant.", "author": "LemmaEOF", "createdAt": "2020-04-22T10:29:43Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/VanillaToolsSupport.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.Blocks;\n+import net.minecraft.block.Material;\n+import net.minecraft.item.Item;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+\n+public class VanillaToolsSupport implements ModInitializer {\n+\tprivate static final Logger LOGGER = LogManager.getLogger(\"fabric-tool-attribute-api-v1\");\n+\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tfor (Block block : Registry.BLOCK) {\n+\t\t\tregisterBlockSupport(Registry.BLOCK.getId(block), block);\n+\t\t}\n+\n+\t\tRegistryEntryAddedCallback.event(Registry.BLOCK).register((rawId, id, object) -> registerBlockSupport(id, object));\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 3, Blocks.OBSIDIAN);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 2, Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.EMERALD_ORE, Blocks.EMERALD_BLOCK, Blocks.GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.REDSTONE_ORE);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 1, Blocks.IRON_BLOCK, Blocks.IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 0, Blocks.ACTIVATOR_RAIL, Blocks.COAL_ORE, Blocks.COBBLESTONE, Blocks.DETECTOR_RAIL, Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.POWERED_RAIL, Blocks.GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.ICE, Blocks.IRON_BLOCK, Blocks.IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE, Blocks.MOSSY_COBBLESTONE, Blocks.NETHERRACK, Blocks.PACKED_ICE, Blocks.BLUE_ICE, Blocks.RAIL, Blocks.REDSTONE_ORE, Blocks.SANDSTONE, Blocks.CHISELED_SANDSTONE, Blocks.CUT_SANDSTONE, Blocks.CHISELED_RED_SANDSTONE, Blocks.CUT_RED_SANDSTONE, Blocks.RED_SANDSTONE, Blocks.STONE, Blocks.GRANITE, Blocks.POLISHED_GRANITE, Blocks.DIORITE, Blocks.POLISHED_DIORITE, Blocks.ANDESITE, Blocks.POLISHED_ANDESITE, Blocks.STONE_SLAB, Blocks.SMOOTH_STONE_SLAB, Blocks.SANDSTONE_SLAB, Blocks.PETRIFIED_OAK_SLAB, Blocks.COBBLESTONE_SLAB, Blocks.BRICK_SLAB, Blocks.STONE_BRICK_SLAB, Blocks.NETHER_BRICK_SLAB, Blocks.QUARTZ_SLAB, Blocks.RED_SANDSTONE_SLAB, Blocks.PURPUR_SLAB, Blocks.SMOOTH_QUARTZ, Blocks.SMOOTH_RED_SANDSTONE, Blocks.SMOOTH_SANDSTONE, Blocks.SMOOTH_STONE, Blocks.STONE_BUTTON, Blocks.STONE_PRESSURE_PLATE, Blocks.POLISHED_GRANITE_SLAB, Blocks.SMOOTH_RED_SANDSTONE_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.POLISHED_DIORITE_SLAB, Blocks.MOSSY_COBBLESTONE_SLAB, Blocks.END_STONE_BRICK_SLAB, Blocks.SMOOTH_SANDSTONE_SLAB, Blocks.SMOOTH_QUARTZ_SLAB, Blocks.GRANITE_SLAB, Blocks.ANDESITE_SLAB, Blocks.RED_NETHER_BRICK_SLAB, Blocks.POLISHED_ANDESITE_SLAB, Blocks.DIORITE_SLAB, Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX);", "originalCommit": "f406acf786eea94b7a65d77b1738a53838b8176a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3MTc5Ng==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412871796", "bodyText": "Things like ACTIVATOR_RAIL is not in any of the materials affected by pickaxe, I will have to look into every one of these to check if they match the material, might do though.", "author": "shedaniel", "createdAt": "2020-04-22T10:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NDQ4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3NjM5Ng==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412876396", "bodyText": "The only ones that need to stay, from what I can tell, are the rails (normal, powered, detector, activator), the ices (normal, packed, and blue), and the shulker boxes (normal plus all 16 colors). All the others use Material.STONE or Material.METAL.", "author": "LemmaEOF", "createdAt": "2020-04-22T10:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NDQ4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3ODQxNQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412878415", "bodyText": "Done, please check", "author": "shedaniel", "createdAt": "2020-04-22T10:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NDQ4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzQ3Nw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412887477", "bodyText": "Looks good!", "author": "LemmaEOF", "createdAt": "2020-04-22T11:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NDQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NTI4OA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412865288", "bodyText": "I'm not sure where in loading stages ModInitializer gets called - is it before vanilla reg, after it, or unreliable?", "author": "LemmaEOF", "createdAt": "2020-04-22T10:30:57Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/VanillaToolsSupport.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.Blocks;\n+import net.minecraft.block.Material;\n+import net.minecraft.item.Item;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.event.registry.RegistryEntryAddedCallback;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+\n+public class VanillaToolsSupport implements ModInitializer {\n+\tprivate static final Logger LOGGER = LogManager.getLogger(\"fabric-tool-attribute-api-v1\");\n+\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tfor (Block block : Registry.BLOCK) {\n+\t\t\tregisterBlockSupport(Registry.BLOCK.getId(block), block);\n+\t\t}\n+\n+\t\tRegistryEntryAddedCallback.event(Registry.BLOCK).register((rawId, id, object) -> registerBlockSupport(id, object));", "originalCommit": "f406acf786eea94b7a65d77b1738a53838b8176a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2OTIwNQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412869205", "bodyText": "Mod initializers are run after vanilla registries have been bootstrapped.", "author": "Juuxel", "createdAt": "2020-04-22T10:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3MTEyNQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412871125", "bodyText": "Ah right, I will remove this", "author": "shedaniel", "createdAt": "2020-04-22T10:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2NTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2ODM5NQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412868395", "bodyText": "Why not put this code in the ShearsItem mixin?", "author": "immibis", "createdAt": "2020-04-22T10:36:10Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -48,7 +69,28 @@\n \t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n \t */\n \t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tfloat getMiningSpeedMultiplier(ItemStack stack, LivingEntity user);\n+\tdefault float getMiningSpeedMultiplier(ItemStack stack, LivingEntity user) {\n+\t\treturn this instanceof ToolItem ? ((ToolItem) this).getMaterial().getMiningSpeed() : 1f;\n+\t}\n+\n+\t/**\n+\t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n+\t *\n+\t * @param state The block to mine.\n+\t * @param stack The stack to check on.\n+\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t */\n+\t//TODO: nullable on user once we have an official @Nullable annotation in\n+\tdefault float getMiningSpeedMultiplier(BlockState state, ItemStack stack, LivingEntity user) {\n+\t\tif (this instanceof ShearsItem) {\n+\t\t\tBlock block = state.getBlock();\n+\t\t\tif (block == Blocks.COBWEB || state.matches(BlockTags.LEAVES)) return 15f;\n+\t\t\tif (state.matches(BlockTags.WOOL)) return 5f;\n+\t\t}", "originalCommit": "f406acf786eea94b7a65d77b1738a53838b8176a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3MDk3NQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412870975", "bodyText": "Done.", "author": "shedaniel", "createdAt": "2020-04-22T10:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg2ODM5NQ=="}], "type": "inlineReview"}, {"oid": "d988e0a056f4d13a93ac5e0b6e24ffa176f3b551", "url": "https://github.com/FabricMC/fabric/commit/d988e0a056f4d13a93ac5e0b6e24ffa176f3b551", "message": "Resolve some issues", "committedDate": "2020-04-22T10:42:21Z", "type": "commit"}, {"oid": "7b5d33beace6aff690db0f32deb7059f7045b3f2", "url": "https://github.com/FabricMC/fabric/commit/7b5d33beace6aff690db0f32deb7059f7045b3f2", "message": "Remove duplicate entries", "committedDate": "2020-04-22T10:51:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg3NzkxMg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412877912", "bodyText": "Add javadocs for the deprecation, maybe?", "author": "LemmaEOF", "createdAt": "2020-04-22T10:51:38Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -38,7 +40,23 @@\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n \t */\n \t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t@Deprecated", "originalCommit": "d988e0a056f4d13a93ac5e0b6e24ffa176f3b551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4MDA0Mg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412880042", "bodyText": "The ones necessary to keep here are all three types of pumpkin, melons, scaffolding, ladders and all wood buttons.", "author": "LemmaEOF", "createdAt": "2020-04-22T10:55:05Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/VanillaToolsSupport.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.Blocks;\n+import net.minecraft.block.Material;\n+import net.minecraft.item.Item;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+\n+public class VanillaToolsSupport implements ModInitializer {\n+\tprivate static final Logger LOGGER = LogManager.getLogger(\"fabric-tool-attribute-api-v1\");\n+\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tfor (Block block : Registry.BLOCK) {\n+\t\t\tregisterBlockSupport(Registry.BLOCK.getId(block), block);\n+\t\t}\n+\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 3, Blocks.OBSIDIAN);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 2, Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.EMERALD_ORE, Blocks.EMERALD_BLOCK, Blocks.GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.REDSTONE_ORE);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 1, Blocks.IRON_BLOCK, Blocks.IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 0, Blocks.ACTIVATOR_RAIL, Blocks.COAL_ORE, Blocks.COBBLESTONE, Blocks.DETECTOR_RAIL, Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.POWERED_RAIL, Blocks.GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.ICE, Blocks.IRON_BLOCK, Blocks.IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE, Blocks.MOSSY_COBBLESTONE, Blocks.NETHERRACK, Blocks.PACKED_ICE, Blocks.BLUE_ICE, Blocks.RAIL, Blocks.REDSTONE_ORE, Blocks.SANDSTONE, Blocks.CHISELED_SANDSTONE, Blocks.CUT_SANDSTONE, Blocks.CHISELED_RED_SANDSTONE, Blocks.CUT_RED_SANDSTONE, Blocks.RED_SANDSTONE, Blocks.STONE, Blocks.GRANITE, Blocks.POLISHED_GRANITE, Blocks.DIORITE, Blocks.POLISHED_DIORITE, Blocks.ANDESITE, Blocks.POLISHED_ANDESITE, Blocks.STONE_SLAB, Blocks.SMOOTH_STONE_SLAB, Blocks.SANDSTONE_SLAB, Blocks.PETRIFIED_OAK_SLAB, Blocks.COBBLESTONE_SLAB, Blocks.BRICK_SLAB, Blocks.STONE_BRICK_SLAB, Blocks.NETHER_BRICK_SLAB, Blocks.QUARTZ_SLAB, Blocks.RED_SANDSTONE_SLAB, Blocks.PURPUR_SLAB, Blocks.SMOOTH_QUARTZ, Blocks.SMOOTH_RED_SANDSTONE, Blocks.SMOOTH_SANDSTONE, Blocks.SMOOTH_STONE, Blocks.STONE_BUTTON, Blocks.STONE_PRESSURE_PLATE, Blocks.POLISHED_GRANITE_SLAB, Blocks.SMOOTH_RED_SANDSTONE_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.POLISHED_DIORITE_SLAB, Blocks.MOSSY_COBBLESTONE_SLAB, Blocks.END_STONE_BRICK_SLAB, Blocks.SMOOTH_SANDSTONE_SLAB, Blocks.SMOOTH_QUARTZ_SLAB, Blocks.GRANITE_SLAB, Blocks.ANDESITE_SLAB, Blocks.RED_NETHER_BRICK_SLAB, Blocks.POLISHED_ANDESITE_SLAB, Blocks.DIORITE_SLAB, Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX);\n+\n+\t\tregisterSupport(FabricToolTags.AXES, 0, Blocks.OAK_PLANKS, Blocks.SPRUCE_PLANKS, Blocks.BIRCH_PLANKS, Blocks.JUNGLE_PLANKS, Blocks.ACACIA_PLANKS, Blocks.DARK_OAK_PLANKS, Blocks.BOOKSHELF, Blocks.OAK_WOOD, Blocks.SPRUCE_WOOD, Blocks.BIRCH_WOOD, Blocks.JUNGLE_WOOD, Blocks.ACACIA_WOOD, Blocks.DARK_OAK_WOOD, Blocks.OAK_LOG, Blocks.SPRUCE_LOG, Blocks.BIRCH_LOG, Blocks.JUNGLE_LOG, Blocks.ACACIA_LOG, Blocks.DARK_OAK_LOG, Blocks.CHEST, Blocks.PUMPKIN, Blocks.CARVED_PUMPKIN, Blocks.JACK_O_LANTERN, Blocks.MELON, Blocks.LADDER, Blocks.SCAFFOLDING, Blocks.OAK_BUTTON, Blocks.SPRUCE_BUTTON, Blocks.BIRCH_BUTTON, Blocks.JUNGLE_BUTTON, Blocks.DARK_OAK_BUTTON, Blocks.ACACIA_BUTTON, Blocks.OAK_PRESSURE_PLATE, Blocks.SPRUCE_PRESSURE_PLATE, Blocks.BIRCH_PRESSURE_PLATE, Blocks.JUNGLE_PRESSURE_PLATE, Blocks.DARK_OAK_PRESSURE_PLATE, Blocks.ACACIA_PRESSURE_PLATE);", "originalCommit": "d988e0a056f4d13a93ac5e0b6e24ffa176f3b551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4MzE5NA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412883194", "bodyText": "We could probably trim this down a lot by having Material.EARTH and Material.SAND be supported materials for shovels. That'd cover everything except clay, grass, mycelium, snow and snow blocks. You've also got Blocks.SNOW and Blocks.SNOW_BLOCK in here twice.", "author": "LemmaEOF", "createdAt": "2020-04-22T11:00:18Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/VanillaToolsSupport.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.Blocks;\n+import net.minecraft.block.Material;\n+import net.minecraft.item.Item;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+\n+public class VanillaToolsSupport implements ModInitializer {\n+\tprivate static final Logger LOGGER = LogManager.getLogger(\"fabric-tool-attribute-api-v1\");\n+\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tfor (Block block : Registry.BLOCK) {\n+\t\t\tregisterBlockSupport(Registry.BLOCK.getId(block), block);\n+\t\t}\n+\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 3, Blocks.OBSIDIAN);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 2, Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.EMERALD_ORE, Blocks.EMERALD_BLOCK, Blocks.GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.REDSTONE_ORE);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 1, Blocks.IRON_BLOCK, Blocks.IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE);\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 0, Blocks.ACTIVATOR_RAIL, Blocks.COAL_ORE, Blocks.COBBLESTONE, Blocks.DETECTOR_RAIL, Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.POWERED_RAIL, Blocks.GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.ICE, Blocks.IRON_BLOCK, Blocks.IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE, Blocks.MOSSY_COBBLESTONE, Blocks.NETHERRACK, Blocks.PACKED_ICE, Blocks.BLUE_ICE, Blocks.RAIL, Blocks.REDSTONE_ORE, Blocks.SANDSTONE, Blocks.CHISELED_SANDSTONE, Blocks.CUT_SANDSTONE, Blocks.CHISELED_RED_SANDSTONE, Blocks.CUT_RED_SANDSTONE, Blocks.RED_SANDSTONE, Blocks.STONE, Blocks.GRANITE, Blocks.POLISHED_GRANITE, Blocks.DIORITE, Blocks.POLISHED_DIORITE, Blocks.ANDESITE, Blocks.POLISHED_ANDESITE, Blocks.STONE_SLAB, Blocks.SMOOTH_STONE_SLAB, Blocks.SANDSTONE_SLAB, Blocks.PETRIFIED_OAK_SLAB, Blocks.COBBLESTONE_SLAB, Blocks.BRICK_SLAB, Blocks.STONE_BRICK_SLAB, Blocks.NETHER_BRICK_SLAB, Blocks.QUARTZ_SLAB, Blocks.RED_SANDSTONE_SLAB, Blocks.PURPUR_SLAB, Blocks.SMOOTH_QUARTZ, Blocks.SMOOTH_RED_SANDSTONE, Blocks.SMOOTH_SANDSTONE, Blocks.SMOOTH_STONE, Blocks.STONE_BUTTON, Blocks.STONE_PRESSURE_PLATE, Blocks.POLISHED_GRANITE_SLAB, Blocks.SMOOTH_RED_SANDSTONE_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.POLISHED_DIORITE_SLAB, Blocks.MOSSY_COBBLESTONE_SLAB, Blocks.END_STONE_BRICK_SLAB, Blocks.SMOOTH_SANDSTONE_SLAB, Blocks.SMOOTH_QUARTZ_SLAB, Blocks.GRANITE_SLAB, Blocks.ANDESITE_SLAB, Blocks.RED_NETHER_BRICK_SLAB, Blocks.POLISHED_ANDESITE_SLAB, Blocks.DIORITE_SLAB, Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX);\n+\n+\t\tregisterSupport(FabricToolTags.AXES, 0, Blocks.OAK_PLANKS, Blocks.SPRUCE_PLANKS, Blocks.BIRCH_PLANKS, Blocks.JUNGLE_PLANKS, Blocks.ACACIA_PLANKS, Blocks.DARK_OAK_PLANKS, Blocks.BOOKSHELF, Blocks.OAK_WOOD, Blocks.SPRUCE_WOOD, Blocks.BIRCH_WOOD, Blocks.JUNGLE_WOOD, Blocks.ACACIA_WOOD, Blocks.DARK_OAK_WOOD, Blocks.OAK_LOG, Blocks.SPRUCE_LOG, Blocks.BIRCH_LOG, Blocks.JUNGLE_LOG, Blocks.ACACIA_LOG, Blocks.DARK_OAK_LOG, Blocks.CHEST, Blocks.PUMPKIN, Blocks.CARVED_PUMPKIN, Blocks.JACK_O_LANTERN, Blocks.MELON, Blocks.LADDER, Blocks.SCAFFOLDING, Blocks.OAK_BUTTON, Blocks.SPRUCE_BUTTON, Blocks.BIRCH_BUTTON, Blocks.JUNGLE_BUTTON, Blocks.DARK_OAK_BUTTON, Blocks.ACACIA_BUTTON, Blocks.OAK_PRESSURE_PLATE, Blocks.SPRUCE_PRESSURE_PLATE, Blocks.BIRCH_PRESSURE_PLATE, Blocks.JUNGLE_PRESSURE_PLATE, Blocks.DARK_OAK_PRESSURE_PLATE, Blocks.ACACIA_PRESSURE_PLATE);\n+\n+\t\tregisterSupport(FabricToolTags.SHOVELS, 0, Blocks.CLAY, Blocks.DIRT, Blocks.COARSE_DIRT, Blocks.PODZOL, Blocks.FARMLAND, Blocks.GRASS_BLOCK, Blocks.GRAVEL, Blocks.MYCELIUM, Blocks.SAND, Blocks.RED_SAND, Blocks.SNOW_BLOCK, Blocks.SNOW, Blocks.SOUL_SAND, Blocks.GRASS_PATH, Blocks.WHITE_CONCRETE_POWDER, Blocks.ORANGE_CONCRETE_POWDER, Blocks.MAGENTA_CONCRETE_POWDER, Blocks.LIGHT_BLUE_CONCRETE_POWDER, Blocks.YELLOW_CONCRETE_POWDER, Blocks.LIME_CONCRETE_POWDER, Blocks.PINK_CONCRETE_POWDER, Blocks.GRAY_CONCRETE_POWDER, Blocks.LIGHT_GRAY_CONCRETE_POWDER, Blocks.CYAN_CONCRETE_POWDER, Blocks.PURPLE_CONCRETE_POWDER, Blocks.BLUE_CONCRETE_POWDER, Blocks.BROWN_CONCRETE_POWDER, Blocks.GREEN_CONCRETE_POWDER, Blocks.RED_CONCRETE_POWDER, Blocks.BLACK_CONCRETE_POWDER, Blocks.SNOW, Blocks.SNOW_BLOCK);", "originalCommit": "d988e0a056f4d13a93ac5e0b6e24ffa176f3b551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwOTgyMA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412909820", "bodyText": "this seems un-maintainable tbh", "author": "modmuss50", "createdAt": "2020-04-22T11:45:28Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/VanillaToolsSupport.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.Blocks;\n+import net.minecraft.block.Material;\n+import net.minecraft.item.Item;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.Identifier;\n+import net.minecraft.util.registry.Registry;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+\n+public class VanillaToolsSupport implements ModInitializer {\n+\tprivate static final Logger LOGGER = LogManager.getLogger(\"fabric-tool-attribute-api-v1\");\n+\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tfor (Block block : Registry.BLOCK) {\n+\t\t\tregisterBlockSupport(Registry.BLOCK.getId(block), block);\n+\t\t}\n+\n+\t\tregisterSupport(FabricToolTags.PICKAXES, 3, Blocks.OBSIDIAN);", "originalCommit": "7b5d33beace6aff690db0f32deb7059f7045b3f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkxODgxNg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412918816", "bodyText": "The list looks rather arbitrary to me, why not use net.minecraft.item.AxeItem.EFFECTIVE_BLOCKS etc?", "author": "sfPlayer1", "createdAt": "2020-04-22T12:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwOTgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyMTQwOQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412921409", "bodyText": "Actually true, we still need to hardcode the blocks with special mining levels though", "author": "shedaniel", "createdAt": "2020-04-22T12:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwOTgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxODg1MA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r413218850", "bodyText": "@modmuss50 that's the thing - Mojang's system of hardcoding block mining levels and effectivenesses is fundamentally unmaintainable. We're doing what we can to work around it but if Mojang hardcodes it we have to too.", "author": "LemmaEOF", "createdAt": "2020-04-22T18:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwOTgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMDE2NA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r413220164", "bodyText": "We now work around this by using tool handlers, check the latest code and you will see that this is basically completely different", "author": "shedaniel", "createdAt": "2020-04-22T18:29:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwOTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkxMjAxNQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r412912015", "bodyText": "TODO isnt really right for this. just a comment.", "author": "modmuss50", "createdAt": "2020-04-22T11:49:13Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -38,7 +40,23 @@\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n \t */\n \t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, LivingEntity user) {\n+\t\treturn this instanceof ToolItem ? ((ToolItem) this).getMaterial().getMiningLevel() : 0;\n+\t}\n+\n+\t/**\n+\t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n+\t *\n+\t * @param state The block to mine.\n+\t * @param stack The stack to check on.\n+\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t */\n+\t//TODO: nullable on user once we have an official @Nullable annotation in", "originalCommit": "7b5d33beace6aff690db0f32deb7059f7045b3f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "69c2917e8a553f4a34f86c9c704eb9ce470e9be8", "url": "https://github.com/FabricMC/fabric/commit/69c2917e8a553f4a34f86c9c704eb9ce470e9be8", "message": "maybe?", "committedDate": "2020-04-22T14:05:26Z", "type": "commit"}, {"oid": "abd6ab7497bf30650cf1ba4a4c194cea06c6a5b8", "url": "https://github.com/FabricMC/fabric/commit/abd6ab7497bf30650cf1ba4a4c194cea06c6a5b8", "message": "fix max breaking speed", "committedDate": "2020-04-22T14:56:19Z", "type": "commit"}, {"oid": "c5d183a1b79e352852e7f83201e3538a403d3ec7", "url": "https://github.com/FabricMC/fabric/commit/c5d183a1b79e352852e7f83201e3538a403d3ec7", "message": "choose an item that is the closest", "committedDate": "2020-04-22T15:13:47Z", "type": "commit"}, {"oid": "ac5595297f5c2b56753ddb23532aa9b905b6507a", "url": "https://github.com/FabricMC/fabric/commit/ac5595297f5c2b56753ddb23532aa9b905b6507a", "message": "Set version to 1.1", "committedDate": "2020-04-22T15:14:36Z", "type": "commit"}, {"oid": "c59882c0761fb28befd990e4f973ddd1a4d5441b", "url": "https://github.com/FabricMC/fabric/commit/c59882c0761fb28befd990e4f973ddd1a4d5441b", "message": "better docs remove stuff", "committedDate": "2020-04-22T15:23:57Z", "type": "commit"}, {"oid": "08da3a080c24e77a31effe7213af542bb82e6036", "url": "https://github.com/FabricMC/fabric/commit/08da3a080c24e77a31effe7213af542bb82e6036", "message": "Merge remote-tracking branch 'fabric/1.15' into patch-1.15\n\n# Conflicts:\n#\tfabric-tool-attribute-api-v1/build.gradle\n#\tfabric-tool-attribute-api-v1/src/main/resources/fabric-tool-attribute-api-v1.mixins.json", "committedDate": "2020-04-22T15:24:16Z", "type": "commit"}, {"oid": "6a049ae61a7c9335b566f58d2b16026273ac3ef0", "url": "https://github.com/FabricMC/fabric/commit/6a049ae61a7c9335b566f58d2b16026273ac3ef0", "message": "deprecation doc and no todo comments", "committedDate": "2020-04-22T15:29:44Z", "type": "commit"}, {"oid": "5773ff834c1507b1f8a4142e8aa32753fe3a541e", "url": "https://github.com/FabricMC/fabric/commit/5773ff834c1507b1f8a4142e8aa32753fe3a541e", "message": "Check if block has valid mining level", "committedDate": "2020-04-22T16:59:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMTIwNA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r413221204", "bodyText": "Now that these are publicly exposed, they're definitely going to need javadocs.", "author": "LemmaEOF", "createdAt": "2020-04-22T18:31:29Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/ToolManager.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package net.fabricmc.fabric.api.tool.attribute.v1;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+public final class ToolManager {", "originalCommit": "5773ff834c1507b1f8a4142e8aa32753fe3a541e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMjI0Mw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r413222243", "bodyText": "I hope this won't mean that every mod needs to register events for all their tools?", "author": "LemmaEOF", "createdAt": "2020-04-22T18:32:58Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/ToolManager.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package net.fabricmc.fabric.api.tool.attribute.v1;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+public final class ToolManager {\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\treturn ToolManagerImpl.tag(tag);\n+\t}\n+\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn ToolManagerImpl.general();\n+\t}\n+\n+\tpublic static TriState handleIsEffectiveOn(ItemStack stack, BlockState state, LivingEntity user) {\n+\t\treturn ToolManagerImpl.handleIsEffectiveOn(stack, state, user);\n+\t}\n+\n+\tpublic static float handleBreakingSpeed(ItemStack stack, BlockState state, LivingEntity user) {\n+\t\treturn ToolManagerImpl.handleBreakingSpeed(stack, state, user);\n+\t}\n+\n+\tprivate ToolManager() {\n+\t}\n+\n+\tpublic interface ToolHandler {", "originalCommit": "5773ff834c1507b1f8a4142e8aa32753fe3a541e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIzNTI3Mg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r413235272", "bodyText": "nope, ideally you don't even need to touch this callback, I have thought of keeping this callback internal, but have decided to leave it open in case someone adds a new tool type that is completely separate from vanilla", "author": "shedaniel", "createdAt": "2020-04-22T18:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMjI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIzNTkyNA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r413235924", "bodyText": "alright, sounds good.", "author": "LemmaEOF", "createdAt": "2020-04-22T18:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyMjI0Mw=="}], "type": "inlineReview"}, {"oid": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "url": "https://github.com/FabricMC/fabric/commit/5b1ab1596b668b623f1c6261a948b936fdac7b6a", "message": "javadocs", "committedDate": "2020-04-23T01:42:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1ODA2Mw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414558063", "bodyText": "The parameter order here differs from DynamicAttributeTool", "author": "sfPlayer1", "createdAt": "2020-04-24T13:02:14Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/ToolManager.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package net.fabricmc.fabric.api.tool.attribute.v1;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+/**\n+ * API facing part to register tool handlers and get information about how tools are handled.\n+ */\n+public final class ToolManager {\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\treturn ToolManagerImpl.tag(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn ToolManagerImpl.general();\n+\t}\n+\n+\t/**\n+\t * Handles if the tool is effective on a block.\n+\t *\n+\t * @param stack the item stack involved with breaking the block\n+\t * @param state the block state to break\n+\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t * @return the state of effective\n+\t */\n+\tpublic static TriState handleIsEffectiveOn(ItemStack stack, BlockState state, LivingEntity user) {\n+\t\treturn ToolManagerImpl.handleIsEffectiveOn(stack, state, user);\n+\t}\n+\n+\t/**\n+\t * Handles the breaking speed breaking a block.\n+\t *\n+\t * @param stack the item stack involved with breaking the block\n+\t * @param state the block state to break\n+\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t * @return the speed multiplier in breaking the block, 1.0 if no change.\n+\t */\n+\tpublic static float handleBreakingSpeed(ItemStack stack, BlockState state, LivingEntity user) {\n+\t\treturn ToolManagerImpl.handleBreakingSpeed(stack, state, user);\n+\t}\n+\n+\tprivate ToolManager() {\n+\t}\n+\n+\t/**\n+\t * The handler to handle tool speed and effectiveness.\n+\t *\n+\t * @see net.fabricmc.fabric.impl.tool.attribute.ToolHandlers for default handlers.\n+\t */\n+\tpublic interface ToolHandler {\n+\t\t/**\n+\t\t * Determines whether this handler is active and effective of the tools.\n+\t\t *\n+\t\t * @param tag   the tag involved\n+\t\t * @param stack the item stack breaking the block\n+\t\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t\t * @param state the block state to break\n+\t\t * @return the result of effectiveness\n+\t\t */\n+\t\tdefault ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1ODUwMw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414558503", "bodyText": "Same order issue, not sure if Float is a good choice vs TypedActionResult or what it was called?", "author": "sfPlayer1", "createdAt": "2020-04-24T13:03:06Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/ToolManager.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package net.fabricmc.fabric.api.tool.attribute.v1;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+/**\n+ * API facing part to register tool handlers and get information about how tools are handled.\n+ */\n+public final class ToolManager {\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\treturn ToolManagerImpl.tag(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn ToolManagerImpl.general();\n+\t}\n+\n+\t/**\n+\t * Handles if the tool is effective on a block.\n+\t *\n+\t * @param stack the item stack involved with breaking the block\n+\t * @param state the block state to break\n+\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t * @return the state of effective\n+\t */\n+\tpublic static TriState handleIsEffectiveOn(ItemStack stack, BlockState state, LivingEntity user) {\n+\t\treturn ToolManagerImpl.handleIsEffectiveOn(stack, state, user);\n+\t}\n+\n+\t/**\n+\t * Handles the breaking speed breaking a block.\n+\t *\n+\t * @param stack the item stack involved with breaking the block\n+\t * @param state the block state to break\n+\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t * @return the speed multiplier in breaking the block, 1.0 if no change.\n+\t */\n+\tpublic static float handleBreakingSpeed(ItemStack stack, BlockState state, LivingEntity user) {\n+\t\treturn ToolManagerImpl.handleBreakingSpeed(stack, state, user);\n+\t}\n+\n+\tprivate ToolManager() {\n+\t}\n+\n+\t/**\n+\t * The handler to handle tool speed and effectiveness.\n+\t *\n+\t * @see net.fabricmc.fabric.impl.tool.attribute.ToolHandlers for default handlers.\n+\t */\n+\tpublic interface ToolHandler {\n+\t\t/**\n+\t\t * Determines whether this handler is active and effective of the tools.\n+\t\t *\n+\t\t * @param tag   the tag involved\n+\t\t * @param stack the item stack breaking the block\n+\t\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t\t * @param state the block state to break\n+\t\t * @return the result of effectiveness\n+\t\t */\n+\t\tdefault ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\treturn ActionResult.PASS;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Determines the mining speed multiplier of the tools.\n+\t\t *\n+\t\t * @param tag   the tag involved\n+\t\t * @param stack the item stack breaking the block\n+\t\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t\t * @param state the block state to break\n+\t\t * @return the result of mining speed, null if pass.\n+\t\t */\n+\t\tdefault Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1ODkyMA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414558920", "bodyText": "If my two comments below are viable, we should be able to use plain vanilla item instances directly besides removing quite some code.", "author": "sfPlayer1", "createdAt": "2020-04-24T13:03:48Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolHandlers.java", "diffHunk": "@@ -0,0 +1,343 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.HoeItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PickaxeItem;\n+import net.minecraft.item.ShearsItem;\n+import net.minecraft.item.ShovelItem;\n+import net.minecraft.item.SwordItem;\n+import net.minecraft.item.ToolItem;\n+import net.minecraft.item.ToolMaterial;\n+import net.minecraft.item.ToolMaterials;\n+import net.minecraft.recipe.Ingredient;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+import net.fabricmc.fabric.api.tool.attribute.v1.ToolManager;\n+import net.fabricmc.fabric.mixin.tool.attribute.MiningToolItemAccessor;\n+import net.fabricmc.fabric.mixin.tool.attribute.ToolItemAccessor;\n+\n+/**\n+ * Entrypoint to register the default tool handlers.\n+ */\n+public class ToolHandlers implements ModInitializer {\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tToolManager.general().register(new ModdedToolsModdedBlocksToolHandler());\n+\t\tToolManager.general().register(new VanillaToolsModdedBlocksToolHandler());\n+\t\tToolManager.general().register(new VanillaToolsVanillaBlocksToolHandler());\n+\t\tToolManager.tag(FabricToolTags.PICKAXES).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.WOOD),", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNDQxNg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414704416", "bodyText": "I have changed this to use vanilla tools, only changing the material if needed. Don't know if this is a good approach.", "author": "shedaniel", "createdAt": "2020-04-24T16:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1ODkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk4OTE4NQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414989185", "bodyText": "This is not feasible since it is changing global state in a multi-threaded environment, causing e.g. integrated server behavior to change while the client thread mines something. Changing material or mining level parameters would first have to be removed.", "author": "sfPlayer1", "createdAt": "2020-04-25T05:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1ODkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2MTc5MQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414561791", "bodyText": "Messing with the material shouldn't be really necessary anymore, I'd rely on the retrieved vanilla tool as is. Vanilla shouldn't have any blocks that are incompatible with its own tools (=materials)", "author": "sfPlayer1", "createdAt": "2020-04-24T13:08:14Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolHandlers.java", "diffHunk": "@@ -0,0 +1,343 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.HoeItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PickaxeItem;\n+import net.minecraft.item.ShearsItem;\n+import net.minecraft.item.ShovelItem;\n+import net.minecraft.item.SwordItem;\n+import net.minecraft.item.ToolItem;\n+import net.minecraft.item.ToolMaterial;\n+import net.minecraft.item.ToolMaterials;\n+import net.minecraft.recipe.Ingredient;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+import net.fabricmc.fabric.api.tool.attribute.v1.ToolManager;\n+import net.fabricmc.fabric.mixin.tool.attribute.MiningToolItemAccessor;\n+import net.fabricmc.fabric.mixin.tool.attribute.ToolItemAccessor;\n+\n+/**\n+ * Entrypoint to register the default tool handlers.\n+ */\n+public class ToolHandlers implements ModInitializer {\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tToolManager.general().register(new ModdedToolsModdedBlocksToolHandler());\n+\t\tToolManager.general().register(new VanillaToolsModdedBlocksToolHandler());\n+\t\tToolManager.general().register(new VanillaToolsVanillaBlocksToolHandler());\n+\t\tToolManager.tag(FabricToolTags.PICKAXES).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.AXES).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.SHOVELS).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.HOES).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.SWORDS).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateSword(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateSword(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateSword(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateSword(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.SHEARS).register(new ShearsVanillaBlocksToolHandler());\n+\t}\n+\n+\tprivate ToolItem createPickaxe(ToolMaterial material) {\n+\t\treturn new DummyPickaxeItem(material, 1, -2.8F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createAxe(ToolMaterial material) {\n+\t\treturn new DummyAxeItem(material, 6.0F, -3.2F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createShovel(ToolMaterial material) {\n+\t\treturn new ShovelItem(material, 1.5F, -3.0F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createHoe(ToolMaterial material) {\n+\t\treturn new HoeItem(material, -2.0F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createSword(ToolMaterial material) {\n+\t\treturn new SwordItem(material, 3, -2.4F, new Item.Settings());\n+\t}\n+\n+\tprivate static class DummyPickaxeItem extends PickaxeItem {\n+\t\tprivate DummyPickaxeItem(ToolMaterial material, int attackDamage, float attackSpeed, Settings settings) {\n+\t\t\tsuper(material, attackDamage, attackSpeed, settings);\n+\t\t}\n+\t}\n+\n+\tprivate static class DummyAxeItem extends AxeItem {\n+\t\tprivate DummyAxeItem(ToolMaterial material, float attackDamage, float attackSpeed, Settings settings) {\n+\t\t\tsuper(material, attackDamage, attackSpeed, settings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are an subclass of {@link DynamicAttributeTool} by comparing their mining level\n+\t * using {@link DynamicAttributeTool#getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} and the block mining level.\n+\t *\n+\t * <p>Only applicable to modded blocks that are registered, as only they have the registered required mining level.</p>\n+\t */\n+\tprivate static class ModdedToolsModdedBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\t\tToolManagerImpl.Entry entry = ToolManagerImpl.entryNullable(state.getBlock());\n+\n+\t\t\t\tif (entry != null) {\n+\t\t\t\t\tint miningLevel = ((DynamicAttributeTool) stack.getItem()).getMiningLevel(tag, state, stack, user);\n+\t\t\t\t\tint requiredMiningLevel = entry.getMiningLevel(tag);\n+\n+\t\t\t\t\tif (requiredMiningLevel >= 0 && miningLevel >= requiredMiningLevel) {\n+\t\t\t\t\t\treturn ActionResult.SUCCESS;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn ActionResult.PASS;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\t\tfloat multiplier = ((DynamicAttributeTool) stack.getItem()).getMiningSpeedMultiplier(tag, state, stack, user);\n+\t\t\t\tif (multiplier != 1f) return multiplier;\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are not a subclass of {@link DynamicAttributeTool} by\n+\t * comparing their mining level using {@link ToolMaterial#getMiningLevel()} and the block mining level.\n+\t *\n+\t * <p>Only applicable to modded blocks that are registered, as only they have the registered required mining level.</p>\n+\t */\n+\tprivate static class VanillaToolsModdedBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (!(stack.getItem() instanceof DynamicAttributeTool)) {\n+\t\t\t\tToolManagerImpl.Entry entry = ToolManagerImpl.entryNullable(state.getBlock());\n+\n+\t\t\t\tif (entry != null) {\n+\t\t\t\t\tint miningLevel = stack.getItem() instanceof ToolItem ? ((ToolItem) stack.getItem()).getMaterial().getMiningLevel() : 0;\n+\t\t\t\t\tint requiredMiningLevel = entry.getMiningLevel(tag);\n+\n+\t\t\t\t\tif (requiredMiningLevel >= 0 && miningLevel >= requiredMiningLevel) {\n+\t\t\t\t\t\treturn ActionResult.SUCCESS;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn ActionResult.PASS;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (!(stack.getItem() instanceof DynamicAttributeTool)) {\n+\t\t\t\tfloat multiplier = stack.getItem().getMiningSpeed(stack, state);\n+\t\t\t\tif (multiplier != 1f) return multiplier;\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are not a subclass of {@link DynamicAttributeTool} by\n+\t * using the vanilla {@link Item#isEffectiveOn(BlockState)}.\n+\t *\n+\t * <p>Only applicable to blocks that are vanilla or share the material that is handled by their vanilla tool.</p>\n+\t */\n+\tprivate static class VanillaToolsVanillaBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\treturn !(stack.getItem() instanceof DynamicAttributeTool) && (stack.getItem().isEffectiveOn(state) || stack.getItem().getMiningSpeed(stack, state) != 1f) ? ActionResult.SUCCESS : ActionResult.PASS;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (!(stack.getItem() instanceof DynamicAttributeTool)) {\n+\t\t\t\tfloat miningSpeed = stack.getItem().getMiningSpeed(stack, state);\n+\n+\t\t\t\tif (miningSpeed != 1f) {\n+\t\t\t\t\treturn miningSpeed;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are a subclass of {@link DynamicAttributeTool} by using the\n+\t * vanilla {@link Item#isEffectiveOn(BlockState)} with a custom fake tool material to use the mining level\n+\t * from {@link DynamicAttributeTool#getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)}.\n+\t *\n+\t * <p>Only applicable to blocks that are vanilla or share the material that is handled by their vanilla tool.</p>\n+\t */\n+\tprivate static class ModdedMiningToolsVanillaBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\tprivate final FakeAdaptableToolMaterial fakeMaterial = new FakeAdaptableToolMaterial();\n+\t\tprivate final ImmutableList<ToolItem> vanillaItems;\n+\n+\t\tprivate ModdedMiningToolsVanillaBlocksToolHandler(ImmutableList<ToolItem> vanillaItems) {\n+\t\t\tthis.vanillaItems = vanillaItems;\n+\t\t}\n+\n+\t\tprivate ToolItem getVanillaItem(int miningLevel) {\n+\t\t\tif (miningLevel < 0) return vanillaItems.get(0);\n+\t\t\tif (miningLevel >= vanillaItems.size()) return vanillaItems.get(vanillaItems.size() - 1);\n+\t\t\treturn vanillaItems.get(miningLevel);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\t\tint miningLevel = ((DynamicAttributeTool) stack.getItem()).getMiningLevel(tag, state, stack, user);\n+\t\t\t\tif (miningLevel < 0) return ActionResult.PASS;\n+\t\t\t\tToolItem vanillaItem = getVanillaItem(miningLevel);\n+\t\t\t\tToolMaterial tempMaterial = vanillaItem.getMaterial();", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyNTM2NA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414625364", "bodyText": "What if we have tools that have mining levels outside 0 to 3? Or larger than level 1 axes?", "author": "shedaniel", "createdAt": "2020-04-24T14:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2MTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk4ODg3Mw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414988873", "bodyText": "The next-best vanilla tool should suffice for vanilla blocks unless I am missing something. Even if the modded tool has level 20, a vanilla diamond tool should still be just as effective considering vanilla won't have level 20 blocks but at worst obsidian.", "author": "sfPlayer1", "createdAt": "2020-04-25T05:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2MTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA1MTIyOA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r415051228", "bodyText": "True, I can do that for vanilla blocks", "author": "shedaniel", "createdAt": "2020-04-25T12:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2MTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NjQ3OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414566479", "bodyText": "Is it really needed to go through the vanilla item again? May a pure effectiveness check as above suffice? If not, can't the return value from the unbiased vanilla tool be analyzed and then adjusted for the desired new speed, potentially with some hardcoded values?", "author": "sfPlayer1", "createdAt": "2020-04-24T13:15:09Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolHandlers.java", "diffHunk": "@@ -0,0 +1,343 @@\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.AxeItem;\n+import net.minecraft.item.HoeItem;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.PickaxeItem;\n+import net.minecraft.item.ShearsItem;\n+import net.minecraft.item.ShovelItem;\n+import net.minecraft.item.SwordItem;\n+import net.minecraft.item.ToolItem;\n+import net.minecraft.item.ToolMaterial;\n+import net.minecraft.item.ToolMaterials;\n+import net.minecraft.recipe.Ingredient;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+import net.fabricmc.fabric.api.tool.attribute.v1.ToolManager;\n+import net.fabricmc.fabric.mixin.tool.attribute.MiningToolItemAccessor;\n+import net.fabricmc.fabric.mixin.tool.attribute.ToolItemAccessor;\n+\n+/**\n+ * Entrypoint to register the default tool handlers.\n+ */\n+public class ToolHandlers implements ModInitializer {\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tToolManager.general().register(new ModdedToolsModdedBlocksToolHandler());\n+\t\tToolManager.general().register(new VanillaToolsModdedBlocksToolHandler());\n+\t\tToolManager.general().register(new VanillaToolsVanillaBlocksToolHandler());\n+\t\tToolManager.tag(FabricToolTags.PICKAXES).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreatePickaxe(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.AXES).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateAxe(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.SHOVELS).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateShovel(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.HOES).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateHoe(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.SWORDS).register(new ModdedMiningToolsVanillaBlocksToolHandler(\n+\t\t\t\tImmutableList.of(\n+\t\t\t\t\t\tcreateSword(ToolMaterials.WOOD),\n+\t\t\t\t\t\tcreateSword(ToolMaterials.STONE),\n+\t\t\t\t\t\tcreateSword(ToolMaterials.IRON),\n+\t\t\t\t\t\tcreateSword(ToolMaterials.DIAMOND)\n+\t\t\t\t)\n+\t\t));\n+\t\tToolManager.tag(FabricToolTags.SHEARS).register(new ShearsVanillaBlocksToolHandler());\n+\t}\n+\n+\tprivate ToolItem createPickaxe(ToolMaterial material) {\n+\t\treturn new DummyPickaxeItem(material, 1, -2.8F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createAxe(ToolMaterial material) {\n+\t\treturn new DummyAxeItem(material, 6.0F, -3.2F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createShovel(ToolMaterial material) {\n+\t\treturn new ShovelItem(material, 1.5F, -3.0F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createHoe(ToolMaterial material) {\n+\t\treturn new HoeItem(material, -2.0F, new Item.Settings());\n+\t}\n+\n+\tprivate ToolItem createSword(ToolMaterial material) {\n+\t\treturn new SwordItem(material, 3, -2.4F, new Item.Settings());\n+\t}\n+\n+\tprivate static class DummyPickaxeItem extends PickaxeItem {\n+\t\tprivate DummyPickaxeItem(ToolMaterial material, int attackDamage, float attackSpeed, Settings settings) {\n+\t\t\tsuper(material, attackDamage, attackSpeed, settings);\n+\t\t}\n+\t}\n+\n+\tprivate static class DummyAxeItem extends AxeItem {\n+\t\tprivate DummyAxeItem(ToolMaterial material, float attackDamage, float attackSpeed, Settings settings) {\n+\t\t\tsuper(material, attackDamage, attackSpeed, settings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are an subclass of {@link DynamicAttributeTool} by comparing their mining level\n+\t * using {@link DynamicAttributeTool#getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} and the block mining level.\n+\t *\n+\t * <p>Only applicable to modded blocks that are registered, as only they have the registered required mining level.</p>\n+\t */\n+\tprivate static class ModdedToolsModdedBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\t\tToolManagerImpl.Entry entry = ToolManagerImpl.entryNullable(state.getBlock());\n+\n+\t\t\t\tif (entry != null) {\n+\t\t\t\t\tint miningLevel = ((DynamicAttributeTool) stack.getItem()).getMiningLevel(tag, state, stack, user);\n+\t\t\t\t\tint requiredMiningLevel = entry.getMiningLevel(tag);\n+\n+\t\t\t\t\tif (requiredMiningLevel >= 0 && miningLevel >= requiredMiningLevel) {\n+\t\t\t\t\t\treturn ActionResult.SUCCESS;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn ActionResult.PASS;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\t\tfloat multiplier = ((DynamicAttributeTool) stack.getItem()).getMiningSpeedMultiplier(tag, state, stack, user);\n+\t\t\t\tif (multiplier != 1f) return multiplier;\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are not a subclass of {@link DynamicAttributeTool} by\n+\t * comparing their mining level using {@link ToolMaterial#getMiningLevel()} and the block mining level.\n+\t *\n+\t * <p>Only applicable to modded blocks that are registered, as only they have the registered required mining level.</p>\n+\t */\n+\tprivate static class VanillaToolsModdedBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (!(stack.getItem() instanceof DynamicAttributeTool)) {\n+\t\t\t\tToolManagerImpl.Entry entry = ToolManagerImpl.entryNullable(state.getBlock());\n+\n+\t\t\t\tif (entry != null) {\n+\t\t\t\t\tint miningLevel = stack.getItem() instanceof ToolItem ? ((ToolItem) stack.getItem()).getMaterial().getMiningLevel() : 0;\n+\t\t\t\t\tint requiredMiningLevel = entry.getMiningLevel(tag);\n+\n+\t\t\t\t\tif (requiredMiningLevel >= 0 && miningLevel >= requiredMiningLevel) {\n+\t\t\t\t\t\treturn ActionResult.SUCCESS;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn ActionResult.PASS;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (!(stack.getItem() instanceof DynamicAttributeTool)) {\n+\t\t\t\tfloat multiplier = stack.getItem().getMiningSpeed(stack, state);\n+\t\t\t\tif (multiplier != 1f) return multiplier;\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are not a subclass of {@link DynamicAttributeTool} by\n+\t * using the vanilla {@link Item#isEffectiveOn(BlockState)}.\n+\t *\n+\t * <p>Only applicable to blocks that are vanilla or share the material that is handled by their vanilla tool.</p>\n+\t */\n+\tprivate static class VanillaToolsVanillaBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\treturn !(stack.getItem() instanceof DynamicAttributeTool) && (stack.getItem().isEffectiveOn(state) || stack.getItem().getMiningSpeed(stack, state) != 1f) ? ActionResult.SUCCESS : ActionResult.PASS;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (!(stack.getItem() instanceof DynamicAttributeTool)) {\n+\t\t\t\tfloat miningSpeed = stack.getItem().getMiningSpeed(stack, state);\n+\n+\t\t\t\tif (miningSpeed != 1f) {\n+\t\t\t\t\treturn miningSpeed;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This handler handles items that are a subclass of {@link DynamicAttributeTool} by using the\n+\t * vanilla {@link Item#isEffectiveOn(BlockState)} with a custom fake tool material to use the mining level\n+\t * from {@link DynamicAttributeTool#getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)}.\n+\t *\n+\t * <p>Only applicable to blocks that are vanilla or share the material that is handled by their vanilla tool.</p>\n+\t */\n+\tprivate static class ModdedMiningToolsVanillaBlocksToolHandler implements ToolManager.ToolHandler {\n+\t\tprivate final FakeAdaptableToolMaterial fakeMaterial = new FakeAdaptableToolMaterial();\n+\t\tprivate final ImmutableList<ToolItem> vanillaItems;\n+\n+\t\tprivate ModdedMiningToolsVanillaBlocksToolHandler(ImmutableList<ToolItem> vanillaItems) {\n+\t\t\tthis.vanillaItems = vanillaItems;\n+\t\t}\n+\n+\t\tprivate ToolItem getVanillaItem(int miningLevel) {\n+\t\t\tif (miningLevel < 0) return vanillaItems.get(0);\n+\t\t\tif (miningLevel >= vanillaItems.size()) return vanillaItems.get(vanillaItems.size() - 1);\n+\t\t\treturn vanillaItems.get(miningLevel);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\t\tint miningLevel = ((DynamicAttributeTool) stack.getItem()).getMiningLevel(tag, state, stack, user);\n+\t\t\t\tif (miningLevel < 0) return ActionResult.PASS;\n+\t\t\t\tToolItem vanillaItem = getVanillaItem(miningLevel);\n+\t\t\t\tToolMaterial tempMaterial = vanillaItem.getMaterial();\n+\t\t\t\tfakeMaterial.miningLevel = miningLevel;\n+\t\t\t\t((ToolItemAccessor) vanillaItem).setMaterial(fakeMaterial);\n+\t\t\t\tboolean effective = vanillaItem.isEffectiveOn(state) || vanillaItem.getMiningSpeed(new ItemStack(vanillaItem), state) != 1f;\n+\t\t\t\t((ToolItemAccessor) vanillaItem).setMaterial(tempMaterial);\n+\t\t\t\treturn effective ? ActionResult.SUCCESS : ActionResult.PASS;\n+\t\t\t}\n+\n+\t\t\treturn ActionResult.PASS;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Float getMiningSpeedMultiplier(Tag<Item> tag, ItemStack stack, LivingEntity user, BlockState state) {\n+\t\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\t\tint miningLevel = ((DynamicAttributeTool) stack.getItem()).getMiningLevel(tag, state, stack, user);\n+\t\t\t\tif (miningLevel < 0) return null;\n+\t\t\t\tItem vanillaItem = getVanillaItem(miningLevel);\n+\t\t\t\tfloat tempMiningSpeed = ((MiningToolItemAccessor) vanillaItem).getMiningSpeed();\n+\t\t\t\t((MiningToolItemAccessor) vanillaItem).setMiningSpeed(((DynamicAttributeTool) stack.getItem()).getMiningSpeedMultiplier(tag, state, stack, user));\n+\t\t\t\tfloat miningSpeed = vanillaItem.getMiningSpeed(stack, state);\n+\t\t\t\t((MiningToolItemAccessor) vanillaItem).setMiningSpeed(tempMiningSpeed);", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MTIyMw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414661223", "bodyText": "Also some spacing in that method please, it's stuffed to the brim", "author": "i509VCB", "createdAt": "2020-04-24T15:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5OTE1MQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414699151", "bodyText": "Don't think we can adjust according to vanilla, for example, swords have constant speed on cobweb no matter the speed of the tool material.", "author": "shedaniel", "createdAt": "2020-04-24T16:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MDAzMA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414990030", "bodyText": "These exceptions may be worth hardcoding if it saves us from all the tool manipulation trickery. Maybe first comparing two vanilla tools (like diamond vs iron) to each other is sufficient to test and observe special behavior.", "author": "sfPlayer1", "createdAt": "2020-04-25T05:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA1MjQ4OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r415052489", "bodyText": "In some cases, it should be impossible to compare with two vanilla tools, for example obsidian, it is impossible to have two tools to compare with (in 1.15 anyway), for other levels it should be easy.", "author": "shedaniel", "createdAt": "2020-04-25T12:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2Njg5Ng==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414566896", "bodyText": "Can this use IdentityHashMap?", "author": "sfPlayer1", "createdAt": "2020-04-24T13:15:46Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.ToolManager;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t//noinspection unchecked\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolManager.ToolHandler>> HANDLER_MAP = new HashMap<>();", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5MjE5OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414692199", "bodyText": "Why? Tags with the same identifier are supposed to use the same handler.", "author": "shedaniel", "createdAt": "2020-04-24T16:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2Njg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MDQ3Ng==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414990476", "bodyText": "I didn't quite remember how we obtained tags, they are not using identity behavior so it can't use IdentityHashMap.", "author": "sfPlayer1", "createdAt": "2020-04-25T06:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2Njg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTIyOA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414991228", "bodyText": "Using IdentityHashMap might also not be super future-proof, given the big tag changes coming in 1.16.", "author": "LemmaEOF", "createdAt": "2020-04-25T06:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2Njg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NzE4OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414567189", "bodyText": "construction prevention in non-api is superfluous", "author": "sfPlayer1", "createdAt": "2020-04-24T13:16:10Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.ToolManager;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t//noinspection unchecked\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolManager.ToolHandler>> HANDLER_MAP = new HashMap<>();\n+\tprivate static final Event<ToolManager.ToolHandler> GENERAL_TOOLS_HANDLER = EventFactory.createArrayBacked(ToolManager.ToolHandler.class, ToolManagerImpl::taggedToolHandlerInvoker);\n+\n+\tprivate static final Map<Block, EntryImpl> entries = new HashMap<>();\n+\n+\tprivate ToolManagerImpl() {\n+\t}", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2NzMyOA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414567328", "bodyText": "Also IdentityHashMap", "author": "sfPlayer1", "createdAt": "2020-04-24T13:16:20Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.ToolManager;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t//noinspection unchecked\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolManager.ToolHandler>> HANDLER_MAP = new HashMap<>();\n+\tprivate static final Event<ToolManager.ToolHandler> GENERAL_TOOLS_HANDLER = EventFactory.createArrayBacked(ToolManager.ToolHandler.class, ToolManagerImpl::taggedToolHandlerInvoker);\n+\n+\tprivate static final Map<Block, EntryImpl> entries = new HashMap<>();", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU2OTE4Nw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r414569187", "bodyText": "I don't think those events  are too useful for standard uses, as such they should probably be moved down in this class and the comment should refer to DynamicAttributeTool as the standard way to implement the functionality. The same applies to the class comment.", "author": "sfPlayer1", "createdAt": "2020-04-24T13:19:05Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/ToolManager.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package net.fabricmc.fabric.api.tool.attribute.v1;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+/**\n+ * API facing part to register tool handlers and get information about how tools are handled.\n+ */\n+public final class ToolManager {\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\treturn ToolManagerImpl.tag(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn ToolManagerImpl.general();\n+\t}", "originalCommit": "5b1ab1596b668b623f1c6261a948b936fdac7b6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1a58a15def3812ea3f7cb9144f4687451dc8c66", "url": "https://github.com/FabricMC/fabric/commit/b1a58a15def3812ea3f7cb9144f4687451dc8c66", "message": "Most of the issues resolved", "committedDate": "2020-04-24T16:24:43Z", "type": "commit"}, {"oid": "90130b67ffe2df03f810487314ecea75426d0457", "url": "https://github.com/FabricMC/fabric/commit/90130b67ffe2df03f810487314ecea75426d0457", "message": "Some more javadoc and resolve some issues", "committedDate": "2020-04-25T12:26:56Z", "type": "commit"}, {"oid": "592f7d8680fe2d0759d4ee7d4b4789582952bfe1", "url": "https://github.com/FabricMC/fabric/commit/592f7d8680fe2d0759d4ee7d4b4789582952bfe1", "message": "Forgot to change order for these", "committedDate": "2020-04-25T12:28:26Z", "type": "commit"}, {"oid": "b25316b84bb07c1562d75e491d630f74b80fa7f4", "url": "https://github.com/FabricMC/fabric/commit/b25316b84bb07c1562d75e491d630f74b80fa7f4", "message": "Adds post process method to DynamicAttributeTool\nFixed going to vanilla again to query\nFixed tool mining level < 0\nFixed vanilla items on modded blocks not working\nRenamed taggedToolHandlerInvoker to toolHandlerInvoker\nRenamed entries to ENTRIES", "committedDate": "2020-04-25T18:07:13Z", "type": "commit"}, {"oid": "b150cdf3206a760856a77ec26b4bab6029378c80", "url": "https://github.com/FabricMC/fabric/commit/b150cdf3206a760856a77ec26b4bab6029378c80", "message": "New comparision method for modded tools to vanilla blocks", "committedDate": "2020-04-25T18:38:51Z", "type": "commit"}, {"oid": "be6b6d6c078ed4daceb2d12847377c3a16a06c5e", "url": "https://github.com/FabricMC/fabric/commit/be6b6d6c078ed4daceb2d12847377c3a16a06c5e", "message": "Remove useless mixins and use getMaterial().getMiningSpeed to support more tools.", "committedDate": "2020-04-25T18:41:08Z", "type": "commit"}, {"oid": "15e97820ec357833a1f0075cf730dff56eb58a22", "url": "https://github.com/FabricMC/fabric/commit/15e97820ec357833a1f0075cf730dff56eb58a22", "message": "Simply mixin", "committedDate": "2020-04-25T18:42:27Z", "type": "commit"}, {"oid": "7895d7912565ebb71940b0ddbc318d60ef4fc0f9", "url": "https://github.com/FabricMC/fabric/commit/7895d7912565ebb71940b0ddbc318d60ef4fc0f9", "message": "Some useful javadocs", "committedDate": "2020-04-25T18:48:45Z", "type": "commit"}, {"oid": "0493bc30d3676a8ffea9d674304e7bb586595137", "url": "https://github.com/FabricMC/fabric/commit/0493bc30d3676a8ffea9d674304e7bb586595137", "message": "Fix license", "committedDate": "2020-04-25T18:50:49Z", "type": "commit"}, {"oid": "0eb60bac851b9bd7ff5a7649bf32b94cd2d00ebb", "url": "https://github.com/FabricMC/fabric/commit/0eb60bac851b9bd7ff5a7649bf32b94cd2d00ebb", "message": "Bump fabric-object-builders-v0 because we are good", "committedDate": "2020-04-25T19:02:16Z", "type": "commit"}, {"oid": "ce752702d44954cfe4b858c09870b937c5b693d8", "url": "https://github.com/FabricMC/fabric/commit/ce752702d44954cfe4b858c09870b937c5b693d8", "message": "Merge remote-tracking branch 'fabric/1.15' into patch-1", "committedDate": "2020-04-30T04:58:00Z", "type": "commit"}, {"oid": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "url": "https://github.com/FabricMC/fabric/commit/df0f5e273fade5fdc3da14ca6f373efd0ed21428", "message": "Bump version of fabric-object-builder-api-v1 because we are nice", "committedDate": "2020-04-30T04:58:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MzA5Mw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417783093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Please make the material require tool if you plan to disable drops and slow the breaking down using the\n          \n          \n            \n            \t * Please make the material requires a tool if you plan to disable drops and slow the breaking down using the", "author": "i509VCB", "createdAt": "2020-04-30T06:29:55Z", "path": "fabric-object-builder-api-v1/src/main/java/net/fabricmc/fabric/api/object/builder/v1/block/FabricBlockSettings.java", "diffHunk": "@@ -233,16 +233,27 @@ public FabricBlockSettings collidable(boolean collidable) {\n \n \t/* FABRIC HELPERS */\n \n+\t/**\n+\t * Makes the block breakable by any tool if {@code breakByHand} is set to true.\n+\t */\n \tpublic FabricBlockSettings breakByHand(boolean breakByHand) {\n \t\tFabricBlockInternals.computeExtraData(this).breakByHand(breakByHand);\n \t\treturn this;\n \t}\n \n+\t/**\n+\t * Please make the material require tool if you plan to disable drops and slow the breaking down using the\n+\t * incorrect tool by using {@link FabricMaterialBuilder#requiresTool()}.\n+\t */\n \tpublic FabricBlockSettings breakByTool(Tag<Item> tag, int miningLevel) {\n \t\tFabricBlockInternals.computeExtraData(this).addMiningLevel(tag, miningLevel);\n \t\treturn this;\n \t}\n \n+\t/**\n+\t * Please make the material require tool if you plan to disable drops and slow the breaking down using the", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NzQzNQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417787435", "bodyText": "should be require a", "author": "LemmaEOF", "createdAt": "2020-04-30T06:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MzA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MzQzOA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417783438", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Make the material require tool to drop and slows down mining speed if the incorrect tool is used.\n          \n          \n            \n            \t * Make the material require a tool to drop and slows down mining speed if the incorrect tool is used.", "author": "i509VCB", "createdAt": "2020-04-30T06:30:46Z", "path": "fabric-object-builder-api-v1/src/main/java/net/fabricmc/fabric/api/object/builder/v1/block/FabricMaterialBuilder.java", "diffHunk": "@@ -84,6 +84,9 @@ public FabricMaterialBuilder replaceable() {\n \t\treturn this;\n \t}\n \n+\t/**\n+\t * Make the material require tool to drop and slows down mining speed if the incorrect tool is used.", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4Mzg3Nw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417783877", "bodyText": "I get that docs are nice, but the v0 block settings should be deprecated, so unsure if the effort is needed for it", "author": "i509VCB", "createdAt": "2020-04-30T06:31:57Z", "path": "fabric-object-builders-v0/src/main/java/net/fabricmc/fabric/api/block/FabricBlockSettings.java", "diffHunk": "@@ -68,16 +68,27 @@ public static FabricBlockSettings copyOf(Block.Settings settings) {\n \n \t/* FABRIC HELPERS */\n \n+\t/**\n+\t * Makes the block breakable by any tool if {@code breakByHand} is set to true.\n+\t */", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NzA1Nw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417787057", "bodyText": "Just a few neat javadocs, can't go wrong with that tbh", "author": "shedaniel", "createdAt": "2020-04-30T06:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4Mzg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NDA2NA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417784064", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @param stack The stack mining the block\n          \n          \n            \n            \t * @param stack The item stack being used to mine the block", "author": "i509VCB", "createdAt": "2020-04-30T06:32:28Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The stack mining the block", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4ODAwOQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417788009", "bodyText": "The item stack used to mine the block instead?", "author": "shedaniel", "createdAt": "2020-04-30T06:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NDA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NDE4OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417784189", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @param user  The current user of the tool, or null if there isn't any\n          \n          \n            \n            \t * @param user The current user of the tool, or null if there isn't any", "author": "i509VCB", "createdAt": "2020-04-30T06:32:42Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The stack mining the block\n+\t * @param user  The current user of the tool, or null if there isn't any", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4OTExMw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417789113", "bodyText": "we have been adding spaces, and not adding spaces at the same time, do we want to bikeshed javadoc spacing", "author": "shedaniel", "createdAt": "2020-04-30T06:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NDE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4NDQ5MA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417784490", "bodyText": "Maybe use 1.0F instead so the code style isn't over the place", "author": "i509VCB", "createdAt": "2020-04-30T06:33:40Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The stack mining the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, LivingEntity user) {\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The stack mining the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\treturn getMiningLevel(stack, user);\n+\t}\n \n \t/**\n \t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The stack mining the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tfloat getMiningSpeedMultiplier(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault float getMiningSpeedMultiplier(ItemStack stack, LivingEntity user) {\n+\t\treturn 1f;", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "url": "https://github.com/FabricMC/fabric/commit/8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "message": "Resolve some issues", "committedDate": "2020-04-30T06:46:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4Nzc0Nw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417787747", "bodyText": "What is nullable here?\nThe user?\nIf it's the user I would change to this for now:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n          \n          \n            \n            \tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, /* @Nullable */ LivingEntity user) {", "author": "i509VCB", "createdAt": "2020-04-30T06:42:00Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The stack mining the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, LivingEntity user) {\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The stack mining the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4ODY1OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417788659", "bodyText": "Maybe make all these tool handlers their own classes?\nWould clean up the nearly 70% of this class that is inner classes.\nMaybe to a v1.handler package?", "author": "i509VCB", "createdAt": "2020-04-30T06:44:21Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolHandlers.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.Items;\n+import net.minecraft.item.ShearsItem;\n+import net.minecraft.item.ToolItem;\n+import net.minecraft.item.ToolMaterial;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.api.ModInitializer;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.tool.attribute.v1.FabricToolTags;\n+\n+/**\n+ * Entrypoint to register the default tool handlers.\n+ */\n+public class ToolHandlers implements ModInitializer {\n+\t@Override\n+\tpublic void onInitialize() {\n+\t\tToolManagerImpl.general().register(new ModdedToolsModdedBlocksToolHandler());\n+\t\tToolManagerImpl.general().register(new VanillaToolsModdedBlocksToolHandler());\n+\t\tToolManagerImpl.general().register(new VanillaToolsVanillaBlocksToolHandler());", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4OTI2NA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417789264", "bodyText": "specify nullability to the applicable return value or parameters", "author": "i509VCB", "createdAt": "2020-04-30T06:45:54Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolHandler>> HANDLER_MAP = new HashMap<>();\n+\tprivate static final Event<ToolHandler> GENERAL_TOOLS_HANDLER = EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker);\n+\n+\tprivate static final Map<Block, EntryImpl> ENTRIES = new IdentityHashMap<>();\n+\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> entry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (entry.getKey().getId().equals(tag.getId())) {\n+\t\t\t\treturn entry.getValue();\n+\t\t\t}\n+\t\t}\n+\n+\t\tHANDLER_MAP.put(tag, EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker));\n+\t\treturn HANDLER_MAP.get(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn GENERAL_TOOLS_HANDLER;\n+\t}\n+\n+\tprivate static ToolHandler toolHandlerInvoker(ToolHandler[] toolHandlers) {\n+\t\treturn new ToolHandler() {\n+\t\t\t@Override\n+\t\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tActionResult effectiveOn = Objects.requireNonNull(toolHandler.isEffectiveOn(tag, state, stack, user));\n+\n+\t\t\t\t\tif (effectiveOn != ActionResult.PASS) {\n+\t\t\t\t\t\treturn effectiveOn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic TypedActionResult<Float> getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tTypedActionResult<Float> miningSpeedMultiplier = Objects.requireNonNull(toolHandler.getMiningSpeedMultiplier(tag, state, stack, user));\n+\n+\t\t\t\t\tif (miningSpeedMultiplier.getResult() != ActionResult.PASS) {\n+\t\t\t\t\t\treturn miningSpeedMultiplier;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn TypedActionResult.pass(1f);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic static Entry entry(Block block) {\n+\t\treturn ENTRIES.computeIfAbsent(block, (bb) -> new EntryImpl());\n+\t}\n+\n+\tpublic static Entry entryNullable(Block block) {\n+\t\treturn ENTRIES.get(block);\n+\t}\n+\n+\t@Deprecated\n+\tpublic static void registerBreakByHand(Block block, boolean value) {\n+\t\tentry(block).setBreakByHand(value);\n+\t}\n+\n+\t@Deprecated\n+\tpublic static void registerBreakByTool(Block block, Tag<Item> tag, int miningLevel) {\n+\t\tentry(block).putBreakByTool(tag, miningLevel);\n+\t}\n+\n+\t/**\n+\t * Hook for ItemStack.isEffectiveOn and similar methods.\n+\t */\n+\t//TODO: nullable on user once we have an official @Nullable annotation in\n+\tpublic static TriState handleIsEffectiveOn(BlockState state, ItemStack stack, LivingEntity user) {", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4OTQyMA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417789420", "bodyText": "Mark the user param nullable?", "author": "i509VCB", "createdAt": "2020-04-30T06:46:20Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolHandler>> HANDLER_MAP = new HashMap<>();\n+\tprivate static final Event<ToolHandler> GENERAL_TOOLS_HANDLER = EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker);\n+\n+\tprivate static final Map<Block, EntryImpl> ENTRIES = new IdentityHashMap<>();\n+\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> entry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (entry.getKey().getId().equals(tag.getId())) {\n+\t\t\t\treturn entry.getValue();\n+\t\t\t}\n+\t\t}\n+\n+\t\tHANDLER_MAP.put(tag, EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker));\n+\t\treturn HANDLER_MAP.get(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn GENERAL_TOOLS_HANDLER;\n+\t}\n+\n+\tprivate static ToolHandler toolHandlerInvoker(ToolHandler[] toolHandlers) {\n+\t\treturn new ToolHandler() {\n+\t\t\t@Override\n+\t\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tActionResult effectiveOn = Objects.requireNonNull(toolHandler.isEffectiveOn(tag, state, stack, user));\n+\n+\t\t\t\t\tif (effectiveOn != ActionResult.PASS) {\n+\t\t\t\t\t\treturn effectiveOn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic TypedActionResult<Float> getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tTypedActionResult<Float> miningSpeedMultiplier = Objects.requireNonNull(toolHandler.getMiningSpeedMultiplier(tag, state, stack, user));\n+\n+\t\t\t\t\tif (miningSpeedMultiplier.getResult() != ActionResult.PASS) {\n+\t\t\t\t\t\treturn miningSpeedMultiplier;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn TypedActionResult.pass(1f);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic static Entry entry(Block block) {\n+\t\treturn ENTRIES.computeIfAbsent(block, (bb) -> new EntryImpl());\n+\t}\n+\n+\tpublic static Entry entryNullable(Block block) {\n+\t\treturn ENTRIES.get(block);\n+\t}\n+\n+\t@Deprecated\n+\tpublic static void registerBreakByHand(Block block, boolean value) {\n+\t\tentry(block).setBreakByHand(value);\n+\t}\n+\n+\t@Deprecated\n+\tpublic static void registerBreakByTool(Block block, Tag<Item> tag, int miningLevel) {\n+\t\tentry(block).putBreakByTool(tag, miningLevel);\n+\t}\n+\n+\t/**\n+\t * Hook for ItemStack.isEffectiveOn and similar methods.\n+\t */\n+\t//TODO: nullable on user once we have an official @Nullable annotation in\n+\tpublic static TriState handleIsEffectiveOn(BlockState state, ItemStack stack, LivingEntity user) {\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> eventEntry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (stack.getItem().isIn(eventEntry.getKey())) {\n+\t\t\t\tActionResult effective = eventEntry.getValue().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\t\t\t\tif (effective.isAccepted()) return TriState.TRUE;\n+\t\t\t\teffective = general().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\t\t\t\tif (effective.isAccepted()) return TriState.TRUE;\n+\t\t\t}\n+\t\t}\n+\n+\t\tEntryImpl entry = (EntryImpl) entryNullable(state.getBlock());\n+\n+\t\tif (entry != null) {\n+\t\t\treturn entry.defaultValue;\n+\t\t} else {\n+\t\t\treturn TriState.DEFAULT;\n+\t\t}\n+\t}\n+\n+\tpublic static float handleBreakingSpeed(BlockState state, ItemStack stack, LivingEntity user) {\n+\t\tfloat breakingSpeed = 0f;\n+\t\tTag<Item> handledTag = null;\n+\t\tboolean handled = false;\n+\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> eventEntry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (stack.getItem().isIn(eventEntry.getKey())) {\n+\t\t\t\tActionResult effective = eventEntry.getValue().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\n+\t\t\t\tif (effective.isAccepted()) {\n+\t\t\t\t\tTypedActionResult<Float> speedMultiplier = Objects.requireNonNull(eventEntry.getValue().invoker().getMiningSpeedMultiplier(eventEntry.getKey(), state, stack, user));\n+\n+\t\t\t\t\tif (speedMultiplier.getResult().isAccepted()) {\n+\t\t\t\t\t\thandled = true;\n+\n+\t\t\t\t\t\tif (speedMultiplier.getValue() > breakingSpeed) {\n+\t\t\t\t\t\t\tbreakingSpeed = speedMultiplier.getValue();\n+\t\t\t\t\t\t\thandledTag = eventEntry.getKey();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\teffective = general().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\n+\t\t\t\tif (effective.isAccepted()) {\n+\t\t\t\t\tTypedActionResult<Float> speedMultiplier = Objects.requireNonNull(general().invoker().getMiningSpeedMultiplier(eventEntry.getKey(), state, stack, user));\n+\n+\t\t\t\t\tif (speedMultiplier.getResult().isAccepted()) {\n+\t\t\t\t\t\thandled = true;\n+\n+\t\t\t\t\t\tif (speedMultiplier.getValue() > breakingSpeed) {\n+\t\t\t\t\t\t\tbreakingSpeed = speedMultiplier.getValue();\n+\t\t\t\t\t\t\thandledTag = eventEntry.getKey();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Give it a default speed if it is not handled.\n+\t\tbreakingSpeed = handled ? breakingSpeed : 1f;\n+\n+\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\tbreakingSpeed = ((DynamicAttributeTool) stack.getItem()).postProcessMiningSpeed(handledTag, state, stack, user, breakingSpeed, handled);\n+\t\t}\n+\n+\t\treturn breakingSpeed;\n+\t}\n+\n+\t/**\n+\t * The handler to handle tool speed and effectiveness.\n+\t *\n+\t * @see net.fabricmc.fabric.impl.tool.attribute.ToolHandlers for default handlers.\n+\t */\n+\tpublic interface ToolHandler {\n+\t\t/**\n+\t\t * Determines whether this handler is active and effective of the tools.\n+\t\t *\n+\t\t * @param tag   the tag involved\n+\t\t * @param state the block state to break\n+\t\t * @param stack the item stack breaking the block\n+\t\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t\t * @return the result of effectiveness\n+\t\t */\n+\t\tdefault ActionResult isEffectiveOn(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4OTU1Nw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417789557", "bodyText": "again like above, mark the user param nullable", "author": "i509VCB", "createdAt": "2020-04-30T06:46:38Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolHandler>> HANDLER_MAP = new HashMap<>();\n+\tprivate static final Event<ToolHandler> GENERAL_TOOLS_HANDLER = EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker);\n+\n+\tprivate static final Map<Block, EntryImpl> ENTRIES = new IdentityHashMap<>();\n+\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> entry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (entry.getKey().getId().equals(tag.getId())) {\n+\t\t\t\treturn entry.getValue();\n+\t\t\t}\n+\t\t}\n+\n+\t\tHANDLER_MAP.put(tag, EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker));\n+\t\treturn HANDLER_MAP.get(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn GENERAL_TOOLS_HANDLER;\n+\t}\n+\n+\tprivate static ToolHandler toolHandlerInvoker(ToolHandler[] toolHandlers) {\n+\t\treturn new ToolHandler() {\n+\t\t\t@Override\n+\t\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tActionResult effectiveOn = Objects.requireNonNull(toolHandler.isEffectiveOn(tag, state, stack, user));\n+\n+\t\t\t\t\tif (effectiveOn != ActionResult.PASS) {\n+\t\t\t\t\t\treturn effectiveOn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic TypedActionResult<Float> getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tTypedActionResult<Float> miningSpeedMultiplier = Objects.requireNonNull(toolHandler.getMiningSpeedMultiplier(tag, state, stack, user));\n+\n+\t\t\t\t\tif (miningSpeedMultiplier.getResult() != ActionResult.PASS) {\n+\t\t\t\t\t\treturn miningSpeedMultiplier;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn TypedActionResult.pass(1f);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic static Entry entry(Block block) {\n+\t\treturn ENTRIES.computeIfAbsent(block, (bb) -> new EntryImpl());\n+\t}\n+\n+\tpublic static Entry entryNullable(Block block) {\n+\t\treturn ENTRIES.get(block);\n+\t}\n+\n+\t@Deprecated\n+\tpublic static void registerBreakByHand(Block block, boolean value) {\n+\t\tentry(block).setBreakByHand(value);\n+\t}\n+\n+\t@Deprecated\n+\tpublic static void registerBreakByTool(Block block, Tag<Item> tag, int miningLevel) {\n+\t\tentry(block).putBreakByTool(tag, miningLevel);\n+\t}\n+\n+\t/**\n+\t * Hook for ItemStack.isEffectiveOn and similar methods.\n+\t */\n+\t//TODO: nullable on user once we have an official @Nullable annotation in\n+\tpublic static TriState handleIsEffectiveOn(BlockState state, ItemStack stack, LivingEntity user) {\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> eventEntry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (stack.getItem().isIn(eventEntry.getKey())) {\n+\t\t\t\tActionResult effective = eventEntry.getValue().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\t\t\t\tif (effective.isAccepted()) return TriState.TRUE;\n+\t\t\t\teffective = general().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\t\t\t\tif (effective.isAccepted()) return TriState.TRUE;\n+\t\t\t}\n+\t\t}\n+\n+\t\tEntryImpl entry = (EntryImpl) entryNullable(state.getBlock());\n+\n+\t\tif (entry != null) {\n+\t\t\treturn entry.defaultValue;\n+\t\t} else {\n+\t\t\treturn TriState.DEFAULT;\n+\t\t}\n+\t}\n+\n+\tpublic static float handleBreakingSpeed(BlockState state, ItemStack stack, LivingEntity user) {\n+\t\tfloat breakingSpeed = 0f;\n+\t\tTag<Item> handledTag = null;\n+\t\tboolean handled = false;\n+\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> eventEntry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (stack.getItem().isIn(eventEntry.getKey())) {\n+\t\t\t\tActionResult effective = eventEntry.getValue().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\n+\t\t\t\tif (effective.isAccepted()) {\n+\t\t\t\t\tTypedActionResult<Float> speedMultiplier = Objects.requireNonNull(eventEntry.getValue().invoker().getMiningSpeedMultiplier(eventEntry.getKey(), state, stack, user));\n+\n+\t\t\t\t\tif (speedMultiplier.getResult().isAccepted()) {\n+\t\t\t\t\t\thandled = true;\n+\n+\t\t\t\t\t\tif (speedMultiplier.getValue() > breakingSpeed) {\n+\t\t\t\t\t\t\tbreakingSpeed = speedMultiplier.getValue();\n+\t\t\t\t\t\t\thandledTag = eventEntry.getKey();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\teffective = general().invoker().isEffectiveOn(eventEntry.getKey(), state, stack, user);\n+\n+\t\t\t\tif (effective.isAccepted()) {\n+\t\t\t\t\tTypedActionResult<Float> speedMultiplier = Objects.requireNonNull(general().invoker().getMiningSpeedMultiplier(eventEntry.getKey(), state, stack, user));\n+\n+\t\t\t\t\tif (speedMultiplier.getResult().isAccepted()) {\n+\t\t\t\t\t\thandled = true;\n+\n+\t\t\t\t\t\tif (speedMultiplier.getValue() > breakingSpeed) {\n+\t\t\t\t\t\t\tbreakingSpeed = speedMultiplier.getValue();\n+\t\t\t\t\t\t\thandledTag = eventEntry.getKey();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Give it a default speed if it is not handled.\n+\t\tbreakingSpeed = handled ? breakingSpeed : 1f;\n+\n+\t\tif (stack.getItem() instanceof DynamicAttributeTool) {\n+\t\t\tbreakingSpeed = ((DynamicAttributeTool) stack.getItem()).postProcessMiningSpeed(handledTag, state, stack, user, breakingSpeed, handled);\n+\t\t}\n+\n+\t\treturn breakingSpeed;\n+\t}\n+\n+\t/**\n+\t * The handler to handle tool speed and effectiveness.\n+\t *\n+\t * @see net.fabricmc.fabric.impl.tool.attribute.ToolHandlers for default handlers.\n+\t */\n+\tpublic interface ToolHandler {\n+\t\t/**\n+\t\t * Determines whether this handler is active and effective of the tools.\n+\t\t *\n+\t\t * @param tag   the tag involved\n+\t\t * @param state the block state to break\n+\t\t * @param stack the item stack breaking the block\n+\t\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t\t * @return the result of effectiveness\n+\t\t */\n+\t\tdefault ActionResult isEffectiveOn(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\treturn ActionResult.PASS;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Determines the mining speed multiplier of the tools.\n+\t\t *\n+\t\t * @param tag   the tag involved\n+\t\t * @param state the block state to break\n+\t\t * @param stack the item stack breaking the block\n+\t\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t\t * @return the result of mining speed.\n+\t\t */\n+\t\tdefault TypedActionResult<Float> getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MDM0MA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417790340", "bodyText": "I horribly dislike the fact that we are using a short circuiting injector to handle this. Other mods which mixin to isEffectiveOn will silent fail if they inject after fabric here.\nI'd say @Overwrite or find a way to keep the vanilla codepath within a possible scope to be executed.", "author": "i509VCB", "createdAt": "2020-04-30T06:48:32Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/mixin/tool/attribute/MixinItemStack.java", "diffHunk": "@@ -42,30 +41,12 @@\n \n \t@Inject(at = @At(\"HEAD\"), method = \"isEffectiveOn\", cancellable = true)\n \tpublic void isEffectiveOn(BlockState state, CallbackInfoReturnable<Boolean> info) {\n-\t\tTriState triState = ToolManager.handleIsEffectiveOn((ItemStack) (Object) this, state, null);\n-\n-\t\tif (triState != TriState.DEFAULT) {\n-\t\t\tinfo.setReturnValue(triState.get());\n-\t\t\tinfo.cancel();\n-\t\t}\n+\t\tinfo.setReturnValue(ToolManager.handleIsEffectiveOn(state, (ItemStack) (Object) this, null).get());", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MDQ5Mg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417790492", "bodyText": "Similar to above comment about short circuiting injector.", "author": "i509VCB", "createdAt": "2020-04-30T06:48:53Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/mixin/tool/attribute/MixinItemStack.java", "diffHunk": "@@ -42,30 +41,12 @@\n \n \t@Inject(at = @At(\"HEAD\"), method = \"isEffectiveOn\", cancellable = true)\n \tpublic void isEffectiveOn(BlockState state, CallbackInfoReturnable<Boolean> info) {\n-\t\tTriState triState = ToolManager.handleIsEffectiveOn((ItemStack) (Object) this, state, null);\n-\n-\t\tif (triState != TriState.DEFAULT) {\n-\t\t\tinfo.setReturnValue(triState.get());\n-\t\t\tinfo.cancel();\n-\t\t}\n+\t\tinfo.setReturnValue(ToolManager.handleIsEffectiveOn(state, (ItemStack) (Object) this, null).get());\n \t}\n \n \t@Inject(at = @At(\"HEAD\"), method = \"getMiningSpeed\", cancellable = true)\n \tpublic void getMiningSpeed(BlockState state, CallbackInfoReturnable<Float> info) {\n-\t\tTriState triState = ToolManager.handleIsEffectiveOn((ItemStack) (Object) this, state, null);\n-\n-\t\tif (triState != TriState.DEFAULT) {\n-\t\t\tItem item = this.getItem();\n-\t\t\tfloat miningSpeed;\n-\n-\t\t\tif (item instanceof DynamicAttributeTool) {\n-\t\t\t\tminingSpeed = ((DynamicAttributeTool) this.getItem()).getMiningSpeedMultiplier((ItemStack) (Object) this, null);\n-\t\t\t} else {\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tinfo.setReturnValue(triState.get() ? miningSpeed : 1.0F);\n-\t\t}\n+\t\tinfo.setReturnValue(ToolManager.handleBreakingSpeed(state, (ItemStack) (Object) this, null));", "originalCommit": "df0f5e273fade5fdc3da14ca6f373efd0ed21428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MTAzNg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417791036", "bodyText": "You need to specify which param is nullable here", "author": "i509VCB", "createdAt": "2020-04-30T06:50:08Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, LivingEntity user) {", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MTE5Nw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417791197", "bodyText": "Ditto. Specify nullable thing", "author": "i509VCB", "createdAt": "2020-04-30T06:50:30Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, LivingEntity user) {\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\treturn getMiningLevel(stack, user);\n+\t}\n \n \t/**\n \t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tfloat getMiningSpeedMultiplier(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault float getMiningSpeedMultiplier(ItemStack stack, LivingEntity user) {", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MTI5OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417791299", "bodyText": "Same again.\nDitto. Specify nullable thing", "author": "i509VCB", "createdAt": "2020-04-30T06:50:44Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, LivingEntity user) {\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\treturn getMiningLevel(stack, user);\n+\t}\n \n \t/**\n \t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tfloat getMiningSpeedMultiplier(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault float getMiningSpeedMultiplier(ItemStack stack, LivingEntity user) {\n+\t\treturn 1.0F;\n+\t}\n+\n+\t/**\n+\t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault float getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MTM2OA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417791368", "bodyText": "Same again.\nDitto. Specify nullable thing", "author": "i509VCB", "createdAt": "2020-04-30T06:50:52Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, LivingEntity user) {\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\treturn getMiningLevel(stack, user);\n+\t}\n \n \t/**\n \t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tfloat getMiningSpeedMultiplier(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault float getMiningSpeedMultiplier(ItemStack stack, LivingEntity user) {\n+\t\treturn 1.0F;\n+\t}\n+\n+\t/**\n+\t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault float getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\treturn getMiningSpeedMultiplier(stack, user);\n+\t}\n+\n+\t/**\n+\t * Post process the mining speed.\n+\t *\n+\t * @param tag          The tool tag the item stack is handled by\n+\t * @param state        The block to mine\n+\t * @param stack        The item stack being used to mine the block\n+\t * @param user         The current user of the tool, or null if there isn't any\n+\t * @param currentSpeed The mining speed before post process\n+\t * @param isEffective  whether the tool has been handled\n+\t * @return the speed after post processing\n+\t */\n+\tdefault float postProcessMiningSpeed(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user, float currentSpeed, boolean isEffective) {", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MTQxOA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417791418", "bodyText": "Same again.\nDitto. Specify nullable thing", "author": "i509VCB", "createdAt": "2020-04-30T06:51:00Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -57,10 +111,10 @@\n \t *\n \t * @param slot  The equipment slot this item is equipped in.\n \t * @param stack The stack that's equipped.\n-\t * @param user The current user of the tool, or none if there isn't any\n+\t * @param user  The current user of the tool, or none if there isn't any\n \t * @return The dynamic modifiers to add on top of other modifiers on this stack. If none, return {@link #EMPTY}.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n+\t// nullable on user once we have an official @Nullable annotation in\n \tdefault Multimap<String, EntityAttributeModifier> getDynamicModifiers(EquipmentSlot slot, ItemStack stack, LivingEntity user) {", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MTc1Mw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417791753", "bodyText": "okay I know you are getting sick of these nullable mentions, but for maintainability and ease of possible annotations in the future, we need to mark these nullable params", "author": "i509VCB", "createdAt": "2020-04-30T06:51:45Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/ToolManager.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.tool.attribute.v1;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.ItemStack;\n+\n+import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+/**\n+ * API facing part to register tool handlers and get information about how tools are handled.\n+ * Implement {@link DynamicAttributeTool} to change the mining level or speed of your tool.\n+ */\n+public final class ToolManager {\n+\t/**\n+\t * Handles if the tool is effective on a block.\n+\t *\n+\t * @param state the block state to break\n+\t * @param stack the item stack involved with breaking the block\n+\t * @param user  the user involved in breaking the block, null if not applicable.\n+\t * @return the state of effective\n+\t */\n+\tpublic static TriState handleIsEffectiveOn(BlockState state, ItemStack stack, LivingEntity user) {", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MjY0MQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417792641", "bodyText": "I assume these tags you array copy are either already generated or null checked?", "author": "i509VCB", "createdAt": "2020-04-30T06:53:48Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2MjI0OQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417962249", "bodyText": "This was from the old tool manager, I renamed the class and now it shows up like this, I might want to move these to lists but I don't have an idea on the performance impact.", "author": "shedaniel", "createdAt": "2020-04-30T12:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2MjY2MQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417962661", "bodyText": "well hmm nevermind, it seems like I using arrays might not be a bad idea", "author": "shedaniel", "createdAt": "2020-04-30T12:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAwOTUxMA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r418009510", "bodyText": "Should use Arrays.copyOf though", "author": "sfPlayer1", "createdAt": "2020-04-30T13:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MjY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MzE5Mw==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417793193", "bodyText": "Maybe instead of hard failing here, we just return FAIL or PASS?", "author": "i509VCB", "createdAt": "2020-04-30T06:55:00Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolHandler>> HANDLER_MAP = new HashMap<>();\n+\tprivate static final Event<ToolHandler> GENERAL_TOOLS_HANDLER = EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker);\n+\n+\tprivate static final Map<Block, EntryImpl> ENTRIES = new IdentityHashMap<>();\n+\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> entry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (entry.getKey().getId().equals(tag.getId())) {\n+\t\t\t\treturn entry.getValue();\n+\t\t\t}\n+\t\t}\n+\n+\t\tHANDLER_MAP.put(tag, EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker));\n+\t\treturn HANDLER_MAP.get(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn GENERAL_TOOLS_HANDLER;\n+\t}\n+\n+\tprivate static ToolHandler toolHandlerInvoker(ToolHandler[] toolHandlers) {\n+\t\treturn new ToolHandler() {\n+\t\t\t@Override\n+\t\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tActionResult effectiveOn = Objects.requireNonNull(toolHandler.isEffectiveOn(tag, state, stack, user));", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5NzE5Mg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417797192", "bodyText": "I think you shouldn't be returning null anyway", "author": "shedaniel", "createdAt": "2020-04-30T07:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MzE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyMDIxMA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r418820210", "bodyText": "Null-checking catches errors more quickly, so I'd say it's OK.", "author": "LemmaEOF", "createdAt": "2020-05-02T01:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MzE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5MzUxMg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r417793512", "bodyText": "Consider this like the above where ever you call Objects.requireNonNull", "author": "i509VCB", "createdAt": "2020-04-30T06:55:46Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/ToolManagerImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute;\n+\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import net.minecraft.block.Block;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.fabric.api.event.Event;\n+import net.fabricmc.fabric.api.event.EventFactory;\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.api.util.TriState;\n+\n+public final class ToolManagerImpl {\n+\tpublic interface Entry {\n+\t\tvoid setBreakByHand(boolean value);\n+\n+\t\tvoid putBreakByTool(Tag<Item> tag, int miningLevel);\n+\n+\t\tint getMiningLevel(Tag<Item> tag);\n+\t}\n+\n+\tprivate static class EntryImpl implements Entry {\n+\t\tprivate Tag<Item>[] tags = new Tag[0];\n+\t\tprivate int[] tagLevels = new int[0];\n+\t\tprivate TriState defaultValue = TriState.DEFAULT;\n+\n+\t\t@Override\n+\t\tpublic void setBreakByHand(boolean value) {\n+\t\t\tthis.defaultValue = TriState.of(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void putBreakByTool(Tag<Item> tag, int miningLevel) {\n+\t\t\ttag(tag); // Generate tag entry\n+\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\ttagLevels[i] = miningLevel;\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tTag<Item>[] newTags = new Tag[tags.length + 1];\n+\t\t\tint[] newTagLevels = new int[tagLevels.length + 1];\n+\t\t\tSystem.arraycopy(tags, 0, newTags, 0, tags.length);\n+\t\t\tSystem.arraycopy(tagLevels, 0, newTagLevels, 0, tagLevels.length);\n+\t\t\tnewTags[tags.length] = tag;\n+\t\t\tnewTagLevels[tagLevels.length] = miningLevel;\n+\t\t\ttags = newTags;\n+\t\t\ttagLevels = newTagLevels;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int getMiningLevel(Tag<Item> tag) {\n+\t\t\tfor (int i = 0; i < tags.length; i++) {\n+\t\t\t\tif (tags[i] == tag) {\n+\t\t\t\t\treturn tagLevels[i];\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tprivate static final Map<Tag<Item>, Event<ToolHandler>> HANDLER_MAP = new HashMap<>();\n+\tprivate static final Event<ToolHandler> GENERAL_TOOLS_HANDLER = EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker);\n+\n+\tprivate static final Map<Block, EntryImpl> ENTRIES = new IdentityHashMap<>();\n+\n+\t/**\n+\t * Returns a event for the tag provided, creates a new event if it does not exist.\n+\t *\n+\t * @param tag the tag provided for the tool\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> tag(Tag<Item> tag) {\n+\t\tfor (Map.Entry<Tag<Item>, Event<ToolHandler>> entry : HANDLER_MAP.entrySet()) {\n+\t\t\tif (entry.getKey().getId().equals(tag.getId())) {\n+\t\t\t\treturn entry.getValue();\n+\t\t\t}\n+\t\t}\n+\n+\t\tHANDLER_MAP.put(tag, EventFactory.createArrayBacked(ToolHandler.class, ToolManagerImpl::toolHandlerInvoker));\n+\t\treturn HANDLER_MAP.get(tag);\n+\t}\n+\n+\t/**\n+\t * Returns a event used for every tag registered.\n+\t *\n+\t * @return the event callback.\n+\t */\n+\tpublic static Event<ToolHandler> general() {\n+\t\treturn GENERAL_TOOLS_HANDLER;\n+\t}\n+\n+\tprivate static ToolHandler toolHandlerInvoker(ToolHandler[] toolHandlers) {\n+\t\treturn new ToolHandler() {\n+\t\t\t@Override\n+\t\t\tpublic ActionResult isEffectiveOn(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tActionResult effectiveOn = Objects.requireNonNull(toolHandler.isEffectiveOn(tag, state, stack, user));\n+\n+\t\t\t\t\tif (effectiveOn != ActionResult.PASS) {\n+\t\t\t\t\t\treturn effectiveOn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\treturn ActionResult.PASS;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic TypedActionResult<Float> getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, LivingEntity user) {\n+\t\t\t\tfor (ToolHandler toolHandler : toolHandlers) {\n+\t\t\t\t\tTypedActionResult<Float> miningSpeedMultiplier = Objects.requireNonNull(toolHandler.getMiningSpeedMultiplier(tag, state, stack, user));", "originalCommit": "8453130eaaecea6be4a8b2ce8ad3bb4e020fec73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba8b1a997b71605f9a0144adb649f247c0090952", "url": "https://github.com/FabricMC/fabric/commit/ba8b1a997b71605f9a0144adb649f247c0090952", "message": "a", "committedDate": "2020-04-30T12:19:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAwNjU1MA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r418006550", "bodyText": "This documentation is outdated", "author": "sfPlayer1", "createdAt": "2020-04-30T13:25:00Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/ToolManager.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.api.tool.attribute.v1;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.ItemStack;\n+\n+import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+/**\n+ * API facing part to register tool handlers and get information about how tools are handled.\n+ * Implement {@link DynamicAttributeTool} to change the mining level or speed of your tool.", "originalCommit": "ba8b1a997b71605f9a0144adb649f247c0090952", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxNjE0OA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r418016148", "bodyText": "This needs further explanation with examples where it matters and where it doesn't.", "author": "sfPlayer1", "createdAt": "2020-04-30T13:38:40Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/api/tool/attribute/v1/DynamicAttributeTool.java", "diffHunk": "@@ -33,22 +36,73 @@\n \t/**\n \t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tint getMiningLevel(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault int getMiningLevel(ItemStack stack, /* @Nullable */ LivingEntity user) {\n+\t\treturn 0;\n+\t}\n+\n+\t/**\n+\t * Determines the mining level of the passed stack, which is used for calculating what blocks this tool is allowed to break.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining level of the item. 3 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault int getMiningLevel(Tag<Item> tag, BlockState state, ItemStack stack, /* @Nullable */ LivingEntity user) {\n+\t\treturn getMiningLevel(stack, user);\n+\t}\n \n \t/**\n \t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n \t *\n-\t * @param stack The stack to check on.\n-\t * @param user The current user of the tool, or null if there isn't any.\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n \t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t * @deprecated Use {@link #getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)} to detect tag and block.\n \t */\n-\t//TODO: nullable on user once we have an official @Nullable annotation in\n-\tfloat getMiningSpeedMultiplier(ItemStack stack, LivingEntity user);\n+\t// nullable on user once we have an official @Nullable annotation in\n+\t@Deprecated\n+\tdefault float getMiningSpeedMultiplier(ItemStack stack, /* @Nullable */ LivingEntity user) {\n+\t\treturn 1.0F;\n+\t}\n+\n+\t/**\n+\t * Determines the mining speed multiplier of the passed stack, which is one factor in overall mining speed.\n+\t *\n+\t * @param tag   The tool tag the item stack is being compared to\n+\t * @param state The block to mine\n+\t * @param stack The item stack being used to mine the block\n+\t * @param user  The current user of the tool, or null if there isn't any\n+\t * @return The mining speed multiplier of the item. 8.0 is equal to a diamond pick.\n+\t */\n+\t// nullable on user once we have an official @Nullable annotation in\n+\tdefault float getMiningSpeedMultiplier(Tag<Item> tag, BlockState state, ItemStack stack, /* @Nullable */ LivingEntity user) {\n+\t\treturn getMiningSpeedMultiplier(stack, user);\n+\t}\n+\n+\t/**\n+\t * Post process the mining speed.", "originalCommit": "ba8b1a997b71605f9a0144adb649f247c0090952", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5a4c3ba42d8236244f1bc6d409bfde681285c96", "url": "https://github.com/FabricMC/fabric/commit/f5a4c3ba42d8236244f1bc6d409bfde681285c96", "message": "remove vanilla tools vanilla blocks thing ok", "committedDate": "2020-04-30T15:03:40Z", "type": "commit"}, {"oid": "db396f5ae5ac2a8fdc94bed6eb6740d757fd97fe", "url": "https://github.com/FabricMC/fabric/commit/db396f5ae5ac2a8fdc94bed6eb6740d757fd97fe", "message": "descriptive", "committedDate": "2020-04-30T15:04:39Z", "type": "commit"}, {"oid": "b7444132e29e22b8438e7b994c1e1149cbe6f8fc", "url": "https://github.com/FabricMC/fabric/commit/b7444132e29e22b8438e7b994c1e1149cbe6f8fc", "message": "Get the faster speed instead", "committedDate": "2020-04-30T18:22:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyMjQ0MA==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r418822440", "bodyText": "Maybe have this ModdedToolsVanillaBlocksToolHandler?", "author": "LemmaEOF", "createdAt": "2020-05-02T01:46:27Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/impl/tool/attribute/handlers/ModdedMiningToolsVanillaBlocksToolHandler.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright (c) 2016, 2017, 2018, 2019 FabricMC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package net.fabricmc.fabric.impl.tool.attribute.handlers;\n+\n+import java.util.List;\n+\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.LivingEntity;\n+import net.minecraft.item.Item;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.item.ToolItem;\n+import net.minecraft.tag.Tag;\n+import net.minecraft.util.ActionResult;\n+import net.minecraft.util.TypedActionResult;\n+\n+import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n+import net.fabricmc.fabric.impl.tool.attribute.ToolManagerImpl;\n+\n+/**\n+ * This handler handles items that are a subclass of {@link DynamicAttributeTool} by using the\n+ * vanilla {@link Item#isEffectiveOn(BlockState)} with a custom fake tool material to use the mining level\n+ * from {@link DynamicAttributeTool#getMiningLevel(Tag, BlockState, ItemStack, LivingEntity)}.\n+ *\n+ * <p>Only applicable to blocks that are vanilla or share the material that is handled by their vanilla tool.</p>\n+ */\n+public class ModdedMiningToolsVanillaBlocksToolHandler implements ToolManagerImpl.ToolHandler {", "originalCommit": "b7444132e29e22b8438e7b994c1e1149cbe6f8fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyMzEwOQ==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r418823109", "bodyText": "Is it ok to not have this be TriStates anymore?", "author": "LemmaEOF", "createdAt": "2020-05-02T01:48:18Z", "path": "fabric-tool-attribute-api-v1/src/main/java/net/fabricmc/fabric/mixin/tool/attribute/MixinItemStack.java", "diffHunk": "@@ -31,40 +31,26 @@\n import net.minecraft.item.ItemStack;\n \n import net.fabricmc.fabric.api.tool.attribute.v1.DynamicAttributeTool;\n-import net.fabricmc.fabric.api.util.TriState;\n+import net.fabricmc.fabric.api.tool.attribute.v1.ToolManager;\n import net.fabricmc.fabric.impl.tool.attribute.AttributeManager;\n-import net.fabricmc.fabric.impl.tool.attribute.ToolManager;\n \n @Mixin(ItemStack.class)\n public abstract class MixinItemStack {\n \t@Shadow\n \tpublic abstract Item getItem();\n \n-\t@Inject(at = @At(\"HEAD\"), method = \"isEffectiveOn\", cancellable = true)\n+\t@Inject(at = @At(\"RETURN\"), method = \"isEffectiveOn\", cancellable = true)\n \tpublic void isEffectiveOn(BlockState state, CallbackInfoReturnable<Boolean> info) {\n-\t\tTriState triState = ToolManager.handleIsEffectiveOn((ItemStack) (Object) this, state, null);\n-\n-\t\tif (triState != TriState.DEFAULT) {\n-\t\t\tinfo.setReturnValue(triState.get());\n-\t\t\tinfo.cancel();\n+\t\tif (!info.getReturnValueZ()) {\n+\t\t\tinfo.setReturnValue(ToolManager.handleIsEffectiveOnIgnoresVanilla(state, (ItemStack) (Object) this, null).get());", "originalCommit": "b7444132e29e22b8438e7b994c1e1149cbe6f8fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEyMDgzMg==", "url": "https://github.com/FabricMC/fabric/pull/589#discussion_r419120832", "bodyText": "Yeah I should do that", "author": "shedaniel", "createdAt": "2020-05-03T15:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyMzEwOQ=="}], "type": "inlineReview"}, {"oid": "0fa545c49b1ceae78622fa11e6b5af01a38eb798", "url": "https://github.com/FabricMC/fabric/commit/0fa545c49b1ceae78622fa11e6b5af01a38eb798", "message": "Rename ModdedToolsVanillaBlocksToolHandler", "committedDate": "2020-05-03T15:45:04Z", "type": "commit"}, {"oid": "1073688deae39b43becd912924909ff91444055b", "url": "https://github.com/FabricMC/fabric/commit/1073688deae39b43becd912924909ff91444055b", "message": "Remove tri state", "committedDate": "2020-05-03T15:45:20Z", "type": "commit"}, {"oid": "6e278a08866f4c1229f89aaeae44cc9a880dceb6", "url": "https://github.com/FabricMC/fabric/commit/6e278a08866f4c1229f89aaeae44cc9a880dceb6", "message": "Fix compile errors", "committedDate": "2020-05-03T15:48:01Z", "type": "commit"}, {"oid": "cb7473b883cd599c1ee174972cb2c7c7357025b5", "url": "https://github.com/FabricMC/fabric/commit/cb7473b883cd599c1ee174972cb2c7c7357025b5", "message": "Merge remote-tracking branch 'fabric/1.15' into patch-1", "committedDate": "2020-05-03T18:07:32Z", "type": "commit"}, {"oid": "4ccaba718059f8407c11637fcb43d75d46ad322b", "url": "https://github.com/FabricMC/fabric/commit/4ccaba718059f8407c11637fcb43d75d46ad322b", "message": "testmod", "committedDate": "2020-05-03T18:37:28Z", "type": "commit"}, {"oid": "3965e2d55bd6839ccece77ff08f3d4fa956813ea", "url": "https://github.com/FabricMC/fabric/commit/3965e2d55bd6839ccece77ff08f3d4fa956813ea", "message": "fix formatting", "committedDate": "2020-05-03T18:40:27Z", "type": "commit"}, {"oid": "7b7f0d929948669409badc81d3479cae4b0b7bd1", "url": "https://github.com/FabricMC/fabric/commit/7b7f0d929948669409badc81d3479cae4b0b7bd1", "message": "fix testmod javadoc", "committedDate": "2020-05-03T18:43:47Z", "type": "commit"}, {"oid": "ed0cc48c00e2a9a5b7374c988979a58cbf868484", "url": "https://github.com/FabricMC/fabric/commit/ed0cc48c00e2a9a5b7374c988979a58cbf868484", "message": "forgot to license format testmod", "committedDate": "2020-05-04T04:18:12Z", "type": "commit"}, {"oid": "fb18cebd4e4059929505c70ce47dd9913bb280a3", "url": "https://github.com/FabricMC/fabric/commit/fb18cebd4e4059929505c70ce47dd9913bb280a3", "message": "Bump to 1.1.0", "committedDate": "2020-05-11T12:54:21Z", "type": "commit"}]}