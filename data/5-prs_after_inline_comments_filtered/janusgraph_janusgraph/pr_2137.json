{"pr_number": 2137, "pr_title": "Graph Reindexing Issue Fix", "pr_createdAt": "2020-06-16T14:51:20Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2137", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTY5Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115692", "bodyText": "seems to be unused.", "author": "farodin91", "createdAt": "2020-08-02T19:41:02Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+        getV(graph, c).remove();\n+        \n+    \tclose();\n+    }\n+    \n+\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindOut\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t//add Edge\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \tclose();\n+    }\n+\t\n+\tprivate void initReindexSchema() {\n+\t\tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"vtName\")) {\n+\t\t\tmgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"assocKind\")) {\n+\t\t\tmgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+\t\t}\n+\t}\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tGraphTraversal<Vertex, Edge> result = null; \n+    \t\n+    \tswitch(direction) {\n+    \tcase \"IN\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).inE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"OUT\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).outE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"BOTH\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).bothE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \t}\n+    \t\n+    \torg.junit.Assert.assertNotNull(\"Invalid Direction\",result);\n+    \tint noOfRelations=0;\n+    \twhile(result.hasNext()) {\n+    \t\tEdge next = result.next();\n+    \t\tJanusGraphVertex outVertex = (JanusGraphVertex)next.outVertex();", "originalCommit": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTcyMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115720", "bodyText": "could you use junit5 assertions.", "author": "farodin91", "createdAt": "2020-08-02T19:41:24Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+        getV(graph, c).remove();\n+        \n+    \tclose();\n+    }\n+    \n+\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindOut\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t//add Edge\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \tclose();\n+    }\n+\t\n+\tprivate void initReindexSchema() {\n+\t\tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"vtName\")) {\n+\t\t\tmgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+\t\t}\n+\t\t\n+\t\tif(!mgmt.containsPropertyKey(\"assocKind\")) {\n+\t\t\tmgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+\t\t}\n+\t}\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    \tassertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tGraphTraversal<Vertex, Edge> result = null; \n+    \t\n+    \tswitch(direction) {\n+    \tcase \"IN\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).inE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"OUT\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).outE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \tcase \"BOTH\":\n+    \t\tresult = g.V().has(vPropName , vPropValue).bothE().hasLabel(edgeLabel).has(edgeProperty,edgeValue);\n+    \t\tbreak;\n+    \t}\n+    \t\n+    \torg.junit.Assert.assertNotNull(\"Invalid Direction\",result);", "originalCommit": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464115826", "bodyText": "Why do you need to run remove?", "author": "farodin91", "createdAt": "2020-08-02T19:42:23Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,251 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+\t\n+\t@Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tgetV(graph, a).remove();\n+        getV(graph, b).remove();\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+    \tgetV(graph, a).remove();", "originalCommit": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MDk1Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464240957", "bodyText": "Im creating the vertex with same properties in other testcases also to test index with different directions. Hence removing the vertex after completion of every testcase to avoid conflicts.", "author": "shkrishn", "createdAt": "2020-08-03T07:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0NzA2Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464247062", "bodyText": "Tests in this class should be independent.", "author": "farodin91", "createdAt": "2020-08-03T07:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYwNTExNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555605116", "bodyText": "As @farodin91  suggested, please remove getV(graph, a).remove();, getV(graph, b).remove();\nPlease also remove close(). They are not needed.", "author": "li-boxuan", "createdAt": "2021-01-12T08:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjE0MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116141", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n          \n          \n            \n                            Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();", "author": "farodin91", "createdAt": "2020-08-02T19:45:04Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();", "originalCommit": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjE3NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116174", "bodyText": "spacing", "author": "farodin91", "createdAt": "2020-08-02T19:45:32Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); \n+                        }else if(pos==1) {\n+                        \t//Create IN edge index entry. Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                        \tInternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                        \tthrow new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\t\t//Mutating all OUT relationships for the current vertex", "originalCommit": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjIyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116223", "bodyText": "indent", "author": "farodin91", "createdAt": "2020-08-02T19:45:41Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); \n+                        }else if(pos==1) {\n+                        \t//Create IN edge index entry. Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                        \tInternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                        \tthrow new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\t\t//Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {\n+                \tStaticBuffer otherVertexKey = entry.getKey();", "originalCommit": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNjIzNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464116235", "bodyText": "indent", "author": "farodin91", "createdAt": "2020-08-02T19:45:59Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,45 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<StaticBuffer, List<Entry>>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                        \t//Create OUT edge index entry. Here source will the current vertex and target vertex the other side of the relation\n+                        \toutAdditions.add(entry); ", "originalCommit": "f618bc423afa793ec6bd0c9a7bb9224b013fc7e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MDcyNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464340727", "bodyText": "We use space instead of tabs.", "author": "farodin91", "createdAt": "2020-08-03T10:55:41Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+\t\t\t\t//Create OUT edge index entry. ", "originalCommit": "5ea2b19e585009dcc8c6d76c4ab399a2549c96fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0OTk0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464349942", "bodyText": "Replaced all tabs with spaces.", "author": "shkrishn", "createdAt": "2020-08-03T11:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM0MDcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1MzY0Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r464353646", "bodyText": "You can remove also close.", "author": "farodin91", "createdAt": "2020-08-03T11:26:36Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,240 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindIn\";\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tb.addEdge(\"egLabel\",a,\"assocKind\",2);\n+    \tnewTx();\n+    \t\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \t\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+    \tassertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+    \tassertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+    \tclose();\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexName = \"edgesByAssocKindBoth\";\n+    \t\n+    \t//Schema creation\n+    \tinitReindexSchema();\n+    \tEdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+    \tPropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+    \tmgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+    \tfinishSchema();\n+    \t\n+    \t//Create Vertex\n+    \tJanusGraphVertex a = tx.addVertex();\n+    \ta.property(\"vtName\",\"A\");\n+    \tJanusGraphVertex b = tx.addVertex();\n+    \tb.property(\"vtName\",\"B\");\n+    \tJanusGraphVertex c = tx.addVertex();\n+    \tc.property(\"vtName\",\"C\");\n+    \t\n+    \t//Add Edges\n+    \ta.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \ta.addEdge(\"egLabel\",c,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",a,\"assocKind\",1);\n+    \tc.addEdge(\"egLabel\",b,\"assocKind\",1);\n+    \tnewTx();\n+\n+    \tRelationType t = mgmt.getRelationType(\"egLabel\");\n+    \tRelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting before reindex\n+    \tassertEdgeCounts(false);\n+    \t\n+    \t//Reindexing\n+    \tmgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+    \tfinishSchema();\n+    \t\n+    \trelationIndex = mgmt.getRelationIndex(t,indexName);\n+    \tassertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+    \t\n+    \t//asserting after reindex\n+    \tassertEdgeCounts(true);\n+    \t\n+    \tGraphTraversalSource g = graph.traversal();\n+    \tVertex aV = g.V().has(\"vtName\" , \"A\").next();\n+    \tVertex bV = g.V().has(\"vtName\" , \"B\").next();\n+    \tVertex cV = g.V().has(\"vtName\" , \"C\").next();\n+    \t//assert the vertices of the given relation\n+    \tGraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+    \tEdge edge = has.next();\n+    \tassertEquals(1,edge.property(\"assocKind\").value());\n+    \tassertEquals(\"egLabel\",edge.label());\n+    \tassertEquals(cV.id(), edge.inVertex().id());\n+    \tassertEquals(aV.id(), edge.outVertex().id());\n+    \t\n+\t\tclose();", "originalCommit": "b17c5035da5c745ff4e08368134700ca744382e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkyNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493499926", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n          \n          \n            \n                                        InternalVertex otherVertex = janusgraphRelation.getVertex(1);", "author": "li-boxuan", "createdAt": "2020-09-23T11:55:21Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3MzI2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554073265", "bodyText": "code modified.", "author": "shkrishn", "createdAt": "2021-01-08T17:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5OTkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyNzUxNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493527515", "bodyText": "isReindexed parameter is not used. Anyway, you don't even need a whole method here. I suggest doing\ng.V().has(\"vtName\", \"A\").inE().hasLabel(\"egLabel\").has(\"assoKind\", 1).count().next()\ndirectly, wherever you currently use countOfEdges method.", "author": "li-boxuan", "createdAt": "2020-09-23T12:26:06Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(1,countOfEdges(\"vtName\", \"C\", \"IN\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+        assertEquals(2,countOfEdges(\"vtName\", \"C\", \"OUT\", \"egLabel\", \"assocKind\", 1, isReindexed));\n+    }\n+    \n+    public int countOfEdges(String vPropName, String vPropValue, String direction, String edgeLabel, String edgeProperty, int edgeValue, boolean isReindexed) {", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDMzMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074333", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "author": "shkrishn", "createdAt": "2021-01-08T17:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyNzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMjEzNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493532134", "bodyText": "When you put an ancillary method which is for one or more specific scenarios, you'd better not use a seemingly generic name like \"assertEdgeCounts\".", "author": "li-boxuan", "createdAt": "2020-09-23T12:30:57Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {\n+        if(!mgmt.containsEdgeLabel(\"egLabel\")){\n+            mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\n+        }\n+\n+        if(!mgmt.containsPropertyKey(\"vtName\")) {\n+            mgmt.makePropertyKey(\"vtName\").dataType(String.class).cardinality(Cardinality.SINGLE).make();\n+        }\n+\t\t\n+        if(!mgmt.containsPropertyKey(\"assocKind\")) {\n+            mgmt.makePropertyKey(\"assocKind\").dataType(Integer.class).cardinality(Cardinality.SINGLE).make();\t\n+        }\n+    }\n+    \n+    //To make sure no self links created\n+    public void assertEdgeCounts(boolean isReindexed) {", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NjU5Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554076593", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "author": "shkrishn", "createdAt": "2021-01-08T17:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMjEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNjgwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493536805", "bodyText": "Looks like the three test cases are very similar, except they have different directions. Can you put most of the common logic into one helper method, e.g. \"testReindexingForEdgeIndex(direction)\", and have 3 very short test cases that use that helper method?", "author": "li-boxuan", "createdAt": "2020-09-23T12:36:02Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDIzMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074233", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "author": "shkrishn", "createdAt": "2021-01-08T17:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MDQ1NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493540454", "bodyText": "Once you extract test logic into a single helper method, e.g. \"testReindexingForEdgeIndex(direction)\", then you should be able to put the preparation work in that method and dismiss this method.", "author": "li-boxuan", "createdAt": "2020-09-23T12:39:59Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6165,4 +6165,234 @@ private void testWritingAndReading(File f) {\n \n         assertEquals(1, g.V().has(\"name\", f.getName()).count().next());\n     }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionIN() throws InterruptedException, ExecutionException {\n+       clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindIn\";\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.IN, propAssocKind);\n+        finishSchema();\n+\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+    \t//asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    \t\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+    \t\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+    \n+    \n+    @Test\n+    public void testReindexingForEdgeIndexDirectionBOTH() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindBoth\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.BOTH, propAssocKind);\n+        finishSchema();\n+    \t\n+        //Create Vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        JanusGraphVertex c = tx.addVertex();\n+        c.property(\"vtName\",\"C\");\n+\n+        //Add Edges\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        a.addEdge(\"egLabel\",c,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",a,\"assocKind\",1);\n+        c.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEdgeCounts(false);\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+        \n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEdgeCounts(true);\n+\n+        GraphTraversalSource g = graph.traversal();\n+        Vertex aV = g.V().has(\"vtName\" , \"A\").next();\n+        Vertex bV = g.V().has(\"vtName\" , \"B\").next();\n+        Vertex cV = g.V().has(\"vtName\" , \"C\").next();\n+        //assert the vertices of the given relation\n+        GraphTraversal<Vertex, Edge> has = g.V().has(\"vtName\" , \"C\").inE().hasLabel(\"egLabel\").has(\"assocKind\",1);\n+        Edge edge = has.next();\n+        assertEquals(1,edge.property(\"assocKind\").value());\n+        assertEquals(\"egLabel\",edge.label());\n+        assertEquals(cV.id(), edge.inVertex().id());\n+        assertEquals(aV.id(), edge.outVertex().id());    \t\n+   }\n+    \n+\n+    @Test\n+    public void testReindexingForEdgeIndexDirectionOUT() throws InterruptedException, ExecutionException {\n+        clopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+        String indexName = \"edgesByAssocKindOut\";\n+\n+        //Schema creation\n+        initReindexSchema();\n+        EdgeLabel edgeLabel = mgmt.getEdgeLabel(\"egLabel\");\n+        PropertyKey propAssocKind = mgmt.getPropertyKey(\"assocKind\");\n+        mgmt.buildEdgeIndex(edgeLabel, indexName, Direction.OUT, propAssocKind);\n+        finishSchema();\n+\n+        //Create vertex\n+        JanusGraphVertex a = tx.addVertex();\n+        a.property(\"vtName\",\"A\");\n+        JanusGraphVertex b = tx.addVertex();\n+        b.property(\"vtName\",\"B\");\n+        //add Edge\n+        a.addEdge(\"egLabel\",b,\"assocKind\",1);\n+        b.addEdge(\"egLabel\",a,\"assocKind\",2);\n+        newTx();\n+\n+        RelationType t = mgmt.getRelationType(\"egLabel\");\n+        RelationTypeIndex relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+        \n+        //asserting before reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+\n+        //Reindexing\n+        mgmt.updateIndex(relationIndex, SchemaAction.REINDEX).get();\n+        finishSchema();\n+\n+        relationIndex = mgmt.getRelationIndex(t,indexName);\n+        assertEquals(SchemaStatus.ENABLED, relationIndex.getIndexStatus());\n+\n+        //asserting after reindex\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"A\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 1, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"IN\", \"egLabel\", \"assocKind\", 2, false));\n+        assertEquals(0,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 1,false));\n+        assertEquals(1,countOfEdges(\"vtName\", \"B\", \"OUT\", \"egLabel\", \"assocKind\", 2,false));\n+    }\n+\t\n+    private void initReindexSchema() {", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDE4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074186", "bodyText": "testcase removed as this seems to be unnecessary for this PR", "author": "shkrishn", "createdAt": "2021-01-08T17:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MjA0Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493542047", "bodyText": "IllegalStateException sounds more suitable to me.", "author": "li-boxuan", "createdAt": "2020-09-23T12:41:33Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0NTcyNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493545725", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                totalInAdditions = inAdditions.size();\n          \n          \n            \n                                totalInAdditions += inAdditions.size();", "author": "li-boxuan", "createdAt": "2020-09-23T12:45:13Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {\n+                    StaticBuffer otherVertexKey = entry.getKey();\n+                    List<Entry> inAdditions = entry.getValue();\n+                    totalInAdditions = inAdditions.size();", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NjQ0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554076442", "bodyText": "code modified", "author": "shkrishn", "createdAt": "2021-01-08T17:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0NTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0Nzg5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r493547891", "bodyText": "Can be just Map.Entry, since you have Map imported.", "author": "li-boxuan", "createdAt": "2020-09-23T12:47:25Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex((pos) % 2);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);\n+                        }else {\n+                            throw new IllegalArgumentException(\"Invalid position:\" + pos);\n+                        }\n+\t\t\t\t\t\t \n                     }\n                 }\n+\t\t\n+                //Mutating all OUT relationships for the current vertex\n                 StaticBuffer vertexKey = writeTx.getIdInspector().getKey(vertex.longId());\n-                mutator.mutateEdges(vertexKey, additions, KCVSCache.NO_DELETIONS);\n-                metrics.incrementCustom(ADDED_RECORDS_COUNT, additions.size());\n+                mutator.mutateEdges(vertexKey, outAdditions, KCVSCache.NO_DELETIONS);\n+                \n+                //Mutating all IN relationships for the current vertex\n+                int totalInAdditions = 0;\n+                for(java.util.Map.Entry<StaticBuffer, List<Entry>> entry : inAdditionsMap.entrySet()) {", "originalCommit": "457f0a30e963e273cdf3f9631ce54b206760d236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDA3NDg5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r554074890", "bodyText": "code modified", "author": "shkrishn", "createdAt": "2021-01-08T17:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0Nzg5MQ=="}], "type": "inlineReview"}, {"oid": "0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "url": "https://github.com/JanusGraph/janusgraph/commit/0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "message": "minor code fix\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>", "committedDate": "2021-01-08T17:15:20Z", "type": "forcePushed"}, {"oid": "3fbfc589d583b7e13881ca345e117bd344cd3c18", "url": "https://github.com/JanusGraph/janusgraph/commit/3fbfc589d583b7e13881ca345e117bd344cd3c18", "message": "Removed sysouts\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>", "committedDate": "2021-01-09T08:04:11Z", "type": "forcePushed"}, {"oid": "0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "url": "https://github.com/JanusGraph/janusgraph/commit/0b732b82ca769ac65179261db9fdbec2b7e6f6ef", "message": "minor code fix\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>", "committedDate": "2021-01-08T17:15:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYzODMwOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555638308", "bodyText": "The clopen here is not needed.", "author": "li-boxuan", "createdAt": "2021-01-12T09:45:36Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );", "originalCommit": "91c7be1b61e3efbfe9998703d4a973e62931b272", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgzNzk0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r557837942", "bodyText": "removed", "author": "shkrishn", "createdAt": "2021-01-15T03:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTYzODMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcwOTMxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555709318", "bodyText": "No need to check. You can just create edge labels, property keys, etc. directly.", "author": "li-boxuan", "createdAt": "2021-01-12T11:42:12Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){", "originalCommit": "91c7be1b61e3efbfe9998703d4a973e62931b272", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgzODc3MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r557838771", "bodyText": "done.", "author": "shkrishn", "createdAt": "2021-01-15T03:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTcwOTMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc3MzMxMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r555773313", "bodyText": "You can do this:\nEdgeLabel edgeLabel = mgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();\nso that you don't need to call getEdgeLabel later. Similar for property keys.", "author": "li-boxuan", "createdAt": "2021-01-12T13:35:40Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -6394,4 +6394,117 @@ public void testExistsMatchingIndex() {\n         // test with invalid filter\n         assertEquals(false, IndexSelectionUtil.existsMatchingIndex(conditions, null));\n     }\n+    \n+    @Test\n+    public void testReindexingForEdgeIndex() throws InterruptedException, ExecutionException {\n+    \tclopen(option(LOG_SEND_DELAY, MANAGEMENT_LOG), Duration.ofMillis(0),\n+                option(KCVSLog.LOG_READ_LAG_TIME, MANAGEMENT_LOG), Duration.ofMillis(50),\n+                option(LOG_READ_INTERVAL, MANAGEMENT_LOG), Duration.ofMillis(250)\n+        );\n+    \t\n+    \tString indexWithDirectionIn = \"edgesByAssocKindIn\";\n+    \tString indexwithDirectionOut = \"edgesByAssocKindOut\";\n+    \tString indexWithDirectionBoth = \"edgesByAssocKindBoth\";\n+    \t\n+    \tString propertyKeyForIn = \"assocKindForIn\";\n+    \tString propertyKeyForOut = \"assocKindForOut\";\n+    \tString propertyKeyForBoth = \"assocKindForBoth\";\n+    \t\n+    \t\n+    \t//Schema creation\n+    \tif(!mgmt.containsEdgeLabel(\"egLabel\")){\n+\t\t\tmgmt.makeEdgeLabel(\"egLabel\").multiplicity(Multiplicity.MULTI).make();", "originalCommit": "91c7be1b61e3efbfe9998703d4a973e62931b272", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgzOTE1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r557839153", "bodyText": "done.", "author": "shkrishn", "createdAt": "2021-01-15T03:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc3MzMxMw=="}], "type": "inlineReview"}, {"oid": "52037fbd217e62b6dce1d5a84f55b0889d80d297", "url": "https://github.com/JanusGraph/janusgraph/commit/52037fbd217e62b6dce1d5a84f55b0889d80d297", "message": "Enhance GraphCentricQuery profiling\n\n1. Indicate \"constructGraphCentricQuery\" phase in profiler rather than a vague\n\"optimization\" annotation, if applicable.\n2. Indicate \"GraphCentricQuery\" in profiler if applicable. Previously profiling result\nis corrupted when a gremlin query is satisfied by multiple graph centric queries.\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-01-29T12:45:09Z", "type": "forcePushed"}, {"oid": "23ca9a20ecea3baad93b292c2c0cb93a1134c238", "url": "https://github.com/JanusGraph/janusgraph/commit/23ca9a20ecea3baad93b292c2c0cb93a1134c238", "message": "Bug fix related to graph reindexing\n\nSigned-off-by: Shivaa Krishnan <shkrishnan@informatica.com>", "committedDate": "2021-01-30T08:47:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r567222927", "bodyText": "I find that your test case testReindexingForEdgeIndex will pass even if I remove this whole \"else\" branch. There are two possibilities:\n\nYour test case is not effective enough to cover the edge case\nThis is actually not needed. Maybe only the case where pos == 0 is needed.\n\nCan you please investigate if you have some time? Otherwise, I'll take a look later.", "author": "li-boxuan", "createdAt": "2021-01-30T09:27:47Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/job/IndexRepairJob.java", "diffHunk": "@@ -124,20 +125,48 @@ public void process(JanusGraphVertex vertex, ScanMetrics metrics) {\n                 RelationTypeIndexWrapper wrapper = (RelationTypeIndexWrapper)index;\n                 InternalRelationType wrappedType = wrapper.getWrappedType();\n                 EdgeSerializer edgeSerializer = writeTx.getEdgeSerializer();\n-                List<Entry> additions = new ArrayList<>();\n-\n+                List<Entry> outAdditions = new ArrayList<>();\n+                Map<StaticBuffer,List<Entry>> inAdditionsMap = new HashMap<>();\n+                \n                 for (Object relation : vertex.query().types(indexRelationTypeName).direction(Direction.OUT).relations()) {\n                     InternalRelation janusgraphRelation = (InternalRelation) relation;\n                     for (int pos = 0; pos < janusgraphRelation.getArity(); pos++) {\n                         if (!wrappedType.isUnidirected(Direction.BOTH) && !wrappedType.isUnidirected(EdgeDirection.fromPosition(pos)))\n                             continue; //Directionality is not covered\n+\n                         Entry entry = edgeSerializer.writeRelation(janusgraphRelation, wrappedType, pos, writeTx);\n-                        additions.add(entry);\n+                        \n+                        //The below condition is check to avoid self-links which is getting created after re-indexing\n+                        if(pos==0) {\n+                            //Create OUT edge index entry. \n+                            //Here source will the current vertex and target vertex the other side of the relation \n+                            outAdditions.add(entry); \n+                        }else if(pos==1) {\n+                            //Create IN edge index entry.\n+                            //Here the source vertex is the other side of the current vertex and target will be the current vertex\n+                            InternalVertex otherVertex = janusgraphRelation.getVertex(1);\n+                            StaticBuffer otherVertexKey = writeTx.getIdInspector().getKey(otherVertex.longId());\n+                            inAdditionsMap.computeIfAbsent(otherVertexKey, k -> new ArrayList<Entry>()).add(entry);", "originalCommit": "23ca9a20ecea3baad93b292c2c0cb93a1134c238", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIzNDkwOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r567234908", "bodyText": "@li-boxuan  Sure i ll look into this issue.", "author": "shkrishn", "createdAt": "2021-01-30T11:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTcxNDE2Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2137#discussion_r599714162", "bodyText": "Your fix is correct. It's just that your test case is not effective enough. I can provide a subsequent PR to improve the tests.", "author": "li-boxuan", "createdAt": "2021-03-23T16:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzIyMjkyNw=="}], "type": "inlineReview"}]}