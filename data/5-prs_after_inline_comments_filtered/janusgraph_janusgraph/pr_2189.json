{"pr_number": 2189, "pr_title": "Optimize adjacency checks with unique index", "pr_createdAt": "2020-08-24T12:26:41Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2189", "timeline": [{"oid": "b2b3f95aa644e355cbbcf90a9866a82cc1eb5177", "url": "https://github.com/JanusGraph/janusgraph/commit/b2b3f95aa644e355cbbcf90a9866a82cc1eb5177", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-24T12:28:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2NDI1Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r475564256", "bodyText": "At this point, I'm not entirely sure if the filterTraversal uses the same transaction as the surrounding traversal. Does anyone know off the top of their heads, how such an access is handled by JanusGraph? And if not, can you hint me, where I have to look for it? So far, I was not able to find out, whether the same transaction is reused.", "author": "rngcntr", "createdAt": "2020-08-24T12:31:22Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/LazyHasStep.java", "diffHunk": "@@ -0,0 +1,54 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.TraversalParent;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.structure.Element;\n+import org.apache.tinkerpop.gremlin.structure.util.StringFactory;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class LazyHasStep<S extends Element, E> extends HasStep<S> implements TraversalParent {\n+\n+    private final Traversal.Admin<? extends Element, E> filterTraversal;\n+\n+    public LazyHasStep(Traversal.Admin traversal,\n+                       final Traversal<? extends Element, E> filterTraversal) {\n+        super(traversal);\n+        this.filterTraversal = filterTraversal.asAdmin();\n+        integrateChild(this.filterTraversal);\n+\n+        HasContainer hc = new LazyHasContainer(ADJACENT_ID.name(), this::initializeFilter);\n+        this.addHasContainer(hc);\n+    }\n+\n+    private P<?> initializeFilter() {\n+        if (filterTraversal.hasNext()) {\n+            return P.eq(filterTraversal.next());", "originalCommit": "b2b3f95aa644e355cbbcf90a9866a82cc1eb5177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2ODM3NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r478268375", "bodyText": "While verifying that both traversals use the same transaction, I realized that not only those two transactions are equal. The same transaction is actually used in the optimization phase. With this knowledge, there is no need to wait until runtime before evaluating the filterTraversal. The matching ID can already be retrieved at optimization time and embedded into the query.\nThat makes the optimization much easier and also drops the need for custom classes like LazyHasStep and LazyHasContainer.", "author": "rngcntr", "createdAt": "2020-08-27T09:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2NDI1Ng=="}], "type": "inlineReview"}, {"oid": "df5fda521ffb089bca6214d09f1ec6d950da357b", "url": "https://github.com/JanusGraph/janusgraph/commit/df5fda521ffb089bca6214d09f1ec6d950da357b", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-24T12:42:28Z", "type": "forcePushed"}, {"oid": "728ff9c30ecb7cca7614b18b852bbab721d656bd", "url": "https://github.com/JanusGraph/janusgraph/commit/728ff9c30ecb7cca7614b18b852bbab721d656bd", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-25T06:15:34Z", "type": "forcePushed"}, {"oid": "8046d08c8fae522d9a056381109869e7101a8302", "url": "https://github.com/JanusGraph/janusgraph/commit/8046d08c8fae522d9a056381109869e7101a8302", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-25T13:06:33Z", "type": "forcePushed"}, {"oid": "78de033da86639b8fab737281cbb8d01f587a088", "url": "https://github.com/JanusGraph/janusgraph/commit/78de033da86639b8fab737281cbb8d01f587a088", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-27T08:08:08Z", "type": "forcePushed"}, {"oid": "4822c15868f084ed876ed02f459a202c5a3ead38", "url": "https://github.com/JanusGraph/janusgraph/commit/4822c15868f084ed876ed02f459a202c5a3ead38", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-27T08:58:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxOTk4NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479419984", "bodyText": "Maybe you can put the selection logic into a new class that implements IndexSelectionStrategy interface", "author": "li-boxuan", "createdAt": "2020-08-28T16:45:32Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.graphdb.internal.InternalRelationType;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx;\n+\n+        try {\n+            tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+        } catch (IllegalArgumentException iaex) {\n+            // The traversal needs to be bound to a graph in order to get information about the indexes\n+            return false;\n+        }\n+\n+        List<String> givenKeys = step.getHasContainers().stream()\n+            .map(HasContainer::getKey).collect(Collectors.toList());\n+\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = step.getHasContainers().stream()\n+            .filter(hc -> hc.getBiPredicate() == Compare.eq)\n+            .map(hc -> new PredicateCondition<>(hc.getKey(), JanusGraphPredicateUtils.convert(hc.getBiPredicate()), hc.getValue()))\n+            .collect(Collectors.toList());\n+        final MultiCondition<JanusGraphElement> conditions = QueryUtil.constraints2QNF(tx, constraints);\n+\n+        // collect all matching indexes\n+        final Set<IndexType> availableIndexes = new HashSet<>();\n+        ConditionUtil.traversal(conditions, condition -> {\n+            if (condition instanceof PredicateCondition) {\n+                final RelationType type = ((PredicateCondition<RelationType,JanusGraphElement>) condition).getKey();\n+                Preconditions.checkArgument(type != null && type.isPropertyKey());\n+                Iterables.addAll(availableIndexes, ((InternalRelationType) type).getKeyIndexes());\n+            }\n+            return true;\n+        });\n+\n+        // select only valid unique indexes\n+        return availableIndexes.stream()", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5NTMwNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479895304", "bodyText": "Will look into that. I'd also like to move the code that gathers all available indexes for a property to QueryUtil.java ore somewhere it makes more sense and can be used more widely.", "author": "rngcntr", "createdAt": "2020-08-31T05:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxOTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMDQ2Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479420466", "bodyText": "When would IllegalArgumentException happen? I don't quite understand the logic here.", "author": "li-boxuan", "createdAt": "2020-08-28T16:46:29Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.graphdb.internal.InternalRelationType;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx;\n+\n+        try {\n+            tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+        } catch (IllegalArgumentException iaex) {\n+            // The traversal needs to be bound to a graph in order to get information about the indexes", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5Njk1NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479896954", "bodyText": "It works perfectly fine without the try...catch block except for a single TinkerPop test class which somehow creates traversals which are not bound to a graph. I didn't try to find out how or why these traversals are created that way. But as the getTx(...) method explicitly checks if the traversal is bound to a graph, it looks to me like a valid case to have an unbound traversal.\nMy first plan was to avoid exception handling but then I would have to duplicate most of the code from getTx(...). That's why I went with try...catch.", "author": "rngcntr", "createdAt": "2020-08-31T05:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5NzUzMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479897532", "bodyText": "On second thought: I can try to extract only the line traversal.getGraph().isPresent() and see if that's already sufficient. Just saw that this is how other optimizers handle such cases.", "author": "rngcntr", "createdAt": "2020-08-31T05:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5NDc4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479994780", "bodyText": "Confirmed that it works like I described in the comment above.", "author": "rngcntr", "createdAt": "2020-08-31T09:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMzYyNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479423627", "bodyText": "Can you profile these optimizations if possible? They could take some time (especially the index selection part). Profiling also makes it clear to users whether this optimization is applied or not.", "author": "li-boxuan", "createdAt": "2020-08-28T16:52:47Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -56,21 +51,18 @@\n     }\n \n     protected void optimizeStep(T step) {\n-        P<?> predicate = parsePredicate(step);\n-        if (isValidPredicate(predicate)) {\n-            OptimizablePosition pos = getOptimizablePosition(step);\n-            replaceSequence(step, pos, predicate);\n+        OptimizablePosition pos = getOptimizablePosition(step);\n+        if (pos != OptimizablePosition.NONE && isValidStep(step)) {\n+            replaceSequence(step, pos);", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg5OTEwMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479899101", "bodyText": "By profiling, do you mean to investigate the output of query.profile()? Or something else that I miss?", "author": "rngcntr", "createdAt": "2020-08-31T05:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI0OTM0MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480249341", "bodyText": "Oh I mean you should make the query.profile() result contain the optimization latency here.", "author": "li-boxuan", "createdAt": "2020-08-31T16:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479595719", "bodyText": "I'm not 100% sure but I think you need to add labels of the original step to this new step. Better have a test case to verify.", "author": "li-boxuan", "createdAt": "2020-08-29T02:23:39Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasIdOptimizerStrategy.java", "diffHunk": "@@ -73,4 +77,10 @@ protected boolean isValidPredicate(P<?> predicate) {\n         Object predicateValue = predicate.getValue();\n         return predicateValue instanceof Vertex || predicateValue instanceof Long;\n     }\n+\n+    @Override\n+    protected FilterStep<Edge> makeFilterByAdjacentIdStep(Traversal.Admin<?, ?> traversal, HasStep<?> originalStep) {\n+        HasContainer hc = new HasContainer(ADJACENT_ID.name(), P.eq(parsePredicate(originalStep).getValue()));\n+        return new HasStep<Edge>(traversal, hc);", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkwOTU5Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479909597", "bodyText": "Labels are not needed in this case because the ID is unique even across labels. What we do need is the edge label, but this is already contained in the preceeding in()/out() step.\nYour comment howewer pointed me to the edge layout docs page where I realized we should check if there is a sort key defined for the given edge label before optimizing. Because as one can see, only when the sort key is empty, the sort order will be defined by the IDs.", "author": "rngcntr", "createdAt": "2020-08-31T05:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI2MjAwMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480262003", "bodyText": "Oh, I meant by label() step in gremlin query, not vertex label or edge label. \ud83d\ude09", "author": "li-boxuan", "createdAt": "2020-08-31T16:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgxMjM2MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480812360", "bodyText": "Can you give an example of a query where you think a label() step would be relevant? I can't think of one", "author": "rngcntr", "createdAt": "2020-09-01T05:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgyNjY2Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480826667", "bodyText": "Regarding the sort key, applying the optimization is still advantageouos even with sort keys defined. This may cause a linear search across the edges for the one with the correct ID but this if of course still faster than a linear search across the neighbors with the correct property value.", "author": "rngcntr", "createdAt": "2020-09-01T05:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIxMTMzMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r481211332", "bodyText": "whoops sorry, I meant by as(stepLabel) step, e.g. g.V(vertex).out().has(\"key\", \"value\").as(\"v\").addE(\"connects\").from(\"v\").next()", "author": "li-boxuan", "createdAt": "2020-09-01T15:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIzNDIxMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r484234212", "bodyText": "Finally coming back to this. Very interesting thought, but I think as the only thing that we actually replace are has steps, step labels should not interfere. The TinkerPop documentation shows various usages of the has step. Most of them use only literal values which cannot be derived from step labels. The only exceptions are:\n\nhas(key, predicate) which is ok because predicates also only take literal values.\nhas(key, traversal) which is also ok because nested traversals don't have access to the surrounding traversal's step labels in the original query either.", "author": "rngcntr", "createdAt": "2020-09-07T07:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcwMzg3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r485703870", "bodyText": "I am not sure if I got you, but let me explain what I am worried about:\nLet's say we have a normal query:\ng.V(v1).as(\"v1\").out().has(\"prop\", \"value2\").as(\"v2\").select(\"v1\", \"v2\").by(\"prop\")\nI suspect that with your change, it would be translated to something equivalent to  (note the missing 'as(\"v2\")' step):\ng.V(v1).as(\"v1\").out().hasId(v2).select(\"v1\", \"v2\").by(\"prop\")\nwhich leads to the wrong result.", "author": "li-boxuan", "createdAt": "2020-09-09T15:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExMDUyNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r486110525", "bodyText": "Yes, you were right. What I thought about was the impact of labels for the has step not on the has step. I wrote a test to verify this and indeed had to fix two lines.\nGlad you found that because two existing strategies were also affected.", "author": "rngcntr", "createdAt": "2020-09-10T07:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxMzk2OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r487013969", "bodyText": "Do you mean the same problem exists in two strategies released in v0.5? If that's the case, I suggest you open up a separate PR to fix them, in case this PR cannot be merged in the next release.", "author": "li-boxuan", "createdAt": "2020-09-11T12:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY2MTIyMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r487661220", "bodyText": "Sounds like the right thing to do", "author": "rngcntr", "createdAt": "2020-09-14T05:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NjkxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479596918", "bodyText": "If the filterTraversal has no result, then the previous step (out(), in(), ...) becomes unnecessary too. It can bring huge performance improvement in the super-node context I guess. This could be potentially optimized.", "author": "li-boxuan", "createdAt": "2020-08-29T02:38:00Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.graphdb.internal.InternalRelationType;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx;\n+\n+        try {\n+            tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+        } catch (IllegalArgumentException iaex) {\n+            // The traversal needs to be bound to a graph in order to get information about the indexes\n+            return false;\n+        }\n+\n+        List<String> givenKeys = step.getHasContainers().stream()\n+            .map(HasContainer::getKey).collect(Collectors.toList());\n+\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = step.getHasContainers().stream()\n+            .filter(hc -> hc.getBiPredicate() == Compare.eq)\n+            .map(hc -> new PredicateCondition<>(hc.getKey(), JanusGraphPredicateUtils.convert(hc.getBiPredicate()), hc.getValue()))\n+            .collect(Collectors.toList());\n+        final MultiCondition<JanusGraphElement> conditions = QueryUtil.constraints2QNF(tx, constraints);\n+\n+        // collect all matching indexes\n+        final Set<IndexType> availableIndexes = new HashSet<>();\n+        ConditionUtil.traversal(conditions, condition -> {\n+            if (condition instanceof PredicateCondition) {\n+                final RelationType type = ((PredicateCondition<RelationType,JanusGraphElement>) condition).getKey();\n+                Preconditions.checkArgument(type != null && type.isPropertyKey());\n+                Iterables.addAll(availableIndexes, ((InternalRelationType) type).getKeyIndexes());\n+            }\n+            return true;\n+        });\n+\n+        // select only valid unique indexes\n+        return availableIndexes.stream()\n+            .filter(IndexType::isCompositeIndex)\n+            .map(index -> (CompositeIndexType) index)\n+            .filter(cIndex -> cIndex.getCardinality() == Cardinality.SINGLE)\n+            .filter(cIndex -> isIndexSatisfiedByGivenKeys(cIndex, givenKeys))\n+            .count() > 0;\n+    }\n+\n+    private boolean isIndexSatisfiedByGivenKeys(IndexType index, Collection<String> givenKeys) {\n+        for (int i = 0; i < index.getFieldKeys().length; ++i) {\n+            if (!givenKeys.contains(index.getFieldKeys()[i].getFieldKey().name())) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Traversal.Admin<?,Long> generateFilter(Traversal.Admin<?,?> traversal, HasStep<?> originalStep) {\n+        Traversal.Admin filterTraversal = new DefaultGraphTraversal<>(traversal.getGraph().get())\n+            .addStep(\n+                new GraphStep<>(traversal, Vertex.class, true)\n+            );\n+\n+        filterTraversal.addStep(originalStep);\n+        filterTraversal.addStep(new IdStep<>(traversal));\n+        return filterTraversal;\n+    }\n+\n+    private long evaluateFilter(Traversal.Admin<?,Long> filterTraversal) {\n+        // negative IDs are not valid in JanusGraph. Therefore, if the filterTraversal has no result, the newly", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxMTMyNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479911325", "bodyText": "Agreed. Although it would be an outE(), inE(),... step instead of out(), in(), ... which is not as bad performance wise. But still bad :D\nSo I think the cleanest way to so is to create a new strategy which eliminates traversals with unsatisfiable conditions within them completely. Sounds nice to me \ud83d\ude01", "author": "rngcntr", "createdAt": "2020-08-31T06:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NzE5NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479597194", "bodyText": "I suspect this should be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    filterTraversal.addStep(new IdStep<>(traversal));\n          \n          \n            \n                    filterTraversal.addStep(new IdStep<>(filterTraversal));", "author": "li-boxuan", "createdAt": "2020-08-29T02:41:11Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.graphdb.internal.InternalRelationType;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx;\n+\n+        try {\n+            tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+        } catch (IllegalArgumentException iaex) {\n+            // The traversal needs to be bound to a graph in order to get information about the indexes\n+            return false;\n+        }\n+\n+        List<String> givenKeys = step.getHasContainers().stream()\n+            .map(HasContainer::getKey).collect(Collectors.toList());\n+\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = step.getHasContainers().stream()\n+            .filter(hc -> hc.getBiPredicate() == Compare.eq)\n+            .map(hc -> new PredicateCondition<>(hc.getKey(), JanusGraphPredicateUtils.convert(hc.getBiPredicate()), hc.getValue()))\n+            .collect(Collectors.toList());\n+        final MultiCondition<JanusGraphElement> conditions = QueryUtil.constraints2QNF(tx, constraints);\n+\n+        // collect all matching indexes\n+        final Set<IndexType> availableIndexes = new HashSet<>();\n+        ConditionUtil.traversal(conditions, condition -> {\n+            if (condition instanceof PredicateCondition) {\n+                final RelationType type = ((PredicateCondition<RelationType,JanusGraphElement>) condition).getKey();\n+                Preconditions.checkArgument(type != null && type.isPropertyKey());\n+                Iterables.addAll(availableIndexes, ((InternalRelationType) type).getKeyIndexes());\n+            }\n+            return true;\n+        });\n+\n+        // select only valid unique indexes\n+        return availableIndexes.stream()\n+            .filter(IndexType::isCompositeIndex)\n+            .map(index -> (CompositeIndexType) index)\n+            .filter(cIndex -> cIndex.getCardinality() == Cardinality.SINGLE)\n+            .filter(cIndex -> isIndexSatisfiedByGivenKeys(cIndex, givenKeys))\n+            .count() > 0;\n+    }\n+\n+    private boolean isIndexSatisfiedByGivenKeys(IndexType index, Collection<String> givenKeys) {\n+        for (int i = 0; i < index.getFieldKeys().length; ++i) {\n+            if (!givenKeys.contains(index.getFieldKeys()[i].getFieldKey().name())) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Traversal.Admin<?,Long> generateFilter(Traversal.Admin<?,?> traversal, HasStep<?> originalStep) {\n+        Traversal.Admin filterTraversal = new DefaultGraphTraversal<>(traversal.getGraph().get())\n+            .addStep(\n+                new GraphStep<>(traversal, Vertex.class, true)\n+            );\n+\n+        filterTraversal.addStep(originalStep);\n+        filterTraversal.addStep(new IdStep<>(traversal));", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxMTU0Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479911543", "bodyText": "Good catch!", "author": "rngcntr", "createdAt": "2020-08-31T06:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NzgwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479597805", "bodyText": "I suggest using Traversal.Admin<S2, E2> removeStep(final int index) here or moving this before makeFilterByAdjacentIdStep .  removeStep(originalStep) internally traverses all steps and compare with originalStep. However, since this originalStep is passed into another filterTraversal, it has a risk of getting modified.", "author": "li-boxuan", "createdAt": "2020-08-29T02:48:41Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -90,37 +82,36 @@ private OptimizablePosition getOptimizablePosition(T originalStep) {\n         return OptimizablePosition.NONE;\n     }\n \n-    private void replaceSequence(T originalStep, OptimizablePosition pos,\n-                                   P<?> predicate) {\n+    private void replaceSequence(T originalStep, OptimizablePosition pos) {\n         switch (pos) {\n         case V2E_E2V_ID:\n-            replaceSequenceV2EthenE2VthenID(originalStep, predicate);\n+            replaceSequenceV2EthenE2VthenID(originalStep);\n             break;\n         case V2V_ID:\n-            replaceSequenceV2VthenID(originalStep, predicate);\n+            replaceSequenceV2VthenID(originalStep);\n             break;\n         default:\n             break;\n         }\n     }\n \n-    private void replaceSequenceV2EthenE2VthenID(T originalStep, P<?> predicate) {\n+    private void replaceSequenceV2EthenE2VthenID(T originalStep) {\n         Traversal.Admin<?,?> traversal = originalStep.getTraversal();\n \n         Step<Edge,Vertex> e2vStep;\n         e2vStep = (Step<Edge, Vertex>) originalStep.getPreviousStep();\n \n         // create new has(\"~adjacent\", id_value) step before e2v step\n-        HasStep<Edge> hasAdjacentIdStep = makeHasAdjacentIdStep(traversal, predicate);\n+        FilterStep<Edge> filterByAdjacentIdStep = makeFilterByAdjacentIdStep(traversal, originalStep);\n \n         // remove original selection step\n         traversal.removeStep(originalStep);", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxNTExNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479915114", "bodyText": "First of all, I don't know where I would get the exact step position from, in order to use removeStep(final int index). My only idea would be to iterate all steps myself.\nAnd in addition, I'm not sure why it would be better to delete the old step beforehand. Notice that the new step is not added to the query at this point so it makes no difference when comparing all steps of the traversal.", "author": "rngcntr", "createdAt": "2020-08-31T06:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI2MDg4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480260886", "bodyText": "I agree at the moment, putting this step beforehand makes no difference. What I meant was:\nWe know that removeStep(originalStep) essentially traverses all steps and compares the steps with originalStep using equals() method. We have to ensure originalStep is not modified after we extract it from the traversal, otherwise equals() will always return false.\nIn the last operation, FilterStep<Edge> filterByAdjacentIdStep = makeFilterByAdjacentIdStep(traversal, originalStep);, the originalStep is passed in as a parameter. Within that function, originalStep is added to a new ad-hoc traversal. This means, originalStep is in fact shared by the original traversal and the nested ad-hoc traversal. As discussed above, we have to make sure this originalStep is not mutated in the nested ad-hoc traversal, otherwise it cannot be correctly removed from the original traversal afterward. This sounds a bit risky to me because I don't see a way to enforce this \"contract\".\nUsing an analogy below, this is a competition between\nList<Object> list = new ArrayList<>(Arrays.asList(obj1, obj2));\nrunFunc(obj1);    // a function call that arguably might mutate obj1\nlist.remove(obj1);\nvs\nList<Object> list = new ArrayList<>(Arrays.asList(obj1, obj2));\nlist.remove(obj1);\nrunFunc(obj1);", "author": "li-boxuan", "createdAt": "2020-08-31T16:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgwNDc3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480804776", "bodyText": "Now I understand you and what you say makes perfect sense. Thanks for clarification!", "author": "rngcntr", "createdAt": "2020-09-01T04:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5NzgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479597893", "bodyText": "If I am understanding it correctly, this creates a new ad-hoc traversal which leverages JanusGraphStepStrategy and GraphCentricQuery. We need to profile it, especially because it fires a backend query.", "author": "li-boxuan", "createdAt": "2020-08-29T02:49:45Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.graphdb.internal.InternalRelationType;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx;\n+\n+        try {\n+            tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+        } catch (IllegalArgumentException iaex) {\n+            // The traversal needs to be bound to a graph in order to get information about the indexes\n+            return false;\n+        }\n+\n+        List<String> givenKeys = step.getHasContainers().stream()\n+            .map(HasContainer::getKey).collect(Collectors.toList());\n+\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = step.getHasContainers().stream()\n+            .filter(hc -> hc.getBiPredicate() == Compare.eq)\n+            .map(hc -> new PredicateCondition<>(hc.getKey(), JanusGraphPredicateUtils.convert(hc.getBiPredicate()), hc.getValue()))\n+            .collect(Collectors.toList());\n+        final MultiCondition<JanusGraphElement> conditions = QueryUtil.constraints2QNF(tx, constraints);\n+\n+        // collect all matching indexes\n+        final Set<IndexType> availableIndexes = new HashSet<>();\n+        ConditionUtil.traversal(conditions, condition -> {\n+            if (condition instanceof PredicateCondition) {\n+                final RelationType type = ((PredicateCondition<RelationType,JanusGraphElement>) condition).getKey();\n+                Preconditions.checkArgument(type != null && type.isPropertyKey());\n+                Iterables.addAll(availableIndexes, ((InternalRelationType) type).getKeyIndexes());\n+            }\n+            return true;\n+        });\n+\n+        // select only valid unique indexes\n+        return availableIndexes.stream()\n+            .filter(IndexType::isCompositeIndex)\n+            .map(index -> (CompositeIndexType) index)\n+            .filter(cIndex -> cIndex.getCardinality() == Cardinality.SINGLE)\n+            .filter(cIndex -> isIndexSatisfiedByGivenKeys(cIndex, givenKeys))\n+            .count() > 0;\n+    }\n+\n+    private boolean isIndexSatisfiedByGivenKeys(IndexType index, Collection<String> givenKeys) {\n+        for (int i = 0; i < index.getFieldKeys().length; ++i) {\n+            if (!givenKeys.contains(index.getFieldKeys()[i].getFieldKey().name())) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Traversal.Admin<?,Long> generateFilter(Traversal.Admin<?,?> traversal, HasStep<?> originalStep) {\n+        Traversal.Admin filterTraversal = new DefaultGraphTraversal<>(traversal.getGraph().get())\n+            .addStep(\n+                new GraphStep<>(traversal, Vertex.class, true)\n+            );\n+\n+        filterTraversal.addStep(originalStep);\n+        filterTraversal.addStep(new IdStep<>(traversal));\n+        return filterTraversal;\n+    }\n+\n+    private long evaluateFilter(Traversal.Admin<?,Long> filterTraversal) {\n+        // negative IDs are not valid in JanusGraph. Therefore, if the filterTraversal has no result, the newly\n+        // inserted HasStep should not match anything\n+        long determinedId = -1;\n+        if (filterTraversal.hasNext()) {\n+            determinedId = (long) filterTraversal.next();\n+        }\n+        return determinedId;\n+    }\n+\n+    @Override\n+    protected FilterStep<Edge> makeFilterByAdjacentIdStep(Traversal.Admin<?, ?> traversal, HasStep<?> originalStep) {\n+        Traversal.Admin<?,Long> filterTraversal = generateFilter(traversal, originalStep);\n+        HasContainer hc = new HasContainer(ADJACENT_ID.name(), P.eq(evaluateFilter(filterTraversal)));", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxMjA3OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479912079", "bodyText": "Yes, that's what it does. Same question as above: What exactly to you mean by profiling?", "author": "rngcntr", "createdAt": "2020-08-31T06:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI1MDY5OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480250699", "bodyText": "If you run query.profile(), the latency metrics would be inaccurate because it does not take this query latency into account. By profiling I mean you need to have a timer here, which is a part of the query profile.", "author": "li-boxuan", "createdAt": "2020-08-31T16:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgwNjg3Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480806872", "bodyText": "Alright, I'll try to find out how to add a timer to the query profile. I thought that would happen automatically for optimization strategies because optimization appears quite often in the query profiles that I see.", "author": "rngcntr", "createdAt": "2020-09-01T04:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NjEzMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r480886133", "bodyText": "Adding custom profiling outside the actual query execution is not intended. The metrics, in which the profile is stored, are created within the first next() or hasNext() call of a ProfileStep. Therefore, there is no profiler available at optimization time.\nThe only \"solution\" that comes to my mind is a pretty ugly one and in fact a complete re-write of the current state:\nInstead of doing the ID resolution at optimization time, we would have to do it at runtime. To do so, we would need to implement a custom step which holds both the unoptimized query and a skeleton of the optimized query as it's children. Then at runtime, this step could evaluate the index uniqueness and dynamically decide which path to use. It would then also have to inject the resolved ID into the optimized query somehow. In my eyes, this is a mess...\nIf you have any other idea, please let me know.", "author": "rngcntr", "createdAt": "2020-09-01T06:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIwNTg4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r481205883", "bodyText": "To do profiling in the optimization step, you can actually create a new TP3ProfileWrapper and later in runtime, add the metrics of this \"optimization profiler\" to the query profiler. I did something similar in another issue I have been working on which I would probably submit a PR in 1-2 weeks.\nActually I am thinking that this ad-hoc traversal shall indeed be done only in runtime. Let's say we have\ng.V().has(\"key1\", \"value1\").out(label).has(\"key2\", \"value2\")\nIf g.V().has(\"key1\", \"value1\") does not exist, the query will finish. It could also be the case that this g.V().has(\"key1\", \"value1\") vertex does not have any out(label) edge at all. Under such \"early-stopping\" circumstances, the ad-hoc traversal done for has(\"key2\", \"value2\") in the optimization stage becomes meaningless and brings only overhead. If this ad-hoc traversal is lazily computed, we don't have such a problem.\nThat being said, I do also see the potential performance improvement if we have has(\"key2\", \"value2\") in the optimization stage, since it can eliminate the need of the whole traversal when has(\"key2\", \"value2\") returns null. If we don't put this logic in this strategy, then it does not make much sense to have the ad-hoc traversal in optimization stage.", "author": "li-boxuan", "createdAt": "2020-09-01T15:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjcyMTg1NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r482721854", "bodyText": "As mentioned earlier, I would prefer not to have this logic in the same strategy but instead have a \"cleanup\" strategy which runs at the end of the optimization phase and prunes the query by eliminating all sub queries that contain unsatisfiable condition.\nOther optimization strategies (like this one) could then mark conditions as unsatisfiable by adding/replacing with a hasId(-1) step for example. This way, we can ensure we don't have to implement a similar logic in every strategy that makes use of it.\nAlso thanks for pointing me towards TP3ProfileWrapper. If you don't mind, I would like to wait until I see how you are handling this in your PR.", "author": "rngcntr", "createdAt": "2020-09-03T05:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAzMDg1MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r483030850", "bodyText": "I would prefer not to have this logic in the same strategy but instead have a \"cleanup\" strategy...\n\nThat's fair.\n\nI would like to wait until I see how you are handling this in your PR\n\nSure \ud83d\ude09", "author": "li-boxuan", "createdAt": "2020-09-03T14:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY2ODU5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r501668591", "bodyText": "It's been a while and after this PR was requested to be merged soon in yesterday's JanusGraph meetup, I came back to look at what's still missing here in order to merge the PR. Throughout the day I tried different ways to integrate the collection of metrics into this optimization strategy. But in contrast to what you did in your PR, the step within the traversal that is created by my optimization strategy, is later merged with previous JanusGraphVertexSteps and will therefore not receive it's own query metrics by the query executor.\nThe problem is that the has step created by my strategy is only intermediate and will never remain once the query is completely optimized by the JanusGraphLocalQueryOptimizerStrategy. Therefore at the time the initial Metrics Object is created, there is no step remaining that can possibly be responsible for accounting the time spent in the optimization phase.\nOne possible solution would be to create a custom IdentityStep within the query that does nothing but hold the metrics from the optimization phase. But this step could possibly interfere with other optimization strategies and get removed by them or make it harder for them to be applied.\nConcluding, I don't see a really good solution for this problem. IMHO the cleanest way would be to somehow measure the time for each optimization independently from the query execution, bundle them and somehow integrate them in the profile result afterwards. But this would require a lot of work to be done and design decisions to be made.", "author": "rngcntr", "createdAt": "2020-10-08T12:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3MDgyOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r501670828", "bodyText": "Quick addition: As some optimizations are already applied by TinkerPop and therefore outside of JanusGraph, it would obviously preferred to have this kind of functionality as part of TinkerPop, not JanusGraph.", "author": "rngcntr", "createdAt": "2020-10-08T12:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxNTkzOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r501815939", "bodyText": "I yet to find some time to review this, but\n\nthis PR was requested to be merged soon in yesterday's JanusGraph meetup\n\nthis grasps my attention \ud83d\ude04.  I didn't attend the meetup but I am curious about the request: is there a planned date for the 0.6.0 release? If not, why would users (I assume this was a request by some user) think merging this PR soon will help them? Is it because they are using the master version of JanusGraph?", "author": "li-boxuan", "createdAt": "2020-10-08T15:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE5MzY5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r502193690", "bodyText": "I don't think so. But from a user perspective if they neither know when 0.6.0 will be released nor when this feature will be merged, chances of getting it with v0.6.0 are better the earlier this change is in.\nIf you would like to view the recording of the meetup (where I gave a talk, too \ud83c\udf89), I think @twilmes said he plans to upload it somewhere it's accessible for those who were not able to make it to the meetup.", "author": "rngcntr", "createdAt": "2020-10-09T05:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5Nzg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5ODk4OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479598989", "bodyText": "I am not sure here, but maybe you want to skip this optimization if TraversalHelper.onGraphComputer(traversal). TBH I didn't even know we could create nested traversal, thus I don't know what impact it will have on OLAP traversal.", "author": "li-boxuan", "createdAt": "2020-08-29T03:02:58Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterables;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.graphdb.internal.InternalRelationType;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)", "originalCommit": "4822c15868f084ed876ed02f459a202c5a3ead38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxMjYzOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r479912639", "bodyText": "You're right. I never did any experiments with OLAP traversals so it's probably wise to not tinker (pun intended) with them before gaining a deeper knowledge.", "author": "rngcntr", "createdAt": "2020-08-31T06:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5ODk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcwODczMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r485708731", "bodyText": "nice pun!", "author": "li-boxuan", "createdAt": "2020-09-09T15:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU5ODk4OQ=="}], "type": "inlineReview"}, {"oid": "f34bb32963c21811e4271538a91173253e7fb2b3", "url": "https://github.com/JanusGraph/janusgraph/commit/f34bb32963c21811e4271538a91173253e7fb2b3", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-31T06:51:11Z", "type": "forcePushed"}, {"oid": "644458fc0696129a426101cdbefec19f651d8c74", "url": "https://github.com/JanusGraph/janusgraph/commit/644458fc0696129a426101cdbefec19f651d8c74", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-31T11:03:38Z", "type": "forcePushed"}, {"oid": "07f4cc60cacfdaeac9c024c32d92cc130898dc04", "url": "https://github.com/JanusGraph/janusgraph/commit/07f4cc60cacfdaeac9c024c32d92cc130898dc04", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-08-31T11:57:58Z", "type": "forcePushed"}, {"oid": "62b1c9395a3984e8afd6482be843a30bbca42fb4", "url": "https://github.com/JanusGraph/janusgraph/commit/62b1c9395a3984e8afd6482be843a30bbca42fb4", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-09-01T06:49:18Z", "type": "forcePushed"}, {"oid": "a3d3a16350cbb37117fe4834e79ad896f2ab73d2", "url": "https://github.com/JanusGraph/janusgraph/commit/a3d3a16350cbb37117fe4834e79ad896f2ab73d2", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-09-10T07:00:57Z", "type": "forcePushed"}, {"oid": "8cbf2e11d37abd2fb5b455467ce2d23313e37085", "url": "https://github.com/JanusGraph/janusgraph/commit/8cbf2e11d37abd2fb5b455467ce2d23313e37085", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-08T11:34:09Z", "type": "forcePushed"}, {"oid": "5f26b1ed7a450b1aff1c2146605c5ba38321dffc", "url": "https://github.com/JanusGraph/janusgraph/commit/5f26b1ed7a450b1aff1c2146605c5ba38321dffc", "message": "Optimize adjacency checks with unique index\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-08T11:54:48Z", "type": "forcePushed"}, {"oid": "3df566ea8648a1e2b835664a8816ca62b48d27f1", "url": "https://github.com/JanusGraph/janusgraph/commit/3df566ea8648a1e2b835664a8816ca62b48d27f1", "message": "Make optimizer backend access configurable\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-14T07:30:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNDg2MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r505534861", "bodyText": "This looks interesting. How did you find this step? Did you know why it is not caught by TraversalHelper.onGraphComputer?", "author": "li-boxuan", "createdAt": "2020-10-15T13:19:27Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,145 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<>();\n+        postStrategies.add(JanusGraphStepStrategy.class);\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal)\n+            || traversal.getStartStep() instanceof TraversalVertexProgramStep // not caught by TraversalHelper", "originalCommit": "3df566ea8648a1e2b835664a8816ca62b48d27f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExMDU3MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r506110571", "bodyText": "This odd case occured to me while I was trying to fix failing tests that were atually failing because of the StandardJanusGraph vs StandardJanusGraphTx problem. While debugging I found out that TraversalHelper.onGraphComputer() does return false for traversals that start with TraversalVertexProgramSteps, which are obviously graph computer traversals. So I had a look into TraversalHelper (which is provided by TinkerPop, not JanusGraph) and what I found is that it only considers traversals as graph computer traversals if their parent traversal begins with such a step. For the top layer traversal itself, it returns false.\nWhat I also found out is that in current versions of TinkerPop, the implementation of this method has changed. However, I did not investigate whether or not this case is included in newer versions of TinkerPop.\nWhen debugging, I saw that this change reduced the number of failing tests from 11 down to 2, so there must be some actual difference. However, all the 11 failing tests were fixed by introducing the StandardJanusGraph/StandardJanusGraphTx distinction, so this check isn't actually required. I still kept it in just to be sure, because it seemingly had a positive impact on the test runs earlier.", "author": "rngcntr", "createdAt": "2020-10-16T07:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNDg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI3MjExOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511272118", "bodyText": "While debugging I found out that TraversalHelper.onGraphComputer() does return false for traversals that start with TraversalVertexProgramSteps, which are obviously graph computer traversals\n\nDo you want to ask or report to the TinkerPop community?", "author": "li-boxuan", "createdAt": "2020-10-24T02:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNDg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjI0Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r505536246", "bodyText": "Curious: when is it a StandardJanusGraph instance and when is it a StandardJanusGraphTx instance?", "author": "li-boxuan", "createdAt": "2020-10-15T13:21:21Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,145 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<>();\n+        postStrategies.add(JanusGraphStepStrategy.class);\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal)\n+            || traversal.getStartStep() instanceof TraversalVertexProgramStep // not caught by TraversalHelper\n+            || !traversal.getGraph().isPresent()) {\n+            return;\n+        }\n+\n+        Graph graph = traversal.getGraph().get();\n+        StandardJanusGraph janusGraph = graph instanceof StandardJanusGraph\n+            ? (StandardJanusGraph) graph\n+            : ((StandardJanusGraphTx) graph).getGraph();", "originalCommit": "3df566ea8648a1e2b835664a8816ca62b48d27f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjExNDY5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r506114691", "bodyText": "I found out that after introducing the config option, some tests failed because the graph was not a StandardJanusGraph as I expected. Instead, the traversal's graph was a StandardJanusGraphTx. I did not take a deeper look into the reason for that tbh.", "author": "rngcntr", "createdAt": "2020-10-16T07:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzAxMzQwMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r507013402", "bodyText": "Can you point out some test cases where the graph is a StandardJanusGraphTx? I'd also like to take a look.", "author": "li-boxuan", "createdAt": "2020-10-18T04:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU3MzI2OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r507573269", "bodyText": "InMemoryJanusGraphComputerTest#testMessagePassingOut for example. But there are some others in the same test class.\nYou can just comment out the distinction between StandardJanusGraph and StandardJanusGraphTx and you will end up with ClassCastExceptions.", "author": "rngcntr", "createdAt": "2020-10-19T08:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM2NDg4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r509364880", "bodyText": "I can see that comes from FulgoraGraphComputer which I am unfamiliar with. Anyway, there are only two implementations of graph interface in JanusGraph codebase, namely StandardJanusGraph and StandardJanusGraphTx, so I think this is good enough.", "author": "li-boxuan", "createdAt": "2020-10-21T15:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjI0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI3MjQxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511272418", "bodyText": "I see similar handling in JanusGraphLocalQueryOptimizerStrategy, so this should be legitimate.", "author": "li-boxuan", "createdAt": "2020-10-24T02:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjczNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r505536734", "bodyText": "Nice. Can you add a test case for this?", "author": "li-boxuan", "createdAt": "2020-10-15T13:22:02Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,145 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<>();\n+        postStrategies.add(JanusGraphStepStrategy.class);\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal)\n+            || traversal.getStartStep() instanceof TraversalVertexProgramStep // not caught by TraversalHelper\n+            || !traversal.getGraph().isPresent()) {\n+            return;\n+        }\n+\n+        Graph graph = traversal.getGraph().get();\n+        StandardJanusGraph janusGraph = graph instanceof StandardJanusGraph\n+            ? (StandardJanusGraph) graph\n+            : ((StandardJanusGraphTx) graph).getGraph();\n+\n+        if (!janusGraph.getConfiguration().optimizerBackendAccess()) {\n+            return;", "originalCommit": "3df566ea8648a1e2b835664a8816ca62b48d27f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE1NjE3Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r506156177", "bodyText": "Done as a separate commit. I will squash the commits once the PR is going to be merged.", "author": "rngcntr", "createdAt": "2020-10-16T08:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUzNjczNA=="}], "type": "inlineReview"}, {"oid": "4357b4db97f615011ee75554faaf865d8af10748", "url": "https://github.com/JanusGraph/janusgraph/commit/4357b4db97f615011ee75554faaf865d8af10748", "message": "Add test for OPTIMIZER_BACKEND_ACCESS option\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-16T08:14:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2MDA2OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511260069", "bodyText": "Seems we can also support P.within(singleton) here.\nIf g.V(sv[0]).out().has(\"uniqueId\", 0) can be optimized, so can g.V(sv[0]).out().has(\"uniqueId\", P.within(0))", "author": "li-boxuan", "createdAt": "2020-10-24T02:20:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,145 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<>();\n+        postStrategies.add(JanusGraphStepStrategy.class);\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal)\n+            || traversal.getStartStep() instanceof TraversalVertexProgramStep // not caught by TraversalHelper\n+            || !traversal.getGraph().isPresent()) {\n+            return;\n+        }\n+\n+        Graph graph = traversal.getGraph().get();\n+        StandardJanusGraph janusGraph = graph instanceof StandardJanusGraph\n+            ? (StandardJanusGraph) graph\n+            : ((StandardJanusGraphTx) graph).getGraph();\n+\n+        if (!janusGraph.getConfiguration().optimizerBackendAccess()) {\n+            return;\n+        }\n+\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+\n+        List<String> givenKeys = step.getHasContainers().stream()\n+            .map(HasContainer::getKey).collect(Collectors.toList());\n+\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = step.getHasContainers().stream()\n+            .filter(hc -> hc.getBiPredicate() == Compare.eq)", "originalCommit": "4357b4db97f615011ee75554faaf865d8af10748", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1MTI4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511751286", "bodyText": "Wouldn't it be better to avoid nesting the necessary logic in here and instead have a strategy that replaces P.within(singleton) by P.eq?", "author": "rngcntr", "createdAt": "2020-10-26T07:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2MDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg3OTU2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511879565", "bodyText": "well said, now it surprises me that this optimization hasn't been done yet", "author": "li-boxuan", "createdAt": "2020-10-26T11:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2MDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTkzNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511911935", "bodyText": "There are lots of small things that could be done, but the sheer amount of these little tweaks makes it hard to cover all of them", "author": "rngcntr", "createdAt": "2020-10-26T12:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2MDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2NzY3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511267676", "bodyText": "This assumes and requires conditions is non-null. However, the QueryUtil.constraints2QNF method might return a null value. Although it is not an issue for your current use case, IMO we should simply return an empty set if conditions is null.", "author": "li-boxuan", "createdAt": "2020-10-24T02:35:49Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionUtil.java", "diffHunk": "@@ -25,4 +38,26 @@ public static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n         }\n         return true;\n     }\n+\n+    public static Set<IndexType> getMatchingIndexes(MultiCondition<JanusGraphElement> conditions) {\n+        final Set<IndexType> availableIndexes = new HashSet<>();\n+        ConditionUtil.traversal(conditions, condition -> {", "originalCommit": "4357b4db97f615011ee75554faaf865d8af10748", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2OTA0Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511269046", "bodyText": "Nitpick: we can use enhanced for loop here: for (IndexField indexField : index.getFieldKeys())", "author": "li-boxuan", "createdAt": "2020-10-24T02:39:27Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionUtil.java", "diffHunk": "@@ -25,4 +38,26 @@ public static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n         }\n         return true;\n     }\n+\n+    public static Set<IndexType> getMatchingIndexes(MultiCondition<JanusGraphElement> conditions) {\n+        final Set<IndexType> availableIndexes = new HashSet<>();\n+        ConditionUtil.traversal(conditions, condition -> {\n+            if (condition instanceof PredicateCondition) {\n+                final RelationType type = ((PredicateCondition<RelationType, JanusGraphElement>) condition).getKey();\n+                Preconditions.checkArgument(type != null && type.isPropertyKey());\n+                Iterables.addAll(availableIndexes, ((InternalRelationType) type).getKeyIndexes());\n+            }\n+            return true;\n+        });\n+        return availableIndexes;\n+    }\n+\n+    public static boolean isIndexSatisfiedByGivenKeys(IndexType index, Collection<String> givenKeys) {\n+        for (int i = 0; i < index.getFieldKeys().length; ++i) {\n+            if (!givenKeys.contains(index.getFieldKeys()[i].getFieldKey().name())) {", "originalCommit": "4357b4db97f615011ee75554faaf865d8af10748", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI3MDgzMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511270830", "bodyText": "Not sure if it's just me but I prefer writing it in multiple lines:\npublic static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() {\n    return INSTANCE;\n}\nand a decent IDE like Intellij can automatically collapse it into one line.", "author": "li-boxuan", "createdAt": "2020-10-24T02:44:03Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,145 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }", "originalCommit": "4357b4db97f615011ee75554faaf865d8af10748", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc1Mzc0Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511753747", "bodyText": "I actually prefer line breaks, too. I went and applied them to every strategy now.", "author": "rngcntr", "createdAt": "2020-10-26T07:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI3MDgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5NjI1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511296253", "bodyText": "This does not work due to \n  \n    \n      janusgraph/janusgraph-core/src/main/java/org/janusgraph/graphdb/query/vertex/BaseVertexCentricQueryBuilder.java\n    \n    \n        Lines 107 to 111\n      in\n      4f44a1d\n    \n    \n    \n    \n\n        \n          \n           if (type.equals(ImplicitKey.ADJACENT_ID.name())) { \n        \n\n        \n          \n               Preconditions.checkArgument(rel == Cmp.EQUAL, \"Only equality constraints are supported for %s\", type); \n        \n\n        \n          \n               long vertexId = ElementUtils.getVertexId(value); \n        \n\n        \n          \n               Preconditions.checkArgument(vertexId > 0, \"Expected valid vertex id: %s\", value); \n        \n\n        \n          \n               return adjacent(getVertex(vertexId)); \n        \n    \n  \n\n\nYou can see this problem by adding a test case where the adjacent vertex does not exist, e.g. assertNumStep(1, 0, g.V(sv[0]).out().has(\"uniqueId\", 10000), HasStep.class);", "author": "li-boxuan", "createdAt": "2020-10-24T03:41:38Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,145 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<>();\n+        postStrategies.add(JanusGraphStepStrategy.class);\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal)\n+            || traversal.getStartStep() instanceof TraversalVertexProgramStep // not caught by TraversalHelper\n+            || !traversal.getGraph().isPresent()) {\n+            return;\n+        }\n+\n+        Graph graph = traversal.getGraph().get();\n+        StandardJanusGraph janusGraph = graph instanceof StandardJanusGraph\n+            ? (StandardJanusGraph) graph\n+            : ((StandardJanusGraphTx) graph).getGraph();\n+\n+        if (!janusGraph.getConfiguration().optimizerBackendAccess()) {\n+            return;\n+        }\n+\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+\n+        List<String> givenKeys = step.getHasContainers().stream()\n+            .map(HasContainer::getKey).collect(Collectors.toList());\n+\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = step.getHasContainers().stream()\n+            .filter(hc -> hc.getBiPredicate() == Compare.eq)\n+            .map(hc -> new PredicateCondition<>(hc.getKey(), JanusGraphPredicateUtils.convert(hc.getBiPredicate()), hc.getValue()))\n+            .filter(pc -> tx.validDataType(pc.getValue().getClass()))\n+            .collect(Collectors.toList());\n+        final MultiCondition<JanusGraphElement> conditions = QueryUtil.constraints2QNF(tx, constraints);\n+\n+        // collect all matching indexes\n+        final Set<IndexType> availableIndexes = IndexSelectionUtil.getMatchingIndexes(conditions);\n+\n+        // select only valid unique indexes\n+        return availableIndexes.stream()\n+            .filter(IndexType::isCompositeIndex)\n+            .map(index -> (CompositeIndexType) index)\n+            .filter(cIndex -> cIndex.getCardinality() == Cardinality.SINGLE)\n+            .anyMatch(cIndex -> IndexSelectionUtil.isIndexSatisfiedByGivenKeys(cIndex, givenKeys));\n+    }\n+\n+    private Traversal.Admin<?,Long> generateFilter(Traversal.Admin<?,?> traversal, HasStep<?> originalStep) {\n+        Traversal.Admin filterTraversal = new DefaultGraphTraversal<>(traversal.getGraph().get())\n+            .addStep(\n+                new GraphStep<>(traversal, Vertex.class, true)\n+            );\n+\n+        filterTraversal.addStep(originalStep);\n+        filterTraversal.addStep(new IdStep<>(filterTraversal));\n+        return filterTraversal;\n+    }\n+\n+    private long evaluateFilter(Traversal.Admin<?,Long> filterTraversal) {\n+        // negative IDs are not valid in JanusGraph. Therefore, if the filterTraversal has no result, the newly\n+        // inserted HasStep should not match anything\n+        long determinedId = -1;", "originalCommit": "4357b4db97f615011ee75554faaf865d8af10748", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTc3Mjc4MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r511772781", "bodyText": "Crucial! I think I found a better solution now, since I discovered Gremlin supports a none() step, which is exactly what I tried to emulate here with has('~adjacent', -1) but with style \ud83d\ude01\nI also included your test case (which should be assertNumStep(0, 0, ..., right?) and will now wait for the build to have look at the code coverage and see where I need additional tests. Thanks for taking the time once again to review my PR!", "author": "rngcntr", "createdAt": "2020-10-26T07:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI5NjI1Mw=="}], "type": "inlineReview"}, {"oid": "ee03a7c487957305e2f4acd424345e322f8627f9", "url": "https://github.com/JanusGraph/janusgraph/commit/ee03a7c487957305e2f4acd424345e322f8627f9", "message": "Optimize adjacency checks with unique index\nMake optimizer backend access configurable\nAdd test for OPTIMIZER_BACKEND_ACCESS option\nApply suggestions by @li-boxuan\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-26T07:28:01Z", "type": "forcePushed"}, {"oid": "9dd66bb6718e6d255fffc5518b2d5cb359a8ed9a", "url": "https://github.com/JanusGraph/janusgraph/commit/9dd66bb6718e6d255fffc5518b2d5cb359a8ed9a", "message": "Optimize adjacency checks with unique index\n\nMake optimizer backend access configurable\nAdd test for OPTIMIZER_BACKEND_ACCESS option\nApply suggestions by @li-boxuan\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-26T08:00:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4MDEwOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r513380108", "bodyText": "NoneStep looks nice! One suggestion: can we avoid using magic number -1 here?\nSince the 'evaluateFilter' method now is quite simple, probably we don't need it anymore:\nif (filterTraversal.hasNext()) {\n        HasContainer hc = new HasContainer(ADJACENT_ID.name(), P.eq(adjacentId));\n        return new HasStep<>(traversal, hc);\n} else {\n        return new NoneStep<>(traversal);\n}", "author": "li-boxuan", "createdAt": "2020-10-28T11:48:17Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.NoneStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<>();\n+        postStrategies.add(JanusGraphStepStrategy.class);\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal) || !traversal.getGraph().isPresent()) {\n+            return;\n+        }\n+\n+        Graph graph = traversal.getGraph().get();\n+        StandardJanusGraph janusGraph = graph instanceof StandardJanusGraph\n+            ? (StandardJanusGraph) graph\n+            : ((StandardJanusGraphTx) graph).getGraph();\n+\n+        if (!janusGraph.getConfiguration().optimizerBackendAccess()) {\n+            return;\n+        }\n+\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(this::optimizeStep);\n+    }\n+\n+    /**\n+     * Determines whether this HasStep can be answered by a unique index and thus, returns either 0 or 1 match\n+     */\n+    @Override\n+    protected boolean isValidStep(HasStep<?> step) {\n+        StandardJanusGraphTx tx = (StandardJanusGraphTx) JanusGraphTraversalUtil.getTx(step.getTraversal());\n+\n+        List<String> givenKeys = step.getHasContainers().stream()\n+            .map(HasContainer::getKey).collect(Collectors.toList());\n+\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = step.getHasContainers().stream()\n+            .filter(hc -> hc.getBiPredicate() == Compare.eq)\n+            .map(hc -> new PredicateCondition<>(hc.getKey(), JanusGraphPredicateUtils.convert(hc.getBiPredicate()), hc.getValue()))\n+            .filter(pc -> tx.validDataType(pc.getValue().getClass()))\n+            .collect(Collectors.toList());\n+        final MultiCondition<JanusGraphElement> conditions = QueryUtil.constraints2QNF(tx, constraints);\n+\n+        // collect all matching indexes\n+        final Set<IndexType> availableIndexes = IndexSelectionUtil.getMatchingIndexes(conditions);\n+\n+        // select only valid unique indexes\n+        return availableIndexes.stream()\n+            .filter(IndexType::isCompositeIndex)\n+            .map(index -> (CompositeIndexType) index)\n+            .filter(cIndex -> cIndex.getCardinality() == Cardinality.SINGLE)\n+            .anyMatch(cIndex -> IndexSelectionUtil.isIndexSatisfiedByGivenKeys(cIndex, givenKeys));\n+    }\n+\n+    private Traversal.Admin<?,Long> generateFilter(Traversal.Admin<?,?> traversal, HasStep<?> originalStep) {\n+        Traversal.Admin filterTraversal = new DefaultGraphTraversal<>(traversal.getGraph().get())\n+            .addStep(\n+                new GraphStep<>(traversal, Vertex.class, true)\n+            );\n+\n+        filterTraversal.addStep(originalStep);\n+        filterTraversal.addStep(new IdStep<>(filterTraversal));\n+        return filterTraversal;\n+    }\n+\n+    private long evaluateFilter(Traversal.Admin<?,Long> filterTraversal) {\n+        // negative IDs are not valid in JanusGraph. Therefore, if the filterTraversal has no result, the newly\n+        // inserted HasStep should not match anything\n+        long determinedId = -1;\n+        if (filterTraversal.hasNext()) {\n+            determinedId = filterTraversal.next();\n+        }\n+        return determinedId;\n+    }\n+\n+    @Override\n+    protected FilterStep<Edge> makeFilterByAdjacentIdStep(Traversal.Admin<?, ?> traversal, HasStep<?> originalStep) {\n+        Traversal.Admin<?,Long> filterTraversal = generateFilter(traversal, originalStep);\n+        long adjacentId = evaluateFilter(filterTraversal);\n+        if (adjacentId == -1) {\n+            return new NoneStep<>(traversal);", "originalCommit": "9dd66bb6718e6d255fffc5518b2d5cb359a8ed9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAzNDk3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r514034976", "bodyText": "Yes of course", "author": "rngcntr", "createdAt": "2020-10-29T06:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4MDEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4Mjc4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r513382780", "bodyText": "Since you have NoneStep put in place, maybe you want to assert NoneStep.class here.", "author": "li-boxuan", "createdAt": "2020-10-28T11:52:57Z", "path": "janusgraph-test/src/test/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategyTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.NoOpBarrierStep;\n+import org.janusgraph.graphdb.configuration.GraphDatabaseConfiguration;\n+import org.janusgraph.graphdb.tinkerpop.optimize.strategy.AdjacentVertexHasUniquePropertyOptimizerStrategy;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.janusgraph.graphdb.JanusGraphBaseTest.option;\n+import static org.janusgraph.testutil.JanusGraphAssert.assertNumStep;\n+import static org.janusgraph.testutil.JanusGraphAssert.assertSameResultWithOptimizations;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategyTest extends OptimizerStrategyTest {\n+\n+    private static TraversalStrategy optimizer = AdjacentVertexHasUniquePropertyOptimizerStrategy.instance();\n+\n+    @Test\n+    public void testWithBackendAccess() {\n+        makeSampleGraph();\n+\n+        // AdjacentVertexHasUniquePropertyOptimizer\n+        assertNumStep(1, 0, g.V(sv[0]).out().has(\"uniqueId\", 0), HasStep.class);\n+        assertNumStep(1, 0, g.V(sv[0]).out().barrier(2500).has(\"uniqueId\", 0), NoOpBarrierStep.class);\n+        assertNumStep(1, 1, g.V(sv[0]).barrier(2500).out().barrier(2500).has(\"uniqueId\", 0), NoOpBarrierStep.class);\n+        assertNumStep(1, 0, g.V(sv[0]).out().barrier(2500).has(\"uniqueId\", 0), HasStep.class);\n+        assertNumStep(1, 1, g.V(sv[0]).out().has(\"id\", 0), HasStep.class);\n+        assertNumStep(1, 0, g.V(sv[0]).out().has(\"id\", 0).has(\"uniqueId\", 0), HasStep.class);\n+        assertNumStep(0, 0, g.V(sv[0]).out().has(\"uniqueId\", 10000), HasStep.class);", "originalCommit": "9dd66bb6718e6d255fffc5518b2d5cb359a8ed9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAzODM3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r514038376", "bodyText": "Nice idea", "author": "rngcntr", "createdAt": "2020-10-29T07:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4Mjc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4ODA0MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r513388040", "bodyText": "Question (not directly related to this line but since you are testing barrier step): is there any difference if your Strategy is put before / after LazyBarrierStrategy?", "author": "li-boxuan", "createdAt": "2020-10-28T12:02:19Z", "path": "janusgraph-test/src/test/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategyTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.NoOpBarrierStep;\n+import org.janusgraph.graphdb.configuration.GraphDatabaseConfiguration;\n+import org.janusgraph.graphdb.tinkerpop.optimize.strategy.AdjacentVertexHasUniquePropertyOptimizerStrategy;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.janusgraph.graphdb.JanusGraphBaseTest.option;\n+import static org.janusgraph.testutil.JanusGraphAssert.assertNumStep;\n+import static org.janusgraph.testutil.JanusGraphAssert.assertSameResultWithOptimizations;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategyTest extends OptimizerStrategyTest {\n+\n+    private static TraversalStrategy optimizer = AdjacentVertexHasUniquePropertyOptimizerStrategy.instance();\n+\n+    @Test\n+    public void testWithBackendAccess() {\n+        makeSampleGraph();\n+\n+        // AdjacentVertexHasUniquePropertyOptimizer\n+        assertNumStep(1, 0, g.V(sv[0]).out().has(\"uniqueId\", 0), HasStep.class);\n+        assertNumStep(1, 0, g.V(sv[0]).out().barrier(2500).has(\"uniqueId\", 0), NoOpBarrierStep.class);", "originalCommit": "9dd66bb6718e6d255fffc5518b2d5cb359a8ed9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAzNzU5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r514037591", "bodyText": "I had to ensure that barrier steps between the out() step and the has() step don't break the strategy, because I want my generated filter step to be merged into a preceeding vertex step. This should happen no matter if there is a barrier() in between these steps, so I tested it.", "author": "rngcntr", "createdAt": "2020-10-29T07:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM4ODA0MA=="}], "type": "inlineReview"}, {"oid": "37ba127ce4df64f4c1740c39e545135cb73f89c4", "url": "https://github.com/JanusGraph/janusgraph/commit/37ba127ce4df64f4c1740c39e545135cb73f89c4", "message": "Optimize adjacency checks with unique index\n\nMake optimizer backend access configurable\nAdd test for OPTIMIZER_BACKEND_ACCESS option\nApply suggestions by @li-boxuan\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-29T07:04:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI2MDcxNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r514260714", "bodyText": "What about the case you mentioned in the #2189 (comment), i.e.,\ng.V().has('user', 'name', 'alice').out('knows').as('x').in('knows').has('user', 'name', 'bob').select('x')", "author": "li-boxuan", "createdAt": "2020-10-29T13:33:25Z", "path": "janusgraph-test/src/test/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasUniquePropertyOptimizerStrategyTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.NoneStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.NoOpBarrierStep;\n+import org.janusgraph.graphdb.configuration.GraphDatabaseConfiguration;\n+import org.janusgraph.graphdb.tinkerpop.optimize.strategy.AdjacentVertexHasUniquePropertyOptimizerStrategy;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.janusgraph.graphdb.JanusGraphBaseTest.option;\n+import static org.janusgraph.testutil.JanusGraphAssert.assertNumStep;\n+import static org.janusgraph.testutil.JanusGraphAssert.assertSameResultWithOptimizations;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategyTest extends OptimizerStrategyTest {\n+\n+    private static TraversalStrategy optimizer = AdjacentVertexHasUniquePropertyOptimizerStrategy.instance();\n+\n+    @Test\n+    public void testWithAndWithoutStrategy() {\n+        makeSampleGraph();\n+        assertNumStep(1, 0, g.V(sv[0]).out().has(\"uniqueId\", 0), HasStep.class);\n+        assertNumStep(1, 1, graph.traversal().withoutStrategies(AdjacentVertexHasUniquePropertyOptimizerStrategy.class).V(sv[0]).out().has(\"uniqueId\", 0), HasStep.class);\n+    }\n+\n+    @Test\n+    public void testWithBackendAccess() {", "originalCommit": "37ba127ce4df64f4c1740c39e545135cb73f89c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMyMjEzMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r514322130", "bodyText": "That is an equivalent example which is just more readable because of the given names. I don't even remember why I used step labels for that example, as they only add complexity. Probably did so in order to point out that this part can be nested in arbitrary traversals.", "author": "rngcntr", "createdAt": "2020-10-29T14:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI2MDcxNA=="}], "type": "inlineReview"}, {"oid": "dc106920ad633244867937f5e609f748deb4e588", "url": "https://github.com/JanusGraph/janusgraph/commit/dc106920ad633244867937f5e609f748deb4e588", "message": "Optimize adjacency checks with unique index\n\nMake optimizer backend access configurable\nAdd test for OPTIMIZER_BACKEND_ACCESS option\nApply suggestions by @li-boxuan\nImprove test coverage\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-10-30T07:01:12Z", "type": "forcePushed"}, {"oid": "56bccce8313ca3c624f2dd8b7395a51b8207714b", "url": "https://github.com/JanusGraph/janusgraph/commit/56bccce8313ca3c624f2dd8b7395a51b8207714b", "message": "Optimize adjacency checks with unique index\n\nMake optimizer backend access configurable\nAdd test for OPTIMIZER_BACKEND_ACCESS option\nApply suggestions by @li-boxuan\nImprove test coverage\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2021-01-04T05:58:26Z", "type": "commit"}, {"oid": "56bccce8313ca3c624f2dd8b7395a51b8207714b", "url": "https://github.com/JanusGraph/janusgraph/commit/56bccce8313ca3c624f2dd8b7395a51b8207714b", "message": "Optimize adjacency checks with unique index\n\nMake optimizer backend access configurable\nAdd test for OPTIMIZER_BACKEND_ACCESS option\nApply suggestions by @li-boxuan\nImprove test coverage\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2021-01-04T05:58:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMwNTk3OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r551305978", "bodyText": "Nitpick: The result of this method is always filtered. Instead of filling Set with values and then removing them, we could just pass filter (or predicate) function to this method and filter it directly here without conducting additional pass to filter the resulting set afterwards.", "author": "porunov", "createdAt": "2021-01-04T13:06:41Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionUtil.java", "diffHunk": "@@ -25,4 +40,29 @@ public static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n         }\n         return true;\n     }\n+\n+    public static Set<IndexType> getMatchingIndexes(MultiCondition<JanusGraphElement> conditions) {", "originalCommit": "56bccce8313ca3c624f2dd8b7395a51b8207714b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMxMzIwMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r551313203", "bodyText": "I see what you mean. Do you think it's worth creating an issue to rewrite the method?", "author": "rngcntr", "createdAt": "2021-01-04T13:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMwNTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM1NjgzMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r551356833", "bodyText": "I think issue could be helpful so that we don't forget to change it later", "author": "porunov", "createdAt": "2021-01-04T14:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMwNTk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc5OTQzOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r551799439", "bodyText": "Created #2339", "author": "porunov", "createdAt": "2021-01-05T09:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMwNTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMDk3Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r551610977", "bodyText": "I think this check could be placed on a more high level. Instead of always triggering AdjacentVertexHasUniquePropertyOptimizerStrategy.java for each query we can just skip adding this optimization strategy when this check is disabled in JanusGraph. When janusGraph.getConfiguration().optimizerBackendAccess() is false we don't even need to add this optimization to our life-cycle. Unless I miss something", "author": "porunov", "createdAt": "2021-01-04T22:38:32Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/AdjacentVertexHasUniquePropertyOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,141 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.TraversalVertexProgramStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.*;\n+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.DefaultGraphTraversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.NoneStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.IdStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Graph;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.StandardJanusGraph;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.index.IndexSelectionUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ID;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasUniquePropertyOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasUniquePropertyOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasUniquePropertyOptimizerStrategy();\n+\n+    private AdjacentVertexHasUniquePropertyOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasUniquePropertyOptimizerStrategy instance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<>();\n+        postStrategies.add(JanusGraphStepStrategy.class);\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal) || !traversal.getGraph().isPresent()) {\n+            return;\n+        }\n+\n+        Graph graph = traversal.getGraph().get();\n+        StandardJanusGraph janusGraph = graph instanceof StandardJanusGraph\n+            ? (StandardJanusGraph) graph\n+            : ((StandardJanusGraphTx) graph).getGraph();\n+\n+        if (!janusGraph.getConfiguration().optimizerBackendAccess()) {", "originalCommit": "56bccce8313ca3c624f2dd8b7395a51b8207714b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMjAwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r551612005", "bodyText": "I.e. I see that TraversalStrategies are registered in a static module in StandardJanusGraph but I think we could refactor that later. I guess we need just a separate refactor issue for that", "author": "porunov", "createdAt": "2021-01-04T22:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMDk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTc5ODAyNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2189#discussion_r551798027", "bodyText": "Created #2338", "author": "porunov", "createdAt": "2021-01-05T09:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMDk3Nw=="}], "type": "inlineReview"}]}