{"pr_number": 1960, "pr_title": "Optimize hasId() in the same way as is()", "pr_createdAt": "2020-02-12T07:57:46Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/1960", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUxNzAzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r378517037", "bodyText": "This comment is now wrong because we check not only is(x) but also hasId(id)", "author": "porunov", "createdAt": "2020-02-12T21:16:47Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,191 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n-                }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {\n-                            break;\n-                        } //We can jump over other steps as we move backward\n-                        currentStep = currentStep.getPreviousStep();\n-                    }\n-                    if (currentStep instanceof VertexStep) {\n-                        VertexStep vertexStep = (VertexStep) currentStep;\n-                        if (vertexStep.returnsEdge()\n-                                && (direction == Direction.BOTH || direction.equals(vertexStep.getDirection().opposite()))) {\n-                            //Now replace the step with a has condition\n-                            TraversalHelper.replaceStep(originalStep,\n-                                new HasStep(traversal,\n-                                    new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(vertex))),\n-                                traversal);\n-                        }\n-                    }\n+        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal)\n+            .forEach(originalStep -> {\n+                // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)", "originalCommit": "7d6fc87cf2161fc022b8bef9946caa17e0f46dc6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUyODQ1NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r378528454", "bodyText": "(nitpick) default: break; makes no sense here because we are breaking the switch by default already (i.e. no need to write it explicitly). I would just remove this statement", "author": "porunov", "createdAt": "2020-02-12T21:40:43Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,191 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n-                }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {\n-                            break;\n-                        } //We can jump over other steps as we move backward\n-                        currentStep = currentStep.getPreviousStep();\n-                    }\n-                    if (currentStep instanceof VertexStep) {\n-                        VertexStep vertexStep = (VertexStep) currentStep;\n-                        if (vertexStep.returnsEdge()\n-                                && (direction == Direction.BOTH || direction.equals(vertexStep.getDirection().opposite()))) {\n-                            //Now replace the step with a has condition\n-                            TraversalHelper.replaceStep(originalStep,\n-                                new HasStep(traversal,\n-                                    new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(vertex))),\n-                                traversal);\n-                        }\n-                    }\n+        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal)\n+            .forEach(originalStep -> {\n+                // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n+                Traversal.Admin<?, ?> filterTraversal =\n+                    (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n+                List<Step> subSteps = filterTraversal.getSteps();\n+\n+                OptimizableQueryType type = analyzeSubSteps(subSteps);\n \n+                switch (type) {\n+                case IS:\n+                    replaceIsStep(traversal, originalStep, subSteps);\n+                    break;\n+                case HASID:\n+                    replaceHasIdStep(traversal, originalStep, subSteps);\n+                    break;\n+                default:\n+                    break;", "originalCommit": "7d6fc87cf2161fc022b8bef9946caa17e0f46dc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5MzI3MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r378693271", "bodyText": "It's not a big deal but I'd like to keep it in there just to avoid unnecessary compiler warnings", "author": "rngcntr", "createdAt": "2020-02-13T07:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUyODQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkwODg2Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r378908866", "bodyText": "You are right. I didn't think about it. It makes sense then.", "author": "porunov", "createdAt": "2020-02-13T14:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUyODQ1NA=="}], "type": "inlineReview"}, {"oid": "42c93310862d302e543399b09a3781bbace34553", "url": "https://github.com/JanusGraph/janusgraph/commit/42c93310862d302e543399b09a3781bbace34553", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-13T07:39:13Z", "type": "forcePushed"}, {"oid": "2a814818922778892491c2a4b20023dc57736bbe", "url": "https://github.com/JanusGraph/janusgraph/commit/2a814818922778892491c2a4b20023dc57736bbe", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-14T07:18:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzQ2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r379283465", "bodyText": "I removed the repeated jumps because issues arose when using this strategy on queries that utilize SideEffectStep.\nThe re-ordering of steps caused logical dependencies between these steps to break.", "author": "rngcntr", "createdAt": "2020-02-14T07:28:18Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,179 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n-                }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {", "originalCommit": "2a814818922778892491c2a4b20023dc57736bbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1NDM3OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r379454378", "bodyText": "As I understand you found a bug which currently exists. Would you be able to provide a separate PR which removes this jumps and adds a test where we can see that bug? Or is it appears only in optimized queries with .hasId(id)?", "author": "porunov", "createdAt": "2020-02-14T14:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUxMzg2OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r379513869", "bodyText": "If the bug can be reproduced only in this PR, would you be able to add a test to this PR which shows the issue you described?", "author": "porunov", "createdAt": "2020-02-14T16:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAwMTUyNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r380001524", "bodyText": "This is a bug I encountered when applying the optimization techniques from this class in PR #1961\nAs the basic idea behind both approaches is essentially the same, it should be possible to find a matching test case. I'll try to find one once I get to work on this the next time.", "author": "rngcntr", "createdAt": "2020-02-17T06:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MDMzNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r380140335", "bodyText": "Nevermind, I introduced the bug myself when I was trying to catch even more optimizable sequences of steps. Thanks for your review!", "author": "rngcntr", "createdAt": "2020-02-17T11:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4MzQ2NQ=="}], "type": "inlineReview"}, {"oid": "a05102bf9e52acf2df7a8398eed5cba1874f5549", "url": "https://github.com/JanusGraph/janusgraph/commit/a05102bf9e52acf2df7a8398eed5cba1874f5549", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-17T11:54:14Z", "type": "forcePushed"}, {"oid": "08c2b5f669b7033132a141f324a94f5759adbc53", "url": "https://github.com/JanusGraph/janusgraph/commit/08c2b5f669b7033132a141f324a94f5759adbc53", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-17T12:55:22Z", "type": "forcePushed"}, {"oid": "eccf0a518549350a55aa331a587ecc4f61f8f0ef", "url": "https://github.com/JanusGraph/janusgraph/commit/eccf0a518549350a55aa331a587ecc4f61f8f0ef", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-17T13:52:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzMTAzMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r380331033", "bodyText": "I didn't find vertexStep.close() in the previous version. I don't know if we should close it here after try with resources but could you explain why you are closing vertexStep here? Is it connected to resources leak or other possible problems?", "author": "porunov", "createdAt": "2020-02-17T18:57:34Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexFilterOptimizerStrategy.java", "diffHunk": "@@ -32,73 +32,161 @@\n import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.T;\n import org.apache.tinkerpop.gremlin.structure.Vertex;\n-\n-import java.util.List;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n \n /**\n  * @author Matthias Broecheler (me@matthiasb.com)\n  */\n-public class AdjacentVertexFilterOptimizerStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy> implements TraversalStrategy.ProviderOptimizationStrategy {\n+public class AdjacentVertexFilterOptimizerStrategy\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n \n-    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE = new AdjacentVertexFilterOptimizerStrategy();\n+    private static final AdjacentVertexFilterOptimizerStrategy INSTANCE =\n+        new AdjacentVertexFilterOptimizerStrategy();\n \n-    private AdjacentVertexFilterOptimizerStrategy() {\n-    }\n+    private AdjacentVertexFilterOptimizerStrategy() {}\n \n-    public static AdjacentVertexFilterOptimizerStrategy instance() {\n-        return INSTANCE;\n-    }\n+    public static AdjacentVertexFilterOptimizerStrategy instance() { return INSTANCE; }\n \n+    private enum OptimizableQueryType { NONE, IS, HASID }\n+    ;\n \n     @Override\n     public void apply(final Traversal.Admin<?, ?> traversal) {\n \n-        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal).forEach(originalStep -> {\n-            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n-            Traversal.Admin<?, ?> filterTraversal = (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n-            List<Step> steps = filterTraversal.getSteps();\n-            if (steps.size() == 2 &&\n-                    (steps.get(0) instanceof EdgeVertexStep || steps.get(0) instanceof EdgeOtherVertexStep) &&\n-                    (steps.get(1) instanceof IsStep)) {\n-                //Get the direction in which we filter on the adjacent vertex (or null if not a valid adjacency filter)\n-                Direction direction = null;\n-                if (steps.get(0) instanceof EdgeVertexStep) {\n-                    EdgeVertexStep evs = (EdgeVertexStep) steps.get(0);\n-                    if (evs.getDirection() != Direction.BOTH) direction = evs.getDirection();\n-                } else {\n-                    assert steps.get(0) instanceof EdgeOtherVertexStep;\n-                    direction = Direction.BOTH;\n+        TraversalHelper.getStepsOfClass(TraversalFilterStep.class, traversal)\n+            .forEach(originalStep -> {\n+                // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is/hasId(x)\n+                Traversal.Admin<?, ?> filterTraversal =\n+                    (Traversal.Admin<?, ?>) originalStep.getLocalChildren().get(0);\n+                List<Step> subSteps = filterTraversal.getSteps();\n+\n+                OptimizableQueryType type = analyzeSubSteps(subSteps);\n+\n+                if (type != OptimizableQueryType.NONE) {\n+                    replaceStep(traversal, type, originalStep, subSteps);\n                 }\n-                P predicate = ((IsStep) steps.get(1)).getPredicate();\n-                //Check that we have a valid direction and a valid vertex filter predicate\n-                if (direction != null && predicate.getBiPredicate() == Compare.eq && predicate.getValue() instanceof Vertex) {\n-                    Vertex vertex = (Vertex) predicate.getValue();\n-\n-                    //Now, check that this step is preceded by VertexStep that returns edges\n-                    Step<?, ?> currentStep = originalStep.getPreviousStep();\n-                    while (currentStep != EmptyStep.instance()) {\n-                        if (!(currentStep instanceof HasStep) && !(currentStep instanceof IdentityStep)) {\n-                            break;\n-                        } //We can jump over other steps as we move backward\n-                        currentStep = currentStep.getPreviousStep();\n-                    }\n-                    if (currentStep instanceof VertexStep) {\n-                        VertexStep vertexStep = (VertexStep) currentStep;\n-                        if (vertexStep.returnsEdge()\n-                                && (direction == Direction.BOTH || direction.equals(vertexStep.getDirection().opposite()))) {\n-                            //Now replace the step with a has condition\n-                            TraversalHelper.replaceStep(originalStep,\n-                                new HasStep(traversal,\n-                                    new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(vertex))),\n-                                traversal);\n-                        }\n-                    }\n+            });\n+    }\n+\n+    private void replaceStep(Traversal.Admin<?, ?> traversal, OptimizableQueryType type,\n+                             TraversalFilterStep originalStep, List<Step> steps) {\n+        // Get the direction in which we filter on the adjacent vertex (or null if not a valid\n+        // adjacency filter)\n+        Direction direction = parseDirection(steps);\n+        P predicate = parsePredicate(type, steps);\n+        // Check that we have a valid direction and a valid vertex filter predicate\n+        if (direction != null && isValidPredicate(type, predicate) &&\n+            isPreviousStepValid(originalStep, direction)) {\n+            // Now replace the step with a has condition\n+            HasContainer hc =\n+                new HasContainer(ImplicitKey.ADJACENT_ID.name(), P.eq(predicate.getValue()));\n+            TraversalHelper.replaceStep(originalStep, new HasStep(traversal, hc), traversal);\n+        }\n+    }\n+\n+    private OptimizableQueryType analyzeSubSteps(List<Step> steps) {\n+        if (steps.size() != 2) {\n+            return OptimizableQueryType.NONE;\n+        }\n+\n+        boolean validFirstStep = (steps.get(0) instanceof EdgeVertexStep);\n+        validFirstStep = validFirstStep || (steps.get(0) instanceof EdgeOtherVertexStep);\n \n+        if (!validFirstStep) {\n+            return OptimizableQueryType.NONE;\n+        }\n+\n+        if (steps.get(1) instanceof IsStep) {\n+            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.is(x)\n+            return OptimizableQueryType.IS;\n+        } else if (steps.get(1) instanceof HasStep) {\n+            // Check if this filter traversal matches the pattern: _.inV/outV/otherV.hasId(x)\n+            HasStep hasStep = (HasStep) steps.get(1);\n+            if (hasStep.getHasContainers().size() != 1) {\n+                // TODO does it make sense to allow steps with > 1 containers here?\n+                return OptimizableQueryType.NONE;\n+            }\n+\n+            HasContainer has = (HasContainer) hasStep.getHasContainers().get(0);\n+            if (has.getKey().equals(T.id.getAccessor())) {\n+                return OptimizableQueryType.HASID;\n+            } else {\n+                return OptimizableQueryType.NONE;\n+            }\n+        } else {\n+            return OptimizableQueryType.NONE;\n+        }\n+    }\n+\n+    private boolean isPreviousStepValid(TraversalFilterStep originalStep, Direction direction) {\n+        // check that this step is preceded by VertexStep that returns edges\n+        Step<?, ?> previousStep = originalStep.getPreviousStep();\n+        while (previousStep != EmptyStep.instance()) {\n+            if (!(previousStep instanceof HasStep) && !(previousStep instanceof IdentityStep)) {\n+                break;\n+            }\n+            previousStep = previousStep.getPreviousStep();\n+        }\n+\n+        if (previousStep instanceof VertexStep) {\n+            try (VertexStep<?> vertexStep = (VertexStep<?>) previousStep) {", "originalCommit": "eccf0a518549350a55aa331a587ecc4f61f8f0ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ3NjA3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r380476070", "bodyText": "When not closing vertexStep, Java outputs a warning about a possible resource leak.", "author": "rngcntr", "createdAt": "2020-02-18T06:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzMTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwMTE3OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r380801178", "bodyText": "@rngcntr Can you confirm a possible resource leak here?\nI am just not sure if there is a resource leak. What about other possible VertexStep which are not connected to this optimization? Do we have a resource leak there?\nWhat about all other steps which implement AutoCloseable (most of the steps are either implementing it through TraversalParent or directly)? Do we have resource leak there or is this resource leak connected only to this optimization?\nIf the resource leak is connected to all steps, then we should close them somewhere else (no in particular optimization step). If the resource leak is directly connected to this optimization, then you are doing it right and we should close those steps here.\nI am not very familiar with that code base, so I don't currently see resource leak here.\nWhat I am thinking is that maybe we should close originalStep because we replace it with a new step but I am not sure about it yet.\nAlso, I don't want to introduce a bug here in case this vertex step is supossed to be closed at some other stage but we are closing it erlier, in such case we could introduce a new bug. I don't tell that this code introduces a new bug I just tell that I don't see this code to fix any existing bug (at least, I can't verify it yet).\nI think maybe it is better to not mix the possible resource leak (which isn't connected to this PR) and hasId optimization.\nI think a separate PR to fix a possible resource leak would be a better choice (if there is a resource leak).\nIf you can confirm resource leak, then I am OK with making this change in this PR. If you are able to add a test which verifies this resource leak, it would be great.", "author": "porunov", "createdAt": "2020-02-18T16:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzMTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjY4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r381106680", "bodyText": "I can neither confirm the resource leak nor find any find any bugs (covered by the tests) that arise from closing the step here.\nInternally, close() causes the underlying FlatMapStep's Iterator to be closed if it implements AutoCloseable. This Iterator is initialized with a singleton instance of the class EmptyIterator (which is replaced with an actual Iterator of the Elements emitted by the call of flatMap()).\nBecause EmptyIterator does not implement AutoCloseable, the call of close() has no other effect than satisfying the compiler ;)\nI quickly discussed this with @farodin91 yesterday and we came to the conclusion that even if there's no point in calling close() in this particular case, it aids consistency of the source code in general.\nDon't get me wrong here, I'm also fine with keeping this step unclosed if others prefer", "author": "rngcntr", "createdAt": "2020-02-19T06:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzMTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM2Mjc0OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r381362748", "bodyText": "What do you mean by it aids consistency of the source code in general.?\nAs for me, if we are calling close for some steps (without any logic behind this except removing the warning from compiler) and not calling close for other steps then it looks like inconsistent code.\nLet's imagine the situation when close method actually making the step unreadable. In such case, we will experience a situation, that sometimes, some of VertexSteps are closed during the optimization phase, but some of VertexSteps are not closed during the same optimization phase. We will need to track it back to this point to find out that we are closing only some VertexSteps here for no reason actually (besides making the compiler happy).\nI've described a really easy possible bug here, which I believe we will be able to find very quickly, but in the future close method may have a totally different logic, which will cause \"something\" and so, it will be hard to find out the bug which isn't easily reproducible.\nAs for me, adding such logic just to make a compiler happy is a bad idea.\nI believe, this change isn't connected to this optimization directly. I would recommend opening a new issue and discussing this change there, because this may take some time before we have a consensus on calling close here (which we are not calling right now but your PR adds this logic for some reason. As for me, the reason isn't satisfying, but other members may have more thoughts on this).", "author": "porunov", "createdAt": "2020-02-19T15:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzMTAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgxMzk3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1960#discussion_r381813970", "bodyText": "I totally get your point concerning future changes. I reverted this change and I'm now keeping the handling of close calls the same as it was before this PR.", "author": "rngcntr", "createdAt": "2020-02-20T06:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMzMTAzMw=="}], "type": "inlineReview"}, {"oid": "38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "url": "https://github.com/JanusGraph/janusgraph/commit/38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-20T06:52:40Z", "type": "commit"}, {"oid": "38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "url": "https://github.com/JanusGraph/janusgraph/commit/38a8b853c479b8951b83bf8b5b8cbf02c650f58e", "message": "Optimize hasId() in the same way as is()\n\nAdd tests for optimization of hasId()\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-20T06:52:40Z", "type": "forcePushed"}]}