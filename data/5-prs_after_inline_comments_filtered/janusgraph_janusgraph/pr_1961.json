{"pr_number": 1961, "pr_title": "Apply optimizations to queries to make use of adjacent ids", "pr_createdAt": "2020-02-14T09:38:28Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/1961", "timeline": [{"oid": "a9c91c52e62b8c2287e52ee1cb8bdac4ce20b5b4", "url": "https://github.com/JanusGraph/janusgraph/commit/a9c91c52e62b8c2287e52ee1cb8bdac4ce20b5b4", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-14T09:53:19Z", "type": "forcePushed"}, {"oid": "fd0e7772446cd7d30058ffe544cb5caeecfa9cae", "url": "https://github.com/JanusGraph/janusgraph/commit/fd0e7772446cd7d30058ffe544cb5caeecfa9cae", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-17T09:28:12Z", "type": "forcePushed"}, {"oid": "c963c0f9b5b02bcdf5db77bdc25dfa5cb09c46cd", "url": "https://github.com/JanusGraph/janusgraph/commit/c963c0f9b5b02bcdf5db77bdc25dfa5cb09c46cd", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-20T14:35:48Z", "type": "forcePushed"}, {"oid": "aa674d8a506be800bb621cbe3d4aecfcda538af7", "url": "https://github.com/JanusGraph/janusgraph/commit/aa674d8a506be800bb621cbe3d4aecfcda538af7", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-21T07:50:39Z", "type": "forcePushed"}, {"oid": "910410f99a2c2b2c0f3b65b9c557ba65dd0b443e", "url": "https://github.com/JanusGraph/janusgraph/commit/910410f99a2c2b2c0f3b65b9c557ba65dd0b443e", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-24T12:27:02Z", "type": "forcePushed"}, {"oid": "0c63a36af2696d60ec00c6f4e46afb98d0100a56", "url": "https://github.com/JanusGraph/janusgraph/commit/0c63a36af2696d60ec00c6f4e46afb98d0100a56", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-24T12:55:29Z", "type": "forcePushed"}, {"oid": "8d5093e20c9948f926d1185e5a41d189155c6694", "url": "https://github.com/JanusGraph/janusgraph/commit/8d5093e20c9948f926d1185e5a41d189155c6694", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-24T14:19:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNjQxMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383606413", "bodyText": "This value is never used", "author": "porunov", "createdAt": "2020-02-25T01:10:00Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright 2019 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeOtherVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public abstract class AdjacentVertexOptimizerStrategy<T extends FilterStep<?>>\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+\n+    T stepType;", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNzU3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383607576", "bodyText": "Can be simplified:\nP<?> predicate = parsePredicate(step);\nif (isValidPredicate(predicate)) {\n    OptimizablePosition pos = isOptimizableByPosition(step);\n    replaceSequence(step, pos, predicate);\n}\n\nThe method isOptimizableByPredicate is unnecessary.", "author": "porunov", "createdAt": "2020-02-25T01:14:21Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright 2019 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeOtherVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public abstract class AdjacentVertexOptimizerStrategy<T extends FilterStep<?>>\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+\n+    T stepType;\n+\n+    protected enum OptimizablePosition {\n+        NONE,\n+        V2V_ID,    // vertex-to-vertex step with following filter on id\n+        V2E_E2V_ID // vertex-to-edge step with following edge-to-vertex-step and filter on id\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<Class<? extends ProviderOptimizationStrategy>>();\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    protected void optimizeStep(T step) {\n+        if (isOptimizableByPredicate(step)) {\n+            OptimizablePosition pos = isOptimizableByPosition(step);\n+            P<?> predicate = parsePredicate(step);\n+            replaceSequence(step, pos, predicate);\n+        }", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3MzEwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383673105", "bodyText": "I agree", "author": "rngcntr", "createdAt": "2020-02-25T06:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNzU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NjA1NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383686055", "bodyText": "Here I mean to move 'P<?> predicate = parsePredicate(step);'  outside of the 'if' statement. In such case you don't need to call 'parsePredicate(step)' 2 times. You need to call it only once. Both, for checking its validity and using it inside the 'if' statement. Currently you are calling 'parsePredicate(step)' method 2 times", "author": "porunov", "createdAt": "2020-02-25T06:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNzU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNzkzMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383607933", "bodyText": "Should be called getOptimizablePosition", "author": "porunov", "createdAt": "2020-02-25T01:15:37Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright 2019 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeOtherVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public abstract class AdjacentVertexOptimizerStrategy<T extends FilterStep<?>>\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+\n+    T stepType;\n+\n+    protected enum OptimizablePosition {\n+        NONE,\n+        V2V_ID,    // vertex-to-vertex step with following filter on id\n+        V2E_E2V_ID // vertex-to-edge step with following edge-to-vertex-step and filter on id\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<Class<? extends ProviderOptimizationStrategy>>();\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    protected void optimizeStep(T step) {\n+        if (isOptimizableByPredicate(step)) {\n+            OptimizablePosition pos = isOptimizableByPosition(step);\n+            P<?> predicate = parsePredicate(step);\n+            replaceSequence(step, pos, predicate);\n+        }\n+    }\n+\n+    private boolean isOptimizableByPredicate(T step) {\n+        return isValidPredicate(parsePredicate(step));\n+    }\n+\n+    protected abstract P<?> parsePredicate(T step);\n+\n+    protected abstract boolean isValidPredicate(P<?> predicate);\n+\n+    private OptimizablePosition isOptimizableByPosition(T originalStep) {", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwOTE3NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383609175", "bodyText": "Move prePredecessor after the first if because it isn't necessary if the predecessor is instance of VertexStep", "author": "porunov", "createdAt": "2020-02-25T01:20:15Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright 2019 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeOtherVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public abstract class AdjacentVertexOptimizerStrategy<T extends FilterStep<?>>\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+\n+    T stepType;\n+\n+    protected enum OptimizablePosition {\n+        NONE,\n+        V2V_ID,    // vertex-to-vertex step with following filter on id\n+        V2E_E2V_ID // vertex-to-edge step with following edge-to-vertex-step and filter on id\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<Class<? extends ProviderOptimizationStrategy>>();\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    protected void optimizeStep(T step) {\n+        if (isOptimizableByPredicate(step)) {\n+            OptimizablePosition pos = isOptimizableByPosition(step);\n+            P<?> predicate = parsePredicate(step);\n+            replaceSequence(step, pos, predicate);\n+        }\n+    }\n+\n+    private boolean isOptimizableByPredicate(T step) {\n+        return isValidPredicate(parsePredicate(step));\n+    }\n+\n+    protected abstract P<?> parsePredicate(T step);\n+\n+    protected abstract boolean isValidPredicate(P<?> predicate);\n+\n+    private OptimizablePosition isOptimizableByPosition(T originalStep) {\n+        Step<?, ?> predecessor = originalStep.getPreviousStep();\n+        Step<?, ?> prePredecessor = predecessor.getPreviousStep();", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxMTUzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383611537", "bodyText": "As I understand this if won't be executed because we call this method only if the above checks are passed already (see isOptimizableByPosition method).\nIf so, can't we just remove all this if else if else else and write the next line?\nStep<Edge,Vertex> e2vStep = (Step<Edge,Vertex>) originalStep.getPreviousStep();", "author": "porunov", "createdAt": "2020-02-25T01:29:08Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright 2019 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeOtherVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public abstract class AdjacentVertexOptimizerStrategy<T extends FilterStep<?>>\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+\n+    T stepType;\n+\n+    protected enum OptimizablePosition {\n+        NONE,\n+        V2V_ID,    // vertex-to-vertex step with following filter on id\n+        V2E_E2V_ID // vertex-to-edge step with following edge-to-vertex-step and filter on id\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<Class<? extends ProviderOptimizationStrategy>>();\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    protected void optimizeStep(T step) {\n+        if (isOptimizableByPredicate(step)) {\n+            OptimizablePosition pos = isOptimizableByPosition(step);\n+            P<?> predicate = parsePredicate(step);\n+            replaceSequence(step, pos, predicate);\n+        }\n+    }\n+\n+    private boolean isOptimizableByPredicate(T step) {\n+        return isValidPredicate(parsePredicate(step));\n+    }\n+\n+    protected abstract P<?> parsePredicate(T step);\n+\n+    protected abstract boolean isValidPredicate(P<?> predicate);\n+\n+    private OptimizablePosition isOptimizableByPosition(T originalStep) {\n+        Step<?, ?> predecessor = originalStep.getPreviousStep();\n+        Step<?, ?> prePredecessor = predecessor.getPreviousStep();\n+\n+        // match predecessing out(), in() or both() steps\n+        if (predecessor instanceof VertexStep<?>) {\n+            if (((VertexStep<?>) predecessor).returnsVertex()) {\n+                return OptimizablePosition.V2V_ID;\n+            }\n+            return OptimizablePosition.NONE;\n+        }\n+\n+        // match predecessing inV(), outV() or otherV() steps\n+        // predecessor has to operate on an edge type\n+        if ((predecessor instanceof EdgeVertexStep || predecessor instanceof EdgeOtherVertexStep) &&\n+            (prePredecessor instanceof VertexStep) && ((VertexStep<?>) prePredecessor).returnsEdge()) {\n+            return OptimizablePosition.V2E_E2V_ID;\n+        }\n+\n+        return OptimizablePosition.NONE;\n+    }\n+\n+    private void replaceSequence(T originalStep, OptimizablePosition pos,\n+                                   P<?> predicate) {\n+        switch (pos) {\n+        case V2E_E2V_ID:\n+            replaceSequenceV2EthenE2VthenID(originalStep, predicate);\n+            break;\n+        case V2V_ID:\n+            replaceSequenceV2VthenID(originalStep, predicate);\n+            break;\n+        default:\n+            break;\n+        }\n+    }\n+\n+    private void replaceSequenceV2EthenE2VthenID(T originalStep, P<?> predicate) {\n+        Traversal.Admin<?,?> traversal = originalStep.getTraversal();\n+\n+        Step<Edge,Vertex> e2vStep;\n+        if (originalStep.getPreviousStep() instanceof EdgeVertexStep) {\n+            e2vStep = (EdgeVertexStep) originalStep.getPreviousStep();\n+        } else if (originalStep.getPreviousStep() instanceof EdgeOtherVertexStep) {\n+            e2vStep = (EdgeOtherVertexStep) originalStep.getPreviousStep();\n+        } else {\n+            return;", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3NTIzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383675237", "bodyText": "This works fine while making the code more readable. Thanks!", "author": "rngcntr", "createdAt": "2020-02-25T06:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxMTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxMjY1OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383612659", "bodyText": "Duplicate code can be moved to a separate method like:\nprivate HasStep<Edge> makeHasAdjacentIdStep(Traversal.Admin<?,?> traversal, P<?> predicate){\n    HasContainer hc = new HasContainer(ADJACENT_ID.name(), P.eq(predicate.getValue()));\n    return new HasStep<>(traversal, hc);\n}", "author": "porunov", "createdAt": "2020-02-25T01:33:21Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright 2019 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import static org.janusgraph.graphdb.types.system.ImplicitKey.ADJACENT_ID;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.FilterStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeOtherVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.EdgeVertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.VertexStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.Direction;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public abstract class AdjacentVertexOptimizerStrategy<T extends FilterStep<?>>\n+    extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+\n+    T stepType;\n+\n+    protected enum OptimizablePosition {\n+        NONE,\n+        V2V_ID,    // vertex-to-vertex step with following filter on id\n+        V2E_E2V_ID // vertex-to-edge step with following edge-to-vertex-step and filter on id\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPost() {\n+        Set<Class<? extends ProviderOptimizationStrategy>> postStrategies = new HashSet<Class<? extends ProviderOptimizationStrategy>>();\n+        postStrategies.add(JanusGraphLocalQueryOptimizerStrategy.class);\n+        return postStrategies;\n+    }\n+\n+    protected void optimizeStep(T step) {\n+        if (isOptimizableByPredicate(step)) {\n+            OptimizablePosition pos = isOptimizableByPosition(step);\n+            P<?> predicate = parsePredicate(step);\n+            replaceSequence(step, pos, predicate);\n+        }\n+    }\n+\n+    private boolean isOptimizableByPredicate(T step) {\n+        return isValidPredicate(parsePredicate(step));\n+    }\n+\n+    protected abstract P<?> parsePredicate(T step);\n+\n+    protected abstract boolean isValidPredicate(P<?> predicate);\n+\n+    private OptimizablePosition isOptimizableByPosition(T originalStep) {\n+        Step<?, ?> predecessor = originalStep.getPreviousStep();\n+        Step<?, ?> prePredecessor = predecessor.getPreviousStep();\n+\n+        // match predecessing out(), in() or both() steps\n+        if (predecessor instanceof VertexStep<?>) {\n+            if (((VertexStep<?>) predecessor).returnsVertex()) {\n+                return OptimizablePosition.V2V_ID;\n+            }\n+            return OptimizablePosition.NONE;\n+        }\n+\n+        // match predecessing inV(), outV() or otherV() steps\n+        // predecessor has to operate on an edge type\n+        if ((predecessor instanceof EdgeVertexStep || predecessor instanceof EdgeOtherVertexStep) &&\n+            (prePredecessor instanceof VertexStep) && ((VertexStep<?>) prePredecessor).returnsEdge()) {\n+            return OptimizablePosition.V2E_E2V_ID;\n+        }\n+\n+        return OptimizablePosition.NONE;\n+    }\n+\n+    private void replaceSequence(T originalStep, OptimizablePosition pos,\n+                                   P<?> predicate) {\n+        switch (pos) {\n+        case V2E_E2V_ID:\n+            replaceSequenceV2EthenE2VthenID(originalStep, predicate);\n+            break;\n+        case V2V_ID:\n+            replaceSequenceV2VthenID(originalStep, predicate);\n+            break;\n+        default:\n+            break;\n+        }\n+    }\n+\n+    private void replaceSequenceV2EthenE2VthenID(T originalStep, P<?> predicate) {\n+        Traversal.Admin<?,?> traversal = originalStep.getTraversal();\n+\n+        Step<Edge,Vertex> e2vStep;\n+        if (originalStep.getPreviousStep() instanceof EdgeVertexStep) {\n+            e2vStep = (EdgeVertexStep) originalStep.getPreviousStep();\n+        } else if (originalStep.getPreviousStep() instanceof EdgeOtherVertexStep) {\n+            e2vStep = (EdgeOtherVertexStep) originalStep.getPreviousStep();\n+        } else {\n+            return;\n+        }\n+\n+        // create new has(\"~adjacent\", id_value) step before e2v step\n+        HasContainer hc = new HasContainer(ADJACENT_ID.name(), P.eq(predicate.getValue()));\n+        HasStep<Edge> hasAdjacentIdStep = new HasStep<Edge>(traversal, hc);", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxNDc2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383614765", "bodyText": "Redundant type cast", "author": "porunov", "createdAt": "2020-02-25T01:42:05Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/AdjacentVertexHasIdOptimizerStrategy.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright 2019 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import java.util.List;\n+import org.apache.tinkerpop.gremlin.process.traversal.Compare;\n+import org.apache.tinkerpop.gremlin.process.traversal.P;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.HasStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.T;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class AdjacentVertexHasIdOptimizerStrategy\n+    extends AdjacentVertexOptimizerStrategy<HasStep<?>> {\n+\n+    private static final AdjacentVertexHasIdOptimizerStrategy INSTANCE =\n+        new AdjacentVertexHasIdOptimizerStrategy();\n+\n+    private AdjacentVertexHasIdOptimizerStrategy() {}\n+\n+    public static AdjacentVertexHasIdOptimizerStrategy instance() { return INSTANCE; }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        TraversalHelper.getStepsOfClass(HasStep.class, traversal)\n+            .forEach(step -> optimizeStep(step));\n+    }\n+\n+    @Override\n+    protected P<?> parsePredicate(HasStep<?> hasStep) {\n+        List<HasContainer> hasContainers = hasStep.getHasContainers();\n+\n+        if (hasContainers.size() != 1) {\n+            return null; // TODO does it make sense to allow steps with >1 containers here?\n+        }\n+\n+        HasContainer hc = (HasContainer) hasStep.getHasContainers().get(0);", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzIyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383627223", "bodyText": "Why don't you use ImplicitKey.ADJACENT_ID here but use ~adjacent?", "author": "porunov", "createdAt": "2020-02-25T02:31:27Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphTest.java", "diffHunk": "@@ -4110,6 +4121,80 @@ public void testTinkerPopOptimizationStrategies() {\n         assertNumStep(1, 1, gts.V(sv[0]).bothE(\"knows\").filter(__.otherV().hasId(vs[50].id())), JanusGraphVertexStep.class, TraversalFilterStep.class);\n         assertNumStep(1, 2, gts.V(sv[0]).bothE(\"knows\").filter(__.inV().hasId(vs[50].id())), JanusGraphVertexStep.class, TraversalFilterStep.class);\n \n+        // AdjacentVertexIsOptimizer outE/inE/bothE\n+        assertOptimization(gts.V(sv[0]).outE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).inV(),\n+                           gts.V(sv[0]).outE(\"knows\").inV().is(vs[50]),\n+                           AdjacentVertexIsOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).inE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).outV(),\n+                           gts.V(sv[0]).inE(\"knows\").outV().is(vs[50]),\n+                           AdjacentVertexIsOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).bothE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).otherV(),\n+                           gts.V(sv[0]).bothE(\"knows\").otherV().is(vs[50]),\n+                           AdjacentVertexIsOptimizerStrategy.instance());\n+\n+        // AdjacentVertexIsOptimizer out/in/both\n+        assertOptimization(gts.V(sv[0]).outE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).inV(),\n+                           gts.V(sv[0]).out(\"knows\").is(vs[50]),\n+                           AdjacentVertexIsOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).inE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).outV(),\n+                           gts.V(sv[0]).in(\"knows\").is(vs[50]),\n+                           AdjacentVertexIsOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).bothE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).otherV(),\n+                           gts.V(sv[0]).both(\"knows\").is(vs[50]),\n+                           AdjacentVertexIsOptimizerStrategy.instance());\n+\n+        // AdjacentVertexHasIdOptimizer outE/inE/bothE\n+        assertOptimization(gts.V(sv[0]).outE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).inV(),\n+                           gts.V(sv[0]).outE(\"knows\").inV().hasId(vs[50]),\n+                           AdjacentVertexHasIdOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).inE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).outV(),\n+                           gts.V(sv[0]).inE(\"knows\").outV().hasId(vs[50]),\n+                           AdjacentVertexHasIdOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).bothE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).otherV(),\n+                           gts.V(sv[0]).bothE(\"knows\").otherV().hasId(vs[50]),\n+                           AdjacentVertexHasIdOptimizerStrategy.instance());\n+\n+        // AdjacentVertexHasIdOptimizer out/in/both\n+        assertOptimization(gts.V(sv[0]).outE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).inV(),\n+                           gts.V(sv[0]).out(\"knows\").hasId(vs[50]),\n+                           AdjacentVertexHasIdOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).inE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).outV(),\n+                           gts.V(sv[0]).in(\"knows\").hasId(vs[50]),\n+                           AdjacentVertexHasIdOptimizerStrategy.instance());\n+        assertOptimization(gts.V(sv[0]).bothE(\"knows\").has(ImplicitKey.ADJACENT_ID.name(), vs[50]).otherV(),\n+                           gts.V(sv[0]).both(\"knows\").hasId(vs[50]),\n+                           AdjacentVertexHasIdOptimizerStrategy.instance());\n+\n+        // neq should not be optimized\n+        assertOptimization(gts.V(sv[0]).in().hasId(P.neq(vs[50])),\n+                           gts.V(sv[0]).in().hasId(P.neq(vs[50])),\n+                           AdjacentVertexHasIdOptimizerStrategy.instance());\n+\n+        int[] loop1 = {0}; // repeat starts from vertex with id 0 and goes in to the sv[0] vertex then loops back out to the vertex with the next id\n+        int[] loop2 = {0};\n+        GraphTraversal t1 = gts.V(vs[0], vs[1], vs[2])\n+                           .repeat(__.inE(\"knows\")\n+                                       .has(\"~adjacent\", sv[0].id())", "originalCommit": "8d5093e20c9948f926d1185e5a41d189155c6694", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3Njg5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1961#discussion_r383676891", "bodyText": "This was just a result of frequent deleting and re-writing parts of the query in order to find the mentioned TinkerPop bug. At some point typing \"~adjacent\" was much quicker than typing ImplicitKey.ADJACENT_ID.name(). I will change this to match the style of the other tests", "author": "rngcntr", "createdAt": "2020-02-25T06:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyNzIyMw=="}], "type": "inlineReview"}, {"oid": "422a8409a5820747584c8186aea38feb5642c544", "url": "https://github.com/JanusGraph/janusgraph/commit/422a8409a5820747584c8186aea38feb5642c544", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-25T06:14:39Z", "type": "forcePushed"}, {"oid": "0f7af8db0cfa9923fc45eeddbc01a8aa89c6f5f8", "url": "https://github.com/JanusGraph/janusgraph/commit/0f7af8db0cfa9923fc45eeddbc01a8aa89c6f5f8", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-25T13:38:10Z", "type": "commit"}, {"oid": "0f7af8db0cfa9923fc45eeddbc01a8aa89c6f5f8", "url": "https://github.com/JanusGraph/janusgraph/commit/0f7af8db0cfa9923fc45eeddbc01a8aa89c6f5f8", "message": "Apply optimizations to queries to make use of adjacent ids\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-25T13:38:10Z", "type": "forcePushed"}]}