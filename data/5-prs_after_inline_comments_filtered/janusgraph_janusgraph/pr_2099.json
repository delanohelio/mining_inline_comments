{"pr_number": 2099, "pr_title": "GraphCentricQueryBuilder: Optimize index selection algorithm [continuation]", "pr_createdAt": "2020-04-27T10:48:10Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2099", "timeline": [{"oid": "df8eb753a4e44ca74e79cc00c07c5d78186e94db", "url": "https://github.com/JanusGraph/janusgraph/commit/df8eb753a4e44ca74e79cc00c07c5d78186e94db", "message": "Move score logic towards IndexCandidate(Group)\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-04-27T10:52:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5MTk2MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r417991961", "bodyText": "Can we maybe follow guava's powerSet contract? They look reasonable to me and nice to have IMHO.\nIllegalArgumentException: If set has more than 30 unique elements, because this causes the power set size to exceed the int range.\nNullPointerException: If set is or contains null.", "author": "li-boxuan", "createdAt": "2020-04-30T13:02:18Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class SetUtil {\n+    \n+    public static <T> Set<Set<T>> powerSet(final Set<T> originalSet) {", "originalCommit": "0131c6bde27a13ed5af79fcb7644780c470dd7bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxNzk4MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r418017981", "bodyText": "Did you explore Guava's PowerSet implementation? Their implementation seems to be more efficient: https://www.baeldung.com/java-power-set-of-a-set#optimization, and more importantly, it only uses O(n) space by utilizing the Iterator interface.", "author": "li-boxuan", "createdAt": "2020-04-30T13:41:05Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/SetUtil.java", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class SetUtil {\n+    \n+    public static <T> Set<Set<T>> powerSet(final Set<T> originalSet) {\n+        int resultSize = (int) Math.pow(2, originalSet.size());\n+        Set<Set<T>> resultSets = new HashSet<Set<T>>(resultSize);\n+\n+        resultSets.add(new HashSet<T>(0));\n+\n+        if (originalSet.isEmpty()) {\n+            return resultSets;\n+        }\n+\n+        Set<T> remaining = new HashSet<T>(originalSet);\n+        T first = remaining.iterator().next();\n+        remaining.remove(first);\n+\n+        for (Set<T> intermediateSet : powerSet(remaining)) {", "originalCommit": "0131c6bde27a13ed5af79fcb7644780c470dd7bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAyMjg5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r418022890", "bodyText": "Very interesting, I'll have a look at it!", "author": "rngcntr", "createdAt": "2020-04-30T13:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxNzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIyMDA0NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r419220044", "bodyText": "I refactored the code, it should not exceed the O(n) space bound now", "author": "rngcntr", "createdAt": "2020-05-04T05:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxNzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MzE0NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r419153145", "bodyText": "I didn't check the code yet, but have general questions about this optimization.\n\n\nDo I understand it correctly that if we use index-select-threshold = 0 it means that current logic (which is currently in master branch) will be used? I.e., as I understand, if we use 0 it means that the behaviour will be the same as in current master branch and complexity of the current algorithm to select indexes will not be increased.\n\n\nIf 1) is yes than I see that this value is set by default to 10. It means that it is a breaking change. If so, we should describe this breaking change here https://github.com/JanusGraph/janusgraph/blob/master/docs/changelog.md#upgrade-instructions\n\n\nIs it suggested to use 10 here or should user somehow decide what value to use here? Just interested, if there is 10 or less candidates, is it faster to use brute force algorithm or is it just sufficiently fast so that it is OK to sacrifice candidate selection performance if favour to choosing a good candidate?", "author": "porunov", "createdAt": "2020-05-03T20:07:58Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/configuration/GraphDatabaseConfiguration.java", "diffHunk": "@@ -265,6 +265,13 @@\n                     \"performance improvement if there is a non-trivial latency to the backend.\",\n             ConfigOption.Type.MASKABLE, false);\n \n+    public static final ConfigOption<Integer> INDEX_SELECT_BRUTE_FORCE_THRESHOLD = new ConfigOption<>(QUERY_NS, \"index-select-threshold\",\n+            \"Threshold of deciding whether to use brute force enumeration algorithm or fast approximation algorithm \" +\n+                    \"for selecting suitable indexes. Selecting optimal indexes for a query is a NP-complete set cover problem. \" +\n+                    \"When number of suitable index candidates is no larger than threshold, JanusGraph uses brute force search \" +\n+                    \"with exponential time complexity to ensure the best combination of indexes is selected.\",\n+            ConfigOption.Type.MASKABLE, 10);\n+", "originalCommit": "0131c6bde27a13ed5af79fcb7644780c470dd7bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE4MzkxNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r419183917", "bodyText": "Yes, if set to 0, then the existing logic in current master branch will be used.\n10 is an arbitrary number picked by me originally. My primary purpose was to pick up a threshold that is \"just sufficiently fast so that it is OK to sacrifice candidate selection performance if favour to choosing a good candidate\". We could make it even smaller just to be safe it will make as least impact as possible.\nIn practice, I think the chance is small that people have many index candidates (e.g. >= 5) for one index query.", "author": "li-boxuan", "createdAt": "2020-05-04T01:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MzE0NQ=="}], "type": "inlineReview"}, {"oid": "b8b801a9d163cc0766118e981f16c76830fe6bea", "url": "https://github.com/JanusGraph/janusgraph/commit/b8b801a9d163cc0766118e981f16c76830fe6bea", "message": "Refactor PowerSet implementation\n\n(requested by @li-boxuan)\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-04T05:45:22Z", "type": "forcePushed"}, {"oid": "3ce8c931b0ddf729d34e438512b4451ce0f0adc7", "url": "https://github.com/JanusGraph/janusgraph/commit/3ce8c931b0ddf729d34e438512b4451ce0f0adc7", "message": "Resolve conflicts\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-04T05:54:35Z", "type": "forcePushed"}, {"oid": "6e41aed050852e2792e24ba6f74604fa1c1a5122", "url": "https://github.com/JanusGraph/janusgraph/commit/6e41aed050852e2792e24ba6f74604fa1c1a5122", "message": "GraphCentricQueryBuilder: Optimize index selection algorithm\n\nThis intends to optimize index selection algorithm by introducing\na brute force enumeration way to select appropriate indexes in\nGraphCentricQueryBuilder.\n\nCloses #2048\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-05-04T06:11:27Z", "type": "commit"}, {"oid": "3edcc358bc3a802c4907ef0df3ecf291dbb89b12", "url": "https://github.com/JanusGraph/janusgraph/commit/3edcc358bc3a802c4907ef0df3ecf291dbb89b12", "message": "Resolve conflicts\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-04T06:11:39Z", "type": "forcePushed"}, {"oid": "751d4c40944bcd90c15c8346b526734fdfa62db5", "url": "https://github.com/JanusGraph/janusgraph/commit/751d4c40944bcd90c15c8346b526734fdfa62db5", "message": "Move score logic towards IndexCandidate(Group)\n\nAdditionally: Use custom implementation of powerSet instead of Guava\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-05T07:13:40Z", "type": "forcePushed"}, {"oid": "805898c704878418a853b44cbd4a651972267581", "url": "https://github.com/JanusGraph/janusgraph/commit/805898c704878418a853b44cbd4a651972267581", "message": "Move score logic towards IndexCandidate(Group)\n\nAdditionally: Use custom implementation of powerSet instead of Guava\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-06T08:50:48Z", "type": "commit"}, {"oid": "805898c704878418a853b44cbd4a651972267581", "url": "https://github.com/JanusGraph/janusgraph/commit/805898c704878418a853b44cbd4a651972267581", "message": "Move score logic towards IndexCandidate(Group)\n\nAdditionally: Use custom implementation of powerSet instead of Guava\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-06T08:50:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4Mjc1OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424182759", "bodyText": "Add final", "author": "porunov", "createdAt": "2020-05-13T05:35:46Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java", "diffHunk": "@@ -0,0 +1,78 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class PowerSet<T> extends AbstractSet<Set<T>> {\n+    \n+    private Set<T> originalSet;", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4OTYyOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424189629", "bodyText": "Add static", "author": "porunov", "createdAt": "2020-05-13T05:58:57Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java", "diffHunk": "@@ -0,0 +1,78 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class PowerSet<T> extends AbstractSet<Set<T>> {\n+    \n+    private Set<T> originalSet;\n+\n+    public PowerSet(final Set<T> originalSet) {\n+        this.originalSet = originalSet;\n+    }\n+\n+    @Override\n+    public Iterator<Set<T>> iterator() {\n+        return new PowerSetIterator<T>(originalSet);\n+    }\n+\n+    @Override\n+    public int size() {\n+        return 1 << originalSet.size();\n+    }\n+\n+    private class PowerSetIterator<T> implements Iterator<Set<T>> {", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4OTczNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424189735", "bodyText": "add final", "author": "porunov", "createdAt": "2020-05-13T05:59:18Z", "path": "janusgraph-core/src/main/java/org/janusgraph/util/datastructures/PowerSet.java", "diffHunk": "@@ -0,0 +1,78 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util.datastructures;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class PowerSet<T> extends AbstractSet<Set<T>> {\n+    \n+    private Set<T> originalSet;\n+\n+    public PowerSet(final Set<T> originalSet) {\n+        this.originalSet = originalSet;\n+    }\n+\n+    @Override\n+    public Iterator<Set<T>> iterator() {\n+        return new PowerSetIterator<T>(originalSet);\n+    }\n+\n+    @Override\n+    public int size() {\n+        return 1 << originalSet.size();\n+    }\n+\n+    private class PowerSetIterator<T> implements Iterator<Set<T>> {\n+\n+        private List<T> originalElements;", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NDA3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424644076", "bodyText": "this.coveredClauses = new HashSet<>(indexCandidates.size());", "author": "porunov", "createdAt": "2020-05-13T18:25:59Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidateGroup.java", "diffHunk": "@@ -0,0 +1,71 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.graphdb.query.condition.Condition;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidateGroup implements Comparable<IndexCandidateGroup> {\n+\n+    private Set<IndexCandidate> indexCandidates;\n+    private Set<Condition> coveredClauses;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidateGroup(Set<IndexCandidate> indexCandidates) {\n+        this.indexCandidates = indexCandidates;\n+        this.coveredClauses = new HashSet<>();", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5MDI0NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424690244", "bodyText": "Redundant null initialization", "author": "porunov", "createdAt": "2020-05-13T19:48:22Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTcyMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424695720", "bodyText": "I see that this logic was in the old code but CARDINALITY_SINGE_SCORE and CARDINALITY_OTHER_SCORE are both always equal to 1000, so maybe it should be combined into a single constant like CARDINALITY_SCORE?\nIf so, the code can be simplified to:\nif(index.isCompositeIndex()){\n    return CARDINALITY_SINGE_SCORE;\n}\nreturn 0.0;", "author": "porunov", "createdAt": "2020-05-13T19:58:23Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        if (index.isCompositeIndex()) {\n+            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n+        }\n+        \n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }\n+\n+    public double getScore() {\n+        return score;\n+    }\n+\n+    /**\n+     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n+     * @param coveringClauses\n+     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n+     */\n+    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n+        for (final Condition c : subCover) {\n+            if (!coveringClauses.contains(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private double getConditionBasicScore(final Condition c) {\n+        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n+            return EQUAL_CONDITION_SCORE;\n+        } else {\n+            return OTHER_CONDITION_SCORE;\n+        }\n+    }\n+\n+    private double getIndexTypeScore(final IndexType index) {\n+        double score = 0.0;\n+        if (index.isCompositeIndex()) {\n+            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n+                score = CARDINALITY_SINGE_SCORE;\n+            } else {\n+                score = CARDINALITY_OTHER_SCORE;\n+            }\n+        }\n+        return score;\n+    }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU3MjQ4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r425572480", "bodyText": "To me it looks like these constants were introduced with thought in mind that there should be a distinction in scores between cardinalities. It just looks like the original author prepared this distinction but did evaluate the performance impact of different scores right away.\nTherefore in my opinion, we should keep this code as an entry point for further optimizations as it already hints to a tweak which can increase performance.", "author": "rngcntr", "createdAt": "2020-05-15T05:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU5NjE3MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r425596171", "bodyText": "Good points! Agree!", "author": "porunov", "createdAt": "2020-05-15T06:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY5NTcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwMjczMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424702730", "bodyText": "Previous logic didn't throw an exception. I guess the logic is expected to be used by users thus we should not throw an exception here.\nNot only we decrease performance for these expected scenarios but also we are hiding all exceptions later in the caller call which makes not much sense from an exception (just stopping to create a class).\nThis problem happened due to business logic in the constructor which is considered a bad practice because it becomes harder to provide mocks into the constructor and thus harder to test it in the future. It is better to follow DI here and rewrite this constructor to:\npublic IndexCandidate(IndexType index, Set<Condition> subCover, Object subCondition){\n    this.index = index;\n    this.subCover = subCover;\n    this.subCondition = subCondition;\n}", "author": "porunov", "createdAt": "2020-05-13T20:11:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDU4Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424704587", "bodyText": "Don't throw an exception on expected logic. Exception should not be used as if else conditions.", "author": "porunov", "createdAt": "2020-05-13T20:14:48Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n+            }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNDY2Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424704663", "bodyText": "Don't throw an exception on expected logic. Exception should not be used as if else conditions.", "author": "porunov", "createdAt": "2020-05-13T20:14:56Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final MultiCondition<JanusGraphElement> conditions,\n+                          final IndexSerializer serializer) {\n+        this.index = index;\n+\n+        final Set<Condition> subCover = new HashSet<>(1);\n+        Object subCondition = null;\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon =\n+                GraphCentricQueryBuilder.getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                throw new IllegalArgumentException(\"Only equality conditions are supported\");\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                throw new IllegalArgumentException(\"The query optimizer currently does not support multiple label constraints\");\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                throw new IllegalArgumentException(\"Given IndexType does not match given condition label\");\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        if (index.isCompositeIndex()) {\n+            subCondition = GraphCentricQueryBuilder.indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = GraphCentricQueryBuilder.indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            throw new IllegalArgumentException(\"Unable to initialize IndexCandidate from given parameters\");\n+        }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNTI4OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424715289", "bodyText": "To be fair, I would try to rewrite this class. I know there are a lot of places in JanusGraph where we should rewrite the code but as more we putting complex code the harder it becomes to maintain and extend it.\nIf @rngcntr can rewrite it in this PR, that's great. If cannot, I may later take this PR in made another continuation but I will need to research the logic behind it. I need to understand the purpose behind this logic more.\nBasically, what I can see here on first glance:\n\nThis is a mix of POJO + some calculation logic. It is better to separate business logic from models.\nIt violates Single-responsibility principle not only because it mix of POJO and business logic but because it combines all possible implementations of score calculation inside a single class. In case we have a totally different implementation which might depend on some dependency which neither BruteForce nor Approximation implementations depend on, then we will need to add an unnecessary dependency to those implementations.\nIt violates Dependency inversion principle because it depends on concrete subCover and subCondition inside its constructor.", "author": "porunov", "createdAt": "2020-05-13T20:35:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/util/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,170 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.util;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.GraphCentricQueryBuilder;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNjkzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424716937", "bodyText": "We should not use exceptions for checks. Also, its better to not swallow an exception. How do you know that IllegalArgumentException is a valid exception produces by your check an not by other dependant logic?\nCurrently these type of exceptions work to skip loop iteration (i.e. replace for continue which was used in the previous logic). Using exceptions just to skip loop is a bad practice. I think we should rewrite IndexCandidate code and split it to multiple classes", "author": "porunov", "createdAt": "2020-05-13T20:38:47Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -497,5 +407,122 @@ private static boolean coversAll(final MixedIndexType index, Condition<JanusGrap\n         return match != null && indexInfo.supports(index, match, atom.getPredicate());\n     }\n \n+    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                          final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        /* TODO: smarter optimization:\n+        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n+                if they would result in an individual index call (better to filter afterwards in memory)\n+        */\n+        if (indexCandidates.size() <= tx.getGraph().getConfiguration().getIndexSelectThreshold()) {\n+            return selectIndicesByBruteForce(indexCandidates, conditions, coveredClauses, isSorted);\n+        } else {\n+            return selectIndicesByApprox(indexCandidates, conditions, coveredClauses, isSorted);\n+        }\n+    }\n+\n+    /**\n+     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time complexity.\n+     * Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so we should be careful\n+     * that the problem size MUST be small, otherwise it is more recommended to use an approximation algorithm.\n+     *\n+     * @param rawCandidates\n+     * @param conditions\n+     * @param coveredClauses\n+     * @param isSorted\n+     * @return\n+     */\n+    private JointIndexQuery selectIndicesByBruteForce(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                                      final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        final Set<IndexCandidate> indexCandidates = new HashSet<>();\n+\n+        // validate, enrich index candidates and calculate scores\n+        for (final IndexType index : rawCandidates) {\n+            try {\n+                IndexCandidate ic = new IndexCandidate(index, conditions, serializer);\n+                ic.calculateScoreBruteForce();\n+                indexCandidates.add(ic);\n+            } catch (IllegalArgumentException ignored) {\n+                // ignore invalid index candidates\n+            }\n+        }\n+\n+        IndexCandidateGroup bestGroup = null;\n+        for (Set<IndexCandidate> subset : new PowerSet<IndexCandidate>(indexCandidates)) {\n+            if (subset.isEmpty()) continue;\n+            final IndexCandidateGroup group = new IndexCandidateGroup(subset);\n+            if (group.compareTo(bestGroup) > 0) {\n+                bestGroup = group;\n+            }\n+        }\n+\n+        if (bestGroup != null) {\n+            coveredClauses.addAll(bestGroup.getCoveredClauses());\n+            List<IndexCandidate> bestIndexes = new ArrayList<>(bestGroup.getIndexCandidates());\n+            // sort indexes by score descending order\n+            bestIndexes.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));\n+            // isSorted depends on the first index subquery\n+            isSorted.setValue(orders.isEmpty() || bestIndexes.get(0).getIndex().isMixedIndex()\n+                && indexCoversOrder((MixedIndexType) bestIndexes.get(0).getIndex(), orders));\n+            for (IndexCandidate c : bestIndexes) {\n+                addToJointQuery(c, jointQuery);\n+            }\n+        }\n+\n+        return jointQuery;\n+    }\n+\n+    /**\n+     * Iterate over all potential indexes and compute a score based on how many clauses\n+     * this index covers. The index with the highest score (as long as it covers at least one additional clause)\n+     * is picked and added to the joint query for as long as such exist.\n+     * @param rawCandidates\n+     * @param conditions\n+     * @param coveredClauses\n+     * @param isSorted\n+     * @return\n+     */\n+    private JointIndexQuery selectIndicesByApprox(final Set<IndexType> rawCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                                  final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        while (true) {\n+            IndexCandidate bestCandidate = null;\n+            boolean candidateSupportsSort = false;\n+\n+            for (final IndexType index : rawCandidates) {\n+                try {\n+                    final IndexCandidate indexCandidate = new IndexCandidate(index, conditions, serializer);\n+\n+                    boolean supportsSort = orders.isEmpty() ||\n+                        coveredClauses.isEmpty() && index.isMixedIndex() && indexCoversOrder((MixedIndexType) index, orders);\n+                    indexCandidate.calculateScoreApproximation(coveredClauses, supportsSort);\n \n+                    if (!indexCandidate.isCoveredBy(coveredClauses) && (bestCandidate == null || indexCandidate.getScore() > bestCandidate.getScore())) {\n+                        bestCandidate = indexCandidate;\n+                        candidateSupportsSort = supportsSort;\n+                    }\n+                } catch (IllegalArgumentException ignored) {\n+                    // ignore invalid index candidates\n+                }\n+            }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyNzE5OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424727199", "bodyText": "isSorted passed into selectIndices just to fill it with some value. It isn't obvious because it is basically used as a return value and not input value.\nIt is better to explicitly return result. We can just create another class with JointIndexQuery jointQuery and boolean isSorted and return that result from selectIndices method instead of partially returning result as a return value and partially change input value.", "author": "porunov", "createdAt": "2020-05-13T20:58:37Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -270,92 +263,9 @@ public GraphCentricQuery constructQueryWithoutProfile(final ElementCategory resu\n             return true;\n         });\n \n-        /*\n-        Determine the best join index query to answer this query:\n-        Iterate over all potential indexes (as compiled above) and compute a score based on how many clauses\n-        this index covers. The index with the highest score (as long as it covers at least one additional clause)\n-        is picked and added to the joint query for as long as such exist.\n-         */\n-        final JointIndexQuery jointQuery = new JointIndexQuery();\n-        boolean isSorted = orders.isEmpty();\n         final Set<Condition> coveredClauses = new HashSet<>();\n-        while (true) {\n-            IndexType bestCandidate = null;\n-            double candidateScore = 0.0;\n-            Set<Condition> candidateSubcover = null;\n-            boolean candidateSupportsSort = false;\n-            Object candidateSubCondition = null;\n-\n-            for (final IndexType index : indexCandidates) {\n-                final Set<Condition> subcover = new HashSet<>();\n-                Object subCondition;\n-                boolean supportsSort = orders.isEmpty();\n-                //Check that this index actually applies in case of a schema constraint\n-                if (index.hasSchemaTypeConstraint()) {\n-                    final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n-                    final Map.Entry<Condition,Collection<Object>> equalCon\n-                            = getEqualityConditionValues(conditions,ImplicitKey.LABEL);\n-                    if (equalCon==null) continue;\n-                    final Collection<Object> labels = equalCon.getValue();\n-                    assert labels.size() >= 1;\n-                    if (labels.size()>1) {\n-                        log.warn(\"The query optimizer currently does not support multiple label constraints in query: {}\",this);\n-                        continue;\n-                    }\n-                    if (!type.name().equals(Iterables.getOnlyElement(labels))) {\n-                        continue;\n-                    }\n-                    subcover.add(equalCon.getKey());\n-                }\n-\n-                if (index.isCompositeIndex()) {\n-                    subCondition = indexCover((CompositeIndexType) index,conditions,subcover);\n-                } else {\n-                    subCondition = indexCover((MixedIndexType) index,conditions,serializer,subcover);\n-                    if (coveredClauses.isEmpty() && !supportsSort\n-                            && indexCoversOrder((MixedIndexType)index,orders)) supportsSort=true;\n-                }\n-                if (subCondition==null || subcover.isEmpty()) continue;\n-                double score = 0.0;\n-                boolean coversAdditionalClause = false;\n-                for (final Condition c : subcover) {\n-                    double s = (c instanceof PredicateCondition && ((PredicateCondition)c).getPredicate()==Cmp.EQUAL)?\n-                            EQUAL_CONDITION_SCORE:OTHER_CONDITION_SCORE;\n-                    if (coveredClauses.contains(c)) s=s*ALREADY_MATCHED_ADJUSTOR;\n-                    else coversAdditionalClause = true;\n-                    score+=s;\n-                    if (index.isCompositeIndex())\n-                        score+=((CompositeIndexType)index).getCardinality()==Cardinality.SINGLE?\n-                                CARDINALITY_SINGE_SCORE:CARDINALITY_OTHER_SCORE;\n-                }\n-                if (supportsSort) score+=ORDER_MATCH;\n-                if (coversAdditionalClause && score>candidateScore) {\n-                    candidateScore=score;\n-                    bestCandidate=index;\n-                    candidateSubcover = subcover;\n-                    candidateSubCondition = subCondition;\n-                    candidateSupportsSort = supportsSort;\n-                }\n-            }\n-            if (bestCandidate!=null) {\n-                if (coveredClauses.isEmpty()) isSorted=candidateSupportsSort;\n-                coveredClauses.addAll(candidateSubcover);\n-                if (bestCandidate.isCompositeIndex()) {\n-                    jointQuery.add((CompositeIndexType)bestCandidate,\n-                            serializer.getQuery((CompositeIndexType)bestCandidate,(List<Object[]>)candidateSubCondition));\n-                } else {\n-                    jointQuery.add((MixedIndexType)bestCandidate,\n-                            serializer.getQuery((MixedIndexType)bestCandidate,(Condition)candidateSubCondition,orders));\n-                }\n-            } else {\n-                break;\n-            }\n-            /* TODO: smarter optimization:\n-            - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n-                    if they would result in an individual index call (better to filter afterwards in memory)\n-            - move OR's up and extend GraphCentricQuery to allow multiple JointIndexQuery for proper or'ing of queries\n-            */\n-        }\n+        final MutableBoolean isSorted = new MutableBoolean(orders.isEmpty());\n+        final JointIndexQuery jointQuery = selectIndices(indexCandidates, conditions, coveredClauses, isSorted);", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyODQ5Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424728493", "bodyText": "I would suggest to move selectIndices method into a separate class. Something like IndexSelectionService", "author": "porunov", "createdAt": "2020-05-13T21:01:15Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -497,5 +407,122 @@ private static boolean coversAll(final MixedIndexType index, Condition<JanusGrap\n         return match != null && indexInfo.supports(index, match, atom.getPredicate());\n     }\n \n+    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyOTg1NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r424729855", "bodyText": "I would suggest to move selectIndicesByBruteForce and selectIndicesByApprox to separate classes. As for me they are strategies. So I would move them to BruteForceIndexSelectionStrategy and ApproximationIndexSelectionStrategy.", "author": "porunov", "createdAt": "2020-05-13T21:04:00Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -497,5 +407,122 @@ private static boolean coversAll(final MixedIndexType index, Condition<JanusGrap\n         return match != null && indexInfo.supports(index, match, atom.getPredicate());\n     }\n \n+    private JointIndexQuery selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                          final Set<Condition> coveredClauses, final MutableBoolean isSorted) {\n+        /* TODO: smarter optimization:\n+        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n+                if they would result in an individual index call (better to filter afterwards in memory)\n+        */\n+        if (indexCandidates.size() <= tx.getGraph().getConfiguration().getIndexSelectThreshold()) {\n+            return selectIndicesByBruteForce(indexCandidates, conditions, coveredClauses, isSorted);\n+        } else {\n+            return selectIndicesByApprox(indexCandidates, conditions, coveredClauses, isSorted);\n+        }", "originalCommit": "805898c704878418a853b44cbd4a651972267581", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYxNDIyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r425614223", "bodyText": "I'm currently working on this approach but it looks like this requires moving more code than expected from the GraphCentricQueryBuilder to the strategy classes. I'll push a draft later today so you can at least have a look at what I mean.", "author": "rngcntr", "createdAt": "2020-05-15T07:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcyOTg1NQ=="}], "type": "inlineReview"}, {"oid": "434d25fa5ea74b53aea347f150b2df373983a859", "url": "https://github.com/JanusGraph/janusgraph/commit/434d25fa5ea74b53aea347f150b2df373983a859", "message": "Cleanup\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-15T09:11:20Z", "type": "forcePushed"}, {"oid": "adcde91def8ebb736bd4a884603639ef4da1a943", "url": "https://github.com/JanusGraph/janusgraph/commit/adcde91def8ebb736bd4a884603639ef4da1a943", "message": "Cleanup\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-15T09:13:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQzNjUxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430436518", "bodyText": "Most of methods of this interface are related to implementation, not abstraction. Thus they should either be private or package protected or protected as they are not intended to be used publicly.\nThus, I suggest create an abstract class public abstract class AbstractIndexSelectionStrategy implements IndexSelectionStrategy and move implementations there (make everything non-static. Methods which should be static can be left here). After that make BruteForceIndexSelectionStrategy and ApproximateIndexSelectionStrategy to be extended from AbstractIndexSelectionStrategy.", "author": "porunov", "createdAt": "2020-05-26T14:02:54Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,231 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+import org.javatuples.Pair;\n+\n+import javax.annotation.Nullable;\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public interface IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430445201", "bodyText": "This looks more like Service because it contains a business logic to interact with different strategies. I would suggest to rename it to IndexSelectorService and do not implement IndexSelectionStrategy.", "author": "porunov", "createdAt": "2020-05-26T14:14:23Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class DefaultIndexSelector implements IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1NzcyMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430857721", "bodyText": "Why not see this as a Strategy, too? Sure it combines and calls other strategies based on the size of the problem. But from my point of view it serves the same purpose as other implementations of IndexSelectionStrategy and acts as a drop-in replacement for other strategies.", "author": "rngcntr", "createdAt": "2020-05-27T05:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2Mjc3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430862776", "bodyText": "Good point. I guess it can be seen as a strategy also but from the other hand it just contains logic to choose another strategy based on some logic. I guess if we add another strategy it becomes a dependency of this class also because the logic behind this class is basically to select a strategy.\nI see it more as a service but I don't mind leaving it as a strategy. Just give it some more clear name. Maybe something like 'ThresholdBasedIndexSelectionStrategy'.", "author": "porunov", "createdAt": "2020-05-27T05:20:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2NDc1MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430864750", "bodyText": "LGTM\nI'll see if I can find some spare time today or tomorrow to implement your requested changes", "author": "rngcntr", "createdAt": "2020-05-27T05:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0NzI5NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430447295", "bodyText": "Could you please make it as direct constructor dependency to follow DI principle? It will simplify this class testing in future", "author": "porunov", "createdAt": "2020-05-26T14:17:15Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class DefaultIndexSelector implements IndexSelectionStrategy {\n+\n+    /**\n+     * Transaction which is used to gather settings of the graph\n+     */\n+    private StandardJanusGraphTx tx;\n+\n+    private IndexSelectionStrategy bruteForce;\n+    private IndexSelectionStrategy approximation;\n+\n+    public DefaultIndexSelector(StandardJanusGraphTx tx) {\n+        this.tx = tx;\n+\n+        this.bruteForce = new BruteForceIndexSelector();\n+        this.approximation = new ApproximateIndexSelector();", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0OTU1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430449553", "bodyText": "Can bruteForceThreshold be changed during different calls of this method? If no, could you provide bruteForceThreshold as a dependency of this class?", "author": "porunov", "createdAt": "2020-05-26T14:20:13Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/DefaultIndexSelector.java", "diffHunk": "@@ -0,0 +1,61 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class DefaultIndexSelector implements IndexSelectionStrategy {\n+\n+    /**\n+     * Transaction which is used to gather settings of the graph\n+     */\n+    private StandardJanusGraphTx tx;\n+\n+    private IndexSelectionStrategy bruteForce;\n+    private IndexSelectionStrategy approximation;\n+\n+    public DefaultIndexSelector(StandardJanusGraphTx tx) {\n+        this.tx = tx;\n+\n+        this.bruteForce = new BruteForceIndexSelector();\n+        this.approximation = new ApproximateIndexSelector();\n+    }\n+\n+    @Override\n+    public Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,\n+                                                        final Set<Condition> coveredClauses, OrderList orders, IndexSerializer serializer) {\n+        /* TODO: smarter optimization:\n+        - use in-memory histograms to estimate selectivity of PredicateConditions and filter out low-selectivity ones\n+                if they would result in an individual index call (better to filter afterwards in memory)\n+        */\n+        int bruteForceThreshold = tx.getGraph().getConfiguration().getIndexSelectThreshold();", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1NjE1NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430856155", "bodyText": "Good point", "author": "rngcntr", "createdAt": "2020-05-27T04:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ0OTU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ1NzE4OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430457189", "bodyText": "Do not remove Strategy of concrete implementations. I.e. call it ApproximateIndexSelectionStrategy.", "author": "porunov", "createdAt": "2020-05-26T14:30:07Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelector.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.javatuples.Pair;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ApproximateIndexSelector implements IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ1NzQyMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430457421", "bodyText": "Do not remove Strategy of concrete implementations. I.e. call it BruteForceIndexSelectionStrategy.", "author": "porunov", "createdAt": "2020-05-26T14:30:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelector.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.util.datastructures.PowerSet;\n+import org.javatuples.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class BruteForceIndexSelector implements IndexSelectionStrategy {", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2MjA3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430462073", "bodyText": "Instead of using Pair as a return type, I would create some POJO which contains JointIndexQuery jointQuery and Boolean sorted because 1) It isn't obvious what does Boolean means here. 2) If we decide to extend or shrink our return type, we won't be able to use Pair anymore.", "author": "porunov", "createdAt": "2020-05-26T14:36:31Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,231 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+import org.javatuples.Pair;\n+\n+import javax.annotation.Nullable;\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public interface IndexSelectionStrategy {\n+    Pair<JointIndexQuery, Boolean> selectIndices(final Set<IndexType> indexCandidates, final MultiCondition<JanusGraphElement> conditions,", "originalCommit": "adcde91def8ebb736bd4a884603639ef4da1a943", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66304b76615d6af481324508dcefc0844d0ddd65", "url": "https://github.com/JanusGraph/janusgraph/commit/66304b76615d6af481324508dcefc0844d0ddd65", "message": "Cleanup\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-27T08:10:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430980384", "bodyText": "I think we can add indexSelector as a dependency to this constructor instead of initializing it here to follow DI", "author": "porunov", "createdAt": "2020-05-27T09:24:52Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -81,13 +81,21 @@\n      * Whether smart limit adjustment is enabled\n      */\n     private boolean useSmartLimit;\n+    /**\n+     * Selection service for the best combination of indexes to be queried\n+     */\n+    private IndexSelectionStrategy indexSelector;\n \n     public GraphCentricQueryBuilder(StandardJanusGraphTx tx, IndexSerializer serializer) {\n         Preconditions.checkNotNull(tx);\n         Preconditions.checkNotNull(serializer);\n         useSmartLimit = tx.getGraph().getConfiguration().adjustQueryLimit();\n         this.tx = tx;\n         this.serializer = serializer;\n+        this.indexSelector =\n+            new ThresholdBasedIndexSelectionStrategy(tx.getGraph().getConfiguration().getIndexSelectThreshold(),\n+                new BruteForceIndexSelectionStrategy(),\n+                new ApproximateIndexSelectionStrategy());", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwNDgxMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431004813", "bodyText": "Are you ok with configuring it in StandardJanusGraph?", "author": "rngcntr", "createdAt": "2020-05-27T10:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwNjg2Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431006866", "bodyText": "Also, I guess indexSelectThreshold doesn't change from query to query, so we don't need to create a new implementation of a strategy each time. We should create indexSelectionStrategy only once when we establish a connection.", "author": "porunov", "createdAt": "2020-05-27T10:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMTU4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431011580", "bodyText": "I assume this is a \"yes\" \ud83d\ude04", "author": "rngcntr", "createdAt": "2020-05-27T10:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNjQzOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431016438", "bodyText": "Ah, I didn't see you past comment) Yes, configuring it in StandardJanusGraph looks good!", "author": "porunov", "createdAt": "2020-05-27T10:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4Mjc3OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430982779", "bodyText": "Unused import", "author": "porunov", "createdAt": "2020-05-27T09:28:53Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/GraphCentricQueryBuilder.java", "diffHunk": "@@ -31,12 +33,11 @@\n import org.janusgraph.graphdb.query.profile.QueryProfiler;\n import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n import org.janusgraph.graphdb.types.*;\n-import org.janusgraph.graphdb.types.system.ImplicitKey;\n+import org.javatuples.Pair;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDEzNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984135", "bodyText": "protected -> private", "author": "porunov", "createdAt": "2020-05-27T09:31:03Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDE5OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984199", "bodyText": "protected -> private", "author": "porunov", "createdAt": "2020-05-27T09:31:09Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDI0OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984249", "bodyText": "protected -> private", "author": "porunov", "createdAt": "2020-05-27T09:31:14Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n+                                    Condition<JanusGraphElement> condition,\n+                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n+        if (position>=fields.length) {\n+            indexCovers.add(indexValues);\n+        } else {\n+            final IndexField field = fields[position];\n+            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n+            if (equalCon!=null) {\n+                coveredClauses.add(equalCon.getKey());\n+                assert equalCon.getValue().size()>0;\n+                for (final Object value : equalCon.getValue()) {\n+                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n+                    newValues[position]=value;\n+                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Condition<JanusGraphElement> indexCover(final MixedIndexType index,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDM0Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984347", "bodyText": "protected -> private", "author": "porunov", "createdAt": "2020-05-27T09:31:22Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n+                                    Condition<JanusGraphElement> condition,\n+                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n+        if (position>=fields.length) {\n+            indexCovers.add(indexValues);\n+        } else {\n+            final IndexField field = fields[position];\n+            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n+            if (equalCon!=null) {\n+                coveredClauses.add(equalCon.getKey());\n+                assert equalCon.getValue().size()>0;\n+                for (final Object value : equalCon.getValue()) {\n+                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n+                    newValues[position]=value;\n+                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n+                                                   Condition<JanusGraphElement> condition,\n+                                                   final IndexSerializer indexInfo,\n+                                                   final Set<Condition> covered) {\n+        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        if (condition instanceof Or) {\n+            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+                if (subClause instanceof And) {\n+                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n+                        if (!coversAll(index, subsubClause,indexInfo)) {\n+                            return null;\n+                        }\n+                    }\n+                } else {\n+                    if (!coversAll(index, subClause, indexInfo)) {\n+                        return null;\n+                    }\n+                }\n+            }\n+            covered.add(condition);\n+            return condition;\n+        }\n+        assert condition instanceof And;\n+        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n+        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+            if (coversAll(index,subClause,indexInfo)) {\n+                subCondition.add(subClause);\n+                covered.add(subClause);\n+            }\n+        }\n+        return subCondition.isEmpty()?null:subCondition;\n+    }\n+\n+    protected boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDQxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430984418", "bodyText": "protected -> private", "author": "porunov", "createdAt": "2020-05-27T09:31:27Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {\n+    /**\n+     * Creates an <code>IndexCandidate</code> from a <code>MultiCondition</code> which it covers.\n+     * @param index\n+     * @param conditions For the condition to be valid, it needs to match these rules:\n+     *                   <ul>\n+     *                   <li>It must be an equality condition</li>\n+     *                   <li>It must not cover multiple labels</li>\n+     *                   <li>The label must match the given <code>index</code></li>\n+     *                   </ul>\n+     * @return An instance of <code>IndexCandidate</code> if the parameter <code>conditions</code> is valid, <code>null</code> else.\n+     */\n+    @Nullable\n+    protected IndexCandidate createIndexCandidate(final IndexType index, final MultiCondition<JanusGraphElement> conditions, IndexSerializer serializer) {\n+        final Set<Condition> subCover = new HashSet<>(1);\n+\n+        // Check that this index actually applies in case of a schema constraint\n+        if (index.hasSchemaTypeConstraint()) {\n+            final JanusGraphSchemaType type = index.getSchemaTypeConstraint();\n+            final Map.Entry<Condition, Collection<Object>> equalCon = getEqualityConditionValues(conditions, ImplicitKey.LABEL);\n+\n+            if (equalCon == null) {\n+                // Only equality conditions are supported\n+                return null;\n+            }\n+\n+            final Collection<Object> labels = equalCon.getValue();\n+            assert labels.size() >= 1;\n+\n+            if (labels.size() > 1) {\n+                // The query optimizer currently does not support multiple label constraints\n+                return null;\n+            }\n+            if (!type.name().equals(labels.iterator().next())) {\n+                // Given IndexType does not match given condition label\n+                return null;\n+            }\n+            subCover.add(equalCon.getKey());\n+        }\n+\n+        Object subCondition;\n+        if (index.isCompositeIndex()) {\n+            subCondition = indexCover((CompositeIndexType) index, conditions, subCover);\n+        } else {\n+            subCondition = indexCover((MixedIndexType) index, conditions, serializer, subCover);\n+        }\n+        if (subCondition == null || subCover.isEmpty()) {\n+            // Unable to initialize IndexCandidate from given parameters\n+            return null;\n+        }\n+\n+        return new IndexCandidate(index, subCover, subCondition);\n+    }\n+\n+    protected void addToJointQuery(final IndexCandidate indexCandidate, final JointIndexQuery jointQuery, final IndexSerializer serializer, final OrderList orders) {\n+        if (indexCandidate.getIndex().isCompositeIndex()) {\n+            jointQuery.add((CompositeIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (CompositeIndexType) indexCandidate.getIndex(), (List<Object[]>) indexCandidate.getSubCondition()));\n+        } else {\n+            jointQuery.add((MixedIndexType) indexCandidate.getIndex(), serializer.getQuery(\n+                (MixedIndexType) indexCandidate.getIndex(), (Condition) indexCandidate.getSubCondition(), orders));\n+        }\n+    }\n+\n+    protected List<Object[]> indexCover(final CompositeIndexType index, Condition<JanusGraphElement> condition,\n+                                     Set<Condition> covered) {\n+        if (!QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        assert condition instanceof And;\n+        if (index.getStatus()!= SchemaStatus.ENABLED) return null;\n+        final IndexField[] fields = index.getFieldKeys();\n+        final Object[] indexValues = new Object[fields.length];\n+        final Set<Condition> coveredClauses = new HashSet<>(fields.length);\n+        final List<Object[]> indexCovers = new ArrayList<>(4);\n+\n+        constructIndexCover(indexValues,0,fields,condition,indexCovers,coveredClauses);\n+        if (!indexCovers.isEmpty()) {\n+            covered.addAll(coveredClauses);\n+            return indexCovers;\n+        } else return null;\n+    }\n+\n+    protected void constructIndexCover(Object[] indexValues, int position, IndexField[] fields,\n+                                    Condition<JanusGraphElement> condition,\n+                                    List<Object[]> indexCovers, Set<Condition> coveredClauses) {\n+        if (position>=fields.length) {\n+            indexCovers.add(indexValues);\n+        } else {\n+            final IndexField field = fields[position];\n+            final Map.Entry<Condition,Collection<Object>> equalCon = getEqualityConditionValues(condition,field.getFieldKey());\n+            if (equalCon!=null) {\n+                coveredClauses.add(equalCon.getKey());\n+                assert equalCon.getValue().size()>0;\n+                for (final Object value : equalCon.getValue()) {\n+                    final Object[] newValues = Arrays.copyOf(indexValues,fields.length);\n+                    newValues[position]=value;\n+                    constructIndexCover(newValues,position+1,fields,condition,indexCovers,coveredClauses);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Condition<JanusGraphElement> indexCover(final MixedIndexType index,\n+                                                   Condition<JanusGraphElement> condition,\n+                                                   final IndexSerializer indexInfo,\n+                                                   final Set<Condition> covered) {\n+        if (!indexInfo.features(index).supportNotQueryNormalForm() && !QueryUtil.isQueryNormalForm(condition)) {\n+            return null;\n+        }\n+        if (condition instanceof Or) {\n+            for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+                if (subClause instanceof And) {\n+                    for (final Condition<JanusGraphElement> subsubClause : condition.getChildren()) {\n+                        if (!coversAll(index, subsubClause,indexInfo)) {\n+                            return null;\n+                        }\n+                    }\n+                } else {\n+                    if (!coversAll(index, subClause, indexInfo)) {\n+                        return null;\n+                    }\n+                }\n+            }\n+            covered.add(condition);\n+            return condition;\n+        }\n+        assert condition instanceof And;\n+        final And<JanusGraphElement> subCondition = new And<>(condition.numChildren());\n+        for (final Condition<JanusGraphElement> subClause : condition.getChildren()) {\n+            if (coversAll(index,subClause,indexInfo)) {\n+                subCondition.add(subClause);\n+                covered.add(subClause);\n+            }\n+        }\n+        return subCondition.isEmpty()?null:subCondition;\n+    }\n+\n+    protected boolean coversAll(final MixedIndexType index, Condition<JanusGraphElement> condition,\n+                             IndexSerializer indexInfo) {\n+        if (condition.getType()!=Condition.Type.LITERAL) {\n+            return StreamSupport.stream(condition.getChildren().spliterator(), false)\n+                .allMatch(child -> coversAll(index, child, indexInfo));\n+        }\n+        if (!(condition instanceof PredicateCondition)) {\n+            return false;\n+        }\n+        final PredicateCondition<RelationType, JanusGraphElement> atom = (PredicateCondition) condition;\n+        if (atom.getValue() == null) {\n+            return false;\n+        }\n+\n+        Preconditions.checkArgument(atom.getKey().isPropertyKey());\n+        final PropertyKey key = (PropertyKey) atom.getKey();\n+        final ParameterIndexField[] fields = index.getFieldKeys();\n+        final ParameterIndexField match = Arrays.stream(fields)\n+            .filter(field -> field.getStatus() == SchemaStatus.ENABLED)\n+            .filter(field -> field.getFieldKey().equals(key))\n+            .findAny().orElse(null);\n+        return match != null && indexInfo.supports(index, match, atom.getPredicate());\n+    }\n+\n+    protected Map.Entry<Condition,Collection<Object>> getEqualityConditionValues(", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NzU2MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430987560", "bodyText": "This class looks like self sufficient class. Self sufficient classes should not be abstract. Now it looks more like Utility class.\nTo make it logically abstract I suggest to add implements IndexSelectionStrategy but don't implement it in this class directly. Instead, children of this class will need to implement methods from IndexSelectionStrategy.\nThus, you don't need to add implements IndexSelectionStrategy to any children of this class.", "author": "porunov", "createdAt": "2020-05-27T09:36:41Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,217 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphRelation;\n+import org.janusgraph.core.PropertyKey;\n+import org.janusgraph.core.RelationType;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy {", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4ODI4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430988283", "bodyText": "Mark all these fields as final", "author": "porunov", "createdAt": "2020-05-27T09:37:56Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ThresholdBasedIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+\n+    private int threshold;\n+\n+    private IndexSelectionStrategy usedIfLessOrEqualThreshold;\n+    private IndexSelectionStrategy usedIfGreaterThanThreshold;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4OTMwOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430989309", "bodyText": "Redundant boxing. I.e. use isSorted directly instead of Boolean.valueOf(isSorted)", "author": "porunov", "createdAt": "2020-05-27T09:39:46Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.javatuples.Pair;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ApproximateIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+\n+    /**\n+     * Iterate over all potential indexes and compute a score based on how many clauses\n+     * this index covers. The index with the highest score (as long as it covers at least one\n+     * additional clause) is picked and added to the joint query for as long as such exist.\n+     */\n+    @Override\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        boolean isSorted = orders.isEmpty();\n+        while (true) {\n+            IndexCandidate bestCandidate = null;\n+            boolean candidateSupportsSort = false;\n+\n+            for (final IndexType index : rawCandidates) {\n+                final IndexCandidate indexCandidate =\n+                    createIndexCandidate(index, conditions, serializer);\n+                if (indexCandidate == null) {\n+                    continue;\n+                }\n+\n+                boolean supportsSort =\n+                    orders.isEmpty() ||\n+                    coveredClauses.isEmpty() && index.isMixedIndex() &&\n+                        IndexSelectionStrategy.indexCoversOrder((MixedIndexType) index, orders);\n+                indexCandidate.calculateScoreApproximation(coveredClauses, supportsSort);\n+\n+                if (!indexCandidate.isCoveredBy(coveredClauses) &&\n+                    (bestCandidate == null ||\n+                     indexCandidate.getScore() > bestCandidate.getScore())) {\n+                    bestCandidate = indexCandidate;\n+                    candidateSupportsSort = supportsSort;\n+                }\n+            }\n+\n+            if (bestCandidate != null) {\n+                if (coveredClauses.isEmpty()) {\n+                    isSorted = candidateSupportsSort;\n+                }\n+                coveredClauses.addAll(bestCandidate.getSubCover());\n+                addToJointQuery(bestCandidate, jointQuery, serializer, orders);\n+            } else {\n+                break;\n+            }\n+        }\n+        return new SelectedIndexQuery(jointQuery, Boolean.valueOf(isSorted));", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDE4Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430990182", "bodyText": "Unused import", "author": "porunov", "createdAt": "2020-05-27T09:41:19Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.util.datastructures.PowerSet;\n+import org.javatuples.Pair;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDM2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430990365", "bodyText": "Unused import", "author": "porunov", "createdAt": "2020-05-27T09:41:39Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.javatuples.Pair;", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDkyMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430990920", "bodyText": "Several unused imports", "author": "porunov", "createdAt": "2020-05-27T09:42:37Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ThresholdBasedIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.javatuples.Pair;\n+", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NDE4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r430994183", "bodyText": "This is an utility method, so I would recommend to move it to another class. I.e. something like IndexSelectionUtil.", "author": "porunov", "createdAt": "2020-05-27T09:48:16Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,57 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.*;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.javatuples.Pair;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public interface IndexSelectionStrategy {\n+    SelectedIndexQuery selectIndices(final Set<IndexType> indexCandidates,\n+                                     final MultiCondition<JanusGraphElement> conditions,\n+                                     final Set<Condition> coveredClauses, OrderList orders,\n+                                     IndexSerializer serializer);\n+\n+    static boolean indexCoversOrder(MixedIndexType index, OrderList orders) {\n+        for (int i = 0; i < orders.size(); i++) {\n+            if (!index.indexesKey(orders.getKey(i)))\n+                return false;\n+        }\n+        return true;\n+    }", "originalCommit": "66304b76615d6af481324508dcefc0844d0ddd65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "url": "https://github.com/JanusGraph/janusgraph/commit/ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-27T10:19:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0MDA3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431040073", "bodyText": "There is a unit test which fails due additional dependency.\nTo fix this test StandardJanusGraphTxTest.testGetOrCreatePropertyKey, add the next mock into it:\nIndexSelectionStrategy indexSelectionStrategy = createMock(ThresholdBasedIndexSelectionStrategy.class);\nexpect(mockGraph.getIndexSelector()).andReturn(indexSelectionStrategy);", "author": "porunov", "createdAt": "2020-05-27T11:14:53Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/StandardJanusGraphTx.java", "diffHunk": "@@ -201,6 +204,7 @@ public StandardJanusGraphTx(StandardJanusGraph graph, TransactionConfiguration c\n         this.attributeHandler = graph.getDataSerializer();\n         this.edgeSerializer = graph.getEdgeSerializer();\n         this.indexSerializer = graph.getIndexSerializer();\n+        this.indexSelector = graph.getIndexSelector();", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTEwNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431059107", "bodyText": "Move to AbstractIndexSelectionStrategy", "author": "porunov", "createdAt": "2020-05-27T11:53:31Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431059697", "bodyText": "Move to AbstractIndexSelectionStrategy as protected methods", "author": "porunov", "createdAt": "2020-05-27T11:54:40Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }\n+\n+    public double getScore() {\n+        return score;\n+    }\n+\n+    /**\n+     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n+     * @param coveringClauses\n+     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n+     */\n+    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n+        for (final Condition c : subCover) {\n+            if (!coveringClauses.contains(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private double getConditionBasicScore(final Condition c) {\n+        if (c instanceof PredicateCondition && ((PredicateCondition) c).getPredicate() == Cmp.EQUAL) {\n+            return EQUAL_CONDITION_SCORE;\n+        } else {\n+            return OTHER_CONDITION_SCORE;\n+        }\n+    }\n+\n+    private double getIndexTypeScore(final IndexType index) {\n+        double score = 0.0;\n+        if (index.isCompositeIndex()) {\n+            if (((CompositeIndexType)index).getCardinality() == Cardinality.SINGLE) {\n+                score = CARDINALITY_SINGE_SCORE;\n+            } else {\n+                score = CARDINALITY_OTHER_SCORE;\n+            }\n+        }\n+        return score;\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODA4Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431588087", "bodyText": "What's the point in moving everything from the IndexCandidate to AbstractIndexSelectionStrategy? Why would we want to have methods that are only used for IndexCandidates in another class?", "author": "rngcntr", "createdAt": "2020-05-28T05:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MDg1MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431590851", "bodyText": "To follow SOLID principles. Currently this class violates Single-responsibility principle.\n\nThe class is responsible for 2 separate algorithms. Brute force and approximation.\nThe class is responsible for both business logic (calculation logic) and data (POJO).", "author": "porunov", "createdAt": "2020-05-28T05:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MzIzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431593237", "bodyText": "Notice, those methods are not used by IndexCandidate as you are telling.\nprivate methods are used by brute force and approximation calculation logic (public methods). That calculation logic is used only in concrete strategies. Brute force calculation logic is used only in brute force strategy. Approximation calculation logic is used only in approximation strategy. Whereas getConditionBasicScore and getIndexTypeScore is general logic which is used by both score calculation logic.", "author": "porunov", "createdAt": "2020-05-28T05:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5OTEyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431599123", "bodyText": "Thanks for the explanation! Nice and comprehensive \ud83d\ude04", "author": "rngcntr", "createdAt": "2020-05-28T06:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1OTY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MDExOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431060119", "bodyText": "Move to ApproximateIndexSelectionStrategy as a private method. Just add another method argument (i.e. subCover)", "author": "porunov", "createdAt": "2020-05-27T11:55:32Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }\n+\n+    public double getScore() {\n+        return score;\n+    }\n+\n+    /**\n+     * Determines if this IndexCandidate only covers clauses, which are already covered by a given set.\n+     * @param coveringClauses\n+     * @return true if the IndexCandidate is fully covered by the given set. false if not.\n+     */\n+    public boolean isCoveredBy(final Set<Condition> coveringClauses) {\n+        for (final Condition c : subCover) {\n+            if (!coveringClauses.contains(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwMDU5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431600590", "bodyText": "I think we can even replace this method by just calling coveringClauses.containsAll(subCover).", "author": "rngcntr", "createdAt": "2020-05-28T06:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MDExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwMjc4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431602783", "bodyText": "Totally agree", "author": "porunov", "createdAt": "2020-05-28T06:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MTMxMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431061310", "bodyText": "Move to AbstractIndexSelectionStrategy", "author": "porunov", "createdAt": "2020-05-27T11:57:50Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MzI4OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431063288", "bodyText": "Move it to ApproximateIndexSelectionStrategy. You can just add necessary parameters and return a calculated score. I.e. private double calculateScore(Set<Condition> subCover, IndexType index, final Set<Condition> coveredClauses, boolean supportsSort)", "author": "porunov", "createdAt": "2020-05-27T12:01:29Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }\n+\n+    public void calculateScoreApproximation(final Set<Condition> coveredClauses, boolean supportsSort) {\n+        score = 0.0;\n+\n+        for (final Condition c : subCover) {\n+            double subScore = getConditionBasicScore(c);\n+            if (coveredClauses.contains(c)) {\n+                subScore = subScore * ALREADY_MATCHED_ADJUSTOR;\n+            }\n+            score += subScore + getIndexTypeScore(index);\n+        }\n+\n+        if (supportsSort) {\n+            score += ORDER_MATCH;\n+        }\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA3Mjg3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431072876", "bodyText": "Also, you can just add a method setScore into IndexCandidate and update score after the calculation", "author": "porunov", "createdAt": "2020-05-27T12:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2MzI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2NDU1OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431064558", "bodyText": "Move it to BruteForceIndexSelectionStrategy. You can just add necessary parameters and return a calculated score. I.e. private double calculateScore(Set<Condition> subCover, IndexType index)", "author": "porunov", "createdAt": "2020-05-27T12:03:54Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.core.Cardinality;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.types.CompositeIndexType;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    private static final double ORDER_MATCH = 1;\n+    private static final double ALREADY_MATCHED_ADJUSTOR = -1.1;\n+\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    // initialize with the worst possible score\n+    private double score = Double.NEGATIVE_INFINITY;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+    }\n+\n+    public IndexType getIndex() {\n+        return index;\n+    }\n+\n+    public Set<Condition> getSubCover() {\n+        return subCover;\n+    }\n+\n+    public Object getSubCondition() {\n+        return subCondition;\n+    }\n+\n+    public void calculateScoreBruteForce() {\n+        score = 0.0;\n+        for (final Condition c : subCover) {\n+            score += getConditionBasicScore(c) + getIndexTypeScore(index);\n+        }\n+    }", "originalCommit": "ee9cf61ceaaa7f1cb3223e429f2ae820977b8e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e343e5d474cc583abb6811b6a1b218780c387935", "url": "https://github.com/JanusGraph/janusgraph/commit/e343e5d474cc583abb6811b6a1b218780c387935", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T06:22:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTE0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431609142", "bodyText": "Missed on this. It is used only by ApproximateIndexSelectionStrategy, so I think it should be moved there", "author": "porunov", "createdAt": "2020-05-28T06:30:33Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/AbstractIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,242 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import javax.annotation.Nullable;\n+import com.google.common.base.Preconditions;\n+import org.janusgraph.core.*;\n+import org.janusgraph.core.attribute.Cmp;\n+import org.janusgraph.core.schema.JanusGraphSchemaType;\n+import org.janusgraph.core.schema.SchemaStatus;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.*;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.*;\n+import org.janusgraph.graphdb.types.system.ImplicitKey;\n+\n+import java.util.*;\n+import java.util.stream.StreamSupport;\n+\n+public abstract class AbstractIndexSelectionStrategy implements IndexSelectionStrategy {\n+    private static final double EQUAL_CONDITION_SCORE = 4;\n+    private static final double OTHER_CONDITION_SCORE = 1;\n+    private static final double CARDINALITY_SINGE_SCORE = 1000;\n+    private static final double CARDINALITY_OTHER_SCORE = 1000;\n+\n+    protected static final double ORDER_MATCH = 1;\n+    protected static final double ALREADY_MATCHED_ADJUSTOR = -1.1;", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1ODExMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431658110", "bodyText": "I briefly thought about that, but I decided (for no reason) to have all constants in one place. I'm also fine with moving them to the strategy that uses them, if it is only a single one.", "author": "rngcntr", "createdAt": "2020-05-28T08:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTE0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MTQ0NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431681445", "bodyText": "I think it is better to move them into a concrete strategy while they are used only by that strategy", "author": "porunov", "createdAt": "2020-05-28T08:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwOTE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTQ2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431611465", "bodyText": "It would be better to pass only necessary parameters to the method. Even so, we will need to pass 2 parameters (subCover and index), it is better to pass them instead of indexCandidate because indexCandidate has more details (which are not needed by this method, i.e. subCondition)", "author": "porunov", "createdAt": "2020-05-28T06:36:38Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/ApproximateIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class ApproximateIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy {\n+\n+    /**\n+     * Iterate over all potential indexes and compute a score based on how many clauses\n+     * this index covers. The index with the highest score (as long as it covers at least one\n+     * additional clause) is picked and added to the joint query for as long as such exist.\n+     */\n+    @Override\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        boolean isSorted = orders.isEmpty();\n+        while (true) {\n+            IndexCandidate bestCandidate = null;\n+            boolean candidateSupportsSort = false;\n+\n+            for (final IndexType index : rawCandidates) {\n+                final IndexCandidate indexCandidate =\n+                    createIndexCandidate(index, conditions, serializer);\n+                if (indexCandidate == null) {\n+                    continue;\n+                }\n+\n+                boolean supportsSort =\n+                    orders.isEmpty() ||\n+                    coveredClauses.isEmpty() && index.isMixedIndex() &&\n+                        IndexSelectionUtil.indexCoversOrder((MixedIndexType) index, orders);\n+                indexCandidate.setScore(calculateIndexCandidateScore(indexCandidate, coveredClauses, supportsSort));\n+\n+                if (!coveredClauses.containsAll(indexCandidate.getSubCover()) &&\n+                    (bestCandidate == null ||\n+                     indexCandidate.getScore() > bestCandidate.getScore())) {\n+                    bestCandidate = indexCandidate;\n+                    candidateSupportsSort = supportsSort;\n+                }\n+            }\n+\n+            if (bestCandidate != null) {\n+                if (coveredClauses.isEmpty()) {\n+                    isSorted = candidateSupportsSort;\n+                }\n+                coveredClauses.addAll(bestCandidate.getSubCover());\n+                addToJointQuery(bestCandidate, jointQuery, serializer, orders);\n+            } else {\n+                break;\n+            }\n+        }\n+        return new SelectedIndexQuery(jointQuery, isSorted);\n+    }\n+\n+    private double calculateIndexCandidateScore(final IndexCandidate indexCandidate,", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1NTkyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431655923", "bodyText": "I think it's convenient to pass the entire IndexCandidate object to the score calculation. Especially as we trimmed down the class IndexCandidate to contain only relevant information and no logic, in my opinion every attribute of an IndexCandidate qualifies as a valid foundation to be considered for the calculation of a score.", "author": "rngcntr", "createdAt": "2020-05-28T08:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY4MDkyNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431680927", "bodyText": "Good point. Agree", "author": "porunov", "createdAt": "2020-05-28T08:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTc5MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431611790", "bodyText": "Same here. I would pass 2 separate arguments instead of a single but with redundant information", "author": "porunov", "createdAt": "2020-05-28T06:37:25Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/BruteForceIndexSelectionStrategy.java", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.graphdb.database.IndexSerializer;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.types.IndexType;\n+import org.janusgraph.graphdb.types.MixedIndexType;\n+import org.janusgraph.util.datastructures.PowerSet;\n+\n+/**\n+ * @author Florian Grieskamp (Florian.Grieskamp@gdata.de)\n+ */\n+public class BruteForceIndexSelectionStrategy\n+    extends AbstractIndexSelectionStrategy {\n+\n+    /**\n+     * Determine the best jointIndexQuery by enumerating all possibilities with exponential time\n+     * complexity. Similar to Weighted Set Cover problem, to find the best choice is NP-Complete, so\n+     * we should be careful that the problem size MUST be small, otherwise it is more recommended to\n+     * use an approximation algorithm.\n+     */\n+    @Override\n+    public SelectedIndexQuery selectIndices(final Set<IndexType> rawCandidates,\n+                                            final MultiCondition<JanusGraphElement> conditions,\n+                                            final Set<Condition> coveredClauses, OrderList orders,\n+                                            IndexSerializer serializer) {\n+        final JointIndexQuery jointQuery = new JointIndexQuery();\n+        final Set<IndexCandidate> indexCandidates = new HashSet<>();\n+        boolean isSorted = orders.isEmpty();\n+\n+        // validate, enrich index candidates and calculate scores\n+        for (final IndexType index : rawCandidates) {\n+            IndexCandidate ic = createIndexCandidate(index, conditions, serializer);\n+            if (ic == null) {\n+                continue;\n+            }\n+            ic.setScore(calculateIndexCandidateScore(ic));\n+            indexCandidates.add(ic);\n+        }\n+\n+        IndexCandidateGroup bestGroup = null;\n+        for (Set<IndexCandidate> subset : new PowerSet<>(indexCandidates)) {\n+            if (subset.isEmpty())\n+                continue;\n+            final IndexCandidateGroup group = new IndexCandidateGroup(subset);\n+            if (group.compareTo(bestGroup) > 0) {\n+                bestGroup = group;\n+            }\n+        }\n+\n+        if (bestGroup != null) {\n+            coveredClauses.addAll(bestGroup.getCoveredClauses());\n+            List<IndexCandidate> bestIndexes = new ArrayList<>(bestGroup.getIndexCandidates());\n+            // sort indexes by score descending order\n+            bestIndexes.sort((a, b) -> Double.compare(b.getScore(), a.getScore()));\n+            // isSorted depends on the first index subquery\n+            isSorted =\n+                orders.isEmpty() || bestIndexes.get(0).getIndex().isMixedIndex() &&\n+                                        IndexSelectionUtil.indexCoversOrder(\n+                                            (MixedIndexType) bestIndexes.get(0).getIndex(), orders);\n+            for (IndexCandidate c : bestIndexes) {\n+                addToJointQuery(c, jointQuery, serializer, orders);\n+            }\n+        }\n+\n+        return new SelectedIndexQuery(jointQuery, isSorted);\n+    }\n+\n+    private double calculateIndexCandidateScore(final IndexCandidate ic) {", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNjg0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431616842", "bodyText": "I would put it back to inline initialization because:\n\nThe field isn't final, it means that we may add a bug if we add another constructor later (i.e. forget to initialize it)\nI'm not sure about non final fields in sense of initialization. If final field is initialized only once, what about non final field? Will it be initialized with 0.0 at class fields initialization phase and them Double.NEGATIVE_INFINITY at constructor initialization phase? Again, not sure about it but if we use inline initialization we guarantee that it will be Double.NEGATIVE_INFINITY in both class fields initialization phase and constructor initialization phase.", "author": "porunov", "createdAt": "2020-05-28T06:50:07Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/index/IndexCandidate.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.query.index;\n+\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.types.IndexType;\n+\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class IndexCandidate {\n+    private final IndexType index;\n+    private final Set<Condition> subCover;\n+    private final Object subCondition;\n+\n+    private double score;\n+\n+    public IndexCandidate(final IndexType index,\n+                          final Set<Condition> subCover,\n+                          final Object subCondition) {\n+        this.index = index;\n+        this.subCover = subCover;\n+        this.subCondition = subCondition;\n+        // initialize with the worst possible score\n+        this.score = Double.NEGATIVE_INFINITY;", "originalCommit": "e343e5d474cc583abb6811b6a1b218780c387935", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1Njc3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2099#discussion_r431656773", "bodyText": "Yes, you're right. Good point.", "author": "rngcntr", "createdAt": "2020-05-28T08:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNjg0Mg=="}], "type": "inlineReview"}, {"oid": "2e049b1f556441cf0ec7c23b48d884afa3dc9eaa", "url": "https://github.com/JanusGraph/janusgraph/commit/2e049b1f556441cf0ec7c23b48d884afa3dc9eaa", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T09:01:43Z", "type": "forcePushed"}, {"oid": "67cf2b50576b0d7c970f954856abb41e9c829a8d", "url": "https://github.com/JanusGraph/janusgraph/commit/67cf2b50576b0d7c970f954856abb41e9c829a8d", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T09:07:31Z", "type": "commit"}, {"oid": "67cf2b50576b0d7c970f954856abb41e9c829a8d", "url": "https://github.com/JanusGraph/janusgraph/commit/67cf2b50576b0d7c970f954856abb41e9c829a8d", "message": "Refactor construction of index queries\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-05-28T09:07:31Z", "type": "forcePushed"}]}