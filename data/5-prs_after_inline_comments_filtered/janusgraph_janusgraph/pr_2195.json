{"pr_number": 2195, "pr_title": "Optimize performance of transaction-wise index query cache", "pr_createdAt": "2020-08-29T09:28:01Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2195", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NTUyNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484265525", "bodyText": "Nitpick: Do values and limit have to be modifiable once their values are set by the constructor?", "author": "rngcntr", "createdAt": "2020-09-07T08:13:59Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/subquerycache/SubqueryCache.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.transaction.subquerycache;\n+\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Cache for {@link JointIndexQuery.Subquery} results. Cache entries are manually added using\n+ * {@link #get(JointIndexQuery.Subquery, Callable)} or {@link #put(JointIndexQuery.Subquery, List)},\n+ * and stored in the cache until evicted or invalidated.\n+ * <p>\n+ * Different from a simple exact mapping from keys to values,\n+ * it leverages the fact that the results of a Subquery A with limit X are first X entries of the results of the\n+ * a Subquery B with limit Y, where A and B only differ in limit, and X is less than or equal to Y.\n+ * <p>\n+ * For example, suppose the cache is empty at the beginning. Firstly, prop1_idx:multiKSQ[1]@100 query leads to a cache\n+ * miss, and then results are loaded into cache. Secondly, prop1_idx:multiKSQ[1]@20 query leads to a cache hit, and\n+ * then first 20 results of cached responses are returned. Thirdly, prop1_idx:multiKSQ[1]@2000 leads to a cache miss,\n+ * then results are loaded into cache, and initial results saved by prop1_idx:multiKSQ[1]@100 query are overriden by\n+ * the new results.\n+ * <p>\n+ * Internally, raw query results are encapsulated in {@link SubqueryResult} object together with limit of the query.\n+ * Meanwhile, keys are stored without limit (or with a dummy limit). Whenever there is a hit for key, the limit of\n+ * cached results and that of the query will be compared, and whether this is a cache hit or miss will be determined.\n+ * <p>\n+ * Compared to a simply {@link JointIndexQuery.Subquery} to {@code List<Object>} mapping, this cache has two benefits:\n+ * 1) it reduces latency, as \"subset\" queries can effectively leverage cached results.\n+ * 2) it saves space, as queries only differing in limit will not be saved more than once in cache.\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public interface SubqueryCache {\n+\n+    /**\n+     * Return a list of results if given query exists in cache, otherwise\n+     * return null\n+     *\n+     * @param query a subquery of joint index query\n+     * @return a list of matching results or null if is not in the cache\n+     */\n+    List<Object> getIfPresent(JointIndexQuery.Subquery query);\n+\n+    /**\n+     * Add given values into cache\n+     *\n+     * @param query  a subquery of joint index query\n+     * @param values a list of results to be cached\n+     */\n+    void put(JointIndexQuery.Subquery query, List<Object> values);\n+\n+    /**\n+     * Returns a list of results. If given query not in cache, call the\n+     * value loader to retrieve results and put into the cache\n+     *\n+     * @param query       a subquery of joint index query\n+     * @param valueLoader a callable that returns a list of results\n+     * @return a list of results\n+     * @throws Exception if exception thrown when calling the value loader\n+     */\n+    List<Object> get(JointIndexQuery.Subquery query, Callable<? extends List<Object>> valueLoader) throws Exception;\n+\n+    /**\n+     * Closes the cache which allows the cache to release allocated memory.\n+     * Calling any of the other methods after closing a cache has undetermined behavior.\n+     */\n+    void close();\n+\n+    public class SubqueryResult {\n+        private List<Object> values;\n+        private int limit;\n+\n+        protected SubqueryResult(List<Object> values, int limit) {\n+            this.values = values;\n+            this.limit = limit;\n+        }\n+\n+        public List<Object> getValues() {\n+            return values;\n+        }\n+\n+        public void setValues(List<Object> values) {", "originalCommit": "599b6b8beed017644ebef8283b69c47c5a11fbc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ0MDM4MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484440381", "bodyText": "make sense, will remove redundant setters", "author": "li-boxuan", "createdAt": "2020-09-07T13:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3MTE4MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484271181", "bodyText": "The Java Stream API ist relatively inefficient in most simple cases. Instead you could use List.subList() here.", "author": "rngcntr", "createdAt": "2020-09-07T08:23:52Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/subquerycache/GuavaSubqueryCache.java", "diffHunk": "@@ -0,0 +1,71 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.transaction.subquerycache;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.Weigher;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class GuavaSubqueryCache implements SubqueryCache {\n+    private Cache<JointIndexQuery.Subquery, SubqueryResult> indexCache;\n+\n+    public GuavaSubqueryCache(int concurrencyLevel, long maximumWeight) {\n+        indexCache = CacheBuilder.newBuilder()\n+            .weigher((Weigher<JointIndexQuery.Subquery, SubqueryResult>) (q, r) -> 2 + r.size())\n+            .concurrencyLevel(concurrencyLevel).maximumWeight(maximumWeight).build();\n+    }\n+\n+    @Override\n+    public List<Object> getIfPresent(JointIndexQuery.Subquery key) {\n+        int limit = key.getLimit();\n+        JointIndexQuery.Subquery noLimitKey = key.updateLimit(0);\n+        SubqueryResult result = indexCache.getIfPresent(noLimitKey);\n+        if (result != null && (result.getLimit() >= limit || result.getLimit() > result.size())) {\n+            return result.getValues().stream().limit(limit).collect(Collectors.toList());", "originalCommit": "599b6b8beed017644ebef8283b69c47c5a11fbc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3NDA1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484274053", "bodyText": "These tests do not cover the case in which we have a limit x first and then a limit y > x later. Otherwise the tests look good", "author": "rngcntr", "createdAt": "2020-09-07T08:28:37Z", "path": "janusgraph-test/src/test/java/org/janusgraph/graphdb/query/QueryTest.java", "diffHunk": "@@ -131,6 +132,45 @@ public void testOrderList() {\n \n     }\n \n+    @Test\n+    public void testIndexQueryCache() {", "originalCommit": "599b6b8beed017644ebef8283b69c47c5a11fbc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ2OTU4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484469586", "bodyText": "Agree. I think I will need to break this test case into multiple smaller test cases. Now several scenarios are mixed together and edge cases are more likely to be missing.", "author": "li-boxuan", "createdAt": "2020-09-07T14:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3NDA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3NzA0MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484277041", "bodyText": "I like your verbose documentation \ud83d\udc4d\nBut in this case, I think the description of the internal logic does not fit here. What you describe actually happens inside GuavaSubqueryCache, not SubqueryCache. So you should either move the description there ore move the caching logic here.\nI would even prefer to have as much logic as possible right within SubqueryCache to ensure that all implementations are behaving logically equivalent.", "author": "rngcntr", "createdAt": "2020-09-07T08:33:38Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/subquerycache/SubqueryCache.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.transaction.subquerycache;\n+\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Cache for {@link JointIndexQuery.Subquery} results. Cache entries are manually added using\n+ * {@link #get(JointIndexQuery.Subquery, Callable)} or {@link #put(JointIndexQuery.Subquery, List)},\n+ * and stored in the cache until evicted or invalidated.\n+ * <p>\n+ * Different from a simple exact mapping from keys to values,\n+ * it leverages the fact that the results of a Subquery A with limit X are first X entries of the results of the\n+ * a Subquery B with limit Y, where A and B only differ in limit, and X is less than or equal to Y.\n+ * <p>\n+ * For example, suppose the cache is empty at the beginning. Firstly, prop1_idx:multiKSQ[1]@100 query leads to a cache\n+ * miss, and then results are loaded into cache. Secondly, prop1_idx:multiKSQ[1]@20 query leads to a cache hit, and\n+ * then first 20 results of cached responses are returned. Thirdly, prop1_idx:multiKSQ[1]@2000 leads to a cache miss,\n+ * then results are loaded into cache, and initial results saved by prop1_idx:multiKSQ[1]@100 query are overriden by\n+ * the new results.\n+ * <p>\n+ * Internally, raw query results are encapsulated in {@link SubqueryResult} object together with limit of the query.\n+ * Meanwhile, keys are stored without limit (or with a dummy limit). Whenever there is a hit for key, the limit of\n+ * cached results and that of the query will be compared, and whether this is a cache hit or miss will be determined.\n+ * <p>\n+ * Compared to a simply {@link JointIndexQuery.Subquery} to {@code List<Object>} mapping, this cache has two benefits:\n+ * 1) it reduces latency, as \"subset\" queries can effectively leverage cached results.\n+ * 2) it saves space, as queries only differing in limit will not be saved more than once in cache.\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */", "originalCommit": "599b6b8beed017644ebef8283b69c47c5a11fbc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ3Mjc4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484472783", "bodyText": "agree, I will think over this and probably do some refactoring.", "author": "li-boxuan", "createdAt": "2020-09-07T14:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI3NzA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI4MjM5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r484282391", "bodyText": "If no limit is given, the cached result can be used if ordering is applied afterwards. But this wasn't done before so I'm also ok with declaring it out of scope of this PR.", "author": "rngcntr", "createdAt": "2020-09-07T08:42:41Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -2307,4 +2310,71 @@ public void testOrForceIndexComposite() throws Exception {\n             }\n         }\n     }\n+\n+    /**\n+     * This test builds a mixed index and tests index queries with order and limit.\n+     * It also tests if index query cache is utilised correctly.\n+     */\n+    @Test\n+    public void testOrderByWithLimit() {\n+        final PropertyKey age = makeKey(\"age\", Integer.class);\n+        final JanusGraphIndex mixed = mgmt.buildIndex(\"mixed\", Vertex.class).addKey(age).buildMixedIndex(INDEX);\n+        finishSchema();\n+\n+        for (int i = 0; i < 100; i++) {\n+            tx.addVertex(\"age\", i);\n+        }\n+        tx.commit();\n+\n+        clopen(option(ADJUST_LIMIT),false);\n+        final int[] ascTop100 = IntStream.range(0, 100).toArray();\n+        final int[] ascTop30 = IntStream.range(0, 30).toArray();\n+        final int[] ascTop10 = IntStream.range(0, 10).toArray();\n+        final int[] descTop100 = IntStream.range(0, 100).map(i -> 99 - i).toArray();\n+        final int[] descTop30 = IntStream.range(0, 30).map(i -> 99 - i).toArray();\n+        final int[] descTop10 = IntStream.range(0, 10).map(i -> 99 - i).toArray();\n+\n+        Supplier<GraphTraversal<Vertex, Vertex>> traversal = () -> graph.traversal().V().has(\"age\", P.gte(0)).order();\n+\n+        // traverse with limit 30 (cache cold miss)\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_ASC).limit(30).values(\"age\").profile().next()));\n+        List<Integer> ascAges30 = traversal.get().by(ORDER_AGE_ASC).limit(30).values(\"age\").toList();\n+        assertArrayEquals(ascTop30, ascAges30.stream().mapToInt(i -> i).toArray());\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_DESC).limit(30).values(\"age\").profile().next()));\n+        List<Integer> descAges30 = traversal.get().by(ORDER_AGE_DESC).limit(30).values(\"age\").toList();\n+        assertArrayEquals(descTop30, descAges30.stream().mapToInt(i -> i).toArray());\n+\n+        // traverse without limit (cache cold miss)\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_ASC).values(\"age\").profile().next()));\n+        List<Integer> ascAges = traversal.get().by(ORDER_AGE_ASC).values(\"age\").toList();\n+        assertArrayEquals(ascTop100, ascAges.stream().mapToInt(i -> i).toArray());\n+        assertTrue(hasBackendQuery((TraversalMetrics) traversal.get().by(ORDER_AGE_DESC).values(\"age\").profile().next()));", "originalCommit": "599b6b8beed017644ebef8283b69c47c5a11fbc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ2NzE0NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2195#discussion_r495467145", "bodyText": "The cached values are just vertex ids. Unless we also cache indexed field values (for mixed indexes, of course, since composite indexes do not support ordering query natively anyway), it's impossible to use caching results if ordering is applied afterward.", "author": "li-boxuan", "createdAt": "2020-09-26T15:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI4MjM5MQ=="}], "type": "inlineReview"}, {"oid": "3afb5594d4959d42534ac63dae27fcd91523ab1c", "url": "https://github.com/JanusGraph/janusgraph/commit/3afb5594d4959d42534ac63dae27fcd91523ab1c", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-26T13:31:45Z", "type": "forcePushed"}, {"oid": "e2667d4cb40981ec252d66cb2ce5bd4fe68312bb", "url": "https://github.com/JanusGraph/janusgraph/commit/e2667d4cb40981ec252d66cb2ce5bd4fe68312bb", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-26T13:35:46Z", "type": "forcePushed"}, {"oid": "d6e2a9ed26441347361a2346456d24995c884aa7", "url": "https://github.com/JanusGraph/janusgraph/commit/d6e2a9ed26441347361a2346456d24995c884aa7", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-04T04:10:05Z", "type": "forcePushed"}, {"oid": "7b194ce3c575e9accac6610ec9e5576eeb26afb3", "url": "https://github.com/JanusGraph/janusgraph/commit/7b194ce3c575e9accac6610ec9e5576eeb26afb3", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-12-21T15:29:42Z", "type": "forcePushed"}, {"oid": "1f288aad9a06fbc4678c58ca0cbe7a528ff1d6f6", "url": "https://github.com/JanusGraph/janusgraph/commit/1f288aad9a06fbc4678c58ca0cbe7a528ff1d6f6", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-12-22T06:46:44Z", "type": "forcePushed"}, {"oid": "745be5f5c60c933c827f9835fee8796d1b4348e1", "url": "https://github.com/JanusGraph/janusgraph/commit/745be5f5c60c933c827f9835fee8796d1b4348e1", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-01-02T13:18:38Z", "type": "commit"}, {"oid": "745be5f5c60c933c827f9835fee8796d1b4348e1", "url": "https://github.com/JanusGraph/janusgraph/commit/745be5f5c60c933c827f9835fee8796d1b4348e1", "message": "Refactor transaction-wise index query cache\n\nThis refactors indexCache used in transaction which caches index query results.\nNow indexCache supports subset query, i.e., cached query responses can be\nleveraged if new query and cached query only differ in limit.\n\nCloses #2194\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-01-02T13:18:38Z", "type": "forcePushed"}]}