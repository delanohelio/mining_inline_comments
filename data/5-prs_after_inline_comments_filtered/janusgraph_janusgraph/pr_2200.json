{"pr_number": 2200, "pr_title": "Add strategy that optimize mixed index lookup followed by count step", "pr_createdAt": "2020-09-05T09:18:57Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2200", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkzMTkwMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r483931901", "bodyText": "Now I think constructing a direct index query might be the wrong direction. Using existing Stream<String> query(IndexQuery query, KeyInformation.IndexRetriever information, BaseTransaction tx) in IndexProvider and appending count seems better.", "author": "li-boxuan", "createdAt": "2020-09-05T09:24:45Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/IndexQueryBuilder.java", "diffHunk": "@@ -152,6 +184,73 @@ public String getUnknownKeyName() {\n     // Builder Methods\n     //################################################\n \n+    /**\n+     * Given constraints and result type, construct a direct index query\n+     * If no direct index query can be built, return NULL\n+     *\n+     * @param optProfiler\n+     * @param constraints\n+     * @param resultType\n+     * @return\n+     */\n+    public IndexQueryBuilder constructIndex(QueryProfiler optProfiler,\n+                                            List<PredicateCondition<String, JanusGraphElement>> constraints,\n+                                            ElementCategory resultType) {\n+        optProfiler.startTimer();\n+        // Prepare constraints\n+        final MultiCondition<JanusGraphElement> conditions = QueryUtil.constraints2QNF(tx, constraints);\n+\n+        final Set<Condition> coveredClauses = new HashSet<>();\n+        final IndexSelectionStrategy.SelectedIndexQuery selectedIndex = indexSelector.selectIndices(\n+            resultType, conditions, coveredClauses, OrderList.NO_ORDER, serializer);\n+        if (selectedIndex.isEmpty()) {\n+            return null;\n+        }\n+        JointIndexQuery query = selectedIndex.getQuery();\n+\n+        assert query.size() == 1;\n+        assert query.getQuery(0).getIndex().isMixedIndex() == true;\n+\n+        setIndex(query.getQuery(0).getIndex().getName());\n+        setResultType(resultType);\n+\n+        StringBuilder queryBuilder = new StringBuilder();\n+        constructQuery(queryBuilder, constraints.get(0));\n+        for (int i = 1; i < constraints.size(); i++) {\n+            queryBuilder.append(\" AND \");\n+            constructQuery(queryBuilder, constraints.get(i));\n+        }\n+\n+        setQuery(queryBuilder.toString());\n+        optProfiler.stopTimer();\n+        return this;\n+    }\n+\n+    private void constructQuery(final StringBuilder queryBuilder,\n+                                final PredicateCondition<String, JanusGraphElement> constraint) {\n+        if (ElementCategory.VERTEX.equals(resultType)) {\n+            setPrefixInternal(VERTEX_PREFIX);\n+            queryBuilder.append('v');\n+        } else {\n+            assert ElementCategory.EDGE == resultType;\n+            setPrefixInternal(EDGE_PREFIX);\n+            queryBuilder.append('e');\n+        }\n+        queryBuilder.append(\".\\\"\" + constraint.getKey() + \"\\\":\");\n+        if (Contain.IN.equals(constraint.getPredicate())) {\n+            queryBuilder.append(\"(\");\n+            for (Object value : (List) constraint.getValue()) {\n+                queryBuilder.append(\"\\\"\" + value + \"\\\"\");\n+            }\n+            queryBuilder.append(\")\");\n+        } else if (Text.CONTAINS.equals(constraint.getPredicate()) || Cmp.EQUAL.equals(constraint.getPredicate())) {\n+            queryBuilder.append(\"\\\"\" + constraint.getValue() + \"\\\"\");\n+        } else {\n+            // TODO: we should support all types as long as a single mixed query can be constructed", "originalCommit": "a4f53bd0b24d220a9f85daac876563426aa9fb93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "edbe204982fc98f5c41815855a1c88fce0e0756e", "url": "https://github.com/JanusGraph/janusgraph/commit/edbe204982fc98f5c41815855a1c88fce0e0756e", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-09-06T10:08:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1OTExNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r485359115", "bodyText": "You could maybe add some cases in which the query cannot be optimized and check that there is indeed no JanusGraphMixedIndexCountStep inserted. For example if there is an index but it's type is not mixed. Or there are steps between has(...) and count(), just to name a few ideas.", "author": "rngcntr", "createdAt": "2020-09-09T06:06:54Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -1112,6 +1113,99 @@ public void testIndexParameters() {\n         }\n     }\n \n+    /**\n+     * Tests that if a given query can be satisfied by a single mixed index, and it is followed by a count step, then\n+     * a count query will be built\n+     */\n+    @Test\n+    public void testMixedIndexQueryFollowedByCount() {\n+        final int numV = 1000;\n+        long total;\n+        TraversalMetrics metrics;\n+        final String[] strings = {\"Uncle Berry has a farm\", \"and on his farm he has five ducks\", \"ducks are beautiful animals\", \"the sky is very blue today\"};\n+        setupChainGraph(numV, strings, true);\n+        clopen();\n+\n+        /* ===================================================\n+        has(key, value) followed by count() can be optimized */", "originalCommit": "edbe204982fc98f5c41815855a1c88fce0e0756e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY3NzAyNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r485677026", "bodyText": "Totally. I need to add more test cases.", "author": "li-boxuan", "createdAt": "2020-09-09T14:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1OTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4MzM2OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r485383369", "bodyText": "I like the Idea that the step itself performs the time consuming task of index selection, which makes it possible to track the work done in the optimization phase. Great idea!", "author": "rngcntr", "createdAt": "2020-09-09T07:02:50Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/JanusGraphMixedIndexCountStep.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traverser;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.Profiling;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.ReducingBarrierStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.MutableMetrics;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.apache.tinkerpop.gremlin.structure.util.StringFactory;\n+import org.janusgraph.core.JanusGraphElement;\n+import org.janusgraph.core.JanusGraphIndexQuery;\n+import org.janusgraph.core.JanusGraphTransaction;\n+import org.janusgraph.core.MixedIndexCountQuery;\n+import org.janusgraph.graphdb.internal.ElementCategory;\n+import org.janusgraph.graphdb.internal.OrderList;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+import org.janusgraph.graphdb.query.QueryUtil;\n+import org.janusgraph.graphdb.query.condition.Condition;\n+import org.janusgraph.graphdb.query.condition.MultiCondition;\n+import org.janusgraph.graphdb.query.condition.PredicateCondition;\n+import org.janusgraph.graphdb.query.graph.IndexQueryBuilder;\n+import org.janusgraph.graphdb.query.graph.JointIndexQuery;\n+import org.janusgraph.graphdb.query.graph.MixedIndexCountQueryBuilder;\n+import org.janusgraph.graphdb.query.index.IndexSelectionStrategy;\n+import org.janusgraph.graphdb.query.index.SingleMixedIndexSelectionStrategy;\n+import org.janusgraph.graphdb.query.profile.QueryProfiler;\n+import org.janusgraph.graphdb.tinkerpop.profile.TP3ProfileWrapper;\n+import org.janusgraph.graphdb.transaction.StandardJanusGraphTx;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class JanusGraphMixedIndexCountStep<S> extends ReducingBarrierStep<S, Long> implements Profiling {\n+\n+    private final List<HasContainer> hasContainers = new ArrayList<>();\n+    private QueryProfiler queryProfiler = QueryProfiler.NO_OP;\n+    private QueryProfiler optProfiler = QueryProfiler.NO_OP;\n+    private MixedIndexCountQuery mixedIndexCountQuery;\n+    private boolean done = false;\n+    private IndexSelectionStrategy indexSelector = new SingleMixedIndexSelectionStrategy();\n+\n+    public JanusGraphMixedIndexCountStep(final Traversal.Admin traversal) {\n+        super(traversal);\n+    }\n+\n+    public void setMixedIndexCountQuery(MixedIndexCountQuery mixedIndexCountQuery) {\n+        Objects.requireNonNull(mixedIndexCountQuery);\n+        this.mixedIndexCountQuery = mixedIndexCountQuery;\n+    }\n+\n+    public MixedIndexCountQuery buildGlobalGraphIndexQuery(final GraphStep originalGraphStep, final JanusGraphTransaction tx) {\n+        optProfiler = new TP3ProfileWrapper(new MutableMetrics(this.getId() + \"optimization\", \"optimization\"));\n+        MixedIndexCountQueryBuilder countQueryBuilder = (MixedIndexCountQueryBuilder) tx.mixedIndexCountQuery();\n+        List<PredicateCondition<String, JanusGraphElement>> constraints = new ArrayList<>();\n+        for (final HasContainer condition : hasContainers) {\n+            constraints.add(new PredicateCondition<>(condition.getKey(), JanusGraphPredicateUtils.convert(condition.getBiPredicate()), condition.getValue()));\n+        }\n+        return countQueryBuilder.constructIndex(optProfiler, constraints,", "originalCommit": "edbe204982fc98f5c41815855a1c88fce0e0756e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4ODY2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r485388665", "bodyText": "It took me about half an hour to figure out that this is actually the line that checks if the optimization should be applied at all. I tried to find the line that clearly differentiates between mixed and composite indexes. The fact that this is buried deeply inside the index selection part is a bit of an obfuscation of what actually happens here.\nNow that it became clear to me, it would be good to at least point out exactly what happens here.", "author": "rngcntr", "createdAt": "2020-09-09T07:14:18Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/JanusGraphMixedIndexCountStrategy.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.Compare;\n+import org.apache.tinkerpop.gremlin.process.traversal.Contains;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.HasContainerHolder;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.OrStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.CountGlobalStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.NoOpBarrierStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.IdentityStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.T;\n+import org.janusgraph.core.JanusGraphTransaction;\n+import org.janusgraph.core.MixedIndexCountQuery;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.tinkerpop.optimize.HasStepFolder.validFoldInHasContainer;\n+\n+/**\n+ * If the query can be satisfied by a single mixed index query, and the query is followed by a count step, then\n+ * this strategy replaces original step with {@link JanusGraphMixedIndexCountStep}, which fires a count query against\n+ * mixed index backend without retrieving all elements\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class JanusGraphMixedIndexCountStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+    private static final JanusGraphMixedIndexCountStrategy INSTANCE = new JanusGraphMixedIndexCountStrategy();\n+\n+    private JanusGraphMixedIndexCountStrategy() {\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal))\n+            return;\n+\n+        TraversalHelper.getStepsOfClass(GraphStep.class, traversal).forEach(originalGraphStep -> {\n+            if (originalGraphStep.getIds() == null || originalGraphStep.getIds().length == 0) {\n+                buildMixedIndexCountStep(originalGraphStep, traversal);\n+            }\n+        });\n+    }\n+\n+    private void buildMixedIndexCountStep(final GraphStep originalGraphStep, final Traversal.Admin<?, ?> traversal) {\n+        if (!hasCountGlobalStep(originalGraphStep)) {\n+            return;\n+        }\n+        final JanusGraphMixedIndexCountStep<?> directQueryCountStep = new JanusGraphMixedIndexCountStep<>(traversal);\n+        // we shouldn't really fold in, but only check it, because we don't want to break the original traversal,\n+        // as this optimizer might fail\n+        if (!foldInHasContainer(originalGraphStep, directQueryCountStep, traversal, traversal)) {\n+            return;\n+        }\n+        final JanusGraphTransaction tx = JanusGraphTraversalUtil.getTx(traversal);\n+        MixedIndexCountQuery mixedIndexCountQuery = directQueryCountStep.buildGlobalGraphIndexQuery(originalGraphStep, tx);", "originalCommit": "edbe204982fc98f5c41815855a1c88fce0e0756e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM5MDE5NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r485390194", "bodyText": "These instanceof chains are used quite often so it would be better to move the check to a separate method. This would also give these steps a name that is more readable. For example while (isEligibleToSkip(currentStep)) {...}", "author": "rngcntr", "createdAt": "2020-09-09T07:17:17Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/JanusGraphMixedIndexCountStrategy.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.Compare;\n+import org.apache.tinkerpop.gremlin.process.traversal.Contains;\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.HasContainerHolder;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.filter.OrStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.CountGlobalStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.NoOpBarrierStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.IdentityStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.util.HasContainer;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.apache.tinkerpop.gremlin.structure.T;\n+import org.janusgraph.core.JanusGraphTransaction;\n+import org.janusgraph.core.MixedIndexCountQuery;\n+import org.janusgraph.graphdb.query.JanusGraphPredicateUtils;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.janusgraph.graphdb.tinkerpop.optimize.HasStepFolder.validFoldInHasContainer;\n+\n+/**\n+ * If the query can be satisfied by a single mixed index query, and the query is followed by a count step, then\n+ * this strategy replaces original step with {@link JanusGraphMixedIndexCountStep}, which fires a count query against\n+ * mixed index backend without retrieving all elements\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class JanusGraphMixedIndexCountStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+    private static final JanusGraphMixedIndexCountStrategy INSTANCE = new JanusGraphMixedIndexCountStrategy();\n+\n+    private JanusGraphMixedIndexCountStrategy() {\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal))\n+            return;\n+\n+        TraversalHelper.getStepsOfClass(GraphStep.class, traversal).forEach(originalGraphStep -> {\n+            if (originalGraphStep.getIds() == null || originalGraphStep.getIds().length == 0) {\n+                buildMixedIndexCountStep(originalGraphStep, traversal);\n+            }\n+        });\n+    }\n+\n+    private void buildMixedIndexCountStep(final GraphStep originalGraphStep, final Traversal.Admin<?, ?> traversal) {\n+        if (!hasCountGlobalStep(originalGraphStep)) {\n+            return;\n+        }\n+        final JanusGraphMixedIndexCountStep<?> directQueryCountStep = new JanusGraphMixedIndexCountStep<>(traversal);\n+        // we shouldn't really fold in, but only check it, because we don't want to break the original traversal,\n+        // as this optimizer might fail\n+        if (!foldInHasContainer(originalGraphStep, directQueryCountStep, traversal, traversal)) {\n+            return;\n+        }\n+        final JanusGraphTransaction tx = JanusGraphTraversalUtil.getTx(traversal);\n+        MixedIndexCountQuery mixedIndexCountQuery = directQueryCountStep.buildGlobalGraphIndexQuery(originalGraphStep, tx);\n+        if (mixedIndexCountQuery != null) {\n+            directQueryCountStep.setMixedIndexCountQuery(mixedIndexCountQuery);\n+            removeHasContainerSteps(originalGraphStep, directQueryCountStep, traversal);\n+        }\n+    }\n+\n+    private boolean hasCountGlobalStep(final GraphStep originalGraphStep) {\n+        Step<?, ?> currentStep = originalGraphStep.getNextStep();\n+        while (currentStep instanceof IdentityStep || currentStep instanceof NoOpBarrierStep || currentStep instanceof HasContainerHolder) {", "originalCommit": "edbe204982fc98f5c41815855a1c88fce0e0756e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a113c0d8a68a975b1caf8ac80be857d795af46f", "url": "https://github.com/JanusGraph/janusgraph/commit/6a113c0d8a68a975b1caf8ac80be857d795af46f", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-18T07:05:46Z", "type": "forcePushed"}, {"oid": "0bb36f5b27e1a5d2d64636ac28454898113b1472", "url": "https://github.com/JanusGraph/janusgraph/commit/0bb36f5b27e1a5d2d64636ac28454898113b1472", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-20T06:40:30Z", "type": "forcePushed"}, {"oid": "3ddc708eff5120c5d3705de5dfa4a8694b4c457a", "url": "https://github.com/JanusGraph/janusgraph/commit/3ddc708eff5120c5d3705de5dfa4a8694b4c457a", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-20T07:22:03Z", "type": "forcePushed"}, {"oid": "d82f570df3dcd2afc8949241148eabb5d14bebbb", "url": "https://github.com/JanusGraph/janusgraph/commit/d82f570df3dcd2afc8949241148eabb5d14bebbb", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-27T11:50:28Z", "type": "forcePushed"}, {"oid": "202248078f62859b741693766e6556dc651c6820", "url": "https://github.com/JanusGraph/janusgraph/commit/202248078f62859b741693766e6556dc651c6820", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-27T12:42:46Z", "type": "forcePushed"}, {"oid": "439d437e76522411030fdad2a6928858d470aed3", "url": "https://github.com/JanusGraph/janusgraph/commit/439d437e76522411030fdad2a6928858d470aed3", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-27T12:45:02Z", "type": "forcePushed"}, {"oid": "9110d2c9ef6c2853fb8100f1c46a54e9fc75cd08", "url": "https://github.com/JanusGraph/janusgraph/commit/9110d2c9ef6c2853fb8100f1c46a54e9fc75cd08", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-27T16:54:43Z", "type": "forcePushed"}, {"oid": "d166b48f03b58e64d2eb5603b6af0358969fa716", "url": "https://github.com/JanusGraph/janusgraph/commit/d166b48f03b58e64d2eb5603b6af0358969fa716", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-29T16:52:29Z", "type": "forcePushed"}, {"oid": "394924b59f2561494ac541eb1e45d8a0b0f5f616", "url": "https://github.com/JanusGraph/janusgraph/commit/394924b59f2561494ac541eb1e45d8a0b0f5f616", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-30T05:28:03Z", "type": "forcePushed"}, {"oid": "bfc2b14286b3f8301050a77e609413a0e13ac6c8", "url": "https://github.com/JanusGraph/janusgraph/commit/bfc2b14286b3f8301050a77e609413a0e13ac6c8", "message": "Add strategy that optimize mixed index lookup followed by count step\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-06-30T14:24:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0MTQ5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r661541491", "bodyText": "To pass Solr tests it probably should be:\nfinal String xtextKey = getStringField(\"xtext\");\n\nMaybe in some other places as well. I didn't check the whole test yet", "author": "porunov", "createdAt": "2021-06-30T14:40:54Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -1523,6 +1525,203 @@ public void testIndexParameters() {\n         }\n     }\n \n+    private void checkMixedIndexCountProfiling(TraversalMetrics profile, Map<String, String> annotations) {\n+        Metrics metrics = profile.getMetrics(0);\n+        assertTrue(metrics.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertTrue(metrics.getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        Metrics nested = (Metrics) metrics.getNested().toArray()[0];\n+        assertEquals(QueryProfiler.MIXED_INEX_COUNT_QUERY, nested.getName());\n+        assertTrue(nested.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertEquals(annotations, nested.getAnnotations());\n+    }\n+\n+    /**\n+     * Tests that if a given query can be satisfied by a single mixed index, and it is followed by a count step, then\n+     * a count query will be built\n+     */\n+    @Test\n+    public void testMixedIndexQueryFollowedByCount() {\n+        final int numV = 100;\n+        long total;\n+        final String[] strings = {\"Uncle Berry has a farm\", \"and on his farm he has five ducks\", \"ducks are beautiful animals\", \"the sky is very blue today\"};\n+        setupChainGraph(numV, strings, true);\n+        clopen();\n+\n+        /* ===================================================\n+        has(key, value) followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.text:ducks\").vertexTotals());\n+        TraversalMetrics profile = graph.traversal().V().has(\"text\", Text.textContains(\"ducks\")).count().profile().next();\n+        final String xtextKey = \"xtext\";", "originalCommit": "bfc2b14286b3f8301050a77e609413a0e13ac6c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4511fe970d9ed6cc88cc4c5f4c4031631a717f2b", "url": "https://github.com/JanusGraph/janusgraph/commit/4511fe970d9ed6cc88cc4c5f4c4031631a717f2b", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-01T01:51:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjIxMDIyMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r662210221", "bodyText": "Looks like this one can actually be a constant (i.e. private final static)", "author": "porunov", "createdAt": "2021-07-01T11:33:11Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/JanusGraphMixedIndexCountStrategy.java", "diffHunk": "@@ -0,0 +1,121 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.HasContainerHolder;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.CountGlobalStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.NoOpBarrierStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.IdentityStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.janusgraph.core.JanusGraphTransaction;\n+import org.janusgraph.core.MixedIndexCountQuery;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.step.JanusGraphMixedIndexCountStep;\n+import org.janusgraph.graphdb.tinkerpop.optimize.step.JanusGraphStep;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+/**\n+ * If the query can be satisfied by a single mixed index query, and the query is followed by a count step, then\n+ * this strategy replaces original step with {@link JanusGraphMixedIndexCountStep}, which fires a count query against\n+ * mixed index backend without retrieving all elements\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class JanusGraphMixedIndexCountStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+    private static final JanusGraphMixedIndexCountStrategy INSTANCE = new JanusGraphMixedIndexCountStrategy();\n+\n+    private JanusGraphMixedIndexCountStrategy() {\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal))\n+            return;\n+\n+        TraversalHelper.getStepsOfClass(JanusGraphStep.class, traversal).forEach(originalGraphStep -> {\n+            buildMixedIndexCountStep(originalGraphStep, traversal);\n+        });\n+    }\n+\n+    /**\n+     * Check if a mixed index count step can be built, and if so, apply it.\n+     *\n+     * @param originalGraphStep\n+     * @param traversal\n+     */\n+    private void buildMixedIndexCountStep(final JanusGraphStep originalGraphStep, final Traversal.Admin<?, ?> traversal) {\n+        if (!hasCountGlobalStep(originalGraphStep)) {\n+            return;\n+        }\n+        final JanusGraphMixedIndexCountStep<?> directQueryCountStep = new JanusGraphMixedIndexCountStep<>(traversal);\n+\n+        final JanusGraphTransaction tx = JanusGraphTraversalUtil.getTx(traversal);\n+        // try to find a suitable mixed index and build a mixed index count query\n+        MixedIndexCountQuery mixedIndexCountQuery = directQueryCountStep.buildGlobalGraphIndexQuery(originalGraphStep, tx);\n+        if (mixedIndexCountQuery != null) {\n+            applyMixedIndexCountStep(originalGraphStep, directQueryCountStep, traversal);\n+        }\n+    }\n+\n+    private boolean isEligibleToSkip(final Step currentStep) {\n+        return currentStep instanceof IdentityStep || currentStep instanceof NoOpBarrierStep || currentStep instanceof HasContainerHolder;\n+    }\n+\n+    private boolean hasCountGlobalStep(final GraphStep originalGraphStep) {\n+        Step<?, ?> currentStep = originalGraphStep.getNextStep();\n+        while (isEligibleToSkip(currentStep)) {\n+            currentStep = currentStep.getNextStep();\n+        }\n+        return currentStep instanceof CountGlobalStep;\n+    }\n+\n+    /**\n+     * Apply mixed index count step in the traversal and remove \"has\" steps that already folded in the mixedIndexCountStep\n+     *\n+     * @param originalGraphStep\n+     * @param mixedIndexCountStep\n+     * @param traversal\n+     */\n+    private void applyMixedIndexCountStep(final GraphStep originalGraphStep, final JanusGraphMixedIndexCountStep mixedIndexCountStep,\n+                                          final Traversal.Admin<?, ?> traversal) {\n+        Step<?, ?> currentStep = originalGraphStep.getNextStep();\n+        while (true) {\n+            if (currentStep instanceof HasContainerHolder || currentStep instanceof CountGlobalStep) {\n+                traversal.removeStep(currentStep);\n+            } else if (!isEligibleToSkip(currentStep)) {\n+                break;\n+            }\n+            currentStep = currentStep.getNextStep();\n+        }\n+        TraversalHelper.replaceStep(originalGraphStep, mixedIndexCountStep, traversal);\n+    }\n+\n+    public static JanusGraphMixedIndexCountStrategy instance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public Set<Class<? extends ProviderOptimizationStrategy>> applyPrior() {\n+        return Collections.singleton(JanusGraphStepStrategy.class);", "originalCommit": "4511fe970d9ed6cc88cc4c5f4c4031631a717f2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3bafe9bb192d9105fe1fca3668dbd81a1972d765", "url": "https://github.com/JanusGraph/janusgraph/commit/3bafe9bb192d9105fe1fca3668dbd81a1972d765", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-01T14:53:13Z", "type": "forcePushed"}, {"oid": "df8b5d2e62613467e1e608880373b0e2dde4ce77", "url": "https://github.com/JanusGraph/janusgraph/commit/df8b5d2e62613467e1e608880373b0e2dde4ce77", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-02T10:48:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzMzMjgwMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663332801", "bodyText": "I was thinking about more test cases. Can we add 2 more test cases?\nhas(\"nonIndexedProperty\").has(\"indexedProperty\").count()\nhas(\"indexedProperty\").has(\"nonIndexedProperty\").count()\nWhat do you think about it? Maybe we already checking these cases in other tests. If so, just ignore this comment\nthe above 2 queries are computed the same but they should not be optimized with Mixed Query Count optimization because the whole chain of 'has' steps cannot be answered by a single mixed index.", "author": "porunov", "createdAt": "2021-07-03T07:45:39Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -1523,6 +1529,202 @@ public void testIndexParameters() {\n         }\n     }\n \n+    private void checkMixedIndexCountProfiling(TraversalMetrics profile, Map<String, String> annotations) {\n+        Metrics metrics = profile.getMetrics(0);\n+        assertTrue(metrics.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertTrue(metrics.getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        Metrics nested = (Metrics) metrics.getNested().toArray()[0];\n+        assertEquals(QueryProfiler.MIXED_INEX_COUNT_QUERY, nested.getName());\n+        assertTrue(nested.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertEquals(annotations, nested.getAnnotations());\n+    }\n+\n+    /**\n+     * Tests that if a given query can be satisfied by a single mixed index, and it is followed by a count step, then\n+     * a count query will be built\n+     */\n+    @Test\n+    public void testMixedIndexQueryFollowedByCount() {\n+        final int numV = 100;\n+        final String[] strings = {\"Uncle Berry has a farm\", \"and on his farm he has five ducks\", \"ducks are beautiful animals\", \"the sky is very blue today\"};\n+        setupChainGraph(numV, strings, true);\n+        clopen();\n+\n+        /* ===================================================\n+        has(key, value) followed by count() can be optimized */\n+\n+        // vertex\n+        long total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.text:ducks\").vertexTotals());\n+        TraversalMetrics profile = graph.traversal().V().has(\"text\", Text.textContains(\"ducks\")).count().profile().next();\n+        final String xtextKey = \"xtext\";\n+        Map<String, String> annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains ducks)]:vsearch\", xtextKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"text\", Text.textContains(\"ducks\")).count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.text:ducks\").edgeTotals());\n+        profile = graph.traversal().E().has(\"text\", Text.textContains(\"ducks\")).count().profile().next();\n+        final String textKey = getTextField(\"text\");\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains ducks)]:esearch\", textKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().E().has(\"text\", Text.textContains(\"ducks\")).count().next());\n+\n+        /* =====================================================================\n+        has(key, value).has(key', value') followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.text:farm AND v.name:\\\"Uncle Berry has a farm\\\"\").vertexTotals());\n+        profile = graph.traversal().V().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().profile().next();\n+        final String nameKey = getStringField(\"name\");\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains farm AND %s = Uncle Berry has a farm)]:vsearch\", xtextKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().next());\n+\n+        // edge\n+        total = numV / strings.length;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.text:farm AND e.name:\\\"Uncle Berry has a farm\\\"\").edgeTotals());\n+        profile = graph.traversal().E().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains farm AND %s = Uncle Berry has a farm)]:esearch\", textKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().E().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().next());\n+\n+        /* ==============================================================\n+        has(key, P.within(values)) followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.name:(\\\"Uncle Berry has a farm\\\", \\\"ducks are beautiful animals\\\")\").vertexTotals());\n+        profile = graph.traversal().V().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\"))\n+            .count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[((%s = Uncle Berry has a farm OR %s = ducks are beautiful animals))]:vsearch\", nameKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\")).count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.name:(\\\"Uncle Berry has a farm\\\", \\\"ducks are beautiful animals\\\")\").edgeTotals());\n+        profile = graph.traversal().E().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\"))\n+            .count().profile().next();\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().E().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\")).count().next());\n+\n+\n+        /* ==========================================================================\n+        Or(has(key, value1), has(key, value2)) followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.name:(\\\"Uncle Berry has a farm\\\", \\\"and on his farm he has five ducks\\\")\").vertexTotals());\n+        profile = graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[((%s = Uncle Berry has a farm OR %s = and on his farm he has five ducks))]:vsearch\", nameKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.name:(\\\"Uncle Berry has a farm\\\", \\\"and on his farm he has five ducks\\\")\").edgeTotals());\n+        profile = graph.traversal().E().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().profile().next();\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().E().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().next());\n+\n+        /* ==========================================================================\n+        Or(has(key1, value1), has(key2, value2)) followed by count() can be optimized\n+        if both keys are included by a single index */\n+        if (indexFeatures.supportNotQueryNormalForm()) {\n+            total = numV / strings.length * 2;\n+            profile = graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"text\", Text.textContains(\"and on his farm he has five ducks\")))\n+                .count().profile().next();\n+            annotations = new HashMap() {{\n+                put(\"query\", String.format(\"[((%s = Uncle Berry has a farm) OR (%s textContains and on his farm he has five ducks))]:vsearch\", nameKey, xtextKey));\n+            }};\n+            checkMixedIndexCountProfiling(profile, annotations);\n+            assertEquals(total, graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"text\", Text.textContains(\"and on his farm he has five ducks\")))\n+                .count().next());\n+        }\n+\n+        /* ==========================================================================\n+        has(key, neq(value)) followed by count() can be optimized */\n+        total = numV;\n+        profile = graph.traversal().V().has(\"name\", P.neq(\"value\")).count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> value)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.neq(\"value\")).count().next());\n+\n+        profile = graph.traversal().V().has(\"name\", P.neq(null)).count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> null)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.neq(null)).count().next());\n+\n+        /* ==========================================================================\n+        has(key) followed by count() can be optimized */\n+\n+        total = numV;\n+        profile = graph.traversal().V().has(\"name\").count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> null)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\").count().next());\n+\n+        /* ==========================================================================\n+        has(key, value) followed by other steps and then count() cannot be optimized */\n+\n+        total = numV / strings.length;\n+        profile = graph.traversal().V().has(\"name\", \"Uncle Berry has a farm\").out().count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().V().has(\"name\", \"Uncle Berry has a farm\").out().count().next());\n+\n+        /* ==========================================================================\n+        has(key, value) with composite index followed by count() cannot be optimized */\n+\n+        final PropertyKey ageProperty = mgmt.makePropertyKey(\"age\").dataType(Integer.class).make();\n+        mgmt.buildIndex(\"ageidx\", Vertex.class).addKey(ageProperty).buildCompositeIndex();\n+        finishSchema();\n+\n+        for (int i = 0; i < 10; i++) {\n+            tx.addVertex(\"age\", i % 2);\n+        }\n+        newTx();\n+\n+        profile = graph.traversal().V().has(\"age\", 0).count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(5, graph.traversal().V().has(\"age\", 0).count().next());\n+        profile = graph.traversal().V().has(\"age\").count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(10, graph.traversal().V().has(\"age\").count().next());\n+", "originalCommit": "df8b5d2e62613467e1e608880373b0e2dde4ce77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e317e4e5ac743acf16166cc2c3924cfa87924c6", "url": "https://github.com/JanusGraph/janusgraph/commit/4e317e4e5ac743acf16166cc2c3924cfa87924c6", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-03T13:06:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY0NjI0Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663646243", "bodyText": "What is the reason to change these queries from count().next() to toList().size()? I see that the result should be equivalent, but therefore I don't see the necessity to change the query.", "author": "rngcntr", "createdAt": "2021-07-05T05:27:22Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -1124,6 +1126,7 @@ public void testGraphCentricQueryProfiling() {\n         if (indexFeatures.supportNotQueryNormalForm()) {\n             newTx();\n             assertEquals(3, tx.traversal().V().or(__.has(\"name\", \"bob\"), __.has(\"prop\", \"val\")).count().next());\n+            assertEquals(3, tx.traversal().V().or(__.has(\"name\", \"bob\"), __.has(\"prop\", \"val\")).toList().size());", "originalCommit": "4e317e4e5ac743acf16166cc2c3924cfa87924c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY1OTYzNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663659634", "bodyText": "Now that count() queries are optimized by JanusGraphMixedIndexCountStrategy, I just add this extra check to ensure correctness when JanusGraphMixedIndexCountStrategy does not apply.", "author": "li-boxuan", "createdAt": "2021-07-05T06:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY0NjI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY1MzY2OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663653669", "bodyText": "I stumbled upon this logic and was wondering if it is correct. For example, a query with count().count() (which by the way is completely bonkers) should always return 1, but would be reduced to one JanusGraphMixedIndexCountStep here.", "author": "rngcntr", "createdAt": "2021-07-05T05:49:06Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/tinkerpop/optimize/strategy/JanusGraphMixedIndexCountStrategy.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.graphdb.tinkerpop.optimize.strategy;\n+\n+import org.apache.tinkerpop.gremlin.process.traversal.Step;\n+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;\n+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.HasContainerHolder;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.CountGlobalStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.map.NoOpBarrierStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.IdentityStep;\n+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;\n+import org.apache.tinkerpop.gremlin.process.traversal.util.TraversalHelper;\n+import org.janusgraph.core.JanusGraphTransaction;\n+import org.janusgraph.core.MixedIndexCountQuery;\n+import org.janusgraph.graphdb.tinkerpop.optimize.JanusGraphTraversalUtil;\n+import org.janusgraph.graphdb.tinkerpop.optimize.step.JanusGraphMixedIndexCountStep;\n+import org.janusgraph.graphdb.tinkerpop.optimize.step.JanusGraphStep;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+/**\n+ * If the query can be satisfied by a single mixed index query, and the query is followed by a count step, then\n+ * this strategy replaces original step with {@link JanusGraphMixedIndexCountStep}, which fires a count query against\n+ * mixed index backend without retrieving all elements\n+ *\n+ * @author Boxuan Li (liboxuan@connect.hku.hk)\n+ */\n+public class JanusGraphMixedIndexCountStrategy extends AbstractTraversalStrategy<TraversalStrategy.ProviderOptimizationStrategy>\n+    implements TraversalStrategy.ProviderOptimizationStrategy {\n+    private static final JanusGraphMixedIndexCountStrategy INSTANCE = new JanusGraphMixedIndexCountStrategy();\n+    private static final Set<Class<? extends ProviderOptimizationStrategy>> PRIORS = Collections.singleton(JanusGraphStepStrategy.class);\n+\n+    private JanusGraphMixedIndexCountStrategy() {\n+    }\n+\n+    @Override\n+    public void apply(final Traversal.Admin<?, ?> traversal) {\n+        if (TraversalHelper.onGraphComputer(traversal))\n+            return;\n+\n+        TraversalHelper.getStepsOfClass(JanusGraphStep.class, traversal).forEach(originalGraphStep -> {\n+            buildMixedIndexCountStep(originalGraphStep, traversal);\n+        });\n+    }\n+\n+    /**\n+     * Check if a mixed index count step can be built, and if so, apply it.\n+     *\n+     * @param originalGraphStep\n+     * @param traversal\n+     */\n+    private void buildMixedIndexCountStep(final JanusGraphStep originalGraphStep, final Traversal.Admin<?, ?> traversal) {\n+        if (!hasCountGlobalStep(originalGraphStep)) {\n+            return;\n+        }\n+        final JanusGraphMixedIndexCountStep<?> directQueryCountStep = new JanusGraphMixedIndexCountStep<>(traversal);\n+\n+        final JanusGraphTransaction tx = JanusGraphTraversalUtil.getTx(traversal);\n+        // try to find a suitable mixed index and build a mixed index count query\n+        MixedIndexCountQuery mixedIndexCountQuery = directQueryCountStep.buildGlobalGraphIndexQuery(originalGraphStep, tx);\n+        if (mixedIndexCountQuery != null) {\n+            applyMixedIndexCountStep(originalGraphStep, directQueryCountStep, traversal);\n+        }\n+    }\n+\n+    private boolean isEligibleToSkip(final Step currentStep) {\n+        return currentStep instanceof IdentityStep || currentStep instanceof NoOpBarrierStep || currentStep instanceof HasContainerHolder;\n+    }\n+\n+    private boolean hasCountGlobalStep(final GraphStep originalGraphStep) {\n+        Step<?, ?> currentStep = originalGraphStep.getNextStep();\n+        while (isEligibleToSkip(currentStep)) {\n+            currentStep = currentStep.getNextStep();\n+        }\n+        return currentStep instanceof CountGlobalStep;\n+    }\n+\n+    /**\n+     * Apply mixed index count step in the traversal and remove \"has\" steps that already folded in the mixedIndexCountStep\n+     *\n+     * @param originalGraphStep\n+     * @param mixedIndexCountStep\n+     * @param traversal\n+     */\n+    private void applyMixedIndexCountStep(final GraphStep originalGraphStep, final JanusGraphMixedIndexCountStep mixedIndexCountStep,\n+                                          final Traversal.Admin<?, ?> traversal) {\n+        Step<?, ?> currentStep = originalGraphStep.getNextStep();\n+        while (true) {\n+            if (currentStep instanceof HasContainerHolder || currentStep instanceof CountGlobalStep) {", "originalCommit": "4e317e4e5ac743acf16166cc2c3924cfa87924c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY2MDE2MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663660160", "bodyText": "That is a great point! I don't even know count().count() is legal. I'll check if the result is still correct in this case.", "author": "li-boxuan", "createdAt": "2021-07-05T06:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY1MzY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY3MTc4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663671786", "bodyText": "Should be legal because count() simply produces a single traverser with a count value. This traverser itself can also be counted even if that makes no sense.\nIn addition, I am not entirely sure if there can exist other HasContainerHolder steps between the JanusGraphStep and the CountGlobalStep. For example, JanusGraphStep itself is a HasContainerHolder and so may be other steps. Let me take something like this as an example: g.V().V().count(). Since both V() are represented by JanusGraphStep, both satisfy the condition for this strategy.", "author": "rngcntr", "createdAt": "2021-07-05T06:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY1MzY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mzk1Njc3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663956770", "bodyText": "I rewrote this method and added a few test cases. Let me know if you come up with other corner cases.", "author": "li-boxuan", "createdAt": "2021-07-05T14:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY1MzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY1OTExMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663659110", "bodyText": "@rngcntr This covers the case \"tests combining mixed and composite indexes\". \"age\" is indexed by a composite index while \"name\" is indexed by a mixed index.", "author": "li-boxuan", "createdAt": "2021-07-05T06:03:26Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -1523,6 +1529,213 @@ public void testIndexParameters() {\n         }\n     }\n \n+    private void checkMixedIndexCountProfiling(TraversalMetrics profile, Map<String, String> annotations) {\n+        Metrics metrics = profile.getMetrics(0);\n+        assertTrue(metrics.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertTrue(metrics.getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        Metrics nested = (Metrics) metrics.getNested().toArray()[0];\n+        assertEquals(QueryProfiler.MIXED_INEX_COUNT_QUERY, nested.getName());\n+        assertTrue(nested.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertEquals(annotations, nested.getAnnotations());\n+    }\n+\n+    /**\n+     * Tests that if a given query can be satisfied by a single mixed index, and it is followed by a count step, then\n+     * a count query will be built\n+     */\n+    @Test\n+    public void testMixedIndexQueryFollowedByCount() {\n+        final int numV = 100;\n+        final String[] strings = {\"Uncle Berry has a farm\", \"and on his farm he has five ducks\", \"ducks are beautiful animals\", \"the sky is very blue today\"};\n+        setupChainGraph(numV, strings, true);\n+        clopen();\n+\n+        /* ===================================================\n+        has(key, value) followed by count() can be optimized */\n+\n+        // vertex\n+        long total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.text:ducks\").vertexTotals());\n+        TraversalMetrics profile = graph.traversal().V().has(\"text\", Text.textContains(\"ducks\")).count().profile().next();\n+        final String xtextKey = \"xtext\";\n+        Map<String, String> annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains ducks)]:vsearch\", xtextKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"text\", Text.textContains(\"ducks\")).count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.text:ducks\").edgeTotals());\n+        profile = graph.traversal().E().has(\"text\", Text.textContains(\"ducks\")).count().profile().next();\n+        final String textKey = getTextField(\"text\");\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains ducks)]:esearch\", textKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().E().has(\"text\", Text.textContains(\"ducks\")).count().next());\n+\n+        /* =====================================================================\n+        has(key, value).has(key', value') followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.text:farm AND v.name:\\\"Uncle Berry has a farm\\\"\").vertexTotals());\n+        profile = graph.traversal().V().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().profile().next();\n+        final String nameKey = getStringField(\"name\");\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains farm AND %s = Uncle Berry has a farm)]:vsearch\", xtextKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().next());\n+\n+        // edge\n+        total = numV / strings.length;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.text:farm AND e.name:\\\"Uncle Berry has a farm\\\"\").edgeTotals());\n+        profile = graph.traversal().E().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains farm AND %s = Uncle Berry has a farm)]:esearch\", textKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().E().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().next());\n+\n+        /* ==============================================================\n+        has(key, P.within(values)) followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.name:(\\\"Uncle Berry has a farm\\\", \\\"ducks are beautiful animals\\\")\").vertexTotals());\n+        profile = graph.traversal().V().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\"))\n+            .count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[((%s = Uncle Berry has a farm OR %s = ducks are beautiful animals))]:vsearch\", nameKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\")).count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.name:(\\\"Uncle Berry has a farm\\\", \\\"ducks are beautiful animals\\\")\").edgeTotals());\n+        profile = graph.traversal().E().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\"))\n+            .count().profile().next();\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().E().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\")).count().next());\n+\n+\n+        /* ==========================================================================\n+        Or(has(key, value1), has(key, value2)) followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.name:(\\\"Uncle Berry has a farm\\\", \\\"and on his farm he has five ducks\\\")\").vertexTotals());\n+        profile = graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[((%s = Uncle Berry has a farm OR %s = and on his farm he has five ducks))]:vsearch\", nameKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.name:(\\\"Uncle Berry has a farm\\\", \\\"and on his farm he has five ducks\\\")\").edgeTotals());\n+        profile = graph.traversal().E().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().profile().next();\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().E().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().next());\n+\n+        /* ==========================================================================\n+        Or(has(key1, value1), has(key2, value2)) followed by count() can be optimized\n+        if both keys are included by a single index */\n+        if (indexFeatures.supportNotQueryNormalForm()) {\n+            total = numV / strings.length * 2;\n+            profile = graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"text\", Text.textContains(\"and on his farm he has five ducks\")))\n+                .count().profile().next();\n+            annotations = new HashMap() {{\n+                put(\"query\", String.format(\"[((%s = Uncle Berry has a farm) OR (%s textContains and on his farm he has five ducks))]:vsearch\", nameKey, xtextKey));\n+            }};\n+            checkMixedIndexCountProfiling(profile, annotations);\n+            assertEquals(total, graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"text\", Text.textContains(\"and on his farm he has five ducks\")))\n+                .count().next());\n+        }\n+\n+        /* ==========================================================================\n+        has(key, neq(value)) followed by count() can be optimized */\n+        total = numV;\n+        profile = graph.traversal().V().has(\"name\", P.neq(\"value\")).count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> value)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.neq(\"value\")).count().next());\n+\n+        profile = graph.traversal().V().has(\"name\", P.neq(null)).count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> null)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.neq(null)).count().next());\n+\n+        /* ==========================================================================\n+        has(key) followed by count() can be optimized */\n+\n+        total = numV;\n+        profile = graph.traversal().V().has(\"name\").count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> null)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\").count().next());\n+\n+        /* ==========================================================================\n+        has(key, value) followed by other steps and then count() cannot be optimized */\n+\n+        total = numV / strings.length;\n+        profile = graph.traversal().V().has(\"name\", \"Uncle Berry has a farm\").out().count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().V().has(\"name\", \"Uncle Berry has a farm\").out().count().next());\n+\n+        /* ==========================================================================\n+        has(key, value) with composite index followed by count() cannot be optimized */\n+\n+        final PropertyKey ageProperty = mgmt.makePropertyKey(\"age\").dataType(Integer.class).make();\n+        mgmt.buildIndex(\"ageidx\", Vertex.class).addKey(ageProperty).buildCompositeIndex();\n+        finishSchema();\n+\n+        for (int i = 0; i < 10; i++) {\n+            tx.addVertex(\"age\", i % 2, \"name\", \"anonymous\");\n+        }\n+        newTx();\n+\n+        profile = graph.traversal().V().has(\"age\", 0).count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(5, graph.traversal().V().has(\"age\", 0).count().next());\n+        profile = graph.traversal().V().has(\"age\").count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(10, graph.traversal().V().has(\"age\").count().next());\n+\n+        /* =============================================================================\n+        count() cannot be optimized if a single mixed index cannot meet all conditions */\n+\n+        assertEquals(10, graph.traversal().V().has(\"name\").has(\"age\").count().next());\n+        profile = graph.traversal().V().has(\"name\").has(\"age\").count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(5, graph.traversal().V().has(\"name\").has(\"age\", 0).count().next());", "originalCommit": "4e317e4e5ac743acf16166cc2c3924cfa87924c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY2MzE0NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r663663145", "bodyText": "Oh, I overlooked that one. Well in this case, just ignore my comment ;)", "author": "rngcntr", "createdAt": "2021-07-05T06:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzY1OTExMA=="}], "type": "inlineReview"}, {"oid": "2f1f9f034bae5e75633fa706a72f9e548dbd52f2", "url": "https://github.com/JanusGraph/janusgraph/commit/2f1f9f034bae5e75633fa706a72f9e548dbd52f2", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-05T14:03:01Z", "type": "forcePushed"}, {"oid": "8566b78f5a9bf4dd85f68f8f6772a7f57030eb0e", "url": "https://github.com/JanusGraph/janusgraph/commit/8566b78f5a9bf4dd85f68f8f6772a7f57030eb0e", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-05T14:05:59Z", "type": "forcePushed"}, {"oid": "e9d2ebf42e98bd11f134858d8444a719e07006d9", "url": "https://github.com/JanusGraph/janusgraph/commit/e9d2ebf42e98bd11f134858d8444a719e07006d9", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-06T01:21:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDI0OTE3Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r664249176", "bodyText": "I don't think this would be the expected behavior for chained V() calls. Instead, V() should spawn a new traverser at every single vertex for each incoming traverser. Thus, for a graph with 100 vertices, g.V().V().count() would return 10.000. With this test however, you seem to verify that the result is 100.\nI suggest to test the correctness by comparing the result of g.[...] to g.withoutStrategies(JanusGraphMixedIndexCountStrategy.class).[...]. That would make sure that under no circumstances the optimization affects the output result. In my opinion, this should even be a considered standard procedure when introducing new optimization strategies. (Not blaming you, I skipped this kind of verification for some of my optimization strategies, too)", "author": "rngcntr", "createdAt": "2021-07-06T05:39:20Z", "path": "janusgraph-backend-testutils/src/main/java/org/janusgraph/graphdb/JanusGraphIndexTest.java", "diffHunk": "@@ -1523,6 +1529,223 @@ public void testIndexParameters() {\n         }\n     }\n \n+    private void checkMixedIndexCountProfiling(TraversalMetrics profile, Map<String, String> annotations) {\n+        Metrics metrics = profile.getMetrics(0);\n+        assertTrue(metrics.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertTrue(metrics.getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        Metrics nested = (Metrics) metrics.getNested().toArray()[0];\n+        assertEquals(QueryProfiler.MIXED_INEX_COUNT_QUERY, nested.getName());\n+        assertTrue(nested.getDuration(TimeUnit.MICROSECONDS) > 0);\n+        assertEquals(annotations, nested.getAnnotations());\n+    }\n+\n+    /**\n+     * Tests that if a given query can be satisfied by a single mixed index, and it is followed by a count step, then\n+     * a count query will be built\n+     */\n+    @Test\n+    public void testMixedIndexQueryFollowedByCount() {\n+        final int numV = 100;\n+        final String[] strings = {\"Uncle Berry has a farm\", \"and on his farm he has five ducks\", \"ducks are beautiful animals\", \"the sky is very blue today\"};\n+        setupChainGraph(numV, strings, true);\n+        clopen();\n+\n+        /* ===================================================\n+        has(key, value) followed by count() can be optimized */\n+\n+        // vertex\n+        long total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.text:ducks\").vertexTotals());\n+        TraversalMetrics profile = graph.traversal().V().has(\"text\", Text.textContains(\"ducks\")).count().profile().next();\n+        final String xtextKey = \"xtext\";\n+        Map<String, String> annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains ducks)]:vsearch\", xtextKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"text\", Text.textContains(\"ducks\")).count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.text:ducks\").edgeTotals());\n+        profile = graph.traversal().E().has(\"text\", Text.textContains(\"ducks\")).count().profile().next();\n+        final String textKey = getTextField(\"text\");\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains ducks)]:esearch\", textKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().E().has(\"text\", Text.textContains(\"ducks\")).count().next());\n+\n+        /* =====================================================================\n+        has(key, value).has(key', value') followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.text:farm AND v.name:\\\"Uncle Berry has a farm\\\"\").vertexTotals());\n+        profile = graph.traversal().V().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().profile().next();\n+        final String nameKey = getStringField(\"name\");\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains farm AND %s = Uncle Berry has a farm)]:vsearch\", xtextKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().next());\n+\n+        // edge\n+        total = numV / strings.length;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.text:farm AND e.name:\\\"Uncle Berry has a farm\\\"\").edgeTotals());\n+        profile = graph.traversal().E().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s textContains farm AND %s = Uncle Berry has a farm)]:esearch\", textKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().E().has(\"text\", Text.textContains(\"farm\"))\n+            .has(\"name\", \"Uncle Berry has a farm\").count().next());\n+\n+        /* ==============================================================\n+        has(key, P.within(values)) followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.name:(\\\"Uncle Berry has a farm\\\", \\\"ducks are beautiful animals\\\")\").vertexTotals());\n+        profile = graph.traversal().V().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\"))\n+            .count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[((%s = Uncle Berry has a farm OR %s = ducks are beautiful animals))]:vsearch\", nameKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\")).count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.name:(\\\"Uncle Berry has a farm\\\", \\\"ducks are beautiful animals\\\")\").edgeTotals());\n+        profile = graph.traversal().E().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\"))\n+            .count().profile().next();\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().E().has(\"name\", P.within(\"Uncle Berry has a farm\", \"ducks are beautiful animals\")).count().next());\n+\n+\n+        /* ==========================================================================\n+        Or(has(key, value1), has(key, value2)) followed by count() can be optimized */\n+\n+        // vertex\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(VINDEX, \"v.name:(\\\"Uncle Berry has a farm\\\", \\\"and on his farm he has five ducks\\\")\").vertexTotals());\n+        profile = graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[((%s = Uncle Berry has a farm OR %s = and on his farm he has five ducks))]:vsearch\", nameKey, nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().next());\n+\n+        // edge\n+        total = numV / strings.length * 2;\n+        assertEquals(total, graph.indexQuery(EINDEX, \"e.name:(\\\"Uncle Berry has a farm\\\", \\\"and on his farm he has five ducks\\\")\").edgeTotals());\n+        profile = graph.traversal().E().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().profile().next();\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().E().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"name\", \"and on his farm he has five ducks\"))\n+            .count().next());\n+\n+        /* ==========================================================================\n+        Or(has(key1, value1), has(key2, value2)) followed by count() can be optimized\n+        if both keys are included by a single index */\n+        if (indexFeatures.supportNotQueryNormalForm()) {\n+            total = numV / strings.length * 2;\n+            profile = graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"text\", Text.textContains(\"and on his farm he has five ducks\")))\n+                .count().profile().next();\n+            annotations = new HashMap() {{\n+                put(\"query\", String.format(\"[((%s = Uncle Berry has a farm) OR (%s textContains and on his farm he has five ducks))]:vsearch\", nameKey, xtextKey));\n+            }};\n+            checkMixedIndexCountProfiling(profile, annotations);\n+            assertEquals(total, graph.traversal().V().or(__.has(\"name\", \"Uncle Berry has a farm\"), __.has(\"text\", Text.textContains(\"and on his farm he has five ducks\")))\n+                .count().next());\n+        }\n+\n+        /* ==========================================================================\n+        has(key, neq(value)) followed by count() can be optimized */\n+        total = numV;\n+        profile = graph.traversal().V().has(\"name\", P.neq(\"value\")).count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> value)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.neq(\"value\")).count().next());\n+\n+        profile = graph.traversal().V().has(\"name\", P.neq(null)).count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> null)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\", P.neq(null)).count().next());\n+\n+        /* ==========================================================================\n+        has(key) followed by count() can be optimized */\n+\n+        total = numV;\n+        profile = graph.traversal().V().has(\"name\").count().profile().next();\n+        annotations = new HashMap() {{\n+            put(\"query\", String.format(\"[(%s <> null)]:vsearch\", nameKey));\n+        }};\n+        checkMixedIndexCountProfiling(profile, annotations);\n+        assertEquals(total, graph.traversal().V().has(\"name\").count().next());\n+\n+        /* ==========================================================================\n+        has(key, value) followed by other steps and then count() cannot be optimized */\n+\n+        total = numV / strings.length;\n+        profile = graph.traversal().V().has(\"name\", \"Uncle Berry has a farm\").out().count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(total, graph.traversal().V().has(\"name\", \"Uncle Berry has a farm\").out().count().next());\n+\n+        /* ==========================================================================\n+        has(key, value) with composite index followed by count() cannot be optimized */\n+\n+        final PropertyKey ageProperty = mgmt.makePropertyKey(\"age\").dataType(Integer.class).make();\n+        mgmt.buildIndex(\"ageidx\", Vertex.class).addKey(ageProperty).buildCompositeIndex();\n+        finishSchema();\n+\n+        for (int i = 0; i < 10; i++) {\n+            tx.addVertex(\"age\", i % 2, \"name\", \"anonymous\");\n+        }\n+        newTx();\n+\n+        profile = graph.traversal().V().has(\"age\", 0).count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(5, graph.traversal().V().has(\"age\", 0).count().next());\n+        profile = graph.traversal().V().has(\"age\").count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertTrue(profile.getMetrics(0).getName().contains(JanusGraphStep.class.getSimpleName()));\n+        assertEquals(10, graph.traversal().V().has(\"age\").count().next());\n+\n+        /* =============================================================================\n+        count() cannot be optimized if a single mixed index cannot meet all conditions */\n+\n+        assertEquals(10, graph.traversal().V().has(\"name\").has(\"age\").count().next());\n+        profile = graph.traversal().V().has(\"name\").has(\"age\").count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        assertEquals(5, graph.traversal().V().has(\"name\").has(\"age\", 0).count().next());\n+        profile = graph.traversal().V().has(\"name\").has(\"age\", 0).count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+        profile = graph.traversal().V().has(\"age\").has(\"name\").count().profile().next();\n+        assertFalse(profile.getMetrics(0).getName().contains(JanusGraphMixedIndexCountStep.class.getSimpleName()));\n+\n+        /* ==========================\n+        verify other special cases */\n+\n+        assertEquals(1, graph.traversal().V().has(\"name\").count().count().next());\n+        assertEquals(numV, graph.traversal().V().V().has(\"text\").count().next());", "originalCommit": "e9d2ebf42e98bd11f134858d8444a719e07006d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDI1NTYwOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r664255609", "bodyText": "Great catch! I'll fix this.", "author": "li-boxuan", "createdAt": "2021-07-06T05:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDI0OTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDUwODI3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r664508273", "bodyText": "Now if JanusGraphStep is not the start step, JanusGraphMixedIndexCountStrategy won't be applied.", "author": "li-boxuan", "createdAt": "2021-07-06T12:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDI0OTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDUyOTMwOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2200#discussion_r664529309", "bodyText": "That looks much better, thank you @li-boxuan", "author": "rngcntr", "createdAt": "2021-07-06T12:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDI0OTE3Ng=="}], "type": "inlineReview"}, {"oid": "a2f8e9fd52eb2744de0bac35e85ca4f93f62341c", "url": "https://github.com/JanusGraph/janusgraph/commit/a2f8e9fd52eb2744de0bac35e85ca4f93f62341c", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-06T09:16:58Z", "type": "commit"}, {"oid": "a2f8e9fd52eb2744de0bac35e85ca4f93f62341c", "url": "https://github.com/JanusGraph/janusgraph/commit/a2f8e9fd52eb2744de0bac35e85ca4f93f62341c", "message": "Add strategy that optimizes mixed index lookup followed by count step\n\nThis adds JanusGraphMixedIndexCountStrategy which leverages mixed index\nto return the total count if applicable. The implementation idea is to\nleverage the partial result of JanusGraphStepStrategy and JanusGraphStep\nwhich handle folding and building a global graph centric query.\n\nCloses #874\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2021-07-06T09:16:58Z", "type": "forcePushed"}]}