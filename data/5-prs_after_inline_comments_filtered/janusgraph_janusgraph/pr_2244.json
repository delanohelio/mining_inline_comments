{"pr_number": 2244, "pr_title": "Bug fixes: relations cannot be removed after update", "pr_createdAt": "2020-11-01T10:13:30Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2244", "timeline": [{"oid": "d786c0c3ec0c0e8f138d0f62ff0d4a27efb15c7a", "url": "https://github.com/JanusGraph/janusgraph/commit/d786c0c3ec0c0e8f138d0f62ff0d4a27efb15c7a", "message": "Bug fixes: relations cannot be removed after update\n\nThis commit includes fixes for three bugs:\n\n1) Caused by the optimization in StandardJanusGraphTx::addProperty, which saves a database\nread (and delete) operation for vertex property upsert. If a vertex property (or the vertex\nas a whole) is removed after the property is modified in the same transaction, then the old\nvalue in database will not be deleted after the transaction commits. Reported by #1981.\n\n2) Caused by CacheVertexProperty::remove method which does nothing if it finds the given\nvertex property is already in the deletedRelations map. If the user deletes a vertex property\nafter they update a nested property of that vertex property in the same transaction, then\nthe old value will be removed from database but the new value will be saved into database\nafter the transaction commits.\n\n3) Caused by CacheEdge::remove method which does nothing if it finds the given edge is\nalready in the deletedRelations map. If the user deletes an edge after they update a property\nof that edge in the same transaction, then the old value will be removed from database but the\nnew value will be saved into database after the transaction commits.\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-11-08T13:44:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQwMzc0NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r519403744", "bodyText": "This is just a variable renaming as the old name does not make much sense.", "author": "li-boxuan", "createdAt": "2020-11-08T13:46:15Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/relations/CacheEdge.java", "diffHunk": "@@ -62,10 +62,10 @@ public InternalRelation it() {\n         if (startVertex.hasAddedRelations() && startVertex.hasRemovedRelations()) {\n             //Test whether this relation has been replaced\n             final long id = super.longId();\n-            final Iterable<InternalRelation> previous = startVertex.getAddedRelations(\n+            final Iterable<InternalRelation> added = startVertex.getAddedRelations(", "originalCommit": "d786c0c3ec0c0e8f138d0f62ff0d4a27efb15c7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQwNTIzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r519405237", "bodyText": "This is bug fix (3):\n\nIf the user deletes an edge after they update a property of that edge in the same transaction, then the old value will be removed from database but the new value will be saved into database after the transaction commits.\n\nThis is because after they update the property, the old edge will be marked as deleted in the deletedRelations map. Afterward, when they trigger an edge delete operation, JanusGraph wrongly finds the edge was already marked as \"deleted\" and simply ignores.\nCorresponding tests:\n\ntestUpdateEdgePropertyThenRemoveEdge\ntestUpdateForkEdgePropertyThenRemoveEdge", "author": "li-boxuan", "createdAt": "2020-11-08T13:51:48Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/relations/CacheEdge.java", "diffHunk": "@@ -139,7 +138,7 @@ public byte getLifeCycle() {\n \n     @Override\n     public void remove() {\n-        if (!tx().isRemovedRelation(super.longId())) {\n+        if (!isRemoved()) {", "originalCommit": "d786c0c3ec0c0e8f138d0f62ff0d4a27efb15c7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQwNTU5Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r519405597", "bodyText": "This is bug fix (2):\n\nIf the user deletes a vertex property after they update a nested property of that vertex property in the same transaction, then the old value will be removed from database but the new value will be saved into database after the transaction commits.\n\nThis is because after they update the nested property (property of a property), the old vertex property will be marked as deleted in the deletedRelations map. Afterward, when they trigger a vertex property delete operation, JanusGraph wrongly finds the vertex property was already marked as \"deleted\" and simply ignores.\nCorresponding test:\n\ntestUpdatePropertyPropThenRemovePropertyProp\ntestUpdatePropertyPropThenRemoveProperty", "author": "li-boxuan", "createdAt": "2020-11-08T13:53:10Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/relations/CacheVertexProperty.java", "diffHunk": "@@ -121,7 +121,7 @@ public byte getLifeCycle() {\n \n     @Override\n     public void remove() {\n-        if (!tx().isRemovedRelation(longId())) {\n+        if (!isRemoved()) {", "originalCommit": "d786c0c3ec0c0e8f138d0f62ff0d4a27efb15c7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTQwNjMxNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r519406314", "bodyText": "This, together with changes in StandardJanusGraphTx.java, is to fix bug (1):\n\nCaused by the optimization in StandardJanusGraphTx::addProperty, which saves a database read (and delete) operation for vertex property upsert. If a vertex property (or the vertex as a whole) is removed after the property is modified in the same transaction, then the old value in database will not be deleted after the transaction commits. Reported by #1981.\n\nThe idea is to defer the delete operation until an explicit removal operation is fired. To achieve so, we mark the new vertex property as \"upsert\" so that we know we haven't removed the old value yet.\nCorresponding test cases:\n\ntestUpdateVertexPropThenRemoveProp\ntestUpdateVertexPropThenRemoveVertex", "author": "li-boxuan", "createdAt": "2020-11-08T13:56:00Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/relations/StandardVertexProperty.java", "diffHunk": "@@ -101,6 +114,11 @@ public synchronized void remove() {\n         if (!ElementLifeCycle.isRemoved(lifecycle)) {\n             tx().removeRelation(this);\n             lifecycle = ElementLifeCycle.update(lifecycle, ElementLifeCycle.Event.REMOVED);\n+            if (isUpsert) {", "originalCommit": "d786c0c3ec0c0e8f138d0f62ff0d4a27efb15c7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eced709bef5ac83c6b9f10321202af2790d8a3f8", "url": "https://github.com/JanusGraph/janusgraph/commit/eced709bef5ac83c6b9f10321202af2790d8a3f8", "message": "Bug fixes: relations cannot be removed after update\n\nThis commit includes fixes for three bugs:\n\n1) Caused by the optimization in StandardJanusGraphTx::addProperty, which saves a database\nread (and delete) operation for vertex property upsert. If a vertex property (or the vertex\nas a whole) is removed after the property is modified in the same transaction, then the old\nvalue in database will not be deleted after the transaction commits. Reported by #1981.\n\n2) Caused by CacheVertexProperty::remove method which does nothing if it finds the given\nvertex property is already in the deletedRelations map. If the user deletes a vertex property\nafter they update a nested property of that vertex property in the same transaction, then\nthe old value will be removed from database but the new value will be saved into database\nafter the transaction commits.\n\n3) Caused by CacheEdge::remove method which does nothing if it finds the given edge is\nalready in the deletedRelations map. If the user deletes an edge after they update a property\nof that edge in the same transaction, then the old value will be removed from database but the\nnew value will be saved into database after the transaction commits.\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-11-09T15:44:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxNjk1NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r520016954", "bodyText": "I don't know much about how lambda are compiled but if it is changed to new Consumer<JanusGraphVertexProperty> {....} shouldn't this consumer be static? I don't think we need to create a new instance of this consumer because it doesn't reuse any other parameters.\nI.e., I think it would be better to create a static consumer like:\nprivate static final Consumer<JanusGraphVertexProperty> SINGLE_PROPERTY_REMOVER_CONSUMER = JanusGraphElement::remove; \n\nand reuse SINGLE_PROPERTY_REMOVER_CONSUMER here. That said, if you know that JanusGraphElement::remove will be compiled to static consumer, I'm totally good with it.", "author": "porunov", "createdAt": "2020-11-09T18:11:35Z", "path": "janusgraph-core/src/main/java/org/janusgraph/core/JanusGraphVertexProperty.java", "diffHunk": "@@ -45,4 +47,16 @@ default PropertyKey propertyKey() {\n         return (PropertyKey)getType();\n     }\n \n+    static Consumer<JanusGraphVertexProperty> getRemover(VertexProperty.Cardinality cardinality, Object value) {\n+        if (cardinality == VertexProperty.Cardinality.single) {\n+            return JanusGraphElement::remove;", "originalCommit": "eced709bef5ac83c6b9f10321202af2790d8a3f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY5OTk4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r520699986", "bodyText": "Looks like it is compiled to static consumer:\nboolean sameObject = false;\nConsumer<JanusGraphVertexProperty> c1 = null;\nfor (int i = 0; i < 2; i++) {\n    Consumer<JanusGraphVertexProperty> c2 = new Consumer<JanusGraphVertexProperty>() {\n        @Override\n        public void accept(JanusGraphVertexProperty p) {\n            p.remove();\n        }\n    };\n    if (c1 == null) c1 = c2;\n    else sameObject = c1 == c2; // false\n}\nwhen using method reference or lambda function, result is different:\nboolean sameObject = false;\nConsumer<JanusGraphVertexProperty> c1 = null;\nfor (int i = 0; i < 2; i++) {\n    Consumer<JanusGraphVertexProperty> c2 = JanusGraphElement::remove;\n    if (c1 == null) c1 = c2;\n    else sameObject = c1 == c2; // true\n}\nExample modified from https://stackoverflow.com/questions/23983832/is-method-reference-caching-a-good-idea-in-java-8/23991339#23991339", "author": "li-boxuan", "createdAt": "2020-11-10T16:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxNjk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2OTIzOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r521569239", "bodyText": "Thank you for checking that!", "author": "porunov", "createdAt": "2020-11-11T18:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxNjk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5NjkwNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r521596907", "bodyText": "Just thinking. Do you know if we need to set upsert to true when a property is new? I.e. ElementLifeCycle.isNew(prop.getLifeCycle())?\nI guess, in case we don't set upsert to true when the property is New we may have a problem when we are adding the property in Transaction-1, adding the property in Transaction-2, committing Transaction-1, removing the property in Transaction-2, committing Transaction-2. In such case, I guess we will not check the property from Database in Transaction-2 and thus, we will not remove the property which was committed in Transaction-1.\nThat said, I'm not sure about it and not sure if we need to worry about this use-case at all, so I decided to ask your thoughts.", "author": "porunov", "createdAt": "2020-11-11T19:44:17Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/StandardJanusGraphTx.java", "diffHunk": "@@ -816,7 +815,10 @@ public JanusGraphVertexProperty addProperty(VertexProperty.Cardinality cardinali\n                 if ( (!config.hasVerifyUniqueness() || ((InternalRelationType)key).getConsistencyModifier()!=ConsistencyModifier.LOCK) &&\n                         !TypeUtil.hasAnyIndex(key) && cardinality==keyCardinality.convert()) {\n                     //Only delete in-memory so as to not trigger a read from the database which isn't necessary because we will overwrite blindly\n-                    ((InternalVertex) vertex).getAddedRelations(p -> p.getType().equals(key)).forEach(propertyRemover);\n+                    //We need to label the new property as \"upsert\", so that in case property deletion happens, we not only delete this new\n+                    //in-memory property, but also read from database to delete the old value (if exists)\n+                    ((InternalVertex) vertex).getAddedRelations(p -> p.getType().equals(key)).forEach(p -> propertyRemover.accept((JanusGraphVertexProperty) p));\n+                    prop.setUpsert(true);", "originalCommit": "eced709bef5ac83c6b9f10321202af2790d8a3f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4MDgwMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r522180800", "bodyText": "A property is always \"new\" when you update its value. You cannot directly set a value to a property object; instead, you can only attach a key-value pair to a vertex object, i.e. v.property(\"key\", \"value\").\nThus, the prop here is defined by:\nStandardVertexProperty prop = new StandardVertexProperty(propId, key, (InternalVertex) vertex, normalizedValue, ElementLifeCycle.New); which is always \"new\".\nI believe the scenario you mentioned is already handled as part of this PR, but I am adding a test case to be sure.", "author": "li-boxuan", "createdAt": "2020-11-12T15:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5NjkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwNTE2Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r521605163", "bodyText": "Why did you move this logic from bottom to up?", "author": "porunov", "createdAt": "2020-11-11T20:00:18Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/transaction/StandardJanusGraphTx.java", "diffHunk": "@@ -798,14 +798,13 @@ public JanusGraphVertexProperty addProperty(VertexProperty.Cardinality cardinali\n //                }\n //            }\n \n+            long propId = id == null ? IDManager.getTemporaryRelationID(temporaryIds.nextID()) : id;\n+            StandardVertexProperty prop = new StandardVertexProperty(propId, key, (InternalVertex) vertex, normalizedValue, ElementLifeCycle.New);\n+            if (config.hasAssignIDsImmediately() && id == null) graph.assignID(prop);\n+", "originalCommit": "eced709bef5ac83c6b9f10321202af2790d8a3f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE4MTg1NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r522181855", "bodyText": "Because we need to set prop.setUpsert(true); later.\nIf you are talking about if (config.hasAssignIDsImmediately() && id == null) graph.assignID(prop); this line only, then there is no specific reason. I just feel it doesn't make much difference and it's probably better to put close logic in the near place.", "author": "li-boxuan", "createdAt": "2020-11-12T15:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwNTE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMzg0NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2244#discussion_r521613845", "bodyText": "I'm good with getVertex(0) but maybe it's better to use element()?", "author": "porunov", "createdAt": "2020-11-11T20:17:28Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/relations/StandardVertexProperty.java", "diffHunk": "@@ -101,6 +114,11 @@ public synchronized void remove() {\n         if (!ElementLifeCycle.isRemoved(lifecycle)) {\n             tx().removeRelation(this);\n             lifecycle = ElementLifeCycle.update(lifecycle, ElementLifeCycle.Event.REMOVED);\n+            if (isUpsert) {\n+                VertexProperty.Cardinality cardinality = ((PropertyKey) type).cardinality().convert();\n+                Consumer<JanusGraphVertexProperty> propertyRemover = JanusGraphVertexProperty.getRemover(cardinality, value());\n+                getVertex(0).query().types(type.name()).properties().forEach(propertyRemover);", "originalCommit": "eced709bef5ac83c6b9f10321202af2790d8a3f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "96bdde59bd4cbadd79c085685036b72097f3fe44", "url": "https://github.com/JanusGraph/janusgraph/commit/96bdde59bd4cbadd79c085685036b72097f3fe44", "message": "Bug fixes: relations cannot be removed after update\n\nThis commit includes fixes for three bugs:\n\n1) Caused by the optimization in StandardJanusGraphTx::addProperty, which saves a database\nread (and delete) operation for vertex property upsert. If a vertex property (or the vertex\nas a whole) is removed after the property is modified in the same transaction, then the old\nvalue in database will not be deleted after the transaction commits. Reported by #1981.\n\n2) Caused by CacheVertexProperty::remove method which does nothing if it finds the given\nvertex property is already in the deletedRelations map. If the user deletes a vertex property\nafter they update a nested property of that vertex property in the same transaction, then\nthe old value will be removed from database but the new value will be saved into database\nafter the transaction commits.\n\n3) Caused by CacheEdge::remove method which does nothing if it finds the given edge is\nalready in the deletedRelations map. If the user deletes an edge after they update a property\nof that edge in the same transaction, then the old value will be removed from database but the\nnew value will be saved into database after the transaction commits.\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-11-12T15:17:23Z", "type": "commit"}, {"oid": "96bdde59bd4cbadd79c085685036b72097f3fe44", "url": "https://github.com/JanusGraph/janusgraph/commit/96bdde59bd4cbadd79c085685036b72097f3fe44", "message": "Bug fixes: relations cannot be removed after update\n\nThis commit includes fixes for three bugs:\n\n1) Caused by the optimization in StandardJanusGraphTx::addProperty, which saves a database\nread (and delete) operation for vertex property upsert. If a vertex property (or the vertex\nas a whole) is removed after the property is modified in the same transaction, then the old\nvalue in database will not be deleted after the transaction commits. Reported by #1981.\n\n2) Caused by CacheVertexProperty::remove method which does nothing if it finds the given\nvertex property is already in the deletedRelations map. If the user deletes a vertex property\nafter they update a nested property of that vertex property in the same transaction, then\nthe old value will be removed from database but the new value will be saved into database\nafter the transaction commits.\n\n3) Caused by CacheEdge::remove method which does nothing if it finds the given edge is\nalready in the deletedRelations map. If the user deletes an edge after they update a property\nof that edge in the same transaction, then the old value will be removed from database but the\nnew value will be saved into database after the transaction commits.\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-11-12T15:17:23Z", "type": "forcePushed"}]}