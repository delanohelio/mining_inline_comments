{"pr_number": 2643, "pr_title": "[java] AvoidCallingFinalize detects some false positives (2578)", "pr_createdAt": "2020-07-15T13:19:35Z", "pr_url": "https://github.com/pmd/pmd/pull/2643", "timeline": [{"oid": "5a6e3d609e6f0e87736ef339627a80305d841195", "url": "https://github.com/pmd/pmd/commit/5a6e3d609e6f0e87736ef339627a80305d841195", "message": "[java]AvoidCallingFinalize detects some false positives (2578)", "committedDate": "2020-07-15T12:44:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1MDkzMQ==", "url": "https://github.com/pmd/pmd/pull/2643#discussion_r455250931", "bodyText": "I'm unsure this is actually right\u2026 getArgumentCount returns -1 if the suffix is not actually a method call if I recall correctly\u2026 this would interpret it as an actual no-arg invocation\u2026", "author": "jsotuyod", "createdAt": "2020-07-15T18:19:41Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCallingFinalizeRule.java", "diffHunk": "@@ -4,68 +4,100 @@\n \n package net.sourceforge.pmd.lang.java.rule.errorprone;\n \n-import java.util.HashSet;\n+import static java.lang.Math.max;\n+\n import java.util.List;\n-import java.util.Set;\n+import java.util.regex.Pattern;\n \n-import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\n-import net.sourceforge.pmd.lang.java.ast.ASTName;\n+import net.sourceforge.pmd.lang.java.ast.ASTBlock;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n-import net.sourceforge.pmd.lang.java.symboltable.MethodScope;\n-import net.sourceforge.pmd.lang.symboltable.ScopedNode;\n \n public class AvoidCallingFinalizeRule extends AbstractJavaRule {\n \n-    private Set<MethodScope> checked = new HashSet<>();\n+    private static final Pattern FINALIZE_METHOD_PATTERN = Pattern.compile(\"^(.+\\\\.)?finalize$\");\n \n     @Override\n-    public Object visit(ASTCompilationUnit acu, Object ctx) {\n-        checked.clear();\n-        return super.visit(acu, ctx);\n+    public Object visit(ASTBlock block, Object data) {\n+        if (hasFinalizeMethodCallViolation(block)) {\n+            addViolation(data, block);\n+        }\n+        return super.visit(block, data);\n     }\n \n-    @Override\n-    public Object visit(ASTName name, Object ctx) {\n-        if (name.getImage() == null || !name.getImage().endsWith(\"finalize\")) {\n-            return ctx;\n+    private boolean hasFinalizeMethodCallViolation(ASTBlock block) {\n+        if (isFinalizeMethodBlock(block)) {\n+            return callsNotSuperFinalizeMethod(block);\n         }\n-        if (!checkForViolation(name)) {\n-            return ctx;\n-        }\n-        addViolation(ctx, name);\n-        return ctx;\n+        return callsFinalizeMethod(block);\n     }\n \n-    @Override\n-    public Object visit(ASTPrimaryPrefix pp, Object ctx) {\n-        List<ASTPrimarySuffix> primarySuffixes = pp.getParent().findChildrenOfType(ASTPrimarySuffix.class);\n-        ASTPrimarySuffix firstSuffix = null;\n-        if (!primarySuffixes.isEmpty()) {\n-            firstSuffix = primarySuffixes.get(0);\n-        }\n-        if (firstSuffix == null || firstSuffix.getImage() == null || !firstSuffix.getImage().endsWith(\"finalize\")) {\n-            return super.visit(pp, ctx);\n-        }\n-        if (!checkForViolation(pp)) {\n-            return super.visit(pp, ctx);\n+    private boolean isFinalizeMethodBlock(ASTBlock block) {\n+        ASTMethodDeclaration methodDeclaration = block.getFirstParentOfType(ASTMethodDeclaration.class);\n+        return methodDeclaration != null && isFinalizeMethodDeclaration(methodDeclaration);\n+    }\n+\n+    private boolean isFinalizeMethodDeclaration(ASTMethodDeclaration methodDeclaration) {\n+        return \"finalize\".equals(methodDeclaration.getName()) && methodDeclaration.getArity() == 0;\n+    }\n+\n+    private boolean callsNotSuperFinalizeMethod(ASTBlock block) {\n+        List<ASTPrimaryExpression> primaryExpressions = block.findDescendantsOfType(ASTPrimaryExpression.class);\n+        for (ASTPrimaryExpression primaryExpression : primaryExpressions) {\n+            if (isNotSuperFinalizeMethodCall(primaryExpression)) {\n+                return true;\n+            }\n         }\n-        addViolation(ctx, pp);\n-        return super.visit(pp, ctx);\n+        return false;\n     }\n \n-    private boolean checkForViolation(ScopedNode node) {\n-        MethodScope meth = node.getScope().getEnclosingScope(MethodScope.class);\n-        if (meth != null && \"finalize\".equals(meth.getName())) {\n-            return false;\n+    private boolean isNotSuperFinalizeMethodCall(ASTPrimaryExpression primaryExpression) {\n+        return isFinalizeMethodCall(primaryExpression) && isNotSuperMethodCall(primaryExpression);\n+    }\n+\n+    private boolean isNotSuperMethodCall(ASTPrimaryExpression primaryExpression) {\n+        ASTPrimaryPrefix primaryPrefix = primaryExpression.getFirstChildOfType(ASTPrimaryPrefix.class);\n+        return primaryPrefix == null || !primaryPrefix.usesSuperModifier();\n+    }\n+\n+    private boolean callsFinalizeMethod(ASTBlock block) {\n+        List<ASTPrimaryExpression> primaryExpressions = block.findDescendantsOfType(ASTPrimaryExpression.class);\n+        for (ASTPrimaryExpression primaryExpression : primaryExpressions) {\n+            if (isFinalizeMethodCall(primaryExpression)) {\n+                return true;\n+            }\n         }\n-        if (meth != null && checked.contains(meth)) {\n-            return false;\n+        return false;\n+    }\n+\n+    private boolean isFinalizeMethodCall(ASTPrimaryExpression primaryExpression) {\n+        return hasFinalizeName(primaryExpression) && getArgsCount(primaryExpression) == 0;\n+    }\n+\n+    private boolean hasFinalizeName(ASTPrimaryExpression primaryExpression) {\n+        List<JavaNode> expressionNodes = primaryExpression.findDescendantsOfType(JavaNode.class);\n+        for (JavaNode expressionNode : expressionNodes) {\n+            if (isFinalizeName(expressionNode.getImage())) {\n+                return true;\n+            }\n         }\n-        if (meth != null) {\n-            checked.add(meth);\n+        return false;\n+    }\n+\n+    private boolean isFinalizeName(String name) {\n+        return name != null && FINALIZE_METHOD_PATTERN.matcher(name).find();\n+    }\n+\n+    private int getArgsCount(ASTPrimaryExpression primaryExpression) {\n+        ASTPrimarySuffix primarySuffix = primaryExpression.getFirstChildOfType(ASTPrimarySuffix.class);\n+        if (primarySuffix != null) {\n+            int argsCount = primarySuffix.getArgumentCount();\n+            return max(argsCount, 0);", "originalCommit": "5a6e3d609e6f0e87736ef339627a80305d841195", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2eedff056cf863f51685f676186f45a0558a73d1", "url": "https://github.com/pmd/pmd/commit/2eedff056cf863f51685f676186f45a0558a73d1", "message": "AvoidCallingFinalize: addViolation, getArgsCount fix", "committedDate": "2020-07-16T08:55:09Z", "type": "commit"}, {"oid": "9bbb6aab4d25d0c2abc3a7928856f6a330ab4785", "url": "https://github.com/pmd/pmd/commit/9bbb6aab4d25d0c2abc3a7928856f6a330ab4785", "message": "AvoidCallingFinalize: constructor false negative fix", "committedDate": "2020-07-16T16:21:22Z", "type": "commit"}, {"oid": "01e48c882bbebef713f204be6e16f72901e08b52", "url": "https://github.com/pmd/pmd/commit/01e48c882bbebef713f204be6e16f72901e08b52", "message": "AvoidCallingFinalize: expected lines added to test", "committedDate": "2020-07-17T08:05:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYwMTk2NQ==", "url": "https://github.com/pmd/pmd/pull/2643#discussion_r456601965", "bodyText": "To be fully correct, we need to call here either super or need to use the rule chain. A primary expression could define a anonymous class, which in turn could have primary expressions which call the finalize method....", "author": "adangel", "createdAt": "2020-07-17T18:18:27Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/errorprone/AvoidCallingFinalizeRule.java", "diffHunk": "@@ -4,68 +4,75 @@\n \n package net.sourceforge.pmd.lang.java.rule.errorprone;\n \n-import java.util.HashSet;\n import java.util.List;\n-import java.util.Set;\n+import java.util.regex.Pattern;\n \n-import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\n-import net.sourceforge.pmd.lang.java.ast.ASTName;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n-import net.sourceforge.pmd.lang.java.symboltable.MethodScope;\n-import net.sourceforge.pmd.lang.symboltable.ScopedNode;\n \n public class AvoidCallingFinalizeRule extends AbstractJavaRule {\n \n-    private Set<MethodScope> checked = new HashSet<>();\n+    private static final Pattern FINALIZE_METHOD_PATTERN = Pattern.compile(\"^(.+\\\\.)?finalize$\");\n \n     @Override\n-    public Object visit(ASTCompilationUnit acu, Object ctx) {\n-        checked.clear();\n-        return super.visit(acu, ctx);\n+    public Object visit(ASTPrimaryExpression primaryExpression, Object data) {\n+        if (isIncorrectFinalizeMethodCall(primaryExpression)) {\n+            addViolation(data, primaryExpression);\n+        }\n+        return data;", "originalCommit": "01e48c882bbebef713f204be6e16f72901e08b52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}