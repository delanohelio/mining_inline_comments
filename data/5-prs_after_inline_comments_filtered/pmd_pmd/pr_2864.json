{"pr_number": 2864, "pr_title": "[vf] Provide expression type information to Visualforce rules to avoid false positives", "pr_createdAt": "2020-10-22T18:56:42Z", "pr_url": "https://github.com/pmd/pmd/pull/2864", "timeline": [{"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32", "url": "https://github.com/pmd/pmd/commit/ddf55c7f8115ba79a597cabfd1e629ac3822df32", "message": "Provide type information to Visualforce rules\n\nAddresses the general issue raised in https://github.com/pmd/pmd/issues/1092 This commit removes false positives from expressions in apex tags. The specific use case raised in 1092 isn't reproducible and represents a false negative that will be fixed separately.\n\nThe existing Visualforce rules don't have any information about the data types referenced in the Visualforce page. This results in false positives when attempting to identify expressions that are vulnerable to XSS attacks. The rules should not warn about XSS attacks when the expression refers to a type such as Integer or Boolean.\n\nThe VfExpressionTypeVisitor visits the Visualforce page and extracts the datatypes from Salesforce metadata. Data type information can come from either Apex classes or Object Fields. The Salesforce metadata is generally located in a sibling directory of the Visualforce directory. By default the code looks in directories relative to the Visualforce file to find the metadata. The conventional locations for the metadata are \"../classes\" and \"../objects\", the user can override this default with other directories if required.", "committedDate": "2020-10-22T18:30:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4ODUwNQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510388505", "bodyText": "This should be abstract, I will fix.", "author": "jbartolotta-sfdc", "createdAt": "2020-10-22T18:58:54Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/AbstractVfTypedElExpressionRule.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.rule.security;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.vf.ExpressionType;\n+import net.sourceforge.pmd.lang.vf.VfExpressionTypeVisitor;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.rule.AbstractVfRule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+/**\n+ * Represents a rule where the {@link net.sourceforge.pmd.lang.vf.ast.ASTIdentifier} nodes are enhanced with the\n+ * node's {@link ExpressionType}. This is achieved by processing metadata files referenced by the Visualforce page.\n+ */\n+class AbstractVfTypedElExpressionRule extends AbstractVfRule {", "originalCommit": "ddf55c7f8115ba79a597cabfd1e629ac3822df32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4OTA4OQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510389089", "bodyText": "This is the code that fixes the false positives for this rule.", "author": "jbartolotta-sfdc", "createdAt": "2020-10-22T18:59:46Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/VfUnescapeElRule.java", "diffHunk": "@@ -412,6 +411,11 @@ private boolean doesElContainAnyUnescapedIdentifiers(final ASTElExpression elExp\n             final List<ASTIdentifier> ids = expr.findChildrenOfType(ASTIdentifier.class);\n \n             for (final ASTIdentifier id : ids) {\n+                ExpressionType expressionType = getExpressionType(id);", "originalCommit": "ddf55c7f8115ba79a597cabfd1e629ac3822df32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MDg4NQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510390885", "bodyText": "Added methods that run rules against files found in the test/resources/ directory. I didn't add the runRule method to the base class because the use case is very specific to this change and I didn't want to confuse others that might be writing rule tests.", "author": "jbartolotta-sfdc", "createdAt": "2020-10-22T19:02:53Z", "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/rule/security/VfUnescapeElTest.java", "diffHunk": "@@ -4,8 +4,162 @@\n \n package net.sourceforge.pmd.lang.vf.rule.security;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.PMD;\n+import net.sourceforge.pmd.PMDException;\n+import net.sourceforge.pmd.Report;\n+import net.sourceforge.pmd.Rule;\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.RuleSet;\n+import net.sourceforge.pmd.RuleSets;\n+import net.sourceforge.pmd.RuleViolation;\n+import net.sourceforge.pmd.RulesetsFactoryUtils;\n+import net.sourceforge.pmd.lang.LanguageRegistry;\n+import net.sourceforge.pmd.lang.LanguageVersion;\n+import net.sourceforge.pmd.lang.Parser;\n+import net.sourceforge.pmd.lang.ParserOptions;\n+import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.vf.VFTestContstants;\n+import net.sourceforge.pmd.lang.vf.VfLanguageModule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n import net.sourceforge.pmd.testframework.PmdRuleTst;\n \n public class VfUnescapeElTest extends PmdRuleTst {\n-    // no additional unit tests\n+    public static final String EXPECTED_RULE_MESSAGE = \"Avoid unescaped user controlled content in EL\";", "originalCommit": "ddf55c7f8115ba79a597cabfd1e629ac3822df32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ef9e350fd53e3f6f00da34659ec8433ce398f9b6", "url": "https://github.com/pmd/pmd/commit/ef9e350fd53e3f6f00da34659ec8433ce398f9b6", "message": "Mark AbstractVfTypedElExpressionRule as abstract", "committedDate": "2020-10-22T19:11:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyNjMzMA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510526330", "bodyText": "It occurs to me that this should be renamed to IdentifierType. I will rename it.", "author": "jbartolotta-sfdc", "createdAt": "2020-10-23T00:06:02Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ExpressionType.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Represents all data types that can be referenced from a Visualforce page. This enum consolidates the data types\n+ * available to CustomFields and Apex. It uses the naming convention of CustomFields.\n+ *\n+ * See https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_field_types.htm#meta_type_fieldtype\n+ */\n+public enum ExpressionType {", "originalCommit": "ef9e350fd53e3f6f00da34659ec8433ce398f9b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "url": "https://github.com/pmd/pmd/commit/f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "message": "Rename ExpressionType, remove google collections\n\nRenamed ExpressionType to IdentifierType since this is more accurate.\n\nRemoved usage of google.collect classes that were causing UnsupportedClassVersionError exception in the Travis CI run.", "committedDate": "2020-10-27T23:23:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMTMwMw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513421303", "bodyText": "VfExpressionTypeVisitor and this class are the API for custom rule implementers to use this new feature in own rules.\nBecause of that, I think, this abstract class will need to be public as well.\nOr the other way round: If we want to hide this feature a little for the beginning, we need to annotate VfExpressionTypeVisitor as @Experimental.\nI'm not sure, whether we should provide this as an abstract class and force using it through inheritance, which limits what the custom rule can inherit itself... (e.g. you cannot use this feature with an own rule inheritance hierarchy...).\nMaybe we can find an alternative way.", "author": "adangel", "createdAt": "2020-10-28T12:59:24Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/AbstractVfTypedElExpressionRule.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.rule.security;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.vf.IdentifierType;\n+import net.sourceforge.pmd.lang.vf.VfExpressionTypeVisitor;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.rule.AbstractVfRule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+/**\n+ * Represents a rule where the {@link net.sourceforge.pmd.lang.vf.ast.ASTIdentifier} nodes are enhanced with the\n+ * node's {@link IdentifierType}. This is achieved by processing metadata files referenced by the Visualforce page.\n+ */\n+abstract class AbstractVfTypedElExpressionRule extends AbstractVfRule {", "originalCommit": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NTUyMw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522355523", "bodyText": "I have removed this since it is now stored on the AST.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyODQwOA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513428408", "bodyText": "I think, we should fix/improve AbstractRuleSetFactoryTest. I guess, both apex and visualforce rules are now tested, which is unnecessary.", "author": "adangel", "createdAt": "2020-10-28T13:10:24Z", "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/RuleSetFactoryTest.java", "diffHunk": "@@ -5,7 +5,13 @@\n package net.sourceforge.pmd.lang.vf;\n \n import net.sourceforge.pmd.AbstractRuleSetFactoryTest;\n+import net.sourceforge.pmd.lang.apex.rule.ApexXPathRule;\n \n public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {\n-    // no additional tests\n+    public RuleSetFactoryTest() {\n+        super();\n+        // Copied from net.sourceforge.pmd.lang.apex.RuleSetFactoryTest\n+        // Apex rules are found in the classpath because this module has a dependency on pmd-apex", "originalCommit": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NjE3Mw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522356173", "bodyText": "I added the ability to exclude Languages from the AbstractRuleSetFactoryTest.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyOTI4Ng==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513429286", "bodyText": "The usual pattern is constant holding classes is to create a final class with a private constructor instead of an abstract class...", "author": "adangel", "createdAt": "2020-10-28T13:11:43Z", "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/VFTestContstants.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class VFTestContstants {", "originalCommit": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNjc5Ng==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513436796", "bodyText": "I'd like to have the test resources in a more specific directory. If you just look at the directory listing now (e.g. \"src/test/resources/net/sourceforge/pmd/lang/vf/metadata-sfdx/pages/StandardAccount.page\") you have no clue, what this is for (in which unit test or rule test this is used, etc.). Maybe we keep adding files to these directories for multiple different rules (because there are already pages, so we add another page in the same directory, but test something completely independent)... IMHO we should avoid this. I'd prefer a own directory at least per test class (and the package/directory name gives a hint where the test class is and its name).", "author": "adangel", "createdAt": "2020-10-28T13:22:16Z", "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/VFTestContstants.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class VFTestContstants {\n+    private static final Path ROOT_PATH = Paths.get(\"src\", \"test\", \"resources\", \"net\", \"sourceforge\",", "originalCommit": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNzQ1MA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513107450", "bodyText": "You don't need concurrent maps since they are only modified during initialization.\nIn fact, maybe we could make a new rule for that, something like a \"StatefulEnum\" rule, that flags enums that look like they have mutable state (setters, concurrent map implementations)", "author": "oowekyala", "createdAt": "2020-10-28T00:21:08Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/IdentifierType.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+\n+/**\n+ * Represents all data types that can be referenced from a Visualforce page. This enum consolidates the data types\n+ * available to CustomFields and Apex. It uses the naming convention of CustomFields.\n+ *\n+ * See https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_field_types.htm#meta_type_fieldtype\n+ */\n+public enum IdentifierType {\n+    AutoNumber(false),\n+    Checkbox(false, BasicType.BOOLEAN),\n+    Currency(false, BasicType.CURRENCY),\n+    Date(false, BasicType.DATE),\n+    DateTime(false, BasicType.DATE_TIME),\n+    Email(false),\n+    EncryptedText(true),\n+    ExternalLookup(true),\n+    File(false),\n+    Hierarchy(false),\n+    Html(true),\n+    IndirectLookup(false),\n+    Location(false),\n+    LongTextArea(true),\n+    Lookup(false, BasicType.ID),\n+    MasterDetail(false),\n+    MetadataRelationship(false),\n+    MultiselectPicklist(true),\n+    Note(true),\n+    Number(false, BasicType.DECIMAL, BasicType.DOUBLE, BasicType.INTEGER, BasicType.LONG),\n+    Percent(false),\n+    Phone(false),\n+    Picklist(true),\n+    Summary(false),\n+    Text(true, BasicType.STRING),\n+    TextArea(true),\n+    Time(false, BasicType.TIME),\n+    Url(false),\n+    Unknown(true);\n+\n+    private static final Logger LOGGER = Logger.getLogger(IdentifierType.class.getName());\n+\n+\n+    /**\n+     * True if this field is an XSS risk\n+     */\n+    public final boolean requiresEscaping;\n+\n+    /**\n+     * The set of {@link BasicType}s that map to this type. Multiple types can map to a single instance of this enum.\n+     */\n+    private final Set<BasicType> basicTypes;\n+\n+    /**\n+     * A case insensitive map of the enum name to its instance. The case metadata is not guaranteed to have the correct\n+     * case.\n+     */\n+    private static final Map<String, IdentifierType> CASE_INSENSITIVE_MAP = new ConcurrentHashMap<>();", "originalCommit": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDIzMw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513564233", "bodyText": "These look like new candidates for #2518. I think they're global to the analysed project, and should not be configured on a rule per rule basis (like the auxclasspath for java). This way the info could be added to the ast", "author": "oowekyala", "createdAt": "2020-10-28T15:59:50Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/AbstractVfTypedElExpressionRule.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.rule.security;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.vf.IdentifierType;\n+import net.sourceforge.pmd.lang.vf.VfExpressionTypeVisitor;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.rule.AbstractVfRule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+/**\n+ * Represents a rule where the {@link net.sourceforge.pmd.lang.vf.ast.ASTIdentifier} nodes are enhanced with the\n+ * node's {@link IdentifierType}. This is achieved by processing metadata files referenced by the Visualforce page.\n+ */\n+abstract class AbstractVfTypedElExpressionRule extends AbstractVfRule {\n+    /**\n+     * Directory that contains Apex classes that may be referenced from a Visualforce page.\n+     */\n+    private static final PropertyDescriptor<List<String>> APEX_DIRECTORIES_DESCRIPTOR =", "originalCommit": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc4Mzk0NQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513783945", "bodyText": "@oowekyala #2518 looks promising and solves the issue I originally ran into when trying to store the info on the AST and needed to add configuration properties.\n2518 is currently targeted for 7.0. What are your thoughts on an interim 6.x solution which\n\nAdds the CLI extension -L<langId>:<propName> <value>\nStores the CLI values either in ParserOptions or in a globally available singleton\n\nThis doesn't solve the lifecycle issues, but it does provide a means for language specific properties in a generic way.\nThanks.", "author": "jbartolotta-sfdc", "createdAt": "2020-10-28T21:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU0NDI5Ng==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r514544296", "bodyText": "What are your thoughts on an interim 6.x solution which\n\nAdds the CLI extension -L: \nStores the CLI values either in ParserOptions or in a globally available singleton\n\n\nI think this could work! I don't expect this part of the proposal to change (the CLI syntax), and anyway it would be experimental. Implementing it early will also make it easier for this PR to be adapted to language properties when they're implemented. I think it would be easier to touch ParserOptions than making a global singleton. For one, this would give a way to set those properties in tests. It's also what #2830 does.\nIn this PR, as an interim to the interim, I suppose you could make the changes you need to ParserOptions, and configure it via system properties. This way you can pass values to the properties without needing to implement the new CLI syntax here. We can make a PR next, to replace those system properties with the new CLI syntax.", "author": "oowekyala", "createdAt": "2020-10-29T20:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1NzEwNA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522357104", "bodyText": "@oowekyala I updated the PR to have ParserOptions extend AbstractPropertySource. Let me know your thoughts. If this is too big of a change for 6.x, I can change VFParserOptions to implement PropertySource and delegate to a concrete instance of AbstractPropertySource.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDIzMw=="}], "type": "inlineReview"}, {"oid": "6f7bebcecd5bf976f0ba5bc48a72775bfaf88068", "url": "https://github.com/pmd/pmd/commit/6f7bebcecd5bf976f0ba5bc48a72775bfaf88068", "message": "Configure visualforce to require Java 8\n\npmd-visualforce depends on pmd-apex. pmd-apex relies on Java 8. This change configures pmd-visualforce to also require Java 8.\n\nThis is a breaking change that will need to be documented.", "committedDate": "2020-10-28T22:10:26Z", "type": "commit"}, {"oid": "ba2e91b3a0857d67e47ffce6b9e6c18200558330", "url": "https://github.com/pmd/pmd/commit/ba2e91b3a0857d67e47ffce6b9e6c18200558330", "message": "Exclude languages in AbstractRuleSetFactoryTest\n\nAllow subclasses of AbstractRuleSetFactoryTest to filter out languages\nthat show up in the classpath but should not be tested.\n\nChange VFTestContstants to final instead of abstract.", "committedDate": "2020-10-30T00:22:35Z", "type": "commit"}, {"oid": "ba2e91b3a0857d67e47ffce6b9e6c18200558330", "url": "https://github.com/pmd/pmd/commit/ba2e91b3a0857d67e47ffce6b9e6c18200558330", "message": "Exclude languages in AbstractRuleSetFactoryTest\n\nAllow subclasses of AbstractRuleSetFactoryTest to filter out languages\nthat show up in the classpath but should not be tested.\n\nChange VFTestContstants to final instead of abstract.", "committedDate": "2020-10-30T00:22:35Z", "type": "forcePushed"}, {"oid": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "url": "https://github.com/pmd/pmd/commit/db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "message": "Store type information in AST instead of map\n\nStore the IdentifierType on ASTIdentifier node instead of in a separate map.\n\nUse the existing TypeResolution pattern to configure the visitor instead deriving from an abstract rule.\n\nChanged ParserOptions to extend AbstractPropertySource with the ability to override the defaults via environment variables.", "committedDate": "2020-11-12T18:15:04Z", "type": "commit"}, {"oid": "0348b2c0d2ffefb08ea0b65a452d3746592771d8", "url": "https://github.com/pmd/pmd/commit/0348b2c0d2ffefb08ea0b65a452d3746592771d8", "message": "Merge branch 'master' into issue1092-vf-escape-false-positives", "committedDate": "2020-11-12T18:39:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1ODY3NA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522358674", "bodyText": "Added equals and hashCode based on the ParserOptions JavaDoc comment.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:24:22Z", "path": "pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractPropertySource.java", "diffHunk": "@@ -252,4 +253,22 @@ public String dysfunctionReason() {\n     private <T> String errorForPropCapture(PropertyDescriptor<T> descriptor) {\n         return descriptor.errorFor(getProperty(descriptor));\n     }\n+", "originalCommit": "0348b2c0d2ffefb08ea0b65a452d3746592771d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2MzgyMg==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522363822", "bodyText": "I was undecided if it was better to declare this here or in VfParserOptions. I chose here because it is closer to its usage.\nWhere should I add documentation for these new properties and the fact that they can be set via environment variables?", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:28:25Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfExpressionTypeVisitor.java", "diffHunk": "@@ -4,39 +4,69 @@\n \n package net.sourceforge.pmd.lang.vf;\n \n+import java.io.File;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.logging.Logger;\n \n+import net.sourceforge.pmd.lang.ast.AbstractTokenManager;\n import net.sourceforge.pmd.lang.vf.ast.ASTAttribute;\n import net.sourceforge.pmd.lang.vf.ast.ASTAttributeValue;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n import net.sourceforge.pmd.lang.vf.ast.ASTDotExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTElExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTElement;\n import net.sourceforge.pmd.lang.vf.ast.ASTExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n import net.sourceforge.pmd.lang.vf.ast.ASTText;\n import net.sourceforge.pmd.lang.vf.ast.VfParserVisitorAdapter;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+import net.sourceforge.pmd.properties.PropertySource;\n \n /**\n  * Visits {@link ASTElExpression} nodes and stores type information for all {@link ASTIdentifier} child nodes.\n  */\n public class VfExpressionTypeVisitor extends VfParserVisitorAdapter {\n     private static final Logger LOGGER = Logger.getLogger(VfExpressionTypeVisitor.class.getName());\n \n+    static final List<String> DEFAULT_APEX_DIRECTORIES = Collections.singletonList(\"..\" + File.separator + \"classes\");\n+    static final List<String> DEFAULT_OBJECT_DIRECTORIES = Collections.singletonList(\"..\" + File.separator + \"objects\");\n+\n+    /**\n+     * Directory that contains Apex classes that may be referenced from a Visualforce page.\n+     */\n+    public static final PropertyDescriptor<List<String>> APEX_DIRECTORIES_DESCRIPTOR =", "originalCommit": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNjQxMQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523406411", "bodyText": "I think actually it would be better to put them in VfParserOptions, because otherwise VfParserOptions is a bit opaque", "author": "oowekyala", "createdAt": "2020-11-14T10:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2MzgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2NTg0NQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522365845", "bodyText": "This is where it is stored on the AST.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:29:51Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfExpressionTypeVisitor.java", "diffHunk": "@@ -139,7 +169,7 @@ public Object visit(ASTElExpression node, Object data) {\n             }\n \n             if (type != null) {\n-                identifierTypes.put(entry.getKey(), type);\n+                entry.getKey().setIdentifierType(type);", "originalCommit": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2ODE0OA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522368148", "bodyText": "This pattern seemed like the correct way to invoke the visitor. I hadn't noticed it in my previous commit.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:31:24Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfHandler.java", "diffHunk": "@@ -28,6 +29,23 @@ public Parser getParser(ParserOptions parserOptions) {\n         return new VfParser(parserOptions);\n     }\n \n+    @Override\n+    public VisitorStarter getTypeResolutionFacade(ClassLoader classLoader) {", "originalCommit": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxNTU1OA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522415558", "bodyText": "This is technically the way but it's deprecated for removal. In PMD 7 we'll centralise the logic for such passes in the implementation of the Parser#parse routine. Conveniently, the parse routine is also the place where you have access to a ParserOptions. So you can avoid putting them on the ASTCompilationUnit as public data.\nI suggest you instead move this logic into VfParser#parse and remove ASTCompilationUnit#getPropertySource", "author": "oowekyala", "createdAt": "2020-11-12T20:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2ODE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2OTc5Ng==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522369796", "bodyText": "Added more formal structure to the test files.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T19:33:16Z", "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/VFTestUtils.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public final class VFTestUtils {\n+    /**\n+     * Salesforce metadata is stored in two different formats, the newer sfdx form and the older mdapi format. Used to\n+     * locate metadata on the file system during unit tests.\n+     */\n+    public enum MetadataFormat {\n+        SFDX(\"sfdx\"),\n+        MDAPI(\"mdapi\");\n+\n+        public final String directoryName;\n+\n+        MetadataFormat(String directoryName) {\n+            this.directoryName = directoryName;\n+        }\n+    }\n+\n+    /**\n+     * Represents the metadata types that are referenced from unit tests. Used to locate metadata on the file system\n+     * during unit tests.\n+     */\n+    public enum MetadataType {\n+        Apex(\"classes\"),\n+        Objects(\"objects\"),\n+        Vf(\"pages\");\n+\n+        public final String directoryName;\n+\n+        MetadataType(String directoryName) {\n+            this.directoryName = directoryName;\n+        }\n+    }\n+\n+    /**\n+     * @return the path of the directory that matches the given parameters. The directory path is constructed using the", "originalCommit": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzQ0NQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522497445", "bodyText": "I just found ParserOptionsTest in the pmd-test project I will move these tests over. This class is not currently running as a unit test because it is in the src/main hierarchy. All of the other classes in pmd-test/src/main are abstract classes meant to be extended. ParserOptionsTest#verifyOptionsEqualsHashcode is referenced from XmlParserOptionsTest\nI will refactor #verifyOptionsEqualsHashcode into a utils class and move the test methods over to pmd-test so that they are run.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-12T23:21:11Z", "path": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ParserOptionsTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**", "originalCommit": "0348b2c0d2ffefb08ea0b65a452d3746592771d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "url": "https://github.com/pmd/pmd/commit/e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "message": "Move visitor to VfParser#parse\n\nLanguageVersionHandler#getTypeResolutionFacade is deprecated. Moved the VfExpressionTypeVisitor creation and execution to VfParser#parse instead.\n\nParsingOptionsTest located in pmd-test wasn't running previously because it was in the src/main hierarchy. Moved this test into the src/test hierarchy and consolidated the methods from the\nsimilarly named class from pmd-core.", "committedDate": "2020-11-13T04:13:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNDk0NA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523404944", "bodyText": "This comment should be moved to the getter, otherwise the info is not available to users of the API\nAlso since IdentifierType is an enum the getter will also be available as an XPath attribute. Maybe the comment should say as much", "author": "oowekyala", "createdAt": "2020-11-14T10:37:01Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/ASTIdentifier.java", "diffHunk": "@@ -5,8 +5,14 @@\n package net.sourceforge.pmd.lang.vf.ast;\n \n import net.sourceforge.pmd.annotation.InternalApi;\n+import net.sourceforge.pmd.lang.vf.IdentifierType;\n \n public class ASTIdentifier extends AbstractVFNode {\n+    /**\n+     * The data type that this identifier refers to. May be null.", "originalCommit": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNTQ0NA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523405444", "bodyText": "This looks like a partial duplicate of", "author": "oowekyala", "createdAt": "2020-11-14T10:42:30Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ApexClassPropertyTypes.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import net.sourceforge.pmd.lang.LanguageRegistry;\n+import net.sourceforge.pmd.lang.LanguageVersion;\n+import net.sourceforge.pmd.lang.Parser;\n+import net.sourceforge.pmd.lang.ParserOptions;\n+import net.sourceforge.pmd.lang.apex.ApexLanguageModule;\n+import net.sourceforge.pmd.lang.apex.ast.ApexNode;\n+import net.sourceforge.pmd.lang.ast.Node;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+\n+/**\n+ * Responsible for storing a mapping of Apex Class properties that can be referenced from Visualforce to the type of the\n+ * property.\n+ */\n+class ApexClassPropertyTypes {\n+    private static final Logger LOGGER = Logger.getLogger(ApexClassPropertyTypes.class.getName());\n+    private static final String APEX_CLASS_FILE_SUFFIX = \".cls\";\n+\n+    private final Map<String, IdentifierType> variableNameToVariableType;\n+    private final Set<String> variableNameProcessed;\n+\n+    ApexClassPropertyTypes() {\n+        this.variableNameToVariableType = new HashMap<>();\n+        this.variableNameProcessed = new HashSet<>();\n+    }\n+\n+    /**\n+     * Looks in {@code apexDirectories} for an Apex property identified by {@code expression}.\n+     *\n+     * @return the IdentifierType for the property represented by {@code expression} or null if not found.\n+     */\n+    public IdentifierType getVariableType(String expression, String vfFileName, List<String> apexDirectories) {\n+        String lowerExpression = expression.toLowerCase(Locale.ROOT);\n+        if (variableNameToVariableType.containsKey(lowerExpression)) {\n+            // The expression has been previously retrieved\n+            return variableNameToVariableType.get(lowerExpression);\n+        } else if (variableNameProcessed.contains(lowerExpression)) {\n+            // The expression has been previously requested, but was not found\n+            return null;\n+        } else {\n+            String[] parts = expression.split(\"\\\\.\");\n+            if (parts.length >= 2) {\n+                // Load the class and parse it\n+                String className = parts[0];\n+\n+                Path vfFilePath = Paths.get(vfFileName);\n+                for (String apexDirectory : apexDirectories) {\n+                    Path candidateDirectory;\n+                    if (Paths.get(apexDirectory).isAbsolute()) {", "originalCommit": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNTQ1Mw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523405453", "bodyText": "this", "author": "oowekyala", "createdAt": "2020-11-14T10:42:37Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ObjectFieldTypes.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Responsible for storing a mapping of Fields that can be referenced from Visualforce to the type of the field.\n+ */\n+class ObjectFieldTypes {\n+    private static final Logger LOGGER = Logger.getLogger(ObjectFieldTypes.class.getName());\n+\n+    public static final String CUSTOM_OBJECT_SUFFIX = \"__c\";\n+    private static final String FIELDS_DIRECTORY = \"fields\";\n+    private static final String MDAPI_OBJECT_FILE_SUFFIX = \".object\";\n+    private static final String SFDX_FIELD_FILE_SUFFIX = \".field-meta.xml\";\n+\n+    private static final Map<String, IdentifierType> STANDARD_FIELD_TYPES;\n+\n+    static {\n+        STANDARD_FIELD_TYPES = new HashMap<>();\n+        STANDARD_FIELD_TYPES.put(\"createdbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"createddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"id\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"isdeleted\", IdentifierType.Checkbox);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifiedbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifieddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"systemmodstamp\", IdentifierType.DateTime);\n+    }\n+\n+    /**\n+     * Cache of lowercase variable names to the variable type declared in the field's metadata file.\n+     */\n+    private final Map<String, IdentifierType> variableNameToVariableType;\n+\n+    /**\n+     * Keep track of which variables were already processed. Avoid processing if a page repeatedly asks for an entry\n+     * which we haven't previously found.\n+     */\n+    private final Set<String> variableNameProcessed;\n+\n+    /**\n+     * Keep track of which \".object\" files have already been processed. All fields are processed at once. If an object\n+     * file has been processed\n+     */\n+    private final Set<String> objectFileProcessed;\n+\n+    // XML Parsing objects\n+    private final DocumentBuilder documentBuilder;\n+    private final XPathExpression customObjectFieldsExpression;\n+    private final XPathExpression customFieldFullNameExpression;\n+    private final XPathExpression customFieldTypeExpression;\n+    private final XPathExpression sfdxCustomFieldFullNameExpression;\n+    private final XPathExpression sfdxCustomFieldTypeExpression;\n+\n+    ObjectFieldTypes() {\n+        this.variableNameToVariableType = new HashMap<>();\n+        this.variableNameProcessed = new HashSet<>();\n+        this.objectFileProcessed = new HashSet<>();\n+\n+        try {\n+            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+            documentBuilderFactory.setNamespaceAware(false);\n+            documentBuilderFactory.setValidating(false);\n+            documentBuilderFactory.setIgnoringComments(true);\n+            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n+            documentBuilderFactory.setExpandEntityReferences(false);\n+            documentBuilderFactory.setCoalescing(false);\n+            documentBuilderFactory.setXIncludeAware(false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            this.customObjectFieldsExpression = xPath.compile(\"/CustomObject/fields\");\n+            this.customFieldFullNameExpression = xPath.compile(\"fullName/text()\");\n+            this.customFieldTypeExpression = xPath.compile(\"type/text()\");\n+            this.sfdxCustomFieldFullNameExpression = xPath.compile(\"/CustomField/fullName/text()\");\n+            this.sfdxCustomFieldTypeExpression = xPath.compile(\"/CustomField/type/text()\");\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Looks in {@code objectsDirectories} for a custom field identified by {@code expression}.\n+     *\n+     * @return the IdentifierType for the field represented by {@code expression} or null the custom field isn't found.\n+     */\n+    public IdentifierType getVariableType(String expression, String vfFileName, List<String> objectsDirectories) {\n+        String lowerExpression = expression.toLowerCase(Locale.ROOT);\n+\n+        if (variableNameToVariableType.containsKey(lowerExpression)) {\n+            // The expression has been previously retrieved\n+            return variableNameToVariableType.get(lowerExpression);\n+        } else if (variableNameProcessed.contains(lowerExpression)) {\n+            // The expression has been previously requested, but was not found\n+            return null;\n+        } else {\n+            // The expression should be in the form <objectName>.<fieldName>\n+            String[] parts = expression.split(\"\\\\.\");\n+            if (parts.length == 1) {\n+                throw new RuntimeException(\"Malformed identifier: \" + expression);\n+            } else if (parts.length == 2) {\n+                String objectName = parts[0];\n+                String fieldName = parts[1];\n+\n+                addStandardFields(objectName);\n+\n+                // Attempt to find a metadata file that contains the custom field. The information will be located in a\n+                // file located at <objectDirectory>/<objectName>.object or in an file located at\n+                // <objectDirectory>/<objectName>/fields/<fieldName>.field-meta.xml. The list of object directories\n+                // defaults to the [<vfFileName>/../objects] but can be overridden by the user.\n+                Path vfFilePath = Paths.get(vfFileName);\n+                for (String objectsDirectory : objectsDirectories) {\n+                    Path candidateDirectory;\n+                    if (Paths.get(objectsDirectory).isAbsolute()) {", "originalCommit": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NDEzNw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527974137", "bodyText": "I have refactored these classes to derive from a common base class.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-20T21:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNjExMA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523406110", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                        } catch (IOException | XPathExpressionException | SAXException e) {\n          \n      \n    \n    \n  \n\nOtherwise you'll wrap your runtime exceptions several times. (i just noticed, you'd need a new import for this)\nAlso it would be nice to add some context to the exception. You can use ContextedRuntimeException like so:\nnew ContextedRuntimeException(e).addContextValue(\"object\", customObjectName)\nand add as much relevant info as you want.\nThis applies to more places and is maybe out of the scope of the review. Fix if you want.", "author": "oowekyala", "createdAt": "2020-11-14T10:50:06Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ObjectFieldTypes.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Responsible for storing a mapping of Fields that can be referenced from Visualforce to the type of the field.\n+ */\n+class ObjectFieldTypes {\n+    private static final Logger LOGGER = Logger.getLogger(ObjectFieldTypes.class.getName());\n+\n+    public static final String CUSTOM_OBJECT_SUFFIX = \"__c\";\n+    private static final String FIELDS_DIRECTORY = \"fields\";\n+    private static final String MDAPI_OBJECT_FILE_SUFFIX = \".object\";\n+    private static final String SFDX_FIELD_FILE_SUFFIX = \".field-meta.xml\";\n+\n+    private static final Map<String, IdentifierType> STANDARD_FIELD_TYPES;\n+\n+    static {\n+        STANDARD_FIELD_TYPES = new HashMap<>();\n+        STANDARD_FIELD_TYPES.put(\"createdbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"createddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"id\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"isdeleted\", IdentifierType.Checkbox);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifiedbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifieddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"systemmodstamp\", IdentifierType.DateTime);\n+    }\n+\n+    /**\n+     * Cache of lowercase variable names to the variable type declared in the field's metadata file.\n+     */\n+    private final Map<String, IdentifierType> variableNameToVariableType;\n+\n+    /**\n+     * Keep track of which variables were already processed. Avoid processing if a page repeatedly asks for an entry\n+     * which we haven't previously found.\n+     */\n+    private final Set<String> variableNameProcessed;\n+\n+    /**\n+     * Keep track of which \".object\" files have already been processed. All fields are processed at once. If an object\n+     * file has been processed\n+     */\n+    private final Set<String> objectFileProcessed;\n+\n+    // XML Parsing objects\n+    private final DocumentBuilder documentBuilder;\n+    private final XPathExpression customObjectFieldsExpression;\n+    private final XPathExpression customFieldFullNameExpression;\n+    private final XPathExpression customFieldTypeExpression;\n+    private final XPathExpression sfdxCustomFieldFullNameExpression;\n+    private final XPathExpression sfdxCustomFieldTypeExpression;\n+\n+    ObjectFieldTypes() {\n+        this.variableNameToVariableType = new HashMap<>();\n+        this.variableNameProcessed = new HashSet<>();\n+        this.objectFileProcessed = new HashSet<>();\n+\n+        try {\n+            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+            documentBuilderFactory.setNamespaceAware(false);\n+            documentBuilderFactory.setValidating(false);\n+            documentBuilderFactory.setIgnoringComments(true);\n+            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n+            documentBuilderFactory.setExpandEntityReferences(false);\n+            documentBuilderFactory.setCoalescing(false);\n+            documentBuilderFactory.setXIncludeAware(false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            this.customObjectFieldsExpression = xPath.compile(\"/CustomObject/fields\");\n+            this.customFieldFullNameExpression = xPath.compile(\"fullName/text()\");\n+            this.customFieldTypeExpression = xPath.compile(\"type/text()\");\n+            this.sfdxCustomFieldFullNameExpression = xPath.compile(\"/CustomField/fullName/text()\");\n+            this.sfdxCustomFieldTypeExpression = xPath.compile(\"/CustomField/type/text()\");\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Looks in {@code objectsDirectories} for a custom field identified by {@code expression}.\n+     *\n+     * @return the IdentifierType for the field represented by {@code expression} or null the custom field isn't found.\n+     */\n+    public IdentifierType getVariableType(String expression, String vfFileName, List<String> objectsDirectories) {\n+        String lowerExpression = expression.toLowerCase(Locale.ROOT);\n+\n+        if (variableNameToVariableType.containsKey(lowerExpression)) {\n+            // The expression has been previously retrieved\n+            return variableNameToVariableType.get(lowerExpression);\n+        } else if (variableNameProcessed.contains(lowerExpression)) {\n+            // The expression has been previously requested, but was not found\n+            return null;\n+        } else {\n+            // The expression should be in the form <objectName>.<fieldName>\n+            String[] parts = expression.split(\"\\\\.\");\n+            if (parts.length == 1) {\n+                throw new RuntimeException(\"Malformed identifier: \" + expression);\n+            } else if (parts.length == 2) {\n+                String objectName = parts[0];\n+                String fieldName = parts[1];\n+\n+                addStandardFields(objectName);\n+\n+                // Attempt to find a metadata file that contains the custom field. The information will be located in a\n+                // file located at <objectDirectory>/<objectName>.object or in an file located at\n+                // <objectDirectory>/<objectName>/fields/<fieldName>.field-meta.xml. The list of object directories\n+                // defaults to the [<vfFileName>/../objects] but can be overridden by the user.\n+                Path vfFilePath = Paths.get(vfFileName);\n+                for (String objectsDirectory : objectsDirectories) {\n+                    Path candidateDirectory;\n+                    if (Paths.get(objectsDirectory).isAbsolute()) {\n+                        candidateDirectory = Paths.get(objectsDirectory);\n+                    } else {\n+                        candidateDirectory = vfFilePath.getParent().resolve(objectsDirectory);\n+                    }\n+\n+                    Path sfdxCustomFieldPath = getSfdxCustomFieldPath(candidateDirectory, objectName, fieldName);\n+                    if (sfdxCustomFieldPath != null) {\n+                        // SFDX Format\n+                        parseSfdxCustomField(objectName, sfdxCustomFieldPath);\n+                    } else {\n+                        // MDAPI Format\n+                        String fileName = objectName + MDAPI_OBJECT_FILE_SUFFIX;\n+                        Path mdapiPath = candidateDirectory.resolve(fileName);\n+                        if (Files.exists(mdapiPath) && Files.isRegularFile(mdapiPath)) {\n+                            parseMdapiCustomObject(mdapiPath);\n+                        }\n+                    }\n+\n+                    if (variableNameToVariableType.containsKey(lowerExpression)) {\n+                        // Break out of the loop if a variable was found\n+                        break;\n+                    }\n+                }\n+                variableNameProcessed.add(lowerExpression);\n+            } else {\n+                // TODO: Support cross object relationships, these are expressions that contain \"__r\"\n+                LOGGER.fine(\"Expression does not have two parts: \" + expression);\n+            }\n+        }\n+\n+        return variableNameToVariableType.get(lowerExpression);\n+    }\n+\n+    /**\n+     * Sfdx projects decompose custom fields into individual files. This method will return the individual file that\n+     * corresponds to &lt;objectName&gt;.&lt;fieldName&gt; if it exists.\n+     *\n+     * @return path to the metadata file for the Custom Field or null if not found\n+     */\n+    private Path getSfdxCustomFieldPath(Path objectsDirectory, String objectName, String fieldName) {\n+        Path fieldsDirectoryPath = Paths.get(objectsDirectory.toString(), objectName, FIELDS_DIRECTORY);\n+        if (Files.exists(fieldsDirectoryPath) && Files.isDirectory(fieldsDirectoryPath)) {\n+            Path sfdxFieldPath = Paths.get(fieldsDirectoryPath.toString(), fieldName + SFDX_FIELD_FILE_SUFFIX);\n+            if (Files.exists(sfdxFieldPath) && Files.isRegularFile(sfdxFieldPath)) {\n+                return sfdxFieldPath;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Determine the type of the custom field.\n+     */\n+    private void parseSfdxCustomField(String customObjectName, Path sfdxCustomFieldPath) {\n+        try {\n+            Document document = documentBuilder.parse(sfdxCustomFieldPath.toFile());\n+            Node fullNameNode = (Node) sfdxCustomFieldFullNameExpression.evaluate(document, XPathConstants.NODE);\n+            Node typeNode = (Node) sfdxCustomFieldTypeExpression.evaluate(document, XPathConstants.NODE);\n+            String type = typeNode.getNodeValue();\n+            IdentifierType identifierType = IdentifierType.fromString(type);\n+\n+            String key = customObjectName + \".\" + fullNameNode.getNodeValue();\n+            setVariableType(key, identifierType);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Parse the custom object path and determine the type of all of its custom fields.\n+     */\n+    private void parseMdapiCustomObject(Path mdapiObjectFile) {\n+        String fileName = mdapiObjectFile.getFileName().toString();\n+\n+        String customObjectName = fileName.substring(0, fileName.lastIndexOf(MDAPI_OBJECT_FILE_SUFFIX));\n+        if (!objectFileProcessed.contains(customObjectName)) {\n+            try {\n+                Document document = documentBuilder.parse(mdapiObjectFile.toFile());\n+                NodeList fieldsNodes = (NodeList) customObjectFieldsExpression.evaluate(document, XPathConstants.NODESET);\n+                for (int i = 0; i < fieldsNodes.getLength(); i++) {\n+                    Node fieldsNode = fieldsNodes.item(i);\n+                    Node fullNameNode = (Node) customFieldFullNameExpression.evaluate(fieldsNode, XPathConstants.NODE);\n+                    if (fullNameNode == null) {\n+                        throw new RuntimeException(\"fullName evaluate failed for \" + customObjectName + \" \" + fieldsNode.getTextContent());\n+                    }\n+                    String name = fullNameNode.getNodeValue();\n+                    if (endsWithIgnoreCase(name, CUSTOM_OBJECT_SUFFIX)) {\n+                        Node typeNode = (Node) customFieldTypeExpression.evaluate(fieldsNode, XPathConstants.NODE);\n+                        if (typeNode == null) {\n+                            throw new RuntimeException(\"type evaluate failed for object=\" + customObjectName + \", field=\" + name + \" \" + fieldsNode.getTextContent());\n+                        }\n+                        String type = typeNode.getNodeValue();\n+                        IdentifierType identifierType = IdentifierType.fromString(type);\n+                        String key = customObjectName + \".\" + fullNameNode.getNodeValue();\n+                        setVariableType(key, identifierType);\n+                    }\n+                }\n+            } catch (Exception e) {", "originalCommit": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNjU2NQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523406565", "bodyText": "I think this could be package-private\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class VfExpressionTypeVisitor extends VfParserVisitorAdapter {\n          \n          \n            \n            class VfExpressionTypeVisitor extends VfParserVisitorAdapter {", "author": "oowekyala", "createdAt": "2020-11-14T10:55:08Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfExpressionTypeVisitor.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+\n+import net.sourceforge.pmd.lang.ast.AbstractTokenManager;\n+import net.sourceforge.pmd.lang.vf.ast.ASTAttribute;\n+import net.sourceforge.pmd.lang.vf.ast.ASTAttributeValue;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTDotExpression;\n+import net.sourceforge.pmd.lang.vf.ast.ASTElExpression;\n+import net.sourceforge.pmd.lang.vf.ast.ASTElement;\n+import net.sourceforge.pmd.lang.vf.ast.ASTExpression;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.ast.ASTText;\n+import net.sourceforge.pmd.lang.vf.ast.VfParserVisitorAdapter;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+import net.sourceforge.pmd.properties.PropertySource;\n+\n+/**\n+ * Visits {@link ASTElExpression} nodes and stores type information for all {@link ASTIdentifier} child nodes.\n+ */\n+public class VfExpressionTypeVisitor extends VfParserVisitorAdapter {", "originalCommit": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNzM2NQ==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523407365", "bodyText": "I think it would be a better idea to hide the property source inside the parser options instead of using inheritance. This would avoid eg splitting your equals method with that super call. I'd like to remove AbstractPropertySource eventually, the inheritance is really causing problems.", "author": "oowekyala", "createdAt": "2020-11-14T11:04:43Z", "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ParserOptions.java", "diffHunk": "@@ -4,19 +4,38 @@\n \n package net.sourceforge.pmd.lang;\n \n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import net.sourceforge.pmd.properties.AbstractPropertySource;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+\n /**\n  * Represents a set of configuration options for a {@link Parser}. For each\n  * unique combination of ParserOptions a Parser will be used to create an AST.\n  * Therefore, implementations must implement {@link Object#equals(Object)} and\n  * {@link Object#hashCode()}.\n  */\n-public class ParserOptions {\n+public class ParserOptions extends AbstractPropertySource {", "originalCommit": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNzgxMg==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523407812", "bodyText": "The renaming and the new constructor are binary-incompatible changes. To preserve binary compatibility we can declare this ParserOptionTestUtils next to ParserOptionsTest, give it a package-private constructor, and make ParserOptionsTest extend from it. And deprecate ParserOptionsTest.", "author": "oowekyala", "createdAt": "2020-11-14T11:09:49Z", "path": "pmd-test/src/main/java/net/sourceforge/pmd/lang/ParserOptionsTestUtils.java", "diffHunk": "@@ -5,38 +5,9 @@\n package net.sourceforge.pmd.lang;\n \n import org.junit.Assert;\n-import org.junit.Test;\n \n-/**\n- * Unit tests for {@link ParserOptions}.\n- */\n-public class ParserOptionsTest {\n-\n-    /**\n-     * SuppressMarker should be initially null and changeable.\n-     */\n-    @Test\n-    public void testSuppressMarker() {\n-        ParserOptions parserOptions = new ParserOptions();\n-        Assert.assertNull(parserOptions.getSuppressMarker());\n-        parserOptions.setSuppressMarker(\"foo\");\n-        Assert.assertEquals(\"foo\", parserOptions.getSuppressMarker());\n-    }\n-\n-    /**\n-     * Verify that the equals and hashCode methods work as expected.\n-     */\n-    @Test\n-    public void testEqualsHashcode() {\n-        ParserOptions options1 = new ParserOptions();\n-        options1.setSuppressMarker(\"foo\");\n-        ParserOptions options2 = new ParserOptions();\n-        options2.setSuppressMarker(\"bar\");\n-        ParserOptions options3 = new ParserOptions();\n-        options3.setSuppressMarker(\"foo\");\n-        ParserOptions options4 = new ParserOptions();\n-        options4.setSuppressMarker(\"bar\");\n-        verifyOptionsEqualsHashcode(options1, options2, options3, options4);\n+public final class ParserOptionsTestUtils {", "originalCommit": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3Mzk5OA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527973998", "bodyText": "I have reverted the original file and marked it as deprecated. I renamed the file in src/test to ParserOptionsUnitTest with a comment to change the name in 7.0. The common piece of code is a static method, having ParserOptionsTest extend the util with the static method would not have retained compatibility with anyone code that is calling the ParserOptionsTest static method.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-20T21:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNzgxMg=="}], "type": "inlineReview"}, {"oid": "86b5948f072a789d4a95b7934c0b0814021088e2", "url": "https://github.com/pmd/pmd/commit/86b5948f072a789d4a95b7934c0b0814021088e2", "message": "Update the way nodes with data are identified\n\nChanged method for how the Visualforce strings are reconstructed from the AST. The previous implementation had incorrect assumptions about the structure of the AST. Added tests to more thoroughly test these situations.\n\nChanged name of IdentifierType to DataType. This information can be stored on either ASTIdentifier or ASTLiteral nodes.\n\nChanges based on PR feedgack:\n- Restored ParserOptionsTest in order to avoid binary compatibilty issues.\n- Changed ParserOptions to contain a PropertySource instead of extending AbtractPropertySource.", "committedDate": "2020-11-20T19:59:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NDYwMw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527974603", "bodyText": "I renamed this from IdentifierType. This value can be stored on both ASTIdentifier and ASTLiteral nodes.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-20T21:18:16Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/DataType.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+\n+/**\n+ * Represents all data types that can be referenced from a Visualforce page. This enum consolidates the data types\n+ * available to CustomFields and Apex. It uses the naming convention of CustomFields.\n+ *\n+ * See https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_field_types.htm#meta_type_fieldtype\n+ */\n+public enum DataType {", "originalCommit": "86b5948f072a789d4a95b7934c0b0814021088e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NTQ0Ng==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527975446", "bodyText": "New common class for ASTIdentifier and ASTLiteral.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-20T21:20:07Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/AbstractVFDataNode.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*", "originalCommit": "86b5948f072a789d4a95b7934c0b0814021088e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NjMzOA==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527976338", "bodyText": "Common code for ApexClassPropertyTypes and ObjectFieldTypes.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-20T21:22:16Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/SalesforceFieldTypes.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for storing a mapping of Fields that can be referenced from Visualforce to the type of the field. The\n+ * fields are identified by in a case insensitive manner.\n+ */\n+abstract class SalesforceFieldTypes {", "originalCommit": "86b5948f072a789d4a95b7934c0b0814021088e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3Njg5Mw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527976893", "bodyText": "This method can be iterated on over time to handle the cases listed in the Javadoc.", "author": "jbartolotta-sfdc", "createdAt": "2020-11-20T21:23:38Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/ASTExpression.java", "diffHunk": "@@ -23,4 +41,120 @@ public ASTExpression(VfParser p, int id) {\n     public Object jjtAccept(VfParserVisitor visitor, Object data) {\n         return visitor.visit(this, data);\n     }\n+\n+    private void logWarning(String warning, Node node) {\n+        LOGGER.warning(warning\n+                + \". nodeClass=\" + node.getClass().getSimpleName()\n+                + \", fileName=\" + AbstractTokenManager.getFileName()\n+                + \", beginLine=\" + node.getBeginLine()\n+                + \", image=\" + node.getImage());\n+    }\n+\n+    /**\n+     * <p>\n+     * An Expression can contain one or more strings that map to a piece of data. This method maps the string\n+     * from the Visualforce page to terminal AST node that the string represents. The terminal node will be either an\n+     * ASTIdentifier or ASTLiteral. It is the terminal node that is most important since it represents the type of data\n+     * that will be displayed in the page.\n+     * </p>\n+     * <p>\n+     * The string representation can be reconstructed by starting at the {@code Identifier} node and traversing its\n+     * siblings until a node other than a {@code DotExpression} is encountered. Some more advanced situations aren't\n+     * currently handled by this method. The method will throw an exception in such cases.\n+     * </p>\n+     * <pre>{@code\n+     * <apex:outputText value=\"{!MyValue}\" /> results in AST\n+     * <Identifier Image='MyValue'/>\n+     * The method would return key=ASTIdentifier(Image='MyValue'), value=\"MyValue\"\n+     * }</pre>\n+     * <pre>{@code\n+     * <apex:outputText value=\"{!MyObject__c.Text__c}\" /> results in AST (It's important to notice that DotExpression is\n+     * a sibling of Identifier.\n+     * <Identifier Image='MyObject__c'/>\n+     * <DotExpression Image=''>\n+     *     <Identifier Image='Text__c'/>\n+     * </DotExpression>\n+     * This method would return key=ASTIdentifier(Image='Text__c'), value=\"MyObject__c.Text__c\"\n+     * }</pre>\n+     *\n+     * THE FOLLOWING SITUATIONS ARE NOT HANDLED AND WILL THROW AN EXCEPTION.\n+     * This syntax causes ambiguities with Apex Controller methods that return Maps versus accessing a CustomObject's\n+     * field via array notation. This may be addressed in a future release.\n+     *\n+     * <pre>{@code\n+     * <apex:outputText value=\"{!MyObject__c['Text__c']}\" /> results in AST\n+     * <Identifier Image='MyObject__c'/>\n+     * <Expression Image=''>\n+     *     <Literal Image='&apos;Text__c&apos;'>\n+     * </Expression>\n+\n+     * <apex:outputText value=\"{!MyObject__c[AnotherObject__c.Id]}\" /> results in AST\n+     * <Identifier Image='MyObject__c'/>\n+     * <Expression Image=''>\n+     *     <Identifier Image='AnotherObject__c'/>\n+     *         <DotExpression Image=''>\n+     *             <Identifier Image='Id'/>\n+     *         </DotExpression>\n+     *     </Identifier>\n+     * </Expression>\n+     * }</pre>\n+     *\n+     * @throws DataNodeStateException if the results of this method could have been incorrect. Callers should typically\n+     * not rethrow this exception, as it will happen often and doesn't represent a terminal exception.\n+     */\n+    public Map<AbstractVFDataNode, String> getDataNodes() throws DataNodeStateException {", "originalCommit": "86b5948f072a789d4a95b7934c0b0814021088e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "21506cea859cc1dec6ce2d71c339be219568be87", "url": "https://github.com/pmd/pmd/commit/21506cea859cc1dec6ce2d71c339be219568be87", "message": "Cleanup languages to skip", "committedDate": "2020-11-24T10:39:59Z", "type": "commit"}, {"oid": "fabf2cf6db516fe5c9717be9162f677c969e77f3", "url": "https://github.com/pmd/pmd/commit/fabf2cf6db516fe5c9717be9162f677c969e77f3", "message": "Make the parser options properties private", "committedDate": "2020-11-24T10:53:45Z", "type": "commit"}, {"oid": "58cf6cbc96f3afb0960b1798b39d6040b62d46db", "url": "https://github.com/pmd/pmd/commit/58cf6cbc96f3afb0960b1798b39d6040b62d46db", "message": "Remove AbstractPropertySource equals/hashCode", "committedDate": "2020-11-24T10:55:09Z", "type": "commit"}, {"oid": "0ad1f47b29e7ef5683729530cc434fa07623320f", "url": "https://github.com/pmd/pmd/commit/0ad1f47b29e7ef5683729530cc434fa07623320f", "message": "Use interface instead of deprecated abstract class", "committedDate": "2020-11-24T11:02:32Z", "type": "commit"}, {"oid": "898c301ce0d25db08f9be225d25181e63fce0214", "url": "https://github.com/pmd/pmd/commit/898c301ce0d25db08f9be225d25181e63fce0214", "message": "Merge branch 'master' into pr/2864", "committedDate": "2020-11-24T11:06:07Z", "type": "commit"}, {"oid": "b94ac4f0180a476ed5f883d987f42cd61371c0ee", "url": "https://github.com/pmd/pmd/commit/b94ac4f0180a476ed5f883d987f42cd61371c0ee", "message": "Don't create a vf language module per parser options", "committedDate": "2020-11-24T11:09:25Z", "type": "commit"}, {"oid": "4efe1493a597ba012ad9f6d0d3361928c9952096", "url": "https://github.com/pmd/pmd/commit/4efe1493a597ba012ad9f6d0d3361928c9952096", "message": "Remove some unchecked warnings", "committedDate": "2020-11-24T11:12:32Z", "type": "commit"}, {"oid": "2d5781482eddbd67568c01da584305fa117a794e", "url": "https://github.com/pmd/pmd/commit/2d5781482eddbd67568c01da584305fa117a794e", "message": "Fix tests", "committedDate": "2020-11-24T11:22:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NDA0Nw==", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r529474047", "bodyText": "I replaced your AbstractVfDataNode with this interface (your abstract class was deprecated). Maybe the name VfDataNode is more appropriate, feel free to rename it", "author": "oowekyala", "createdAt": "2020-11-24T11:28:09Z", "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/VfTypedNode.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.ast;\n+\n+import net.sourceforge.pmd.lang.vf.DataType;\n+\n+/**\n+ * Represents a node that displays a piece of data.\n+ */\n+public interface VfTypedNode extends VfNode {", "originalCommit": "2d5781482eddbd67568c01da584305fa117a794e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f805b858504191c38c752578f8aac544f917f6fd", "url": "https://github.com/pmd/pmd/commit/f805b858504191c38c752578f8aac544f917f6fd", "message": "Fix Html DataType\n\nThis DataType does not need to be escaped, it is always escaped by the\nserver.", "committedDate": "2020-12-10T04:11:25Z", "type": "commit"}, {"oid": "e7f7f7184e20edbb496561ecdcad84fef8f50cd6", "url": "https://github.com/pmd/pmd/commit/e7f7f7184e20edbb496561ecdcad84fef8f50cd6", "message": "Merge branch 'master' into pr/2864", "committedDate": "2020-12-10T18:56:08Z", "type": "commit"}, {"oid": "f7829531c966c2e3bff97e08e0cc0c49ab500976", "url": "https://github.com/pmd/pmd/commit/f7829531c966c2e3bff97e08e0cc0c49ab500976", "message": "Add some doc", "committedDate": "2020-12-10T19:17:51Z", "type": "commit"}, {"oid": "aaa540af7b7e742c47db8e02b68564e3fd931e79", "url": "https://github.com/pmd/pmd/commit/aaa540af7b7e742c47db8e02b68564e3fd931e79", "message": "Update release notes", "committedDate": "2020-12-10T19:27:13Z", "type": "commit"}, {"oid": "4e00c204991b8a3bbff9012b1d6f264e14f8166e", "url": "https://github.com/pmd/pmd/commit/4e00c204991b8a3bbff9012b1d6f264e14f8166e", "message": "Small comment and doc edits", "committedDate": "2020-12-11T06:20:10Z", "type": "commit"}]}