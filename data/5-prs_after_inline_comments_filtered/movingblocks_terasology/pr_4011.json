{"pr_number": 4011, "pr_title": "feat(JOML): BlockRegion replacement for Region3i", "pr_createdAt": "2020-05-31T16:49:04Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4011", "timeline": [{"oid": "1b31a9b64cfb8796c67955b3753995a882244cbb", "url": "https://github.com/MovingBlocks/Terasology/commit/1b31a9b64cfb8796c67955b3753995a882244cbb", "message": "feat(JOML): BlockRegion repalcment for Region3i", "committedDate": "2020-05-18T06:14:32Z", "type": "commit"}, {"oid": "da755bfbabbfc44f989cc1239e1749bb021b64ef", "url": "https://github.com/MovingBlocks/Terasology/commit/da755bfbabbfc44f989cc1239e1749bb021b64ef", "message": "updated block region", "committedDate": "2020-05-19T00:07:14Z", "type": "commit"}, {"oid": "26b9226d44a09312d4e0d9bc303d90526af2d35a", "url": "https://github.com/MovingBlocks/Terasology/commit/26b9226d44a09312d4e0d9bc303d90526af2d35a", "message": "fixed formatting", "committedDate": "2020-05-19T02:12:21Z", "type": "commit"}, {"oid": "21858f0e5d06614899c94b328e91388c63684e94", "url": "https://github.com/MovingBlocks/Terasology/commit/21858f0e5d06614899c94b328e91388c63684e94", "message": "updated BlockRegion", "committedDate": "2020-05-20T21:28:07Z", "type": "commit"}, {"oid": "a787012690ed6b620452066dc428726640ca5bdf", "url": "https://github.com/MovingBlocks/Terasology/commit/a787012690ed6b620452066dc428726640ca5bdf", "message": "updated javadocs", "committedDate": "2020-05-20T23:02:31Z", "type": "commit"}, {"oid": "f27d8ccc0265f9fe746cc6b70074e74687c772a6", "url": "https://github.com/MovingBlocks/Terasology/commit/f27d8ccc0265f9fe746cc6b70074e74687c772a6", "message": "correct iterable for BlockRegion", "committedDate": "2020-05-20T23:04:00Z", "type": "commit"}, {"oid": "d1c593d36734ebe3553d511cfa4feb96eea5be59", "url": "https://github.com/MovingBlocks/Terasology/commit/d1c593d36734ebe3553d511cfa4feb96eea5be59", "message": "corrected usecase in test", "committedDate": "2020-05-20T23:06:36Z", "type": "commit"}, {"oid": "60d95dfdc671386573acfff3166f2a6eb280caee", "url": "https://github.com/MovingBlocks/Terasology/commit/60d95dfdc671386573acfff3166f2a6eb280caee", "message": "correct gradle version", "committedDate": "2020-05-31T16:41:48Z", "type": "commit"}, {"oid": "72d563b003dd04a084bf924184a973b53cb83afe", "url": "https://github.com/MovingBlocks/Terasology/commit/72d563b003dd04a084bf924184a973b53cb83afe", "message": "Merge branch 'develop' into feature/block-region-2", "committedDate": "2020-05-31T16:51:15Z", "type": "commit"}, {"oid": "f2d23249831c3131e26b31d6b68342a9c5cc1780", "url": "https://github.com/MovingBlocks/Terasology/commit/f2d23249831c3131e26b31d6b68342a9c5cc1780", "message": "tweak build.gradle", "committedDate": "2020-05-31T16:53:29Z", "type": "commit"}, {"oid": "5e65a17c7a717ee4fc5a7eb8f4537a6d16cb3dea", "url": "https://github.com/MovingBlocks/Terasology/commit/5e65a17c7a717ee4fc5a7eb8f4537a6d16cb3dea", "message": "Merge branch 'feature/block-region-2' of github.com:pollend/Terasology into feature/block-region-2", "committedDate": "2020-05-31T16:54:43Z", "type": "commit"}, {"oid": "8839dcbbaef464013e0502a227be3713b678fd53", "url": "https://github.com/MovingBlocks/Terasology/commit/8839dcbbaef464013e0502a227be3713b678fd53", "message": "Merge branch 'develop' into feature/block-region-2", "committedDate": "2020-06-03T23:13:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyNzY5Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r437227692", "bodyText": "The method name shoud be adjusted:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testRegionEmptyIfMaxLessThanMin() {\n          \n          \n            \n                public void testRegionInvalidIfMaxLessThanMin() {", "author": "kBlaszczyk", "createdAt": "2020-06-09T08:27:37Z", "path": "engine-tests/src/test/java/org/terasology/math/BlockRegionTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2013 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.terasology.math;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.AABBi;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.junit.jupiter.api.Test;\n+import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegionIterable;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ *\n+ */\n+public class BlockRegionTest {\n+\n+\n+    @Test\n+    public void testCreateRegionWithMinAndSize() {\n+        List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5));\n+        List<Vector3i> size = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2));\n+        List<Vector3i> expectedMax = Arrays.asList(new Vector3i(), new Vector3i(3, 3, 3), new Vector3i(10, 8, 6));\n+\n+        for (int i = 0; i < mins.size(); ++i) {\n+            BlockRegion region = new BlockRegion().setMin(mins.get(i)).setSize(size.get(i));\n+            assertEquals(mins.get(i), region.getMin(new Vector3i()));\n+            assertEquals(size.get(i), region.getSize(new Vector3i()));\n+            assertEquals(expectedMax.get(i), region.getMax(new Vector3i()));\n+        }\n+    }\n+\n+    @Test\n+    public void testCreateRegionWithMinMax() {\n+        List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5));\n+        List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2));\n+        List<Vector3i> max = Arrays.asList(new Vector3i(), new Vector3i(3, 3, 3), new Vector3i(10, 8, 6));\n+        for (int i = 0; i < mins.size(); ++i) {\n+            BlockRegion region = new BlockRegion(mins.get(i), max.get(i));\n+            assertEquals(mins.get(i), region.getMin(new Vector3i()));\n+            assertEquals(max.get(i), region.getMax(new Vector3i()));\n+            assertEquals(expectedSize.get(i), region.getSize(new Vector3i()));\n+        }\n+    }\n+\n+    @Test\n+    public void testCreateRegionWithBounds() {\n+        BlockRegion expectedRegion = new BlockRegion(new Vector3i(-2, 4, -16), new Vector3i(4, 107, 0));\n+        List<Vector3i> vec1 = Arrays.asList(new Vector3i(-2, 4, -16), new Vector3i(4, 4, -16), new Vector3i(-2, 107, -16), new Vector3i(-2, 4, 0),\n+            new Vector3i(4, 107, -16), new Vector3i(4, 4, 0), new Vector3i(-2, 107, 0), new Vector3i(4, 107, 0));\n+        List<Vector3i> vec2 = Arrays.asList(new Vector3i(4, 107, 0), new Vector3i(-2, 107, 0), new Vector3i(4, 4, 0), new Vector3i(4, 107, -16),\n+            new Vector3i(-2, 4, 0), new Vector3i(-2, 107, -16), new Vector3i(4, 4, -16), new Vector3i(-2, 4, -16));\n+        for (int i = 0; i < vec1.size(); ++i) {\n+            BlockRegion target = new BlockRegion().union(vec1.get(i)).union(vec2.get(i));\n+            assertEquals(expectedRegion, target);\n+        }\n+    }\n+\n+    @Test\n+    public void testRegionEmptyIfMaxLessThanMin() {", "originalCommit": "8839dcbbaef464013e0502a227be3713b678fd53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzMTQxOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r437231419", "bodyText": "Either reintroduce the method to test a BlockRegion for being empty (which I would prefer), or remove this method. It doesn't actually check for emptiness and the isValid() check is just like the one in the previous method.\nBut I would prefer reintroducing isEmpty() and then turning this method into testRegionEmptyIfSizeZero().", "author": "kBlaszczyk", "createdAt": "2020-06-09T08:33:20Z", "path": "engine-tests/src/test/java/org/terasology/math/BlockRegionTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2013 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.terasology.math;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.AABBi;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.junit.jupiter.api.Test;\n+import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegionIterable;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ *\n+ */\n+public class BlockRegionTest {\n+\n+\n+    @Test\n+    public void testCreateRegionWithMinAndSize() {\n+        List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5));\n+        List<Vector3i> size = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2));\n+        List<Vector3i> expectedMax = Arrays.asList(new Vector3i(), new Vector3i(3, 3, 3), new Vector3i(10, 8, 6));\n+\n+        for (int i = 0; i < mins.size(); ++i) {\n+            BlockRegion region = new BlockRegion().setMin(mins.get(i)).setSize(size.get(i));\n+            assertEquals(mins.get(i), region.getMin(new Vector3i()));\n+            assertEquals(size.get(i), region.getSize(new Vector3i()));\n+            assertEquals(expectedMax.get(i), region.getMax(new Vector3i()));\n+        }\n+    }\n+\n+    @Test\n+    public void testCreateRegionWithMinMax() {\n+        List<Vector3i> mins = Arrays.asList(new Vector3i(), new Vector3i(1, 1, 1), new Vector3i(3, 4, 5));\n+        List<Vector3i> expectedSize = Arrays.asList(new Vector3i(1, 1, 1), new Vector3i(3, 3, 3), new Vector3i(8, 5, 2));\n+        List<Vector3i> max = Arrays.asList(new Vector3i(), new Vector3i(3, 3, 3), new Vector3i(10, 8, 6));\n+        for (int i = 0; i < mins.size(); ++i) {\n+            BlockRegion region = new BlockRegion(mins.get(i), max.get(i));\n+            assertEquals(mins.get(i), region.getMin(new Vector3i()));\n+            assertEquals(max.get(i), region.getMax(new Vector3i()));\n+            assertEquals(expectedSize.get(i), region.getSize(new Vector3i()));\n+        }\n+    }\n+\n+    @Test\n+    public void testCreateRegionWithBounds() {\n+        BlockRegion expectedRegion = new BlockRegion(new Vector3i(-2, 4, -16), new Vector3i(4, 107, 0));\n+        List<Vector3i> vec1 = Arrays.asList(new Vector3i(-2, 4, -16), new Vector3i(4, 4, -16), new Vector3i(-2, 107, -16), new Vector3i(-2, 4, 0),\n+            new Vector3i(4, 107, -16), new Vector3i(4, 4, 0), new Vector3i(-2, 107, 0), new Vector3i(4, 107, 0));\n+        List<Vector3i> vec2 = Arrays.asList(new Vector3i(4, 107, 0), new Vector3i(-2, 107, 0), new Vector3i(4, 4, 0), new Vector3i(4, 107, -16),\n+            new Vector3i(-2, 4, 0), new Vector3i(-2, 107, -16), new Vector3i(4, 4, -16), new Vector3i(-2, 4, -16));\n+        for (int i = 0; i < vec1.size(); ++i) {\n+            BlockRegion target = new BlockRegion().union(vec1.get(i)).union(vec2.get(i));\n+            assertEquals(expectedRegion, target);\n+        }\n+    }\n+\n+    @Test\n+    public void testRegionEmptyIfMaxLessThanMin() {\n+        BlockRegion region = new BlockRegion(new Vector3i(0, 0, 0), new Vector3i(-1, 0, 0));\n+        assertFalse(region.isValid());\n+    }\n+\n+    @Test\n+    public void testRegionEmptyIfSizeZeroOrLess() {", "originalCommit": "8839dcbbaef464013e0502a227be3713b678fd53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MzU1Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r438573552", "bodyText": "probably just get rid of empty. we just used empty to test if the region is valid.", "author": "pollend", "createdAt": "2020-06-11T06:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzMTQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMjc0NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r438632744", "bodyText": "Alright, I agree.", "author": "kBlaszczyk", "createdAt": "2020-06-11T08:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzMTQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MjA5MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r437242090", "bodyText": "The old implementation didn't have this method, which suggests that the engine has no use for it.\nIntroducing a method simply because the backing Joml object provides it is bad practice IMO.\nOur interface should be as slim as necessary.", "author": "kBlaszczyk", "createdAt": "2020-06-09T08:50:02Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.world.block;\n+\n+import org.joml.AABBf;\n+import org.joml.AABBi;\n+import org.joml.Intersectionf;\n+import org.joml.LineSegmentf;\n+import org.joml.Math;\n+import org.joml.Matrix4fc;\n+import org.joml.Planef;\n+import org.joml.Rayf;\n+import org.joml.RoundingMode;\n+import org.joml.Spheref;\n+import org.joml.Vector2f;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.terasology.entitySystem.entity.EntityRef;\n+\n+/**\n+ * is a bounded box describing blocks contained within.\n+ * A {@link BlockRegion} is described and backed by an {@link AABBi}\n+ */\n+public class BlockRegion {\n+\n+    /**\n+     * AABB region that backs a BlockRegion\n+     */\n+    public final AABBi aabb = new AABBi();\n+\n+    public BlockRegion() {\n+    }\n+\n+    public BlockRegion(BlockRegion source) {\n+        aabb.set(source.aabb);\n+    }\n+\n+    public BlockRegion(AABBi source) {\n+        aabb.set(source);\n+    }\n+\n+    public BlockRegion(Vector3ic min, Vector3ic max) {\n+        this(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n+    }\n+\n+    public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        this.setMin(minX, minY, minZ).setMax(maxX, maxY, maxZ);\n+    }\n+\n+    /**\n+     * Get the minimum block coordinate of the given component.\n+     *\n+     * @param component the component, within <code>[0..2]</code>\n+     * @return the maximum coordinate\n+     * @throws IllegalArgumentException if <code>component</code> is not within <code>[0..2]</code>\n+     */\n+    public int getMin(int component) throws IllegalArgumentException {", "originalCommit": "8839dcbbaef464013e0502a227be3713b678fd53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI2MjI3MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r437262271", "bodyText": "I guess we can't use the Joml-object to do the calculation due to the \"Max + 1\"-circumstance.\nBut what's the rational behind not using Math.min()/max()? Is it supposed to be faster not to have the function call?\nThis implementation surely is more error-prone.", "author": "kBlaszczyk", "createdAt": "2020-06-09T09:17:41Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.world.block;\n+\n+import org.joml.AABBf;\n+import org.joml.AABBi;\n+import org.joml.Intersectionf;\n+import org.joml.LineSegmentf;\n+import org.joml.Math;\n+import org.joml.Matrix4fc;\n+import org.joml.Planef;\n+import org.joml.Rayf;\n+import org.joml.RoundingMode;\n+import org.joml.Spheref;\n+import org.joml.Vector2f;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.terasology.entitySystem.entity.EntityRef;\n+\n+/**\n+ * is a bounded box describing blocks contained within.\n+ * A {@link BlockRegion} is described and backed by an {@link AABBi}\n+ */\n+public class BlockRegion {\n+\n+    /**\n+     * AABB region that backs a BlockRegion\n+     */\n+    public final AABBi aabb = new AABBi();\n+\n+    public BlockRegion() {\n+    }\n+\n+    public BlockRegion(BlockRegion source) {\n+        aabb.set(source.aabb);\n+    }\n+\n+    public BlockRegion(AABBi source) {\n+        aabb.set(source);\n+    }\n+\n+    public BlockRegion(Vector3ic min, Vector3ic max) {\n+        this(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n+    }\n+\n+    public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        this.setMin(minX, minY, minZ).setMax(maxX, maxY, maxZ);\n+    }\n+\n+    /**\n+     * Get the minimum block coordinate of the given component.\n+     *\n+     * @param component the component, within <code>[0..2]</code>\n+     * @return the maximum coordinate\n+     * @throws IllegalArgumentException if <code>component</code> is not within <code>[0..2]</code>\n+     */\n+    public int getMin(int component) throws IllegalArgumentException {\n+        return aabb.getMin(component);\n+    }\n+\n+    /**\n+     * get the minimum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getMin(Vector3i dest) {\n+        return dest.set(aabb.minX, aabb.minY, aabb.minZ);\n+    }\n+\n+\n+    /**\n+     * Get the maximum block coordinate of the given component.\n+     *\n+     * @param component the component, within <code>[0..2]</code>\n+     * @return the maximum coordinate\n+     * @throws IllegalArgumentException if <code>component</code> is not within <code>[0..2]</code>\n+     */\n+    public int getMax(int component) throws IllegalArgumentException {\n+        return aabb.getMax(component) - 1;\n+    }\n+\n+    /**\n+     * get the maximum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getMax(Vector3i dest) {\n+        return dest.set(aabb.maxX - 1, aabb.maxY - 1, aabb.maxZ - 1);\n+    }\n+    /**\n+     * the maximum coordinate of the second block x\n+     * @return the minimum coordinate x\n+     */\n+    public int getMaxX() {\n+        return this.aabb.maxX - 1;\n+    }\n+    /**\n+     * the maximum coordinate of the second block y\n+     * @return the minimum coordinate y\n+     */\n+    public int getMaxY() {\n+        return this.aabb.maxY - 1;\n+    }\n+    /**\n+     * the maximum coordinate of the second block z\n+     * @return the minimum coordinate z\n+     */\n+    public int getMaxZ() {\n+        return this.aabb.maxZ - 1;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block x\n+     * @return the minimum coordinate x\n+     */\n+    public int getMinX() {\n+        return this.aabb.minX;\n+    }\n+    /**\n+     * the minimum coordinate of the first block y\n+     * @return the minimum coordinate y\n+     */\n+    public int getMinY() {\n+        return this.aabb.minY;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block z\n+     * @return the minimum coordinate z\n+     */\n+    public int getMinZ() {\n+        return this.aabb.minZ;\n+    }\n+\n+    /**\n+     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param min the first coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMin(Vector3ic min) {\n+        this.aabb.setMin(min);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param max the second coordinate of the second block\n+     * @return this\n+     */\n+    public BlockRegion setMax(Vector3ic max) {\n+        this.setMax(max.x(), max.y(), max.z());\n+        return this;\n+    }\n+\n+    /**\n+     * sets the maximum block for this {@link BlockRegion}\n+     *\n+     * @param maxX the x coordinate of the first block\n+     * @param maxY the y coordinate of the first block\n+     * @param maxZ the z coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n+        this.aabb.setMax(maxX + 1, maxY + 1, maxZ + 1);\n+        return this;\n+    }\n+\n+    /**\n+     * sets the minimum block for this {@link BlockRegion}\n+     *\n+     * @param minX the x coordinate of the first block\n+     * @param minY the y coordinate of the first block\n+     * @param minZ the z coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        aabb.setMin(minX, minY, minZ);\n+        return this;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given {@link EntityRef} associated with a block <code>p</code>.\n+     * @param blockRef entityRef that describes a block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(EntityRef blockRef, BlockRegion dest) {\n+        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n+        if (component != null) {\n+            return this.union(component.position.x(), component.position.y(), component.position.z(), dest);\n+        }\n+        return dest;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n+     *\n+     * @param p the position of the block\n+     * @return this\n+     */\n+    public BlockRegion union(Vector3ic p) {\n+        return union(p.x(), p.y(), p.z(), this);\n+    }\n+\n+    /**\n+     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in <code>dest</code>\n+     *\n+     * @param x    the x coordinate of the block\n+     * @param y    the y coordinate of the block\n+     * @param z    the z coordinate of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        // a block is (x,y,z) and (x + 1, y + 1, z + 1)\n+        dest.aabb.minX = this.aabb.minX < x ? this.aabb.minX : x;", "originalCommit": "8839dcbbaef464013e0502a227be3713b678fd53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMwNTgyNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r437305825", "bodyText": "The validate() method makes invalid regions even more invalid and leaves valid regions untouched.\nI don't see the point of this. The client has to check if the region is still valid after calling addExtents(). In case addExtents() invalidated the region, isValid() already returns false, therefore the additional invalidation is unnecessary, which makes this method obsolete.", "author": "kBlaszczyk", "createdAt": "2020-06-09T10:27:00Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.world.block;\n+\n+import org.joml.AABBf;\n+import org.joml.AABBi;\n+import org.joml.Intersectionf;\n+import org.joml.LineSegmentf;\n+import org.joml.Math;\n+import org.joml.Matrix4fc;\n+import org.joml.Planef;\n+import org.joml.Rayf;\n+import org.joml.RoundingMode;\n+import org.joml.Spheref;\n+import org.joml.Vector2f;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.terasology.entitySystem.entity.EntityRef;\n+\n+/**\n+ * is a bounded box describing blocks contained within.\n+ * A {@link BlockRegion} is described and backed by an {@link AABBi}\n+ */\n+public class BlockRegion {\n+\n+    /**\n+     * AABB region that backs a BlockRegion\n+     */\n+    public final AABBi aabb = new AABBi();\n+\n+    public BlockRegion() {\n+    }\n+\n+    public BlockRegion(BlockRegion source) {\n+        aabb.set(source.aabb);\n+    }\n+\n+    public BlockRegion(AABBi source) {\n+        aabb.set(source);\n+    }\n+\n+    public BlockRegion(Vector3ic min, Vector3ic max) {\n+        this(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n+    }\n+\n+    public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        this.setMin(minX, minY, minZ).setMax(maxX, maxY, maxZ);\n+    }\n+\n+    /**\n+     * Get the minimum block coordinate of the given component.\n+     *\n+     * @param component the component, within <code>[0..2]</code>\n+     * @return the maximum coordinate\n+     * @throws IllegalArgumentException if <code>component</code> is not within <code>[0..2]</code>\n+     */\n+    public int getMin(int component) throws IllegalArgumentException {\n+        return aabb.getMin(component);\n+    }\n+\n+    /**\n+     * get the minimum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getMin(Vector3i dest) {\n+        return dest.set(aabb.minX, aabb.minY, aabb.minZ);\n+    }\n+\n+\n+    /**\n+     * Get the maximum block coordinate of the given component.\n+     *\n+     * @param component the component, within <code>[0..2]</code>\n+     * @return the maximum coordinate\n+     * @throws IllegalArgumentException if <code>component</code> is not within <code>[0..2]</code>\n+     */\n+    public int getMax(int component) throws IllegalArgumentException {\n+        return aabb.getMax(component) - 1;\n+    }\n+\n+    /**\n+     * get the maximum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getMax(Vector3i dest) {\n+        return dest.set(aabb.maxX - 1, aabb.maxY - 1, aabb.maxZ - 1);\n+    }\n+    /**\n+     * the maximum coordinate of the second block x\n+     * @return the minimum coordinate x\n+     */\n+    public int getMaxX() {\n+        return this.aabb.maxX - 1;\n+    }\n+    /**\n+     * the maximum coordinate of the second block y\n+     * @return the minimum coordinate y\n+     */\n+    public int getMaxY() {\n+        return this.aabb.maxY - 1;\n+    }\n+    /**\n+     * the maximum coordinate of the second block z\n+     * @return the minimum coordinate z\n+     */\n+    public int getMaxZ() {\n+        return this.aabb.maxZ - 1;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block x\n+     * @return the minimum coordinate x\n+     */\n+    public int getMinX() {\n+        return this.aabb.minX;\n+    }\n+    /**\n+     * the minimum coordinate of the first block y\n+     * @return the minimum coordinate y\n+     */\n+    public int getMinY() {\n+        return this.aabb.minY;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block z\n+     * @return the minimum coordinate z\n+     */\n+    public int getMinZ() {\n+        return this.aabb.minZ;\n+    }\n+\n+    /**\n+     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param min the first coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMin(Vector3ic min) {\n+        this.aabb.setMin(min);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param max the second coordinate of the second block\n+     * @return this\n+     */\n+    public BlockRegion setMax(Vector3ic max) {\n+        this.setMax(max.x(), max.y(), max.z());\n+        return this;\n+    }\n+\n+    /**\n+     * sets the maximum block for this {@link BlockRegion}\n+     *\n+     * @param maxX the x coordinate of the first block\n+     * @param maxY the y coordinate of the first block\n+     * @param maxZ the z coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n+        this.aabb.setMax(maxX + 1, maxY + 1, maxZ + 1);\n+        return this;\n+    }\n+\n+    /**\n+     * sets the minimum block for this {@link BlockRegion}\n+     *\n+     * @param minX the x coordinate of the first block\n+     * @param minY the y coordinate of the first block\n+     * @param minZ the z coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        aabb.setMin(minX, minY, minZ);\n+        return this;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given {@link EntityRef} associated with a block <code>p</code>.\n+     * @param blockRef entityRef that describes a block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(EntityRef blockRef, BlockRegion dest) {\n+        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n+        if (component != null) {\n+            return this.union(component.position.x(), component.position.y(), component.position.z(), dest);\n+        }\n+        return dest;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n+     *\n+     * @param p the position of the block\n+     * @return this\n+     */\n+    public BlockRegion union(Vector3ic p) {\n+        return union(p.x(), p.y(), p.z(), this);\n+    }\n+\n+    /**\n+     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in <code>dest</code>\n+     *\n+     * @param x    the x coordinate of the block\n+     * @param y    the y coordinate of the block\n+     * @param z    the z coordinate of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        // a block is (x,y,z) and (x + 1, y + 1, z + 1)\n+        dest.aabb.minX = this.aabb.minX < x ? this.aabb.minX : x;\n+        dest.aabb.minY = this.aabb.minY < y ? this.aabb.minY : y;\n+        dest.aabb.minZ = this.aabb.minZ < z ? this.aabb.minZ : z;\n+        dest.aabb.maxX = this.aabb.maxX > (x + 1) ? this.aabb.maxX : (x + 1);\n+        dest.aabb.maxY = this.aabb.maxY > (y + 1) ? this.aabb.maxY : (y + 1);\n+        dest.aabb.maxZ = this.aabb.maxZ > (z + 1) ? this.aabb.maxZ : (z + 1);\n+        return dest;\n+    }\n+\n+    /**\n+     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and store the result in <code>dest</code>.\n+     * @param pos the position of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(Vector3ic pos, BlockRegion dest) {\n+        return this.union(pos.x(), pos.y(), pos.z(), dest);\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other {@link BlockRegion}\n+     * @return this\n+     */\n+    public BlockRegion union(BlockRegion other) {\n+        return this.union(other.aabb);\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other {@link AABBi}\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(AABBi other, BlockRegion dest) {\n+        dest.union(other);\n+        return dest;\n+    }\n+\n+    /**\n+     *  Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other the other {@link AABBi}\n+     * @return this\n+     */\n+    public BlockRegion union(AABBi other) {\n+        this.aabb.union(other);\n+        return this;\n+    }\n+\n+    /**\n+     * Ensure that the minimum coordinates are strictly less than or equal to the maximum coordinates by swapping\n+     * them if necessary.\n+     *\n+     * @return this\n+     */\n+    public BlockRegion correctBounds() {\n+        this.aabb.correctBounds();\n+        return this;\n+    }\n+\n+    /**\n+     * set the size of the block region from minimum.\n+     * @param x the x coordinate to set the size\n+     * @param y the y coordinate to set the size\n+     * @param z the z coordinate to set the size\n+     * @return this\n+     */\n+    public BlockRegion setSize(int x, int y, int z) {\n+        this.aabb.maxX = this.aabb.minX + x;\n+        this.aabb.maxY = this.aabb.minY + y;\n+        this.aabb.maxZ = this.aabb.minZ + z;\n+        return this;\n+    }\n+\n+    /**\n+     * set the size of the block region from minimum.\n+     * @param size the size to set the {@link BlockRegion}\n+     * @return this\n+     */\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n+    }\n+\n+    /**\n+     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getSize(Vector3i dest) {\n+        return dest.set(this.aabb.maxX - this.aabb.minX, this.aabb.maxY - this.aabb.minY, this.aabb.maxZ - this.aabb.minZ);\n+    }\n+\n+    /**\n+     * The number of blocks on the X axis\n+     *\n+     * @return number of blocks in the X axis\n+     */\n+    public int getSizeX() {\n+        return this.aabb.maxX - this.aabb.minX;\n+    }\n+\n+    /**\n+     * The number of blocks on the Y axis\n+     *\n+     * @return number of blocks in the Y axis\n+     */\n+    public int getSizeY() {\n+        return this.aabb.maxY - this.aabb.minY;\n+    }\n+\n+    /**\n+     * The number of blocks on the Z axis\n+     *\n+     * @return number of blocks in the Z axis\n+     */\n+    public int getSizeZ() {\n+        return this.aabb.maxZ - this.aabb.minZ;\n+    }\n+\n+    /**\n+     * Translate <code>this</code> by the given vector <code>xyz</code>.\n+     * @param x  the x coordinate to translate by\n+     * @param y  the y coordinate to translate by\n+     * @param z  the z coordinate to translate by\n+     * @return this\n+     */\n+    public BlockRegion translate(int x, int y, int z) {\n+        aabb.translate(x, y, z);\n+        return this;\n+    }\n+\n+    /**\n+     * Translate <code>this</code> by the given vector <code>xyz</code>.\n+     * @param xyz  the vector to translate by\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion translate(Vector3ic xyz, BlockRegion dest) {\n+        aabb.translate(xyz, dest.aabb);\n+        return dest;\n+    }\n+\n+    /**\n+     * Translate <code>this</code> by the given vector <code>xyz</code>.\n+     *\n+     * @param xyz\n+     *          the vector to translate by\n+     * @return this\n+     */\n+    public BlockRegion translate(Vector3ic xyz) {\n+        this.aabb.translate(xyz);\n+        return this;\n+    }\n+\n+    /**\n+     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n+     * <p>\n+     * The matrix in <code>m</code> <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n+     *\n+     * @param m\n+     *          the affine transformation matrix\n+     * @return this\n+     */\n+    public BlockRegion transform(Matrix4fc m) {\n+        this.aabb.transform(m);\n+        return this;\n+    }\n+\n+    /**\n+     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n+     * <p>\n+     * The matrix in <code>m</code> <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n+     *\n+     * @param m\n+     *          the affine transformation matrix\n+     * @return this\n+     */\n+    public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n+        this.aabb.transform(m, dest.aabb);\n+        return dest;\n+    }\n+\n+    /**\n+     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n+     *\n+     * @param pos  the coordinates of the block\n+     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n+     */\n+    public boolean containsBlock(Vector3ic pos) {\n+        return containsBlock(pos.x(), pos.y(), pos.z());\n+    }\n+\n+    /**\n+     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n+     *\n+     * @param x\n+     *          the x coordinate of the point\n+     * @param y\n+     *          the y coordinate of the point\n+     * @param z\n+     *          the z coordinate of the point\n+     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n+     */\n+    public boolean containsBlock(int x, int y, int z) {\n+        return x >= aabb.minX && y >= aabb.minY && z >= aabb.minZ && x < aabb.maxX && y < aabb.maxY && z < aabb.maxZ;\n+    }\n+\n+    /**\n+     * Test whether the point <code>(x, y, z)</code> lies inside this BlockRegion.\n+     *\n+     * @param x\n+     *          the x coordinate of the point\n+     * @param y\n+     *          the y coordinate of the point\n+     * @param z\n+     *          the z coordinate of the point\n+     * @return <code>true</code> iff the given point lies inside this BlockRegion; <code>false</code> otherwise\n+     */\n+    public boolean containsPoint(float x, float y, float z) {\n+        return this.aabb.containsPoint(x, y, z);\n+    }\n+\n+    /**\n+     * Test whether the point <code>(x, y, z)</code> lies inside this AABB.\n+     *\n+     * @param x\n+     *          the x coordinate of the point\n+     * @param y\n+     *          the y coordinate of the point\n+     * @param z\n+     *          the z coordinate of the point\n+     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n+     */\n+    public boolean containsPoint(int x, int y, int z) {\n+        return this.aabb.containsPoint(x, y, z);\n+    }\n+\n+    /**\n+     * Test whether the given point lies inside this AABB.\n+     *\n+     * @param point\n+     *          the coordinates of the point\n+     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n+     */\n+    public boolean containsPoint(Vector3ic point) {\n+        return this.aabb.containsPoint(point);\n+    }\n+\n+    /**\n+     * Test whether the given point lies inside this AABB.\n+     *\n+     * @param point\n+     *          the coordinates of the point\n+     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n+     */\n+    public boolean containsPoint(Vector3fc point) {\n+        return this.aabb.containsPoint(point);\n+    }\n+\n+    /**\n+     * Test whether the plane given via its plane equation <code>a*x + b*y + c*z + d = 0</code> intersects this AABB.\n+     * <p>\n+     * Reference: <a href=\"http://www.lighthouse3d.com/tutorials/view-frustum-culling/geometric-approach-testing-boxes-ii/\">http://www.lighthouse3d.com</a> (\"Geometric Approach - Testing Boxes II\")\n+     *\n+     * @param a\n+     *          the x factor in the plane equation\n+     * @param b\n+     *          the y factor in the plane equation\n+     * @param c\n+     *          the z factor in the plane equation\n+     * @param d\n+     *          the constant in the plane equation\n+     * @return <code>true</code> iff the plane intersects this AABB; <code>false</code> otherwise\n+     */\n+    public boolean intersectsPlane(float a, float b, float c, float d) {\n+        return this.aabb.intersectsPlane(a, b, c, d);\n+    }\n+\n+    /**\n+     * Test whether the given plane intersects this AABB.\n+     * <p>\n+     * Reference: <a href=\"http://www.lighthouse3d.com/tutorials/view-frustum-culling/geometric-approach-testing-boxes-ii/\">http://www.lighthouse3d.com</a> (\"Geometric Approach - Testing Boxes II\")\n+     *\n+     * @param plane\n+     *          the plane\n+     * @return <code>true</code> iff the plane intersects this AABB; <code>false</code> otherwise\n+     */\n+    public boolean intersectsPlane(Planef plane) {\n+        return this.aabb.intersectsPlane(plane);\n+    }\n+\n+    /**\n+     * Test whether <code>this</code> and <code>other</code> intersect.\n+     *\n+     * @param other\n+     *          the other BlockRegion\n+     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n+     */\n+    public boolean intersectsBlockRegion(BlockRegion other) {\n+        return this.aabb.intersectsAABB(other.aabb);\n+    }\n+\n+    /**\n+     * Test whether <code>this</code> and <code>other</code> intersect.\n+     *\n+     * @param other\n+     *          the other AABB\n+     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n+     */\n+    public boolean intersectsAABB(AABBi other) {\n+        return this.aabb.intersectsAABB(other);\n+    }\n+\n+    /**\n+     * Test whether <code>this</code> and <code>other</code> intersect.\n+     *\n+     * @param other\n+     *          the other AABB\n+     * @return <code>true</code> iff both AABBs intersect; <code>false</code> otherwise\n+     */\n+    public boolean intersectsAABB(AABBf other) {\n+        return this.aabb.intersectsAABB(other);\n+    }\n+\n+    /**\n+     * Test whether this AABB intersects the given sphere with equation\n+     * <code>(x - centerX)^2 + (y - centerY)^2 + (z - centerZ)^2 - radiusSquared = 0</code>.\n+     * <p>\n+     * Reference: <a href=\"http://stackoverflow.com/questions/4578967/cube-sphere-intersection-test#answer-4579069\">http://stackoverflow.com</a>\n+     *\n+     * @param centerX\n+     *          the x coordinate of the center of the sphere\n+     * @param centerY\n+     *          the y coordinate of the center of the sphere\n+     * @param centerZ\n+     *          the z coordinate of the center of the sphere\n+     * @param radiusSquared\n+     *          the square radius of the sphere\n+     * @return <code>true</code> iff this AABB and the sphere intersect; <code>false</code> otherwise\n+     */\n+    public boolean intersectsSphere(float centerX, float centerY, float centerZ, float radiusSquared) {\n+        return Intersectionf.testAabSphere(aabb.minX, aabb.minY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.maxZ, centerX, centerY, centerZ, radiusSquared);\n+    }\n+\n+    /**\n+     * Test whether this AABB intersects the given sphere.\n+     * <p>\n+     * Reference: <a href=\"http://stackoverflow.com/questions/4578967/cube-sphere-intersection-test#answer-4579069\">http://stackoverflow.com</a>\n+     *\n+     * @param sphere\n+     *          the sphere\n+     * @return <code>true</code> iff this AABB and the sphere intersect; <code>false</code> otherwise\n+     */\n+    public boolean intersectsSphere(Spheref sphere) {\n+        return Intersectionf.testAabSphere(aabb, sphere);\n+    }\n+\n+    /**\n+     * Test whether the given ray with the origin <code>(originX, originY, originZ)</code> and direction <code>(dirX, dirY, dirZ)</code>\n+     * intersects this AABB.\n+     * <p>\n+     * This method returns <code>true</code> for a ray whose origin lies inside this AABB.\n+     * <p>\n+     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n+     *\n+     * @param originX\n+     *          the x coordinate of the ray's origin\n+     * @param originY\n+     *          the y coordinate of the ray's origin\n+     * @param originZ\n+     *          the z coordinate of the ray's origin\n+     * @param dirX\n+     *          the x coordinate of the ray's direction\n+     * @param dirY\n+     *          the y coordinate of the ray's direction\n+     * @param dirZ\n+     *          the z coordinate of the ray's direction\n+     * @return <code>true</code> if this AABB and the ray intersect; <code>false</code> otherwise\n+     */\n+    public boolean intersectsRay(float originX, float originY, float originZ, float dirX, float dirY, float dirZ) {\n+        return Intersectionf.testRayAab(originX, originY, originZ, dirX, dirY, dirZ, aabb.minX, aabb.minY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.maxZ);\n+    }\n+\n+    /**\n+     * Test whether the given ray intersects this AABB.\n+     * <p>\n+     * This method returns <code>true</code> for a ray whose origin lies inside this AABB.\n+     * <p>\n+     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n+     *\n+     * @param ray\n+     *          the ray\n+     * @return <code>true</code> if this AABB and the ray intersect; <code>false</code> otherwise\n+     */\n+    public boolean intersectsRay(Rayf ray) {\n+        return Intersectionf.testRayAab(ray, aabb);\n+    }\n+\n+    /**\n+     * Determine whether the undirected line segment with the end points <code>(p0X, p0Y, p0Z)</code> and <code>(p1X, p1Y, p1Z)</code>\n+     * intersects this AABB, and return the values of the parameter <i>t</i> in the ray equation\n+     * <i>p(t) = origin + p0 * (p1 - p0)</i> of the near and far point of intersection.\n+     * <p>\n+     * This method returns <code>true</code> for a line segment whose either end point lies inside this AABB.\n+     * <p>\n+     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n+     *\n+     * @param p0X\n+     *              the x coordinate of the line segment's first end point\n+     * @param p0Y\n+     *              the y coordinate of the line segment's first end point\n+     * @param p0Z\n+     *              the z coordinate of the line segment's first end point\n+     * @param p1X\n+     *              the x coordinate of the line segment's second end point\n+     * @param p1Y\n+     *              the y coordinate of the line segment's second end point\n+     * @param p1Z\n+     *              the z coordinate of the line segment's second end point\n+     * @param result\n+     *              a vector which will hold the resulting values of the parameter\n+     *              <i>t</i> in the ray equation <i>p(t) = p0 + t * (p1 - p0)</i> of the near and far point of intersection\n+     *              iff the line segment intersects this AABB\n+     * @return {@link Intersectionf#INSIDE} if the line segment lies completely inside of this AABB; or\n+     *         {@link Intersectionf#OUTSIDE} if the line segment lies completely outside of this AABB; or\n+     *         {@link Intersectionf#ONE_INTERSECTION} if one of the end points of the line segment lies inside of this AABB; or\n+     *         {@link Intersectionf#TWO_INTERSECTION} if the line segment intersects two sides of this AABB or lies on an edge or a side of this AABB\n+     */\n+    public int intersectLineSegment(float p0X, float p0Y, float p0Z, float p1X, float p1Y, float p1Z, Vector2f result) {\n+        return Intersectionf.intersectLineSegmentAab(p0X, p0Y, p0Z, p1X, p1Y, p1Z, aabb.minX, aabb.minY, aabb.minZ, aabb.maxX, aabb.maxY, aabb.maxZ, result);\n+    }\n+\n+    /**\n+     * Determine whether the given undirected line segment intersects this AABB, and return the values of the parameter <i>t</i> in the ray equation\n+     * <i>p(t) = origin + p0 * (p1 - p0)</i> of the near and far point of intersection.\n+     * <p>\n+     * This method returns <code>true</code> for a line segment whose either end point lies inside this AABB.\n+     * <p>\n+     * Reference: <a href=\"https://dl.acm.org/citation.cfm?id=1198748\">An Efficient and Robust Ray\u2013Box Intersection</a>\n+     *\n+     * @param lineSegment\n+     *              the line segment\n+     * @param result\n+     *              a vector which will hold the resulting values of the parameter\n+     *              <i>t</i> in the ray equation <i>p(t) = p0 + t * (p1 - p0)</i> of the near and far point of intersection\n+     *              iff the line segment intersects this AABB\n+     * @return {@link Intersectionf#INSIDE} if the line segment lies completely inside of this AABB; or\n+     *         {@link Intersectionf#OUTSIDE} if the line segment lies completely outside of this AABB; or\n+     *         {@link Intersectionf#ONE_INTERSECTION} if one of the end points of the line segment lies inside of this AABB; or\n+     *         {@link Intersectionf#TWO_INTERSECTION} if the line segment intersects two sides of this AABB or lies on an edge or a side of this AABB\n+     */\n+    public int intersectLineSegment(LineSegmentf lineSegment, Vector2f result) {\n+        return Intersectionf.intersectLineSegmentAab(lineSegment, aabb, result);\n+    }\n+\n+    /**\n+     * Check whether <code>this</code> BlockRegion represents a valid BlockRegion.\n+     *\n+     * @return <code>true</code> iff this BlockRegion is valid; <code>false</code> otherwise\n+     */\n+    public boolean isValid() {\n+        return aabb.isValid();\n+    }\n+\n+    private BlockRegion validate() {", "originalCommit": "8839dcbbaef464013e0502a227be3713b678fd53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMxMTE0MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4011#discussion_r437311140", "bodyText": "Quite a few param-descriptions are unnecessarily split into two lines.", "author": "kBlaszczyk", "createdAt": "2020-06-09T10:37:06Z", "path": "engine/src/main/java/org/terasology/world/block/BlockRegion.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.world.block;\n+\n+import org.joml.AABBf;\n+import org.joml.AABBi;\n+import org.joml.Intersectionf;\n+import org.joml.LineSegmentf;\n+import org.joml.Math;\n+import org.joml.Matrix4fc;\n+import org.joml.Planef;\n+import org.joml.Rayf;\n+import org.joml.RoundingMode;\n+import org.joml.Spheref;\n+import org.joml.Vector2f;\n+import org.joml.Vector3fc;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.terasology.entitySystem.entity.EntityRef;\n+\n+/**\n+ * is a bounded box describing blocks contained within.\n+ * A {@link BlockRegion} is described and backed by an {@link AABBi}\n+ */\n+public class BlockRegion {\n+\n+    /**\n+     * AABB region that backs a BlockRegion\n+     */\n+    public final AABBi aabb = new AABBi();\n+\n+    public BlockRegion() {\n+    }\n+\n+    public BlockRegion(BlockRegion source) {\n+        aabb.set(source.aabb);\n+    }\n+\n+    public BlockRegion(AABBi source) {\n+        aabb.set(source);\n+    }\n+\n+    public BlockRegion(Vector3ic min, Vector3ic max) {\n+        this(min.x(), min.y(), min.z(), max.x(), max.y(), max.z());\n+    }\n+\n+    public BlockRegion(int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n+        this.setMin(minX, minY, minZ).setMax(maxX, maxY, maxZ);\n+    }\n+\n+    /**\n+     * Get the minimum block coordinate of the given component.\n+     *\n+     * @param component the component, within <code>[0..2]</code>\n+     * @return the maximum coordinate\n+     * @throws IllegalArgumentException if <code>component</code> is not within <code>[0..2]</code>\n+     */\n+    public int getMin(int component) throws IllegalArgumentException {\n+        return aabb.getMin(component);\n+    }\n+\n+    /**\n+     * get the minimum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getMin(Vector3i dest) {\n+        return dest.set(aabb.minX, aabb.minY, aabb.minZ);\n+    }\n+\n+\n+    /**\n+     * Get the maximum block coordinate of the given component.\n+     *\n+     * @param component the component, within <code>[0..2]</code>\n+     * @return the maximum coordinate\n+     * @throws IllegalArgumentException if <code>component</code> is not within <code>[0..2]</code>\n+     */\n+    public int getMax(int component) throws IllegalArgumentException {\n+        return aabb.getMax(component) - 1;\n+    }\n+\n+    /**\n+     * get the maximum block coordinate\n+     *\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getMax(Vector3i dest) {\n+        return dest.set(aabb.maxX - 1, aabb.maxY - 1, aabb.maxZ - 1);\n+    }\n+    /**\n+     * the maximum coordinate of the second block x\n+     * @return the minimum coordinate x\n+     */\n+    public int getMaxX() {\n+        return this.aabb.maxX - 1;\n+    }\n+    /**\n+     * the maximum coordinate of the second block y\n+     * @return the minimum coordinate y\n+     */\n+    public int getMaxY() {\n+        return this.aabb.maxY - 1;\n+    }\n+    /**\n+     * the maximum coordinate of the second block z\n+     * @return the minimum coordinate z\n+     */\n+    public int getMaxZ() {\n+        return this.aabb.maxZ - 1;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block x\n+     * @return the minimum coordinate x\n+     */\n+    public int getMinX() {\n+        return this.aabb.minX;\n+    }\n+    /**\n+     * the minimum coordinate of the first block y\n+     * @return the minimum coordinate y\n+     */\n+    public int getMinY() {\n+        return this.aabb.minY;\n+    }\n+\n+    /**\n+     * the minimum coordinate of the first block z\n+     * @return the minimum coordinate z\n+     */\n+    public int getMinZ() {\n+        return this.aabb.minZ;\n+    }\n+\n+    /**\n+     * Sets the minimum coordinate of the first block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param min the first coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMin(Vector3ic min) {\n+        this.aabb.setMin(min);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the maximum coordinate of the second block for <code>this</code> {@link BlockRegion}\n+     *\n+     * @param max the second coordinate of the second block\n+     * @return this\n+     */\n+    public BlockRegion setMax(Vector3ic max) {\n+        this.setMax(max.x(), max.y(), max.z());\n+        return this;\n+    }\n+\n+    /**\n+     * sets the maximum block for this {@link BlockRegion}\n+     *\n+     * @param maxX the x coordinate of the first block\n+     * @param maxY the y coordinate of the first block\n+     * @param maxZ the z coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMax(int maxX, int maxY, int maxZ) {\n+        this.aabb.setMax(maxX + 1, maxY + 1, maxZ + 1);\n+        return this;\n+    }\n+\n+    /**\n+     * sets the minimum block for this {@link BlockRegion}\n+     *\n+     * @param minX the x coordinate of the first block\n+     * @param minY the y coordinate of the first block\n+     * @param minZ the z coordinate of the first block\n+     * @return this\n+     */\n+    public BlockRegion setMin(int minX, int minY, int minZ) {\n+        aabb.setMin(minX, minY, minZ);\n+        return this;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given {@link EntityRef} associated with a block <code>p</code>.\n+     * @param blockRef entityRef that describes a block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(EntityRef blockRef, BlockRegion dest) {\n+        BlockComponent component = blockRef.getComponent(BlockComponent.class);\n+        if (component != null) {\n+            return this.union(component.position.x(), component.position.y(), component.position.z(), dest);\n+        }\n+        return dest;\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and the given block <code>p</code>.\n+     *\n+     * @param p the position of the block\n+     * @return this\n+     */\n+    public BlockRegion union(Vector3ic p) {\n+        return union(p.x(), p.y(), p.z(), this);\n+    }\n+\n+    /**\n+     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and stores the result in <code>dest</code>\n+     *\n+     * @param x    the x coordinate of the block\n+     * @param y    the y coordinate of the block\n+     * @param z    the z coordinate of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(int x, int y, int z, BlockRegion dest) {\n+        // a block is (x,y,z) and (x + 1, y + 1, z + 1)\n+        dest.aabb.minX = this.aabb.minX < x ? this.aabb.minX : x;\n+        dest.aabb.minY = this.aabb.minY < y ? this.aabb.minY : y;\n+        dest.aabb.minZ = this.aabb.minZ < z ? this.aabb.minZ : z;\n+        dest.aabb.maxX = this.aabb.maxX > (x + 1) ? this.aabb.maxX : (x + 1);\n+        dest.aabb.maxY = this.aabb.maxY > (y + 1) ? this.aabb.maxY : (y + 1);\n+        dest.aabb.maxZ = this.aabb.maxZ > (z + 1) ? this.aabb.maxZ : (z + 1);\n+        return dest;\n+    }\n+\n+    /**\n+     * Compute the union of <code>this</code> and the given block <code>(x, y, z)</code> and store the result in <code>dest</code>.\n+     * @param pos the position of the block\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(Vector3ic pos, BlockRegion dest) {\n+        return this.union(pos.x(), pos.y(), pos.z(), dest);\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other {@link BlockRegion}\n+     * @return this\n+     */\n+    public BlockRegion union(BlockRegion other) {\n+        return this.union(other.aabb);\n+    }\n+\n+    /**\n+     * Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other {@link AABBi}\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion union(AABBi other, BlockRegion dest) {\n+        dest.union(other);\n+        return dest;\n+    }\n+\n+    /**\n+     *  Set <code>this</code> to the union of <code>this</code> and <code>other</code>.\n+     *\n+     * @param other the other {@link AABBi}\n+     * @return this\n+     */\n+    public BlockRegion union(AABBi other) {\n+        this.aabb.union(other);\n+        return this;\n+    }\n+\n+    /**\n+     * Ensure that the minimum coordinates are strictly less than or equal to the maximum coordinates by swapping\n+     * them if necessary.\n+     *\n+     * @return this\n+     */\n+    public BlockRegion correctBounds() {\n+        this.aabb.correctBounds();\n+        return this;\n+    }\n+\n+    /**\n+     * set the size of the block region from minimum.\n+     * @param x the x coordinate to set the size\n+     * @param y the y coordinate to set the size\n+     * @param z the z coordinate to set the size\n+     * @return this\n+     */\n+    public BlockRegion setSize(int x, int y, int z) {\n+        this.aabb.maxX = this.aabb.minX + x;\n+        this.aabb.maxY = this.aabb.minY + y;\n+        this.aabb.maxZ = this.aabb.minZ + z;\n+        return this;\n+    }\n+\n+    /**\n+     * set the size of the block region from minimum.\n+     * @param size the size to set the {@link BlockRegion}\n+     * @return this\n+     */\n+    public BlockRegion setSize(Vector3ic size) {\n+        return setSize(size.x(), size.y(), size.z());\n+    }\n+\n+    /**\n+     * the number of blocks for the +x, +y, +z from the minimum to the maximum\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public Vector3i getSize(Vector3i dest) {\n+        return dest.set(this.aabb.maxX - this.aabb.minX, this.aabb.maxY - this.aabb.minY, this.aabb.maxZ - this.aabb.minZ);\n+    }\n+\n+    /**\n+     * The number of blocks on the X axis\n+     *\n+     * @return number of blocks in the X axis\n+     */\n+    public int getSizeX() {\n+        return this.aabb.maxX - this.aabb.minX;\n+    }\n+\n+    /**\n+     * The number of blocks on the Y axis\n+     *\n+     * @return number of blocks in the Y axis\n+     */\n+    public int getSizeY() {\n+        return this.aabb.maxY - this.aabb.minY;\n+    }\n+\n+    /**\n+     * The number of blocks on the Z axis\n+     *\n+     * @return number of blocks in the Z axis\n+     */\n+    public int getSizeZ() {\n+        return this.aabb.maxZ - this.aabb.minZ;\n+    }\n+\n+    /**\n+     * Translate <code>this</code> by the given vector <code>xyz</code>.\n+     * @param x  the x coordinate to translate by\n+     * @param y  the y coordinate to translate by\n+     * @param z  the z coordinate to translate by\n+     * @return this\n+     */\n+    public BlockRegion translate(int x, int y, int z) {\n+        aabb.translate(x, y, z);\n+        return this;\n+    }\n+\n+    /**\n+     * Translate <code>this</code> by the given vector <code>xyz</code>.\n+     * @param xyz  the vector to translate by\n+     * @param dest will hold the result\n+     * @return dest\n+     */\n+    public BlockRegion translate(Vector3ic xyz, BlockRegion dest) {\n+        aabb.translate(xyz, dest.aabb);\n+        return dest;\n+    }\n+\n+    /**\n+     * Translate <code>this</code> by the given vector <code>xyz</code>.\n+     *\n+     * @param xyz\n+     *          the vector to translate by\n+     * @return this\n+     */\n+    public BlockRegion translate(Vector3ic xyz) {\n+        this.aabb.translate(xyz);\n+        return this;\n+    }\n+\n+    /**\n+     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n+     * <p>\n+     * The matrix in <code>m</code> <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n+     *\n+     * @param m\n+     *          the affine transformation matrix\n+     * @return this\n+     */\n+    public BlockRegion transform(Matrix4fc m) {\n+        this.aabb.transform(m);\n+        return this;\n+    }\n+\n+    /**\n+     * Apply the given {@link Matrix4fc#isAffine() affine} transformation to this {@link BlockRegion}.\n+     * <p>\n+     * The matrix in <code>m</code> <i>must</i> be {@link Matrix4fc#isAffine() affine}.\n+     *\n+     * @param m\n+     *          the affine transformation matrix\n+     * @return this\n+     */\n+    public BlockRegion transform(Matrix4fc m, BlockRegion dest) {\n+        this.aabb.transform(m, dest.aabb);\n+        return dest;\n+    }\n+\n+    /**\n+     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n+     *\n+     * @param pos  the coordinates of the block\n+     * @return <code>true</code> iff the given point lies inside this AABB; <code>false</code> otherwise\n+     */\n+    public boolean containsBlock(Vector3ic pos) {\n+        return containsBlock(pos.x(), pos.y(), pos.z());\n+    }\n+\n+    /**\n+     * Test whether the block <code>(x, y, z)</code> lies inside this BlockRegion.\n+     *\n+     * @param x", "originalCommit": "8839dcbbaef464013e0502a227be3713b678fd53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f428cff3dede3148d3e0ee460277f021cc79d1d", "url": "https://github.com/MovingBlocks/Terasology/commit/3f428cff3dede3148d3e0ee460277f021cc79d1d", "message": "correct test and cleaned up code format", "committedDate": "2020-06-11T06:47:28Z", "type": "commit"}, {"oid": "f62fa46f39fe4c400cc82e250c764a7d543ae54a", "url": "https://github.com/MovingBlocks/Terasology/commit/f62fa46f39fe4c400cc82e250c764a7d543ae54a", "message": "remove extra spacing", "committedDate": "2020-06-11T06:52:00Z", "type": "commit"}]}