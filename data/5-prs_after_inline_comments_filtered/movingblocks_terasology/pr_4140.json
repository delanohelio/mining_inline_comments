{"pr_number": 4140, "pr_title": "Chunk provider refactoring. Part 2.", "pr_createdAt": "2020-09-03T20:52:48Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4140", "timeline": [{"oid": "3fdf220d59a853ec76907c290ae9cb1ea90abba8", "url": "https://github.com/MovingBlocks/Terasology/commit/3fdf220d59a853ec76907c290ae9cb1ea90abba8", "message": "refactor(chunkproviders): implement base asyncronious pipeline for chunk loading.\nImplement all ChunkTask.\nIntegrate AsyncPipeline for RemoteChunkProvider", "committedDate": "2020-08-29T19:16:57Z", "type": "commit"}, {"oid": "ed25d62fc0eec20e945e061021c6c2227e7e85a6", "url": "https://github.com/MovingBlocks/Terasology/commit/ed25d62fc0eec20e945e061021c6c2227e7e85a6", "message": "refactor(chunkprovider): Integrate async pipeline to LocalChunkProvider", "committedDate": "2020-08-30T19:21:13Z", "type": "commit"}, {"oid": "4c05be23dbf42881a1a4a4a067ecd47e9dc5c005", "url": "https://github.com/MovingBlocks/Terasology/commit/4c05be23dbf42881a1a4a4a067ecd47e9dc5c005", "message": "refactor(chunkprovider): fix entity queue and duplication chunks creating.", "committedDate": "2020-09-01T20:56:18Z", "type": "commit"}, {"oid": "a469679c5e3aed12b324ee22f505a3486245ce81", "url": "https://github.com/MovingBlocks/Terasology/commit/a469679c5e3aed12b324ee22f505a3486245ce81", "message": "refactor(chunkprovider): remove unused parameters, make lightmerger chunk task requirement waiter", "committedDate": "2020-09-02T15:00:43Z", "type": "commit"}, {"oid": "c611ae0a6fa6b95e62b7f0737f1e103b3ede0a00", "url": "https://github.com/MovingBlocks/Terasology/commit/c611ae0a6fa6b95e62b7f0737f1e103b3ede0a00", "message": "fix(chunkprovider): fix onDone(ChunkTask) listeners possition", "committedDate": "2020-09-03T08:16:17Z", "type": "commit"}, {"oid": "b2ff626ec2accd76f5c5389adf81f31fe26181f2", "url": "https://github.com/MovingBlocks/Terasology/commit/b2ff626ec2accd76f5c5389adf81f31fe26181f2", "message": "fix(chunkprovider): fix chunk unloading", "committedDate": "2020-09-03T08:29:48Z", "type": "commit"}, {"oid": "4d07728bb565cbe202475e27605dd299575970ab", "url": "https://github.com/MovingBlocks/Terasology/commit/4d07728bb565cbe202475e27605dd299575970ab", "message": "chore(chunkprovider): remove unused code. fix some methods positions. add sorting and nulls checks to LightMerger", "committedDate": "2020-09-03T08:48:30Z", "type": "commit"}, {"oid": "9e3ec8a66abf80508dfb7d880c32131a781cc6a2", "url": "https://github.com/MovingBlocks/Terasology/commit/9e3ec8a66abf80508dfb7d880c32131a781cc6a2", "message": "fix(chunkprovider): fix chunk processing", "committedDate": "2020-09-03T20:22:31Z", "type": "commit"}, {"oid": "5889eb79a1a334eb95b67f143c7ee96eb6717c93", "url": "https://github.com/MovingBlocks/Terasology/commit/5889eb79a1a334eb95b67f143c7ee96eb6717c93", "message": "chore(chunkprovider): remove GeneratingChunkProvider. unsused", "committedDate": "2020-09-04T06:56:14Z", "type": "commit"}, {"oid": "79f2c14c2369c686a1131235d6ae7eb05fb49d78", "url": "https://github.com/MovingBlocks/Terasology/commit/79f2c14c2369c686a1131235d6ae7eb05fb49d78", "message": "chore(chunkprovider): remove ReadyChunkInfo and ChunkFinalizer", "committedDate": "2020-09-04T07:06:27Z", "type": "commit"}, {"oid": "10357efaa40ab8c2ae116d00f18d4f5678ae1357", "url": "https://github.com/MovingBlocks/Terasology/commit/10357efaa40ab8c2ae116d00f18d4f5678ae1357", "message": "chore(chunkprovider): remove old constructor for LocalChunkProvider", "committedDate": "2020-09-04T07:09:08Z", "type": "commit"}, {"oid": "1d809308eaf6b93e1bd878c22630557035664c87", "url": "https://github.com/MovingBlocks/Terasology/commit/1d809308eaf6b93e1bd878c22630557035664c87", "message": "chore(chunkprovider): restore tests", "committedDate": "2020-09-04T10:27:49Z", "type": "commit"}, {"oid": "fefcbef5eda08eaa2c5a4aa19712eeafad26d7fc", "url": "https://github.com/MovingBlocks/Terasology/commit/fefcbef5eda08eaa2c5a4aa19712eeafad26d7fc", "message": "fix(chunkprovider): give more time for tests", "committedDate": "2020-09-04T11:30:33Z", "type": "commit"}, {"oid": "611f7f5e24c868c355fc7383ca199b7370f1d3c3", "url": "https://github.com/MovingBlocks/Terasology/commit/611f7f5e24c868c355fc7383ca199b7370f1d3c3", "message": "fix(chunkprovider): fix test for unload chunk", "committedDate": "2020-09-04T11:53:13Z", "type": "commit"}, {"oid": "2dcac9a566b83a74f145e7c17f9b9f47b39a4962", "url": "https://github.com/MovingBlocks/Terasology/commit/2dcac9a566b83a74f145e7c17f9b9f47b39a4962", "message": "refactor(chunkprovider): rename invalidation listener. enrich javadocs for *ChunkProvider", "committedDate": "2020-09-04T13:40:39Z", "type": "commit"}, {"oid": "c397648c6b665f40e597db830451ce7ee18ef6be", "url": "https://github.com/MovingBlocks/Terasology/commit/c397648c6b665f40e597db830451ce7ee18ef6be", "message": "refactor(chunkprovider): some javadocs", "committedDate": "2020-09-04T14:25:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1NDM3Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484554376", "bodyText": "caught my attention because Threads Make Me Nervous, but I think I see how this is set up. Each case does a requestCreatingOrLoadingArea, which I guess puts stuff on a queue that's handled by some other thread, and then we essentially spin-wait for it here. \ud83d\ude10\nSimple suggestion: Is every requestCreatingOrLoadingArea always followed immediately by a waitChunkReadyAt with the same position? If so, those two calls could be wrapped in a single \"request and block until ready\" sort of method.\nMore complicated suggestion: this makes me want createOrLoadChunk to return a Future. That could be out-of-scope for this PR, though.", "author": "keturn", "createdAt": "2020-09-07T19:47:28Z", "path": "engine-tests/src/test/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProviderTest.java", "diffHunk": "@@ -1,268 +1,298 @@\n-/*\n- * Copyright 2018 MovingBlocks\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n package org.terasology.world.chunks.localChunkProvider;\n \n-import com.google.common.collect.Lists;\n-import gnu.trove.list.TIntList;\n-import gnu.trove.list.array.TIntArrayList;\n-import gnu.trove.map.hash.TShortObjectHashMap;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.ArgumentCaptor;\n-import org.mockito.InOrder;\n-import org.terasology.entitySystem.Component;\n import org.terasology.entitySystem.entity.EntityManager;\n import org.terasology.entitySystem.entity.EntityRef;\n-import org.terasology.entitySystem.entity.EntityStore;\n import org.terasology.entitySystem.event.Event;\n-import org.terasology.entitySystem.prefab.Prefab;\n+import org.terasology.fixtures.TestBlockManager;\n+import org.terasology.fixtures.TestChunkStore;\n+import org.terasology.fixtures.TestStorageManager;\n+import org.terasology.fixtures.TestWorldGenerator;\n+import org.terasology.math.JomlUtil;\n import org.terasology.math.geom.Vector3i;\n-import org.terasology.persistence.ChunkStore;\n import org.terasology.world.BlockEntityRegistry;\n+import org.terasology.world.block.BeforeDeactivateBlocks;\n import org.terasology.world.block.Block;\n import org.terasology.world.block.BlockManager;\n+import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegionIterable;\n import org.terasology.world.block.OnActivatedBlocks;\n import org.terasology.world.block.OnAddedBlocks;\n import org.terasology.world.chunks.Chunk;\n import org.terasology.world.chunks.blockdata.ExtraBlockDataManager;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n import org.terasology.world.chunks.event.OnChunkGenerated;\n import org.terasology.world.chunks.event.OnChunkLoaded;\n-import org.terasology.world.chunks.internal.ReadyChunkInfo;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.atLeastOnce;\n-import static org.mockito.Mockito.doAnswer;\n-import static org.mockito.Mockito.inOrder;\n+import org.terasology.world.chunks.internal.ChunkImpl;\n+\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Optional;\n+\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n \n public class LocalChunkProviderTest {\n \n+    private static final int WAIT_CHUNK_IS_READY_IN_SECONDS = 10;\n+\n     private LocalChunkProvider chunkProvider;\n-    private ChunkFinalizer chunkFinalizer;\n     private EntityManager entityManager;\n     private BlockManager blockManager;\n     private ExtraBlockDataManager extraDataManager;\n     private BlockEntityRegistry blockEntityRegistry;\n     private EntityRef worldEntity;\n     private ChunkCache chunkCache;\n+    private Block blockAtBlockManager;\n+    private TestStorageManager storageManager;\n+    private TestWorldGenerator generator;\n \n     @BeforeEach\n     public void setUp() {\n         entityManager = mock(EntityManager.class);\n-        chunkFinalizer = mock(ChunkFinalizer.class);\n-        blockManager = mock(BlockManager.class);\n+        blockAtBlockManager = new Block();\n+        blockAtBlockManager.setId((short) 1);\n+        blockAtBlockManager.setUri(BlockManager.AIR_ID);\n+        blockAtBlockManager.setEntity(mock(EntityRef.class));\n+        blockManager = new TestBlockManager(blockAtBlockManager);\n         extraDataManager = new ExtraBlockDataManager();\n         blockEntityRegistry = mock(BlockEntityRegistry.class);\n         worldEntity = mock(EntityRef.class);\n         chunkCache = new ConcurrentMapChunkCache();\n-        chunkProvider = new LocalChunkProvider(null,\n-                entityManager, null, blockManager, extraDataManager, chunkFinalizer, null, chunkCache);\n+        storageManager = new TestStorageManager();\n+        generator = new TestWorldGenerator(blockManager);\n+        chunkProvider = new LocalChunkProvider(storageManager,\n+                entityManager,\n+                generator,\n+                blockManager,\n+                extraDataManager,\n+                chunkCache);\n         chunkProvider.setBlockEntityRegistry(blockEntityRegistry);\n         chunkProvider.setWorldEntity(worldEntity);\n+        chunkProvider.setRelevanceSystem(new RelevanceSystem(chunkProvider)); // workaround. initialize loading pipeline\n     }\n \n-    @Test\n-    public void testCompleteUpdateMarksChunkReady() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForNewChunk(chunk, new TShortObjectHashMap<>(), Collections.emptyList());\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n+    @AfterEach\n+    public void tearDown() {\n+        chunkProvider.shutdown();\n+    }\n \n-        chunkProvider.completeUpdate();\n+    private void requestCreatingOrLoadingArea(Vector3i chunkPosition, int radius) {\n+        BlockRegion extentsRegion = new BlockRegion(\n+                chunkPosition.x - radius, chunkPosition.y - radius, chunkPosition.z - radius,\n+                chunkPosition.x + radius, chunkPosition.y + radius, chunkPosition.z + radius);\n+        BlockRegionIterable.region(extentsRegion).build().iterator().forEachRemaining(chunkPos -> chunkProvider.createOrLoadChunk(JomlUtil.from(chunkPos)));\n+    }\n \n-        verify(chunk).markReady();\n+    private void requestCreatingOrLoadingArea(Vector3i chunkPosition) {\n+        requestCreatingOrLoadingArea(chunkPosition, 1);\n     }\n \n     @Test\n-    public void testCompleteUpdateHandlesFinalizedChunkIfReady() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForNewChunk(chunk, new TShortObjectHashMap<>(), Collections.emptyList());\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n-\n-        chunkProvider.completeUpdate();\n+    public void testGenerateSingleChunk() {\n+        Vector3i chunkPosition = new Vector3i(0, 0, 0);\n+        requestCreatingOrLoadingArea(chunkPosition);\n+        waitChunkReadyAt(chunkPosition);\n \n-        final InOrder inOrderVerification = inOrder(worldEntity);\n-        inOrderVerification.verify(worldEntity).send(any(OnChunkGenerated.class));\n-        inOrderVerification.verify(worldEntity).send(any(OnChunkLoaded.class));\n+        final ArgumentCaptor<Event> eventArgumentCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(worldEntity, atLeast(2)).send(eventArgumentCaptor.capture());\n+        Assertions.assertAll(\"WorldEvents not valid\",\n+                () -> {\n+                    Event mustBeOnGeneratedEvent = eventArgumentCaptor.getAllValues().get(0);\n+                    Assertions.assertTrue(mustBeOnGeneratedEvent instanceof OnChunkGenerated,\n+                            \"First world event must be OnChunkGenerated\");\n+                    Assertions.assertEquals(((OnChunkGenerated) mustBeOnGeneratedEvent).getChunkPos(),\n+                            chunkPosition,\n+                            \"Chunk position at event not expected\");\n+                },\n+                () -> {\n+                    Event mustBeOnLoadedEvent = eventArgumentCaptor.getAllValues().get(1);\n+                    Assertions.assertTrue(mustBeOnLoadedEvent instanceof OnChunkLoaded,\n+                            \"Second world event must be OnChunkLoaded\");\n+                    Assertions.assertEquals(((OnChunkLoaded) mustBeOnLoadedEvent).getChunkPos(),\n+                            chunkPosition,\n+                            \"Chunk position at event not expected\");\n+                });\n     }\n \n     @Test\n-    public void testCompleteUpdateGeneratesStoredEntities() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final ChunkProviderTestComponent testComponent = new ChunkProviderTestComponent();\n-        final EntityStore entityStore = createEntityStoreWithComponents(testComponent);\n-        final List<EntityStore> entityStores = Collections.singletonList(entityStore);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForNewChunk(chunk, new TShortObjectHashMap<>(), entityStores);\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n-        final EntityRef mockEntity = mock(EntityRef.class);\n-        when(entityManager.create()).thenReturn(mockEntity);\n-\n-        chunkProvider.completeUpdate();\n-\n-        verify(mockEntity).addComponent(eq(testComponent));\n+    public void testGenerateSingleChunkWithBlockLifeCycle() {\n+        Vector3i chunkPosition = new Vector3i(0, 0, 0);\n+        blockAtBlockManager.setLifecycleEventsRequired(true);\n+        blockAtBlockManager.setEntity(mock(EntityRef.class));\n+        requestCreatingOrLoadingArea(chunkPosition);\n+        waitChunkReadyAt(chunkPosition);\n+\n+        final ArgumentCaptor<Event> worldEventCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(worldEntity, atLeast(2)).send(worldEventCaptor.capture());\n+        Assertions.assertAll(\"World Events not valid\",\n+                () -> {\n+                    Event mustBeOnGeneratedEvent = worldEventCaptor.getAllValues().get(0);\n+                    Assertions.assertTrue(mustBeOnGeneratedEvent instanceof OnChunkGenerated,\n+                            \"First world event must be OnChunkGenerated\");\n+                    Assertions.assertEquals(((OnChunkGenerated) mustBeOnGeneratedEvent).getChunkPos(),\n+                            chunkPosition,\n+                            \"Chunk position at event not expected\");\n+                },\n+                () -> {\n+                    Event mustBeOnLoadedEvent = worldEventCaptor.getAllValues().get(1);\n+                    Assertions.assertTrue(mustBeOnLoadedEvent instanceof OnChunkLoaded,\n+                            \"Second world event must be OnChunkLoaded\");\n+                    Assertions.assertEquals(((OnChunkLoaded) mustBeOnLoadedEvent).getChunkPos(),\n+                            chunkPosition,\n+                            \"Chunk position at event not expected\");\n+                });\n+\n+        //TODO, it is not clear if the activate/addedBlocks event logic is correct.\n+        //See https://github.com/MovingBlocks/Terasology/issues/3244\n+        final ArgumentCaptor<Event> blockEventCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(blockAtBlockManager.getEntity(), atLeast(1)).send(blockEventCaptor.capture());\n+\n+        Event mustBeOnActivatedBlocks = blockEventCaptor.getAllValues().get(0);\n+        Assertions.assertTrue(mustBeOnActivatedBlocks instanceof OnActivatedBlocks,\n+                \"First block event must be OnActivatedBlocks\");\n+        Assertions.assertTrue(((OnActivatedBlocks) mustBeOnActivatedBlocks).blockCount() > 0,\n+                \"Block count on activate must be non zero\");\n     }\n \n     @Test\n-    public void testCompleteUpdateGeneratesStoredEntitiesFromPrefab() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final Prefab prefab = mock(Prefab.class);\n-        final ChunkProviderTestComponent testComponent = new ChunkProviderTestComponent();\n-        final EntityStore entityStore = createEntityStoreWithPrefabAndComponents(prefab, testComponent);\n-        final List<EntityStore> entityStores = Collections.singletonList(entityStore);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForNewChunk(chunk, new TShortObjectHashMap<>(), entityStores);\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n-        final EntityRef mockEntity = mock(EntityRef.class);\n-        when(entityManager.create(any(Prefab.class))).thenReturn(mockEntity);\n-\n-        chunkProvider.completeUpdate();\n-\n-        verify(entityManager).create(eq(prefab));\n-        verify(mockEntity).addComponent(eq(testComponent));\n-    }\n+    public void testLoadSingleChunk() {\n+        Vector3i chunkPosition = new Vector3i(0, 0, 0);\n+        Chunk chunk = new ChunkImpl(chunkPosition, blockManager, extraDataManager);\n+        generator.createChunk(chunk, null);\n+        storageManager.add(chunk);\n \n-    @Test\n-    public void testCompleteUpdateRestoresEntitiesForRestoredChunks() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final ChunkStore chunkStore = mock(ChunkStore.class);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForRestoredChunk(chunk, new TShortObjectHashMap<>(), chunkStore, Collections.emptyList());\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n+        requestCreatingOrLoadingArea(chunkPosition);\n+        waitChunkReadyAt(chunkPosition);\n \n-        chunkProvider.completeUpdate();\n+        Assertions.assertTrue(((TestChunkStore) storageManager.loadChunkStore(chunkPosition)).isEntityRestored(),\n+                \"Entities must be restored by loading\");\n \n-        verify(chunkStore).restoreEntities();\n+        final ArgumentCaptor<Event> eventArgumentCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(worldEntity, atLeast(1)).send(eventArgumentCaptor.capture());\n+        Event mustBeOnLoadedEvent = eventArgumentCaptor.getAllValues().get(0);\n+        Assertions.assertTrue(mustBeOnLoadedEvent instanceof OnChunkLoaded,\n+                \"Second world event must be OnChunkLoaded\");\n+        Assertions.assertEquals(((OnChunkLoaded) mustBeOnLoadedEvent).getChunkPos(),\n+                chunkPosition,\n+                \"Chunk position at event not expected\");\n     }\n \n     @Test\n-    public void testCompleteUpdateSendsBlockAddedEvents() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final short blockId = 42;\n-        final EntityRef blockEntity = mock(EntityRef.class);\n-        registerBlockWithIdAndEntity(blockId, blockEntity, blockManager);\n-        final TShortObjectHashMap<TIntList> blockPositionMappings = new TShortObjectHashMap<>();\n-        blockPositionMappings.put(blockId, withPositions(new Vector3i(1, 2, 3)));\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForRestoredChunk(chunk, blockPositionMappings, mock(ChunkStore.class), Collections.emptyList());\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n-\n-        chunkProvider.completeUpdate();\n+    public void testLoadSingleChunkWithBlockLifecycle() {\n+        Vector3i chunkPosition = new Vector3i(0, 0, 0);\n+        Chunk chunk = new ChunkImpl(chunkPosition, blockManager, extraDataManager);\n+        generator.createChunk(chunk, null);\n+        storageManager.add(chunk);\n+        blockAtBlockManager.setLifecycleEventsRequired(true);\n+        blockAtBlockManager.setEntity(mock(EntityRef.class));\n \n-        final ArgumentCaptor<Event> eventArgumentCaptor = ArgumentCaptor.forClass(Event.class);\n-        verify(blockEntity, atLeastOnce()).send(eventArgumentCaptor.capture());\n-        final Event event = eventArgumentCaptor.getAllValues().get(0);\n-        assertTrue(event instanceof OnAddedBlocks);\n-        Iterable<Vector3i> positions = ((OnAddedBlocks) event).getBlockPositions();\n-        assertTrue(Lists.newArrayList(positions).contains(new Vector3i(1, 2, 3)));\n-    }\n+        requestCreatingOrLoadingArea(chunkPosition);\n+        waitChunkReadyAt(chunkPosition);\n \n-    @Test\n-    public void testCompleteUpdateSendsBlockActivatedEvents() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final TShortObjectHashMap<TIntList> blockPositionMappings = new TShortObjectHashMap<>();\n-        final short blockId = 42;\n-        final EntityRef blockEntity = mock(EntityRef.class);\n-        registerBlockWithIdAndEntity(blockId, blockEntity, blockManager);\n-        blockPositionMappings.put(blockId, withPositions(new Vector3i(1, 2, 3)));\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForRestoredChunk(chunk, blockPositionMappings, mock(ChunkStore.class), Collections.emptyList());\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n-\n-        chunkProvider.completeUpdate();\n+        Assertions.assertTrue(((TestChunkStore) storageManager.loadChunkStore(chunkPosition)).isEntityRestored(),\n+                \"Entities must be restored by loading\");\n \n-        final ArgumentCaptor<Event> eventArgumentCaptor = ArgumentCaptor.forClass(Event.class);\n-        verify(blockEntity, atLeastOnce()).send(eventArgumentCaptor.capture());\n-        final Event event = eventArgumentCaptor.getAllValues().get(1);\n-        assertTrue(event instanceof OnActivatedBlocks);\n-        Iterable<Vector3i> positions = ((OnActivatedBlocks) event).getBlockPositions();\n-        assertTrue(Lists.newArrayList(positions).contains(new Vector3i(1, 2, 3)));\n-    }\n \n-    private static void markAllChunksAsReady(final ChunkCache chunkCache) {\n-        markAllChunksAsReadyExcludingPosition(chunkCache, null);\n+        final ArgumentCaptor<Event> eventArgumentCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(worldEntity, atLeast(1)).send(eventArgumentCaptor.capture());\n+        Event mustBeOnLoadedEvent = eventArgumentCaptor.getAllValues().get(0);\n+        Assertions.assertTrue(mustBeOnLoadedEvent instanceof OnChunkLoaded,\n+                \"Second world event must be OnChunkLoaded\");\n+        Assertions.assertEquals(((OnChunkLoaded) mustBeOnLoadedEvent).getChunkPos(),\n+                chunkPosition,\n+                \"Chunk position at event not expected\");\n+\n+        //TODO, it is not clear if the activate/addedBlocks event logic is correct.\n+        //See https://github.com/MovingBlocks/Terasology/issues/3244\n+        final ArgumentCaptor<Event> blockEventCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(blockAtBlockManager.getEntity(), atLeast(2)).send(blockEventCaptor.capture());\n+        Assertions.assertAll(\"Block events not valid\",\n+                () -> {\n+                    Event mustBeOnAddedBlocks = blockEventCaptor.getAllValues().get(0);\n+                    Assertions.assertTrue(mustBeOnAddedBlocks instanceof OnAddedBlocks,\n+                            \"First block event must be OnAddedBlocks\");\n+                    Assertions.assertTrue(((OnAddedBlocks) mustBeOnAddedBlocks).blockCount() > 0,\n+                            \"Block count on activate must be non zero\");\n+                },\n+                () -> {\n+                    Event mustBeOnActivatedBlocks = blockEventCaptor.getAllValues().get(1);\n+                    Assertions.assertTrue(mustBeOnActivatedBlocks instanceof OnActivatedBlocks,\n+                            \"First block event must be OnActivatedBlocks\");\n+                    Assertions.assertTrue(((OnActivatedBlocks) mustBeOnActivatedBlocks).blockCount() > 0,\n+                            \"Block count on activate must be non zero\");\n+                });\n     }\n \n-    private static void markAllChunksAsReadyExcludingPosition(final ChunkCache chunkCache, final Vector3i positionToExclude) {\n-        chunkCache.getAllChunks().stream()\n-                .filter(chunk -> !chunk.getPosition().equals(positionToExclude))\n-                .forEach(c -> when(c.isReady()).thenReturn(true));\n-    }\n+    @Test\n+    public void testUnloadChunkAndDeactivationBlock() throws InterruptedException {\n+        Vector3i chunkPosition = new Vector3i(0, 0, 0);\n+        blockAtBlockManager.setLifecycleEventsRequired(true);\n+        blockAtBlockManager.setEntity(mock(EntityRef.class));\n+\n+        requestCreatingOrLoadingArea(chunkPosition);\n+        waitChunkReadyAt(chunkPosition);\n+\n+        //Wait BeforeDeactivateBlocks event\n+        Assertions.assertTimeoutPreemptively(Duration.of(WAIT_CHUNK_IS_READY_IN_SECONDS, ChronoUnit.SECONDS),\n+                () -> {\n+                    ArgumentCaptor<Event> blockEventCaptor = ArgumentCaptor.forClass(Event.class);\n+                    while (!blockEventCaptor.getAllValues()\n+                            .stream()\n+                            .filter((e) -> e instanceof BeforeDeactivateBlocks)\n+                            .map((e) -> (BeforeDeactivateBlocks) e)\n+                            .findFirst().isPresent()) {\n+                        chunkProvider.beginUpdate();\n+                        blockEventCaptor = ArgumentCaptor.forClass(Event.class);\n+                        verify(blockAtBlockManager.getEntity(), atLeast(1)).send(blockEventCaptor.capture());\n \n-    private static void generateMockChunkCubeWithSideWidthAround(final Vector3i position, final int sideWidth, final ChunkCache chunkCache) {\n-        for (int x = position.getX() - sideWidth; x <= position.getX() + sideWidth; x++) {\n-            for (int y = position.getY() - sideWidth; y <= position.getY() + sideWidth; y++) {\n-                for (int z = position.getZ() - sideWidth; z <= position.getZ() + sideWidth; z++) {\n-                    if (x == position.getX() && y == position.getY() && z == position.getZ()) {\n-                        //dont override the inner chunk\n-                        continue;\n                     }\n-                    chunkCache.put(new Vector3i(x, y, z), mockChunkAt(x, y, z));\n                 }\n-            }\n-        }\n-    }\n-\n-    private static EntityStore createEntityStoreWithComponents(Component... components) {\n-        return createEntityStoreWithPrefabAndComponents(null, components);\n-    }\n-\n-    private static EntityStore createEntityStoreWithPrefabAndComponents(Prefab prefab, Component... components) {\n-        final EntityStore entityStore = new EntityStore(prefab);\n-        for (Component component : components) {\n-            entityStore.addComponent(component);\n-        }\n-        return entityStore;\n-    }\n-\n-    private static Chunk mockChunkAt(final int x, final int y, final int z) {\n-        final Chunk chunk = mock(Chunk.class);\n-        when(chunk.getPosition()).thenReturn(new Vector3i(x, y, z));\n-        return chunk;\n-    }\n-\n-\n-    private static Chunk mockChunkWithReadinessStateAt(final int x, final int y, final int z) {\n-        final Chunk chunk = mockChunkAt(x, y, z);\n-        AtomicBoolean chunkReady = new AtomicBoolean();\n-        when(chunk.isReady()).thenAnswer(i -> chunkReady.get());\n-        doAnswer(i -> {\n-            chunkReady.set(true);\n-            return null;\n-        }).when(chunk).markReady();\n-        return chunk;\n-    }\n+        );\n \n-    private static TIntArrayList withPositions(final Vector3i position) {\n-        final TIntArrayList positions = new TIntArrayList();\n-        positions.add(position.x);\n-        positions.add(position.y);\n-        positions.add(position.z);\n-        return positions;\n+        final ArgumentCaptor<Event> eventArgumentCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(worldEntity, atLeast(1)).send(eventArgumentCaptor.capture());\n+        Optional<BeforeChunkUnload> beforeChunkUnload = eventArgumentCaptor.getAllValues()\n+                .stream()\n+                .filter((e) -> e instanceof BeforeChunkUnload)\n+                .map((e) -> (BeforeChunkUnload) e)\n+                .findFirst();\n+\n+        Assertions.assertTrue(beforeChunkUnload.isPresent(),\n+                \"World events must have BeforeChunkUnload event when chunk was unload\");\n+        Assertions.assertEquals(beforeChunkUnload.get().getChunkPos(),\n+                chunkPosition,\n+                \"Chunk position at event not expected\");\n+\n+        //TODO, it is not clear if the activate/addedBlocks event logic is correct.\n+        //See https://github.com/MovingBlocks/Terasology/issues/3244\n+        final ArgumentCaptor<Event> blockEventCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(blockAtBlockManager.getEntity(), atLeast(2)).send(blockEventCaptor.capture());\n+        Optional<BeforeDeactivateBlocks> beforeDeactivateBlocks = blockEventCaptor.getAllValues()\n+                .stream()\n+                .filter((e) -> e instanceof BeforeDeactivateBlocks)\n+                .map((e) -> (BeforeDeactivateBlocks) e)\n+                .findFirst();\n+        Assertions.assertTrue(beforeDeactivateBlocks.isPresent(),\n+                \"World events must have BeforeDeactivateBlocks event when chunk with lifecycle blocks was unload\");\n+        Assertions.assertTrue(beforeDeactivateBlocks.get().blockCount() > 0,\n+                \"BeforeDeactivateBlocks must have block count more then zero\");\n     }\n \n-    private static void registerBlockWithIdAndEntity(final short blockId, final EntityRef blockEntity, final BlockManager blockManager) {\n-        final Block block = new Block();\n-        block.setEntity(blockEntity);\n-        when(blockManager.getBlock(eq(blockId))).thenReturn(block);\n+    private void waitChunkReadyAt(Vector3i chunkPosition) {\n+        Assertions.assertTimeoutPreemptively(Duration.of(WAIT_CHUNK_IS_READY_IN_SECONDS, ChronoUnit.SECONDS),\n+                () -> {\n+                    while (chunkCache.get(chunkPosition) == null || !chunkCache.get(chunkPosition).isReady()) {\n+                        Thread.yield();", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY2OTQxNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484669417", "bodyText": "Simple suggestion: yeah it is good idea. But suitable only for tests.\nComplicated suggestions: no one in non test not needed it. and better replace TaskMaster with Future and ExectionService\nfun fact: Thread.yield() - do nothing in 99% case.", "author": "DarkWeird", "createdAt": "2020-09-08T06:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1NDM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1NTQ5MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484555490", "bodyText": "Are these assertions identical to those in testGenerateSingleChunk without the BlockLifeCycle stuff?\nIs that setLifecycleEventsRequired(true) expected to change the results at all?\nIf they're the same assertions and effectively the same initial conditions, I'd say remove the duplication to make it clearer what the focus is for this test.", "author": "keturn", "createdAt": "2020-09-07T19:53:33Z", "path": "engine-tests/src/test/java/org/terasology/world/chunks/localChunkProvider/LocalChunkProviderTest.java", "diffHunk": "@@ -1,268 +1,298 @@\n-/*\n- * Copyright 2018 MovingBlocks\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n package org.terasology.world.chunks.localChunkProvider;\n \n-import com.google.common.collect.Lists;\n-import gnu.trove.list.TIntList;\n-import gnu.trove.list.array.TIntArrayList;\n-import gnu.trove.map.hash.TShortObjectHashMap;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.ArgumentCaptor;\n-import org.mockito.InOrder;\n-import org.terasology.entitySystem.Component;\n import org.terasology.entitySystem.entity.EntityManager;\n import org.terasology.entitySystem.entity.EntityRef;\n-import org.terasology.entitySystem.entity.EntityStore;\n import org.terasology.entitySystem.event.Event;\n-import org.terasology.entitySystem.prefab.Prefab;\n+import org.terasology.fixtures.TestBlockManager;\n+import org.terasology.fixtures.TestChunkStore;\n+import org.terasology.fixtures.TestStorageManager;\n+import org.terasology.fixtures.TestWorldGenerator;\n+import org.terasology.math.JomlUtil;\n import org.terasology.math.geom.Vector3i;\n-import org.terasology.persistence.ChunkStore;\n import org.terasology.world.BlockEntityRegistry;\n+import org.terasology.world.block.BeforeDeactivateBlocks;\n import org.terasology.world.block.Block;\n import org.terasology.world.block.BlockManager;\n+import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegionIterable;\n import org.terasology.world.block.OnActivatedBlocks;\n import org.terasology.world.block.OnAddedBlocks;\n import org.terasology.world.chunks.Chunk;\n import org.terasology.world.chunks.blockdata.ExtraBlockDataManager;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n import org.terasology.world.chunks.event.OnChunkGenerated;\n import org.terasology.world.chunks.event.OnChunkLoaded;\n-import org.terasology.world.chunks.internal.ReadyChunkInfo;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.atLeastOnce;\n-import static org.mockito.Mockito.doAnswer;\n-import static org.mockito.Mockito.inOrder;\n+import org.terasology.world.chunks.internal.ChunkImpl;\n+\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Optional;\n+\n+import static org.mockito.Mockito.atLeast;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n \n public class LocalChunkProviderTest {\n \n+    private static final int WAIT_CHUNK_IS_READY_IN_SECONDS = 10;\n+\n     private LocalChunkProvider chunkProvider;\n-    private ChunkFinalizer chunkFinalizer;\n     private EntityManager entityManager;\n     private BlockManager blockManager;\n     private ExtraBlockDataManager extraDataManager;\n     private BlockEntityRegistry blockEntityRegistry;\n     private EntityRef worldEntity;\n     private ChunkCache chunkCache;\n+    private Block blockAtBlockManager;\n+    private TestStorageManager storageManager;\n+    private TestWorldGenerator generator;\n \n     @BeforeEach\n     public void setUp() {\n         entityManager = mock(EntityManager.class);\n-        chunkFinalizer = mock(ChunkFinalizer.class);\n-        blockManager = mock(BlockManager.class);\n+        blockAtBlockManager = new Block();\n+        blockAtBlockManager.setId((short) 1);\n+        blockAtBlockManager.setUri(BlockManager.AIR_ID);\n+        blockAtBlockManager.setEntity(mock(EntityRef.class));\n+        blockManager = new TestBlockManager(blockAtBlockManager);\n         extraDataManager = new ExtraBlockDataManager();\n         blockEntityRegistry = mock(BlockEntityRegistry.class);\n         worldEntity = mock(EntityRef.class);\n         chunkCache = new ConcurrentMapChunkCache();\n-        chunkProvider = new LocalChunkProvider(null,\n-                entityManager, null, blockManager, extraDataManager, chunkFinalizer, null, chunkCache);\n+        storageManager = new TestStorageManager();\n+        generator = new TestWorldGenerator(blockManager);\n+        chunkProvider = new LocalChunkProvider(storageManager,\n+                entityManager,\n+                generator,\n+                blockManager,\n+                extraDataManager,\n+                chunkCache);\n         chunkProvider.setBlockEntityRegistry(blockEntityRegistry);\n         chunkProvider.setWorldEntity(worldEntity);\n+        chunkProvider.setRelevanceSystem(new RelevanceSystem(chunkProvider)); // workaround. initialize loading pipeline\n     }\n \n-    @Test\n-    public void testCompleteUpdateMarksChunkReady() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForNewChunk(chunk, new TShortObjectHashMap<>(), Collections.emptyList());\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n+    @AfterEach\n+    public void tearDown() {\n+        chunkProvider.shutdown();\n+    }\n \n-        chunkProvider.completeUpdate();\n+    private void requestCreatingOrLoadingArea(Vector3i chunkPosition, int radius) {\n+        BlockRegion extentsRegion = new BlockRegion(\n+                chunkPosition.x - radius, chunkPosition.y - radius, chunkPosition.z - radius,\n+                chunkPosition.x + radius, chunkPosition.y + radius, chunkPosition.z + radius);\n+        BlockRegionIterable.region(extentsRegion).build().iterator().forEachRemaining(chunkPos -> chunkProvider.createOrLoadChunk(JomlUtil.from(chunkPos)));\n+    }\n \n-        verify(chunk).markReady();\n+    private void requestCreatingOrLoadingArea(Vector3i chunkPosition) {\n+        requestCreatingOrLoadingArea(chunkPosition, 1);\n     }\n \n     @Test\n-    public void testCompleteUpdateHandlesFinalizedChunkIfReady() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForNewChunk(chunk, new TShortObjectHashMap<>(), Collections.emptyList());\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n-\n-        chunkProvider.completeUpdate();\n+    public void testGenerateSingleChunk() {\n+        Vector3i chunkPosition = new Vector3i(0, 0, 0);\n+        requestCreatingOrLoadingArea(chunkPosition);\n+        waitChunkReadyAt(chunkPosition);\n \n-        final InOrder inOrderVerification = inOrder(worldEntity);\n-        inOrderVerification.verify(worldEntity).send(any(OnChunkGenerated.class));\n-        inOrderVerification.verify(worldEntity).send(any(OnChunkLoaded.class));\n+        final ArgumentCaptor<Event> eventArgumentCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(worldEntity, atLeast(2)).send(eventArgumentCaptor.capture());\n+        Assertions.assertAll(\"WorldEvents not valid\",\n+                () -> {\n+                    Event mustBeOnGeneratedEvent = eventArgumentCaptor.getAllValues().get(0);\n+                    Assertions.assertTrue(mustBeOnGeneratedEvent instanceof OnChunkGenerated,\n+                            \"First world event must be OnChunkGenerated\");\n+                    Assertions.assertEquals(((OnChunkGenerated) mustBeOnGeneratedEvent).getChunkPos(),\n+                            chunkPosition,\n+                            \"Chunk position at event not expected\");\n+                },\n+                () -> {\n+                    Event mustBeOnLoadedEvent = eventArgumentCaptor.getAllValues().get(1);\n+                    Assertions.assertTrue(mustBeOnLoadedEvent instanceof OnChunkLoaded,\n+                            \"Second world event must be OnChunkLoaded\");\n+                    Assertions.assertEquals(((OnChunkLoaded) mustBeOnLoadedEvent).getChunkPos(),\n+                            chunkPosition,\n+                            \"Chunk position at event not expected\");\n+                });\n     }\n \n     @Test\n-    public void testCompleteUpdateGeneratesStoredEntities() throws Exception {\n-        final Chunk chunk = mockChunkAt(0, 0, 0);\n-        final ChunkProviderTestComponent testComponent = new ChunkProviderTestComponent();\n-        final EntityStore entityStore = createEntityStoreWithComponents(testComponent);\n-        final List<EntityStore> entityStores = Collections.singletonList(entityStore);\n-        final ReadyChunkInfo readyChunkInfo = ReadyChunkInfo.createForNewChunk(chunk, new TShortObjectHashMap<>(), entityStores);\n-        when(chunkFinalizer.completeFinalization()).thenReturn(Collections.singletonList(readyChunkInfo));\n-        final EntityRef mockEntity = mock(EntityRef.class);\n-        when(entityManager.create()).thenReturn(mockEntity);\n-\n-        chunkProvider.completeUpdate();\n-\n-        verify(mockEntity).addComponent(eq(testComponent));\n+    public void testGenerateSingleChunkWithBlockLifeCycle() {\n+        Vector3i chunkPosition = new Vector3i(0, 0, 0);\n+        blockAtBlockManager.setLifecycleEventsRequired(true);\n+        blockAtBlockManager.setEntity(mock(EntityRef.class));\n+        requestCreatingOrLoadingArea(chunkPosition);\n+        waitChunkReadyAt(chunkPosition);\n+\n+        final ArgumentCaptor<Event> worldEventCaptor = ArgumentCaptor.forClass(Event.class);\n+        verify(worldEntity, atLeast(2)).send(worldEventCaptor.capture());\n+        Assertions.assertAll(\"World Events not valid\",", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1ODI3Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484558276", "bodyText": "Skip this suggestion if it's scope creep, but since this is just passing through to the dist FromRegion in this private class defined right here:\ninstead of wrapping that getPosition result, can you instead joml-ify the distFromRegion types?", "author": "keturn", "createdAt": "2020-09-07T20:10:47Z", "path": "engine/src/main/java/org/terasology/rendering/world/ChunkMeshUpdateManager.java", "diffHunk": "@@ -195,7 +199,7 @@ private int score(ChunkTask task) {\n             if (task.isTerminateSignal()) {\n                 return -1;\n             }\n-            return distFromRegion(task.getPosition(), new Vector3i(cameraChunkPosX, cameraChunkPosY, cameraChunkPosZ));\n+            return distFromRegion(JomlUtil.from(task.getPosition()), new Vector3i(cameraChunkPosX, cameraChunkPosY, cameraChunkPosZ));", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2MDg1Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484560852", "bodyText": "I'm not clear on this one at all.\nAs far as I can tell, it's only used in LightMergerChunkTaskProvider, and I'm not sure what's going on there.", "author": "keturn", "createdAt": "2020-09-07T20:27:27Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/tasks/InterruptChunkTask.java", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline.tasks;\n+\n+import org.joml.Vector3i;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.ChunkTask;\n+\n+/**\n+ * Chunk task which interrupt processing in {@link org.terasology.world.chunks.pipeline.ChunkProcessingPipeline}\n+ * <p>\n+ * [Warn] this task not cleanup left phases for chunks. Use it with attention.\n+ * <p>\n+ * If you not send chunk to processing - you not processed chunk to end -- never.\n+ */\n+public class InterruptChunkTask implements ChunkTask {", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3NzA3MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484677071", "bodyText": "Moving chunk to pending chunks(Internal storage of LightMergerChunkTaskProvider), next stages \"waits\" :D\nMagic of this method - getChunk() => null (You saw ChunkProcessingPipeline#invokePipeline returns silently when chunk == null)", "author": "DarkWeird", "createdAt": "2020-09-08T06:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2MDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2OTMwNg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484569306", "bodyText": "ahh, this is probably the important part of this PR, isn't it.\nOkay, I can appreciate having some pipeline stages that have a consistent interface.\nI may have some questions but it looks like I need to read ChunkProcessingPipeline.", "author": "keturn", "createdAt": "2020-09-07T21:23:03Z", "path": "engine/src/main/java/org/terasology/world/chunks/remoteChunkProvider/RemoteChunkProvider.java", "diffHunk": "@@ -24,105 +11,100 @@\n import org.terasology.entitySystem.entity.EntityRef;\n import org.terasology.logic.players.LocalPlayer;\n import org.terasology.math.ChunkMath;\n+import org.terasology.math.JomlUtil;\n import org.terasology.math.Region3i;\n import org.terasology.math.TeraMath;\n-import org.terasology.math.geom.Vector3f;\n import org.terasology.math.geom.Vector3i;\n-import org.terasology.monitoring.PerformanceMonitor;\n import org.terasology.monitoring.chunk.ChunkMonitor;\n import org.terasology.world.block.BlockManager;\n import org.terasology.world.chunks.Chunk;\n import org.terasology.world.chunks.ChunkConstants;\n import org.terasology.world.chunks.ChunkProvider;\n-import org.terasology.world.chunks.ChunkRegionListener;\n import org.terasology.world.chunks.event.BeforeChunkUnload;\n import org.terasology.world.chunks.event.OnChunkLoaded;\n-import org.terasology.world.chunks.internal.GeneratingChunkProvider;\n-import org.terasology.world.chunks.pipeline.AbstractChunkTask;\n-import org.terasology.world.chunks.pipeline.ChunkGenerationPipeline;\n+import org.terasology.world.chunks.pipeline.ChunkProcessingPipeline;\n import org.terasology.world.chunks.pipeline.ChunkTask;\n+import org.terasology.world.chunks.pipeline.LightMergerChunkTaskProvider;\n+import org.terasology.world.chunks.pipeline.tasks.DeflateChunkTask;\n+import org.terasology.world.chunks.pipeline.tasks.GenerateInternalLightningChunkTask;\n+import org.terasology.world.chunks.pipeline.tasks.NotifyChunkTask;\n import org.terasology.world.internal.ChunkViewCore;\n import org.terasology.world.internal.ChunkViewCoreImpl;\n-import org.terasology.world.propagation.light.InternalLightProcessor;\n-import org.terasology.world.propagation.light.LightMerger;\n \n import java.math.RoundingMode;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.BlockingQueue;\n \n /**\n- *\n+ * Provides chunks received from remote source.\n+ * <p>\n+ * Loading/Unload chunks dependent on {@link org.terasology.network.Server}\n+ * <p/>\n+ * Produce events:\n+ * <p>\n+ * {@link OnChunkLoaded} when chunk received from server and processed.\n+ * <p>\n+ * {@link BeforeChunkUnload} when {@link org.terasology.network.Server} send invalidate chunk and chunk removing\n  */\n-public class RemoteChunkProvider implements ChunkProvider, GeneratingChunkProvider {\n+public class RemoteChunkProvider implements ChunkProvider {\n \n     private static final Logger logger = LoggerFactory.getLogger(RemoteChunkProvider.class);\n-    private Map<Vector3i, Chunk> chunkCache = Maps.newHashMap();\n-    private final BlockingQueue<Chunk> readyChunks = Queues.newLinkedBlockingQueue();\n     private final BlockingQueue<Vector3i> invalidateChunks = Queues.newLinkedBlockingQueue();\n-    private List<Chunk> sortedReadyChunks = Lists.newArrayList();\n+    private Map<Vector3i, Chunk> chunkCache = Maps.newHashMap();\n     private ChunkReadyListener listener;\n     private EntityRef worldEntity = EntityRef.NULL;\n \n     private BlockManager blockManager;\n \n-    private ChunkGenerationPipeline pipeline;\n-\n-    private LightMerger<Chunk> lightMerger = new LightMerger<>(this);\n+    private ChunkProcessingPipeline loadingPipeline;\n \n     private LocalPlayer localPlayer;\n \n     public RemoteChunkProvider(BlockManager blockManager, LocalPlayer localPlayer) {\n         this.blockManager = blockManager;\n         this.localPlayer = localPlayer;\n-        pipeline = new ChunkGenerationPipeline(new ChunkTaskRelevanceComparator());\n+        loadingPipeline = new ChunkProcessingPipeline(new ChunkTaskRelevanceComparator());\n+\n+        loadingPipeline.addStage(GenerateInternalLightningChunkTask::new)", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3MDU5MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484570590", "bodyText": "It is a class named Wrapper, I am automatically suspicious. \ud83d\udd75\ufe0f\n(Another reason for me to take a closer look at the Pipeline class.)", "author": "keturn", "createdAt": "2020-09-07T21:31:44Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/tasks/ChunkTaskListenerWrapper.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline.tasks;\n+\n+import org.joml.Vector3i;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.ChunkTask;\n+import org.terasology.world.chunks.pipeline.ChunkTaskListener;\n+\n+/**\n+ * Wrapper for {@link ChunkTask} with {@link ChunkTaskListener} feature.\n+ * <p>\n+ * Fire {@link ChunkTaskListener#onDone(ChunkTask)}  after wrapped {@link ChunkTask}\n+ */\n+public class ChunkTaskListenerWrapper implements ChunkTask {\n+    private final ChunkTask chunkTask;\n+    private final ChunkTaskListener listener;", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3NTc4Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484675783", "bodyText": "Tasks like Runnable. This class delegating(wrapping) ChunkTask's run method and append Listener behavior.\nYeah, better to use Callable and Future but we have TaskMaster :D", "author": "DarkWeird", "createdAt": "2020-09-08T06:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3MDU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3MDg2OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484570869", "bodyText": "I am still confused about what the role of InterruptChunkTask is here.", "author": "keturn", "createdAt": "2020-09-07T21:33:59Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/LightMergerChunkTaskProvider.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Sets;\n+import org.jetbrains.annotations.NotNull;\n+import org.joml.Vector3i;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.world.block.BlockRegion;\n+import org.terasology.world.block.BlockRegionIterable;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.pipeline.tasks.InterruptChunkTask;\n+import org.terasology.world.chunks.pipeline.tasks.LightMergerChunkTask;\n+import org.terasology.world.propagation.light.LightMerger;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * Light Merger Chunk Task Provider.\n+ * <p>\n+ * Check requirements and re-invoke {@link LightMergerChunkTask} when requirements meets.\n+ */\n+public class LightMergerChunkTaskProvider implements Function<Chunk, ChunkTask>, ChunkTaskListener,\n+        ChunkRemoveFromPipelineListener {\n+\n+    private final ChunkProvider chunkProvider;\n+    private final ChunkProcessingPipeline pipeline;\n+    private final Set<Chunk> pending = Sets.newConcurrentHashSet();\n+    private final Map<Vector3i, Chunk> noticedChunkInProcessing = new ConcurrentHashMap<>();\n+\n+    public LightMergerChunkTaskProvider(ChunkProvider chunkProvider,\n+                                        ChunkProcessingPipeline pipeline) {\n+        this.chunkProvider = chunkProvider;\n+        this.pipeline = pipeline;\n+    }\n+\n+    @Override\n+    public ChunkTask apply(Chunk chunk) {\n+        if (getLocalChunks(chunk).noneMatch(Objects::isNull)) {\n+            return makeTask(chunk, getLocalChunks(chunk).toArray(Chunk[]::new));\n+        } else {\n+            pending.add(chunk);\n+            return new InterruptChunkTask();", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3NDY2MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484674661", "bodyText": "Interrupt chunk processing for this Chunk.\nKinda \"I want to stop processing there, but leave next stages. I will back later.\"\nLightMerger requires neighbor chunks for light calculation. then I interrupt chunk processing, while not I not gather required chunks. See this::onDone\nI had think about RecursiveTask, ForkJoinPool... but we have TaskMaster", "author": "DarkWeird", "createdAt": "2020-09-08T06:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3MDg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MDA2Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r486690067", "bodyText": "Ah, I haven't yet studied this to completely understand, but it does help to know this is the reason.\nI think this is something it would help to see tests for! Either as tests of Pipeline or tests of LightMergerChunkTaskProvider, whichever seems more appropriate.", "author": "keturn", "createdAt": "2020-09-10T23:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3MDg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3NTAxNA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484575014", "bodyText": "This reminds me, I want this thread pool size to be configurable!\n(That can be out-of-scope for this PR, this is just a note marking the place to do it.)", "author": "keturn", "createdAt": "2020-09-07T22:04:38Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/ChunkProcessingPipeline.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.Vector3i;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.utilities.concurrency.TaskMaster;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.tasks.ChunkTaskListenerWrapper;\n+\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Manages execution of chunk tasks on a queue.\n+ * <p>\n+ * {@link ChunkTask}s are executing in background threads.\n+ * <p>\n+ * {@link ChunkTask}s are executing by priority via {@link Comparable}.\n+ * <p>\n+ * {@link Chunk}s will processing on stages {@link ChunkProcessingPipeline#addStage}\n+ */\n+public class ChunkProcessingPipeline implements ChunkTaskListener {\n+    private static final int NUM_TASK_THREADS = 8;", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3NzA2Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484577067", "bodyText": "Are there multiple kinds of comparators? Oh, yes, indeed there are. localChunkProvider.relevanceSystem is something complicated, and RemoteChunkProvider does something simpler.\nIn that case, I agree that passing it in to the constructor here is the thing to do.", "author": "keturn", "createdAt": "2020-09-07T22:21:06Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/ChunkProcessingPipeline.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.Vector3i;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.utilities.concurrency.TaskMaster;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.tasks.ChunkTaskListenerWrapper;\n+\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Manages execution of chunk tasks on a queue.\n+ * <p>\n+ * {@link ChunkTask}s are executing in background threads.\n+ * <p>\n+ * {@link ChunkTask}s are executing by priority via {@link Comparable}.\n+ * <p>\n+ * {@link Chunk}s will processing on stages {@link ChunkProcessingPipeline#addStage}\n+ */\n+public class ChunkProcessingPipeline implements ChunkTaskListener {\n+    private static final int NUM_TASK_THREADS = 8;\n+    private static final Logger logger = LoggerFactory.getLogger(ChunkProcessingPipeline.class);\n+\n+    private final TaskMaster<ChunkTask> chunkProcessor;\n+    private final List<Function<Chunk, ChunkTask>> stages = new LinkedList<>();\n+    private final List<ChunkTaskListener> chunkTaskListeners = new LinkedList<>();\n+    private final List<ChunkRemoveFromPipelineListener> chunkRemoveFromPipelineListeners = new LinkedList<>();\n+    private final Map<Chunk, Deque<Function<Chunk, ChunkTask>>> chunkNextStages = new ConcurrentHashMap<>();\n+    private final Set<org.joml.Vector3i> processingPositions = Sets.newConcurrentHashSet();\n+    private final Set<org.joml.Vector3i> invalidatedPositions = Sets.newConcurrentHashSet();\n+\n+    /**\n+     * Create ChunkProcessingTaskMaster.\n+     *\n+     * @param taskComparator using by TaskMaster for priority ordering task.\n+     */\n+    public ChunkProcessingPipeline(Comparator<ChunkTask> taskComparator) {", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3MDczNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484670737", "bodyText": "yes, it is.", "author": "DarkWeird", "createdAt": "2020-09-08T06:07:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3NzA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3ODk4Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484578982", "bodyText": "Is there a good reason for this ever to be null, or can we make it a checkNotNull(chunk) instead of a silent return?", "author": "keturn", "createdAt": "2020-09-07T22:36:46Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/ChunkProcessingPipeline.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.Vector3i;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.utilities.concurrency.TaskMaster;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.tasks.ChunkTaskListenerWrapper;\n+\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Manages execution of chunk tasks on a queue.\n+ * <p>\n+ * {@link ChunkTask}s are executing in background threads.\n+ * <p>\n+ * {@link ChunkTask}s are executing by priority via {@link Comparable}.\n+ * <p>\n+ * {@link Chunk}s will processing on stages {@link ChunkProcessingPipeline#addStage}\n+ */\n+public class ChunkProcessingPipeline implements ChunkTaskListener {\n+    private static final int NUM_TASK_THREADS = 8;\n+    private static final Logger logger = LoggerFactory.getLogger(ChunkProcessingPipeline.class);\n+\n+    private final TaskMaster<ChunkTask> chunkProcessor;\n+    private final List<Function<Chunk, ChunkTask>> stages = new LinkedList<>();\n+    private final List<ChunkTaskListener> chunkTaskListeners = new LinkedList<>();\n+    private final List<ChunkRemoveFromPipelineListener> chunkRemoveFromPipelineListeners = new LinkedList<>();\n+    private final Map<Chunk, Deque<Function<Chunk, ChunkTask>>> chunkNextStages = new ConcurrentHashMap<>();\n+    private final Set<org.joml.Vector3i> processingPositions = Sets.newConcurrentHashSet();\n+    private final Set<org.joml.Vector3i> invalidatedPositions = Sets.newConcurrentHashSet();\n+\n+    /**\n+     * Create ChunkProcessingTaskMaster.\n+     *\n+     * @param taskComparator using by TaskMaster for priority ordering task.\n+     */\n+    public ChunkProcessingPipeline(Comparator<ChunkTask> taskComparator) {\n+        chunkProcessor = TaskMaster.createDynamicPriorityTaskMaster(\"Chunk-Processing\", NUM_TASK_THREADS,\n+                taskComparator);\n+    }\n+\n+    /**\n+     * Add stage to pipeline. If stage instance of {@link ChunkTaskListener} - it's will be register as listener. If\n+     * stage instance of {@link ChunkRemoveFromPipelineListener} - it's will be register as listener.\n+     *\n+     * @param stage function for ChunkTask generating by Chunk.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addStage(Function<Chunk, ChunkTask> stage) {\n+        stages.add(stage);\n+        if (stage instanceof ChunkTaskListener) {\n+            addListener((ChunkTaskListener) stage);\n+        }\n+        if (stage instanceof ChunkRemoveFromPipelineListener) {\n+            addListener((ChunkRemoveFromPipelineListener) stage);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Register chunk task listener.\n+     *\n+     * @param listener listener.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addListener(ChunkTaskListener listener) {\n+        chunkTaskListeners.add(listener);\n+        return this;\n+    }\n+\n+    /**\n+     * Register chunk task listener.\n+     *\n+     * @param listener listener.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addListener(ChunkRemoveFromPipelineListener listener) {\n+        chunkRemoveFromPipelineListeners.add(listener);\n+        return this;\n+    }\n+\n+    /**\n+     * Run generator task and then run pipeline processing with it.\n+     *\n+     * @param generatorTask ChunkTask which provides new chunk to pipeline\n+     */\n+    public void invokeGeneratorTask(SupplierChunkTask generatorTask) {\n+        if (processingPositions.contains(generatorTask.getPosition())) {\n+            return;\n+        }\n+        processingPositions.add(generatorTask.getPosition());\n+        doTask(new ChunkTaskListenerWrapper(generatorTask, (chunkTask) -> invokePipeline(chunkTask.getChunk())));\n+    }\n+\n+    /**\n+     * Send chunk to processing pipeline. If chunk not processing yet then pipeline will be setted. If chunk processed\n+     * then chunk will be processing in next stage;\n+     *\n+     * @param chunk chunk to process.\n+     */\n+    public void invokePipeline(Chunk chunk) {\n+        if (chunk == null) {\n+            return;", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3MTA0Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484671043", "bodyText": "See InterruptChunkTask", "author": "DarkWeird", "createdAt": "2020-09-08T06:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3ODk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3OTU4Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484579583", "bodyText": "This Function<Chunk, ChunkTask> type shows up just enough times for me to wonder if it's worth making a type alias for it.\nOh, does Java not have type aliases? Um. Functional interface?", "author": "keturn", "createdAt": "2020-09-07T22:41:50Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/ChunkProcessingPipeline.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.Vector3i;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.utilities.concurrency.TaskMaster;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.tasks.ChunkTaskListenerWrapper;\n+\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Manages execution of chunk tasks on a queue.\n+ * <p>\n+ * {@link ChunkTask}s are executing in background threads.\n+ * <p>\n+ * {@link ChunkTask}s are executing by priority via {@link Comparable}.\n+ * <p>\n+ * {@link Chunk}s will processing on stages {@link ChunkProcessingPipeline#addStage}\n+ */\n+public class ChunkProcessingPipeline implements ChunkTaskListener {\n+    private static final int NUM_TASK_THREADS = 8;\n+    private static final Logger logger = LoggerFactory.getLogger(ChunkProcessingPipeline.class);\n+\n+    private final TaskMaster<ChunkTask> chunkProcessor;\n+    private final List<Function<Chunk, ChunkTask>> stages = new LinkedList<>();", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3MDUxNg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484670516", "bodyText": "Yeah Functional interfaces.", "author": "DarkWeird", "createdAt": "2020-09-08T06:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU3OTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU4NTY5MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484585691", "bodyText": "hmm, I think we can improve on this.\nConcerns:\n\nthis NotifyChunkTask has stuff in it not related to notifications: chunkCache and markReady.\nit calls something named onChunkReady before doing chunk.markReady?\n\nchunk.markReady seems extraneous? i.e. is this task doing anything to improve the readiness of the chunk?\n\n\ncould listener be null? IntelliJ surprisingly hasn't yelled at me about this, but it's not immediately obvious that subscribe will always be called with a non-null value before the pipeline receives a chunk.\nthe Pipeline already manages its list of chunkTaskListeners, but here we have this NotifyChunkTask that is a different way of supporting listeners?\n\nCould this be more like:\nloadingPipeline.addListener((chunkTask) -> listener.onChunkReady(chunkTask.getPosition()))  // also needs null-check for `listener`\n    .addListener((chunkTask) -> worldEntity.send(new OnChunkLoaded(chunkTask.getPosition()))", "author": "keturn", "createdAt": "2020-09-07T23:30:45Z", "path": "engine/src/main/java/org/terasology/world/chunks/remoteChunkProvider/RemoteChunkProvider.java", "diffHunk": "@@ -24,105 +11,100 @@\n import org.terasology.entitySystem.entity.EntityRef;\n import org.terasology.logic.players.LocalPlayer;\n import org.terasology.math.ChunkMath;\n+import org.terasology.math.JomlUtil;\n import org.terasology.math.Region3i;\n import org.terasology.math.TeraMath;\n-import org.terasology.math.geom.Vector3f;\n import org.terasology.math.geom.Vector3i;\n-import org.terasology.monitoring.PerformanceMonitor;\n import org.terasology.monitoring.chunk.ChunkMonitor;\n import org.terasology.world.block.BlockManager;\n import org.terasology.world.chunks.Chunk;\n import org.terasology.world.chunks.ChunkConstants;\n import org.terasology.world.chunks.ChunkProvider;\n-import org.terasology.world.chunks.ChunkRegionListener;\n import org.terasology.world.chunks.event.BeforeChunkUnload;\n import org.terasology.world.chunks.event.OnChunkLoaded;\n-import org.terasology.world.chunks.internal.GeneratingChunkProvider;\n-import org.terasology.world.chunks.pipeline.AbstractChunkTask;\n-import org.terasology.world.chunks.pipeline.ChunkGenerationPipeline;\n+import org.terasology.world.chunks.pipeline.ChunkProcessingPipeline;\n import org.terasology.world.chunks.pipeline.ChunkTask;\n+import org.terasology.world.chunks.pipeline.LightMergerChunkTaskProvider;\n+import org.terasology.world.chunks.pipeline.tasks.DeflateChunkTask;\n+import org.terasology.world.chunks.pipeline.tasks.GenerateInternalLightningChunkTask;\n+import org.terasology.world.chunks.pipeline.tasks.NotifyChunkTask;\n import org.terasology.world.internal.ChunkViewCore;\n import org.terasology.world.internal.ChunkViewCoreImpl;\n-import org.terasology.world.propagation.light.InternalLightProcessor;\n-import org.terasology.world.propagation.light.LightMerger;\n \n import java.math.RoundingMode;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.BlockingQueue;\n \n /**\n- *\n+ * Provides chunks received from remote source.\n+ * <p>\n+ * Loading/Unload chunks dependent on {@link org.terasology.network.Server}\n+ * <p/>\n+ * Produce events:\n+ * <p>\n+ * {@link OnChunkLoaded} when chunk received from server and processed.\n+ * <p>\n+ * {@link BeforeChunkUnload} when {@link org.terasology.network.Server} send invalidate chunk and chunk removing\n  */\n-public class RemoteChunkProvider implements ChunkProvider, GeneratingChunkProvider {\n+public class RemoteChunkProvider implements ChunkProvider {\n \n     private static final Logger logger = LoggerFactory.getLogger(RemoteChunkProvider.class);\n-    private Map<Vector3i, Chunk> chunkCache = Maps.newHashMap();\n-    private final BlockingQueue<Chunk> readyChunks = Queues.newLinkedBlockingQueue();\n     private final BlockingQueue<Vector3i> invalidateChunks = Queues.newLinkedBlockingQueue();\n-    private List<Chunk> sortedReadyChunks = Lists.newArrayList();\n+    private Map<Vector3i, Chunk> chunkCache = Maps.newHashMap();\n     private ChunkReadyListener listener;\n     private EntityRef worldEntity = EntityRef.NULL;\n \n     private BlockManager blockManager;\n \n-    private ChunkGenerationPipeline pipeline;\n-\n-    private LightMerger<Chunk> lightMerger = new LightMerger<>(this);\n+    private ChunkProcessingPipeline loadingPipeline;\n \n     private LocalPlayer localPlayer;\n \n     public RemoteChunkProvider(BlockManager blockManager, LocalPlayer localPlayer) {\n         this.blockManager = blockManager;\n         this.localPlayer = localPlayer;\n-        pipeline = new ChunkGenerationPipeline(new ChunkTaskRelevanceComparator());\n+        loadingPipeline = new ChunkProcessingPipeline(new ChunkTaskRelevanceComparator());\n+\n+        loadingPipeline.addStage(GenerateInternalLightningChunkTask::new)\n+                .addStage(DeflateChunkTask::new)\n+                .addStage(new LightMergerChunkTaskProvider(this, loadingPipeline))\n+                .addStage(NotifyChunkTask.stage(\"Notify listeners\", (chunk) -> {\n+                    listener.onChunkReady(chunk.getPosition());\n+                    worldEntity.send(new OnChunkLoaded(chunk.getPosition()));\n+                    Chunk oldChunk = chunkCache.put(chunk.getPosition(), chunk);\n+                    if (oldChunk != null) {\n+                        oldChunk.dispose();\n+                    }\n+                    chunk.markReady();", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MjI1Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484682252", "bodyText": "this NotifyChunkTask has stuff in it not related to notifications: chunkCache and markReady.\n\n... :(\n\nit calls something named onChunkReady before doing chunk.markReady?\n\nyeah it is some kind of smell. listener(Server) not need chunk itself now.\n\nchunk.markReady seems extraneous? i.e. is this task doing anything to improve the readiness of the chunk?\n\nIt is only this.ready = true T_T idk why do there :D\n\ncould listener be null? IntelliJ surprisingly hasn't yelled at me about this, but it's not immediately obvious that subscribe will always be called with a non-null value before the pipeline receives a chunk.\n\nCurrently - no\n\nthe Pipeline already manages its list of chunkTaskListeners, but here we have this NotifyChunkTask that is a different way of supporting listeners?\n\nChunkTaskListeners it is more internal listeners or technical. it firing on every stage.\nNotifyChunkTask - Better naming LambdaChunkTask :D\n\nloadingPipeline.addListener((chunkTask) -> listener.onChunkReady(chunkTask.getPosition()))  // also needs null-check for listener\n.addListener((chunkTask) -> worldEntity.send(new OnChunkLoaded(chunkTask.getPosition()))\n\nlisteners - technical listeners. ChunkRemoveFromPipelineListener(aka ChunkTaskListener) It can be used for watch pipeline stage in other world. it is used by Stages itself.", "author": "DarkWeird", "createdAt": "2020-09-08T06:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU4NTY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU4NzU5Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484587596", "bodyText": "TaskManager.put says it may block if the queue is full. Ideally, the queue doesn't get full (and, in fact, the current implementation of DynamicPriorityBlockingQueue uses a linked list which won't ever be \"full\"), but is that the failure mode we want? It might be better to start dropping chunks and throwing errors instead of blocking the main thread.", "author": "keturn", "createdAt": "2020-09-07T23:45:41Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/ChunkProcessingPipeline.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.Vector3i;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.utilities.concurrency.TaskMaster;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.tasks.ChunkTaskListenerWrapper;\n+\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Manages execution of chunk tasks on a queue.\n+ * <p>\n+ * {@link ChunkTask}s are executing in background threads.\n+ * <p>\n+ * {@link ChunkTask}s are executing by priority via {@link Comparable}.\n+ * <p>\n+ * {@link Chunk}s will processing on stages {@link ChunkProcessingPipeline#addStage}\n+ */\n+public class ChunkProcessingPipeline implements ChunkTaskListener {\n+    private static final int NUM_TASK_THREADS = 8;\n+    private static final Logger logger = LoggerFactory.getLogger(ChunkProcessingPipeline.class);\n+\n+    private final TaskMaster<ChunkTask> chunkProcessor;\n+    private final List<Function<Chunk, ChunkTask>> stages = new LinkedList<>();\n+    private final List<ChunkTaskListener> chunkTaskListeners = new LinkedList<>();\n+    private final List<ChunkRemoveFromPipelineListener> chunkRemoveFromPipelineListeners = new LinkedList<>();\n+    private final Map<Chunk, Deque<Function<Chunk, ChunkTask>>> chunkNextStages = new ConcurrentHashMap<>();\n+    private final Set<org.joml.Vector3i> processingPositions = Sets.newConcurrentHashSet();\n+    private final Set<org.joml.Vector3i> invalidatedPositions = Sets.newConcurrentHashSet();\n+\n+    /**\n+     * Create ChunkProcessingTaskMaster.\n+     *\n+     * @param taskComparator using by TaskMaster for priority ordering task.\n+     */\n+    public ChunkProcessingPipeline(Comparator<ChunkTask> taskComparator) {\n+        chunkProcessor = TaskMaster.createDynamicPriorityTaskMaster(\"Chunk-Processing\", NUM_TASK_THREADS,\n+                taskComparator);\n+    }\n+\n+    /**\n+     * Add stage to pipeline. If stage instance of {@link ChunkTaskListener} - it's will be register as listener. If\n+     * stage instance of {@link ChunkRemoveFromPipelineListener} - it's will be register as listener.\n+     *\n+     * @param stage function for ChunkTask generating by Chunk.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addStage(Function<Chunk, ChunkTask> stage) {\n+        stages.add(stage);\n+        if (stage instanceof ChunkTaskListener) {\n+            addListener((ChunkTaskListener) stage);\n+        }\n+        if (stage instanceof ChunkRemoveFromPipelineListener) {\n+            addListener((ChunkRemoveFromPipelineListener) stage);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Register chunk task listener.\n+     *\n+     * @param listener listener.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addListener(ChunkTaskListener listener) {\n+        chunkTaskListeners.add(listener);\n+        return this;\n+    }\n+\n+    /**\n+     * Register chunk task listener.\n+     *\n+     * @param listener listener.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addListener(ChunkRemoveFromPipelineListener listener) {\n+        chunkRemoveFromPipelineListeners.add(listener);\n+        return this;\n+    }\n+\n+    /**\n+     * Run generator task and then run pipeline processing with it.\n+     *\n+     * @param generatorTask ChunkTask which provides new chunk to pipeline\n+     */\n+    public void invokeGeneratorTask(SupplierChunkTask generatorTask) {\n+        if (processingPositions.contains(generatorTask.getPosition())) {\n+            return;\n+        }\n+        processingPositions.add(generatorTask.getPosition());\n+        doTask(new ChunkTaskListenerWrapper(generatorTask, (chunkTask) -> invokePipeline(chunkTask.getChunk())));\n+    }\n+\n+    /**\n+     * Send chunk to processing pipeline. If chunk not processing yet then pipeline will be setted. If chunk processed\n+     * then chunk will be processing in next stage;\n+     *\n+     * @param chunk chunk to process.\n+     */\n+    public void invokePipeline(Chunk chunk) {\n+        if (chunk == null) {\n+            return;\n+        }\n+        Function<Chunk, ChunkTask> nextStage =\n+                chunkNextStages.computeIfAbsent(chunk, c -> new LinkedList<>(stages)).poll();\n+        Vector3i position = chunk.getPosition(new Vector3i());\n+\n+        if (chunk.isReady() || invalidatedPositions.remove(position) || nextStage == null) {\n+            processingPositions.remove(position);\n+            chunkNextStages.remove(chunk);\n+            chunkRemoveFromPipelineListeners.forEach(l -> l.onRemove(position));\n+            return;\n+        }\n+        invokeStage(chunk, nextStage);\n+    }\n+\n+    public void shutdown() {\n+        chunkNextStages.clear();\n+        processingPositions.clear();\n+        chunkProcessor.shutdown(new ShutdownChunkTask(), false);\n+    }\n+\n+    public void restart() {\n+        chunkNextStages.clear();\n+        processingPositions.clear();\n+        chunkProcessor.restart();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param chunkTask ChunkTask which done processing.\n+     */\n+    @Override\n+    public void onDone(ChunkTask chunkTask) {\n+        chunkTaskListeners.forEach((listener) -> listener.onDone(chunkTask));\n+        logger.debug(\"Task \" + chunkTask + \" done\");\n+        invokePipeline(chunkTask.getChunk());\n+    }\n+\n+    /**\n+     * Stop processing chunk at position.\n+     *\n+     * @param pos position of chunk to stop processing.\n+     */\n+    public void stopProcessingAt(Vector3i pos) {\n+        invalidatedPositions.add(pos);\n+        processingPositions.remove(pos);\n+        chunkRemoveFromPipelineListeners.forEach(l -> l.onRemove(pos));\n+    }\n+\n+    /**\n+     * Check is position processing.\n+     *\n+     * @param pos position for check\n+     * @return true if position processing, false otherwise\n+     */\n+    public boolean isPositionProcessing(org.joml.Vector3i pos) {\n+        return processingPositions.contains(pos);\n+    }\n+\n+    /**\n+     * Get processing positions.\n+     *\n+     * @return copy of processing positions\n+     */\n+    public List<org.joml.Vector3i> getProcessingPosition() {\n+        return new LinkedList<>(processingPositions);\n+    }\n+\n+    /**\n+     * Wrap chunktask with this as listener and do it.\n+     *\n+     * @param task task which wrapping.\n+     */\n+    void doTaskWrapper(ChunkTask task) {\n+        ChunkTask wrapper = new ChunkTaskListenerWrapper(task, this);\n+        doTask(wrapper);\n+    }\n+\n+    private void doTask(ChunkTask task) {\n+        try {\n+            logger.debug(\"Start processing task :\" + task);\n+            chunkProcessor.put(task);", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3MjEzOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484672139", "bodyText": "Seems it is changing for TaskMaster", "author": "DarkWeird", "createdAt": "2020-09-08T06:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU4NzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5MjYzMw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484592633", "bodyText": "I was confused by the use of \"done\" here. How is it done if the pipeline hasn't even been invoked yet?\nbut this also shows me something about that comment I left on RemoteChunkProvider's use of NotifyChunkTask. It doesn't use addListener for those because those listeners would be called before the chunk is finished with the pipeline!\nThe fact that addStage may also treat the stage as a listener gets extra confusing here, because this ChunkTask will be sent to all those listening-stages now, but it will also be sent to that stage later in the pipeline.", "author": "keturn", "createdAt": "2020-09-08T00:23:37Z", "path": "engine/src/main/java/org/terasology/world/chunks/pipeline/ChunkProcessingPipeline.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Sets;\n+import org.joml.Vector3i;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.utilities.concurrency.TaskMaster;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.pipeline.tasks.ChunkTaskListenerWrapper;\n+\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Manages execution of chunk tasks on a queue.\n+ * <p>\n+ * {@link ChunkTask}s are executing in background threads.\n+ * <p>\n+ * {@link ChunkTask}s are executing by priority via {@link Comparable}.\n+ * <p>\n+ * {@link Chunk}s will processing on stages {@link ChunkProcessingPipeline#addStage}\n+ */\n+public class ChunkProcessingPipeline implements ChunkTaskListener {\n+    private static final int NUM_TASK_THREADS = 8;\n+    private static final Logger logger = LoggerFactory.getLogger(ChunkProcessingPipeline.class);\n+\n+    private final TaskMaster<ChunkTask> chunkProcessor;\n+    private final List<Function<Chunk, ChunkTask>> stages = new LinkedList<>();\n+    private final List<ChunkTaskListener> chunkTaskListeners = new LinkedList<>();\n+    private final List<ChunkRemoveFromPipelineListener> chunkRemoveFromPipelineListeners = new LinkedList<>();\n+    private final Map<Chunk, Deque<Function<Chunk, ChunkTask>>> chunkNextStages = new ConcurrentHashMap<>();\n+    private final Set<org.joml.Vector3i> processingPositions = Sets.newConcurrentHashSet();\n+    private final Set<org.joml.Vector3i> invalidatedPositions = Sets.newConcurrentHashSet();\n+\n+    /**\n+     * Create ChunkProcessingTaskMaster.\n+     *\n+     * @param taskComparator using by TaskMaster for priority ordering task.\n+     */\n+    public ChunkProcessingPipeline(Comparator<ChunkTask> taskComparator) {\n+        chunkProcessor = TaskMaster.createDynamicPriorityTaskMaster(\"Chunk-Processing\", NUM_TASK_THREADS,\n+                taskComparator);\n+    }\n+\n+    /**\n+     * Add stage to pipeline. If stage instance of {@link ChunkTaskListener} - it's will be register as listener. If\n+     * stage instance of {@link ChunkRemoveFromPipelineListener} - it's will be register as listener.\n+     *\n+     * @param stage function for ChunkTask generating by Chunk.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addStage(Function<Chunk, ChunkTask> stage) {\n+        stages.add(stage);\n+        if (stage instanceof ChunkTaskListener) {\n+            addListener((ChunkTaskListener) stage);\n+        }\n+        if (stage instanceof ChunkRemoveFromPipelineListener) {\n+            addListener((ChunkRemoveFromPipelineListener) stage);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Register chunk task listener.\n+     *\n+     * @param listener listener.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addListener(ChunkTaskListener listener) {\n+        chunkTaskListeners.add(listener);\n+        return this;\n+    }\n+\n+    /**\n+     * Register chunk task listener.\n+     *\n+     * @param listener listener.\n+     * @return self for Fluent api.\n+     */\n+    public ChunkProcessingPipeline addListener(ChunkRemoveFromPipelineListener listener) {\n+        chunkRemoveFromPipelineListeners.add(listener);\n+        return this;\n+    }\n+\n+    /**\n+     * Run generator task and then run pipeline processing with it.\n+     *\n+     * @param generatorTask ChunkTask which provides new chunk to pipeline\n+     */\n+    public void invokeGeneratorTask(SupplierChunkTask generatorTask) {\n+        if (processingPositions.contains(generatorTask.getPosition())) {\n+            return;\n+        }\n+        processingPositions.add(generatorTask.getPosition());\n+        doTask(new ChunkTaskListenerWrapper(generatorTask, (chunkTask) -> invokePipeline(chunkTask.getChunk())));\n+    }\n+\n+    /**\n+     * Send chunk to processing pipeline. If chunk not processing yet then pipeline will be setted. If chunk processed\n+     * then chunk will be processing in next stage;\n+     *\n+     * @param chunk chunk to process.\n+     */\n+    public void invokePipeline(Chunk chunk) {\n+        if (chunk == null) {\n+            return;\n+        }\n+        Function<Chunk, ChunkTask> nextStage =\n+                chunkNextStages.computeIfAbsent(chunk, c -> new LinkedList<>(stages)).poll();\n+        Vector3i position = chunk.getPosition(new Vector3i());\n+\n+        if (chunk.isReady() || invalidatedPositions.remove(position) || nextStage == null) {\n+            processingPositions.remove(position);\n+            chunkNextStages.remove(chunk);\n+            chunkRemoveFromPipelineListeners.forEach(l -> l.onRemove(position));\n+            return;\n+        }\n+        invokeStage(chunk, nextStage);\n+    }\n+\n+    public void shutdown() {\n+        chunkNextStages.clear();\n+        processingPositions.clear();\n+        chunkProcessor.shutdown(new ShutdownChunkTask(), false);\n+    }\n+\n+    public void restart() {\n+        chunkNextStages.clear();\n+        processingPositions.clear();\n+        chunkProcessor.restart();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param chunkTask ChunkTask which done processing.\n+     */\n+    @Override\n+    public void onDone(ChunkTask chunkTask) {\n+        chunkTaskListeners.forEach((listener) -> listener.onDone(chunkTask));\n+        logger.debug(\"Task \" + chunkTask + \" done\");\n+        invokePipeline(chunkTask.getChunk());", "originalCommit": "c397648c6b665f40e597db830451ce7ee18ef6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5NDIxOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484594219", "bodyText": "ohh, okay, part of my confusion is invokePipeline doesn't necessarily mean start the pipeline on that chunk. It means \"run the next stage in the pipeline for this chunk.\"", "author": "keturn", "createdAt": "2020-09-08T00:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5MjYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3MTc0NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r484671745", "bodyText": "then better naming onChunkTaskDone ?", "author": "DarkWeird", "createdAt": "2020-09-08T06:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU5MjYzMw=="}], "type": "inlineReview"}, {"oid": "0043f0e5f9452b5676ab97e35acdce90aebc59cb", "url": "https://github.com/MovingBlocks/Terasology/commit/0043f0e5f9452b5676ab97e35acdce90aebc59cb", "message": "refactoring(chunkprovider): reimplement ChunkProcessingPipeline on ForkJoinPool", "committedDate": "2020-09-13T20:53:52Z", "type": "commit"}, {"oid": "81df1031a33b02f6dfcc275836d4d1193b70c182", "url": "https://github.com/MovingBlocks/Terasology/commit/81df1031a33b02f6dfcc275836d4d1193b70c182", "message": "refactoring(chunkprovider): reimplement ChunkProcessingPipeline on CompletableFuture", "committedDate": "2020-09-15T21:14:10Z", "type": "commit"}, {"oid": "6ab1d3d4aed405bb02356bfaf5ba8ab2a923daee", "url": "https://github.com/MovingBlocks/Terasology/commit/6ab1d3d4aed405bb02356bfaf5ba8ab2a923daee", "message": "refactor(chunkprovider): reimplement ChunkProcessingPipeline on CompletableFuture and ForkJoinPool.", "committedDate": "2020-09-18T13:40:25Z", "type": "commit"}, {"oid": "114e9c40459e127537899a6fe092fb08297b85c9", "url": "https://github.com/MovingBlocks/Terasology/commit/114e9c40459e127537899a6fe092fb08297b85c9", "message": "refactor(chunkprovider): chore and javadocs.", "committedDate": "2020-09-18T14:41:31Z", "type": "commit"}, {"oid": "e76100625304c8db2479e0b3a1cdee9252deab0f", "url": "https://github.com/MovingBlocks/Terasology/commit/e76100625304c8db2479e0b3a1cdee9252deab0f", "message": "refactor(chunkprovider): migrate LocalChunkProviderTest to use ChunkProcessingPipeline's future", "committedDate": "2020-09-18T14:49:09Z", "type": "commit"}, {"oid": "6497fa279ee65843d34a95b6ace97f931f4a90f9", "url": "https://github.com/MovingBlocks/Terasology/commit/6497fa279ee65843d34a95b6ace97f931f4a90f9", "message": "refactor(chunkprovider): reimplement Pipeline again", "committedDate": "2020-09-21T15:01:14Z", "type": "commit"}, {"oid": "6497fa279ee65843d34a95b6ace97f931f4a90f9", "url": "https://github.com/MovingBlocks/Terasology/commit/6497fa279ee65843d34a95b6ace97f931f4a90f9", "message": "refactor(chunkprovider): reimplement Pipeline again", "committedDate": "2020-09-21T15:01:14Z", "type": "forcePushed"}, {"oid": "e226d76503dbd0c8f3f9db7afc1516d7f5c1c77e", "url": "https://github.com/MovingBlocks/Terasology/commit/e226d76503dbd0c8f3f9db7afc1516d7f5c1c77e", "message": "Merge remote-tracking branch 'upstream/develop' into refactor/chunkprovider", "committedDate": "2020-09-21T17:14:56Z", "type": "commit"}, {"oid": "e9d75b5ec47ee64e45ef64bc8495069a7499b4a0", "url": "https://github.com/MovingBlocks/Terasology/commit/e9d75b5ec47ee64e45ef64bc8495069a7499b4a0", "message": "refactoring(chunkprovider): Small fixes", "committedDate": "2020-09-21T18:54:44Z", "type": "commit"}, {"oid": "1e2742f7b85dc29832de7e86315fa7a208317e3b", "url": "https://github.com/MovingBlocks/Terasology/commit/1e2742f7b85dc29832de7e86315fa7a208317e3b", "message": "refactor(chunkprovider): add tests for ChunkProcessingPipeline and some chores in Pipeline", "committedDate": "2020-09-22T13:53:54Z", "type": "commit"}, {"oid": "943641b3ce83952cf5a60d7812b120e46779d78b", "url": "https://github.com/MovingBlocks/Terasology/commit/943641b3ce83952cf5a60d7812b120e46779d78b", "message": "refactor(chunkprovider): fix imports", "committedDate": "2020-09-22T14:05:33Z", "type": "commit"}, {"oid": "354e746c1b872be72cec99b2305e0357b3660865", "url": "https://github.com/MovingBlocks/Terasology/commit/354e746c1b872be72cec99b2305e0357b3660865", "message": "refactor(chunkprovider): Return comparable - chunk loading priority", "committedDate": "2020-09-22T14:54:30Z", "type": "commit"}, {"oid": "625cd1060e4358db3725267459dca5ab0129657d", "url": "https://github.com/MovingBlocks/Terasology/commit/625cd1060e4358db3725267459dca5ab0129657d", "message": "refactor(chunkprovider):remove jetbrains annotation from tests", "committedDate": "2020-09-22T14:56:52Z", "type": "commit"}, {"oid": "125034f0c11ce28ba92c81d23a03361451f5490d", "url": "https://github.com/MovingBlocks/Terasology/commit/125034f0c11ce28ba92c81d23a03361451f5490d", "message": "refactor(chunkprovider): Cleanup and refactor Pipeline's code", "committedDate": "2020-09-23T13:51:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3MTg5Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4140#discussion_r499171896", "bodyText": "are these real sleeps in the tests, not using some mock clock that doesn't actually use real time?\nI think it's worth taking another look at this to see if we can come up with something that is faster but still reliable.", "author": "keturn", "createdAt": "2020-10-03T18:42:33Z", "path": "engine-tests/src/test/java/org/terasology/world/chunks/pipeline/ChunkProcessingPipelineTest.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.world.chunks.pipeline;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import org.joml.Vector3i;\n+import org.joml.Vector3ic;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.terasology.TerasologyTestingEnvironment;\n+import org.terasology.assets.management.AssetManager;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.registry.CoreRegistry;\n+import org.terasology.world.block.BlockManager;\n+import org.terasology.world.block.internal.BlockManagerImpl;\n+import org.terasology.world.block.tiles.NullWorldAtlas;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.blockdata.ExtraBlockDataManager;\n+import org.terasology.world.chunks.internal.ChunkImpl;\n+import org.terasology.world.chunks.pipeline.stages.ChunkTaskProvider;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_METHOD)\n+class ChunkProcessingPipelineTest extends TerasologyTestingEnvironment {\n+\n+    private final BlockManager blockManager = new BlockManagerImpl(new NullWorldAtlas(),\n+            CoreRegistry.get(AssetManager.class));\n+    private final ExtraBlockDataManager extraDataManager = new ExtraBlockDataManager();\n+    private ChunkProcessingPipeline pipeline;\n+\n+    @Test\n+    void simpleProcessingSuccess() throws ExecutionException, InterruptedException, TimeoutException {\n+        pipeline = new ChunkProcessingPipeline((p) -> null, (o1, o2) -> 0);\n+\n+        org.terasology.math.geom.Vector3i chunkPos = new org.terasology.math.geom.Vector3i(0, 0, 0);\n+        Chunk chunk = createChunkAt(chunkPos);\n+\n+        pipeline.addStage(ChunkTaskProvider.create(\"dummy task\", (c) -> c));\n+\n+        Future<Chunk> chunkFuture = pipeline.invokeGeneratorTask(new Vector3i(0, 0, 0), () -> chunk);\n+        Chunk chunkAfterProcessing = chunkFuture.get(1, TimeUnit.SECONDS);\n+\n+        Assertions.assertEquals(chunkAfterProcessing.getPosition(new Vector3i()), chunk.getPosition(new Vector3i()),\n+                \"Chunk after processing must have equals position, probably pipeline lost you chunk\");\n+    }\n+\n+    @Test\n+    void simpleStopProcessingSuccess() {\n+        pipeline = new ChunkProcessingPipeline((p) -> null, (o1, o2) -> 0);\n+\n+        Vector3i position = new Vector3i(0, 0, 0);\n+        Chunk chunk = createChunkAt(position);\n+\n+\n+        pipeline.addStage(ChunkTaskProvider.create(\"dummy long executing task\", (c) -> {\n+            try {\n+                Thread.sleep(1_000);", "originalCommit": "125034f0c11ce28ba92c81d23a03361451f5490d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}