{"pr_number": 4327, "pr_title": "TeraEd: Run Terasology in Swing/AWT", "pr_createdAt": "2020-12-21T13:23:03Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4327", "timeline": [{"oid": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "url": "https://github.com/MovingBlocks/Terasology/commit/613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "message": "TeraEd: Run Terasology in Swing/AWT", "committedDate": "2020-12-21T12:58:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzNzExOA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546837118", "bodyText": "Don't think that right. Rendering can be openGL-less.(like vulkan in future, or CPU rendering(yeah it can be))", "author": "DarkWeird", "createdAt": "2020-12-21T17:34:16Z", "path": "engine/src/main/java/org/terasology/engine/subsystem/DisplayDeviceInfo.java", "diffHunk": "@@ -0,0 +1,12 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.engine.subsystem;\n+\n+public interface DisplayDeviceInfo {", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5ODQyNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546898425", "bodyText": "Well, it is actually already the case as there is HeadlessDisplayDevice. Didn't want to tackle that as it is currently used for metrics only. But I'm ok with any alternative you wish to suggest.", "author": "hajdam", "createdAt": "2020-12-21T19:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzNzExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzNzU1Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546837556", "bodyText": "Seems this initialization was in construct, isn't it?", "author": "DarkWeird", "createdAt": "2020-12-21T17:35:13Z", "path": "engine/src/main/java/org/terasology/engine/subsystem/headless/HeadlessGraphics.java", "diffHunk": "@@ -73,8 +73,16 @@ public void registerCoreAssetTypes(ModuleAwareAssetTypeManager assetTypeManager)\n         assetTypeManager.registerCoreAssetType(Material.class, (AssetFactory<Material, MaterialData>) HeadlessMaterial::new, \"materials\");\n         assetTypeManager.registerCoreAssetType(Mesh.class, (AssetFactory<Mesh, MeshData>) HeadlessMesh::new, \"mesh\");\n         assetTypeManager.registerCoreAssetType(SkeletalMesh.class, (AssetFactory<SkeletalMesh, SkeletalMeshData>) HeadlessSkeletalMesh::new, \"skeletalMesh\");\n-        assetTypeManager.registerCoreAssetType(MeshAnimation.class, (AssetFactory<MeshAnimation, MeshAnimationData>) MeshAnimationImpl::new, \"animations\", \"skeletalMesh\");\n-        assetTypeManager.registerCoreAssetType(MeshAnimationBundle.class, (AssetFactory<MeshAnimationBundle, MeshAnimationBundleData>) MeshAnimationBundle::new, \"skeletalMesh\", \"animations\");\n+        assetTypeManager.registerCoreAssetType(MeshAnimation.class, (AssetFactory<MeshAnimation, MeshAnimationData>) (urn, assetType, data) -> {\n+            MeshAnimationImpl meshAnimationImpl = new MeshAnimationImpl(urn, assetType, data);\n+            meshAnimationImpl.glInitialize();", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4MTI5NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546881295", "bodyText": "Yes, but I had to extract openGL initialization as it has to be done with active OpenGL, which is not the case for TeraEd (subsystem constructors are run before TeraEd have got OpenGL canvas available - glInitialize is postponed for later call in render method there)", "author": "hajdam", "createdAt": "2020-12-21T19:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzNzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzOTA1MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546839050", "bodyText": "Are you move \"main\" thread  there?", "author": "DarkWeird", "createdAt": "2020-12-21T17:38:20Z", "path": "engine/src/main/java/org/terasology/engine/subsystem/lwjgl/LwjglGraphicsManager.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright 2017 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.engine.subsystem.lwjgl;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Queues;\n+import org.lwjgl.opengl.GL11;\n+import org.lwjgl.opengl.GL12;\n+import org.terasology.assets.AssetFactory;\n+import org.terasology.assets.module.ModuleAssetDataProducer;\n+import org.terasology.assets.module.ModuleAwareAssetTypeManager;\n+import org.terasology.context.Context;\n+import org.terasology.engine.GameThread;\n+import org.terasology.engine.subsystem.RenderingSubsystemFactory;\n+import org.terasology.rendering.assets.animation.MeshAnimation;\n+import org.terasology.rendering.assets.animation.MeshAnimationBundle;\n+import org.terasology.rendering.assets.animation.MeshAnimationBundleData;\n+import org.terasology.rendering.assets.animation.MeshAnimationImpl;\n+import org.terasology.rendering.assets.atlas.Atlas;\n+import org.terasology.rendering.assets.font.Font;\n+import org.terasology.rendering.assets.font.FontData;\n+import org.terasology.rendering.assets.font.FontImpl;\n+import org.terasology.rendering.assets.material.Material;\n+import org.terasology.rendering.assets.material.MaterialData;\n+import org.terasology.rendering.assets.mesh.Mesh;\n+import org.terasology.rendering.assets.mesh.MeshData;\n+import org.terasology.rendering.assets.shader.Shader;\n+import org.terasology.rendering.assets.shader.ShaderData;\n+import org.terasology.rendering.assets.skeletalmesh.SkeletalMesh;\n+import org.terasology.rendering.assets.skeletalmesh.SkeletalMeshData;\n+import org.terasology.rendering.assets.texture.PNGTextureFormat;\n+import org.terasology.rendering.assets.texture.Texture;\n+import org.terasology.rendering.assets.texture.TextureData;\n+import org.terasology.rendering.assets.texture.subtexture.Subtexture;\n+import org.terasology.rendering.assets.texture.subtexture.SubtextureData;\n+import org.terasology.rendering.opengl.GLSLMaterial;\n+import org.terasology.rendering.opengl.GLSLShader;\n+import org.terasology.rendering.opengl.OpenGLMesh;\n+import org.terasology.rendering.opengl.OpenGLSkeletalMesh;\n+import org.terasology.rendering.opengl.OpenGLTexture;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.function.Consumer;\n+\n+import static org.lwjgl.opengl.GL11.GL_TEXTURE_2D;\n+import static org.lwjgl.opengl.GL11.GL_TEXTURE_WRAP_S;\n+import static org.lwjgl.opengl.GL11.GL_TEXTURE_WRAP_T;\n+import static org.lwjgl.opengl.GL11.glBindTexture;\n+import static org.lwjgl.opengl.GL11.glDeleteTextures;\n+import static org.lwjgl.opengl.GL11.glGenTextures;\n+import static org.lwjgl.opengl.GL11.glTexParameterf;\n+\n+public class LwjglGraphicsManager {\n+\n+    private final GLBufferPool bufferPool = new GLBufferPool(false);\n+\n+    private final BlockingDeque<Runnable> displayThreadActions = Queues.newLinkedBlockingDeque();\n+\n+    private ThreadMode threadMode = ThreadMode.GAME_THREAD;", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwMzg3NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546903875", "bodyText": "Sorry, I don't understand what you mean here... This variable here is to indicate if graphics operations can be performed in game thread (PC) or must be executed in display thread later (TeraEd).", "author": "hajdam", "createdAt": "2020-12-21T20:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzOTA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwNTQ2OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546905469", "bodyText": "I thought that is rendering separation in engine on rendering and logic thread.", "author": "DarkWeird", "createdAt": "2020-12-21T20:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzOTA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwODcxNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546908715", "bodyText": "I did think so too, but I hadn't find it (yet).", "author": "hajdam", "createdAt": "2020-12-21T20:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjgzOTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0MTE3Mw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546841173", "bodyText": "Don't pass context as parameter if you can.\nWe(me and MichaelP) want integarate DI in future (WIP now)\nExcepts - you putting something in context.", "author": "DarkWeird", "createdAt": "2020-12-21T17:42:45Z", "path": "engine/src/main/java/org/terasology/input/lwjgl/LwjglKeyboardDevice.java", "diffHunk": "@@ -169,26 +173,30 @@\n     private Queue<CharKeyboardAction> charQueue = Lists.newLinkedList();\n     private TIntSet buttonStates = new TIntHashSet();\n \n-    public LwjglKeyboardDevice() {\n-        long window = GLFW.glfwGetCurrentContext();\n+    public LwjglKeyboardDevice(Context context) {", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4NjEyNA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546886124", "bodyText": "I though I needed it there, but I can move it out. Well, it's not nice that keyboard registers itself to GL window as side effect in constructor anyway...", "author": "hajdam", "createdAt": "2020-12-21T19:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0MTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0MzA3MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546843070", "bodyText": "Don't think that should be exposed.\nMaybe better implemen TeraEd's keyboardDevice.\nI don't sure that swing's keycodes equals glfw's keycodes.", "author": "DarkWeird", "createdAt": "2020-12-21T17:46:41Z", "path": "engine/src/main/java/org/terasology/input/lwjgl/LwjglKeyboardDevice.java", "diffHunk": "@@ -198,7 +206,7 @@ private void glfwCharCallback(long window, int chr) {\n      *         GLFW#GLFW_REPEAT}\n      * @param mods - modification keys: {@link GLFW#GLFW_MOD_SHIFT} and etc.\n      */\n-    private void glfwKeyCallback(long window, int key, int scancode, int action, int mods) {\n+    public void glfwKeyCallback(long window, int key, int scancode, int action, int mods) {", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0NjQ4MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546846480", "bodyText": "As keyboard's comment", "author": "DarkWeird", "createdAt": "2020-12-21T17:54:01Z", "path": "engine/src/main/java/org/terasology/input/lwjgl/LwjglMouseDevice.java", "diffHunk": "@@ -48,27 +52,34 @@ public LwjglMouseDevice(Context context) {\n         this.uiScale = this.renderingConfig.getUiScale() / 100f;\n         this.renderingConfig.subscribe(RenderingConfig.UI_SCALE, this);\n \n-        // GLFW callback\n-        long window = GLFW.glfwGetCurrentContext();\n-        GLFW.glfwSetMouseButtonCallback(window, this::mouseButtonCallback);\n-        GLFW.glfwSetScrollCallback(window, this::scrollCallback);\n+        DisplayDevice displayDevice = context.get(DisplayDevice.class);", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg0NzcyOA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546847728", "bodyText": "Try to not use CoreRegistry if you can.\nIt is our weak point and tech debt for parallel tests, beauty architecture.\nBetter passthru context or shader manager to constructor.", "author": "DarkWeird", "createdAt": "2020-12-21T17:56:42Z", "path": "engine/src/main/java/org/terasology/rendering/opengl/GLSLMaterial.java", "diffHunk": "@@ -80,7 +80,13 @@ public GLSLMaterial(ResourceUrn urn, AssetType<?, MaterialData> assetType, Mater\n         getDisposalHook().setDisposeAction(disposalAction);\n         this.materialData = data;\n         shaderManager = CoreRegistry.get(ShaderManager.class);\n-        reload(data);\n+    }\n+\n+    public void glInitialize() {\n+        if (shaderManager == null) {\n+            shaderManager = CoreRegistry.get(ShaderManager.class);", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg1MDA0NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546850045", "bodyText": "Hmm.\nthere should runs all render code, isn't it?\nSeems, it is best place for rendering ticks", "author": "DarkWeird", "createdAt": "2020-12-21T18:01:43Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/subsystem/LwjglPortlet.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.editor.subsystem;\n+\n+import com.google.common.base.Preconditions;\n+import org.lwjgl.glfw.GLFW;\n+import org.lwjgl.glfw.GLFWImage;\n+import org.lwjgl.opengl.GL43;\n+import org.lwjgl.opengl.awt.AWTGLCanvas;\n+import org.lwjgl.opengl.awt.GLData;\n+import org.lwjgl.system.MemoryUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.assets.module.ModuleAwareAssetTypeManager;\n+import org.terasology.config.Config;\n+import org.terasology.config.RenderingConfig;\n+import org.terasology.context.Context;\n+import org.terasology.engine.GameEngine;\n+import org.terasology.engine.GameThread;\n+import org.terasology.engine.TerasologyEngine;\n+import org.terasology.engine.modes.GameState;\n+import org.terasology.engine.subsystem.DisplayDevice;\n+import org.terasology.engine.subsystem.lwjgl.BaseLwjglSubsystem;\n+import org.terasology.engine.subsystem.lwjgl.DebugCallback;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsManager;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsUtil;\n+import org.terasology.entitySystem.event.internal.EventSystem;\n+import org.terasology.input.InputSystem;\n+import org.terasology.input.lwjgl.LwjglKeyboardDevice;\n+import org.terasology.input.lwjgl.LwjglMouseDevice;\n+import org.terasology.nui.canvas.CanvasRenderer;\n+import org.terasology.registry.CoreRegistry;\n+import org.terasology.rendering.ShaderManager;\n+import org.terasology.rendering.ShaderManagerLwjgl;\n+import org.terasology.rendering.nui.internal.LwjglCanvasRenderer;\n+\n+import javax.imageio.ImageIO;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionListener;\n+import java.awt.event.MouseWheelEvent;\n+import java.awt.event.MouseWheelListener;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+\n+import static org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT;\n+import static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;\n+import static org.lwjgl.opengl.GL11.glClear;\n+import static org.lwjgl.opengl.GL11.glLoadIdentity;\n+\n+public class LwjglPortlet extends BaseLwjglSubsystem {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LwjglPortlet.class);\n+\n+    private Context context;\n+    private RenderingConfig config;\n+\n+    private GameEngine engine;\n+    private AWTGLCanvas canvas;\n+    private LwjglPortletDisplayDevice display;\n+\n+    private final LwjglGraphicsManager graphics = new LwjglGraphicsManager();\n+\n+    @Override\n+    public String getName() {\n+        return \"Portlet\";\n+    }\n+\n+    @Override\n+    public void initialise(GameEngine gameEngine, Context rootContext) {\n+        logger.info(\"Starting initialization of LWJGL\");\n+        this.engine = gameEngine;\n+        this.context = rootContext;\n+        this.config = context.get(Config.class).getRendering();\n+\n+        graphics.setThreadMode(LwjglGraphicsManager.ThreadMode.DISPLAY_THREAD);\n+        display = new LwjglPortletDisplayDevice(canvas, graphics);\n+        context.put(DisplayDevice.class, display);\n+        logger.info(\"Initial initialization complete\");\n+    }\n+\n+    @Override\n+    public void registerCoreAssetTypes(ModuleAwareAssetTypeManager assetTypeManager) {\n+        graphics.registerCoreAssetTypes(assetTypeManager);\n+    }\n+\n+    @Override\n+    public void postInitialise(Context rootContext) {\n+        graphics.registerRenderingSubsystem(context);\n+\n+        initBuffer();\n+\n+        context.put(CanvasRenderer.class, new LwjglCanvasRenderer(context));\n+    }\n+\n+    @Override\n+    public void postUpdate(GameState currentState, float delta) {\n+        graphics.processActions();\n+\n+        currentState.render();\n+\n+        display.update();\n+        int frameLimit = context.get(Config.class).getRendering().getFrameLimit();\n+        if (frameLimit > 0) {\n+//            Lwjgl2Sync.sync(frameLimit);\n+        }\n+        if (display.isCloseRequested()) {\n+            engine.shutdown();\n+        }\n+    }\n+\n+    public void setupThreads() {\n+        GameThread.reset();\n+        GameThread.setToCurrentThread();\n+\n+        EventSystem eventSystem = CoreRegistry.get(EventSystem.class);\n+        if (eventSystem != null) {\n+            eventSystem.setToCurrentThread();\n+        }\n+    }\n+\n+    public void createCanvas() {\n+        GLData data = new GLData();\n+        data.samples = 4;\n+        canvas = new AWTGLCanvas() {\n+            @Override\n+            public void initGL() {\n+                initOpenGL(LwjglPortlet.this.context);\n+                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n+                glLoadIdentity();\n+                LwjglPortlet.this.context.put(CanvasRenderer.class, new LwjglCanvasRenderer(LwjglPortlet.this.context));\n+            }\n+\n+            @Override\n+            public void paintGL() {\n+                if (!((TerasologyEngine) engine).tick()) {", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2MjYwOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546862609", "bodyText": "Swing's key codes equal glfw's key codes?", "author": "DarkWeird", "createdAt": "2020-12-21T18:29:46Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/subsystem/LwjglPortlet.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+package org.terasology.editor.subsystem;\n+\n+import com.google.common.base.Preconditions;\n+import org.lwjgl.glfw.GLFW;\n+import org.lwjgl.glfw.GLFWImage;\n+import org.lwjgl.opengl.GL43;\n+import org.lwjgl.opengl.awt.AWTGLCanvas;\n+import org.lwjgl.opengl.awt.GLData;\n+import org.lwjgl.system.MemoryUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.terasology.assets.module.ModuleAwareAssetTypeManager;\n+import org.terasology.config.Config;\n+import org.terasology.config.RenderingConfig;\n+import org.terasology.context.Context;\n+import org.terasology.engine.GameEngine;\n+import org.terasology.engine.GameThread;\n+import org.terasology.engine.TerasologyEngine;\n+import org.terasology.engine.modes.GameState;\n+import org.terasology.engine.subsystem.DisplayDevice;\n+import org.terasology.engine.subsystem.lwjgl.BaseLwjglSubsystem;\n+import org.terasology.engine.subsystem.lwjgl.DebugCallback;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsManager;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsUtil;\n+import org.terasology.entitySystem.event.internal.EventSystem;\n+import org.terasology.input.InputSystem;\n+import org.terasology.input.lwjgl.LwjglKeyboardDevice;\n+import org.terasology.input.lwjgl.LwjglMouseDevice;\n+import org.terasology.nui.canvas.CanvasRenderer;\n+import org.terasology.registry.CoreRegistry;\n+import org.terasology.rendering.ShaderManager;\n+import org.terasology.rendering.ShaderManagerLwjgl;\n+import org.terasology.rendering.nui.internal.LwjglCanvasRenderer;\n+\n+import javax.imageio.ImageIO;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionListener;\n+import java.awt.event.MouseWheelEvent;\n+import java.awt.event.MouseWheelListener;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+\n+import static org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT;\n+import static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;\n+import static org.lwjgl.opengl.GL11.glClear;\n+import static org.lwjgl.opengl.GL11.glLoadIdentity;\n+\n+public class LwjglPortlet extends BaseLwjglSubsystem {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LwjglPortlet.class);\n+\n+    private Context context;\n+    private RenderingConfig config;\n+\n+    private GameEngine engine;\n+    private AWTGLCanvas canvas;\n+    private LwjglPortletDisplayDevice display;\n+\n+    private final LwjglGraphicsManager graphics = new LwjglGraphicsManager();\n+\n+    @Override\n+    public String getName() {\n+        return \"Portlet\";\n+    }\n+\n+    @Override\n+    public void initialise(GameEngine gameEngine, Context rootContext) {\n+        logger.info(\"Starting initialization of LWJGL\");\n+        this.engine = gameEngine;\n+        this.context = rootContext;\n+        this.config = context.get(Config.class).getRendering();\n+\n+        graphics.setThreadMode(LwjglGraphicsManager.ThreadMode.DISPLAY_THREAD);\n+        display = new LwjglPortletDisplayDevice(canvas, graphics);\n+        context.put(DisplayDevice.class, display);\n+        logger.info(\"Initial initialization complete\");\n+    }\n+\n+    @Override\n+    public void registerCoreAssetTypes(ModuleAwareAssetTypeManager assetTypeManager) {\n+        graphics.registerCoreAssetTypes(assetTypeManager);\n+    }\n+\n+    @Override\n+    public void postInitialise(Context rootContext) {\n+        graphics.registerRenderingSubsystem(context);\n+\n+        initBuffer();\n+\n+        context.put(CanvasRenderer.class, new LwjglCanvasRenderer(context));\n+    }\n+\n+    @Override\n+    public void postUpdate(GameState currentState, float delta) {\n+        graphics.processActions();\n+\n+        currentState.render();\n+\n+        display.update();\n+        int frameLimit = context.get(Config.class).getRendering().getFrameLimit();\n+        if (frameLimit > 0) {\n+//            Lwjgl2Sync.sync(frameLimit);\n+        }\n+        if (display.isCloseRequested()) {\n+            engine.shutdown();\n+        }\n+    }\n+\n+    public void setupThreads() {\n+        GameThread.reset();\n+        GameThread.setToCurrentThread();\n+\n+        EventSystem eventSystem = CoreRegistry.get(EventSystem.class);\n+        if (eventSystem != null) {\n+            eventSystem.setToCurrentThread();\n+        }\n+    }\n+\n+    public void createCanvas() {\n+        GLData data = new GLData();\n+        data.samples = 4;\n+        canvas = new AWTGLCanvas() {\n+            @Override\n+            public void initGL() {\n+                initOpenGL(LwjglPortlet.this.context);\n+                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n+                glLoadIdentity();\n+                LwjglPortlet.this.context.put(CanvasRenderer.class, new LwjglCanvasRenderer(LwjglPortlet.this.context));\n+            }\n+\n+            @Override\n+            public void paintGL() {\n+                if (!((TerasologyEngine) engine).tick()) {\n+                    // ignore?\n+                }\n+            }\n+        };\n+    }\n+\n+    public AWTGLCanvas getCanvas() {\n+        return this.canvas;\n+    }\n+\n+    private void initBuffer() {\n+        logger.info(\"Initializing display (if last line in log then likely the game crashed from an issue with your \" +\n+                \"video card)\");\n+\n+        if (!config.isVSync()) {\n+            GLFW.glfwSwapInterval(0);\n+        }\n+\n+        try {\n+            String root = \"org/terasology/icons/\";\n+            ClassLoader classLoader = getClass().getClassLoader();\n+\n+            BufferedImage icon16 = ImageIO.read(classLoader.getResourceAsStream(root + \"gooey_sweet_16.png\"));\n+            BufferedImage icon32 = ImageIO.read(classLoader.getResourceAsStream(root + \"gooey_sweet_32.png\"));\n+            BufferedImage icon64 = ImageIO.read(classLoader.getResourceAsStream(root + \"gooey_sweet_64.png\"));\n+            BufferedImage icon128 = ImageIO.read(classLoader.getResourceAsStream(root + \"gooey_sweet_128.png\"));\n+            GLFWImage.Buffer buffer = GLFWImage.create(4);\n+            buffer.put(0, LwjglGraphicsUtil.convertToGLFWFormat(icon16));\n+            buffer.put(1, LwjglGraphicsUtil.convertToGLFWFormat(icon32));\n+            buffer.put(2, LwjglGraphicsUtil.convertToGLFWFormat(icon64));\n+            buffer.put(3, LwjglGraphicsUtil.convertToGLFWFormat(icon128));\n+\n+        } catch (IOException | IllegalArgumentException e) {\n+            logger.warn(\"Could not set icon\", e);\n+        }\n+\n+        display.setDisplayModeSetting(config.getDisplayModeSetting());\n+    }\n+\n+    private void initOpenGL(Context currentContext) {\n+        logger.info(\"Initializing OpenGL\");\n+        LwjglGraphicsUtil.checkOpenGL();\n+        LwjglGraphicsUtil.initOpenGLParams();\n+        if (config.getDebug().isEnabled()) {\n+            try {\n+                GL43.glDebugMessageCallback(new DebugCallback(), MemoryUtil.NULL);\n+            } catch (IllegalStateException e) {\n+                logger.warn(\"Unable to specify DebugCallback to receive debugging messages from the GL.\");\n+            }\n+        }\n+        currentContext.put(ShaderManager.class, new ShaderManagerLwjgl());\n+    }\n+\n+    public void initInputs() {\n+        final InputSystem inputSystem = context.get(InputSystem.class);\n+        Preconditions.checkNotNull(inputSystem);\n+        canvas.addKeyListener(new KeyListener() {\n+            @Override\n+            public void keyTyped(KeyEvent e) {\n+                ((LwjglKeyboardDevice) inputSystem.getKeyboard()).glfwCharCallback(0, e.getKeyChar());\n+            }\n+\n+            @Override\n+            public void keyPressed(KeyEvent e) {\n+                ((LwjglKeyboardDevice) inputSystem.getKeyboard()).glfwKeyCallback(0, e.getKeyChar(),", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg3NTg5MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546875891", "bodyText": "Partially. Characters equals directly, special keys will have to be converted. Didn't do this yet. Same applies to mouse events - idea here is, that there will be for example mode in editor, where you click on it and mouse will go to exclusive mode to test gameplay until ESC for example... Or something like that.", "author": "hajdam", "createdAt": "2020-12-21T19:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2MjYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2MzQwNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546863407", "bodyText": "This data can be changed by resize?", "author": "DarkWeird", "createdAt": "2020-12-21T18:31:36Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/subsystem/LwjglPortletDisplayDevice.java", "diffHunk": "@@ -0,0 +1,140 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.editor.subsystem;\n+\n+import org.lwjgl.glfw.GLFW;\n+import org.lwjgl.opengl.GL11;\n+import org.lwjgl.opengl.awt.AWTGLCanvas;\n+import org.terasology.engine.subsystem.DisplayDevice;\n+import org.terasology.engine.subsystem.DisplayDeviceInfo;\n+import org.terasology.engine.subsystem.Resolution;\n+import org.terasology.engine.subsystem.lwjgl.LwjglDisplayDevice;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsManager;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsUtil;\n+import org.terasology.engine.subsystem.lwjgl.LwjglResolution;\n+import org.terasology.rendering.nui.layers.mainMenu.videoSettings.DisplayModeSetting;\n+import org.terasology.utilities.subscribables.AbstractSubscribable;\n+\n+import java.awt.GraphicsEnvironment;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class LwjglPortletDisplayDevice extends AbstractSubscribable implements DisplayDevice {\n+\n+    private final AWTGLCanvas canvas;\n+    private final LwjglGraphicsManager graphics;\n+    private DisplayDeviceInfo displayDeviceInfo;\n+\n+    public LwjglPortletDisplayDevice(AWTGLCanvas canvas, LwjglGraphicsManager graphics) {\n+        this.canvas = canvas;\n+        this.graphics = graphics;\n+        canvas.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateViewport();\n+            }\n+        });\n+        graphics.asynchToDisplayThread(() -> {\n+            displayDeviceInfo = LwjglGraphicsUtil.getDisplayDeviceInfo();", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg3Njc2NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546876764", "bodyText": "The reason for this is, that it calls GL11 functions which requires active OpenGL context to process, so have to be done in display thread. There are currently vendor strings, so it should be ok to call once (unless someone can switch graphic cards in the middle of playing?), but there is no resize dependent information there as of yet.", "author": "hajdam", "createdAt": "2020-12-21T19:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2MzQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwNDg1Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546904852", "bodyText": "Hmm it maybe interesting- change graphics during teraed session. But not in resize event.", "author": "DarkWeird", "createdAt": "2020-12-21T20:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2MzQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkxMjI0Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546912242", "bodyText": "Well, it could be red every render tick, so that it will be available for metrics 1-tick delayed in the worst case.", "author": "hajdam", "createdAt": "2020-12-21T20:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2MzQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MTM0MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r547091340", "bodyText": "Ideally render ticks should works every 1/60 seconds.\nthen 1-tick delay is not afraid :)", "author": "DarkWeird", "createdAt": "2020-12-22T06:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2MzQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NjU3Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546866572", "bodyText": "Commented code should be eliminated", "author": "DarkWeird", "createdAt": "2020-12-21T18:39:04Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/subsystem/LwjglPortletDisplayDevice.java", "diffHunk": "@@ -0,0 +1,140 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.editor.subsystem;\n+\n+import org.lwjgl.glfw.GLFW;\n+import org.lwjgl.opengl.GL11;\n+import org.lwjgl.opengl.awt.AWTGLCanvas;\n+import org.terasology.engine.subsystem.DisplayDevice;\n+import org.terasology.engine.subsystem.DisplayDeviceInfo;\n+import org.terasology.engine.subsystem.Resolution;\n+import org.terasology.engine.subsystem.lwjgl.LwjglDisplayDevice;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsManager;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsUtil;\n+import org.terasology.engine.subsystem.lwjgl.LwjglResolution;\n+import org.terasology.rendering.nui.layers.mainMenu.videoSettings.DisplayModeSetting;\n+import org.terasology.utilities.subscribables.AbstractSubscribable;\n+\n+import java.awt.GraphicsEnvironment;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class LwjglPortletDisplayDevice extends AbstractSubscribable implements DisplayDevice {\n+\n+    private final AWTGLCanvas canvas;\n+    private final LwjglGraphicsManager graphics;\n+    private DisplayDeviceInfo displayDeviceInfo;\n+\n+    public LwjglPortletDisplayDevice(AWTGLCanvas canvas, LwjglGraphicsManager graphics) {\n+        this.canvas = canvas;\n+        this.graphics = graphics;\n+        canvas.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateViewport();\n+            }\n+        });\n+        graphics.asynchToDisplayThread(() -> {\n+            displayDeviceInfo = LwjglGraphicsUtil.getDisplayDeviceInfo();\n+        });\n+    }\n+\n+    @Override\n+    public boolean hasFocus() {\n+        return canvas.hasFocus();\n+    }\n+\n+    @Override\n+    public boolean isCloseRequested() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setFullscreen(boolean state) {\n+    }\n+\n+    @Override\n+    public boolean isFullscreen() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setDisplayModeSetting(DisplayModeSetting displayModeSetting) {\n+    }\n+\n+    @Override\n+    public DisplayModeSetting getDisplayModeSetting() {\n+        return DisplayModeSetting.WINDOWED;\n+    }\n+\n+    @Override\n+    public Resolution getResolution() {\n+        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        int bitDepth = env.getDefaultScreenDevice().getDisplayMode().getBitDepth();\n+        int refreshRate = env.getDefaultScreenDevice().getDisplayMode().getRefreshRate();\n+        return new LwjglResolution(getWidth(), getHeight(), bitDepth, bitDepth, bitDepth, refreshRate);\n+    }\n+\n+    @Override\n+    public List<Resolution> getResolutions() {\n+        ArrayList<Resolution> resolutions = new ArrayList<>();\n+        resolutions.add(getResolution());\n+        return resolutions;\n+    }\n+\n+    @Override\n+    public int getWidth() {\n+        return canvas.getWidth();\n+    }\n+\n+    @Override\n+    public int getHeight() {\n+        return canvas.getHeight();\n+    }\n+\n+    @Override\n+    public void setResolution(Resolution resolution) {\n+    }\n+\n+    @Override\n+    public void processMessages() {\n+        GLFW.glfwPollEvents();\n+        //canvas.render();", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5OTQwNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546899405", "bodyText": "Forgot to remove that :-(", "author": "hajdam", "createdAt": "2020-12-21T19:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2NjU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg2Njk3MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r546866970", "bodyText": "Double line", "author": "DarkWeird", "createdAt": "2020-12-21T18:40:08Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/ui/Viewport.java", "diffHunk": "@@ -15,23 +15,38 @@\n  */\n package org.terasology.editor.ui;\n \n+import org.lwjgl.opengl.awt.AWTGLCanvas;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.SwingConstants;\n import java.awt.*;\n \n /**\n  * TeraEd main class.\n  */\n @SuppressWarnings(\"serial\")\n-public final class Viewport extends Canvas {\n+public final class Viewport extends JPanel {\n \n     private static final Logger logger = LoggerFactory.getLogger(Viewport.class);\n+    private JLabel startingLabel = new JLabel(\"Starting Terasology...\");\n \n     public Viewport() {\n+        setLayout(new BorderLayout());\n         setSize(1280, 720);\n         setMinimumSize(new Dimension(640, 480));\n         setPreferredSize(new Dimension(1280, 720));", "originalCommit": "613f07e8111a6a4fd8a4fa0ee06b14eef17e24a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3955c7697ceb39da417c02b1c7bdb065152cfb4e", "url": "https://github.com/MovingBlocks/Terasology/commit/3955c7697ceb39da417c02b1c7bdb065152cfb4e", "message": "TeraEd: Run Terasology in Swing/AWT - 2", "committedDate": "2020-12-21T23:48:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzEwNTcxMw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r547105713", "bodyText": "Your game not runs in teraEd because LwjglTime returns 0.0 every time (see StageLoading)\nYou should initialize GLFW for timer starts counts. (or use different timer)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        sceneProperties = new SceneProperties(engine);\n          \n          \n            \n            \n          \n          \n            \n                        if (!GLFW.glfwInit()) {\n          \n          \n            \n                            throw new RuntimeException(\"Failed to initialize GLFW\");\n          \n          \n            \n                        }\n          \n          \n            \n                        sceneProperties = new SceneProperties(engine);", "author": "DarkWeird", "createdAt": "2020-12-22T07:08:38Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/TeraEd.java", "diffHunk": "@@ -66,23 +56,42 @@ public void run() {\n             logger.warn(\"Failed to set look and feel to Nimbus\", e);\n         }\n         try {\n-            LwjglPortlet lwjglPortlet = new LwjglPortlet();\n+            LwjglPortlet portlet = new LwjglPortlet();\n \n             PathManager.getInstance().useDefaultHomePath();\n \n             engine = new TerasologyEngineBuilder()\n-                    .add(new LwjglGraphics())\n                     .add(new LwjglTimer())\n                     .add(new LwjglAudio())\n-                    .add(new LwjglInput())\n-                    .add(lwjglPortlet).build();\n+                    .add(new AwtInput())\n+                    .add(new BindsSubsystem())\n+                    .add(portlet).build();\n             sceneProperties = new SceneProperties(engine);", "originalCommit": "3955c7697ceb39da417c02b1c7bdb065152cfb4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "95d9b70010f3a86a5bd1ff5667b4204c400fd311", "url": "https://github.com/MovingBlocks/Terasology/commit/95d9b70010f3a86a5bd1ff5667b4204c400fd311", "message": "TeraEd: Run Terasology in Swing/AWT - 3", "committedDate": "2020-12-22T12:43:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MDgwNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r547280807", "bodyText": "You don't need this.\nYou don't use GLFW's window", "author": "DarkWeird", "createdAt": "2020-12-22T13:35:28Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/subsystem/LwjglPortletDisplayDevice.java", "diffHunk": "@@ -0,0 +1,132 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.editor.subsystem;\n+\n+import org.lwjgl.glfw.GLFW;\n+import org.lwjgl.opengl.GL11;\n+import org.lwjgl.opengl.awt.AWTGLCanvas;\n+import org.terasology.engine.subsystem.DisplayDevice;\n+import org.terasology.engine.subsystem.DisplayDeviceInfo;\n+import org.terasology.engine.subsystem.Resolution;\n+import org.terasology.engine.subsystem.lwjgl.LwjglDisplayDevice;\n+import org.terasology.engine.subsystem.lwjgl.LwjglGraphicsManager;\n+import org.terasology.engine.subsystem.lwjgl.LwjglResolution;\n+import org.terasology.rendering.nui.layers.mainMenu.videoSettings.DisplayModeSetting;\n+import org.terasology.utilities.subscribables.AbstractSubscribable;\n+\n+import java.awt.GraphicsEnvironment;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class LwjglPortletDisplayDevice extends AbstractSubscribable implements DisplayDevice {\n+\n+    private final AWTGLCanvas canvas;\n+    private final LwjglGraphicsManager graphics;\n+\n+    public LwjglPortletDisplayDevice(AWTGLCanvas canvas, LwjglGraphicsManager graphics) {\n+        this.canvas = canvas;\n+        this.graphics = graphics;\n+        canvas.addComponentListener(new ComponentAdapter() {\n+            @Override\n+            public void componentResized(ComponentEvent e) {\n+                updateViewport();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean hasFocus() {\n+        return canvas.hasFocus();\n+    }\n+\n+    @Override\n+    public boolean isCloseRequested() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setFullscreen(boolean state) {\n+    }\n+\n+    @Override\n+    public boolean isFullscreen() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void setDisplayModeSetting(DisplayModeSetting displayModeSetting) {\n+    }\n+\n+    @Override\n+    public DisplayModeSetting getDisplayModeSetting() {\n+        return DisplayModeSetting.WINDOWED;\n+    }\n+\n+    @Override\n+    public Resolution getResolution() {\n+        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        int bitDepth = env.getDefaultScreenDevice().getDisplayMode().getBitDepth();\n+        int refreshRate = env.getDefaultScreenDevice().getDisplayMode().getRefreshRate();\n+        return new LwjglResolution(getWidth(), getHeight(), bitDepth, bitDepth, bitDepth, refreshRate);\n+    }\n+\n+    @Override\n+    public List<Resolution> getResolutions() {\n+        ArrayList<Resolution> resolutions = new ArrayList<>();\n+        resolutions.add(getResolution());\n+        return resolutions;\n+    }\n+\n+    @Override\n+    public int getWidth() {\n+        return canvas.getWidth();\n+    }\n+\n+    @Override\n+    public int getHeight() {\n+        return canvas.getHeight();\n+    }\n+\n+    @Override\n+    public void setResolution(Resolution resolution) {\n+    }\n+\n+    @Override\n+    public void processMessages() {\n+        GLFW.glfwPollEvents();", "originalCommit": "95d9b70010f3a86a5bd1ff5667b4204c400fd311", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MjA5MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r547282091", "bodyText": "see:\nhttps://stackoverflow.com/questions/32159065/how-to-grab-a-mouse-in-java-swing", "author": "DarkWeird", "createdAt": "2020-12-22T13:38:04Z", "path": "facades/TeraEd/src/main/java/org/terasology/editor/input/AwtMouseDevice.java", "diffHunk": "@@ -0,0 +1,159 @@\n+// Copyright 2020 The Terasology Foundation\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package org.terasology.editor.input;\n+\n+import com.google.common.collect.Lists;\n+import gnu.trove.set.TIntSet;\n+import gnu.trove.set.hash.TIntHashSet;\n+import org.joml.Vector2d;\n+import org.joml.Vector2i;\n+import org.lwjgl.opengl.awt.AWTGLCanvas;\n+import org.terasology.config.RenderingConfig;\n+import org.terasology.input.ButtonState;\n+import org.terasology.input.InputType;\n+import org.terasology.input.MouseInput;\n+import org.terasology.input.device.MouseAction;\n+import org.terasology.input.device.MouseDevice;\n+\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Queue;\n+\n+/**\n+ * Awt mouse device convertor. Handles mouse input via AWT's callbacks Handles mouse state.\n+ */\n+public class AwtMouseDevice implements MouseDevice, PropertyChangeListener {\n+    private RenderingConfig renderingConfig;\n+    private float uiScale;\n+    private boolean mouseGrabbed;\n+    private Queue<MouseAction> queue = Lists.newLinkedList();\n+\n+    private TIntSet buttonStates = new TIntHashSet();\n+\n+    private double xPos;\n+    private double yPos;\n+\n+    private double xPosDelta;\n+    private double yPosDelta;\n+\n+    public AwtMouseDevice(RenderingConfig renderingConfig) {\n+        this.renderingConfig = renderingConfig;\n+        this.uiScale = renderingConfig.getUiScale() / 100f;\n+        renderingConfig.subscribe(RenderingConfig.UI_SCALE, this);\n+    }\n+\n+    public void registerToAwtGlCanvas(AWTGLCanvas canvas) {\n+        canvas.addMouseListener(new MouseListener() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+            }\n+\n+            @Override\n+            public void mousePressed(MouseEvent e) {\n+                int button = e.getButton() - 1;\n+                buttonStates.add(button);\n+                MouseInput mouseInput = MouseInput.find(InputType.MOUSE_BUTTON, button);\n+                queue.offer(new MouseAction(mouseInput, ButtonState.DOWN, getPosition()));\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                int button = e.getButton() - 1;\n+                buttonStates.remove(button);\n+                MouseInput mouseInput = MouseInput.find(InputType.MOUSE_BUTTON, button);\n+                queue.offer(new MouseAction(mouseInput, ButtonState.UP, getPosition()));\n+            }\n+\n+            @Override\n+            public void mouseEntered(MouseEvent e) {\n+\n+            }\n+\n+            @Override\n+            public void mouseExited(MouseEvent e) {\n+\n+            }\n+        });\n+        canvas.addMouseMotionListener(new MouseMotionListener() {\n+            @Override\n+            public void mouseDragged(MouseEvent e) {\n+                updateMouse(e.getX(), e.getY());\n+            }\n+\n+            @Override\n+            public void mouseMoved(MouseEvent e) {\n+                updateMouse(e.getX(), e.getY());\n+            }\n+        });\n+\n+        canvas.addMouseWheelListener(e -> {\n+            int yOffset = e.getUnitsToScroll();\n+            if (yOffset != 0.0) {\n+                int id = (yOffset > 0) ? 1 : -1;\n+                queue.offer(new MouseAction(InputType.MOUSE_WHEEL.getInput(id), 1, getPosition()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void update() {\n+    }\n+\n+    private void updateMouse(double x, double y) {\n+        xPosDelta = x - this.xPos;\n+        yPosDelta = y - this.yPos;\n+        this.xPos = x;\n+        this.yPos = y;\n+    }\n+\n+    @Override\n+    public Vector2i getPosition() {\n+        return new Vector2i((int) (xPos / this.uiScale), (int) (yPos / this.uiScale));\n+    }\n+\n+    @Override\n+    public Vector2d getDelta() {\n+\n+        Vector2d result = new Vector2d(xPosDelta, yPosDelta);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean isButtonDown(int button) {\n+        return buttonStates.contains(button);\n+    }\n+\n+    @Override\n+    public boolean isVisible() {\n+        return !mouseGrabbed;\n+    }\n+\n+    @Override\n+    public void setGrabbed(boolean newGrabbed) {\n+        if (newGrabbed != mouseGrabbed) {\n+            mouseGrabbed = newGrabbed;", "originalCommit": "95d9b70010f3a86a5bd1ff5667b4204c400fd311", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyMzE5OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r547523198", "bodyText": "This will require additional logic for shifting between regular and grab mode. There is also issue with rotating already.", "author": "hajdam", "createdAt": "2020-12-22T21:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MjA5MQ=="}], "type": "inlineReview"}, {"oid": "b7e2fb883f945b27a0d0bfcbada0485c52bb5b28", "url": "https://github.com/MovingBlocks/Terasology/commit/b7e2fb883f945b27a0d0bfcbada0485c52bb5b28", "message": "TeraEd: Run Terasology in Swing/AWT - 4", "committedDate": "2020-12-22T21:41:55Z", "type": "commit"}, {"oid": "d9b513ff6e2802570ab0eb5e4e41b2bdec3e4c2c", "url": "https://github.com/MovingBlocks/Terasology/commit/d9b513ff6e2802570ab0eb5e4e41b2bdec3e4c2c", "message": "TeraEd: Run Terasology in Swing/AWT - 5", "committedDate": "2020-12-25T02:37:17Z", "type": "commit"}, {"oid": "1bb1e81dd561999625fb1fb23028ad40f9d0c1be", "url": "https://github.com/MovingBlocks/Terasology/commit/1bb1e81dd561999625fb1fb23028ad40f9d0c1be", "message": "TeraEd: Run Terasology in Swing/AWT - 6", "committedDate": "2020-12-25T02:47:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1NTE5Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r548855197", "bodyText": "commented code", "author": "DarkWeird", "createdAt": "2020-12-25T10:54:23Z", "path": "engine/src/main/java/org/terasology/rendering/opengl/GLSLMaterial.java", "diffHunk": "@@ -705,6 +702,15 @@ public void run() {\n                         it.advance();\n                         GL20.glDeleteProgram(it.value());\n                     }\n+\n+//                    final TIntIntMap deletedPrograms = new TIntIntHashMap(shaderPrograms);", "originalCommit": "d9b513ff6e2802570ab0eb5e4e41b2bdec3e4c2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1OTY2MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r548859660", "bodyText": "Fixed in the commit following right after this.", "author": "hajdam", "createdAt": "2020-12-25T11:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1NTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg2MDE1Nw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4327#discussion_r548860157", "bodyText": "oh, ok.\nI reviewed commit 5 only :D", "author": "DarkWeird", "createdAt": "2020-12-25T11:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg1NTE5Nw=="}], "type": "inlineReview"}, {"oid": "e61a8a4d519945ecd12739644a0830b81b2b3f2d", "url": "https://github.com/MovingBlocks/Terasology/commit/e61a8a4d519945ecd12739644a0830b81b2b3f2d", "message": "Merge branch 'develop' into develop-teraed", "committedDate": "2020-12-25T11:41:20Z", "type": "commit"}, {"oid": "5e2087436323ab1e6075145c12f21d137fa8ec77", "url": "https://github.com/MovingBlocks/Terasology/commit/5e2087436323ab1e6075145c12f21d137fa8ec77", "message": "Merge branch 'develop' into develop-teraed", "committedDate": "2020-12-30T00:55:25Z", "type": "commit"}, {"oid": "afb5e4cf58d65cb10ebf83448556e0edb94e2b47", "url": "https://github.com/MovingBlocks/Terasology/commit/afb5e4cf58d65cb10ebf83448556e0edb94e2b47", "message": "Merge branch 'develop' into develop-teraed", "committedDate": "2021-01-06T13:15:37Z", "type": "commit"}, {"oid": "890f0c53dece208a583d083ea78c124362b1d4a9", "url": "https://github.com/MovingBlocks/Terasology/commit/890f0c53dece208a583d083ea78c124362b1d4a9", "message": "Merge branch 'develop' into develop-teraed", "committedDate": "2021-01-06T13:19:09Z", "type": "commit"}]}