{"pr_number": 4139, "pr_title": "backport changes from old bullet branch", "pr_createdAt": "2020-08-28T02:03:36Z", "pr_url": "https://github.com/MovingBlocks/Terasology/pull/4139", "timeline": [{"oid": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "url": "https://github.com/MovingBlocks/Terasology/commit/b7d49972c1205e48af7df1f02d056adbf2e2815d", "message": "backport changes from old bullet branch\n\nissue: https://github.com/MovingBlocks/Terasology/pull/3809\n\nSquashed commit of the following:\n\ncommit e30948379027b7e0e49cd62e55133017c3d963b0\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Wed Aug 26 23:34:39 2020 -0700\n\n    update engine\n\ncommit 5d3ae14ebac84a23c1bcb98726e9820ca31a603a\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Mon Jan 6 12:18:16 2020 -0800\n\n    added voxel world system and updated bullet model\n\ncommit 58725e406acef913cdf0fedce8d9aeaf6924603d\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Sat Dec 28 17:10:39 2019 -0800\n\n    updated physics addressing performance issues\n\ncommit a845a19188dd16de2a06e3e1e8301cacb578430a\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Fri Dec 27 10:13:29 2019 -0800\n\n    updated motion state and resolved pending impulse issue\n\ncommit c24307e85f6a76494aa2fe1be1b246561717a7be\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Tue Dec 24 23:05:21 2019 -0800\n\n    upgraded version of bullet\n\ncommit f2bc1af38038be48d5f5eb40f3724be737147999\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Sat Dec 21 21:51:16 2019 -0800\n\n    fixed voxel test\n\ncommit 4b217249f8426de9c5bc06272251ba234726168d\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Sat Dec 21 20:49:26 2019 -0800\n\n    tweak to fix scaling problems\n\ncommit cc90b894712828dcd4b326d64c109d4e186e0359\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Sat Dec 21 20:19:44 2019 -0800\n\n    added friction and restitution\n\ncommit 005451f2b28f8c45e840a602e53bd904ad4f4aba\nAuthor: Michael <polli104@mail.chapman.edu>\nDate:   Sat Dec 21 14:33:48 2019 -0800\n\n    Squashed commit of the following:\n\n    commit daeb98d8af7f7000707e95f389a9a1ce4d501391\n    Author: Michael <polli104@mail.chapman.edu>\n    Date:   Mon Nov 25 22:25:31 2019 -0800\n\n        updated version of bullet\n\n    commit fafb0cc322ac387b3826b09f15d19db6116f005a\n    Merge: 53e33a297 b8e06611b\n    Author: Michael <polli104@mail.chapman.edu>\n    Date:   Sun Nov 24 21:54:22 2019 -0800\n\n        Merge remote-tracking branch 'upstream/develop' into TerraBulletPhysics2\n\n    commit 53e33a2972ee4dfa650e0f91041d11568b21acc3\n    Author: Michael <polli104@mail.chapman.edu>\n    Date:   Mon Aug 5 20:26:01 2019 -0700\n\n        fixed segfaul\n\n    commit c352257202ba20c12636a7438a3822a97208d9b0\n    Merge: 0da643867 6907a2e2f\n    Author: Michael <polli104@mail.chapman.edu>\n    Date:   Sun Aug 4 23:24:37 2019 -0700\n\n        Merge remote-tracking branch 'upstream/develop' into TerraBulletPhysics2\n\n    commit 0da643867a96b0d5135286baba8be08752384143\n    Merge: 845e8d55a 60a66b0f7\n    Author: Michael Pollind <polli104@mail.chapman.edu>\n    Date:   Fri Jul 13 15:42:10 2018 -0700\n\n        Merge remote-tracking branch 'eviltak/collisionshape-api' into TerraBulletPhysics2\n\n    commit 845e8d55af3f5ba0c46d9580a2dd0e9674c55d21\n    Author: Michael Pollind <mpollind@gmail.com>\n    Date:   Sat Jul 7 21:55:32 2018 -0700\n\n        fixed terrabullet build\n\n    commit c47fdce0570257e479134d4916b0ae4ed087d0fe\n    Author: Michael Pollind <mpollind@gmail.com>\n    Date:   Sat Jul 7 13:54:21 2018 -0700\n\n        implemented physics", "committedDate": "2020-08-28T02:00:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNjQ5OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478806498", "bodyText": "Commented out? Better to either leave a TODO for why / how to restore, or just take it out if it is no longer relevant.", "author": "Cervator", "createdAt": "2020-08-28T03:12:13Z", "path": "engine-tests/src/test/java/org/terasology/world/block/shape/BlockShapeTest.java", "diffHunk": "@@ -44,46 +42,43 @@\n     public void setup() throws Exception {\n         super.setup();\n \n-        AssetManager assetManager = CoreRegistry.get(AssetManager.class);\n+        this.assetManager = CoreRegistry.get(AssetManager.class);\n         blockManager = new BlockManagerImpl(new NullWorldAtlas(), assetManager);\n         CoreRegistry.put(BlockManager.class, blockManager);\n-        this.assetManager = assetManager;\n \n     }\n \n     @Test\n     public void testConvexHull() {\n-        BlockShape blockShape =  assetManager.getAsset(\"engine:halfSlope\", BlockShape.class).get();\n+        BlockShape blockShape = assetManager.getAsset(\"engine:halfSlope\", BlockShape.class).get();\n         CollisionShape shape = blockShape.getCollisionShape(Rotation.rotate(Yaw.CLOCKWISE_90));\n \n         assertTrue(shape instanceof ConvexHullShape);\n         Vector3f[] test = new Vector3f[]{new Vector3f(0.49999997f, 0.0f, 0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, 0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n-                new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n-                new Vector3f(0.49999997f, 0.0f, 0.49999997f)};\n+            new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, 0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, -0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, -0.49999997f),\n+            new Vector3f(-0.49999997f, -0.49999997f, 0.49999997f),\n+            new Vector3f(0.49999997f, 0.0f, 0.49999997f)};\n \n         BulletConvexHullShape bulletConvexHullShape = (BulletConvexHullShape) shape;\n \n-        ObjectArrayList<javax.vecmath.Vector3f> points = ((com.bulletphysics.collision.shapes.ConvexHullShape) bulletConvexHullShape.underlyingShape).getPoints();\n-        for (int x = 0; x < points.size(); x++) {\n-            fuzzVectorTest(test[x], VecMath.from(points.get(x)));\n-\n-        }\n-\n+//        Vector3f[] points = ((ConvexHullShape) bulletConvexHullShape.underlyingShape).getVertices();", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNzEzMA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478807130", "bodyText": "Just looking on GitHub, but it doesn't seem like this import gets used? Also is a LWJGL subsystem the best place for physics? It might be, but it the physics isn't strictly related to LWJGL.", "author": "Cervator", "createdAt": "2020-08-28T03:15:09Z", "path": "engine/src/main/java/org/terasology/engine/subsystem/lwjgl/BaseLwjglSubsystem.java", "diffHunk": "@@ -15,6 +15,8 @@\n  */\n package org.terasology.engine.subsystem.lwjgl;\n \n+import com.badlogic.gdx.physics.bullet.Bullet;\n+import com.badlogic.gdx.physics.bullet.BulletBase;", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwNzU1MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478807550", "bodyText": "Oh boy, we still had bare ifs? Yikes :-)\nTrivial: One more space needed here", "author": "Cervator", "createdAt": "2020-08-28T03:17:06Z", "path": "engine/src/main/java/org/terasology/logic/characters/KinematicCharacterMover.java", "diffHunk": "@@ -459,8 +459,9 @@ private boolean moveHorizontal(Vector3f horizMove, CharacterCollider collider, V\n         }\n         boolean horizontalHit = false;\n         Vector3f normalizedDir = horizMove.normalize();\n-        if(!normalizedDir.isFinite())\n+        if(!normalizedDir.isFinite()) {", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwODUyMQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478808521", "bodyText": "Wut. This constant's name is probably sensible enough, but most people probably won't know what that means anyway (I'm one of them). Might be good with with a one-liner javadoc to explain this field?", "author": "Cervator", "createdAt": "2020-08-28T03:21:14Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -96,59 +96,55 @@\n /**\n  * Physics engine implementation using TeraBullet (a customised version of JBullet).\n  */\n+@RegisterSystem\n public class BulletPhysics implements PhysicsEngine {\n+    public static final int AABB_SIZE = Integer.MAX_VALUE;\n+\n+    public static final float SIMD_EPSILON = 1.1920929E-7F;", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTQ1MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478809450", "bodyText": "How does this relate with the constant in this class that's also about Epsilon, and in fact shares the same name as the old version of the getter? Same thing? This seems a very magic number", "author": "Cervator", "createdAt": "2020-08-28T03:24:59Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -429,31 +450,30 @@ public boolean hasCharacterCollider(EntityRef entity) {\n         return entityRigidBodies.keySet().iterator();\n     }\n \n-    @Override\n-    public void awakenArea(org.terasology.math.geom.Vector3f pos, float radius) {\n-        Vector3f min = new Vector3f(VecMath.to(pos));\n-        min.sub(new Vector3f(0.6f, 0.6f, 0.6f));\n-        Vector3f max = new Vector3f(VecMath.to(pos));\n-        max.add(new Vector3f(0.6f, 0.6f, 0.6f));\n-        discreteDynamicsWorld.awakenRigidBodiesInArea(min, max);\n-    }\n-\n     @Override\n     public void awakenArea(Vector3fc pos, float radius) {\n-        Vector3f min = new Vector3f(VecMath.to(pos));\n-        min.sub(new Vector3f(0.6f, 0.6f, 0.6f));\n-        Vector3f max = new Vector3f(VecMath.to(pos));\n-        max.add(new Vector3f(0.6f, 0.6f, 0.6f));\n-        discreteDynamicsWorld.awakenRigidBodiesInArea(min, max);\n+        btPairCachingGhostObject ghost = new btPairCachingGhostObject();\n+        btSphereShape shape = new btSphereShape(radius);\n+        ghost.setCollisionShape(shape);\n+        ghost.setWorldTransform(new Matrix4f().translationRotateScale(pos, new Quaternionf(), 1.0f));\n+\n+        discreteDynamicsWorld.addCollisionObject(ghost, (short) -1, (short) -1);\n+        for (int i = 0; i < ghost.getNumOverlappingObjects(); ++i) {\n+            btCollisionObject other = ghost.getOverlappingObject(i);\n+            other.activate(true);\n+        }\n+        discreteDynamicsWorld.removeCollisionObject(ghost);\n     }\n \n     @Override\n     public float getEpsilon() {\n-        return BulletGlobals.SIMD_EPSILON;\n+        //TODO: figure out how access this from libgdx\n+        return 1.19209290e-07f;", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTU2MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478809561", "bodyText": "Use the getter, or the constant directly?", "author": "Cervator", "createdAt": "2020-08-28T03:25:21Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -308,13 +327,13 @@ public boolean updateRigidBody(EntityRef entity) {\n             return false;\n         } else if (rigidBody != null) {\n             float scale = location.getWorldScale();\n-            if (Math.abs(rigidBody.rb.getCollisionShape().getLocalScaling(new Vector3f()).x - scale) > BulletGlobals.SIMD_EPSILON\n+            if (Math.abs(rigidBody.rb.getCollisionShape().getLocalScaling().x - scale) > this.getEpsilon()", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MzgzMw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478863833", "bodyText": "My opinion: use constant directly - it is constant, it is local and it can be inline at compile time(save several CPU ticks).", "author": "DarkWeird", "createdAt": "2020-08-28T06:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgwOTcyNA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478809724", "bodyText": "Trivial: code style (missing space) - more of them too, won't comment on each, but may want to run the Checkstyle plugin on each modified file to catch these :-)", "author": "Cervator", "createdAt": "2020-08-28T03:26:03Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -597,7 +620,11 @@ private synchronized void processQueuedBodies() {\n         }\n         while (!removalQueue.isEmpty()) {\n             BulletRigidBody body = removalQueue.poll();\n+            if(body.isDisposed) {", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMDAzOA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478810038", "bodyText": "Is this TODO still valid? If so maybe could it be expanded on a bit to make it clear what it means?", "author": "Cervator", "createdAt": "2020-08-28T03:27:29Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -646,62 +677,66 @@ private void removeRigidBody(BulletRigidBody body) {\n      * <br><br>\n      * TODO: Flyweight this (take scale as parameter)", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMDI1NQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478810255", "bodyText": "More meaningful variable names than a1 2 and 3? Seeing more, than those three as well", "author": "Cervator", "createdAt": "2020-08-28T03:28:25Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -710,72 +745,78 @@ private PairCachingGhostObject createCollider(Vector3f pos, ConvexShape shape, s\n     }\n \n     private Collection<? extends PhysicsSystem.CollisionPair> getNewCollisionPairs() {\n+        discreteDynamicsWorld.getCollisionWorld().performDiscreteCollisionDetection();\n+\n         List<PhysicsSystem.CollisionPair> collisionPairs = Lists.newArrayList();\n \n-        DynamicsWorld world = discreteDynamicsWorld;\n-        ObjectArrayList<PersistentManifold> manifolds = new ObjectArrayList<>();\n-        for (PairCachingGhostObject trigger : entityTriggers.values()) {\n-            EntityRef entity = (EntityRef) trigger.getUserPointer();\n-            for (BroadphasePair initialPair : trigger.getOverlappingPairCache().getOverlappingPairArray()) {\n+        for (btPairCachingGhostObject trigger : entityTriggers.values()) {\n+            EntityRef entity = (EntityRef) trigger.userData;\n+            btBroadphasePairArray pairs = trigger.getOverlappingPairCache().getOverlappingPairArray();\n+            for (int x = 0; x < pairs.size(); x++) {\n+                btBroadphasePair initialPair = pairs.at(x);\n                 EntityRef otherEntity = null;\n-                if (initialPair.pProxy0.clientObject == trigger) {\n-                    if (((CollisionObject) initialPair.pProxy1.clientObject).getUserPointer() instanceof EntityRef) {\n-                        otherEntity = (EntityRef) ((CollisionObject) initialPair.pProxy1.clientObject).getUserPointer();\n+                btBroadphaseProxy p0 = btBroadphaseProxy.obtain(initialPair.getPProxy0().getCPointer(), false);\n+                btBroadphaseProxy p1 = btBroadphaseProxy.obtain(initialPair.getPProxy1().getCPointer(), false);\n+\n+                if (p0.getClientObject() == trigger.getCPointer()) {\n+\n+                    btCollisionObject other = btCollisionObject.getInstance(p1.getClientObject());\n+                    if (other.userData instanceof EntityRef) {\n+                        otherEntity = (EntityRef) other.userData;\n                     }\n                 } else {\n-                    if (((CollisionObject) initialPair.pProxy0.clientObject).getUserPointer() instanceof EntityRef) {\n-                        otherEntity = (EntityRef) ((CollisionObject) initialPair.pProxy0.clientObject).getUserPointer();\n+                    btCollisionObject other = btCollisionObject.getInstance(p0.getClientObject());\n+                    if (other.userData instanceof EntityRef) {\n+                        otherEntity = (EntityRef) other.userData;\n                     }\n                 }\n                 if (otherEntity == null || otherEntity == EntityRef.NULL) {\n                     continue;\n                 }\n-                BroadphasePair pair = world.getPairCache().findPair(initialPair.pProxy0, initialPair.pProxy1);\n+                btBroadphasePair pair = discreteDynamicsWorld.getPairCache().findPair(p0, p1);\n                 if (pair == null) {\n                     continue;\n                 }\n+\n                 manifolds.clear();\n-                if (pair.algorithm != null) {\n-                    pair.algorithm.getAllContactManifolds(manifolds);\n+                if (pair.getAlgorithm() != null) {\n+                    pair.getAlgorithm().getAllContactManifolds(manifolds);\n                 }\n-                for (PersistentManifold manifold : manifolds) {\n+                for (int y = 0; y < manifolds.size(); y++) {\n+\n+                    btPersistentManifold manifold = manifolds.atConst(y);\n                     for (int point = 0; point < manifold.getNumContacts(); ++point) {\n-                        ManifoldPoint manifoldPoint = manifold.getContactPoint(point);\n-                        if (manifoldPoint.getDistance() < 0) {\n+                        btManifoldPoint manifoldPoint = manifold.getContactPoint(point);\n+                        if (manifoldPoint.getDistance() < 0.f) {\n+                            Vector3f a1 = new Vector3f();", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMDYzNg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478810636", "bodyText": "More commented out code - either remove if it is no longer needed or put a comment / TODO to explain why it is still there please :-)\nSeeing at least one more of these, will skip commenting on any more", "author": "Cervator", "createdAt": "2020-08-28T03:29:54Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -790,128 +831,151 @@ public boolean needsCollision(BroadphaseProxy proxy0) {\n \n     private static class BulletRigidBody implements RigidBody {\n \n-        public final com.bulletphysics.dynamics.RigidBody rb;\n+        public final btRigidBody rb;\n+        public final btRigidBody.btRigidBodyConstructionInfo info;\n         public short collidesWith;\n-        private final Transform pooledTransform = new Transform();\n+        public boolean isDisposed;\n+        //  private final Transform pooledTransform = new Transform();\n         private final Vector3f pendingImpulse = new Vector3f();\n         private final Vector3f pendingForce = new Vector3f();\n \n-        BulletRigidBody(RigidBodyConstructionInfo info) {\n-            rb = new com.bulletphysics.dynamics.RigidBody(info);\n+        BulletRigidBody(btRigidBody.btRigidBodyConstructionInfo info) {\n+            this.info = info;\n+            rb = new btRigidBody(info);\n+            isDisposed = false;\n         }\n \n         @Override\n-        public void applyImpulse(org.terasology.math.geom.Vector3f impulse) {\n-            pendingImpulse.add(VecMath.to(impulse));\n+        public void applyImpulse(Vector3f impulse) {\n+            pendingImpulse.add(impulse);\n         }\n \n         @Override\n-        public void applyForce(org.terasology.math.geom.Vector3f force) {\n-            pendingForce.add(VecMath.to(force));\n+        public void applyForce(Vector3f force) {\n+            pendingForce.add(force);\n         }\n \n         @Override\n-        public void translate(org.terasology.math.geom.Vector3f translation) {\n-            rb.translate(VecMath.to(translation));\n+        public void translate(Vector3f translation) {\n+            rb.translate(translation);\n         }\n \n         @Override\n-        public org.terasology.math.geom.Quat4f getOrientation(org.terasology.math.geom.Quat4f out) {\n-            Quat4f vm = VecMath.to(out);\n-            rb.getOrientation(vm);\n-            out.set(vm.x, vm.y, vm.z, vm.w);\n-            return out;\n+        public Quaternionf getOrientation(Quaternionf out) {\n+            return out.setFromUnnormalized(rb.getWorldTransform());\n         }\n \n         @Override\n-        public org.terasology.math.geom.Vector3f getLocation(org.terasology.math.geom.Vector3f out) {\n-            Vector3f vm = VecMath.to(out);\n-            rb.getCenterOfMassPosition(vm);\n-            out.set(vm.x, vm.y, vm.z);\n+        public Vector3f getLocation(Vector3f out) {\n+            Vector3f result = rb.getWorldTransform().getTranslation(new Vector3f());\n+            out.x = result.x;\n+            out.y = result.y;\n+            out.z = result.z;\n             return out;\n         }\n \n         @Override\n-        public org.terasology.math.geom.Vector3f getLinearVelocity(org.terasology.math.geom.Vector3f out) {\n-            Vector3f vm = VecMath.to(out);\n-            rb.getLinearVelocity(vm);\n-            out.set(vm.x, vm.y, vm.z);\n-            return out;\n+        public Matrix4f getWorldTransform() {\n+            return rb.getWorldTransform();\n         }\n \n         @Override\n-        public org.terasology.math.geom.Vector3f getAngularVelocity(org.terasology.math.geom.Vector3f out) {\n-            Vector3f vm = VecMath.to(out);\n-            rb.getAngularVelocity(vm);\n-            out.set(vm.x, vm.y, vm.z);\n-            return out;\n+        public Matrix4f setWorldTransform(Matrix4f trans) {\n+            rb.setWorldTransform(trans);\n+            return trans;\n         }\n \n         @Override\n-        public void setLinearVelocity(org.terasology.math.geom.Vector3f value) {\n-            rb.setLinearVelocity(VecMath.to(value));\n+        public Vector3f getLinearVelocity(Vector3f out) {\n+            return rb.getLinearVelocity();\n         }\n \n         @Override\n-        public void setAngularVelocity(org.terasology.math.geom.Vector3f value) {\n-            rb.setAngularVelocity(VecMath.to(value));\n+        public Vector3f getAngularVelocity(Vector3f out) {\n+            return rb.getAngularVelocity();// out;\n         }\n \n         @Override\n-        public void setOrientation(org.terasology.math.geom.Quat4f orientation) {\n-            rb.getWorldTransform(pooledTransform);\n-            pooledTransform.setRotation(VecMath.to(orientation));\n-            rb.proceedToTransform(pooledTransform);\n+        public void setLinearVelocity(Vector3f value) {\n+            rb.setLinearVelocity(value);\n         }\n \n         @Override\n-        public void setLocation(org.terasology.math.geom.Vector3f location) {\n-            rb.getWorldTransform(pooledTransform);\n-            pooledTransform.origin.set(VecMath.to(location));\n-            rb.proceedToTransform(pooledTransform);\n+        public void setAngularVelocity(Vector3f value) {\n+            rb.setAngularVelocity(value);\n         }\n \n         @Override\n-        public void setVelocity(org.terasology.math.geom.Vector3f linear, org.terasology.math.geom.Vector3f angular) {\n-            rb.setLinearVelocity(VecMath.to(linear));\n-            rb.setAngularVelocity(VecMath.to(angular));\n+        public void setOrientation(Quaternionf orientation) {\n+            Matrix4f transform = rb.getWorldTransform();\n+            rb.setWorldTransform(new Matrix4f().translationRotateScale(transform.getTranslation(new Vector3f()), orientation, 1.0f));\n         }\n \n         @Override\n-        public void setTransform(org.terasology.math.geom.Vector3f location, org.terasology.math.geom.Quat4f orientation) {\n-            rb.getWorldTransform(pooledTransform);\n-            pooledTransform.origin.set(VecMath.to(location));\n-            pooledTransform.setRotation(VecMath.to(orientation));\n-            rb.proceedToTransform(pooledTransform);\n+        public void setLocation(Vector3f location) {\n+            Matrix4f translation = rb.getWorldTransform();\n+            Quaternionf quaternion = new Quaternionf().setFromUnnormalized(translation);\n+\n+//            Quat4f quaternion = new Quat4f();", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMTQ4OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478811488", "bodyText": "Any reason this isn't just one line instead of two? Assigning this Vector3f to verts next", "author": "Cervator", "createdAt": "2020-08-28T03:33:23Z", "path": "engine/src/main/java/org/terasology/physics/bullet/shapes/BulletConvexHullShape.java", "diffHunk": "@@ -15,47 +15,58 @@\n  */\n package org.terasology.physics.bullet.shapes;\n \n-import com.bulletphysics.collision.shapes.ConvexHullShape;\n-import com.bulletphysics.util.ObjectArrayList;\n-import org.terasology.math.VecMath;\n-import org.terasology.math.geom.Quat4f;\n-import org.terasology.math.geom.Vector3f;\n+import com.badlogic.gdx.physics.bullet.collision.btConvexHullShape;\n+import com.google.common.collect.Lists;\n+import org.joml.Quaternionf;\n+import org.joml.Vector3f;\n+import org.lwjgl.BufferUtils;\n import org.terasology.physics.shapes.CollisionShape;\n+import org.terasology.physics.shapes.ConvexHullShape;\n \n+import java.nio.FloatBuffer;\n import java.util.List;\n-import java.util.stream.Collectors;\n \n-public class BulletConvexHullShape extends BulletCollisionShape implements org.terasology.physics.shapes.ConvexHullShape {\n+\n+public class BulletConvexHullShape extends BulletCollisionShape implements ConvexHullShape {\n     // TODO: Handle scale\n-    private final ConvexHullShape convexHullShape;\n+    private final btConvexHullShape convexHullShape;\n \n     public BulletConvexHullShape(List<Vector3f> vertices) {\n-        ObjectArrayList<javax.vecmath.Vector3f> vertexList = new ObjectArrayList<>();\n-\n-        vertexList.addAll(vertices.stream().map(VecMath::to).collect(Collectors.toList()));\n-\n-        convexHullShape = new ConvexHullShape(vertexList);\n-        underlyingShape = convexHullShape;\n+        FloatBuffer buffer = BufferUtils.createFloatBuffer(vertices.size() * 3);\n+        for(int i = 0; i < vertices.size(); i++){\n+            Vector3f vertex = vertices.get(i);\n+            buffer.put(vertex.x);\n+            buffer.put(vertex.y);\n+            buffer.put(vertex.z);\n+        }\n+        this.convexHullShape = new btConvexHullShape(buffer,vertices.size(),3 * Float.BYTES);\n+        this.underlyingShape = convexHullShape;\n     }\n \n-    private BulletConvexHullShape(ObjectArrayList<javax.vecmath.Vector3f> vertexList) {\n-        convexHullShape = new ConvexHullShape(vertexList);\n-        underlyingShape = convexHullShape;\n+    public BulletConvexHullShape(FloatBuffer buffer,int numPoints,int stride){\n+        this.convexHullShape = new btConvexHullShape(buffer,numPoints,stride);\n+        this.underlyingShape = convexHullShape;\n     }\n \n     @Override\n-    public CollisionShape rotate(Quat4f rot) {\n-        ObjectArrayList<javax.vecmath.Vector3f> transformedVerts = new ObjectArrayList<>();\n-        for (javax.vecmath.Vector3f vert : convexHullShape.getPoints()) {\n-            transformedVerts.add(com.bulletphysics.linearmath.QuaternionUtil.quatRotate(VecMath.to(rot), vert, new javax.vecmath.Vector3f()));\n+    public CollisionShape rotate(Quaternionf rot) {\n+        List<Vector3f> verts = Lists.newArrayList();\n+        for(int x = 0; x < convexHullShape.getNumPoints(); x++){\n+            Vector3f p = convexHullShape.getScaledPoint(x);\n+            p.rotate(rot);\n+\n+            verts.add(p);\n         }\n-        return new BulletConvexHullShape(transformedVerts);\n+        return new BulletConvexHullShape(verts);\n     }\n \n     @Override\n     public Vector3f[] getVertices() {\n-        return convexHullShape.getPoints().stream()\n-                .map(VecMath::from)\n-                .toArray(Vector3f[]::new);\n+        Vector3f[] verts = new Vector3f[convexHullShape.getNumPoints()];\n+        for(int x = 0; x < convexHullShape.getNumPoints(); x++){\n+            Vector3f p = convexHullShape.getScaledPoint(x);", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMTU1Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478811556", "bodyText": "Outdated copyright statements (new one can be generated from within IntelliJ)", "author": "Cervator", "createdAt": "2020-08-28T03:33:42Z", "path": "engine/src/main/java/org/terasology/physics/bullet/shapes/BulletCylinderShape.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2018 MovingBlocks", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjE4NA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478812184", "bodyText": "This seems like a change that might be meaningful to explain: as per the name of this method it could make perfect sense to return a new physics engine, but what did adding the WorldProvider before achieve that isn't needed now? And if we don't need the Context here should that be removed as a method param?", "author": "Cervator", "createdAt": "2020-08-28T03:36:18Z", "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsEngineManager.java", "diffHunk": "@@ -39,6 +41,6 @@\n      * @return The created {@link PhysicsEngine} instance.\n      */\n     public static PhysicsEngine getNewPhysicsEngine(Context context) {\n-        return new BulletPhysics(context.get(WorldProvider.class));\n+        return new BulletPhysics();", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3MDMyOQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478870329", "bodyText": "world used by LiquidWorldWrapper and PhysicsWorldWrapper.\nis handles \"static body collision\" (?)\nI don't known how this doing now :D\ncandidates for check", "author": "DarkWeird", "createdAt": "2020-08-28T07:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjQ3Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478812476", "bodyText": "Unnecessarily qualified class? I see the old Vector3f import get removed, so is this needed? Haven't asked my IDE tho", "author": "Cervator", "createdAt": "2020-08-28T03:37:36Z", "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsSystem.java", "diffHunk": "@@ -146,7 +147,7 @@ public void updateRigidBody(OnChangedComponent event, EntityRef entity) {\n \n     @ReceiveEvent(components = {BlockComponent.class})\n     public void onBlockAltered(OnChangedBlock event, EntityRef entity) {\n-        physics.awakenArea(event.getBlockPosition().toVector3f(), 0.6f);\n+        physics.awakenArea(new org.joml.Vector3f(JomlUtil.from(event.getBlockPosition())), 0.6f);", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMjU1Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478812552", "bodyText": "Mystery new imports?", "author": "Cervator", "createdAt": "2020-08-28T03:37:57Z", "path": "engine/src/main/java/org/terasology/physics/engine/PhysicsEngineManager.java", "diffHunk": "@@ -21,6 +21,8 @@\n import org.terasology.physics.shapes.CollisionShape;\n import org.terasology.physics.shapes.CollisionShapeFactory;\n import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.BlockManager;", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxMzAzNQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478813035", "bodyText": "This very much looks like the sort of class that could use some solid javadoc :-) And would it make sense to make the @RegisterSystem explicitly ALWAYS ? If that's intended", "author": "Cervator", "createdAt": "2020-08-28T03:39:45Z", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxNjI5MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478816290", "bodyText": "This and other bits of code in this class is kinda ... wild. And unusual. It might make sense if you're familiar with native physics code but if not I'd find this pretty opaque. More comments at least, perhaps?", "author": "Cervator", "createdAt": "2020-08-28T03:53:50Z", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {\n+\n+    @In\n+    private PhysicsEngine physics;\n+    @In\n+    private EntityManager entityManager;\n+    @In\n+    private WorldProvider worldProvider;\n+    @In\n+    private ChunkProvider chunkProvider;\n+\n+    private TShortHashSet registred = new TShortHashSet();\n+\n+    private btRigidBodyConstructionInfo blockConsInf;\n+    private btVoxelShape worldShape;\n+    private VoxelCollisionAlgorithmWrapper wrapper;\n+    private btRigidBody rigidBody;\n+\n+    @Override\n+    public void initialise() {\n+        if (physics instanceof BulletPhysics) {\n+            btDiscreteDynamicsWorld discreteDynamicsWorld = ((BulletPhysics) physics).getDiscreteDynamicsWorld();\n+\n+            wrapper = new VoxelCollisionAlgorithmWrapper(ChunkConstants.SIZE_X, ChunkConstants.SIZE_Y, ChunkConstants.SIZE_Z);\n+            worldShape = new btVoxelShape(wrapper, new Vector3f(-AABB_SIZE, -AABB_SIZE, -AABB_SIZE), new Vector3f(AABB_SIZE, AABB_SIZE, AABB_SIZE));\n+\n+            Matrix4f matrix4f = new Matrix4f();\n+            btDefaultMotionState blockMotionState = new btDefaultMotionState(matrix4f);\n+\n+            blockConsInf = new btRigidBodyConstructionInfo(0, blockMotionState, worldShape, new Vector3f());\n+            rigidBody = new btRigidBody(blockConsInf);\n+            rigidBody.setCollisionFlags(btCollisionObject.CollisionFlags.CF_STATIC_OBJECT | rigidBody.getCollisionFlags());\n+            short mask = (short) (~(StandardCollisionGroup.STATIC.getFlag() | StandardCollisionGroup.LIQUID.getFlag()));", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxNjc0OA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478816748", "bodyText": "Really not sure what this does, but it looks expensive. And is it intentional to use the prefix version of ++ ? That sticks out as unusual and therefore bug prone? Especially if not explained well.", "author": "Cervator", "createdAt": "2020-08-28T03:55:47Z", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {\n+\n+    @In\n+    private PhysicsEngine physics;\n+    @In\n+    private EntityManager entityManager;\n+    @In\n+    private WorldProvider worldProvider;\n+    @In\n+    private ChunkProvider chunkProvider;\n+\n+    private TShortHashSet registred = new TShortHashSet();\n+\n+    private btRigidBodyConstructionInfo blockConsInf;\n+    private btVoxelShape worldShape;\n+    private VoxelCollisionAlgorithmWrapper wrapper;\n+    private btRigidBody rigidBody;\n+\n+    @Override\n+    public void initialise() {\n+        if (physics instanceof BulletPhysics) {\n+            btDiscreteDynamicsWorld discreteDynamicsWorld = ((BulletPhysics) physics).getDiscreteDynamicsWorld();\n+\n+            wrapper = new VoxelCollisionAlgorithmWrapper(ChunkConstants.SIZE_X, ChunkConstants.SIZE_Y, ChunkConstants.SIZE_Z);\n+            worldShape = new btVoxelShape(wrapper, new Vector3f(-AABB_SIZE, -AABB_SIZE, -AABB_SIZE), new Vector3f(AABB_SIZE, AABB_SIZE, AABB_SIZE));\n+\n+            Matrix4f matrix4f = new Matrix4f();\n+            btDefaultMotionState blockMotionState = new btDefaultMotionState(matrix4f);\n+\n+            blockConsInf = new btRigidBodyConstructionInfo(0, blockMotionState, worldShape, new Vector3f());\n+            rigidBody = new btRigidBody(blockConsInf);\n+            rigidBody.setCollisionFlags(btCollisionObject.CollisionFlags.CF_STATIC_OBJECT | rigidBody.getCollisionFlags());\n+            short mask = (short) (~(StandardCollisionGroup.STATIC.getFlag() | StandardCollisionGroup.LIQUID.getFlag()));\n+            discreteDynamicsWorld.addRigidBody(rigidBody, physics.combineGroups(StandardCollisionGroup.WORLD), mask);\n+        }\n+\n+        super.initialise();\n+    }\n+\n+    private void tryRegister(Block block) {\n+        short id = block.getId();\n+        if (!registred.contains(id)) {\n+            btCollisionShape shape = ((BulletCollisionShape) block.getCollisionShape()).underlyingShape;\n+            btVoxelInfo info = new btVoxelInfo(shape != null && block.isTargetable(), shape != null && !block.isPenetrable(), id, shape, JomlUtil.from(block.getCollisionOffset()), block.getFriction(), block.getRestitution(), block.getFriction());\n+            wrapper.setVoxelInfo(info);\n+            registred.add(id);\n+        }\n+    }\n+\n+\n+    @ReceiveEvent(components = {BlockComponent.class})\n+    public void onBlockChange(OnChangedBlock event, EntityRef entity) {\n+        tryRegister(event.getNewType());\n+        wrapper.setBlock(event.getBlockPosition().x, event.getBlockPosition().y, event.getBlockPosition().z, event.getNewType().getId());\n+    }\n+\n+    @ReceiveEvent(components = WorldComponent.class)\n+    public void onChunkUloaded(BeforeChunkUnload beforeChunkUnload, EntityRef worldEntity) {\n+        Vector3i chunkPos = beforeChunkUnload.getChunkPos();\n+        wrapper.freeRegion(chunkPos.x, chunkPos.y, chunkPos.z);\n+    }\n+\n+    @ReceiveEvent(components = {WorldComponent.class})\n+    public void onNewChunk(OnChunkLoaded chunkAvailable, EntityRef worldEntity) {\n+        Vector3i chunkPos = chunkAvailable.getChunkPos();\n+        Chunk chunk = chunkProvider.getChunk(chunkPos);\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(2 * (ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z));\n+        buffer.order(ByteOrder.nativeOrder());\n+        short[] entries = new short[ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z];\n+        for (int x = 0; x < ChunkConstants.SIZE_X; ++x) {", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgxNjgwNw==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478816807", "bodyText": "Why k", "author": "Cervator", "createdAt": "2020-08-28T03:56:04Z", "path": "engine/src/main/java/org/terasology/physics/engine/VoxelWorldSystem.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 MovingBlocks\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.terasology.physics.engine;\n+\n+import com.badlogic.gdx.physics.bullet.collision.VoxelCollisionAlgorithmWrapper;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;\n+import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelInfo;\n+import com.badlogic.gdx.physics.bullet.collision.btVoxelShape;\n+import com.badlogic.gdx.physics.bullet.dynamics.btDiscreteDynamicsWorld;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody;\n+import com.badlogic.gdx.physics.bullet.dynamics.btRigidBody.btRigidBodyConstructionInfo;\n+import com.badlogic.gdx.physics.bullet.linearmath.btDefaultMotionState;\n+import gnu.trove.set.hash.TShortHashSet;\n+import org.joml.Matrix4f;\n+import org.joml.Vector3f;\n+import org.terasology.entitySystem.entity.EntityManager;\n+import org.terasology.entitySystem.entity.EntityRef;\n+import org.terasology.entitySystem.event.ReceiveEvent;\n+import org.terasology.entitySystem.systems.BaseComponentSystem;\n+import org.terasology.entitySystem.systems.RegisterSystem;\n+import org.terasology.math.JomlUtil;\n+import org.terasology.math.geom.Vector3i;\n+import org.terasology.physics.StandardCollisionGroup;\n+import org.terasology.physics.bullet.BulletPhysics;\n+import org.terasology.physics.bullet.shapes.BulletCollisionShape;\n+import org.terasology.registry.In;\n+import org.terasology.world.OnChangedBlock;\n+import org.terasology.world.WorldComponent;\n+import org.terasology.world.WorldProvider;\n+import org.terasology.world.block.Block;\n+import org.terasology.world.block.BlockComponent;\n+import org.terasology.world.chunks.Chunk;\n+import org.terasology.world.chunks.ChunkConstants;\n+import org.terasology.world.chunks.ChunkProvider;\n+import org.terasology.world.chunks.event.BeforeChunkUnload;\n+import org.terasology.world.chunks.event.OnChunkLoaded;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import static org.terasology.physics.bullet.BulletPhysics.AABB_SIZE;\n+\n+@RegisterSystem\n+public class VoxelWorldSystem extends BaseComponentSystem {\n+\n+    @In\n+    private PhysicsEngine physics;\n+    @In\n+    private EntityManager entityManager;\n+    @In\n+    private WorldProvider worldProvider;\n+    @In\n+    private ChunkProvider chunkProvider;\n+\n+    private TShortHashSet registred = new TShortHashSet();\n+\n+    private btRigidBodyConstructionInfo blockConsInf;\n+    private btVoxelShape worldShape;\n+    private VoxelCollisionAlgorithmWrapper wrapper;\n+    private btRigidBody rigidBody;\n+\n+    @Override\n+    public void initialise() {\n+        if (physics instanceof BulletPhysics) {\n+            btDiscreteDynamicsWorld discreteDynamicsWorld = ((BulletPhysics) physics).getDiscreteDynamicsWorld();\n+\n+            wrapper = new VoxelCollisionAlgorithmWrapper(ChunkConstants.SIZE_X, ChunkConstants.SIZE_Y, ChunkConstants.SIZE_Z);\n+            worldShape = new btVoxelShape(wrapper, new Vector3f(-AABB_SIZE, -AABB_SIZE, -AABB_SIZE), new Vector3f(AABB_SIZE, AABB_SIZE, AABB_SIZE));\n+\n+            Matrix4f matrix4f = new Matrix4f();\n+            btDefaultMotionState blockMotionState = new btDefaultMotionState(matrix4f);\n+\n+            blockConsInf = new btRigidBodyConstructionInfo(0, blockMotionState, worldShape, new Vector3f());\n+            rigidBody = new btRigidBody(blockConsInf);\n+            rigidBody.setCollisionFlags(btCollisionObject.CollisionFlags.CF_STATIC_OBJECT | rigidBody.getCollisionFlags());\n+            short mask = (short) (~(StandardCollisionGroup.STATIC.getFlag() | StandardCollisionGroup.LIQUID.getFlag()));\n+            discreteDynamicsWorld.addRigidBody(rigidBody, physics.combineGroups(StandardCollisionGroup.WORLD), mask);\n+        }\n+\n+        super.initialise();\n+    }\n+\n+    private void tryRegister(Block block) {\n+        short id = block.getId();\n+        if (!registred.contains(id)) {\n+            btCollisionShape shape = ((BulletCollisionShape) block.getCollisionShape()).underlyingShape;\n+            btVoxelInfo info = new btVoxelInfo(shape != null && block.isTargetable(), shape != null && !block.isPenetrable(), id, shape, JomlUtil.from(block.getCollisionOffset()), block.getFriction(), block.getRestitution(), block.getFriction());\n+            wrapper.setVoxelInfo(info);\n+            registred.add(id);\n+        }\n+    }\n+\n+\n+    @ReceiveEvent(components = {BlockComponent.class})\n+    public void onBlockChange(OnChangedBlock event, EntityRef entity) {\n+        tryRegister(event.getNewType());\n+        wrapper.setBlock(event.getBlockPosition().x, event.getBlockPosition().y, event.getBlockPosition().z, event.getNewType().getId());\n+    }\n+\n+    @ReceiveEvent(components = WorldComponent.class)\n+    public void onChunkUloaded(BeforeChunkUnload beforeChunkUnload, EntityRef worldEntity) {\n+        Vector3i chunkPos = beforeChunkUnload.getChunkPos();\n+        wrapper.freeRegion(chunkPos.x, chunkPos.y, chunkPos.z);\n+    }\n+\n+    @ReceiveEvent(components = {WorldComponent.class})\n+    public void onNewChunk(OnChunkLoaded chunkAvailable, EntityRef worldEntity) {\n+        Vector3i chunkPos = chunkAvailable.getChunkPos();\n+        Chunk chunk = chunkProvider.getChunk(chunkPos);\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(2 * (ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z));\n+        buffer.order(ByteOrder.nativeOrder());\n+        short[] entries = new short[ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y * ChunkConstants.SIZE_Z];\n+        for (int x = 0; x < ChunkConstants.SIZE_X; ++x) {\n+            for (int y = 0; y < ChunkConstants.SIZE_Y; ++y) {\n+                for (int z = 0; z < ChunkConstants.SIZE_Z; ++z) {\n+                    int index = (z * ChunkConstants.SIZE_X * ChunkConstants.SIZE_Y) + (x * ChunkConstants.SIZE_Y) + y;\n+                    Block block = chunk.getBlock(x, y, z);\n+                    short id = block.getId();\n+                    tryRegister(block);\n+                    entries[index] = id;\n+\n+                }\n+            }\n+        }\n+        for (int k = 0; k < entries.length; k++) {", "originalCommit": "b7d49972c1205e48af7df1f02d056adbf2e2815d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "feb91f9e01b66a32bacc81f6aa109c67644795a9", "url": "https://github.com/MovingBlocks/Terasology/commit/feb91f9e01b66a32bacc81f6aa109c67644795a9", "message": "clean up code", "committedDate": "2020-08-28T06:15:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MjQ0MA==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478862440", "bodyText": "There is not right place.", "author": "DarkWeird", "createdAt": "2020-08-28T06:41:25Z", "path": "engine/src/main/java/org/terasology/engine/subsystem/lwjgl/BaseLwjglSubsystem.java", "diffHunk": "@@ -38,30 +39,32 @@ public void preInitialise(Context context) {\n         if (!initialised) {\n             initLogger();\n             LWJGLHelper.initNativeLibs();\n+            Bullet.init(true, false);", "originalCommit": "feb91f9e01b66a32bacc81f6aa109c67644795a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2NDI3Mg==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r478864272", "bodyText": "What is it? You salting code? :D", "author": "DarkWeird", "createdAt": "2020-08-28T06:46:28Z", "path": "engine/src/main/java/org/terasology/physics/bullet/BulletPhysics.java", "diffHunk": "@@ -364,21 +383,23 @@ public boolean removeTrigger(EntityRef entity) {\n     //TODO: update if detectGroups changed\n     public boolean updateTrigger(EntityRef entity) {\n         LocationComponent location = entity.getComponent(LocationComponent.class);\n-        PairCachingGhostObject triggerObj = entityTriggers.get(entity);\n+        btPairCachingGhostObject triggerObj = entityTriggers.get(entity);\n \n         if (location == null || Float.isNaN(location.getWorldPosition().x)) {\n             logger.warn(\"Trying to update or create trigger of entity that has no LocationComponent?! Entity: {}\", entity);\n             return false;\n         }\n         if (triggerObj != null) {\n             float scale = location.getWorldScale();\n-            if (Math.abs(triggerObj.getCollisionShape().getLocalScaling(new Vector3f()).x - scale) > BulletGlobals.SIMD_EPSILON) {\n+            if (Math.abs(triggerObj.getCollisionShape().getLocalScaling().x - scale) > SIMD_EPSILON) {\n                 discreteDynamicsWorld.removeCollisionObject(triggerObj);\n                 newTrigger(entity);\n             } else {\n-                Quat4f worldRotation = VecMath.to(location.getWorldRotation());\n-                Vector3f worldPosition = VecMath.to(location.getWorldPosition());\n-                triggerObj.setWorldTransform(new Transform(new Matrix4f(worldRotation, worldPosition, 1.0f)));\n+                Quaternionf worldRotation = JomlUtil.from(location.getWorldRotation());\n+                Vector3f worldPosition = JomlUtil.from(location.getWorldPosition());\n+                triggerObj.setWorldTransform(new Matrix4f().translationRotateScale(worldPosition,worldRotation,1.0f));\n+\n+//                triggerObj.setWorldTransform(new Matrix4f(worldRotation, worldPosition, 1.0f));//new Transform(new Matrix4f(worldRotation, worldPosition, 1.0f)));", "originalCommit": "feb91f9e01b66a32bacc81f6aa109c67644795a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0f25e0e941dccbb549762d580ed0b44a18f5c3f", "url": "https://github.com/MovingBlocks/Terasology/commit/f0f25e0e941dccbb549762d580ed0b44a18f5c3f", "message": "update version", "committedDate": "2020-08-28T15:50:55Z", "type": "commit"}, {"oid": "c17142e7b400b6501a99564de5b3b4c5b94d45ea", "url": "https://github.com/MovingBlocks/Terasology/commit/c17142e7b400b6501a99564de5b3b4c5b94d45ea", "message": "add javadocs and increase stepsize", "committedDate": "2020-08-28T16:33:19Z", "type": "commit"}, {"oid": "c864887721b35ba46e7e1879a0c8fbffef35ac41", "url": "https://github.com/MovingBlocks/Terasology/commit/c864887721b35ba46e7e1879a0c8fbffef35ac41", "message": "update assembly path loading", "committedDate": "2020-08-28T22:35:28Z", "type": "commit"}, {"oid": "6dad845740bae43f558c7f3063206bda4d75a165", "url": "https://github.com/MovingBlocks/Terasology/commit/6dad845740bae43f558c7f3063206bda4d75a165", "message": "clean up code", "committedDate": "2020-08-28T23:44:17Z", "type": "commit"}, {"oid": "49de41309f8c7097dc82e348136ed2979d4a19b1", "url": "https://github.com/MovingBlocks/Terasology/commit/49de41309f8c7097dc82e348136ed2979d4a19b1", "message": "chore: use v1 release of JNBullet", "committedDate": "2020-08-31T03:24:00Z", "type": "commit"}, {"oid": "6599dfc8ad743733beae66c1a4a3ae70515b67ae", "url": "https://github.com/MovingBlocks/Terasology/commit/6599dfc8ad743733beae66c1a4a3ae70515b67ae", "message": "fix convex hull shape", "committedDate": "2020-09-01T03:05:35Z", "type": "commit"}, {"oid": "8c20c3075f423b4b0296a5f4475dc1b4e90b2e1a", "url": "https://github.com/MovingBlocks/Terasology/commit/8c20c3075f423b4b0296a5f4475dc1b4e90b2e1a", "message": "fix entity motion state", "committedDate": "2020-09-01T04:06:16Z", "type": "commit"}, {"oid": "e0ad9ad9a6cd0811f308be970eb13df777394d96", "url": "https://github.com/MovingBlocks/Terasology/commit/e0ad9ad9a6cd0811f308be970eb13df777394d96", "message": "add bullet init for test cases", "committedDate": "2020-09-01T21:46:50Z", "type": "commit"}, {"oid": "7df9e51748329424e8445070b99ad131d6c02231", "url": "https://github.com/MovingBlocks/Terasology/commit/7df9e51748329424e8445070b99ad131d6c02231", "message": "add native extraction", "committedDate": "2020-09-02T04:10:06Z", "type": "commit"}, {"oid": "6fea5d0c1a774f4f07f90844cc933a8e5f7149c5", "url": "https://github.com/MovingBlocks/Terasology/commit/6fea5d0c1a774f4f07f90844cc933a8e5f7149c5", "message": "bump", "committedDate": "2020-09-02T04:34:27Z", "type": "commit"}, {"oid": "1ead3100ab78d22f5b37b93c7d87259a46574a8d", "url": "https://github.com/MovingBlocks/Terasology/commit/1ead3100ab78d22f5b37b93c7d87259a46574a8d", "message": "remove native path helper and define paths in pathmanager", "committedDate": "2020-09-02T05:18:19Z", "type": "commit"}, {"oid": "63963c12b90efacd8237cfe646a7ec50a97ddf5d", "url": "https://github.com/MovingBlocks/Terasology/commit/63963c12b90efacd8237cfe646a7ec50a97ddf5d", "message": "extrack natives", "committedDate": "2020-09-02T06:00:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1NzY4MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484457681", "bodyText": "Why there?\nWhat are means booleans?", "author": "DarkWeird", "createdAt": "2020-09-07T14:14:35Z", "path": "engine/src/main/java/org/terasology/engine/TerasologyEngine.java", "diffHunk": "@@ -155,6 +156,9 @@\n      *                   audio and input subsystems.\n      */\n     public TerasologyEngine(TimeSubsystem timeSubsystem, Collection<EngineSubsystem> subsystems) {\n+        // configure native paths\n+        PathManager.getInstance();", "originalCommit": "63963c12b90efacd8237cfe646a7ec50a97ddf5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4OTg4Ng==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484489886", "bodyText": "when the native paths are defined I also set the java paths. Just calling an instance of PathManager should be enough to set this up. Maybe something should be setup that is more sensible.", "author": "pollend", "createdAt": "2020-09-07T15:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1NzY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODU0MQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484458541", "bodyText": "Are we using returns  somewhere? in modules?\ngetWorldTransform with returns void - sounds strange..", "author": "DarkWeird", "createdAt": "2020-09-07T14:15:53Z", "path": "engine/src/main/java/org/terasology/physics/bullet/EntityMotionState.java", "diffHunk": "@@ -16,47 +16,55 @@\n \n package org.terasology.physics.bullet;\n \n-import com.bulletphysics.linearmath.MotionState;\n-import com.bulletphysics.linearmath.Transform;\n+import com.badlogic.gdx.physics.bullet.linearmath.btMotionState;\n+import org.joml.Matrix4f;\n+import org.joml.Quaternionf;\n+import org.joml.Vector3f;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.terasology.entitySystem.entity.EntityRef;\n import org.terasology.logic.location.LocationComponent;\n-import org.terasology.math.VecMath;\n+import org.terasology.math.JomlUtil;\n \n /**\n  * This motion state is used to connect rigid body entities to their rigid body in the bullet physics engine.\n  * Bullet reads the initial state of the rigid body out of the entity, and then updates its location and rotation\n  * as it moves under physics.\n  *\n  */\n-public class EntityMotionState extends MotionState {\n+public class EntityMotionState extends btMotionState {\n+    private static final Logger logger = LoggerFactory.getLogger(EntityMotionState.class);\n+\n     private EntityRef entity;\n+    private Quaternionf rot = new Quaternionf();\n+    private Vector3f position = new Vector3f();\n \n     /**\n      * Only the BulletPhysics class is expected to create instances.\n      *\n-     * @param entity The entity to relate this motion state to and set the\n-     *               LocationComponent of.\n+     * @param entity The entity to relate this motion state to and set the LocationComponent of.\n      */\n     EntityMotionState(EntityRef entity) {\n+        super();\n         this.entity = entity;\n     }\n \n     @Override\n-    public Transform getWorldTransform(Transform transform) {\n+    public void getWorldTransform(Matrix4f transform) {", "originalCommit": "63963c12b90efacd8237cfe646a7ec50a97ddf5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1MTY4OQ==", "url": "https://github.com/MovingBlocks/Terasology/pull/4139#discussion_r484551689", "bodyText": "this syncs changes between the LocationComponent and the bullet rigid body. this is for the JNI layer and its not exposed to engine. I believe this is generated by swig.", "author": "pollend", "createdAt": "2020-09-07T19:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ1ODU0MQ=="}], "type": "inlineReview"}]}