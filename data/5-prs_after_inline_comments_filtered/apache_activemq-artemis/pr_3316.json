{"pr_number": 3316, "pr_title": "ARTEMIS-2937 Broker Connections", "pr_createdAt": "2020-10-28T00:28:37Z", "pr_url": "https://github.com/apache/activemq-artemis/pull/3316", "timeline": [{"oid": "7691c0a04ab3f955c1feac1e0578da88575551df", "url": "https://github.com/apache/activemq-artemis/commit/7691c0a04ab3f955c1feac1e0578da88575551df", "message": "ARTEMIS-2937 DOCS & Examples on AMQP Broker Connection", "committedDate": "2020-10-28T14:38:44Z", "type": "forcePushed"}, {"oid": "10de26f79f309f699f53012dacb1fe9fdc2b22c7", "url": "https://github.com/apache/activemq-artemis/commit/10de26f79f309f699f53012dacb1fe9fdc2b22c7", "message": "ARTEMIS-2937 DOC updates", "committedDate": "2020-10-28T14:59:46Z", "type": "forcePushed"}, {"oid": "8499eac76c2044bfa52a65b9ada15581cd2efb7a", "url": "https://github.com/apache/activemq-artemis/commit/8499eac76c2044bfa52a65b9ada15581cd2efb7a", "message": "ARTEMIS-2937 Server Side AMQP Connectivity with options to transfer queues or replicate data", "committedDate": "2020-10-28T15:37:25Z", "type": "commit"}, {"oid": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "url": "https://github.com/apache/activemq-artemis/commit/12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "message": "ARTEMIS-2937 DOCS & Examples on AMQP Broker Connection", "committedDate": "2020-10-28T15:37:25Z", "type": "commit"}, {"oid": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "url": "https://github.com/apache/activemq-artemis/commit/12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "message": "ARTEMIS-2937 DOCS & Examples on AMQP Broker Connection", "committedDate": "2020-10-28T15:37:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513393624", "bodyText": "Since there appears to be a fixed 'head' node that always exists, and doesnt seem to ever be in the nodeMap, what does it mean if node.prev is null here?\nI ask as it seems odd that removal with id could return a value as in this case, but appear not to do anything at all to update the main list structure? When can that happen? (I may be missing something obvious here..)", "author": "gemmellr", "createdAt": "2020-10-28T12:12:22Z", "path": "artemis-commons/src/main/java/org/apache/activemq/artemis/utils/collections/LinkedListImpl.java", "diffHunk": "@@ -72,9 +115,43 @@ public void addHead(E e) {\n          node.next.prev = node;\n       }\n \n+      itemAdded(node, e);\n+\n       size++;\n    }\n \n+   @Override\n+   public E removeWithID(long id) {\n+      if (nodeMap == null) {\n+         return null;\n+      }\n+\n+      Node<E> node = nodeMap.get(id);\n+      if (node == null) {\n+         return null;\n+      }\n+\n+      if (node.prev != null) {\n+         removeAfter(node.prev);\n+      }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNTg4NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513605884", "bodyText": "if node != null, not.prev will always be != null...\nWe are adding the nodes to a separate list... the head will also be on the nodeList.\nthe != null is actually my OCD being extra careful. if you are strong opinioned about it I can take it out.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMTY3NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514131674", "bodyText": "Its more confusion and concern that it has modified the 'side area' map at this point but could return without removing anything from the the actual main list structure. If this is something to be careful about it seems more like it should be throwing an IllegalStateException or somthing rather than silently skipping, since the list must be broken for the check to have any effect.", "author": "gemmellr", "createdAt": "2020-10-29T09:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNTI2NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514205264", "bodyText": "I removed the check..", "author": "clebertsuconic", "createdAt": "2020-10-29T12:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5OTM2MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513399360", "bodyText": "This isnt used, tested, or similarly included on the PriorityLinkedList.\nShould it just be removed for now, or added to the PriorityLinkedList and tested?", "author": "gemmellr", "createdAt": "2020-10-28T12:22:36Z", "path": "artemis-commons/src/main/java/org/apache/activemq/artemis/utils/collections/LinkedListImpl.java", "diffHunk": "@@ -20,39 +20,82 @@\n import java.util.Comparator;\n import java.util.NoSuchElementException;\n import java.util.Objects;\n+import java.util.function.ToLongFunction;\n+\n+import io.netty.util.collection.LongObjectHashMap;\n \n /**\n  * A linked list implementation which allows multiple iterators to exist at the same time on the queue, and which see any\n  * elements added or removed from the queue either directly or via iterators.\n- *\n+ * <p>\n  * This class is not thread safe.\n  */\n public class LinkedListImpl<E> implements LinkedList<E> {\n \n    private static final int INITIAL_ITERATOR_ARRAY_SIZE = 10;\n \n    private final Node<E> head = new NodeHolder<>(null);\n-\n+   private final Comparator<E> comparator;\n+   LongObjectHashMap<Node<E>> nodeMap;\n    private Node<E> tail = null;\n-\n    private int size;\n-\n    // We store in an array rather than a Map for the best performance\n    private volatile Iterator[] iters;\n-\n    private int numIters;\n-\n    private int nextIndex;\n-\n-   private final Comparator<E> comparator;\n+   private ToLongFunction<E> idSupplier;\n \n    public LinkedListImpl() {\n-      this(null);\n+      this(null, null);\n    }\n \n    public LinkedListImpl(Comparator<E> comparator) {\n+      this(comparator, null);\n+   }\n+\n+   public LinkedListImpl(Comparator<E> comparator, ToLongFunction<E> supplier) {\n       iters = createIteratorArray(INITIAL_ITERATOR_ARRAY_SIZE);\n       this.comparator = comparator;\n+      this.idSupplier = supplier;\n+      if (idSupplier != null) {\n+         this.nodeMap = newLongHashMap();\n+      } else {\n+         this.nodeMap = null;\n+      }\n+   }\n+\n+   @Override\n+   public void clearID() {\n+      idSupplier = null;\n+      if (nodeMap != null) {\n+         nodeMap.clear();\n+         nodeMap = null;\n+      }\n+   }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MTExMQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513461111", "bodyText": "Debug stacktrace left over", "author": "gemmellr", "createdAt": "2020-10-28T13:53:58Z", "path": "artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/MessageReferenceImpl.java", "diffHunk": "@@ -362,6 +362,7 @@ public PagingStore getOwner() {\n \n    @Override\n    public void setOwner(PagingStore owner) {\n+      new Exception(\"Setting owner as \" + owner.getStoreName()).printStackTrace();", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODE0Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513468142", "bodyText": "Would read better if the \"// Fixed-address producer\" bit was outside the inner if, where it was originally, to balance with the comment in the other leg ( // Anonymous-relay producer, message must carry a To value)", "author": "gemmellr", "createdAt": "2020-10-28T14:02:50Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPSessionCallback.java", "diffHunk": "@@ -466,8 +466,10 @@ public void serverSend(ProtonServerReceiverContext context,\n \n       RoutingType routingType = null;\n       if (address != null) {\n-         // Fixed-address producer\n-         message.setAddress(address);\n+         if (!address.toString().equals(message.getAddress())) {\n+            // set Fixed-address producer if the message.properties.to address differs from the producer\n+            message.setAddress(address);\n+         }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODgzNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513468836", "bodyText": "typo in AMQPConenctionBridge\nEDIT: Actually, the comment may be in the wrong place? This is a provate method so it cant directly be used by AMQPConnectionBridge", "author": "gemmellr", "createdAt": "2020-10-28T14:03:48Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/ProtonProtocolManager.java", "diffHunk": "@@ -173,8 +177,35 @@ public ProtonProtocolManager setDirectDeliver(boolean directDeliver) {\n       return this;\n    }\n \n+   /** for outgoing */\n+   public ProtonClientProtocolManager createClientManager() {\n+      ProtonClientProtocolManager clientOutgoing = new ProtonClientProtocolManager(factory, server);\n+      return clientOutgoing;\n+   }\n+\n    @Override\n    public ConnectionEntry createConnectionEntry(Acceptor acceptorUsed, Connection remotingConnection) {\n+      return internalConnectionEntry(remotingConnection, false, null);\n+   }\n+\n+   /** This method is not part of the ProtocolManager interface because it only makes sense on AMQP.\n+    *  More specifically on AMQP Bridges */\n+   public ConnectionEntry createOutgoingConnectionEntry(Connection remotingConnection) {\n+      return internalConnectionEntry(remotingConnection, true, null);\n+   }\n+\n+   public ConnectionEntry createOutgoingConnectionEntry(Connection remotingConnection, ClientSASLFactory saslFactory) {\n+      return internalConnectionEntry(remotingConnection, true, saslFactory);\n+   }\n+\n+   /**\n+    * AMQP is an agnostic protocol, client and server.\n+    * This method is used also by the AMQPConenctionBridge where there is no acceptor in place.", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNzQ5NQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513607495", "bodyText": "I removed the comment.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4NDU0MQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513484541", "bodyText": "This section appears like it probably isnt thread safe in its use of proton-j.\nThe initial connection open and a flush is offloaded to the connection thread...then this thread proceeds to create a session object on the connection, though then offloads its open and flush and open call back to the connection thread. The next bit where it starts creating senders and recievers on this thread (if not more, depends whether the Stream returned was sequential or not) is probably safe as those bits offload to the connection thread I believe.", "author": "gemmellr", "createdAt": "2020-10-28T14:23:28Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }\n+      ScheduledFuture scheduledFuture = reconnectFuture;\n+      reconnectFuture = null;\n+      if (scheduledFuture != null) {\n+         scheduledFuture.cancel(true);\n+      }\n+      started = false;\n+   }\n+\n+   @Override\n+   public void start() throws Exception {\n+      started = true;\n+      server.getConfiguration().registerBrokerPlugin(this);\n+      try {\n+\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+               installMirrorController((AMQPMirrorBrokerConnectionElement)connectionElement, server);\n+            }\n+         }\n+      } catch (Throwable e) {\n+         logger.warn(e.getMessage(), e);\n+         return;\n+      }\n+      connectExecutor.execute(() -> doConnect());\n+   }\n+\n+   public NettyConnection getConnection() {\n+      return connection;\n+   }\n+\n+   @Override\n+   public void afterCreateQueue(Queue queue) {\n+      connectExecutor.execute(() -> {\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            validateMatching(queue, connectionElement);\n+         }\n+      });\n+   }\n+\n+   public void validateMatching(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() != AMQPBrokerConnectionAddressType.MIRROR) {\n+         if (connectionElement.getQueueName() != null) {\n+            if (queue.getName().equals(connectionElement.getQueueName())) {\n+               createLink(queue, connectionElement);\n+            }\n+         } else if (connectionElement.match(queue.getAddress(), server.getConfiguration().getWildcardConfiguration())) {\n+            createLink(queue, connectionElement);\n+         }\n+      }\n+   }\n+\n+   public void createLink(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() == AMQPBrokerConnectionAddressType.PEER) {\n+         connectSender(queue, queue.getAddress().toString(), Symbol.valueOf(\"qd.waypoint\"));\n+         connectReceiver(protonRemotingConnection, session, sessionContext, queue, Symbol.valueOf(\"qd.waypoint\"));\n+      } else {\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.SENDER) {\n+            connectSender(queue, queue.getAddress().toString());\n+         }\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.RECEIVER) {\n+            connectReceiver(protonRemotingConnection, session, sessionContext, queue);\n+         }\n+      }\n+   }\n+\n+   private void doConnect() {\n+      try {\n+         List<TransportConfiguration> configurationList = brokerConnectConfiguration.getTransportConfigurations();\n+\n+         TransportConfiguration tpConfig = configurationList.get(0);\n+\n+         String hostOnParameter = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, tpConfig.getParams());\n+         int portOnParameter = ConfigurationHelper.getIntProperty(TransportConstants.PORT_PROP_NAME, TransportConstants.DEFAULT_PORT, tpConfig.getParams());\n+         this.host = hostOnParameter;\n+         this.port = portOnParameter;\n+         connection = bridgesConnector.createConnection(null, hostOnParameter, portOnParameter);\n+\n+         if (connection == null) {\n+            retryConnection();\n+            return;\n+         }\n+\n+         reconnectFuture = null;\n+         retryCounter = 0;\n+\n+         // before we retry the connection we need to remove any previous links\n+         // as they will need to be recreated\n+         senders.clear();\n+         receivers.clear();\n+\n+         ClientSASLFactory saslFactory = null;\n+\n+         if (brokerConnectConfiguration.getUser() != null && brokerConnectConfiguration.getPassword() != null) {\n+            saslFactory = availableMechanims -> {\n+               if (availableMechanims != null && Arrays.asList(availableMechanims).contains(\"PLAIN\")) {\n+                  return new PlainSASLMechanism(brokerConnectConfiguration.getUser(), brokerConnectConfiguration.getPassword());\n+               } else {\n+                  return null;\n+               }\n+            };\n+         }\n+\n+         ConnectionEntry entry = protonProtocolManager.createOutgoingConnectionEntry(connection, saslFactory);\n+         protonRemotingConnection = (ActiveMQProtonRemotingConnection) entry.connection;\n+         connection.getChannel().pipeline().addLast(new AMQPBrokerConnectionChannelHandler(bridgesConnector.getChannelGroup(), protonRemotingConnection.getAmqpConnection().getHandler()));\n+\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            protonRemotingConnection.getAmqpConnection().open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         session = protonRemotingConnection.getAmqpConnection().getHandler().getConnection().session();\n+         sessionContext = protonRemotingConnection.getAmqpConnection().getSessionExtension(session);\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            session.open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         if (brokerConnectConfiguration.getConnectionElements() != null) {\n+            Stream<Binding> bindingStream = server.getPostOffice().getAllBindings();\n+\n+            bindingStream.forEach(binding -> {\n+               if (binding instanceof QueueBinding) {\n+                  Queue queue = ((QueueBinding) binding).getQueue();\n+                  for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+                     validateMatching(queue, connectionElement);\n+                  }\n+               }\n+            });\n+\n+            for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+               if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+                  AMQPMirrorBrokerConnectionElement replica = (AMQPMirrorBrokerConnectionElement)connectionElement;\n+                  Queue queue = server.locateQueue(replica.getSourceMirrorAddress());\n+\n+                  connectSender(queue, ProtonProtocolManager.MIRROR_ADDRESS);\n+               }\n+            }\n+         }\n+\n+         protonRemotingConnection.getAmqpConnection().flush();", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513491335", "bodyText": "If you stop a connection with mirror config that doesnt specify a source mirror address, what happens to the generated mirror queue and its contents?", "author": "gemmellr", "createdAt": "2020-10-28T14:31:27Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwODQxNw==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513608417", "bodyText": "They would stay in, unless someone removed the queue.\nThe mirror will also stay in generating values.. just the connection would be stopped.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODgzNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513658834", "bodyText": "I will document this. We can change behavior in a future release. and I will create a JIRA for this.", "author": "clebertsuconic", "createdAt": "2020-10-28T18:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2MDQxMQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513660411", "bodyText": "https://issues.apache.org/jira/browse/ARTEMIS-2965", "author": "clebertsuconic", "createdAt": "2020-10-28T18:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE5MzQwMQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514193401", "bodyText": "Ok, so it still exists, and it accumulates ongoing activity...then you can restart it and theyll be mirrored? That seems fine.\nIn which case maybe the JIRA would jsut be be more 'allow deleting connections (and related mirror queues?)'", "author": "gemmellr", "createdAt": "2020-10-29T11:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNTYyOQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514205629", "bodyText": "that's correct", "author": "clebertsuconic", "createdAt": "2020-10-29T12:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwMzYwOA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513503608", "bodyText": "Starts with Capital while all the others are camelCase", "author": "gemmellr", "createdAt": "2020-10-28T14:46:11Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/mirror/AMQPMirrorControllerSource.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.protocol.amqp.connect.mirror;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.activemq.artemis.api.core.Message;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.core.paging.PagingStore;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.MessageReference;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.RoutingContext;\n+import org.apache.activemq.artemis.core.server.impl.AckReason;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.impl.RoutingContextImpl;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.transaction.Transaction;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessage;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessageBrokerAccessor;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Properties;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPMirrorControllerSource implements MirrorController, ActiveMQComponent {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPMirrorControllerSource.class);\n+\n+   public static final Symbol EVENT_TYPE = Symbol.getSymbol(\"x-opt-amq-mr-ev-type\");\n+   public static final Symbol ADDRESS = Symbol.getSymbol(\"x-opt-amq-mr-adr\");\n+   public static final Symbol QUEUE = Symbol.getSymbol(\"x-opt-amq-mr-qu\");\n+\n+   // Events:\n+   public static final Symbol ADD_ADDRESS = Symbol.getSymbol(\"addAddress\");\n+   public static final Symbol DELETE_ADDRESS = Symbol.getSymbol(\"deleteAddress\");\n+   public static final Symbol CREATE_QUEUE = Symbol.getSymbol(\"createQueue\");\n+   public static final Symbol DELETE_QUEUE = Symbol.getSymbol(\"deleteQueue\");\n+   public static final Symbol ADDRESS_SCAN_START = Symbol.getSymbol(\"AddressCanStart\");\n+   public static final Symbol ADDRESS_SCAN_END = Symbol.getSymbol(\"AddressScanEnd\");", "originalCommit": "7691c0a04ab3f955c1feac1e0578da88575551df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNTg4Ng==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513505886", "bodyText": "\"daMap\" might be more descriptive, help readability", "author": "gemmellr", "createdAt": "2020-10-28T14:48:47Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/mirror/AMQPMirrorControllerSource.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.protocol.amqp.connect.mirror;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.activemq.artemis.api.core.Message;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.core.paging.PagingStore;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.MessageReference;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.RoutingContext;\n+import org.apache.activemq.artemis.core.server.impl.AckReason;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.impl.RoutingContextImpl;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.transaction.Transaction;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessage;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessageBrokerAccessor;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Properties;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPMirrorControllerSource implements MirrorController, ActiveMQComponent {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPMirrorControllerSource.class);\n+\n+   public static final Symbol EVENT_TYPE = Symbol.getSymbol(\"x-opt-amq-mr-ev-type\");\n+   public static final Symbol ADDRESS = Symbol.getSymbol(\"x-opt-amq-mr-adr\");\n+   public static final Symbol QUEUE = Symbol.getSymbol(\"x-opt-amq-mr-qu\");\n+\n+   // Events:\n+   public static final Symbol ADD_ADDRESS = Symbol.getSymbol(\"addAddress\");\n+   public static final Symbol DELETE_ADDRESS = Symbol.getSymbol(\"deleteAddress\");\n+   public static final Symbol CREATE_QUEUE = Symbol.getSymbol(\"createQueue\");\n+   public static final Symbol DELETE_QUEUE = Symbol.getSymbol(\"deleteQueue\");\n+   public static final Symbol ADDRESS_SCAN_START = Symbol.getSymbol(\"AddressCanStart\");\n+   public static final Symbol ADDRESS_SCAN_END = Symbol.getSymbol(\"AddressScanEnd\");\n+   public static final Symbol POST_ACK = Symbol.getSymbol(\"postAck\");\n+\n+   // Delivery annotation property used on mirror control routing and Ack\n+   public static final Symbol INTERNAL_ID = Symbol.getSymbol(\"x-opt-amq-mr-id\");\n+   public static final Symbol INTERNAL_DESTINATION = Symbol.getSymbol(\"x-opt-amq-mr-dst\");\n+\n+   private static final ThreadLocal<MirrorControlRouting> mirrorControlRouting = ThreadLocal.withInitial(() -> new MirrorControlRouting(null));\n+\n+   final Queue snfQueue;\n+   final ActiveMQServer server;\n+   final boolean acks;\n+\n+   boolean started;\n+\n+   @Override\n+   public void start() throws Exception {\n+   }\n+\n+   @Override\n+   public void stop() throws Exception {\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   public AMQPMirrorControllerSource(Queue snfQueue, ActiveMQServer server, boolean acks) {\n+      this.snfQueue = snfQueue;\n+      this.server = server;\n+      this.acks = acks;\n+   }\n+\n+   @Override\n+   public void startAddressScan() throws Exception {\n+      Message message = createMessage(null, null, ADDRESS_SCAN_START, null);\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void endAddressScan() throws Exception {\n+      Message message = createMessage(null, null, ADDRESS_SCAN_END, null);\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void addAddress(AddressInfo addressInfo) throws Exception {\n+      Message message = createMessage(addressInfo.getName(), null, ADD_ADDRESS, addressInfo.toJSON());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void deleteAddress(AddressInfo addressInfo) throws Exception {\n+      Message message = createMessage(addressInfo.getName(), null, DELETE_ADDRESS, addressInfo.toJSON());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void createQueue(QueueConfiguration queueConfiguration) throws Exception {\n+      Message message = createMessage(queueConfiguration.getAddress(), queueConfiguration.getName(), CREATE_QUEUE, queueConfiguration.toJSON());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void deleteQueue(SimpleString address, SimpleString queue) throws Exception {\n+      Message message = createMessage(address, queue, DELETE_QUEUE, queue.toString());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void sendMessage(Message message, RoutingContext context, List<MessageReference> refs) {\n+\n+      try {\n+         context.setReusable(false);\n+         PagingStore storeOwner = null;\n+         if (refs.size() > 0) {\n+            storeOwner = refs.get(0).getOwner();\n+         }\n+         if (storeOwner != null && !storeOwner.getAddress().equals(message.getAddressSimpleString())) {\n+            storeOwner = server.getPagingManager().getPageStore(message.getAddressSimpleString());\n+         }\n+         MessageReference ref = MessageReference.Factory.createReference(message, snfQueue, storeOwner);\n+\n+         snfQueue.refUp(ref);\n+\n+         Map<Symbol, Object> symbolObjectMap = new HashMap<>();", "originalCommit": "7691c0a04ab3f955c1feac1e0578da88575551df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTY1MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513521650", "bodyText": "The arg modified is called \"isServer\", and this says it may now change depending on whether saslClientFactory is null - yet the new bridge code allows it to be both null or not, depending on whether a user/pass is given. This seems strange.", "author": "gemmellr", "createdAt": "2020-10-28T15:07:19Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/AMQPConnectionContext.java", "diffHunk": "@@ -129,7 +156,7 @@ public AMQPConnectionContext(ProtonProtocolManager protocolManager,\n       } else {\n          nettyExecutor = new ExecutorNettyAdapter(protocolManager.getServer().getExecutorFactory().getExecutor());\n       }\n-      this.handler = new ProtonHandler(nettyExecutor, protocolManager.getServer().getExecutorFactory().getExecutor(), isIncomingConnection);\n+      this.handler = new ProtonHandler(nettyExecutor, protocolManager.getServer().getExecutorFactory().getExecutor(), isIncomingConnection && saslClientFactory == null);", "originalCommit": "7691c0a04ab3f955c1feac1e0578da88575551df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODAyNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513658026", "bodyText": "this is not actually part of my change. This was this way before since \"ARTEMIS-1454: Support SASL in outgoing AMQP\" on commit cc8a0cb", "author": "clebertsuconic", "createdAt": "2020-10-28T18:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0OTE1Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514149152", "bodyText": "The bit im talking about is part of your change, its the diff being commented on. The change makes the value passed for ''isServer' also dependent on whether or not saslClientFactory is null or not. The usage of these bits it in the overall changes mean it can be both null and non-null values, for outgoing 'client' connections. I dont see why the value passed for 'isServer' would change depending on this.", "author": "gemmellr", "createdAt": "2020-10-29T10:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2MTEzNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513561136", "bodyText": "Stale comment", "author": "gemmellr", "createdAt": "2020-10-28T15:56:19Z", "path": "examples/features/broker-connection/amqp-receiving-messages/src/main/java/org/apache/activemq/artemis/jms/example/BrokerConnectionReceiver.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.jms.example;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Queue;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+import org.apache.qpid.jms.JmsConnectionFactory;\n+\n+/**\n+ * This example demonstrates how sessions created from a single connection can be load\n+ * balanced across the different nodes of the cluster.\n+ * <p>\n+ * In this example there are three nodes and we use a round-robin client side load-balancing\n+ * policy.\n+ */", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513564426", "bodyText": "I know the target of the example is SSL between the brokers...but it might make more sense to use SSL for the clients too. Then you would only need one acceptor.\nThis basically makes it seem like SSL isnt being used.", "author": "gemmellr", "createdAt": "2020-10-28T16:00:04Z", "path": "examples/features/broker-connection/amqp-sending-overssl/src/main/java/org/apache/activemq/artemis/jms/example/BrokerConnectionSenderSSL.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.jms.example;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Queue;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+import org.apache.qpid.jms.JmsConnectionFactory;\n+\n+/**\n+ * This example is demonstrating how messages are transferred from one broker towards another broker\n+ * through the sender element on a AMQP Broker Connection.\n+ */\n+public class BrokerConnectionSenderSSL {\n+\n+   public static void main(final String[] args) throws Exception {\n+      Connection connectionOnServer0 = null;\n+      ConnectionFactory connectionFactoryServer0 = new JmsConnectionFactory(\"amqp://localhost:5671\");", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTYwNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513579604", "bodyText": "I'm not showing how to use SSL on  the client here.. .this is already covered elsewhere.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4ODM1Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513588352", "bodyText": "I know that, as I commented. Its just weird though. The example broker config is actually more complicated due to not using SSL for the client...which wouldnt add any complexity since all the stores are already in place.", "author": "gemmellr", "createdAt": "2020-10-28T16:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzU0NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513617544", "bodyText": "I would not do that on this version.. there's a lot of stuff to cover already.", "author": "clebertsuconic", "createdAt": "2020-10-28T17:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIzMjE1OQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514232159", "bodyText": "I'm sending a change for this on the PR #3318", "author": "clebertsuconic", "createdAt": "2020-10-29T12:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2OTc0NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513569744", "bodyText": "Given this will be the typical case, I think not printing (perhaps debug logging?) the stacktrace would be good, and instead having the assumption check say why it is skipping", "author": "gemmellr", "createdAt": "2020-10-28T16:06:24Z", "path": "tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/amqp/connect/QpidDispatchPeerTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.tests.integration.amqp.connect;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.DeliveryMode;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Queue;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import java.net.URL;\n+\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.tests.integration.amqp.AmqpClientTestSupport;\n+import org.apache.activemq.artemis.tests.util.CFUtil;\n+import org.apache.activemq.artemis.tests.util.Wait;\n+import org.apache.activemq.artemis.utils.ExecuteUtil;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+/** This test will only be executed if you have qdrouterd available on your system, otherwise is ignored by an assume exception. */\n+public class QpidDispatchPeerTest extends AmqpClientTestSupport {\n+\n+   ExecuteUtil.ProcessHolder qpidProcess;\n+\n+   /**\n+    * This will validate if the environemnt has qdrouterd installed and if this test can be used or not.\n+    */\n+   @BeforeClass\n+   public static void validateqdrotuer() {\n+      try {\n+         int result = ExecuteUtil.runCommand(true, \"qdrouterd\", \"--version\");\n+         Assume.assumeTrue(\"qdrouterd does not exist\", result == 0);\n+      } catch (Exception e) {\n+         e.printStackTrace();", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5NDU2MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513594560", "bodyText": "Adding a \":\" between the name and generated bit would aid readability when debugging protocol trace.", "author": "gemmellr", "createdAt": "2020-10-28T16:38:54Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }\n+      ScheduledFuture scheduledFuture = reconnectFuture;\n+      reconnectFuture = null;\n+      if (scheduledFuture != null) {\n+         scheduledFuture.cancel(true);\n+      }\n+      started = false;\n+   }\n+\n+   @Override\n+   public void start() throws Exception {\n+      started = true;\n+      server.getConfiguration().registerBrokerPlugin(this);\n+      try {\n+\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+               installMirrorController((AMQPMirrorBrokerConnectionElement)connectionElement, server);\n+            }\n+         }\n+      } catch (Throwable e) {\n+         logger.warn(e.getMessage(), e);\n+         return;\n+      }\n+      connectExecutor.execute(() -> doConnect());\n+   }\n+\n+   public NettyConnection getConnection() {\n+      return connection;\n+   }\n+\n+   @Override\n+   public void afterCreateQueue(Queue queue) {\n+      connectExecutor.execute(() -> {\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            validateMatching(queue, connectionElement);\n+         }\n+      });\n+   }\n+\n+   public void validateMatching(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() != AMQPBrokerConnectionAddressType.MIRROR) {\n+         if (connectionElement.getQueueName() != null) {\n+            if (queue.getName().equals(connectionElement.getQueueName())) {\n+               createLink(queue, connectionElement);\n+            }\n+         } else if (connectionElement.match(queue.getAddress(), server.getConfiguration().getWildcardConfiguration())) {\n+            createLink(queue, connectionElement);\n+         }\n+      }\n+   }\n+\n+   public void createLink(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() == AMQPBrokerConnectionAddressType.PEER) {\n+         connectSender(queue, queue.getAddress().toString(), Symbol.valueOf(\"qd.waypoint\"));\n+         connectReceiver(protonRemotingConnection, session, sessionContext, queue, Symbol.valueOf(\"qd.waypoint\"));\n+      } else {\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.SENDER) {\n+            connectSender(queue, queue.getAddress().toString());\n+         }\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.RECEIVER) {\n+            connectReceiver(protonRemotingConnection, session, sessionContext, queue);\n+         }\n+      }\n+   }\n+\n+   private void doConnect() {\n+      try {\n+         List<TransportConfiguration> configurationList = brokerConnectConfiguration.getTransportConfigurations();\n+\n+         TransportConfiguration tpConfig = configurationList.get(0);\n+\n+         String hostOnParameter = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, tpConfig.getParams());\n+         int portOnParameter = ConfigurationHelper.getIntProperty(TransportConstants.PORT_PROP_NAME, TransportConstants.DEFAULT_PORT, tpConfig.getParams());\n+         this.host = hostOnParameter;\n+         this.port = portOnParameter;\n+         connection = bridgesConnector.createConnection(null, hostOnParameter, portOnParameter);\n+\n+         if (connection == null) {\n+            retryConnection();\n+            return;\n+         }\n+\n+         reconnectFuture = null;\n+         retryCounter = 0;\n+\n+         // before we retry the connection we need to remove any previous links\n+         // as they will need to be recreated\n+         senders.clear();\n+         receivers.clear();\n+\n+         ClientSASLFactory saslFactory = null;\n+\n+         if (brokerConnectConfiguration.getUser() != null && brokerConnectConfiguration.getPassword() != null) {\n+            saslFactory = availableMechanims -> {\n+               if (availableMechanims != null && Arrays.asList(availableMechanims).contains(\"PLAIN\")) {\n+                  return new PlainSASLMechanism(brokerConnectConfiguration.getUser(), brokerConnectConfiguration.getPassword());\n+               } else {\n+                  return null;\n+               }\n+            };\n+         }\n+\n+         ConnectionEntry entry = protonProtocolManager.createOutgoingConnectionEntry(connection, saslFactory);\n+         protonRemotingConnection = (ActiveMQProtonRemotingConnection) entry.connection;\n+         connection.getChannel().pipeline().addLast(new AMQPBrokerConnectionChannelHandler(bridgesConnector.getChannelGroup(), protonRemotingConnection.getAmqpConnection().getHandler()));\n+\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            protonRemotingConnection.getAmqpConnection().open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         session = protonRemotingConnection.getAmqpConnection().getHandler().getConnection().session();\n+         sessionContext = protonRemotingConnection.getAmqpConnection().getSessionExtension(session);\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            session.open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         if (brokerConnectConfiguration.getConnectionElements() != null) {\n+            Stream<Binding> bindingStream = server.getPostOffice().getAllBindings();\n+\n+            bindingStream.forEach(binding -> {\n+               if (binding instanceof QueueBinding) {\n+                  Queue queue = ((QueueBinding) binding).getQueue();\n+                  for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+                     validateMatching(queue, connectionElement);\n+                  }\n+               }\n+            });\n+\n+            for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+               if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+                  AMQPMirrorBrokerConnectionElement replica = (AMQPMirrorBrokerConnectionElement)connectionElement;\n+                  Queue queue = server.locateQueue(replica.getSourceMirrorAddress());\n+\n+                  connectSender(queue, ProtonProtocolManager.MIRROR_ADDRESS);\n+               }\n+            }\n+         }\n+\n+         protonRemotingConnection.getAmqpConnection().flush();\n+\n+         bridgeManager.connected(connection, this);\n+      } catch (Throwable e) {\n+         error(e);\n+      }\n+   }\n+\n+   public void retryConnection() {\n+      if (bridgeManager.isStarted() && started) {\n+         if (brokerConnectConfiguration.getReconnectAttempts() < 0 || retryCounter < brokerConnectConfiguration.getReconnectAttempts()) {\n+            retryCounter++;\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnection(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"Reconnecting in \" + brokerConnectConfiguration.getRetryInterval() + \", this is the \" + retryCounter + \" of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+            reconnectFuture = scheduledExecutorService.schedule(() -> connectExecutor.execute(() -> doConnect()), brokerConnectConfiguration.getRetryInterval(), TimeUnit.MILLISECONDS);\n+         } else {\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnectionFailed(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"no more reconnections as the retry counter reached \" + retryCounter + \" out of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+         }\n+      }\n+   }\n+\n+   /** The reason this method is static is the following:\n+    *\n+    *  It is returning the snfQueue to the replica, and I needed isolation from the actual instance.\n+    *  During development I had a mistake where I used a property from the Object,\n+    *  so, I needed this isolation for my organization and making sure nothing would be shared. */\n+   private static QueueBinding installMirrorController(AMQPMirrorBrokerConnectionElement replicaConfig, ActiveMQServer server) throws Exception {\n+\n+      AddressInfo addressInfo = server.getAddressInfo(replicaConfig.getSourceMirrorAddress());\n+      if (addressInfo == null) {\n+         addressInfo = new AddressInfo(replicaConfig.getSourceMirrorAddress()).addRoutingType(RoutingType.ANYCAST).setAutoCreated(false).setTemporary(!replicaConfig.isDurable());\n+         server.addAddressInfo(addressInfo);\n+      }\n+\n+      if (addressInfo.getRoutingType() != RoutingType.ANYCAST) {\n+         throw new IllegalArgumentException(\"sourceMirrorAddress is not ANYCAST\");\n+      }\n+\n+      Queue mirrorControlQueue = server.locateQueue(replicaConfig.getSourceMirrorAddress());\n+\n+      if (mirrorControlQueue == null) {\n+         mirrorControlQueue = server.createQueue(new QueueConfiguration(replicaConfig.getSourceMirrorAddress()).setAddress(replicaConfig.getSourceMirrorAddress()).setRoutingType(RoutingType.ANYCAST).setDurable(replicaConfig.isDurable()), true);\n+      }\n+\n+      mirrorControlQueue.setMirrorController(true);\n+\n+      QueueBinding snfReplicaQueueBinding = (QueueBinding)server.getPostOffice().getBinding(replicaConfig.getSourceMirrorAddress());\n+      if (snfReplicaQueueBinding == null) {\n+         logger.warn(\"Queue does not exist even after creation! \" + replicaConfig);\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      Queue snfQueue = snfReplicaQueueBinding.getQueue();\n+\n+      if (!snfQueue.getAddress().equals(replicaConfig.getSourceMirrorAddress())) {\n+         logger.warn(\"Queue \" + snfQueue + \" belong to a different address (\" + snfQueue.getAddress() + \"), while we expected it to be \" + addressInfo.getName());\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      AMQPMirrorControllerSource newPartition = new AMQPMirrorControllerSource(snfQueue, server, replicaConfig.isMessageAcknowledgements());\n+\n+      server.scanAddresses(newPartition);\n+\n+      MirrorController currentMirrorController = server.getMirrorController();\n+\n+      if (currentMirrorController == null) {\n+         server.installMirrorController(newPartition);\n+      } else {\n+         // Replace a standard implementation by an aggregated supporting multiple targets\n+         if (currentMirrorController instanceof AMQPMirrorControllerSource) {\n+            // replacing the simple mirror control for an aggregator\n+            AMQPMirrorControllerAggregation remoteAggregation = new AMQPMirrorControllerAggregation();\n+            remoteAggregation.addPartition((AMQPMirrorControllerSource) currentMirrorController);\n+            currentMirrorController = remoteAggregation;\n+            server.installMirrorController(remoteAggregation);\n+         }\n+         ((AMQPMirrorControllerAggregation) currentMirrorController).addPartition(newPartition);\n+      }\n+\n+      return snfReplicaQueueBinding;\n+   }\n+\n+   private void connectReceiver(ActiveMQProtonRemotingConnection protonRemotingConnection,\n+                                Session session,\n+                                AMQPSessionContext sessionContext,\n+                                Queue queue,\n+                                Symbol... capabilities) {\n+      if (logger.isDebugEnabled()) {\n+         logger.debug(\"Connecting inbound for \" + queue);\n+      }\n+\n+      if (session == null) {\n+         logger.debug(\"session is null\");\n+         return;\n+      }\n+\n+      protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+\n+         if (receivers.contains(queue)) {\n+            logger.debug(\"Receiver for queue \" + queue + \" already exists, just giving up\");\n+            return;\n+         }\n+         receivers.add(queue);\n+         Receiver receiver = session.receiver(queue.getName().toString() + UUIDGenerator.getInstance().generateStringUUID());", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5OTQ4Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513599482", "bodyText": "also, the link is named based on the queue name, but then the address name as the source address....I'd tend to expect the receiver link name to incorporate the source address", "author": "gemmellr", "createdAt": "2020-10-28T16:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5NDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5NDcyOQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513594729", "bodyText": "Adding a \":\" between the name and generated bit would aid readability when debugging protocol trace.", "author": "gemmellr", "createdAt": "2020-10-28T16:39:11Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }\n+      ScheduledFuture scheduledFuture = reconnectFuture;\n+      reconnectFuture = null;\n+      if (scheduledFuture != null) {\n+         scheduledFuture.cancel(true);\n+      }\n+      started = false;\n+   }\n+\n+   @Override\n+   public void start() throws Exception {\n+      started = true;\n+      server.getConfiguration().registerBrokerPlugin(this);\n+      try {\n+\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+               installMirrorController((AMQPMirrorBrokerConnectionElement)connectionElement, server);\n+            }\n+         }\n+      } catch (Throwable e) {\n+         logger.warn(e.getMessage(), e);\n+         return;\n+      }\n+      connectExecutor.execute(() -> doConnect());\n+   }\n+\n+   public NettyConnection getConnection() {\n+      return connection;\n+   }\n+\n+   @Override\n+   public void afterCreateQueue(Queue queue) {\n+      connectExecutor.execute(() -> {\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            validateMatching(queue, connectionElement);\n+         }\n+      });\n+   }\n+\n+   public void validateMatching(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() != AMQPBrokerConnectionAddressType.MIRROR) {\n+         if (connectionElement.getQueueName() != null) {\n+            if (queue.getName().equals(connectionElement.getQueueName())) {\n+               createLink(queue, connectionElement);\n+            }\n+         } else if (connectionElement.match(queue.getAddress(), server.getConfiguration().getWildcardConfiguration())) {\n+            createLink(queue, connectionElement);\n+         }\n+      }\n+   }\n+\n+   public void createLink(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() == AMQPBrokerConnectionAddressType.PEER) {\n+         connectSender(queue, queue.getAddress().toString(), Symbol.valueOf(\"qd.waypoint\"));\n+         connectReceiver(protonRemotingConnection, session, sessionContext, queue, Symbol.valueOf(\"qd.waypoint\"));\n+      } else {\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.SENDER) {\n+            connectSender(queue, queue.getAddress().toString());\n+         }\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.RECEIVER) {\n+            connectReceiver(protonRemotingConnection, session, sessionContext, queue);\n+         }\n+      }\n+   }\n+\n+   private void doConnect() {\n+      try {\n+         List<TransportConfiguration> configurationList = brokerConnectConfiguration.getTransportConfigurations();\n+\n+         TransportConfiguration tpConfig = configurationList.get(0);\n+\n+         String hostOnParameter = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, tpConfig.getParams());\n+         int portOnParameter = ConfigurationHelper.getIntProperty(TransportConstants.PORT_PROP_NAME, TransportConstants.DEFAULT_PORT, tpConfig.getParams());\n+         this.host = hostOnParameter;\n+         this.port = portOnParameter;\n+         connection = bridgesConnector.createConnection(null, hostOnParameter, portOnParameter);\n+\n+         if (connection == null) {\n+            retryConnection();\n+            return;\n+         }\n+\n+         reconnectFuture = null;\n+         retryCounter = 0;\n+\n+         // before we retry the connection we need to remove any previous links\n+         // as they will need to be recreated\n+         senders.clear();\n+         receivers.clear();\n+\n+         ClientSASLFactory saslFactory = null;\n+\n+         if (brokerConnectConfiguration.getUser() != null && brokerConnectConfiguration.getPassword() != null) {\n+            saslFactory = availableMechanims -> {\n+               if (availableMechanims != null && Arrays.asList(availableMechanims).contains(\"PLAIN\")) {\n+                  return new PlainSASLMechanism(brokerConnectConfiguration.getUser(), brokerConnectConfiguration.getPassword());\n+               } else {\n+                  return null;\n+               }\n+            };\n+         }\n+\n+         ConnectionEntry entry = protonProtocolManager.createOutgoingConnectionEntry(connection, saslFactory);\n+         protonRemotingConnection = (ActiveMQProtonRemotingConnection) entry.connection;\n+         connection.getChannel().pipeline().addLast(new AMQPBrokerConnectionChannelHandler(bridgesConnector.getChannelGroup(), protonRemotingConnection.getAmqpConnection().getHandler()));\n+\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            protonRemotingConnection.getAmqpConnection().open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         session = protonRemotingConnection.getAmqpConnection().getHandler().getConnection().session();\n+         sessionContext = protonRemotingConnection.getAmqpConnection().getSessionExtension(session);\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            session.open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         if (brokerConnectConfiguration.getConnectionElements() != null) {\n+            Stream<Binding> bindingStream = server.getPostOffice().getAllBindings();\n+\n+            bindingStream.forEach(binding -> {\n+               if (binding instanceof QueueBinding) {\n+                  Queue queue = ((QueueBinding) binding).getQueue();\n+                  for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+                     validateMatching(queue, connectionElement);\n+                  }\n+               }\n+            });\n+\n+            for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+               if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+                  AMQPMirrorBrokerConnectionElement replica = (AMQPMirrorBrokerConnectionElement)connectionElement;\n+                  Queue queue = server.locateQueue(replica.getSourceMirrorAddress());\n+\n+                  connectSender(queue, ProtonProtocolManager.MIRROR_ADDRESS);\n+               }\n+            }\n+         }\n+\n+         protonRemotingConnection.getAmqpConnection().flush();\n+\n+         bridgeManager.connected(connection, this);\n+      } catch (Throwable e) {\n+         error(e);\n+      }\n+   }\n+\n+   public void retryConnection() {\n+      if (bridgeManager.isStarted() && started) {\n+         if (brokerConnectConfiguration.getReconnectAttempts() < 0 || retryCounter < brokerConnectConfiguration.getReconnectAttempts()) {\n+            retryCounter++;\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnection(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"Reconnecting in \" + brokerConnectConfiguration.getRetryInterval() + \", this is the \" + retryCounter + \" of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+            reconnectFuture = scheduledExecutorService.schedule(() -> connectExecutor.execute(() -> doConnect()), brokerConnectConfiguration.getRetryInterval(), TimeUnit.MILLISECONDS);\n+         } else {\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnectionFailed(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"no more reconnections as the retry counter reached \" + retryCounter + \" out of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+         }\n+      }\n+   }\n+\n+   /** The reason this method is static is the following:\n+    *\n+    *  It is returning the snfQueue to the replica, and I needed isolation from the actual instance.\n+    *  During development I had a mistake where I used a property from the Object,\n+    *  so, I needed this isolation for my organization and making sure nothing would be shared. */\n+   private static QueueBinding installMirrorController(AMQPMirrorBrokerConnectionElement replicaConfig, ActiveMQServer server) throws Exception {\n+\n+      AddressInfo addressInfo = server.getAddressInfo(replicaConfig.getSourceMirrorAddress());\n+      if (addressInfo == null) {\n+         addressInfo = new AddressInfo(replicaConfig.getSourceMirrorAddress()).addRoutingType(RoutingType.ANYCAST).setAutoCreated(false).setTemporary(!replicaConfig.isDurable());\n+         server.addAddressInfo(addressInfo);\n+      }\n+\n+      if (addressInfo.getRoutingType() != RoutingType.ANYCAST) {\n+         throw new IllegalArgumentException(\"sourceMirrorAddress is not ANYCAST\");\n+      }\n+\n+      Queue mirrorControlQueue = server.locateQueue(replicaConfig.getSourceMirrorAddress());\n+\n+      if (mirrorControlQueue == null) {\n+         mirrorControlQueue = server.createQueue(new QueueConfiguration(replicaConfig.getSourceMirrorAddress()).setAddress(replicaConfig.getSourceMirrorAddress()).setRoutingType(RoutingType.ANYCAST).setDurable(replicaConfig.isDurable()), true);\n+      }\n+\n+      mirrorControlQueue.setMirrorController(true);\n+\n+      QueueBinding snfReplicaQueueBinding = (QueueBinding)server.getPostOffice().getBinding(replicaConfig.getSourceMirrorAddress());\n+      if (snfReplicaQueueBinding == null) {\n+         logger.warn(\"Queue does not exist even after creation! \" + replicaConfig);\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      Queue snfQueue = snfReplicaQueueBinding.getQueue();\n+\n+      if (!snfQueue.getAddress().equals(replicaConfig.getSourceMirrorAddress())) {\n+         logger.warn(\"Queue \" + snfQueue + \" belong to a different address (\" + snfQueue.getAddress() + \"), while we expected it to be \" + addressInfo.getName());\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      AMQPMirrorControllerSource newPartition = new AMQPMirrorControllerSource(snfQueue, server, replicaConfig.isMessageAcknowledgements());\n+\n+      server.scanAddresses(newPartition);\n+\n+      MirrorController currentMirrorController = server.getMirrorController();\n+\n+      if (currentMirrorController == null) {\n+         server.installMirrorController(newPartition);\n+      } else {\n+         // Replace a standard implementation by an aggregated supporting multiple targets\n+         if (currentMirrorController instanceof AMQPMirrorControllerSource) {\n+            // replacing the simple mirror control for an aggregator\n+            AMQPMirrorControllerAggregation remoteAggregation = new AMQPMirrorControllerAggregation();\n+            remoteAggregation.addPartition((AMQPMirrorControllerSource) currentMirrorController);\n+            currentMirrorController = remoteAggregation;\n+            server.installMirrorController(remoteAggregation);\n+         }\n+         ((AMQPMirrorControllerAggregation) currentMirrorController).addPartition(newPartition);\n+      }\n+\n+      return snfReplicaQueueBinding;\n+   }\n+\n+   private void connectReceiver(ActiveMQProtonRemotingConnection protonRemotingConnection,\n+                                Session session,\n+                                AMQPSessionContext sessionContext,\n+                                Queue queue,\n+                                Symbol... capabilities) {\n+      if (logger.isDebugEnabled()) {\n+         logger.debug(\"Connecting inbound for \" + queue);\n+      }\n+\n+      if (session == null) {\n+         logger.debug(\"session is null\");\n+         return;\n+      }\n+\n+      protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+\n+         if (receivers.contains(queue)) {\n+            logger.debug(\"Receiver for queue \" + queue + \" already exists, just giving up\");\n+            return;\n+         }\n+         receivers.add(queue);\n+         Receiver receiver = session.receiver(queue.getName().toString() + UUIDGenerator.getInstance().generateStringUUID());\n+         receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);\n+         receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);\n+         Target target = new Target();\n+         target.setAddress(queue.getAddress().toString());\n+         receiver.setTarget(target);\n+\n+         Source source = new Source();\n+         source.setAddress(queue.getAddress().toString());\n+         receiver.setSource(source);\n+\n+         if (capabilities != null) {\n+            source.setCapabilities(capabilities);\n+         }\n+\n+         receiver.open();\n+         protonRemotingConnection.getAmqpConnection().flush();\n+         try {\n+            sessionContext.addReceiver(receiver);\n+         } catch (Exception e) {\n+            error(e);\n+         }\n+      });\n+   }\n+\n+   private void connectSender(Queue queue,\n+                              String targetName,\n+                              Symbol... capabilities) {\n+      if (logger.isDebugEnabled()) {\n+         logger.debug(\"Connecting outbound for \" + queue);\n+      }\n+\n+\n+      if (session == null) {\n+         logger.debug(\"Session is null\");\n+         return;\n+      }\n+\n+      protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+         try {\n+            if (senders.contains(queue)) {\n+               logger.debug(\"Sender for queue \" + queue + \" already exists, just giving up\");\n+               return;\n+            }\n+            senders.add(queue);\n+            Sender sender = session.sender(targetName + UUIDGenerator.getInstance().generateStringUUID());", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}