{"pr_number": 1329, "pr_title": "HIVE-23897 : Create a common Retry Interface for replication", "pr_createdAt": "2020-07-28T12:40:02Z", "pr_url": "https://github.com/apache/hive/pull/1329", "timeline": [{"oid": "ccfc5095840a710600e6c527f6bac85cd58a0760", "url": "https://github.com/apache/hive/commit/ccfc5095840a710600e6c527f6bac85cd58a0760", "message": "HIVE-23897 : Create a common Retry Interface for replication", "committedDate": "2020-07-28T14:11:56Z", "type": "forcePushed"}, {"oid": "93cff723d1b49cd8c68c89419cf94e8fc900336e", "url": "https://github.com/apache/hive/commit/93cff723d1b49cd8c68c89419cf94e8fc900336e", "message": "HIVE-23897 : Create a common Retry Interface for replication", "committedDate": "2020-07-28T19:09:40Z", "type": "forcePushed"}, {"oid": "ffaf249c1164d524b800e11855948dd0d1da3e1c", "url": "https://github.com/apache/hive/commit/ffaf249c1164d524b800e11855948dd0d1da3e1c", "message": "HIVE-23897 : Create a common Retry Interface for replication", "committedDate": "2020-07-28T19:24:57Z", "type": "forcePushed"}, {"oid": "142e0cb28fc5e8a1a9a5db2e3850aaab2fd6c08c", "url": "https://github.com/apache/hive/commit/142e0cb28fc5e8a1a9a5db2e3850aaab2fd6c08c", "message": "HIVE-23897 : Create a common Retry Interface for replication", "committedDate": "2020-07-29T13:58:31Z", "type": "forcePushed"}, {"oid": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "url": "https://github.com/apache/hive/commit/c181c2c3426ca4f7727c270a05ed6b43d96be47b", "message": "HIVE-23897 : Create a common Retry Interface for replication", "committedDate": "2020-07-29T15:10:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjEyNTc1Mw==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462125753", "bodyText": "Default is in minutes but the comment is in second. Should we change  this?", "author": "pkumarsinha", "createdAt": "2020-07-29T08:23:36Z", "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -617,6 +617,22 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n             \"Name of the source cluster for the replication.\"),\n     REPL_TARGET_CLUSTER_NAME(\"hive.repl.target.cluster.name\", null,\n             \"Name of the target cluster for the replication.\"),\n+    REPL_RETRY_INTIAL_DELAY(\"hive.repl.retry.initial.delay\", \"60s\",\n+      new TimeValidator(TimeUnit.SECONDS),\n+      \"Initial Delay before retry starts.\"),\n+    REPL_RETRY_BACKOFF_COEFFICIENT(\"hive.repl.retry.backoff.coefficient\", 1.2f,\n+      \"The backoff coefficient for exponential retry delay between retries. \" +\n+        \"Previous Delay * Backoff Coefficient will determine the next retry interval\"),\n+    REPL_RETRY_JITTER(\"hive.repl.retry.jitter\", \"30s\", new TimeValidator(TimeUnit.SECONDS),\n+      \"A random jitter to be applied to avoid all retries happening at the same time.\"),\n+    REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES(\"hive.repl.retry.max.delay.between.retries\", \"60m\",\n+      new TimeValidator(TimeUnit.MINUTES),\n+      \"Maximum allowed retry delay in seconds after including exponential backoff. \" +", "originalCommit": "ffaf249c1164d524b800e11855948dd0d1da3e1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0MzQ1Ng==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462643456", "bodyText": "nit:can consider formatting this file", "author": "pkumarsinha", "createdAt": "2020-07-29T23:17:34Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/repl/atlas/RetryingClientTimeBased.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.repl.atlas;\n+\n+import com.sun.jersey.api.client.UniformInterfaceException;\n+import org.apache.atlas.AtlasServiceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Implement retry logic for service calls.\n+ */\n+public class RetryingClientTimeBased {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;\n+  private static final Logger LOG = LoggerFactory.getLogger(RetryingClientTimeBased.class);\n+  private static final String ERROR_MESSAGE_NO_ENTITIES = \"no entities to create/update\";\n+  private static final String ERROR_MESSAGE_IN_PROGRESS = \"import or export is in progress\";\n+  private static final String ATLAS_ERROR_CODE_IMPORT_EMPTY_ZIP = \"empty ZIP file\";\n+  protected long totalDurationInSeconds;\n+  protected long initialDelayInSeconds;\n+  protected long maxRetryDelayInSeconds;\n+  protected double backOff;\n+  protected int maxJitterInSeconds;\n+\n+  protected <T> T invokeWithRetry(Callable<T> func, T defaultReturnValue) throws Exception {\n+    long startTime = System.currentTimeMillis();\n+    long delay = this.initialDelayInSeconds;\n+    while (elapsedTimeInSeconds(startTime) + delay > this.totalDurationInSeconds) {\n+      try {\n+        LOG.debug(\"Retrying method: {}\", func.getClass().getName(), null);\n+        return func.call();\n+      } catch (Exception e) {\n+        if (processImportExportLockException(e, delay)) {\n+          //retry case. compute next sleep time\n+          delay = getNextDelay(delay);\n+          continue;\n+        }\n+        if (processInvalidParameterException(e)) {\n+          return null;\n+        }\n+        LOG.error(func.getClass().getName(), e);\n+        throw new Exception(e);\n+      }\n+    }\n+    return defaultReturnValue;\n+  }\n+\n+  private long getNextDelay(long currentDelay) {\n+    if (currentDelay <= 0) { // in case initial delay was set to 0.\n+      currentDelay = MINIMUM_DELAY_IN_SEC;\n+    }\n+", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDQ5Nw==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462650497", "bodyText": "nit:Mark it as final, will go well with naming convension", "author": "pkumarsinha", "createdAt": "2020-07-29T23:40:15Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/util/Retryable.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.util;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.utils.SecurityUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class to implement any retry logic in case of exceptions.\n+ */\n+public class Retryable {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MjM3Nw==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462652377", "bodyText": "Should this or the default(a new const.) be little higher?", "author": "pkumarsinha", "createdAt": "2020-07-29T23:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NDUzNA==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462654534", "bodyText": "e.getClass().equals(k) The exceptions classes don't have .equals() overrides so it will be reference comparison. I understand the the current usage is on Exception.class but opening up interface for any exception object will make it error prone if accidentally uses with direct exception object.", "author": "pkumarsinha", "createdAt": "2020-07-29T23:53:30Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/util/Retryable.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.util;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.utils.SecurityUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class to implement any retry logic in case of exceptions.\n+ */\n+public class Retryable {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;\n+\n+  private long totalDurationInSeconds;\n+  private List<Class<? extends Exception>> retryOn;\n+  private List<Class<? extends Exception>> failOn;\n+  private long initialDelayInSeconds;\n+  private long maxRetryDelayInSeconds;\n+  private double backOff;\n+  private int maxJitterInSeconds;\n+\n+  private Retryable() {\n+    this.retryOn = new ArrayList<>();\n+    this.failOn = new ArrayList<>();\n+    this.initialDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY), TimeUnit.SECONDS);\n+    this.maxRetryDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES), TimeUnit.SECONDS);\n+    this.backOff = HiveConf.ConfVars.REPL_RETRY_BACKOFF_COEFFICIENT.defaultFloatVal;\n+    this.maxJitterInSeconds = (int) HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_JITTER.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_JITTER), TimeUnit.SECONDS);\n+    this.totalDurationInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION), TimeUnit.SECONDS);;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  public <T> T executeCallable(Callable<T> callable) throws Exception {\n+    long startTime = System.currentTimeMillis();\n+    long delay = this.initialDelayInSeconds;\n+    Exception currentCapturedException = null;\n+    while(true) {\n+      try {\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          SecurityUtils.reloginExpiringKeytabUser();\n+          return UserGroupInformation.getLoginUser().doAs((PrivilegedExceptionAction<T>) () -> callable.call());\n+        } else {\n+          return callable.call();\n+        }\n+      } catch (Exception e) {\n+        if (this.failOn.stream().noneMatch(k -> e.getClass().equals(k))", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1Njc2Mg==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462656762", "bodyText": "nit: ( currentCapturedException and e) counterparts are (previousException, currentException) in method signature getNextDelay(). Consider changing the name, it looks a bit confusing", "author": "pkumarsinha", "createdAt": "2020-07-30T00:00:53Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/util/Retryable.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.util;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.utils.SecurityUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class to implement any retry logic in case of exceptions.\n+ */\n+public class Retryable {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;\n+\n+  private long totalDurationInSeconds;\n+  private List<Class<? extends Exception>> retryOn;\n+  private List<Class<? extends Exception>> failOn;\n+  private long initialDelayInSeconds;\n+  private long maxRetryDelayInSeconds;\n+  private double backOff;\n+  private int maxJitterInSeconds;\n+\n+  private Retryable() {\n+    this.retryOn = new ArrayList<>();\n+    this.failOn = new ArrayList<>();\n+    this.initialDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY), TimeUnit.SECONDS);\n+    this.maxRetryDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES), TimeUnit.SECONDS);\n+    this.backOff = HiveConf.ConfVars.REPL_RETRY_BACKOFF_COEFFICIENT.defaultFloatVal;\n+    this.maxJitterInSeconds = (int) HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_JITTER.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_JITTER), TimeUnit.SECONDS);\n+    this.totalDurationInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION), TimeUnit.SECONDS);;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  public <T> T executeCallable(Callable<T> callable) throws Exception {\n+    long startTime = System.currentTimeMillis();\n+    long delay = this.initialDelayInSeconds;\n+    Exception currentCapturedException = null;\n+    while(true) {\n+      try {\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          SecurityUtils.reloginExpiringKeytabUser();\n+          return UserGroupInformation.getLoginUser().doAs((PrivilegedExceptionAction<T>) () -> callable.call());\n+        } else {\n+          return callable.call();\n+        }\n+      } catch (Exception e) {\n+        if (this.failOn.stream().noneMatch(k -> e.getClass().equals(k))\n+          && this.retryOn.stream().anyMatch(k -> e.getClass().isAssignableFrom(k))) {\n+          if (elapsedTimeInSeconds(startTime) + delay > this.totalDurationInSeconds) {\n+            // case where waiting would go beyond max duration. So throw exception and return\n+            throw e;\n+          }\n+          sleep(delay);\n+          //retry case. compute next sleep time\n+          delay = getNextDelay(delay, currentCapturedException, e);", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1NzE1Ng==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462657156", "bodyText": "Consider changing the .equals comparison here as well.", "author": "pkumarsinha", "createdAt": "2020-07-30T00:02:12Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/util/Retryable.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.util;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.utils.SecurityUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class to implement any retry logic in case of exceptions.\n+ */\n+public class Retryable {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;\n+\n+  private long totalDurationInSeconds;\n+  private List<Class<? extends Exception>> retryOn;\n+  private List<Class<? extends Exception>> failOn;\n+  private long initialDelayInSeconds;\n+  private long maxRetryDelayInSeconds;\n+  private double backOff;\n+  private int maxJitterInSeconds;\n+\n+  private Retryable() {\n+    this.retryOn = new ArrayList<>();\n+    this.failOn = new ArrayList<>();\n+    this.initialDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY), TimeUnit.SECONDS);\n+    this.maxRetryDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES), TimeUnit.SECONDS);\n+    this.backOff = HiveConf.ConfVars.REPL_RETRY_BACKOFF_COEFFICIENT.defaultFloatVal;\n+    this.maxJitterInSeconds = (int) HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_JITTER.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_JITTER), TimeUnit.SECONDS);\n+    this.totalDurationInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION), TimeUnit.SECONDS);;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  public <T> T executeCallable(Callable<T> callable) throws Exception {\n+    long startTime = System.currentTimeMillis();\n+    long delay = this.initialDelayInSeconds;\n+    Exception currentCapturedException = null;\n+    while(true) {\n+      try {\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          SecurityUtils.reloginExpiringKeytabUser();\n+          return UserGroupInformation.getLoginUser().doAs((PrivilegedExceptionAction<T>) () -> callable.call());\n+        } else {\n+          return callable.call();\n+        }\n+      } catch (Exception e) {\n+        if (this.failOn.stream().noneMatch(k -> e.getClass().equals(k))\n+          && this.retryOn.stream().anyMatch(k -> e.getClass().isAssignableFrom(k))) {\n+          if (elapsedTimeInSeconds(startTime) + delay > this.totalDurationInSeconds) {\n+            // case where waiting would go beyond max duration. So throw exception and return\n+            throw e;\n+          }\n+          sleep(delay);\n+          //retry case. compute next sleep time\n+          delay = getNextDelay(delay, currentCapturedException, e);\n+          // reset current captured exception.\n+          currentCapturedException = e;\n+        } else {\n+          // Exception cannot be retried on. Throw exception and return\n+          throw e;\n+        }\n+      }\n+    }\n+  }\n+\n+  private void sleep(long seconds) {\n+    try {\n+      Thread.sleep(seconds * 1000);\n+    } catch (InterruptedException e) {\n+      // no-op.. just proceed\n+    }\n+  }\n+\n+  private long getNextDelay(long currentDelay, final Exception previousException, final Exception currentException) {\n+    if (previousException != null && !previousException.getClass().equals(currentException.getClass())) {", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1Nzc4OQ==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462657789", "bodyText": "Format the class", "author": "pkumarsinha", "createdAt": "2020-07-30T00:04:32Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/util/Retryable.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.util;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.utils.SecurityUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class to implement any retry logic in case of exceptions.\n+ */\n+public class Retryable {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;\n+\n+  private long totalDurationInSeconds;\n+  private List<Class<? extends Exception>> retryOn;\n+  private List<Class<? extends Exception>> failOn;\n+  private long initialDelayInSeconds;\n+  private long maxRetryDelayInSeconds;\n+  private double backOff;\n+  private int maxJitterInSeconds;\n+\n+  private Retryable() {\n+    this.retryOn = new ArrayList<>();\n+    this.failOn = new ArrayList<>();\n+    this.initialDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY), TimeUnit.SECONDS);", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY5NzU1Mg==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462697552", "bodyText": "Didn't get this comment.", "author": "aasha", "createdAt": "2020-07-30T02:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1Nzc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MTAwMQ==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462661001", "bodyText": "Do we really  need it synchronized as the build process is single thread operation, no?", "author": "pkumarsinha", "createdAt": "2020-07-30T00:15:36Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/util/Retryable.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.util;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.utils.SecurityUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class to implement any retry logic in case of exceptions.\n+ */\n+public class Retryable {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;\n+\n+  private long totalDurationInSeconds;\n+  private List<Class<? extends Exception>> retryOn;\n+  private List<Class<? extends Exception>> failOn;\n+  private long initialDelayInSeconds;\n+  private long maxRetryDelayInSeconds;\n+  private double backOff;\n+  private int maxJitterInSeconds;\n+\n+  private Retryable() {\n+    this.retryOn = new ArrayList<>();\n+    this.failOn = new ArrayList<>();\n+    this.initialDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY), TimeUnit.SECONDS);\n+    this.maxRetryDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES), TimeUnit.SECONDS);\n+    this.backOff = HiveConf.ConfVars.REPL_RETRY_BACKOFF_COEFFICIENT.defaultFloatVal;\n+    this.maxJitterInSeconds = (int) HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_JITTER.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_JITTER), TimeUnit.SECONDS);\n+    this.totalDurationInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION), TimeUnit.SECONDS);;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  public <T> T executeCallable(Callable<T> callable) throws Exception {\n+    long startTime = System.currentTimeMillis();\n+    long delay = this.initialDelayInSeconds;\n+    Exception currentCapturedException = null;\n+    while(true) {\n+      try {\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          SecurityUtils.reloginExpiringKeytabUser();\n+          return UserGroupInformation.getLoginUser().doAs((PrivilegedExceptionAction<T>) () -> callable.call());\n+        } else {\n+          return callable.call();\n+        }\n+      } catch (Exception e) {\n+        if (this.failOn.stream().noneMatch(k -> e.getClass().equals(k))\n+          && this.retryOn.stream().anyMatch(k -> e.getClass().isAssignableFrom(k))) {\n+          if (elapsedTimeInSeconds(startTime) + delay > this.totalDurationInSeconds) {\n+            // case where waiting would go beyond max duration. So throw exception and return\n+            throw e;\n+          }\n+          sleep(delay);\n+          //retry case. compute next sleep time\n+          delay = getNextDelay(delay, currentCapturedException, e);\n+          // reset current captured exception.\n+          currentCapturedException = e;\n+        } else {\n+          // Exception cannot be retried on. Throw exception and return\n+          throw e;\n+        }\n+      }\n+    }\n+  }\n+\n+  private void sleep(long seconds) {\n+    try {\n+      Thread.sleep(seconds * 1000);\n+    } catch (InterruptedException e) {\n+      // no-op.. just proceed\n+    }\n+  }\n+\n+  private long getNextDelay(long currentDelay, final Exception previousException, final Exception currentException) {\n+    if (previousException != null && !previousException.getClass().equals(currentException.getClass())) {\n+      // New exception encountered. Returning initial delay for next retry.\n+      return this.initialDelayInSeconds;\n+    }\n+\n+    if (currentDelay <= 0) { // in case initial delay was set to 0.\n+      currentDelay = MINIMUM_DELAY_IN_SEC;\n+    }\n+\n+    currentDelay *= this.backOff;\n+    if (this.maxJitterInSeconds > 0) {\n+      currentDelay += new Random().nextInt(this.maxJitterInSeconds);\n+    }\n+\n+    if (currentDelay > this.maxRetryDelayInSeconds) {\n+      currentDelay = this.maxRetryDelayInSeconds;\n+    }\n+\n+    return  currentDelay;\n+  }\n+\n+  private long elapsedTimeInSeconds(long fromTimeMillis) {\n+    return (System.currentTimeMillis() - fromTimeMillis)/ 1000;\n+  }\n+\n+  public static class Builder {\n+    private final Retryable runnable = new Retryable();\n+    public Builder() {\n+    }\n+\n+    public Builder withHiveConf(HiveConf conf) {\n+      runnable.totalDurationInSeconds = conf.getTimeVar(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION, TimeUnit.SECONDS);\n+      runnable.initialDelayInSeconds = conf.getTimeVar(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY, TimeUnit.SECONDS);\n+      runnable.maxRetryDelayInSeconds = conf.getTimeVar(HiveConf.ConfVars\n+        .REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES, TimeUnit.SECONDS);\n+      runnable.backOff = conf.getFloatVar(HiveConf.ConfVars.REPL_RETRY_BACKOFF_COEFFICIENT);\n+      runnable.maxJitterInSeconds = (int) conf.getTimeVar(HiveConf.ConfVars.REPL_RETRY_JITTER, TimeUnit.SECONDS);\n+      return this;\n+    }\n+\n+    public Retryable build() {\n+      return runnable;\n+    }\n+\n+    public Builder withTotalDuration(long maxDuration) {\n+      runnable.totalDurationInSeconds = maxDuration;\n+      return this;\n+    }\n+\n+    // making this thread safe as it appends to list", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNTY4NQ==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462835685", "bodyText": "If we use a common retryable it can be used in a multi threaded way as well. Right now we are not using it but keeping it synchronized will keep it thread safe and allow case where you create retryable once and pass the common retry params and then call excute from different places.", "author": "aasha", "createdAt": "2020-07-30T08:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MTAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY2MTU4Mw==", "url": "https://github.com/apache/hive/pull/1329#discussion_r462661583", "bodyText": "Why not to use similar name like withFailOnExceptionList ?", "author": "pkumarsinha", "createdAt": "2020-07-30T00:17:57Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/util/Retryable.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.util;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.utils.SecurityUtils;\n+import org.apache.hadoop.security.UserGroupInformation;\n+\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Class to implement any retry logic in case of exceptions.\n+ */\n+public class Retryable {\n+  private static long MINIMUM_DELAY_IN_SEC = 1;\n+\n+  private long totalDurationInSeconds;\n+  private List<Class<? extends Exception>> retryOn;\n+  private List<Class<? extends Exception>> failOn;\n+  private long initialDelayInSeconds;\n+  private long maxRetryDelayInSeconds;\n+  private double backOff;\n+  private int maxJitterInSeconds;\n+\n+  private Retryable() {\n+    this.retryOn = new ArrayList<>();\n+    this.failOn = new ArrayList<>();\n+    this.initialDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY), TimeUnit.SECONDS);\n+    this.maxRetryDelayInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES), TimeUnit.SECONDS);\n+    this.backOff = HiveConf.ConfVars.REPL_RETRY_BACKOFF_COEFFICIENT.defaultFloatVal;\n+    this.maxJitterInSeconds = (int) HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_JITTER.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_JITTER), TimeUnit.SECONDS);\n+    this.totalDurationInSeconds = HiveConf.toTime(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION.defaultStrVal,\n+      HiveConf.getDefaultTimeUnit(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION), TimeUnit.SECONDS);;\n+  }\n+\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n+\n+  public <T> T executeCallable(Callable<T> callable) throws Exception {\n+    long startTime = System.currentTimeMillis();\n+    long delay = this.initialDelayInSeconds;\n+    Exception currentCapturedException = null;\n+    while(true) {\n+      try {\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          SecurityUtils.reloginExpiringKeytabUser();\n+          return UserGroupInformation.getLoginUser().doAs((PrivilegedExceptionAction<T>) () -> callable.call());\n+        } else {\n+          return callable.call();\n+        }\n+      } catch (Exception e) {\n+        if (this.failOn.stream().noneMatch(k -> e.getClass().equals(k))\n+          && this.retryOn.stream().anyMatch(k -> e.getClass().isAssignableFrom(k))) {\n+          if (elapsedTimeInSeconds(startTime) + delay > this.totalDurationInSeconds) {\n+            // case where waiting would go beyond max duration. So throw exception and return\n+            throw e;\n+          }\n+          sleep(delay);\n+          //retry case. compute next sleep time\n+          delay = getNextDelay(delay, currentCapturedException, e);\n+          // reset current captured exception.\n+          currentCapturedException = e;\n+        } else {\n+          // Exception cannot be retried on. Throw exception and return\n+          throw e;\n+        }\n+      }\n+    }\n+  }\n+\n+  private void sleep(long seconds) {\n+    try {\n+      Thread.sleep(seconds * 1000);\n+    } catch (InterruptedException e) {\n+      // no-op.. just proceed\n+    }\n+  }\n+\n+  private long getNextDelay(long currentDelay, final Exception previousException, final Exception currentException) {\n+    if (previousException != null && !previousException.getClass().equals(currentException.getClass())) {\n+      // New exception encountered. Returning initial delay for next retry.\n+      return this.initialDelayInSeconds;\n+    }\n+\n+    if (currentDelay <= 0) { // in case initial delay was set to 0.\n+      currentDelay = MINIMUM_DELAY_IN_SEC;\n+    }\n+\n+    currentDelay *= this.backOff;\n+    if (this.maxJitterInSeconds > 0) {\n+      currentDelay += new Random().nextInt(this.maxJitterInSeconds);\n+    }\n+\n+    if (currentDelay > this.maxRetryDelayInSeconds) {\n+      currentDelay = this.maxRetryDelayInSeconds;\n+    }\n+\n+    return  currentDelay;\n+  }\n+\n+  private long elapsedTimeInSeconds(long fromTimeMillis) {\n+    return (System.currentTimeMillis() - fromTimeMillis)/ 1000;\n+  }\n+\n+  public static class Builder {\n+    private final Retryable runnable = new Retryable();\n+    public Builder() {\n+    }\n+\n+    public Builder withHiveConf(HiveConf conf) {\n+      runnable.totalDurationInSeconds = conf.getTimeVar(HiveConf.ConfVars.REPL_RETRY_TOTAL_DURATION, TimeUnit.SECONDS);\n+      runnable.initialDelayInSeconds = conf.getTimeVar(HiveConf.ConfVars.REPL_RETRY_INTIAL_DELAY, TimeUnit.SECONDS);\n+      runnable.maxRetryDelayInSeconds = conf.getTimeVar(HiveConf.ConfVars\n+        .REPL_RETRY_MAX_DELAY_BETWEEN_RETRIES, TimeUnit.SECONDS);\n+      runnable.backOff = conf.getFloatVar(HiveConf.ConfVars.REPL_RETRY_BACKOFF_COEFFICIENT);\n+      runnable.maxJitterInSeconds = (int) conf.getTimeVar(HiveConf.ConfVars.REPL_RETRY_JITTER, TimeUnit.SECONDS);\n+      return this;\n+    }\n+\n+    public Retryable build() {\n+      return runnable;\n+    }\n+\n+    public Builder withTotalDuration(long maxDuration) {\n+      runnable.totalDurationInSeconds = maxDuration;\n+      return this;\n+    }\n+\n+    // making this thread safe as it appends to list\n+    public synchronized Builder withRetryOnException(final Class<? extends Exception> exceptionClass) {\n+      if (exceptionClass != null &&\n+        runnable.retryOn.stream().noneMatch(k -> exceptionClass.equals(k))) {\n+        runnable.retryOn.add(exceptionClass);\n+      }\n+      return this;\n+    }\n+\n+    public synchronized Builder withRetryOnExceptionList(final List<Class<? extends Exception>> exceptionClassList) {\n+      for (final Class<? extends Exception> exceptionClass : exceptionClassList) {\n+        if (exceptionClass != null &&\n+          runnable.retryOn.stream().noneMatch(k -> exceptionClass.equals(k))) {\n+          runnable.retryOn.add(exceptionClass);\n+        }\n+      }\n+      return this;\n+    }\n+\n+    public synchronized Builder withFailOnException(final Class<? extends Exception> exceptionClass) {\n+      if (exceptionClass != null &&\n+        runnable.failOn.stream().noneMatch(k -> exceptionClass.equals(k))) {\n+        runnable.failOn.add(exceptionClass);\n+      }\n+      return this;\n+    }\n+\n+    public synchronized Builder withDontRetryOnExceptionList(final List<Class<?", "originalCommit": "c181c2c3426ca4f7727c270a05ed6b43d96be47b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "375dc7295158506c17b64549aa9cc70f345ef728", "url": "https://github.com/apache/hive/commit/375dc7295158506c17b64549aa9cc70f345ef728", "message": "HIVE-23897 : Create a common Retry Interface for replication", "committedDate": "2020-07-30T05:26:22Z", "type": "commit"}, {"oid": "375dc7295158506c17b64549aa9cc70f345ef728", "url": "https://github.com/apache/hive/commit/375dc7295158506c17b64549aa9cc70f345ef728", "message": "HIVE-23897 : Create a common Retry Interface for replication", "committedDate": "2020-07-30T05:26:22Z", "type": "forcePushed"}]}