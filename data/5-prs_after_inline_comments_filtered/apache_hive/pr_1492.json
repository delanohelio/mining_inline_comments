{"pr_number": 1492, "pr_title": "HIVE-24154: Missing simplification opportunity with IN and EQUALS cla\u2026", "pr_createdAt": "2020-09-13T01:24:38Z", "pr_url": "https://github.com/apache/hive/pull/1492", "timeline": [{"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d", "url": "https://github.com/apache/hive/commit/a406f104dbc929ea7f092198bf3be68a48744c6d", "message": "HIVE-24154: Missing simplification opportunity with IN and EQUALS clauses", "committedDate": "2020-09-13T05:48:47Z", "type": "commit"}, {"oid": "a406f104dbc929ea7f092198bf3be68a48744c6d", "url": "https://github.com/apache/hive/commit/a406f104dbc929ea7f092198bf3be68a48744c6d", "message": "HIVE-24154: Missing simplification opportunity with IN and EQUALS clauses", "committedDate": "2020-09-13T05:48:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMDgyMw==", "url": "https://github.com/apache/hive/pull/1492#discussion_r487510823", "bodyText": "oh my; Constrain had it's constructor arguments swapped! what a typo!", "author": "kgyrtkirk", "createdAt": "2020-09-13T10:23:03Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -599,7 +587,7 @@ public ConstraintGroup(RexNode rexNode) {\n           if (constraint == null) {\n             throw new SemanticException(\"Unable to find constraint which was earlier added.\");\n           }\n-          ret.add(constraint.exprNode);\n+          ret.add(constraint.constNode);", "originalCommit": "a406f104dbc929ea7f092198bf3be68a48744c6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0NTE5Mw==", "url": "https://github.com/apache/hive/pull/1492#discussion_r487545193", "bodyText": "I was also surprised we did not catch it before! But that's OK, it was working as expected and now they are swapped back!", "author": "jcamachor", "createdAt": "2020-09-13T15:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMDgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTIzMw==", "url": "https://github.com/apache/hive/pull/1492#discussion_r487511233", "bodyText": "note: we have RexNode-s are comparable; this string2expr stuff is not neccessarily needed anymore", "author": "kgyrtkirk", "createdAt": "2020-09-13T10:27:02Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -734,6 +721,30 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n               }\n               operands.remove(i);\n               --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              String ref = c.exprNode.toString();\n+              stringToExpr.put(ref, c.exprNode);\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                String expr = c.constNode.toString();\n+                stringToExpr.put(expr, c.constNode);", "originalCommit": "a406f104dbc929ea7f092198bf3be68a48744c6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU0NjcxNg==", "url": "https://github.com/apache/hive/pull/1492#discussion_r487546716", "bodyText": "Makes sense, I will simplify this code.", "author": "jcamachor", "createdAt": "2020-09-13T16:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUxMTIzMw=="}], "type": "inlineReview"}, {"oid": "db4dfda745b761bbb103eed87f2e7680f454b234", "url": "https://github.com/apache/hive/commit/db4dfda745b761bbb103eed87f2e7680f454b234", "message": "q file updates", "committedDate": "2020-09-13T16:34:25Z", "type": "commit"}, {"oid": "5a0e9aca03d96186a54cbd2edaa15df37f8701b7", "url": "https://github.com/apache/hive/commit/5a0e9aca03d96186a54cbd2edaa15df37f8701b7", "message": "removing string-based mapping", "committedDate": "2020-09-13T16:45:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2NjA2Ng==", "url": "https://github.com/apache/hive/pull/1492#discussion_r488766066", "bodyText": "I think this may not neccessarily false; consider:\nx=1 and x=2\n\nwhich is not true; but in case x is null - the result of the AND will be null\ninstead of false this could be only rewritten to x is null and null; but even in that case there could be other stuff which might affect null/false;\nso I think we may not do a return here.", "author": "kgyrtkirk", "createdAt": "2020-09-15T15:36:54Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -727,44 +708,58 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n                 }\n               } else {\n                 for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  String expr = inCall.getOperands().get(j).toString();\n-                  inLHSExprToRHSExprs.put(ref, expr);\n-                  stringToExpr.put(expr, inCall.getOperands().get(j));\n+                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+                }\n+              }\n+              operands.remove(i);\n+              --i;\n+            } else if (operand.getKind() == SqlKind.EQUALS) {\n+              Constraint c = Constraint.of(operand);\n+              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+                continue;\n+              }\n+              RexNode ref = c.exprNode;\n+              if (inLHSExprToRHSExprs.containsKey(ref)) {\n+                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n+                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+                  // Note that Multimap does not keep a key if all its values are removed.\n+                  // Hence, since there are no common expressions and it is within an AND,\n+                  // we should return false\n+                  return rexBuilder.makeLiteral(false);", "originalCommit": "5a0e9aca03d96186a54cbd2edaa15df37f8701b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NDE3Mg==", "url": "https://github.com/apache/hive/pull/1492#discussion_r488774172", "bodyText": "Good catch. It seems the problem was already there though. I am revisiting this logic.", "author": "jcamachor", "createdAt": "2020-09-15T15:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2NjA2Ng=="}], "type": "inlineReview"}, {"oid": "e206afc08bb0845333a8088a8a4223ae32bdfc60", "url": "https://github.com/apache/hive/commit/e206afc08bb0845333a8088a8a4223ae32bdfc60", "message": "addressing review comment : nullability", "committedDate": "2020-09-15T18:36:32Z", "type": "commit"}, {"oid": "beeefbfccd764e22e146b95baadf966e708f1d0d", "url": "https://github.com/apache/hive/commit/beeefbfccd764e22e146b95baadf966e708f1d0d", "message": "Revert \"addressing review comment : nullability\"\n\nThis reverts commit e206afc08bb0845333a8088a8a4223ae32bdfc60.", "committedDate": "2020-09-15T19:07:19Z", "type": "commit"}, {"oid": "a2e443e4e0b686bc2fe0f164f84d8863300ac33e", "url": "https://github.com/apache/hive/commit/a2e443e4e0b686bc2fe0f164f84d8863300ac33e", "message": "addressing review comment : nullability", "committedDate": "2020-09-15T19:59:21Z", "type": "commit"}, {"oid": "db45b1d73397dea3699811bb43f7083486241be7", "url": "https://github.com/apache/hive/commit/db45b1d73397dea3699811bb43f7083486241be7", "message": "Merge remote-tracking branch 'apache/master' into HIVE-24154", "committedDate": "2020-09-15T20:15:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMjQ0OQ==", "url": "https://github.com/apache/hive/pull/1492#discussion_r489412449", "bodyText": "I believe this would not need to be a CASE it could be an AND as well\n(x IS NULL OR y IS NULL) AND null\n\nbut I know - it won't make much difference - the CASE might be more readbale :)", "author": "kgyrtkirk", "createdAt": "2020-09-16T12:53:08Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {\n+        // We handle possible null values in the expressions.\n+        List<RexNode> nullableExprs =\n+            inLHSExprToRHSNullableExprs.get(ref)\n+                .stream()\n+                .map(n -> rexBuilder.makeCall(SqlStdOperatorTable.IS_NULL, ImmutableList.of(n)))\n+                .collect(Collectors.toList());\n+        return rexBuilder.makeCall(SqlStdOperatorTable.CASE,", "originalCommit": "db45b1d73397dea3699811bb43f7083486241be7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMzU4Mg==", "url": "https://github.com/apache/hive/pull/1492#discussion_r489413582", "bodyText": "at this point - aren't we in the middle of processing all the operands of the AND?\nx IN (1,2) AND x IN (3,4) AND y IN (1,2)\n\nI suspect for the above expression we don't know anything about y (yet) - isn't that a problem?", "author": "kgyrtkirk", "createdAt": "2020-09-16T12:54:56Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);", "originalCommit": "db45b1d73397dea3699811bb43f7083486241be7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg==", "url": "https://github.com/apache/hive/pull/1492#discussion_r489419982", "bodyText": "right now I don't fully agree with this logic - if we have an expression like:\nx IN (1,2) AND x in (3,4) and y IN (5,6)\n\nit's clear that we may only return false or null; but I think we may still need to choose false based on the other expressions; for the above:\n\nwhen x is null, y=5 then the result will be null\nbut when x is null, y=1 then the result will be false\n\nin light of this reasoning it seem to me that this starts looking more and more sophisticated....\nI think it might worth a try to see if these \"early-return-type\" simplifications kick-in a lot or not - and as an alternative approach consider removing them instead of saving them.\nI think at some point we should run the simplification earlier when the ORs are still open - so that it could analyze-it properly", "author": "kgyrtkirk", "createdAt": "2020-09-16T13:04:27Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -678,100 +679,135 @@ private RexNode useStructIfNeeded(List<? extends RexNode> columns) {\n     }\n \n     @Override public RexNode visitCall(RexCall call) {\n-      final RexNode node;\n-      final List<RexNode> operands;\n-      final List<RexNode> newOperands;\n-      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n       switch (call.getKind()) {\n         case AND:\n-          // IN clauses need to be combined by keeping only common elements\n-          operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                Set<RexNode> expressions = Sets.newHashSet();\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  expressions.add(inCall.getOperands().get(j));\n-                }\n-                inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                  inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-                }\n-              }\n-              operands.remove(i);\n-              --i;\n-            } else if (operand.getKind() == SqlKind.EQUALS) {\n-              Constraint c = Constraint.of(operand);\n-              if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n-                continue;\n+          return handleAND(rexBuilder, call);\n+        case OR:\n+          return handleOR(rexBuilder, call);\n+        default:\n+          return super.visitCall(call);\n+      }\n+    }\n+\n+    private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping only common elements\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      // We will use this set to keep those expressions that may evaluate\n+      // into a null value.\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSNullableExprs = LinkedHashMultimap.create();\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenAnd(call.getOperands()));\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          if (ref.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(ref, ref);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(ref)) {\n+            Set<RexNode> expressions = Sets.newHashSet();\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              expressions.add(constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              RexNode ref = c.exprNode;\n-              if (inLHSExprToRHSExprs.containsKey(ref)) {\n-                inLHSExprToRHSExprs.get(ref).retainAll(Collections.singleton(c.constNode));\n-                if (!inLHSExprToRHSExprs.containsKey(ref)) {\n-                  // Note that Multimap does not keep a key if all its values are removed.\n-                  // Hence, since there are no common expressions and it is within an AND,\n-                  // we should return false\n-                  return rexBuilder.makeLiteral(false);\n-                }\n-              } else {\n-                inLHSExprToRHSExprs.put(ref, c.constNode);\n+            }\n+            inLHSExprToRHSExprs.get(ref).retainAll(expressions);\n+            if (!inLHSExprToRHSExprs.containsKey(ref)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, ref, inLHSExprToRHSNullableExprs);\n+            }\n+          } else {\n+            for (int j = 1; j < inCall.getOperands().size(); j++) {\n+              RexNode constNode = inCall.getOperands().get(j);\n+              inLHSExprToRHSExprs.put(ref, constNode);\n+              if (constNode.getType().isNullable()) {\n+                inLHSExprToRHSNullableExprs.put(ref, constNode);\n               }\n-              operands.remove(i);\n-              --i;\n             }\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n-          break;\n-        case OR:\n-          // IN clauses need to be combined by keeping all elements\n-          operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n-          for (int i = 0; i < operands.size(); i++) {\n-            RexNode operand = operands.get(i);\n-            if (operand.getKind() == SqlKind.IN) {\n-              RexCall inCall = (RexCall) operand;\n-              if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n-                continue;\n-              }\n-              RexNode ref = inCall.getOperands().get(0);\n-              for (int j = 1; j < inCall.getOperands().size(); j++) {\n-                inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n-              }\n-              operands.remove(i);\n-              --i;\n+          operands.remove(i);\n+          --i;\n+        } else if (operand.getKind() == SqlKind.EQUALS) {\n+          Constraint c = Constraint.of(operand);\n+          if (c == null || !HiveCalciteUtil.isDeterministic(c.exprNode)) {\n+            continue;\n+          }\n+          if (c.exprNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.exprNode);\n+          }\n+          if (c.constNode.getType().isNullable()) {\n+            inLHSExprToRHSNullableExprs.put(c.exprNode, c.constNode);\n+          }\n+          if (inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+            inLHSExprToRHSExprs.get(c.exprNode).retainAll(Collections.singleton(c.constNode));\n+            if (!inLHSExprToRHSExprs.containsKey(c.exprNode)) {\n+              // Note that Multimap does not keep a key if all its values are removed.\n+              return createResultFromEmptySet(rexBuilder, c.exprNode, inLHSExprToRHSNullableExprs);\n             }\n+          } else {\n+            inLHSExprToRHSExprs.put(c.exprNode, c.constNode);\n           }\n-          // Create IN clauses\n-          newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n-          newOperands.addAll(operands);\n-          // Return node\n-          node = RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n-          break;\n-        default:\n-          return super.visitCall(call);\n+          operands.remove(i);\n+          --i;\n+        }\n       }\n-      return node;\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode handleOR(RexBuilder rexBuilder, RexCall call) {\n+      // IN clauses need to be combined by keeping all elements\n+      final List<RexNode> operands = new ArrayList<>(RexUtil.flattenOr(call.getOperands()));\n+      final Multimap<RexNode,RexNode> inLHSExprToRHSExprs = LinkedHashMultimap.create();\n+      for (int i = 0; i < operands.size(); i++) {\n+        RexNode operand = operands.get(i);\n+        if (operand.getKind() == SqlKind.IN) {\n+          RexCall inCall = (RexCall) operand;\n+          if (!HiveCalciteUtil.isDeterministic(inCall.getOperands().get(0))) {\n+            continue;\n+          }\n+          RexNode ref = inCall.getOperands().get(0);\n+          for (int j = 1; j < inCall.getOperands().size(); j++) {\n+            inLHSExprToRHSExprs.put(ref, inCall.getOperands().get(j));\n+          }\n+          operands.remove(i);\n+          --i;\n+        }\n+      }\n+      // Create IN clauses\n+      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      newOperands.addAll(operands);\n+      // Return node\n+      return RexUtil.composeDisjunction(rexBuilder, newOperands, false);\n+    }\n+\n+    private static RexNode createResultFromEmptySet(RexBuilder rexBuilder,\n+        RexNode ref, Multimap<RexNode, RexNode> inLHSExprToRHSNullableExprs) {\n+      if (inLHSExprToRHSNullableExprs.containsKey(ref)) {", "originalCommit": "db45b1d73397dea3699811bb43f7083486241be7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUwMTIwNg==", "url": "https://github.com/apache/hive/pull/1492#discussion_r489501206", "bodyText": "I agree. Isn't enough to move the logic to deal with the empty case to the end, instead of doing early bail out? I think that would fix the issue. I need to deal with the empty case in some way.\nI prefer to avoid moving the rule at this stage and keep the change focused within the rule. Otherwise, we may have to deal with closing and re-opening, plus the fix seems more risky (including backporting).", "author": "jcamachor", "createdAt": "2020-09-16T14:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4MTY2Mg==", "url": "https://github.com/apache/hive/pull/1492#discussion_r489581662", "bodyText": "isn't enough to move the logic to deal with the empty case to the end\n\nof course - that could work as well! I just wanted to suggest that in case there is no \"big benefit\" keeping it - we may remove it as well - it contained correctness issues before this patch :)\n\nI prefer to avoid moving the rule at this stage and keep the change focused within the rule.\n\nI only wanted to note that we should do that sometime later on", "author": "kgyrtkirk", "createdAt": "2020-09-16T16:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTcxODk1MQ==", "url": "https://github.com/apache/hive/pull/1492#discussion_r489718951", "bodyText": "@kgyrtkirk I pushed a new commit and added a few more test cases.", "author": "jcamachor", "createdAt": "2020-09-16T19:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxOTk4Mg=="}], "type": "inlineReview"}, {"oid": "b140c78d5a5a08aea2f198af546ac961a9c470f6", "url": "https://github.com/apache/hive/commit/b140c78d5a5a08aea2f198af546ac961a9c470f6", "message": "Merge remote-tracking branch 'apache/master' into HIVE-24154", "committedDate": "2020-09-16T14:53:53Z", "type": "commit"}, {"oid": "193fb77a8d425c68e5e4c8848fcaf68f9bb863f6", "url": "https://github.com/apache/hive/commit/193fb77a8d425c68e5e4c8848fcaf68f9bb863f6", "message": "addressing latest comments", "committedDate": "2020-09-16T19:50:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0MzEzNw==", "url": "https://github.com/apache/hive/pull/1492#discussion_r495843137", "bodyText": "Is there any particular reason why do we need this? (I think it was not needed before)\nI believe this will at most only add a cast to wieden nullability", "author": "kgyrtkirk", "createdAt": "2020-09-28T10:34:06Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HivePointLookupOptimizerRule.java", "diffHunk": "@@ -757,10 +752,15 @@ private static RexNode handleAND(RexBuilder rexBuilder, RexCall call) {\n         }\n       }\n       // Create IN clauses\n-      final List<RexNode> newOperands = createInClauses(rexBuilder, inLHSExprToRHSExprs);\n+      final List<RexNode> newOperands = createInClauses(rexBuilder,\n+          visitedRefs, inLHSExprToRHSExprs, inLHSExprToRHSNullableExprs);\n       newOperands.addAll(operands);\n       // Return node\n-      return RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      RexNode result = RexUtil.composeConjunction(rexBuilder, newOperands, false);\n+      if (!result.getType().equals(call.getType())) {", "originalCommit": "193fb77a8d425c68e5e4c8848fcaf68f9bb863f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMjE1Mg==", "url": "https://github.com/apache/hive/pull/1492#discussion_r496112152", "bodyText": "Once again, good catch. This compensation was coming from a previous version of the patch :( I have pushed a new commit.", "author": "jcamachor", "createdAt": "2020-09-28T17:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg0MzEzNw=="}], "type": "inlineReview"}, {"oid": "8c20fb1edb1f4ffc34249b263c02ed1cc9f78110", "url": "https://github.com/apache/hive/commit/8c20fb1edb1f4ffc34249b263c02ed1cc9f78110", "message": "remove simplification", "committedDate": "2020-09-28T17:18:39Z", "type": "commit"}]}