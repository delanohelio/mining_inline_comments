{"pr_number": 1706, "pr_title": "HIVE-24274: Implement Query Text based MaterializedView rewrite", "pr_createdAt": "2020-11-25T12:22:26Z", "pr_url": "https://github.com/apache/hive/pull/1706", "timeline": [{"oid": "88c0fd6a967a84278c13ac5e0c915d9ada238688", "url": "https://github.com/apache/hive/commit/88c0fd6a967a84278c13ac5e0c915d9ada238688", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite", "committedDate": "2020-11-30T09:50:22Z", "type": "forcePushed"}, {"oid": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "url": "https://github.com/apache/hive/commit/f2bd4979366380a4f7fd799a8933860eb0426ccc", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite", "committedDate": "2020-12-08T07:14:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTkxMA==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539721910", "bodyText": "Let's make it shorter: hive.materializedview.rewriting.query.text -> hive.materializedview.rewriting.text or hive.materializedview.rewriting.sql ?", "author": "jcamachor", "createdAt": "2020-12-09T23:20:54Z", "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -1844,6 +1844,9 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n     // materialized views\n     HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING(\"hive.materializedview.rewriting\", true,\n         \"Whether to try to rewrite queries using the materialized views enabled for rewriting\"),\n+    HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT(\"hive.materializedview.rewriting.query.text\", true,", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkyNTA1Nw==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539925057", "bodyText": "renamed to hive.materializedview.rewriting.sql", "author": "kasakrisz", "createdAt": "2020-12-10T07:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTc2OQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539729769", "bodyText": "Can we add a comment why we are only enabling this when this config value is true? enableUnparse documentation has a description on why it is not enabled in general. However, it is worth having a comment here, since it is difficult to establish the connection between the config property and the variable.", "author": "jcamachor", "createdAt": "2020-12-09T23:38:21Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/Context.java", "diffHunk": "@@ -336,6 +344,9 @@ private Context(Configuration conf, String executionId)  {\n     opContext = new CompilationOpContext();\n \n     viewsTokenRewriteStreams = new HashMap<>();\n+    enableUnparse =", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3MjU3OQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539972579", "bodyText": "added", "author": "kasakrisz", "createdAt": "2020-12-10T08:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyOTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMDMwOQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539730309", "bodyText": "Can we add a comment (I know that the code was not added in this patch but it is useful to have some clarification on why this is being done)?", "author": "jcamachor", "createdAt": "2020-12-09T23:39:39Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ddl/view/materialized/alter/rebuild/AlterMaterializedViewRebuildAnalyzer.java", "diffHunk": "@@ -57,7 +57,7 @@ public void analyzeInternal(ASTNode root) throws SemanticException {\n \n     ASTNode tableTree = (ASTNode) root.getChild(0);\n     TableName tableName = getQualifiedTableName(tableTree);\n-    if (ctx.enableUnparse()) {\n+    if (ctx.isScheduledQuery()) {\n       unparseTranslator.addTableNameTranslation(tableTree, SessionState.get().getCurrentDatabase());", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3MjcyOQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539972729", "bodyText": "added", "author": "kasakrisz", "createdAt": "2020-12-10T08:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMTg2MQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539731861", "bodyText": "add javadoc?\nAlso, should this method be renamed to getSQLMatchingMaterializedView or anything more descriptive?", "author": "jcamachor", "createdAt": "2020-12-09T23:42:44Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk3Mjk5OQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539972999", "bodyText": "added comment.", "author": "kasakrisz", "createdAt": "2020-12-10T08:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMTg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4MDg3MQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539980871", "bodyText": "renamed", "author": "kasakrisz", "createdAt": "2020-12-10T08:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczMTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNDUzNw==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539734537", "bodyText": "filterAugmentMaterializedViews contains logic that is relevant to incremental computation of MVs, as well as other logic that works specifically for certain plan patterns. For instance, I am not sure we should be calling deriveGroupingSetsMaterializedViews for textual queries, e.g., whether it could lead to incorrect results.\nInstead, should we call getValidMaterializedViews(materializedViews, tablesUsed, false, false, txnMgr)? The caveat is that you will also need to create a method\n  private List<RelOptMaterialization> getValidMaterializedViews(List<Table> materializedViewTables,\n      List<String> tablesUsed, boolean forceMVContentsUpToDate, *boolean tryIncrementalRewriting*,\n      boolean expandGroupingSets, HiveTxnManager txnMgr) throws HiveException {\n\nFor the former calls, you can pass the value of the property HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_MATERIALIZED_VIEW_REWRITING_INCREMENTAL) for tryIncrementalRewriting. For the new call from this method, you should pass false. This will effectively lead to ignoring the MVs if they are outdated.", "author": "jcamachor", "createdAt": "2020-12-09T23:47:41Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/Hive.java", "diffHunk": "@@ -1945,6 +1945,18 @@ public RelOptMaterialization getMaterializedViewForRebuild(String dbName, String\n     }\n   }\n \n+  public List<RelOptMaterialization> getMaterialization(\n+          String queryString, List<String> tablesUsed, HiveTxnManager txnMgr) throws HiveException {\n+\n+    List<RelOptMaterialization> materializedViews =\n+            HiveMaterializedViewsRegistry.get().getRewritingMaterializedViews(queryString);\n+    if (materializedViews.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    return filterAugmentMaterializedViews(materializedViews, tablesUsed, txnMgr);", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA1NjEyOA==", "url": "https://github.com/apache/hive/pull/1706#discussion_r540056128", "bodyText": "refactored this method: instead of calling filterAugmentMaterializedViews iterate through the mvs got from the registry and call HiveMaterializedViewUtils.isOutdatedMaterializedView for each of them. If it returns null or true filter out.\nThe majority of the code in getValidMaterializedViews can be ignored in this scenario because:\n\nall boolean parameters of getValidMaterializedViews is false\nWe pull the MVs from the registry so all of them must exists in the registry\n\nIn case of multiple HS2 instances the registry may not contains all the possible MVs for rewrite but we initiate the lookup using the registry.\nI would extend this sql text based rewrite functionality to able to lookup from the metastore in a follow up patch.", "author": "kasakrisz", "createdAt": "2020-12-10T10:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTczNDUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MjI2NQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539752265", "bodyText": "We should not call toLowerCase. For instance, it would transform literal values that should be different and then consider them equal, e.g., col1='AaAa' vs col1='Aaaa'.\nIn addition to applying the change, can you add a test for this case to see that rewriting is triggered vs not-triggered?", "author": "jcamachor", "createdAt": "2020-12-10T00:31:20Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczODc1NQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r540738755", "bodyText": "removed toLoverCase() calls.\nAdded test which confirms that lookup is case sensitive now.", "author": "kasakrisz", "createdAt": "2020-12-11T07:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MjI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MzEwOQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539753109", "bodyText": "This will print the full query which will be very verbose. Maybe move printing the query text to TRACE level and simply print No materialized view with similar query text found in registry in DEBUG mode.", "author": "jcamachor", "createdAt": "2020-12-10T00:33:27Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/metadata/MaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiFunction;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * Collection for storing {@link RelOptMaterialization}s.\n+ * RelOptMaterialization can be lookup by\n+ * - the Materialized View fully qualified name\n+ * - query text.\n+ * This implementation contains two {@link ConcurrentHashMap} one for name based and one for query text based lookup.\n+ * The map contents are synchronized during each dml operation: Dml operations are performed initially on the map\n+ * which provides name based lookup. The map which provides query text based lookup is updated by lambda expressions\n+ * passed to {@link ConcurrentHashMap#compute(Object, BiFunction)}.\n+ */\n+public class MaterializedViewsCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(MaterializedViewsCache.class);\n+\n+  // Key is the database name. Value a map from the qualified name to the view object.\n+  private final ConcurrentMap<String, ConcurrentMap<String, RelOptMaterialization>> materializedViews =\n+          new ConcurrentHashMap<>();\n+  // Map for looking up materialization by view query text\n+  private final Map<String, List<RelOptMaterialization>> sqlToMaterializedView = new ConcurrentHashMap<>();\n+\n+\n+  public void putIfAbsent(Table materializedViewTable, RelOptMaterialization materialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    // You store the materialized view\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, relOptMaterialization) -> {\n+      List<RelOptMaterialization> materializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+      materializationList.add(materialization);\n+      return materialization;\n+    });\n+\n+    LOG.debug(\"Materialized view {}.{} added to registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  private ConcurrentMap<String, RelOptMaterialization> ensureDbMap(Table materializedViewTable) {\n+    // We are going to create the map for each view in the given database\n+    ConcurrentMap<String, RelOptMaterialization> dbMap =\n+            new ConcurrentHashMap<String, RelOptMaterialization>();\n+    // If we are caching the MV, we include it in the cache\n+    final ConcurrentMap<String, RelOptMaterialization> prevDbMap = materializedViews.putIfAbsent(\n+            materializedViewTable.getDbName(), dbMap);\n+    if (prevDbMap != null) {\n+      dbMap = prevDbMap;\n+    }\n+    return dbMap;\n+  }\n+\n+  public void refresh(\n+          Table oldMaterializedViewTable, Table materializedViewTable, RelOptMaterialization newMaterialization) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = ensureDbMap(materializedViewTable);\n+\n+    dbMap.compute(materializedViewTable.getTableName(), (mvTableName, existingMaterialization) -> {\n+      List<RelOptMaterialization> optMaterializationList = sqlToMaterializedView.computeIfAbsent(\n+              materializedViewTable.getViewExpandedText().toLowerCase(), s -> new ArrayList<>());\n+\n+      if (existingMaterialization == null) {\n+        // If it was not existing, we just create it\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      Table existingMaterializedViewTable = HiveMaterializedViewUtils.extractTable(existingMaterialization);\n+      if (existingMaterializedViewTable.equals(oldMaterializedViewTable)) {\n+        // If the old version is the same, we replace it\n+        optMaterializationList.remove(existingMaterialization);\n+        optMaterializationList.add(newMaterialization);\n+        return newMaterialization;\n+      }\n+      // Otherwise, we return existing materialization\n+      return existingMaterialization;\n+    });\n+\n+    LOG.debug(\"Refreshed materialized view {}.{} -> {}.{}\",\n+            oldMaterializedViewTable.getDbName(), oldMaterializedViewTable.getTableName(),\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(Table materializedViewTable) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(materializedViewTable.getDbName());\n+    if (dbMap != null) {\n+      // Delete only if the create time for the input materialized view table and the table\n+      // in the map match. Otherwise, keep the one in the map.\n+      dbMap.computeIfPresent(materializedViewTable.getTableName(), (mvTableName, oldMaterialization) -> {\n+        if (HiveMaterializedViewUtils.extractTable(oldMaterialization).equals(materializedViewTable)) {\n+          List<RelOptMaterialization> materializationList =\n+                  sqlToMaterializedView.get(materializedViewTable.getViewExpandedText().toLowerCase());\n+          materializationList.remove(oldMaterialization);\n+          return null;\n+        }\n+        return oldMaterialization;\n+      });\n+    }\n+\n+    LOG.debug(\"Materialized view {}.{} removed from registry\",\n+            materializedViewTable.getDbName(), materializedViewTable.getTableName());\n+  }\n+\n+  public void remove(String dbName, String tableName) {\n+    ConcurrentMap<String, RelOptMaterialization> dbMap = materializedViews.get(dbName);\n+    if (dbMap != null) {\n+      dbMap.computeIfPresent(tableName, (mvTableName, relOptMaterialization) -> {\n+        String queryText = HiveMaterializedViewUtils.extractTable(relOptMaterialization).getViewExpandedText();\n+        List<RelOptMaterialization> materializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+        materializationList.remove(relOptMaterialization);\n+        return null;\n+      });\n+\n+      LOG.debug(\"Materialized view {}.{} removed from registry\", dbName, tableName);\n+    }\n+  }\n+\n+  public List<RelOptMaterialization> values() {\n+    List<RelOptMaterialization> result = new ArrayList<>();\n+    materializedViews.forEach((dbName, mvs) -> result.addAll(mvs.values()));\n+    return unmodifiableList(result);\n+  }\n+\n+  RelOptMaterialization get(String dbName, String viewName) {\n+    if (materializedViews.get(dbName) != null) {\n+      LOG.debug(\"Found materialized view {}.{} in registry\", dbName, viewName);\n+      return materializedViews.get(dbName).get(viewName);\n+    }\n+    LOG.debug(\"Materialized view {}.{} not found in registry\", dbName, viewName);\n+    return null;\n+  }\n+\n+  public List<RelOptMaterialization> get(String queryText) {\n+    List<RelOptMaterialization> relOptMaterializationList = sqlToMaterializedView.get(queryText.toLowerCase());\n+    if (relOptMaterializationList == null) {\n+      LOG.debug(\"No materialized view with query text '{}' found in registry\", queryText);", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1MzQyMQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r540153421", "bodyText": "moved to trace level", "author": "kasakrisz", "createdAt": "2020-12-10T13:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MzEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NzUxMw==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539757513", "bodyText": "could this be private?", "author": "jcamachor", "createdAt": "2020-12-10T00:44:26Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -345,9 +345,19 @@\n \n import javax.sql.DataSource;\n \n+import static java.util.Collections.singletonList;\n+import static org.apache.hadoop.hive.ql.optimizer.calcite.rules.views.HiveMaterializedViewUtils.extractTable;\n+\n \n public class CalcitePlanner extends SemanticAnalyzer {\n \n+  /**\n+   * {@link org.antlr.runtime.TokenRewriteStream} offers the opportunity of multiple rewrites of the same\n+   * input text (in our case the sql query text). These rewrites are called programs and identified by a string.\n+   * EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM is for identifying the program which replaces all identifiers in the\n+   * query with fully qualified identifiers.\n+   */\n+  public static final String EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM = \"EXPANDED_QUERY_PROGRAM\";", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwOTc0MQ==", "url": "https://github.com/apache/hive/pull/1706#discussion_r540209741", "bodyText": "done", "author": "kasakrisz", "createdAt": "2020-12-10T14:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1NzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1OTI5MA==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539759290", "bodyText": "Can we move this to HiveMaterializedViewsUtils.java? I think there is a single other place where we call _ copyNodeNewCluster_ and it's to create a new materialization too. Maybe you can make _ copyNodeNewCluster_ private, make _ copyMaterializationToNewCluster_ in HiveMaterializedViewsUtils.java, and only call the latter.", "author": "jcamachor", "createdAt": "2020-12-10T00:49:00Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyNjI2Mg==", "url": "https://github.com/apache/hive/pull/1706#discussion_r540226262", "bodyText": "moved", "author": "kasakrisz", "createdAt": "2020-12-10T14:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1OTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDMxOA==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539764318", "bodyText": "Can you add a few masking tests that match / do not match based on exact SQL text?\nThere are positive and negative tests for current rewriting (masking_mv in both cases):\n873d31f#diff-3ae6a10ec619425775eeff0c135ace87cfe2c8dfbaea22f99278d7cd5d9bc330", "author": "jcamachor", "createdAt": "2020-12-10T01:02:23Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java", "diffHunk": "@@ -12565,15 +12566,17 @@ void analyzeInternal(ASTNode ast, Supplier<PlannerContext> pcf) throws SemanticE\n     sinkOp = genOPTree(ast, plannerCtx);\n \n     boolean usesMasking = false;", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc4OTI1Ng==", "url": "https://github.com/apache/hive/pull/1706#discussion_r540789256", "bodyText": "added tests", "author": "kasakrisz", "createdAt": "2020-12-11T08:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NjU1Mg==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539766552", "bodyText": "Another validation is needed here to confirm whether current user has access to such MV. See HiveMaterializedViewUtils.checkPrivilegeForMaterializedViews (cf4463e)\nPlease, add a test such as the one included in the cf4463e .", "author": "jcamachor", "createdAt": "2020-12-10T01:08:44Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2349,6 +2362,50 @@ private RelNode applyMaterializedViewRewriting(RelOptPlanner planner, RelNode ba\n       return basePlan;\n     }\n \n+    private RelOptMaterialization copyMaterializationToNewCluster(RelOptCluster optCluster, RelOptMaterialization materialization) {\n+      final RelNode viewScan = materialization.tableRel;\n+      final RelNode newViewScan = HiveMaterializedViewUtils.copyNodeNewCluster(\n+              optCluster, viewScan);\n+      return new RelOptMaterialization(newViewScan, materialization.queryRel, null,\n+              materialization.qualifiedTableName);\n+    }\n+\n+    private boolean isMaterializedViewRewritingByTextEnabled() {\n+      return conf.getBoolVar(ConfVars.HIVE_MATERIALIZED_VIEW_ENABLE_AUTO_REWRITING_QUERY_TEXT) &&\n+              mvRebuildMode == MaterializationRebuildMode.NONE &&\n+              !getQB().isMaterializedView() && !ctx.isLoadingMaterializedView() && !getQB().isCTAS() &&\n+              getQB().getIsQuery() &&\n+              getQB().hasTableDefined();\n+    }\n+\n+    private RelNode applyMaterializedViewRewritingByText(RelNode calciteGenPlan, RelOptCluster optCluster) {\n+      unparseTranslator.applyTranslations(ctx.getTokenRewriteStream(), EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM);\n+      String expandedQueryText = ctx.getTokenRewriteStream()\n+              .toString(EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM, ast.getTokenStartIndex(), ast.getTokenStopIndex());\n+      try {\n+        List<RelOptMaterialization> relOptMaterializationList = db.getMaterialization(\n+                expandedQueryText, getTablesUsed(calciteGenPlan), getTxnMgr());\n+        for (RelOptMaterialization relOptMaterialization : relOptMaterializationList) {\n+          try {\n+            Table hiveTableMD = extractTable(relOptMaterialization);\n+            if (db.validateMaterializedViewsFromRegistry(", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODkxMw==", "url": "https://github.com/apache/hive/pull/1706#discussion_r540858913", "bodyText": "added check, and tests", "author": "kasakrisz", "createdAt": "2020-12-11T10:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc2NzE0Nw==", "url": "https://github.com/apache/hive/pull/1706#discussion_r539767147", "bodyText": "Neat, thanks for adding these tests!!", "author": "jcamachor", "createdAt": "2020-12-10T01:10:16Z", "path": "ql/src/test/org/apache/hadoop/hive/ql/metadata/TestMaterializedViewsCache.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.metadata;\n+\n+import org.apache.calcite.plan.Convention;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptMaterialization;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptQuery;\n+import org.apache.calcite.plan.RelOptTable;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelShuttle;\n+import org.apache.calcite.rel.RelVisitor;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.CorrelationId;\n+import org.apache.calcite.rel.metadata.Metadata;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.apache.calcite.util.Litmus;\n+import org.apache.calcite.util.Pair;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.RelOptHiveTable;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static org.hamcrest.CoreMatchers.hasItem;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+\n+/**\n+ * Functional and parallel execution tests for {@link MaterializedViewsCache}.\n+ * Parallel execution test is disabled by default.\n+ */\n+class TestMaterializedViewsCache {", "originalCommit": "f2bd4979366380a4f7fd799a8933860eb0426ccc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75ccc402d8592281320675369b3477ac50a8ccc1", "url": "https://github.com/apache/hive/commit/75ccc402d8592281320675369b3477ac50a8ccc1", "message": "rename config to hive.materializedview.rewriting.sql", "committedDate": "2020-12-10T07:10:44Z", "type": "forcePushed"}, {"oid": "742dc5b8d0d84712e466d3046dae5bf634f853ec", "url": "https://github.com/apache/hive/commit/742dc5b8d0d84712e466d3046dae5bf634f853ec", "message": "log query sql text at trace level", "committedDate": "2020-12-10T13:02:36Z", "type": "forcePushed"}, {"oid": "1c3b6e39cc7ea80ea05404c8992b1dfe5c7deb82", "url": "https://github.com/apache/hive/commit/1c3b6e39cc7ea80ea05404c8992b1dfe5c7deb82", "message": "log query sql text at trace level", "committedDate": "2020-12-10T13:06:12Z", "type": "forcePushed"}, {"oid": "d3c872ebb9b9007dcaa75825570a9f92c3490009", "url": "https://github.com/apache/hive/commit/d3c872ebb9b9007dcaa75825570a9f92c3490009", "message": "HIVE-24274: Implement Query Text based MaterializedView rewrite", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "43cb8d9aa70fb161bc84c92c6731dc72aa603bd1", "url": "https://github.com/apache/hive/commit/43cb8d9aa70fb161bc84c92c6731dc72aa603bd1", "message": "rename config to hive.materializedview.rewriting.sql", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "7b70bbb33565851dbfc195143789e78b071048d6", "url": "https://github.com/apache/hive/commit/7b70bbb33565851dbfc195143789e78b071048d6", "message": "add comments", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "d7f8bf07aa8710b8d84980d6a9da09be88bf3521", "url": "https://github.com/apache/hive/commit/d7f8bf07aa8710b8d84980d6a9da09be88bf3521", "message": "rename getMaterialization to getMaterializedViewsBySql", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "ec82f81afc9ec10edbcf461a996b16cbf898221a", "url": "https://github.com/apache/hive/commit/ec82f81afc9ec10edbcf461a996b16cbf898221a", "message": "disable parallelism test", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "e42a5070ca08042738ed1685ce478a0f7e17bd46", "url": "https://github.com/apache/hive/commit/e42a5070ca08042738ed1685ce478a0f7e17bd46", "message": "refactor outdated validation logic", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "27a369cfb6ab2b0e7abf01e7fea560ca4d88de40", "url": "https://github.com/apache/hive/commit/27a369cfb6ab2b0e7abf01e7fea560ca4d88de40", "message": "log query sql text at trace level", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "8dcafba1318ea80d0a1f6ddc88064b111e9c47b0", "url": "https://github.com/apache/hive/commit/8dcafba1318ea80d0a1f6ddc88064b111e9c47b0", "message": "make EXPANDED_QUERY_TOKEN_REWRITE_PROGRAM private", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "4852d431ca0399b676e04c17e5fe422da46cc401", "url": "https://github.com/apache/hive/commit/4852d431ca0399b676e04c17e5fe422da46cc401", "message": "move copyMaterializationToNewCluster to HiveMaterializedViewUtils", "committedDate": "2020-12-11T05:05:40Z", "type": "commit"}, {"oid": "dfee0120cc7a20010d67da80cf360de298b16760", "url": "https://github.com/apache/hive/commit/dfee0120cc7a20010d67da80cf360de298b16760", "message": "turn off text based rewrite", "committedDate": "2020-12-11T05:17:17Z", "type": "commit"}, {"oid": "dfee0120cc7a20010d67da80cf360de298b16760", "url": "https://github.com/apache/hive/commit/dfee0120cc7a20010d67da80cf360de298b16760", "message": "turn off text based rewrite", "committedDate": "2020-12-11T05:17:17Z", "type": "forcePushed"}, {"oid": "920cdb8ac2ee463f46785bf73d8c985dce9054b7", "url": "https://github.com/apache/hive/commit/920cdb8ac2ee463f46785bf73d8c985dce9054b7", "message": "remove toLowerCase when lookup", "committedDate": "2020-12-11T07:17:04Z", "type": "commit"}, {"oid": "5a37670c849df2ed1be418ff2d42cfa1480def9d", "url": "https://github.com/apache/hive/commit/5a37670c849df2ed1be418ff2d42cfa1480def9d", "message": "add test for masking", "committedDate": "2020-12-11T08:51:17Z", "type": "commit"}, {"oid": "c097ddcf766777e8a13d17d5b0626fce294f3179", "url": "https://github.com/apache/hive/commit/c097ddcf766777e8a13d17d5b0626fce294f3179", "message": "test filtering out outdated MVs", "committedDate": "2020-12-11T09:04:15Z", "type": "commit"}, {"oid": "a316853915848c716a69eb6ee803816e0928d5f8", "url": "https://github.com/apache/hive/commit/a316853915848c716a69eb6ee803816e0928d5f8", "message": "check privilege to use MV", "committedDate": "2020-12-11T10:48:58Z", "type": "commit"}, {"oid": "863ea8e2769964133607680ae8cfdc7e82a2d126", "url": "https://github.com/apache/hive/commit/863ea8e2769964133607680ae8cfdc7e82a2d126", "message": "remove \"set hive.materializedview.rewriting.sql=true\" since it is enabled by default", "committedDate": "2020-12-11T13:02:55Z", "type": "commit"}, {"oid": "1781dc6a8288554d5f84e4926d0ac1a830beb647", "url": "https://github.com/apache/hive/commit/1781dc6a8288554d5f84e4926d0ac1a830beb647", "message": "add negative test: cbo turned off", "committedDate": "2020-12-14T17:50:56Z", "type": "commit"}]}