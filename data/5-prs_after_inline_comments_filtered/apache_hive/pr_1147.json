{"pr_number": 1147, "pr_title": "HIVE-23716: Support Anti Join in Hive", "pr_createdAt": "2020-06-18T13:57:38Z", "pr_url": "https://github.com/apache/hive/pull/1147", "timeline": [{"oid": "7942eb1dc7d67844eb9bd76ccbce6f490743698a", "url": "https://github.com/apache/hive/commit/7942eb1dc7d67844eb9bd76ccbce6f490743698a", "message": "HIVE-23716 : Support Anti Join in Hive", "committedDate": "2020-06-24T06:22:59Z", "type": "forcePushed"}, {"oid": "6ff1a1a84dec5b56ab6fd653e7c649857669b151", "url": "https://github.com/apache/hive/commit/6ff1a1a84dec5b56ab6fd653e7c649857669b151", "message": "HIVE-23716 : Support Anti Join in Hive", "committedDate": "2020-06-24T11:00:02Z", "type": "forcePushed"}, {"oid": "6a28ebcee740f5d938fb7e010b62b3c255848f84", "url": "https://github.com/apache/hive/commit/6a28ebcee740f5d938fb7e010b62b3c255848f84", "message": "HIVE-23716 : Support Anti Join in Hive", "committedDate": "2020-06-25T03:30:07Z", "type": "forcePushed"}, {"oid": "0a6ebb64af37dd1d4a6b4fa287e2afb6259e8387", "url": "https://github.com/apache/hive/commit/0a6ebb64af37dd1d4a6b4fa287e2afb6259e8387", "message": "HIVE-23716 : Support Anti Join in Hive", "committedDate": "2020-06-25T15:07:11Z", "type": "forcePushed"}, {"oid": "ad0ac42e04b220a7518ec6f486819ab26d2f2488", "url": "https://github.com/apache/hive/commit/ad0ac42e04b220a7518ec6f486819ab26d2f2488", "message": "HIVE-23716 : Support Anti Join in Hive", "committedDate": "2020-06-29T12:06:38Z", "type": "forcePushed"}, {"oid": "3ff7bb0e16085c7f2329a1bfe938486a2aa55f9e", "url": "https://github.com/apache/hive/commit/3ff7bb0e16085c7f2329a1bfe938486a2aa55f9e", "message": "enable anti join by default", "committedDate": "2020-06-29T17:56:17Z", "type": "forcePushed"}, {"oid": "382d50d3424e961e03ec95dd818d569065b19988", "url": "https://github.com/apache/hive/commit/382d50d3424e961e03ec95dd818d569065b19988", "message": "Added test cases for anti join", "committedDate": "2020-07-01T11:56:26Z", "type": "forcePushed"}, {"oid": "27caca5d37bd39d3110b527555f105f5c530fd64", "url": "https://github.com/apache/hive/commit/27caca5d37bd39d3110b527555f105f5c530fd64", "message": "Added test cases for anti join\n\nAdded test cases for anti join", "committedDate": "2020-07-01T13:44:58Z", "type": "forcePushed"}, {"oid": "3d46d4a9cc2633d7d41f53bcd424d8eeb9a75d79", "url": "https://github.com/apache/hive/commit/3d46d4a9cc2633d7d41f53bcd424d8eeb9a75d79", "message": "latest change", "committedDate": "2020-07-03T18:32:48Z", "type": "forcePushed"}, {"oid": "c11898a829149a8a959ab8b1fdb36fde11b74eb7", "url": "https://github.com/apache/hive/commit/c11898a829149a8a959ab8b1fdb36fde11b74eb7", "message": "Added test cases for anti join", "committedDate": "2020-07-06T13:49:36Z", "type": "forcePushed"}, {"oid": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "url": "https://github.com/apache/hive/commit/ee4390223caf1816ba6c07c1245876dc3c99d1e9", "message": "Added test cases for anti join", "committedDate": "2020-07-07T06:53:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4ODI0MQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r456588241", "bodyText": "@maheshk114 Have you run all the tests with this feature set to true by default? This change touches existing logic/code and we should definitely run all the existing tests with this set to TRUE.", "author": "vineetgarg02", "createdAt": "2020-07-17T17:50:55Z", "path": "common/src/java/org/apache/hadoop/hive/conf/HiveConf.java", "diffHunk": "@@ -2162,7 +2162,8 @@ private static void populateLlapDaemonVarsSet(Set<String> llapDaemonVarsSetLocal\n         \"Whether Hive enables the optimization about converting common join into mapjoin based on the input file size. \\n\" +\n         \"If this parameter is on, and the sum of size for n-1 of the tables/partitions for a n-way join is smaller than the\\n\" +\n         \"specified size, the join is directly converted to a mapjoin (there is no conditional task).\"),\n-\n+    HIVE_CONVERT_ANTI_JOIN(\"hive.auto.convert.anti.join\", false,", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5MzkwOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r456593908", "bodyText": "Yes, i had triggered a ptest run with this config enabled to true by default. There were some 26 failures. I had analyzed those and some fixes were done to make sure that the result is same for both and difference in plan is as expected.", "author": "maheshk114", "createdAt": "2020-07-17T18:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4ODI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyOTgyMA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457829820", "bodyText": "Is there any reason why we should not enable this by default in master? It seems it is always beneficial to execute the antijoin since we already have a vectorized implementation too. That would increase the test coverage for the feature.", "author": "jcamachor", "createdAt": "2020-07-21T04:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4ODI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MjI0Mw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458082243", "bodyText": "Agree with the above, I believe we should enable anti-join by default as 1) this feature should aways improve runtime 2) can help us find possible issues and 3) further optimize existing implementation based on future scenarios", "author": "pgaref", "createdAt": "2020-07-21T13:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4ODI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyNjEwMw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466826103", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-08-07T05:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4ODI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAwODk4Mw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457008983", "bodyText": "I think this can be moved down after all the condition checks below and return statements and within a isDebugEnabled check?", "author": "ramesh0201", "createdAt": "2020-07-20T03:13:56Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinWithFilterToAntiJoinRule.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveJoinWithFilterToAntiJoinRule extends RelOptRule {\n+  protected static final Logger LOG = LoggerFactory.getLogger(HiveJoinWithFilterToAntiJoinRule.class);\n+  public static final HiveJoinWithFilterToAntiJoinRule INSTANCE = new HiveJoinWithFilterToAntiJoinRule();\n+\n+  //    HiveProject(fld=[$0])\n+  //      HiveFilter(condition=[IS NULL($1)])\n+  //        HiveJoin(condition=[=($0, $1)], joinType=[left], algorithm=[none], cost=[not available])\n+  //\n+  // TO\n+  //\n+  //    HiveProject(fld_tbl=[$0])\n+  //      HiveAntiJoin(condition=[=($0, $1)], joinType=[anti])\n+  //\n+  public HiveJoinWithFilterToAntiJoinRule() {\n+    super(operand(Project.class, operand(Filter.class, operand(Join.class, RelOptRule.any()))),\n+            \"HiveJoinWithFilterToAntiJoinRule:filter\");\n+  }\n+\n+  // is null filter over a left join.\n+  public void onMatch(final RelOptRuleCall call) {\n+    final Project project = call.rel(0);\n+    final Filter filter = call.rel(1);\n+    final Join join = call.rel(2);\n+    perform(call, project, filter, join);\n+  }\n+\n+  protected void perform(RelOptRuleCall call, Project project, Filter filter, Join join) {\n+    LOG.debug(\"Matched HiveAntiJoinRule\");", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU0NTA4MQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457545081", "bodyText": "sure ..will do that", "author": "maheshk114", "createdAt": "2020-07-20T16:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAwODk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzNTk5OQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458135999", "bodyText": "nit: if inner join found a match.", "author": "pgaref", "createdAt": "2020-07-21T14:22:23Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java", "diffHunk": "@@ -638,6 +657,12 @@ private void genObject(int aliasNum, boolean allLeftFirst, boolean allLeftNull)\n           // skipping the rest of the rows in the rhs table of the semijoin\n           done = !needsPostEvaluation;\n         }\n+      } else if (type == JoinDesc.ANTI_JOIN) {\n+        if (innerJoin(skip, left, right)) {\n+          // if anti join found a match then the condition is not matched for anti join, so we can skip rest of the", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYwNTQ5OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460605498", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-27T01:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzNTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0MzM3OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458143378", "bodyText": "Not sure I fully understand the comment here -- !forward (false) and antijoin (true) will still skip the object", "author": "pgaref", "createdAt": "2020-07-21T14:31:35Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java", "diffHunk": "@@ -523,11 +533,19 @@ private boolean createForwardJoinObject(boolean[] skip) throws HiveException {\n         forward = true;\n       }\n     }\n+    return forward;\n+  }\n+\n+  // returns whether a record was forwarded\n+  private boolean createForwardJoinObject(boolean[] skip, boolean antiJoin) throws HiveException {\n+    boolean forward = fillFwdCache(skip);\n     if (forward) {\n       if (needsPostEvaluation) {\n         forward = !JoinUtil.isFiltered(forwardCache, residualJoinFilters, residualJoinFiltersOIs);\n       }\n-      if (forward) {\n+\n+      // For anti join, check all right side and if nothing is matched then only forward.", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE5ODcxOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459198718", "bodyText": "For anti join we don't emit the record here. It's done after all the records are checked and none of the record matches the condition. Here if forward is false we don't forward and as its a \"&\" we don't forward for anti join == true even if forward is true.", "author": "maheshk114", "createdAt": "2020-07-23T03:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0MzM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMwNzU0Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459307547", "bodyText": "Ok makes sense now -- so maybe we should just mention that for anti-join we dont forward at this point", "author": "pgaref", "createdAt": "2020-07-23T08:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0MzM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYwNTczMA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460605730", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-27T01:40:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0MzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0Nzg0OQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458147849", "bodyText": "nit:  The result is modified during", "author": "pgaref", "createdAt": "2020-07-21T14:37:33Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinGenerateResultOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashSet;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashSetResult;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashTableResult;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+\n+// TODO : This class is duplicate of semi join. Need to do a refactoring to merge it with semi join.\n+/**\n+ * This class has methods for generating vectorized join results for Anti joins.\n+ * The big difference between inner joins and anti joins is existence testing.\n+ * Inner joins use a hash map to lookup the 1 or more small table values.\n+ * Anti joins are a specialized join for outputting big table rows whose key exists\n+ * in the small table.\n+ *\n+ * No small table values are needed for anti since they would be empty.  So,\n+ * we use a hash set as the hash table.  Hash sets just report whether a key exists.  This\n+ * is a big performance optimization.\n+ */\n+public abstract class VectorMapJoinAntiJoinGenerateResultOperator\n+        extends VectorMapJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final Logger LOG = LoggerFactory.getLogger(VectorMapJoinAntiJoinGenerateResultOperator.class.getName());\n+\n+  // Anti join specific members.\n+\n+  // An array of hash set results so we can do lookups on the whole batch before output result\n+  // generation.\n+  protected transient VectorMapJoinHashSetResult hashSetResults[];\n+\n+  // Pre-allocated member for storing the (physical) batch index of matching row (single- or\n+  // multi-small-table-valued) indexes during a process call.\n+  protected transient int[] allMatchs;\n+\n+  // Pre-allocated member for storing the (physical) batch index of rows that need to be spilled.\n+  protected transient int[] spills;\n+\n+  // Pre-allocated member for storing index into the hashSetResults for each spilled row.\n+  protected transient int[] spillHashMapResultIndices;\n+\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinGenerateResultOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinGenerateResultOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinGenerateResultOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                                     VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  /*\n+   * Setup our anti join specific members.\n+   */\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Anti join specific.\n+    VectorMapJoinHashSet baseHashSet = (VectorMapJoinHashSet) vectorMapJoinHashTable;\n+\n+    hashSetResults = new VectorMapJoinHashSetResult[VectorizedRowBatch.DEFAULT_SIZE];\n+    for (int i = 0; i < hashSetResults.length; i++) {\n+      hashSetResults[i] = baseHashSet.createHashSetResult();\n+    }\n+\n+    allMatchs = new int[VectorizedRowBatch.DEFAULT_SIZE];\n+\n+    spills = new int[VectorizedRowBatch.DEFAULT_SIZE];\n+    spillHashMapResultIndices = new int[VectorizedRowBatch.DEFAULT_SIZE];\n+  }\n+\n+  //-----------------------------------------------------------------------------------------------\n+\n+  /*\n+   * Anti join (hash set).\n+   */\n+\n+  /**\n+   * Generate the anti join output results for one vectorized row batch. The result is modified in the during hash", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYwNTgzNg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460605836", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-27T01:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE0Nzg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1MTgyOQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458151829", "bodyText": "nit: whose key DOES NOT exist", "author": "pgaref", "createdAt": "2020-07-21T14:42:27Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinGenerateResultOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashSet;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashSetResult;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashTableResult;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+\n+// TODO : This class is duplicate of semi join. Need to do a refactoring to merge it with semi join.\n+/**\n+ * This class has methods for generating vectorized join results for Anti joins.\n+ * The big difference between inner joins and anti joins is existence testing.\n+ * Inner joins use a hash map to lookup the 1 or more small table values.\n+ * Anti joins are a specialized join for outputting big table rows whose key exists", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYwNjAxNg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460606016", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-27T01:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1MTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NzIxNg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458157216", "bodyText": "leftover?", "author": "pgaref", "createdAt": "2020-07-21T14:49:24Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIwODA2Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459208067", "bodyText": "The pre batch processing done only for joins which emits the right table records. For semi join and anti join, it's not required.", "author": "maheshk114", "createdAt": "2020-07-23T04:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NzIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1ODgyOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458158828", "bodyText": "would it make sense to move the Result inversion to a utility function?", "author": "pgaref", "createdAt": "2020-07-21T14:51:20Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      // The one join column for this specialized class.\n+      LongColumnVector joinColVector = (LongColumnVector) batch.cols[singleJoinColumn];\n+      long[] vector = joinColVector.vector;\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          // For anti join, if the right side is null then its a match.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          long key = vector[0];\n+          if (useMinMax && (key < min || key > max)) {\n+            // Out of range for whole batch. Its a match for anti join. We can emit the row.\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else {\n+            joinResult = hashSet.contains(key, hashSetResults[0]);\n+            // reverse the join result for anti join.\n+            if (joinResult == JoinUtil.JoinResult.NOMATCH) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMjU2Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460522562", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1ODgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2MjU1OQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458162559", "bodyText": "Maybe rename to haveExistingKey? or HaveCurrentKey?", "author": "pgaref", "createdAt": "2020-07-21T14:56:11Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      // The one join column for this specialized class.\n+      LongColumnVector joinColVector = (LongColumnVector) batch.cols[singleJoinColumn];\n+      long[] vector = joinColVector.vector;\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          // For anti join, if the right side is null then its a match.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          long key = vector[0];\n+          if (useMinMax && (key < min || key > max)) {\n+            // Out of range for whole batch. Its a match for anti join. We can emit the row.\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else {\n+            joinResult = hashSet.contains(key, hashSetResults[0]);\n+            // reverse the join result for anti join.\n+            if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+              joinResult = JoinUtil.JoinResult.MATCH;\n+            } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+              joinResult = JoinUtil.JoinResult.NOMATCH;\n+            }\n+          }\n+        }\n+\n+        // Common repeated join result processing.\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+        // NOT Repeating.\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matches / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+        long saveKey = 0;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxODE5NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466818194", "bodyText": "I have kept the code same as Semi join. may be we can take up this refactoring as part of merging the code.", "author": "maheshk114", "createdAt": "2020-08-07T04:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2MjU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NDU5Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458164592", "bodyText": "It seems that this could be simplified (not sure haveSaveKey variable is needed)", "author": "pgaref", "createdAt": "2020-07-21T14:58:44Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      // The one join column for this specialized class.\n+      LongColumnVector joinColVector = (LongColumnVector) batch.cols[singleJoinColumn];\n+      long[] vector = joinColVector.vector;\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          // For anti join, if the right side is null then its a match.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          long key = vector[0];\n+          if (useMinMax && (key < min || key > max)) {\n+            // Out of range for whole batch. Its a match for anti join. We can emit the row.\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else {\n+            joinResult = hashSet.contains(key, hashSetResults[0]);\n+            // reverse the join result for anti join.\n+            if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+              joinResult = JoinUtil.JoinResult.MATCH;\n+            } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+              joinResult = JoinUtil.JoinResult.NOMATCH;\n+            }\n+          }\n+        }\n+\n+        // Common repeated join result processing.\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+        // NOT Repeating.\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matches / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+        long saveKey = 0;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;\n+        JoinUtil.JoinResult saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+\n+        // Logical loop over the rows in the batch since the batch may have selected in use.\n+        for (int logical = 0; logical < inputLogicalSize; logical++) {\n+          int batchIndex = (selectedInUse ? selected[logical] : logical);\n+\n+          // Single-Column Long get key.\n+          long currentKey;\n+          boolean isNull;\n+          if (!joinColVector.noNulls && joinColVector.isNull[batchIndex]) {\n+            currentKey = 0;\n+            isNull = true;\n+          } else {\n+            currentKey = vector[batchIndex];\n+            isNull = false;\n+          }\n+\n+          // Equal key series checking.\n+          if (isNull || !haveSaveKey || currentKey != saveKey) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxMjM2OQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459212369", "bodyText": "I have kept the code same as Semi join. may be we can take up this refactoring as part of merging the code.", "author": "maheshk114", "createdAt": "2020-07-23T04:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NDU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMwNzkyMQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459307921", "bodyText": "ack", "author": "pgaref", "createdAt": "2020-07-23T08:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NDU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NTg0NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458165844", "bodyText": "seems that only SPILL case is useful here?", "author": "pgaref", "createdAt": "2020-07-21T15:00:18Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      // The one join column for this specialized class.\n+      LongColumnVector joinColVector = (LongColumnVector) batch.cols[singleJoinColumn];\n+      long[] vector = joinColVector.vector;\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          // For anti join, if the right side is null then its a match.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          long key = vector[0];\n+          if (useMinMax && (key < min || key > max)) {\n+            // Out of range for whole batch. Its a match for anti join. We can emit the row.\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else {\n+            joinResult = hashSet.contains(key, hashSetResults[0]);\n+            // reverse the join result for anti join.\n+            if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+              joinResult = JoinUtil.JoinResult.MATCH;\n+            } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+              joinResult = JoinUtil.JoinResult.NOMATCH;\n+            }\n+          }\n+        }\n+\n+        // Common repeated join result processing.\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+        // NOT Repeating.\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matches / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+        long saveKey = 0;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;\n+        JoinUtil.JoinResult saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+\n+        // Logical loop over the rows in the batch since the batch may have selected in use.\n+        for (int logical = 0; logical < inputLogicalSize; logical++) {\n+          int batchIndex = (selectedInUse ? selected[logical] : logical);\n+\n+          // Single-Column Long get key.\n+          long currentKey;\n+          boolean isNull;\n+          if (!joinColVector.noNulls && joinColVector.isNull[batchIndex]) {\n+            currentKey = 0;\n+            isNull = true;\n+          } else {\n+            currentKey = vector[batchIndex];\n+            isNull = false;\n+          }\n+\n+          // Equal key series checking.\n+          if (isNull || !haveSaveKey || currentKey != saveKey) {\n+            // New key.\n+            if (haveSaveKey) {\n+              // Move on with our counts.\n+              switch (saveJoinResult) {\n+              case MATCH:\n+                // We have extracted the existence from the hash set result, so we don't keep it.\n+                break;\n+              case SPILL:", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxODM1OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466818358", "bodyText": "I have kept the code same as Semi join. may be we can take up this refactoring as part of merging the code.", "author": "maheshk114", "createdAt": "2020-08-07T04:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NTg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NzEwNA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458167104", "bodyText": "Inversion is actual done below", "author": "pgaref", "createdAt": "2020-07-21T15:01:55Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      // The one join column for this specialized class.\n+      LongColumnVector joinColVector = (LongColumnVector) batch.cols[singleJoinColumn];\n+      long[] vector = joinColVector.vector;\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          // For anti join, if the right side is null then its a match.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          long key = vector[0];\n+          if (useMinMax && (key < min || key > max)) {\n+            // Out of range for whole batch. Its a match for anti join. We can emit the row.\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else {\n+            joinResult = hashSet.contains(key, hashSetResults[0]);\n+            // reverse the join result for anti join.\n+            if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+              joinResult = JoinUtil.JoinResult.MATCH;\n+            } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+              joinResult = JoinUtil.JoinResult.NOMATCH;\n+            }\n+          }\n+        }\n+\n+        // Common repeated join result processing.\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+        // NOT Repeating.\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matches / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+        long saveKey = 0;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;\n+        JoinUtil.JoinResult saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+\n+        // Logical loop over the rows in the batch since the batch may have selected in use.\n+        for (int logical = 0; logical < inputLogicalSize; logical++) {\n+          int batchIndex = (selectedInUse ? selected[logical] : logical);\n+\n+          // Single-Column Long get key.\n+          long currentKey;\n+          boolean isNull;\n+          if (!joinColVector.noNulls && joinColVector.isNull[batchIndex]) {\n+            currentKey = 0;\n+            isNull = true;\n+          } else {\n+            currentKey = vector[batchIndex];\n+            isNull = false;\n+          }\n+\n+          // Equal key series checking.\n+          if (isNull || !haveSaveKey || currentKey != saveKey) {\n+            // New key.\n+            if (haveSaveKey) {\n+              // Move on with our counts.\n+              switch (saveJoinResult) {\n+              case MATCH:\n+                // We have extracted the existence from the hash set result, so we don't keep it.\n+                break;\n+              case SPILL:\n+                // We keep the hash set result for its spill information.\n+                hashSetResultCount++;\n+                break;\n+              case NOMATCH:\n+                break;\n+              }\n+            }\n+\n+            if (isNull) {\n+              saveJoinResult = JoinUtil.JoinResult.MATCH;\n+              haveSaveKey = false;\n+            } else {\n+              // Regardless of our matching result, we keep that information to make multiple use\n+              // of it for a possible series of equal keys.\n+              haveSaveKey = true;\n+              saveKey = currentKey;\n+              if (useMinMax && (currentKey < min || currentKey > max)) {\n+                // Key out of range for whole hash table, is a valid match for anti join.", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMjQ1NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460522454", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NzUxNQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458167515", "bodyText": "Again this could be replaced with an Inversion utility function", "author": "pgaref", "createdAt": "2020-07-21T15:02:27Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      // The one join column for this specialized class.\n+      LongColumnVector joinColVector = (LongColumnVector) batch.cols[singleJoinColumn];\n+      long[] vector = joinColVector.vector;\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          // For anti join, if the right side is null then its a match.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          long key = vector[0];\n+          if (useMinMax && (key < min || key > max)) {\n+            // Out of range for whole batch. Its a match for anti join. We can emit the row.\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else {\n+            joinResult = hashSet.contains(key, hashSetResults[0]);\n+            // reverse the join result for anti join.\n+            if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+              joinResult = JoinUtil.JoinResult.MATCH;\n+            } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+              joinResult = JoinUtil.JoinResult.NOMATCH;\n+            }\n+          }\n+        }\n+\n+        // Common repeated join result processing.\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+        // NOT Repeating.\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matches / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+        long saveKey = 0;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;\n+        JoinUtil.JoinResult saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+\n+        // Logical loop over the rows in the batch since the batch may have selected in use.\n+        for (int logical = 0; logical < inputLogicalSize; logical++) {\n+          int batchIndex = (selectedInUse ? selected[logical] : logical);\n+\n+          // Single-Column Long get key.\n+          long currentKey;\n+          boolean isNull;\n+          if (!joinColVector.noNulls && joinColVector.isNull[batchIndex]) {\n+            currentKey = 0;\n+            isNull = true;\n+          } else {\n+            currentKey = vector[batchIndex];\n+            isNull = false;\n+          }\n+\n+          // Equal key series checking.\n+          if (isNull || !haveSaveKey || currentKey != saveKey) {\n+            // New key.\n+            if (haveSaveKey) {\n+              // Move on with our counts.\n+              switch (saveJoinResult) {\n+              case MATCH:\n+                // We have extracted the existence from the hash set result, so we don't keep it.\n+                break;\n+              case SPILL:\n+                // We keep the hash set result for its spill information.\n+                hashSetResultCount++;\n+                break;\n+              case NOMATCH:\n+                break;\n+              }\n+            }\n+\n+            if (isNull) {\n+              saveJoinResult = JoinUtil.JoinResult.MATCH;\n+              haveSaveKey = false;\n+            } else {\n+              // Regardless of our matching result, we keep that information to make multiple use\n+              // of it for a possible series of equal keys.\n+              haveSaveKey = true;\n+              saveKey = currentKey;\n+              if (useMinMax && (currentKey < min || currentKey > max)) {\n+                // Key out of range for whole hash table, is a valid match for anti join.\n+                saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+              } else {\n+                saveJoinResult = hashSet.contains(currentKey, hashSetResults[hashSetResultCount]);\n+              }\n+\n+              // Reverse the match result for anti join.", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMjMyOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460522328", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2NzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2OTQ1Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458169457", "bodyText": "Repeating Common anti join result processing code -- move to function?", "author": "pgaref", "createdAt": "2020-07-21T15:05:10Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinLongOperator.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinLongHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+// Single-Column Long hash table import.\n+// Single-Column Long specific imports.\n+\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column Long\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinLongOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinLongOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinLongHashSet hashSet;\n+\n+  // Single-Column Long specific members.\n+  // For integers, we have optional min/max filtering.\n+  private transient boolean useMinMax;\n+  private transient long min;\n+  private transient long max;\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  // Pass-thru constructors.\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinLongOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinLongOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                           VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  // Process Single-Column Long Anti Join on a vectorized row batch.\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    // Initialize Single-Column Long members for this specialized class.\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    // Get our Single-Column Long hash set information for this specialized class.\n+    hashSet = (VectorMapJoinLongHashSet) vectorMapJoinHashTable;\n+    useMinMax = hashSet.useMinMax();\n+    if (useMinMax) {\n+      min = hashSet.min();\n+      max = hashSet.max();\n+    }\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      // The one join column for this specialized class.\n+      LongColumnVector joinColVector = (LongColumnVector) batch.cols[singleJoinColumn];\n+      long[] vector = joinColVector.vector;\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          // For anti join, if the right side is null then its a match.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          long key = vector[0];\n+          if (useMinMax && (key < min || key > max)) {\n+            // Out of range for whole batch. Its a match for anti join. We can emit the row.\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else {\n+            joinResult = hashSet.contains(key, hashSetResults[0]);\n+            // reverse the join result for anti join.\n+            if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+              joinResult = JoinUtil.JoinResult.MATCH;\n+            } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+              joinResult = JoinUtil.JoinResult.NOMATCH;\n+            }\n+          }\n+        }\n+\n+        // Common repeated join result processing.\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+        // NOT Repeating.\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matches / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+        long saveKey = 0;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;\n+        JoinUtil.JoinResult saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+\n+        // Logical loop over the rows in the batch since the batch may have selected in use.\n+        for (int logical = 0; logical < inputLogicalSize; logical++) {\n+          int batchIndex = (selectedInUse ? selected[logical] : logical);\n+\n+          // Single-Column Long get key.\n+          long currentKey;\n+          boolean isNull;\n+          if (!joinColVector.noNulls && joinColVector.isNull[batchIndex]) {\n+            currentKey = 0;\n+            isNull = true;\n+          } else {\n+            currentKey = vector[batchIndex];\n+            isNull = false;\n+          }\n+\n+          // Equal key series checking.\n+          if (isNull || !haveSaveKey || currentKey != saveKey) {\n+            // New key.\n+            if (haveSaveKey) {\n+              // Move on with our counts.\n+              switch (saveJoinResult) {\n+              case MATCH:\n+                // We have extracted the existence from the hash set result, so we don't keep it.\n+                break;\n+              case SPILL:\n+                // We keep the hash set result for its spill information.\n+                hashSetResultCount++;\n+                break;\n+              case NOMATCH:\n+                break;\n+              }\n+            }\n+\n+            if (isNull) {\n+              saveJoinResult = JoinUtil.JoinResult.MATCH;\n+              haveSaveKey = false;\n+            } else {\n+              // Regardless of our matching result, we keep that information to make multiple use\n+              // of it for a possible series of equal keys.\n+              haveSaveKey = true;\n+              saveKey = currentKey;\n+              if (useMinMax && (currentKey < min || currentKey > max)) {\n+                // Key out of range for whole hash table, is a valid match for anti join.\n+                saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+              } else {\n+                saveJoinResult = hashSet.contains(currentKey, hashSetResults[hashSetResultCount]);\n+              }\n+\n+              // Reverse the match result for anti join.\n+              if (saveJoinResult == JoinUtil.JoinResult.NOMATCH) {\n+                saveJoinResult = JoinUtil.JoinResult.MATCH;\n+              } else if (saveJoinResult == JoinUtil.JoinResult.MATCH) {\n+                saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+              }\n+            }\n+\n+            // Common anti join result processing.\n+            switch (saveJoinResult) {\n+            case MATCH:\n+              allMatchs[allMatchCount++] = batchIndex;\n+              // VectorizedBatchUtil.debugDisplayOneRow(batch, batchIndex, CLASS_NAME + \" MATCH isSingleValue \" + equalKeySeriesIsSingleValue[equalKeySeriesCount] + \" currentKey \" + currentKey);\n+              break;\n+\n+            case SPILL:\n+              spills[spillCount] = batchIndex;\n+              spillHashMapResultIndices[spillCount] = hashSetResultCount;\n+              spillCount++;\n+              break;\n+\n+            case NOMATCH:\n+              // VectorizedBatchUtil.debugDisplayOneRow(batch, batchIndex, CLASS_NAME + \" NOMATCH\" + \" currentKey \" + currentKey);\n+              break;\n+            }\n+          } else {\n+            // Series of equal keys.", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMjMxMg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460522312", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2OTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2OTcyMw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458169723", "bodyText": "leftover?", "author": "pgaref", "createdAt": "2020-07-21T15:05:30Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinMultiKeyOperator.java", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSerializeRow;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinBytesHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.apache.hadoop.hive.serde2.ByteStream.Output;\n+import org.apache.hadoop.hive.serde2.binarysortable.fast.BinarySortableSerializeWrite;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// Multi-Key hash table import.\n+// Multi-Key specific imports.\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on Multi-Key\n+ * using hash set.\n+ */\n+public class VectorMapJoinAntiJoinMultiKeyOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  //------------------------------------------------------------------------------------------------\n+\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinMultiKeyOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  //------------------------------------------------------------------------------------------------\n+\n+  // (none)\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+  //---------------------------------------------------------------------------\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinBytesHashSet hashSet;\n+\n+  //---------------------------------------------------------------------------\n+  // Multi-Key specific members.\n+  //\n+\n+  // Object that can take a set of columns in row in a vectorized row batch and serialized it.\n+  // Known to not have any nulls.\n+  private transient VectorSerializeRow keyVectorSerializeWrite;\n+\n+  // The BinarySortable serialization of the current key.\n+  private transient Output currentKeyOutput;\n+\n+  // The BinarySortable serialization of the saved key for a possible series of equal keys.\n+  private transient Output saveKeyOutput;\n+\n+  //---------------------------------------------------------------------------\n+  // Pass-thru constructors.\n+  //\n+\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinMultiKeyOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinMultiKeyOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinMultiKeyOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                               VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  //---------------------------------------------------------------------------\n+  // Process Multi-Key Anti Join on a vectorized row batch.\n+  //\n+\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    /*\n+     * Initialize Multi-Key members for this specialized class.\n+     */\n+\n+    keyVectorSerializeWrite = new VectorSerializeRow(BinarySortableSerializeWrite.with(\n+            this.getConf().getKeyTblDesc().getProperties(), bigTableKeyColumnMap.length));\n+    keyVectorSerializeWrite.init(bigTableKeyTypeInfos, bigTableKeyColumnMap);\n+\n+    currentKeyOutput = new Output();\n+    saveKeyOutput = new Output();\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    /*\n+     * Get our Multi-Key hash set information for this specialized class.\n+     */\n+\n+    hashSet = (VectorMapJoinBytesHashSet) vectorMapJoinHashTable;\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+\n+      // Do the per-batch setup for an anti join.\n+\n+      // (Currently none)", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxODQ5Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466818492", "bodyText": "I have kept the code same as Semi join. may be we can take up this refactoring as part of merging the code.", "author": "maheshk114", "createdAt": "2020-08-07T04:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3ODc4Ng==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458178786", "bodyText": "simplification?", "author": "pgaref", "createdAt": "2020-07-21T15:17:43Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinMultiKeyOperator.java", "diffHunk": "@@ -0,0 +1,400 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorSerializeRow;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinBytesHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.apache.hadoop.hive.serde2.ByteStream.Output;\n+import org.apache.hadoop.hive.serde2.binarysortable.fast.BinarySortableSerializeWrite;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// Multi-Key hash table import.\n+// Multi-Key specific imports.\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on Multi-Key\n+ * using hash set.\n+ */\n+public class VectorMapJoinAntiJoinMultiKeyOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  //------------------------------------------------------------------------------------------------\n+\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinMultiKeyOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  //------------------------------------------------------------------------------------------------\n+\n+  // (none)\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+  //---------------------------------------------------------------------------\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinBytesHashSet hashSet;\n+\n+  //---------------------------------------------------------------------------\n+  // Multi-Key specific members.\n+  //\n+\n+  // Object that can take a set of columns in row in a vectorized row batch and serialized it.\n+  // Known to not have any nulls.\n+  private transient VectorSerializeRow keyVectorSerializeWrite;\n+\n+  // The BinarySortable serialization of the current key.\n+  private transient Output currentKeyOutput;\n+\n+  // The BinarySortable serialization of the saved key for a possible series of equal keys.\n+  private transient Output saveKeyOutput;\n+\n+  //---------------------------------------------------------------------------\n+  // Pass-thru constructors.\n+  //\n+\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinMultiKeyOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinMultiKeyOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinMultiKeyOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                               VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  //---------------------------------------------------------------------------\n+  // Process Multi-Key Anti Join on a vectorized row batch.\n+  //\n+\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    /*\n+     * Initialize Multi-Key members for this specialized class.\n+     */\n+\n+    keyVectorSerializeWrite = new VectorSerializeRow(BinarySortableSerializeWrite.with(\n+            this.getConf().getKeyTblDesc().getProperties(), bigTableKeyColumnMap.length));\n+    keyVectorSerializeWrite.init(bigTableKeyTypeInfos, bigTableKeyColumnMap);\n+\n+    currentKeyOutput = new Output();\n+    saveKeyOutput = new Output();\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    /*\n+     * Get our Multi-Key hash set information for this specialized class.\n+     */\n+\n+    hashSet = (VectorMapJoinBytesHashSet) vectorMapJoinHashTable;\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+\n+      // Do the per-batch setup for an anti join.\n+\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      /*\n+       * Multi-Key specific declarations.\n+       */\n+\n+      // None.\n+\n+      /*\n+       * Multi-Key Long check for repeating.\n+       */\n+\n+      // If all BigTable input columns to key expressions are isRepeating, then\n+      // calculate key once; lookup once.\n+      boolean allKeyInputColumnsRepeating;\n+      if (bigTableKeyColumnMap.length == 0) {\n+       allKeyInputColumnsRepeating = false;\n+      } else {\n+        allKeyInputColumnsRepeating = true;\n+        for (int i = 0; i < bigTableKeyColumnMap.length; i++) {\n+          if (!batch.cols[bigTableKeyColumnMap[i]].isRepeating) {\n+            allKeyInputColumnsRepeating =  false;\n+            break;\n+          }\n+        }\n+      }\n+\n+      if (allKeyInputColumnsRepeating) {\n+\n+        /*\n+         * Repeating.\n+         */\n+\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+\n+        /*\n+         * Multi-Key specific repeated lookup.\n+         */\n+\n+        keyVectorSerializeWrite.setOutput(currentKeyOutput);\n+        keyVectorSerializeWrite.serializeWrite(batch, 0);\n+        JoinUtil.JoinResult joinResult;\n+        if (keyVectorSerializeWrite.getHasAnyNulls()) {\n+          // If right side is null, its a match for anti join.\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          byte[] keyBytes = currentKeyOutput.getData();\n+          int keyLength = currentKeyOutput.getLength();\n+          // LOG.debug(CLASS_NAME + \" processOp all \" + displayBytes(keyBytes, 0, keyLength));\n+          joinResult = hashSet.contains(keyBytes, 0, keyLength, hashSetResults[0]);\n+          // reverse the join result from hash table for anti join.\n+          if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+            joinResult = JoinUtil.JoinResult.NOMATCH;\n+          }\n+        }\n+\n+        /*\n+         * Common repeated join result processing.\n+         */\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+\n+        /*\n+         * NOT Repeating.\n+         */\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matches / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+\n+        /*\n+         * Multi-Key specific variables.\n+         */\n+\n+        Output temp;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;\n+        JoinUtil.JoinResult saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+\n+        // Logical loop over the rows in the batch since the batch may have selected in use.\n+        for (int logical = 0; logical < inputLogicalSize; logical++) {\n+          int batchIndex = (selectedInUse ? selected[logical] : logical);\n+\n+          /*\n+           * Multi-Key get key.\n+           */\n+\n+          // Generate binary sortable key for current row in vectorized row batch.\n+          keyVectorSerializeWrite.setOutput(currentKeyOutput);\n+          keyVectorSerializeWrite.serializeWrite(batch, batchIndex);\n+          boolean isAnyNull = keyVectorSerializeWrite.getHasAnyNulls();\n+\n+          // LOG.debug(CLASS_NAME + \" currentKey \" +\n+          //      VectorizedBatchUtil.displayBytes(currentKeyOutput.getData(), 0, currentKeyOutput.getLength()));\n+\n+          /*\n+           * Equal key series checking.\n+           */\n+\n+          if (isAnyNull || !haveSaveKey || !saveKeyOutput.arraysEquals(currentKeyOutput)) {\n+\n+            // New key.\n+\n+            if (haveSaveKey) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxODU0NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466818544", "bodyText": "I have kept the code same as Semi join. may be we can take up this refactoring as part of merging the code.", "author": "maheshk114", "createdAt": "2020-08-07T04:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE3ODc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE4MDI2NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458180264", "bodyText": "Inversion func", "author": "pgaref", "createdAt": "2020-07-21T15:19:27Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinStringOperator.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.StringExpr;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinBytesHashSet;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+\n+// Single-Column String hash table import.\n+// Single-Column String specific imports.\n+\n+// TODO : Duplicate codes need to merge with semi join.\n+/*\n+ * Specialized class for doing a vectorized map join that is an anti join on a Single-Column String\n+ * using a hash set.\n+ */\n+public class VectorMapJoinAntiJoinStringOperator extends VectorMapJoinAntiJoinGenerateResultOperator {\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  //------------------------------------------------------------------------------------------------\n+\n+  private static final String CLASS_NAME = VectorMapJoinAntiJoinStringOperator.class.getName();\n+  private static final Logger LOG = LoggerFactory.getLogger(CLASS_NAME);\n+\n+  protected String getLoggingPrefix() {\n+    return super.getLoggingPrefix(CLASS_NAME);\n+  }\n+\n+  //------------------------------------------------------------------------------------------------\n+\n+  // (none)\n+\n+  // The above members are initialized by the constructor and must not be\n+  // transient.\n+  //---------------------------------------------------------------------------\n+\n+  // The hash map for this specialized class.\n+  private transient VectorMapJoinBytesHashSet hashSet;\n+\n+  //---------------------------------------------------------------------------\n+  // Single-Column String specific members.\n+  //\n+\n+  // The column number for this one column join specialization.\n+  private transient int singleJoinColumn;\n+\n+  //---------------------------------------------------------------------------\n+  // Pass-thru constructors.\n+  //\n+\n+  /** Kryo ctor. */\n+  protected VectorMapJoinAntiJoinStringOperator() {\n+    super();\n+  }\n+\n+  public VectorMapJoinAntiJoinStringOperator(CompilationOpContext ctx) {\n+    super(ctx);\n+  }\n+\n+  public VectorMapJoinAntiJoinStringOperator(CompilationOpContext ctx, OperatorDesc conf,\n+                                             VectorizationContext vContext, VectorDesc vectorDesc) throws HiveException {\n+    super(ctx, conf, vContext, vectorDesc);\n+  }\n+\n+  //---------------------------------------------------------------------------\n+  // Process Single-Column String anti Join on a vectorized row batch.\n+  //\n+\n+  @Override\n+  protected void commonSetup() throws HiveException {\n+    super.commonSetup();\n+\n+    /*\n+     * Initialize Single-Column String members for this specialized class.\n+     */\n+\n+    singleJoinColumn = bigTableKeyColumnMap[0];\n+  }\n+\n+  @Override\n+  public void hashTableSetup() throws HiveException {\n+    super.hashTableSetup();\n+\n+    /*\n+     * Get our Single-Column String hash set information for this specialized class.\n+     */\n+\n+    hashSet = (VectorMapJoinBytesHashSet) vectorMapJoinHashTable;\n+  }\n+\n+  @Override\n+  public void processBatch(VectorizedRowBatch batch) throws HiveException {\n+\n+    try {\n+\n+      // Do the per-batch setup for an anti join.\n+\n+      // (Currently none)\n+      // antiPerBatchSetup(batch);\n+\n+      // For anti joins, we may apply the filter(s) now.\n+      for(VectorExpression ve : bigTableFilterExpressions) {\n+        ve.evaluate(batch);\n+      }\n+\n+      final int inputLogicalSize = batch.size;\n+      if (inputLogicalSize == 0) {\n+        return;\n+      }\n+\n+      // Perform any key expressions.  Results will go into scratch columns.\n+      if (bigTableKeyExpressions != null) {\n+        for (VectorExpression ve : bigTableKeyExpressions) {\n+          ve.evaluate(batch);\n+        }\n+      }\n+\n+      /*\n+       * Single-Column String specific declarations.\n+       */\n+\n+      // The one join column for this specialized class.\n+      BytesColumnVector joinColVector = (BytesColumnVector) batch.cols[singleJoinColumn];\n+      byte[][] vector = joinColVector.vector;\n+      int[] start = joinColVector.start;\n+      int[] length = joinColVector.length;\n+\n+      /*\n+       * Single-Column Long check for repeating.\n+       */\n+\n+      // Check single column for repeating.\n+      boolean allKeyInputColumnsRepeating = joinColVector.isRepeating;\n+\n+      if (allKeyInputColumnsRepeating) {\n+\n+        /*\n+         * Repeating.\n+         */\n+\n+        // All key input columns are repeating.  Generate key once.  Lookup once.\n+        // Since the key is repeated, we must use entry 0 regardless of selectedInUse.\n+\n+        /*\n+         * Single-Column String specific repeated lookup.\n+         */\n+\n+        JoinUtil.JoinResult joinResult;\n+        if (!joinColVector.noNulls && joinColVector.isNull[0]) {\n+          joinResult = JoinUtil.JoinResult.MATCH;\n+        } else {\n+          byte[] keyBytes = vector[0];\n+          int keyStart = start[0];\n+          int keyLength = length[0];\n+          joinResult = hashSet.contains(keyBytes, keyStart, keyLength, hashSetResults[0]);\n+          if (joinResult == JoinUtil.JoinResult.NOMATCH) {\n+            joinResult = JoinUtil.JoinResult.MATCH;\n+          } else if (joinResult == JoinUtil.JoinResult.MATCH) {\n+            joinResult = JoinUtil.JoinResult.NOMATCH;\n+          }\n+        }\n+\n+        /*\n+         * Common repeated join result processing.\n+         */\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" repeated joinResult \" + joinResult.name());\n+        }\n+        finishAntiRepeated(batch, joinResult, hashSetResults[0]);\n+      } else {\n+\n+        /*\n+         * NOT Repeating.\n+         */\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(CLASS_NAME + \" batch #\" + batchCounter + \" non-repeated\");\n+        }\n+\n+        // We remember any matching rows in matchs / matchSize.  At the end of the loop,\n+        // selected / batch.size will represent both matching and non-matching rows for outer join.\n+        // Only deferred rows will have been removed from selected.\n+        int selected[] = batch.selected;\n+        boolean selectedInUse = batch.selectedInUse;\n+\n+        int hashSetResultCount = 0;\n+        int allMatchCount = 0;\n+        int spillCount = 0;\n+\n+        /*\n+         * Single-Column String specific variables.\n+         */\n+\n+        int saveKeyBatchIndex = -1;\n+\n+        // We optimize performance by only looking up the first key in a series of equal keys.\n+        boolean haveSaveKey = false;\n+        JoinUtil.JoinResult saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+\n+        // Logical loop over the rows in the batch since the batch may have selected in use.\n+        for (int logical = 0; logical < inputLogicalSize; logical++) {\n+          int batchIndex = (selectedInUse ? selected[logical] : logical);\n+\n+          /*\n+           * Single-Column String get key.\n+           */\n+\n+          // Implicit -- use batchIndex.\n+          boolean isNull = !joinColVector.noNulls && joinColVector.isNull[batchIndex];\n+\n+          /*\n+           * Equal key series checking.\n+           */\n+\n+          if (isNull || !haveSaveKey ||\n+              !StringExpr.equal(vector[saveKeyBatchIndex], start[saveKeyBatchIndex], length[saveKeyBatchIndex],\n+                      vector[batchIndex], start[batchIndex], length[batchIndex])) {\n+\n+            // New key.\n+\n+            if (haveSaveKey) {\n+              // Move on with our counts.\n+              switch (saveJoinResult) {\n+              case MATCH:\n+                // We have extracted the existence from the hash set result, so we don't keep it.\n+                break;\n+              case SPILL:\n+                // We keep the hash set result for its spill information.\n+                hashSetResultCount++;\n+                break;\n+              case NOMATCH:\n+                break;\n+              }\n+            }\n+\n+            if (isNull) {\n+              saveJoinResult = JoinUtil.JoinResult.NOMATCH;\n+              haveSaveKey = false;\n+            } else {\n+              // Regardless of our matching result, we keep that information to make multiple use\n+              // of it for a possible series of equal keys.\n+              haveSaveKey = true;\n+  \n+              /*\n+               * Single-Column String specific save key and lookup.\n+               */\n+  \n+              saveKeyBatchIndex = batchIndex;\n+  \n+              /*\n+               * Single-Column String specific lookup key.\n+               */\n+  \n+              byte[] keyBytes = vector[batchIndex];\n+              int keyStart = start[batchIndex];\n+              int keyLength = length[batchIndex];\n+              saveJoinResult = hashSet.contains(keyBytes, keyStart, keyLength, hashSetResults[hashSetResultCount]);\n+              if (saveJoinResult == JoinUtil.JoinResult.NOMATCH) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMjI2MQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460522261", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE4MDI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5MDY0Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458190642", "bodyText": "Not sure I understand the issue here -- is the problem the fact that ANTI-join matches with NULL rows on the right side?", "author": "pgaref", "createdAt": "2020-07-21T15:33:12Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinAddNotNullRule.java", "diffHunk": "@@ -74,7 +78,14 @@ public HiveJoinAddNotNullRule(Class<? extends Join> clazz,\n   @Override\n   public void onMatch(RelOptRuleCall call) {\n     Join join = call.rel(0);\n-    if (join.getJoinType() == JoinRelType.FULL || join.getCondition().isAlwaysTrue()) {\n+\n+    // For anti join case add the not null on right side if the condition is", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNTM1Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459215352", "bodyText": "For the case when we have. join condition which gets evaluated, it will return false while comparing with a null on the right side. But for always true join condition, we will not do a match for right side assuming it's always true.  So for anti join, the left side records will not be emitted. To avoid this we put a null check on right side table and for all null entry, no records will be projected from right side and thus all records from left side will be emitted. So the comment is not very accurate. It's like even if the condition is always true, we add a null check on right side for anti join. I will update it.", "author": "maheshk114", "createdAt": "2020-07-23T05:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5MDY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMxMDM3Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459310372", "bodyText": "Thanks! Makes sense now", "author": "pgaref", "createdAt": "2020-07-23T09:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5MDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNTQ1Ng==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458205456", "bodyText": "Makes sense, for this particular purpose in the future we could something like The opossite bloom filter to support such cases\nhttps://github.com/jmhodges/opposite_of_a_bloom_filter/", "author": "pgaref", "createdAt": "2020-07-21T15:52:55Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/SyntheticJoinPredicate.java", "diffHunk": "@@ -339,6 +339,12 @@ String getFuncText(String funcText, final int srcPos) {\n           vector.add(right, left);\n           break;\n         case JoinDesc.LEFT_OUTER_JOIN:\n+        case JoinDesc.ANTI_JOIN:\n+        //TODO : In case of anti join, bloom filter can be created on left side also (\"IN (keylist right table)\").\n+        // But the filter should be \"not-in\" (\"NOT IN (keylist right table)\") as we want to select the records from\n+        // left side which are not present in the right side. But it may cause wrong result as\n+        // bloom filter may have false positive and thus simply adding not is not correct,\n+        // special handling is required for \"NOT IN\".", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5ODgwNw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458498807", "bodyText": "Could we create a follow-up JIRA to explore this?", "author": "jcamachor", "createdAt": "2020-07-22T02:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxNjg3OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459216878", "bodyText": "created a Jira ..https://issues.apache.org/jira/browse/HIVE-23903", "author": "maheshk114", "createdAt": "2020-07-23T05:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMwODk4Ng==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459308986", "bodyText": "Thank Mahesh! Had this in the back of my head for a while -- this will be useful for a bunch of cases including anti-joins", "author": "pgaref", "createdAt": "2020-07-23T09:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNTk1OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458205958", "bodyText": "Shall we open a ticket to track this? What is the main challenge here?", "author": "pgaref", "createdAt": "2020-07-21T15:53:34Z", "path": "ql/src/test/org/apache/hadoop/hive/ql/exec/vector/mapjoin/TestMapJoinOperator.java", "diffHunk": "@@ -1792,6 +1794,8 @@ private void executeTest(MapJoinTestDescription testDesc, MapJoinTestData testDa\n     case FULL_OUTER:\n       executeTestFullOuter(testDesc, testData, title);\n       break;\n+    case ANTI: //TODO", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIxOTk2Ng==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459219966", "bodyText": "https://issues.apache.org/jira/browse/HIVE-23904", "author": "maheshk114", "createdAt": "2020-07-23T05:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNTk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMDA5Mw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457830093", "bodyText": "nit. Fwd -> Forward", "author": "jcamachor", "createdAt": "2020-07-21T04:33:15Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java", "diffHunk": "@@ -509,11 +513,17 @@ protected void addToAliasFilterTags(byte alias, List<Object> object, boolean isN\n     }\n   }\n \n+  private void createForwardJoinObjectForAntiJoin(boolean[] skip) throws HiveException {\n+    boolean forward = fillFwdCache(skip);", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMTM4NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460521384", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMDA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMTQwOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457831408", "bodyText": "hasAntiJoin -> hasLeftAntiSemiJoin\nAccordingly in other places. This fits well with other logic where you use isSemiJoin boolean... Now it is less ambiguous that it applies to both.", "author": "jcamachor", "createdAt": "2020-07-21T04:39:03Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java", "diffHunk": "@@ -153,6 +153,8 @@\n \n   transient boolean hasLeftSemiJoin = false;\n \n+  transient boolean hasAntiJoin = false;", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMTA1Ng==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460521056", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMTQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMjA5NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457832094", "bodyText": "Can we create a JIRA for this and link it to HIVE-23716?", "author": "jcamachor", "createdAt": "2020-07-21T04:41:56Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/mapjoin/VectorMapJoinAntiJoinGenerateResultOperator.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hive.ql.exec.vector.mapjoin;\n+\n+import org.apache.hadoop.hive.ql.CompilationOpContext;\n+import org.apache.hadoop.hive.ql.exec.JoinUtil;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizationContext;\n+import org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\n+import org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashSet;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashSetResult;\n+import org.apache.hadoop.hive.ql.exec.vector.mapjoin.hashtable.VectorMapJoinHashTableResult;\n+import org.apache.hadoop.hive.ql.metadata.HiveException;\n+import org.apache.hadoop.hive.ql.plan.OperatorDesc;\n+import org.apache.hadoop.hive.ql.plan.VectorDesc;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+\n+// TODO : This class is duplicate of semi join. Need to do a refactoring to merge it with semi join.", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMDczNA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459220734", "bodyText": "https://issues.apache.org/jira/browse/HIVE-23905", "author": "maheshk114", "createdAt": "2020-07-23T05:25:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMjA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMzE2MA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457833160", "bodyText": "Why is HiveAntiJoinFactoryImpl extending SemiJoinFactory? I think it is not used... Can we remove it?", "author": "jcamachor", "createdAt": "2020-07-21T04:45:54Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelFactories.java", "diffHunk": "@@ -188,6 +193,20 @@ public RelNode createSemiJoin(RelNode left, RelNode right,\n     }\n   }\n \n+  /**\n+   * Implementation of {@link AntiJoinFactory} that returns\n+   * {@link org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveAntiJoin}\n+   * .\n+   */\n+  private static class HiveAntiJoinFactoryImpl implements SemiJoinFactory {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMDkzMA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460520930", "bodyText": "HiveAntiJoinFactoryImpl is removed", "author": "maheshk114", "createdAt": "2020-07-26T12:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMzQ5MA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457833490", "bodyText": "Not currently part of the HiveRelNode interface? What does that mean? HiveAntiJoin is implementing HiveRelNode.", "author": "jcamachor", "createdAt": "2020-07-21T04:47:17Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelOptMaterializationValidator.java", "diffHunk": "@@ -253,6 +256,14 @@ private RelNode visit(HiveSemiJoin semiJoin) {\n     return visitChildren(semiJoin);\n   }\n \n+  // Note: Not currently part of the HiveRelNode interface\n+  private RelNode visit(HiveAntiJoin antiJoin) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMDkwMw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460520903", "bodyText": "Not sure ..copy pasted from semi join.", "author": "maheshk114", "createdAt": "2020-07-26T12:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMzQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzNDI5MA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457834290", "bodyText": "This is interesting. An antijoin of a PK-FK join returns no rows? Can we create a JIRA for such optimization based on integrity constraints?", "author": "jcamachor", "createdAt": "2020-07-21T04:50:19Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelOptUtil.java", "diffHunk": "@@ -747,7 +747,7 @@ public static RewritablePKFKJoinInfo isRewritablePKFKJoin(Join join,\n     final RelNode nonFkInput = leftInputPotentialFK ? join.getRight() : join.getLeft();\n     final RewritablePKFKJoinInfo nonRewritable = RewritablePKFKJoinInfo.of(false, null);\n \n-    if (joinType != JoinRelType.INNER && !join.isSemiJoin()) {\n+    if (joinType != JoinRelType.INNER && !join.isSemiJoin() && joinType != JoinRelType.ANTI) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI1MzM5Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459253392", "bodyText": "https://issues.apache.org/jira/browse/HIVE-23906", "author": "maheshk114", "createdAt": "2020-07-23T07:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzNDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzNDY0Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457834642", "bodyText": "Should we add precondition for semiJoinType that is either SEMI or ANTI?", "author": "jcamachor", "createdAt": "2020-07-21T04:51:32Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveSubQRemoveRelBuilder.java", "diffHunk": "@@ -1112,7 +1112,7 @@ public RexNode field(RexNode e, String name) {\n   }\n \n   public HiveSubQRemoveRelBuilder join(JoinRelType joinType, RexNode condition,\n-                                       Set<CorrelationId> variablesSet, boolean createSemiJoin) {\n+                                       Set<CorrelationId> variablesSet, JoinRelType semiJoinType) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUyMDY0Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460520647", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzNDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzNTAwMA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r457835000", "bodyText": "Can we add a comment explaining what joinFilter holds?\nIs this an aux data structure? Will condition in Join hold the full condition? I am asking because it is important that digest contains the full condition so Calcite does not think that two operators are equivalent when they are not.", "author": "jcamachor", "createdAt": "2020-07-21T04:52:51Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/reloperators/HiveAntiJoin.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.reloperators;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.CalciteSemanticException;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.HiveRelOptUtil;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.HiveRulesRegistry;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class HiveAntiJoin extends Join implements HiveRelNode {\n+\n+  private final RexNode joinFilter;", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNTk3Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459825977", "bodyText": "The joinjoinFilter holds the residual filter which is used during post processing. These are the join conditions that are not part of the join key. I think condition in Join hold the full condition.", "author": "maheshk114", "createdAt": "2020-07-24T02:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzNTAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0MzAyMQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458343021", "bodyText": "I wonder whether we really need all these operator variants at this stage. In Calcite, it all seems to be based on a single Join class in newer releases. Can we create a follow-up JIRA to explore whether we could merge HiveJoin, HiveSemiJoin, and HiveAntiSemiJoin?", "author": "jcamachor", "createdAt": "2020-07-21T19:41:09Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/reloperators/HiveAntiJoin.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.reloperators;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.CalciteSemanticException;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.HiveRelOptUtil;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.rules.HiveRulesRegistry;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class HiveAntiJoin extends Join implements HiveRelNode {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNjYzNg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459826636", "bodyText": "https://issues.apache.org/jira/browse/HIVE-23919", "author": "maheshk114", "createdAt": "2020-07-24T02:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0MzAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0MzE1OQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458343159", "bodyText": "nit. spacing", "author": "jcamachor", "createdAt": "2020-07-21T19:41:27Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinAddNotNullRule.java", "diffHunk": "@@ -56,6 +57,9 @@\n   public static final HiveJoinAddNotNullRule INSTANCE_SEMIJOIN =\n       new HiveJoinAddNotNullRule(HiveSemiJoin.class, HiveRelFactories.HIVE_FILTER_FACTORY);\n \n+  public static final HiveJoinAddNotNullRule INSTANCE_ANTIJOIN =\n+          new HiveJoinAddNotNullRule(HiveAntiJoin.class, HiveRelFactories.HIVE_FILTER_FACTORY);", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxOTUyMw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460519523", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0MzE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0Nzc4OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458347788", "bodyText": "This condition does not seem correct (I think the example you provided in the comment is different case).\n\nWhen join.getCondition().isAlwaysTrue(), we always bail out because we cannot introduce is not null condition on any key column (how can you know on which keys you would be filtering?).\nFor full outer join, we bail out because even non-matching rows from any of the inputs should still produce output rows.\nFor left anti join, as you did below, we introduce is not null filter on the right side. This only happens if condition is not always true.", "author": "jcamachor", "createdAt": "2020-07-21T19:49:56Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinAddNotNullRule.java", "diffHunk": "@@ -74,7 +78,14 @@ public HiveJoinAddNotNullRule(Class<? extends Join> clazz,\n   @Override\n   public void onMatch(RelOptRuleCall call) {\n     Join join = call.rel(0);\n-    if (join.getJoinType() == JoinRelType.FULL || join.getCondition().isAlwaysTrue()) {\n+\n+    // For anti join case add the not null on right side if the condition is\n+    // always true. This is done because during execution, anti join expect the right side to\n+    // be empty and if we dont put null check on right, for null only right side table and condition\n+    // always true, execution will produce 0 records.\n+    // eg  select * from left_tbl where (select 1 from all_null_right limit 1) is null\n+    if (join.getJoinType() == JoinRelType.FULL ||\n+            (join.getJoinType() != JoinRelType.ANTI && join.getCondition().isAlwaysTrue())) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyNzAwMg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459827002", "bodyText": "Yes, the comment is not proper. It's like we will add a not null condition for anti join even if the condition is always true.", "author": "maheshk114", "createdAt": "2020-07-24T02:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0Nzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0ODUwMg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458348502", "bodyText": "LEFT_ANTI_SEMI ?", "author": "jcamachor", "createdAt": "2020-07-21T19:51:14Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/plan/VectorMapJoinDesc.java", "diffHunk": "@@ -89,7 +89,8 @@ public PrimitiveTypeInfo getPrimitiveTypeInfo() {\n     INNER_BIG_ONLY,\n     LEFT_SEMI,\n     OUTER,\n-    FULL_OUTER\n+    FULL_OUTER,\n+    ANTI", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxOTExMQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460519111", "bodyText": "LEFT_ANTI", "author": "maheshk114", "createdAt": "2020-07-26T12:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM0ODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5OTM3Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458399377", "bodyText": "This is not correct and needs further thinking. If we have a PK-FK join that is only appending columns to the FK side, it basically means it is not filtering anything (everything is matching). If that is the case, then ANTIJOIN result would be empty? We could detect this at planning time and trigger the rewriting.\nCould we bail out from the rule if it is an ANTIJOIN and create a follow-up JIRA to tackle this and introduce further tests?", "author": "jcamachor", "createdAt": "2020-07-21T21:29:34Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinConstraintsRule.java", "diffHunk": "@@ -100,7 +100,8 @@ public void onMatch(RelOptRuleCall call) {\n     // These boolean values represent corresponding left, right input which is potential FK\n     boolean leftInputPotentialFK = topRefs.intersects(leftBits);\n     boolean rightInputPotentialFK = topRefs.intersects(rightBits);\n-    if (leftInputPotentialFK && rightInputPotentialFK && (joinType == JoinRelType.INNER || joinType == JoinRelType.SEMI)) {\n+    if (leftInputPotentialFK && rightInputPotentialFK &&\n+            (joinType == JoinRelType.INNER || joinType == JoinRelType.SEMI || joinType == JoinRelType.ANTI)) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0MDEzOQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459840139", "bodyText": "https://issues.apache.org/jira/browse/HIVE-23920", "author": "maheshk114", "createdAt": "2020-07-24T03:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5OTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwODE2OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458408168", "bodyText": "Why is this rule skipped if it is an ANTI join? It seems this rule could be straightforward. Should we create a follow-up JIRA?", "author": "jcamachor", "createdAt": "2020-07-21T21:48:00Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinProjectTransposeRule.java", "diffHunk": "@@ -133,6 +135,10 @@ private HiveJoinProjectTransposeRuleBase(\n \n     public void onMatch(RelOptRuleCall call) {\n       //TODO: this can be removed once CALCITE-3824 is released\n+      Join joinRel = call.rel(0);\n+      if (joinRel.getJoinType() == JoinRelType.ANTI) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0MTA4Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459841087", "bodyText": "This was causing some issue with having clause. https://issues.apache.org/jira/browse/HIVE-23921", "author": "maheshk114", "createdAt": "2020-07-24T03:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwODE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ0NzEwOQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458447109", "bodyText": "Rename HiveJoinWithFilterToAntiJoinRule to HiveAntiSemiJoinRule to follow naming convention for other rules, e.g., HiveSemiJoinRule.", "author": "jcamachor", "createdAt": "2020-07-21T23:30:48Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinWithFilterToAntiJoinRule.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveJoinWithFilterToAntiJoinRule extends RelOptRule {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxODk3NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460518974", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ0NzEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NzYyNA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458467624", "bodyText": "projectsRight() is always true for LEFT join, this condition can be simplified.", "author": "jcamachor", "createdAt": "2020-07-22T00:40:44Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinWithFilterToAntiJoinRule.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveJoinWithFilterToAntiJoinRule extends RelOptRule {\n+  protected static final Logger LOG = LoggerFactory.getLogger(HiveJoinWithFilterToAntiJoinRule.class);\n+  public static final HiveJoinWithFilterToAntiJoinRule INSTANCE = new HiveJoinWithFilterToAntiJoinRule();\n+\n+  //    HiveProject(fld=[$0])\n+  //      HiveFilter(condition=[IS NULL($1)])\n+  //        HiveJoin(condition=[=($0, $1)], joinType=[left], algorithm=[none], cost=[not available])\n+  //\n+  // TO\n+  //\n+  //    HiveProject(fld_tbl=[$0])\n+  //      HiveAntiJoin(condition=[=($0, $1)], joinType=[anti])\n+  //\n+  public HiveJoinWithFilterToAntiJoinRule() {\n+    super(operand(Project.class, operand(Filter.class, operand(Join.class, RelOptRule.any()))),\n+            \"HiveJoinWithFilterToAntiJoinRule:filter\");\n+  }\n+\n+  // is null filter over a left join.\n+  public void onMatch(final RelOptRuleCall call) {\n+    final Project project = call.rel(0);\n+    final Filter filter = call.rel(1);\n+    final Join join = call.rel(2);\n+    perform(call, project, filter, join);\n+  }\n+\n+  protected void perform(RelOptRuleCall call, Project project, Filter filter, Join join) {\n+    LOG.debug(\"Matched HiveAntiJoinRule\");\n+\n+    if (join.getCondition().isAlwaysTrue()) {\n+      return;\n+    }\n+\n+    //We support conversion from left outer join only.\n+    if (join.getJoinType() != JoinRelType.LEFT) {\n+      return;\n+    }\n+\n+    assert (filter != null);\n+\n+    List<RexNode> aboveFilters = RelOptUtil.conjunctions(filter.getCondition());\n+    boolean hasIsNull = false;\n+\n+    // Get all filter condition and check if any of them is a \"is null\" kind.\n+    for (RexNode filterNode : aboveFilters) {\n+      if (filterNode.getKind() == SqlKind.IS_NULL &&\n+              isFilterFromRightSide(join, filterNode, join.getJoinType())) {\n+        hasIsNull = true;\n+        break;\n+      }\n+    }\n+\n+    // Is null should be on a key from right side of the join.\n+    if (!hasIsNull) {\n+      return;\n+    }\n+\n+    // Build anti join with same left, right child and condition as original left outer join.\n+    Join anti = join.copy(join.getTraitSet(), join.getCondition(),\n+            join.getLeft(), join.getRight(), JoinRelType.ANTI, false);\n+\n+    //TODO : Do we really need it\n+    call.getPlanner().onCopy(join, anti);\n+\n+    RelNode newProject = getNewProjectNode(project, anti);\n+    if (newProject != null) {\n+      call.getPlanner().onCopy(project, newProject);\n+      call.transformTo(newProject);\n+    }\n+  }\n+\n+  protected RelNode getNewProjectNode(Project oldProject, Join newJoin) {\n+    List<RelDataTypeField> newJoinFiledList = newJoin.getRowType().getFieldList();\n+    List<RexNode> newProjectExpr = new ArrayList<>();\n+    for (RexNode field : oldProject.getProjects()) {\n+      if (!(field instanceof  RexInputRef)) {\n+        return null;\n+      }\n+      int idx = ((RexInputRef)field).getIndex();\n+      if (idx > newJoinFiledList.size()) {\n+        LOG.debug(\" Project filed \" + ((RexInputRef) field).getName() +\n+                \" is from right side of join. Can not convert to anti join.\");\n+        return null;\n+      }\n+\n+      final RexInputRef ref = newJoin.getCluster().getRexBuilder()\n+              .makeInputRef(field.getType(), idx);\n+      newProjectExpr.add(ref);\n+    }\n+    return oldProject.copy(oldProject.getTraitSet(), newJoin, newProjectExpr, oldProject.getRowType());\n+  }\n+\n+  private boolean isFilterFromRightSide(RelNode joinRel, RexNode filter, JoinRelType joinType) {\n+    List<RelDataTypeField> joinFields = joinRel.getRowType().getFieldList();\n+    int nTotalFields = joinFields.size();\n+\n+    List<RelDataTypeField> leftFields = (joinRel.getInputs().get(0)).getRowType().getFieldList();\n+    int nFieldsLeft = leftFields.size();\n+    List<RelDataTypeField> rightFields = (joinRel.getInputs().get(1)).getRowType().getFieldList();\n+    int nFieldsRight = rightFields.size();\n+    assert nTotalFields == (!joinType.projectsRight() ? nFieldsLeft : nFieldsLeft + nFieldsRight);", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxODgxNw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460518817", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NzYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2ODAyOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458468028", "bodyText": "No need for this line indeed.", "author": "jcamachor", "createdAt": "2020-07-22T00:42:14Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinWithFilterToAntiJoinRule.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveJoinWithFilterToAntiJoinRule extends RelOptRule {\n+  protected static final Logger LOG = LoggerFactory.getLogger(HiveJoinWithFilterToAntiJoinRule.class);\n+  public static final HiveJoinWithFilterToAntiJoinRule INSTANCE = new HiveJoinWithFilterToAntiJoinRule();\n+\n+  //    HiveProject(fld=[$0])\n+  //      HiveFilter(condition=[IS NULL($1)])\n+  //        HiveJoin(condition=[=($0, $1)], joinType=[left], algorithm=[none], cost=[not available])\n+  //\n+  // TO\n+  //\n+  //    HiveProject(fld_tbl=[$0])\n+  //      HiveAntiJoin(condition=[=($0, $1)], joinType=[anti])\n+  //\n+  public HiveJoinWithFilterToAntiJoinRule() {\n+    super(operand(Project.class, operand(Filter.class, operand(Join.class, RelOptRule.any()))),\n+            \"HiveJoinWithFilterToAntiJoinRule:filter\");\n+  }\n+\n+  // is null filter over a left join.\n+  public void onMatch(final RelOptRuleCall call) {\n+    final Project project = call.rel(0);\n+    final Filter filter = call.rel(1);\n+    final Join join = call.rel(2);\n+    perform(call, project, filter, join);\n+  }\n+\n+  protected void perform(RelOptRuleCall call, Project project, Filter filter, Join join) {\n+    LOG.debug(\"Matched HiveAntiJoinRule\");\n+\n+    if (join.getCondition().isAlwaysTrue()) {\n+      return;\n+    }\n+\n+    //We support conversion from left outer join only.\n+    if (join.getJoinType() != JoinRelType.LEFT) {\n+      return;\n+    }\n+\n+    assert (filter != null);\n+\n+    List<RexNode> aboveFilters = RelOptUtil.conjunctions(filter.getCondition());\n+    boolean hasIsNull = false;\n+\n+    // Get all filter condition and check if any of them is a \"is null\" kind.\n+    for (RexNode filterNode : aboveFilters) {\n+      if (filterNode.getKind() == SqlKind.IS_NULL &&\n+              isFilterFromRightSide(join, filterNode, join.getJoinType())) {\n+        hasIsNull = true;\n+        break;\n+      }\n+    }\n+\n+    // Is null should be on a key from right side of the join.\n+    if (!hasIsNull) {\n+      return;\n+    }\n+\n+    // Build anti join with same left, right child and condition as original left outer join.\n+    Join anti = join.copy(join.getTraitSet(), join.getCondition(),\n+            join.getLeft(), join.getRight(), JoinRelType.ANTI, false);\n+\n+    //TODO : Do we really need it\n+    call.getPlanner().onCopy(join, anti);", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxODgwOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460518808", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2ODAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2ODA4MQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458468081", "bodyText": "This call is not necessary either.", "author": "jcamachor", "createdAt": "2020-07-22T00:42:29Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinWithFilterToAntiJoinRule.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveJoinWithFilterToAntiJoinRule extends RelOptRule {\n+  protected static final Logger LOG = LoggerFactory.getLogger(HiveJoinWithFilterToAntiJoinRule.class);\n+  public static final HiveJoinWithFilterToAntiJoinRule INSTANCE = new HiveJoinWithFilterToAntiJoinRule();\n+\n+  //    HiveProject(fld=[$0])\n+  //      HiveFilter(condition=[IS NULL($1)])\n+  //        HiveJoin(condition=[=($0, $1)], joinType=[left], algorithm=[none], cost=[not available])\n+  //\n+  // TO\n+  //\n+  //    HiveProject(fld_tbl=[$0])\n+  //      HiveAntiJoin(condition=[=($0, $1)], joinType=[anti])\n+  //\n+  public HiveJoinWithFilterToAntiJoinRule() {\n+    super(operand(Project.class, operand(Filter.class, operand(Join.class, RelOptRule.any()))),\n+            \"HiveJoinWithFilterToAntiJoinRule:filter\");\n+  }\n+\n+  // is null filter over a left join.\n+  public void onMatch(final RelOptRuleCall call) {\n+    final Project project = call.rel(0);\n+    final Filter filter = call.rel(1);\n+    final Join join = call.rel(2);\n+    perform(call, project, filter, join);\n+  }\n+\n+  protected void perform(RelOptRuleCall call, Project project, Filter filter, Join join) {\n+    LOG.debug(\"Matched HiveAntiJoinRule\");\n+\n+    if (join.getCondition().isAlwaysTrue()) {\n+      return;\n+    }\n+\n+    //We support conversion from left outer join only.\n+    if (join.getJoinType() != JoinRelType.LEFT) {\n+      return;\n+    }\n+\n+    assert (filter != null);\n+\n+    List<RexNode> aboveFilters = RelOptUtil.conjunctions(filter.getCondition());\n+    boolean hasIsNull = false;\n+\n+    // Get all filter condition and check if any of them is a \"is null\" kind.\n+    for (RexNode filterNode : aboveFilters) {\n+      if (filterNode.getKind() == SqlKind.IS_NULL &&\n+              isFilterFromRightSide(join, filterNode, join.getJoinType())) {\n+        hasIsNull = true;\n+        break;\n+      }\n+    }\n+\n+    // Is null should be on a key from right side of the join.\n+    if (!hasIsNull) {\n+      return;\n+    }\n+\n+    // Build anti join with same left, right child and condition as original left outer join.\n+    Join anti = join.copy(join.getTraitSet(), join.getCondition(),\n+            join.getLeft(), join.getRight(), JoinRelType.ANTI, false);\n+\n+    //TODO : Do we really need it\n+    call.getPlanner().onCopy(join, anti);\n+\n+    RelNode newProject = getNewProjectNode(project, anti);\n+    if (newProject != null) {\n+      call.getPlanner().onCopy(project, newProject);", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxODc5OQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460518799", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T12:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2ODA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MjEyMg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458472122", "bodyText": "We should simply use project.copy and remove this method (it seems we are also limiting it to RexInputRef... why is that done?).\nYou can verify that all fields are coming from left input using isFilterFromRightSide; in fact, you can rename it to isExprFromRightSide and pass a list of RexNode as second parameter. If they do not, just bail out similarly to what you do with the filter. Please, check whether such method already exists (e.g., in HiveCalciteUtil or RexUtil) so we do not re-implement it if it does.", "author": "jcamachor", "createdAt": "2020-07-22T00:57:06Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinWithFilterToAntiJoinRule.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveJoinWithFilterToAntiJoinRule extends RelOptRule {\n+  protected static final Logger LOG = LoggerFactory.getLogger(HiveJoinWithFilterToAntiJoinRule.class);\n+  public static final HiveJoinWithFilterToAntiJoinRule INSTANCE = new HiveJoinWithFilterToAntiJoinRule();\n+\n+  //    HiveProject(fld=[$0])\n+  //      HiveFilter(condition=[IS NULL($1)])\n+  //        HiveJoin(condition=[=($0, $1)], joinType=[left], algorithm=[none], cost=[not available])\n+  //\n+  // TO\n+  //\n+  //    HiveProject(fld_tbl=[$0])\n+  //      HiveAntiJoin(condition=[=($0, $1)], joinType=[anti])\n+  //\n+  public HiveJoinWithFilterToAntiJoinRule() {\n+    super(operand(Project.class, operand(Filter.class, operand(Join.class, RelOptRule.any()))),\n+            \"HiveJoinWithFilterToAntiJoinRule:filter\");\n+  }\n+\n+  // is null filter over a left join.\n+  public void onMatch(final RelOptRuleCall call) {\n+    final Project project = call.rel(0);\n+    final Filter filter = call.rel(1);\n+    final Join join = call.rel(2);\n+    perform(call, project, filter, join);\n+  }\n+\n+  protected void perform(RelOptRuleCall call, Project project, Filter filter, Join join) {\n+    LOG.debug(\"Matched HiveAntiJoinRule\");\n+\n+    if (join.getCondition().isAlwaysTrue()) {\n+      return;\n+    }\n+\n+    //We support conversion from left outer join only.\n+    if (join.getJoinType() != JoinRelType.LEFT) {\n+      return;\n+    }\n+\n+    assert (filter != null);\n+\n+    List<RexNode> aboveFilters = RelOptUtil.conjunctions(filter.getCondition());\n+    boolean hasIsNull = false;\n+\n+    // Get all filter condition and check if any of them is a \"is null\" kind.\n+    for (RexNode filterNode : aboveFilters) {\n+      if (filterNode.getKind() == SqlKind.IS_NULL &&\n+              isFilterFromRightSide(join, filterNode, join.getJoinType())) {\n+        hasIsNull = true;\n+        break;\n+      }\n+    }\n+\n+    // Is null should be on a key from right side of the join.\n+    if (!hasIsNull) {\n+      return;\n+    }\n+\n+    // Build anti join with same left, right child and condition as original left outer join.\n+    Join anti = join.copy(join.getTraitSet(), join.getCondition(),\n+            join.getLeft(), join.getRight(), JoinRelType.ANTI, false);\n+\n+    //TODO : Do we really need it\n+    call.getPlanner().onCopy(join, anti);\n+\n+    RelNode newProject = getNewProjectNode(project, anti);\n+    if (newProject != null) {\n+      call.getPlanner().onCopy(project, newProject);\n+      call.transformTo(newProject);\n+    }\n+  }\n+\n+  protected RelNode getNewProjectNode(Project oldProject, Join newJoin) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NDE3MQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459984171", "bodyText": "I didn't find any such utility method, so added this into HiveCalciteUtil and used.", "author": "maheshk114", "createdAt": "2020-07-24T10:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MjEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MzQ4Ng==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458473486", "bodyText": "nit. space before =", "author": "jcamachor", "createdAt": "2020-07-22T01:02:14Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveRemoveGBYSemiJoinRule.java", "diffHunk": "@@ -41,17 +41,19 @@\n \n   public HiveRemoveGBYSemiJoinRule() {\n     super(\n-        operand(HiveSemiJoin.class,\n+        operand(Join.class,\n             some(\n                 operand(RelNode.class, any()),\n                 operand(Aggregate.class, any()))),\n         HiveRelFactories.HIVE_BUILDER, \"HiveRemoveGBYSemiJoinRule\");\n   }\n \n   @Override public void onMatch(RelOptRuleCall call) {\n-    final HiveSemiJoin semijoin= call.rel(0);\n+    final Join join= call.rel(0);", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNTI1Nw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460515257", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-26T11:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3MzQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3NDg5MA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458474890", "bodyText": "This does not seem to be the case anymore? Should we remove? Otherwise, please create a follow-up JIRA.", "author": "jcamachor", "createdAt": "2020-07-22T01:07:51Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveSubQueryRemoveRule.java", "diffHunk": "@@ -414,6 +416,13 @@ private RexNode rewriteInExists(RexSubQuery e, Set<CorrelationId> variablesSet,\n       // null keys we do not need to generate count(*), count(c)\n       if (e.getKind() == SqlKind.EXISTS) {\n         logic = RelOptUtil.Logic.TRUE_FALSE;\n+        if (conf.getBoolVar(HiveConf.ConfVars.HIVE_CONVERT_ANTI_JOIN)) {\n+          //TODO : As of now anti join is first converted to left outer join", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NjMyOQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459986329", "bodyText": "Now also the conversion is not done. The code is present but actual conversion is not done and logic is still TRUE_FALSE. For the code to be effective , the logic should be changed to FALSE. I have not done it yet, as it was causing some change in plan which i could not judge to be expected or not. Anyways i have created a JIRA to track this.\nhttps://issues.apache.org/jira/browse/HIVE-23928", "author": "maheshk114", "createdAt": "2020-07-24T11:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3NDg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3OTg5NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458479894", "bodyText": "Did you verify whether super method handles ANTI join? Not a blocker but we may need to create a follow-up JIRA if it does not.", "author": "jcamachor", "createdAt": "2020-07-22T01:26:16Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/stats/HiveRelMdDistinctRowCount.java", "diffHunk": "@@ -79,6 +80,11 @@ public Double getDistinctRowCount(HiveSemiJoin rel, RelMetadataQuery mq, Immutab\n     return super.getDistinctRowCount(rel, mq, groupKey, predicate);\n   }\n \n+  public Double getDistinctRowCount(HiveAntiJoin rel, RelMetadataQuery mq, ImmutableBitSet groupKey,\n+                                    RexNode predicate) {\n+    return super.getDistinctRowCount(rel, mq, groupKey, predicate);", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4ODIxNA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459988214", "bodyText": "calcite 21 does not support distinct calculation for Anti join.\nif (join.isSemiJoin()) {\nreturn getSemiJoinDistinctRowCount(join, mq, groupKey, predicate);\n} else {\nBuilder leftMask = ImmutableBitSet.builder();\nI think these rules will not get triggered as of now for Anti join as i am not converting the not-exists to anti join. As of now all these rules will be applied on left outer and then we convert the left outer to anti join.\nI", "author": "maheshk114", "createdAt": "2020-07-24T11:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3OTg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxODQ1NA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460518454", "bodyText": "https://issues.apache.org/jira/browse/HIVE-23933", "author": "maheshk114", "createdAt": "2020-07-26T11:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3OTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4Mjk2Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458482962", "bodyText": "Logic for antijoin would be slightly different?\nreturn pkfk.fkInfo.rowCount * (1-selectivity);\n\nYou had similar change below. Does that make sense?\nIn addition, does super.getRowCount(rel, mq) handle antijoin correctly?", "author": "jcamachor", "createdAt": "2020-07-22T01:37:32Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/stats/HiveRelMdRowCount.java", "diffHunk": "@@ -118,6 +119,15 @@ public Double getRowCount(HiveJoin join, RelMetadataQuery mq) {\n   }\n \n   public Double getRowCount(HiveSemiJoin rel, RelMetadataQuery mq) {\n+    return getRowCountInt(rel, mq);\n+  }\n+\n+  public Double getRowCount(HiveAntiJoin rel, RelMetadataQuery mq) {\n+    return getRowCountInt(rel, mq);\n+  }\n+\n+  private Double getRowCountInt(Join rel, RelMetadataQuery mq) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxNTY5NQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460515695", "bodyText": "Yes done.", "author": "maheshk114", "createdAt": "2020-07-26T11:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4Mjk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDUxODQxMQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460518411", "bodyText": "super.getRowCount(rel, mq) does not support Anti join. I think we need to handle it.\nhttps://issues.apache.org/jira/browse/HIVE-23933", "author": "maheshk114", "createdAt": "2020-07-26T11:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4Mjk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5MjQ3MA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458492470", "bodyText": "We can probably remove j instanceof HiveJoin?", "author": "jcamachor", "createdAt": "2020-07-22T02:12:29Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/stats/HiveRelMdSelectivity.java", "diffHunk": "@@ -142,7 +146,7 @@ private Double computeInnerJoinSelectivity(Join j, RelMetadataQuery mq, RexNode\n         ndvEstimate = exponentialBackoff(peLst, colStatMap);\n       }\n \n-      if (j.isSemiJoin()) {\n+      if (j.isSemiJoin() || (j instanceof HiveJoin && j.getJoinType().equals(JoinRelType.ANTI))) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMjI2MQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460002261", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-24T11:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5MjQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5NDkwMQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458494901", "bodyText": "Shouldn't we use result=0?\nIf we estimated that the result of the inner join is going to be larger than the left input, it seems we should assume that nothing is going to come out of the anti join?", "author": "jcamachor", "createdAt": "2020-07-22T02:21:32Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2606,6 +2607,17 @@ private long computeFinalRowCount(List<Long> rowCountParents, long interimRowCou\n           // max # of rows = rows from left side\n           result = Math.min(rowCountParents.get(joinCond.getLeft()), result);\n           break;\n+        case JoinDesc.ANTI_JOIN:\n+          long leftRowCount = rowCountParents.get(joinCond.getLeft());\n+          if (leftRowCount < result) {\n+            // Ideally the inner join count should be less than the left row count. but if its not calculated\n+            // properly then we can assume whole of left table will be selected.\n+            result = leftRowCount;", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMTkyNQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460001925", "bodyText": "This case will come if the stats are not proper. So to be on safer side, i assume that all rows from the left side will be projected. That is the max value. If set it to 0, it should not trigger some re-write, assuming the join result is empty.", "author": "maheshk114", "createdAt": "2020-07-24T11:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5NDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5NTkyMQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458495921", "bodyText": "Can we make this block part of the applyPostJoinOrderingTransform, in particular before/after steps 3 and 4 in that method (those steps relate to semijoin conversion)?", "author": "jcamachor", "createdAt": "2020-07-22T02:25:14Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -1901,6 +1905,11 @@ public RelNode apply(RelOptCluster cluster, RelOptSchema relOptSchema, SchemaPlu\n       calcitePreCboPlan = applyPreJoinOrderingTransforms(calciteGenPlan,\n           mdProvider.getMetadataProvider(), executorProvider);\n \n+      if (conf.getBoolVar(ConfVars.HIVE_CONVERT_ANTI_JOIN)) {", "originalCommit": "ee4390223caf1816ba6c07c1245876dc3c99d1e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAwMTIzNg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r460001236", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-24T11:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5NTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUxMTIyMA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r458511220", "bodyText": "Probably it is here where we do not create the antijoin operator explicitly and why we end up with normal joins in Calcite plan. Since we are creating SemiJoin and AntiJoin as different operators, I think we should follow that pattern here and create an antijoin explicitly or using the builder (you can look at HiveSemiJoinRule). Nevertheless, we could possibly get rid of HiveAntiJoin and HiveSemiJoin all together as I mentioned in another comment, but that can be part of another JIRA.", "author": "jcamachor", "createdAt": "2020-07-22T03:24:46Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinWithFilterToAntiJoinRule.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.util.ImmutableBitSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveJoinWithFilterToAntiJoinRule extends RelOptRule {\n+  protected static final Logger LOG = LoggerFactory.getLogger(HiveJoinWithFilterToAntiJoinRule.class);\n+  public static final HiveJoinWithFilterToAntiJoinRule INSTANCE = new HiveJoinWithFilterToAntiJoinRule();\n+\n+  //    HiveProject(fld=[$0])\n+  //      HiveFilter(condition=[IS NULL($1)])\n+  //        HiveJoin(condition=[=($0, $1)], joinType=[left], algorithm=[none], cost=[not available])\n+  //\n+  // TO\n+  //\n+  //    HiveProject(fld_tbl=[$0])\n+  //      HiveAntiJoin(condition=[=($0, $1)], joinType=[anti])\n+  //\n+  public HiveJoinWithFilterToAntiJoinRule() {\n+    super(operand(Project.class, operand(Filter.class, operand(Join.class, RelOptRule.any()))),\n+            \"HiveJoinWithFilterToAntiJoinRule:filter\");\n+  }\n+\n+  // is null filter over a left join.\n+  public void onMatch(final RelOptRuleCall call) {\n+    final Project project = call.rel(0);\n+    final Filter filter = call.rel(1);\n+    final Join join = call.rel(2);\n+    perform(call, project, filter, join);\n+  }\n+\n+  protected void perform(RelOptRuleCall call, Project project, Filter filter, Join join) {\n+    LOG.debug(\"Matched HiveAntiJoinRule\");\n+\n+    assert (filter != null);\n+\n+    //We support conversion from left outer join only.\n+    if (join.getJoinType() != JoinRelType.LEFT) {\n+      return;\n+    }\n+\n+    List<RexNode> aboveFilters = RelOptUtil.conjunctions(filter.getCondition());\n+    boolean hasIsNull = false;\n+\n+    // Get all filter condition and check if any of them is a \"is null\" kind.\n+    for (RexNode filterNode : aboveFilters) {\n+      if (filterNode.getKind() == SqlKind.IS_NULL &&\n+              isFilterFromRightSide(join, filterNode, join.getJoinType())) {\n+        hasIsNull = true;\n+        break;\n+      }\n+    }\n+\n+    // Is null should be on a key from right side of the join.\n+    if (!hasIsNull) {\n+      return;\n+    }\n+\n+    // Build anti join with same left, right child and condition as original left outer join.\n+    Join anti = join.copy(join.getTraitSet(), join.getCondition(),", "originalCommit": "b3631f8c2fcca7895e0ccec324ce55de99c2a4cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5ODg0NQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r459998845", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-07-24T11:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUxMTIyMA=="}], "type": "inlineReview"}, {"oid": "30587265a5085c0f499367ea7bb1ee29e7f98173", "url": "https://github.com/apache/hive/commit/30587265a5085c0f499367ea7bb1ee29e7f98173", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-07-29T18:06:43Z", "type": "forcePushed"}, {"oid": "d655b4a22d69d1f5974c27ee87d96940ba6e8b0b", "url": "https://github.com/apache/hive/commit/d655b4a22d69d1f5974c27ee87d96940ba6e8b0b", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-07-30T04:19:57Z", "type": "forcePushed"}, {"oid": "97da5815b060641e30fbb0da8e0369de1f93531e", "url": "https://github.com/apache/hive/commit/97da5815b060641e30fbb0da8e0369de1f93531e", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-07-30T13:39:44Z", "type": "forcePushed"}, {"oid": "feef4718b1d9064cfd65487153a945778d0c4547", "url": "https://github.com/apache/hive/commit/feef4718b1d9064cfd65487153a945778d0c4547", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-07-30T13:43:26Z", "type": "forcePushed"}, {"oid": "a07f2a2c5c5a03dfff83758a8d66845fa945f08e", "url": "https://github.com/apache/hive/commit/a07f2a2c5c5a03dfff83758a8d66845fa945f08e", "message": "HIVE-23716 : Support Anti Join: review comment fix : outfile change for setting anti join true by default", "committedDate": "2020-07-31T06:52:01Z", "type": "forcePushed"}, {"oid": "50507cf6ed4a744c8789fe2da101024911d4336b", "url": "https://github.com/apache/hive/commit/50507cf6ed4a744c8789fe2da101024911d4336b", "message": "HIVE-23716 : Support Anti Join: review comment fix : outfile change for setting anti join true by default", "committedDate": "2020-07-31T13:05:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDQxOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464630418", "bodyText": "nit. Change comment to javadoc", "author": "jcamachor", "createdAt": "2020-08-03T19:57:24Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveCalciteUtil.java", "diffHunk": "@@ -1233,4 +1233,21 @@ public FixNullabilityShuttle(RexBuilder rexBuilder,\n     }\n   }\n \n+  // Checks if any of the expression given as list expressions are from right side of the join.", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Nzg0MA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465297840", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-08-04T20:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY3MzUwMg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464673502", "bodyText": "Thanks for creating HIVE-23906. Can we simply return nonRewritable if it is an anti-join for the time being, rather than proceeding? This certainly requires a bit of extra thinking and specific tests to make sure it is working as expected (for which we already have HIVE-23906).", "author": "jcamachor", "createdAt": "2020-08-03T21:32:19Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelOptUtil.java", "diffHunk": "@@ -747,6 +747,8 @@ public static RewritablePKFKJoinInfo isRewritablePKFKJoin(Join join,\n     final RelNode nonFkInput = leftInputPotentialFK ? join.getRight() : join.getLeft();\n     final RewritablePKFKJoinInfo nonRewritable = RewritablePKFKJoinInfo.of(false, null);\n \n+    // TODO : Need to handle Anti join.", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NzgwOQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465297809", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-08-04T20:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY3MzUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY3NzczOQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464677739", "bodyText": "Can we remove this change? We will address this in HIVE-23906.", "author": "jcamachor", "createdAt": "2020-08-03T21:42:44Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/HiveRelOptUtil.java", "diffHunk": "@@ -854,7 +856,7 @@ public static RewritablePKFKJoinInfo isRewritablePKFKJoin(Join join,\n             if (ecT.getEquivalenceClassesMap().containsKey(uniqueKeyColumnRef) &&\n                 ecT.getEquivalenceClassesMap().get(uniqueKeyColumnRef).contains(foreignKeyColumnRef)) {\n               if (foreignKeyColumnType.isNullable()) {\n-                if (joinType == JoinRelType.INNER || join.isSemiJoin()) {\n+                if (joinType == JoinRelType.INNER || join.isSemiJoin() || joinType == JoinRelType.ANTI) {", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Nzc3Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465297772", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-08-04T20:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY3NzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4Njk0Mw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464686943", "bodyText": "It seems aboveFilters are ignored but we should not. For instance, condition is AND(func(x,y), z IS NULL), where x comes from the left input, and y and z from the right input. You would still need to apply first conjunct for correctness? Could we try to add such test too?", "author": "jcamachor", "createdAt": "2020-08-03T22:06:11Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveAntiSemiJoinRule.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hive.ql.optimizer.calcite.rules;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.Project;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.HiveCalciteUtil;\n+import org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveAntiJoin;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Planner rule that converts a join plus filter to anti join.\n+ */\n+public class HiveAntiSemiJoinRule extends RelOptRule {\n+  protected static final Logger LOG = LoggerFactory.getLogger(HiveAntiSemiJoinRule.class);\n+  public static final HiveAntiSemiJoinRule INSTANCE = new HiveAntiSemiJoinRule();\n+\n+  //    HiveProject(fld=[$0])\n+  //      HiveFilter(condition=[IS NULL($1)])\n+  //        HiveJoin(condition=[=($0, $1)], joinType=[left], algorithm=[none], cost=[not available])\n+  //\n+  // TO\n+  //\n+  //    HiveProject(fld_tbl=[$0])\n+  //      HiveAntiJoin(condition=[=($0, $1)], joinType=[anti])\n+  //\n+  public HiveAntiSemiJoinRule() {\n+    super(operand(Project.class, operand(Filter.class, operand(Join.class, RelOptRule.any()))),\n+            \"HiveJoinWithFilterToAntiJoinRule:filter\");\n+  }\n+\n+  // is null filter over a left join.\n+  public void onMatch(final RelOptRuleCall call) {\n+    final Project project = call.rel(0);\n+    final Filter filter = call.rel(1);\n+    final Join join = call.rel(2);\n+    perform(call, project, filter, join);\n+  }\n+\n+  protected void perform(RelOptRuleCall call, Project project, Filter filter, Join join) {\n+    LOG.debug(\"Start Matching HiveAntiJoinRule\");\n+\n+    //TODO : Need to support this scenario.\n+    if (join.getCondition().isAlwaysTrue()) {\n+      return;\n+    }\n+\n+    //We support conversion from left outer join only.\n+    if (join.getJoinType() != JoinRelType.LEFT) {\n+      return;\n+    }\n+\n+    assert (filter != null);\n+\n+    // If null filter is not present from right side then we can not convert to anti join.\n+    List<RexNode> aboveFilters = RelOptUtil.conjunctions(filter.getCondition());\n+    Stream<RexNode> nullFilters = aboveFilters.stream().filter(filterNode -> filterNode.getKind() == SqlKind.IS_NULL);\n+    boolean hasNullFilter = HiveCalciteUtil.hasAnyExpressionFromRightSide(join, nullFilters.collect(Collectors.toList()));\n+    if (!hasNullFilter) {\n+      return;\n+    }\n+\n+    // If any projection is there from right side, then we can not convert to anti join.\n+    boolean hasProjection = HiveCalciteUtil.hasAnyExpressionFromRightSide(join, project.getProjects());\n+    if (hasProjection) {\n+      return;\n+    }\n+\n+    LOG.debug(\"Matched HiveAntiJoinRule\");\n+\n+    // Build anti join with same left, right child and condition as original left outer join.\n+    Join anti = HiveAntiJoin.getAntiJoin(join.getLeft().getCluster(), join.getLeft().getTraitSet(),\n+            join.getLeft(), join.getRight(), join.getCondition());\n+    RelNode newProject = project.copy(project.getTraitSet(), anti, project.getProjects(), project.getRowType());\n+    call.transformTo(newProject);", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NzcxOA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465297718", "bodyText": "added some new test cases like select t1.fld from tbl t1 left join tbl1 t2 on t1.fld = t2.fld where t2.fld is null and rand(t2.fld) > 100;\nselect t1.fld from tbl t1 left join tbl1 t2 on t1.fld = t2.fld where t2.fld is null and rand(t1.fld) > 100;\nselect t1.fld from tbl t1 left join tbl1 t2 on t1.fld = t2.fld where t2.fld is null and rand(t1.fld) > 100 and rand(t1.fld) > 2100;\nselect t1.fld from tbl t1 left join tbl2 t2 on t1.fld = t2.fld where t2.fld is null or t2.fld1 is null;\nselect t1.fld from tbl t1 left join tbl2 t2 on t1.fld = t2.fld where t2.fld is null or t2.fld1 = 1;", "author": "maheshk114", "createdAt": "2020-08-04T20:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4Njk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjI5OA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465446298", "bodyText": "Is rand pushed down?\nI was referring specifically about conditions that remain on top of the join (that's why I used a function on columns from multiple inputs). The logic above seems to remove those conditions and they get ignored... but they should not.", "author": "jcamachor", "createdAt": "2020-08-05T03:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4Njk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxOTE0OQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466819149", "bodyText": "for normal filter, its being pushed down. here we get filters which can not be pushed down. I have modified the code to handle those filters. And added these extra tests to verify.  rand  is not pushed down.", "author": "maheshk114", "createdAt": "2020-08-07T04:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4Njk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MjYxMA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464692610", "bodyText": "I did not check the physical implementation in much detail: Just wanted to confirm that you are considering there the case for empty (0 rows) right input, correct? It came to mind as the introduced filter could filter all rows.", "author": "jcamachor", "createdAt": "2020-08-03T22:21:41Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinAddNotNullRule.java", "diffHunk": "@@ -92,7 +104,7 @@ public void onMatch(RelOptRuleCall call) {\n     Set<String> rightPushedPredicates = Sets.newHashSet(registry.getPushedPredicates(join, 1));\n \n     boolean genPredOnLeft = join.getJoinType() == JoinRelType.RIGHT || join.getJoinType() == JoinRelType.INNER || join.isSemiJoin();\n-    boolean genPredOnRight = join.getJoinType() == JoinRelType.LEFT || join.getJoinType() == JoinRelType.INNER || join.isSemiJoin();\n+    boolean genPredOnRight = join.getJoinType() == JoinRelType.LEFT || join.getJoinType() == JoinRelType.INNER || join.isSemiJoin()|| join.getJoinType() == JoinRelType.ANTI;", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NzY2Mw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465297663", "bodyText": "Yes ..if right side is null then it emits all the right side records", "author": "maheshk114", "createdAt": "2020-08-04T20:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MjYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjQ5NQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465446495", "bodyText": "I was referring to empty input (no rows) rather than null.", "author": "jcamachor", "createdAt": "2020-08-05T03:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MjYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgxOTU3Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466819572", "bodyText": "yes ..that is taken care of.\n// For anti join, we should proceed to emit records if the right side is empty or not matching.\nif (type == JoinDesc.ANTI_JOIN && !producedRow) {", "author": "maheshk114", "createdAt": "2020-08-07T04:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MjYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5NjI4Mg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464696282", "bodyText": "This should be removed to avoid confusion, since we bail out above.", "author": "jcamachor", "createdAt": "2020-08-03T22:32:13Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveJoinConstraintsRule.java", "diffHunk": "@@ -183,6 +189,7 @@ public void onMatch(RelOptRuleCall call) {\n     switch (joinType) {\n     case SEMI:\n     case INNER:\n+    case ANTI:", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NzYyNQ==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465297625", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-08-04T20:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5NjI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5ODkxMw==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464698913", "bodyText": "test?", "author": "jcamachor", "createdAt": "2020-08-03T22:40:04Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/ppd/PredicateTransitivePropagate.java", "diffHunk": "@@ -203,6 +203,7 @@ private boolean filterExists(ReduceSinkOperator target, ExprNodeDesc replaced) {\n           vector.add(right, left);\n           break;\n         case JoinDesc.LEFT_OUTER_JOIN:\n+        case JoinDesc.ANTI_JOIN: //TODO : need to test", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NzYwNA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r465297604", "bodyText": "removed the comment.", "author": "maheshk114", "createdAt": "2020-08-04T20:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5ODkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTY5MA==", "url": "https://github.com/apache/hive/pull/1147#discussion_r464705690", "bodyText": "This is concerning. In fact, I believe we should rather apply this rule after join reordering, since there is no support built-in for ANTIJOIN in the reordering algorithm, while there is support for outer join... which could lead to worse join order.\nIf the problem is that the inputs are being swapped, we can add a variant of HiveJoinCommuteRule / JoinCommuteRule to this program that is applied on RIGHT OUTER joins.", "author": "jcamachor", "createdAt": "2020-08-03T23:01:40Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/parse/CalcitePlanner.java", "diffHunk": "@@ -2129,6 +2133,16 @@ private RelNode applyPreJoinOrderingTransforms(RelNode basePlan, RelMetadataProv\n             HiveRemoveSqCountCheck.INSTANCE);\n       }\n \n+      // 10. Convert left outer join + null filter on right side table column to anti join. Add this\n+      // rule after all the optimization for which calcite support for anti join is missing.\n+      // Needs to be done before ProjectRemoveRule as it expect a project over filter.\n+      // This is done before join re-ordering as join re-ordering is converting the left outer", "originalCommit": "50507cf6ed4a744c8789fe2da101024911d4336b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgyMjUxNg==", "url": "https://github.com/apache/hive/pull/1147#discussion_r466822516", "bodyText": "As discussed, i have created a Jira https://issues.apache.org/jira/browse/HIVE-24013", "author": "maheshk114", "createdAt": "2020-08-07T05:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTY5MA=="}], "type": "inlineReview"}, {"oid": "3e5b1daf2c293ca026fd80442a8992192ca49b67", "url": "https://github.com/apache/hive/commit/3e5b1daf2c293ca026fd80442a8992192ca49b67", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-08-04T20:00:06Z", "type": "forcePushed"}, {"oid": "fe22e6c18bc2206db8f3f876ff0d89e01b6bab65", "url": "https://github.com/apache/hive/commit/fe22e6c18bc2206db8f3f876ff0d89e01b6bab65", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-08-04T20:05:31Z", "type": "forcePushed"}, {"oid": "c1ac211dfc6930697225bd06e29aec4f3f5cb84e", "url": "https://github.com/apache/hive/commit/c1ac211dfc6930697225bd06e29aec4f3f5cb84e", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-08-07T04:40:19Z", "type": "forcePushed"}, {"oid": "e90daeeb5132613fc88435bdc0efb578889a26d8", "url": "https://github.com/apache/hive/commit/e90daeeb5132613fc88435bdc0efb578889a26d8", "message": "HIVE-23716 : Support Anti Join in Hive", "committedDate": "2020-08-07T16:47:21Z", "type": "commit"}, {"oid": "441105e1bb9cef4f3db8c8741dc40d678995e65c", "url": "https://github.com/apache/hive/commit/441105e1bb9cef4f3db8c8741dc40d678995e65c", "message": "Added test cases for anti join", "committedDate": "2020-08-07T16:47:21Z", "type": "commit"}, {"oid": "bef0f0fe0fb292a1b2aa1451d626cff6f6bb28fc", "url": "https://github.com/apache/hive/commit/bef0f0fe0fb292a1b2aa1451d626cff6f6bb28fc", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-08-07T16:47:21Z", "type": "commit"}, {"oid": "5f57875c53eb0261b9c119995b2d79f53179c93b", "url": "https://github.com/apache/hive/commit/5f57875c53eb0261b9c119995b2d79f53179c93b", "message": "HIVE-23716 : Support Anti Join: review comment fix : outfile change for setting anti join true by default", "committedDate": "2020-08-07T16:47:21Z", "type": "commit"}, {"oid": "5ab1a12895473f69605dd4863e021638ff049af5", "url": "https://github.com/apache/hive/commit/5ab1a12895473f69605dd4863e021638ff049af5", "message": "HIVE-23716 : Support Anti Join: review comment fix : outfile change for setting anti join true by default", "committedDate": "2020-08-07T16:47:21Z", "type": "commit"}, {"oid": "4d05a0cfe1a039877bec13f303c38e932fcb08cd", "url": "https://github.com/apache/hive/commit/4d05a0cfe1a039877bec13f303c38e932fcb08cd", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-08-07T16:47:22Z", "type": "commit"}, {"oid": "4d05a0cfe1a039877bec13f303c38e932fcb08cd", "url": "https://github.com/apache/hive/commit/4d05a0cfe1a039877bec13f303c38e932fcb08cd", "message": "HIVE-23716 : Support Anti Join: review comment fix", "committedDate": "2020-08-07T16:47:22Z", "type": "forcePushed"}]}