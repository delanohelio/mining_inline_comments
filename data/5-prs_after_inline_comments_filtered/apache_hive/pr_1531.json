{"pr_number": 1531, "pr_title": "HIVE-24203: Implement stats annotation rule for the LateralViewJoinOperator", "pr_createdAt": "2020-09-28T13:45:56Z", "pr_url": "https://github.com/apache/hive/pull/1531", "timeline": [{"oid": "c88200f458e85f0982dc37641764e451e44d2548", "url": "https://github.com/apache/hive/commit/c88200f458e85f0982dc37641764e451e44d2548", "message": "HIVE-24203: Implement stats annotation rule for the LateralViewJoinOperator", "committedDate": "2020-09-29T03:59:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1OTQ1NQ==", "url": "https://github.com/apache/hive/pull/1531#discussion_r497059455", "bodyText": "Could you provide a bit more details about what the rule does? Most of the other rules in this class give a general overview of the cost model they implement.", "author": "zabetak", "createdAt": "2020-09-29T21:05:57Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,77 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator joins the output of select with the output of UDTF.", "originalCommit": "c88200f458e85f0982dc37641764e451e44d2548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyNjU2MQ==", "url": "https://github.com/apache/hive/pull/1531#discussion_r497526561", "bodyText": "@zabetak Thanks for taking a look!\nI added a description. Please feel free to ask me if something doesn't make sense.", "author": "okumin", "createdAt": "2020-09-30T13:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA1OTQ1NQ=="}], "type": "inlineReview"}, {"oid": "01641e9a0680035e1233e4b8dd21998f27845371", "url": "https://github.com/apache/hive/commit/01641e9a0680035e1233e4b8dd21998f27845371", "message": "HIVE-24203: Implement stats annotation rule for the LateralViewJoinOperator", "committedDate": "2020-09-30T03:13:14Z", "type": "forcePushed"}, {"oid": "b37a00a9addc557ffc37723d996b130355b7f721", "url": "https://github.com/apache/hive/commit/b37a00a9addc557ffc37723d996b130355b7f721", "message": "HIVE-24203: Implement stats annotation rule for the LateralViewJoinOperator", "committedDate": "2020-09-30T05:19:52Z", "type": "forcePushed"}, {"oid": "e2479f85c032aa08b5d9065f53b2e26140853cf7", "url": "https://github.com/apache/hive/commit/e2479f85c032aa08b5d9065f53b2e26140853cf7", "message": "HIVE-24203: Implement stats annotation rule for the LateralViewJoinOperator", "committedDate": "2020-09-30T07:34:56Z", "type": "forcePushed"}, {"oid": "cc942b665ea15e38b14c9c70d813c3bd348bc112", "url": "https://github.com/apache/hive/commit/cc942b665ea15e38b14c9c70d813c3bd348bc112", "message": "HIVE-24203: Implement stats annotation rule for the LateralViewJoinOperator", "committedDate": "2020-09-30T12:43:25Z", "type": "commit"}, {"oid": "cc942b665ea15e38b14c9c70d813c3bd348bc112", "url": "https://github.com/apache/hive/commit/cc942b665ea15e38b14c9c70d813c3bd348bc112", "message": "HIVE-24203: Implement stats annotation rule for the LateralViewJoinOperator", "committedDate": "2020-09-30T12:43:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2NTA1MA==", "url": "https://github.com/apache/hive/pull/1531#discussion_r497865050", "bodyText": "Just leaving a note. I took a quick look at the UDTF logic and it seems the selectivity is hardcoded via config. It seems the outer flag is not taken into account either, which could be a straightforward improvement for the estimates, i.e., UDFT will produce at least as many rows as it receives.", "author": "jcamachor", "createdAt": "2020-10-01T00:01:21Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.", "originalCommit": "cc942b665ea15e38b14c9c70d813c3bd348bc112", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Njk0Nw==", "url": "https://github.com/apache/hive/pull/1531#discussion_r497866947", "bodyText": "Do you need to clone them? Are you modifying them? (Same for next line)", "author": "jcamachor", "createdAt": "2020-10-01T00:08:47Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics().clone();", "originalCommit": "cc942b665ea15e38b14c9c70d813c3bd348bc112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwNjM5Ng==", "url": "https://github.com/apache/hive/pull/1531#discussion_r500006396", "bodyText": "As for udtfStats, we can totally avoid clone.\nAs for udtfStats, its column stats will be updated. However, looks like StatsUtils.getColStatisticsFromExprMap clones them?\nAnyway I think we can remove them if CI passes. I will try it.", "author": "okumin", "createdAt": "2020-10-06T04:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Njk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMzYzNw==", "url": "https://github.com/apache/hive/pull/1531#discussion_r500423637", "bodyText": "Nothing was not unexpectedly broken. CI failed but it would not be related to this PR...\n\n91e492d", "author": "okumin", "createdAt": "2020-10-06T16:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Njk0Nw=="}], "type": "inlineReview"}, {"oid": "91e492de239427fc1e38e5e4350cfdce409ebb70", "url": "https://github.com/apache/hive/commit/91e492de239427fc1e38e5e4350cfdce409ebb70", "message": "Remove unnecessary clone", "committedDate": "2020-10-06T07:40:01Z", "type": "commit"}, {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24", "url": "https://github.com/apache/hive/commit/ab75d7ae2a01613f9539d1e12857a32329b61b24", "message": "Add one more test query", "committedDate": "2020-10-06T13:04:17Z", "type": "commit"}, {"oid": "ab75d7ae2a01613f9539d1e12857a32329b61b24", "url": "https://github.com/apache/hive/commit/ab75d7ae2a01613f9539d1e12857a32329b61b24", "message": "Add one more test query", "committedDate": "2020-10-06T13:04:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3NjIwMg==", "url": "https://github.com/apache/hive/pull/1531#discussion_r500976202", "bodyText": "I know selectStats.getNumRows() should not be zero - but just in case... could you also add the resulting logic as StatsUtils or something like that?", "author": "kgyrtkirk", "createdAt": "2020-10-07T12:36:40Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();", "originalCommit": "ab75d7ae2a01613f9539d1e12857a32329b61b24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5MTg5Nw==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501691897", "bodyText": "Added steps to check both numbers and ensure at least one record on stats.\n5039634", "author": "okumin", "createdAt": "2020-10-08T12:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk3NjIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ==", "url": "https://github.com/apache/hive/pull/1531#discussion_r500981185", "bodyText": "this seems to be a common expression in both branches of the if - could you move it outside?", "author": "kgyrtkirk", "createdAt": "2020-10-07T12:44:26Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }", "originalCommit": "ab75d7ae2a01613f9539d1e12857a32329b61b24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwMTc5NA==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501101794", "bodyText": "I wonder if we should switch [0] or [1] based on a condition. I can see some rules use a different marker based on maybe the existence of column stats.", "author": "okumin", "createdAt": "2020-10-07T15:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwMzM0MQ==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501203341", "bodyText": "I don't know what's the point of these [0]/[1] markers; from one of the historical commits it seems to me like these are some kind of \"log message indexes\" inside the method ....\nI think we could stop doing that...", "author": "kgyrtkirk", "createdAt": "2020-10-07T17:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY4OTQ1MQ==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501689451", "bodyText": "I also agree and I did that.\nd333d5d", "author": "okumin", "createdAt": "2020-10-08T12:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4MTE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501021466", "bodyText": "I think we should make sure that NDV is at least 1 in case numrows is >0", "author": "kgyrtkirk", "createdAt": "2020-10-07T13:41:27Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2921,6 +2920,97 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n     }\n   }\n \n+  /**\n+   * LateralViewJoinOperator changes the data size and column level statistics.\n+   *\n+   * A diagram of LATERAL VIEW.\n+   *\n+   *   [Lateral View Forward]\n+   *          /     \\\n+   *    [Select]  [Select]\n+   *        |        |\n+   *        |     [UDTF]\n+   *        \\       /\n+   *   [Lateral View Join]\n+   *\n+   * For each row of the source, the left branch just picks columns and the right branch processes UDTF.\n+   * And then LVJ joins a row from the left branch with rows from the right branch.\n+   * The join has one-to-many relationship since UDTF can generate multiple rows.\n+   *\n+   * This rule multiplies the stats from the left branch by T(right) / T(left) and sums up the both sides.\n+   */\n+  public static class LateralViewJoinStatsRule extends DefaultStatsRule implements SemanticNodeProcessor {\n+    @Override\n+    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n+                          Object... nodeOutputs) throws SemanticException {\n+      final LateralViewJoinOperator lop = (LateralViewJoinOperator) nd;\n+      final AnnotateStatsProcCtx aspCtx = (AnnotateStatsProcCtx) procCtx;\n+      final HiveConf conf = aspCtx.getConf();\n+\n+      if (!isAllParentsContainStatistics(lop)) {\n+        return null;\n+      }\n+\n+      final List<Operator<? extends OperatorDesc>> parents = lop.getParentOperators();\n+      if (parents.size() != 2) {\n+        LOG.warn(\"LateralViewJoinOperator should have just two parents but actually has \"\n+                + parents.size() + \" parents.\");\n+        return null;\n+      }\n+\n+      final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n+      final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n+\n+      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long selectDataSize = StatsUtils.safeMult(selectStats.getDataSize(), factor);\n+      final long dataSize = StatsUtils.safeAdd(selectDataSize, udtfStats.getDataSize());\n+      Statistics joinedStats = new Statistics(udtfStats.getNumRows(), dataSize, 0, 0);\n+\n+      if (satisfyPrecondition(selectStats) && satisfyPrecondition(udtfStats)) {\n+        final Map<String, ExprNodeDesc> columnExprMap = lop.getColumnExprMap();\n+        final RowSchema schema = lop.getSchema();\n+\n+        joinedStats.updateColumnStatsState(selectStats.getColumnStatsState());\n+        final List<ColStatistics> selectColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, selectStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(multiplyColStats(selectColStats, factor));\n+\n+        joinedStats.updateColumnStatsState(udtfStats.getColumnStatsState());\n+        final List<ColStatistics> udtfColStats = StatsUtils\n+                .getColStatisticsFromExprMap(conf, udtfStats, columnExprMap, schema);\n+        joinedStats.addToColumnStats(udtfColStats);\n+\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[0] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      } else {\n+        joinedStats = applyRuntimeStats(aspCtx.getParseContext().getContext(), joinedStats, lop);\n+        lop.setStatistics(joinedStats);\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"[1] STATS-\" + lop.toString() + \": \" + joinedStats.extendedToString());\n+        }\n+      }\n+      return null;\n+    }\n+\n+    private List<ColStatistics> multiplyColStats(List<ColStatistics> colStatistics, double factor) {\n+      for (ColStatistics colStats : colStatistics) {\n+        colStats.setNumFalses(StatsUtils.safeMult(colStats.getNumFalses(), factor));\n+        colStats.setNumTrues(StatsUtils.safeMult(colStats.getNumTrues(), factor));\n+        colStats.setNumNulls(StatsUtils.safeMult(colStats.getNumNulls(), factor));\n+        // When factor > 1, the same records are duplicated and countDistinct never changes.\n+        if (factor < 1.0) {\n+          colStats.setCountDistint(StatsUtils.safeMult(colStats.getCountDistint(), factor));", "originalCommit": "ab75d7ae2a01613f9539d1e12857a32329b61b24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5Njk5OQ==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501096999", "bodyText": "Now I think this is available for this purpose if we add updating num trues and num falses?\n\n  \n    \n      hive/ql/src/java/org/apache/hadoop/hive/ql/stats/StatsUtils.java\n    \n    \n        Lines 2050 to 2100\n      in\n      c082a72\n    \n    \n    \n    \n\n        \n          \n           public static void updateStats(Statistics stats, long newNumRows, \n        \n\n        \n          \n               boolean useColStats, Operator<? extends OperatorDesc> op, \n        \n\n        \n          \n               Set<String> affectedColumns) { \n        \n\n        \n          \n            \n        \n\n        \n          \n             if (newNumRows < 0) { \n        \n\n        \n          \n               LOG.debug(\"STATS-\" + op.toString() + \": Overflow in number of rows. \" \n        \n\n        \n          \n                   + newNumRows + \" rows will be set to Long.MAX_VALUE\"); \n        \n\n        \n          \n               newNumRows = StatsUtils.getMaxIfOverflow(newNumRows); \n        \n\n        \n          \n             } \n        \n\n        \n          \n             if (newNumRows == 0) { \n        \n\n        \n          \n               LOG.debug(\"STATS-\" + op.toString() + \": Equals 0 in number of rows. \" \n        \n\n        \n          \n                   + newNumRows + \" rows will be set to 1\"); \n        \n\n        \n          \n               newNumRows = 1; \n        \n\n        \n          \n             } \n        \n\n        \n          \n            \n        \n\n        \n          \n             long oldRowCount = stats.getNumRows(); \n        \n\n        \n          \n             double ratio = (double) newNumRows / (double) oldRowCount; \n        \n\n        \n          \n             stats.setNumRows(newNumRows); \n        \n\n        \n          \n            \n        \n\n        \n          \n             if (useColStats) { \n        \n\n        \n          \n               List<ColStatistics> colStats = stats.getColumnStats(); \n        \n\n        \n          \n               for (ColStatistics cs : colStats) { \n        \n\n        \n          \n                 long oldDV = cs.getCountDistint(); \n        \n\n        \n          \n                 if (affectedColumns.contains(cs.getColumnName())) { \n        \n\n        \n          \n                   long newDV = oldDV; \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // if ratio is greater than 1, then number of rows increases. This can happen \n        \n\n        \n          \n                   // when some operators like GROUPBY duplicates the input rows in which case \n        \n\n        \n          \n                   // number of distincts should not change. Update the distinct count only when \n        \n\n        \n          \n                   // the output number of rows is less than input number of rows. \n        \n\n        \n          \n                   if (ratio <= 1.0) { \n        \n\n        \n          \n                     newDV = (long) Math.ceil(ratio * oldDV); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   cs.setCountDistint(newDV); \n        \n\n        \n          \n                   cs.setFilterColumn(); \n        \n\n        \n          \n                   oldDV = newDV; \n        \n\n        \n          \n                 } \n        \n\n        \n          \n                 if (oldDV > newNumRows) { \n        \n\n        \n          \n                   cs.setCountDistint(newNumRows); \n        \n\n        \n          \n                 } \n        \n\n        \n          \n                 long newNumNulls = Math.round(ratio * cs.getNumNulls()); \n        \n\n        \n          \n                 cs.setNumNulls(newNumNulls > newNumRows ? newNumRows: newNumNulls); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               stats.setColumnStats(colStats); \n        \n\n        \n          \n               long newDataSize = StatsUtils.getDataSizeFromColumnStats(newNumRows, colStats); \n        \n\n        \n          \n               stats.setDataSize(StatsUtils.getMaxIfOverflow(newDataSize)); \n        \n\n        \n          \n             } else { \n        \n\n        \n          \n               long newDataSize = (long) (ratio * stats.getDataSize()); \n        \n\n        \n          \n               stats.setDataSize(StatsUtils.getMaxIfOverflow(newDataSize)); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }", "author": "okumin", "createdAt": "2020-10-07T15:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTExMDkyMg==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501110922", "bodyText": "This method may include additional logging and logics to optimize JOIN such as cs.setFilterColumn. It would be better to implement a simple and separate utility.", "author": "okumin", "createdAt": "2020-10-07T15:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY5NzU3OQ==", "url": "https://github.com/apache/hive/pull/1531#discussion_r501697579", "bodyText": "Ceiled. I moved this method since I'd like to reuse it for HIVE-24240.\n5039634", "author": "okumin", "createdAt": "2020-10-08T12:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyMTQ2Ng=="}], "type": "inlineReview"}, {"oid": "d333d5d70184a1cf1f0c0f239e9229965e486202", "url": "https://github.com/apache/hive/commit/d333d5d70184a1cf1f0c0f239e9229965e486202", "message": "Move some steps outside", "committedDate": "2020-10-08T02:54:52Z", "type": "commit"}, {"oid": "50396346eaed5d6bab4ff87dd079918a769a7ebd", "url": "https://github.com/apache/hive/commit/50396346eaed5d6bab4ff87dd079918a769a7ebd", "message": "Ensure that num rows >= 1", "committedDate": "2020-10-08T06:49:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMjU1NA==", "url": "https://github.com/apache/hive/pull/1531#discussion_r504422554", "bodyText": "factor will be greater than 0.0 and must not 0 or infinity.", "author": "okumin", "createdAt": "2020-10-14T06:05:56Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/stats/annotation/StatsRulesProcFactory.java", "diffHunk": "@@ -2961,10 +2961,11 @@ public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n       final Statistics selectStats = parents.get(LateralViewJoinOperator.SELECT_TAG).getStatistics();\n       final Statistics udtfStats = parents.get(LateralViewJoinOperator.UDTF_TAG).getStatistics();\n \n-      final double factor = (double) udtfStats.getNumRows() / (double) selectStats.getNumRows();\n+      final long udtfNumRows = Math.max(udtfStats.getNumRows(), 1);\n+      final double factor = (double) udtfNumRows / (double) Math.max(selectStats.getNumRows(), 1);", "originalCommit": "50396346eaed5d6bab4ff87dd079918a769a7ebd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}