{"pr_number": 1228, "pr_title": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "pr_createdAt": "2020-07-08T14:23:35Z", "pr_url": "https://github.com/apache/hive/pull/1228", "timeline": [{"oid": "9807b73703e827d2be0230cb984197ada56b6ae8", "url": "https://github.com/apache/hive/commit/9807b73703e827d2be0230cb984197ada56b6ae8", "message": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "committedDate": "2020-07-17T14:14:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTU3MQ==", "url": "https://github.com/apache/hive/pull/1228#discussion_r457825571", "bodyText": "Naming (NON_FK_FILTERED : \"notFiltered\") is a bit confusing. We can simplify to NON_FK_FILTERED vs NON_FK_NOT_FILTERED? Create String in converter for both (or enum).", "author": "jcamachor", "createdAt": "2020-07-21T04:14:36Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/translator/ASTConverter.java", "diffHunk": "@@ -442,6 +450,40 @@ private QueryBlockInfo convertSource(RelNode r) throws CalciteSemanticException\n     return new QueryBlockInfo(s, ast);\n   }\n \n+  /**\n+   * Add PK-FK join information to the AST as a query hint\n+   * @param ast\n+   * @param join\n+   * @param swapSides whether the left and right input of the join is swapped\n+   */\n+  private void addPkFkInfoToAST(ASTNode ast, Join join, boolean swapSides) {\n+    List<RexNode> joinFilters = new ArrayList<>(RelOptUtil.conjunctions(join.getCondition()));\n+    RelMetadataQuery mq = join.getCluster().getMetadataQuery();\n+    HiveRelOptUtil.PKFKJoinInfo rightInputResult =\n+            HiveRelOptUtil.extractPKFKJoin(join, joinFilters, false, mq);\n+    HiveRelOptUtil.PKFKJoinInfo leftInputResult =\n+            HiveRelOptUtil.extractPKFKJoin(join, joinFilters, true, mq);\n+    // Add the fkJoinIndex (0=left, 1=right, if swapSides is false) to the AST\n+    // check if the nonFK side is filtered\n+    if (leftInputResult.isPkFkJoin && leftInputResult.additionalPredicates.isEmpty()) {\n+      RelNode nonFkInput = join.getRight();\n+      ast.addChild(pkFkHint(swapSides ? 1 : 0, HiveRelOptUtil.isRowFilteringPlan(mq, nonFkInput)));\n+    } else if (rightInputResult.isPkFkJoin && rightInputResult.additionalPredicates.isEmpty()) {\n+      RelNode nonFkInput = join.getLeft();\n+      ast.addChild(pkFkHint(swapSides ? 0 : 1, HiveRelOptUtil.isRowFilteringPlan(mq, nonFkInput)));\n+    }\n+  }\n+\n+  private ASTNode pkFkHint(int fkTableIndex, boolean nonFkSideIsFiltered) {\n+    ParseDriver parseDriver = new ParseDriver();\n+    try {\n+      return parseDriver.parseHint(String.format(\"PKFK_JOIN(%d, %s)\",\n+              fkTableIndex, nonFkSideIsFiltered ? NON_FK_FILTERED : \"notFiltered\"));", "originalCommit": "9807b73703e827d2be0230cb984197ada56b6ae8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTc0Ng==", "url": "https://github.com/apache/hive/pull/1228#discussion_r457825746", "bodyText": "Can we add a comment to this method? In which cases we can pushdown through inner join?", "author": "jcamachor", "createdAt": "2020-07-21T04:15:19Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/topnkey/TopNKeyPushdownProcessor.java", "diffHunk": "@@ -255,6 +260,88 @@ private void pushdownThroughLeftOuterJoin(TopNKeyOperator topNKey) throws Semant\n     }\n   }\n \n+  private void pushdownInnerJoin(TopNKeyOperator topNKey, int fkJoinInputIndex, boolean nonFkSideIsFiltered) throws SemanticException {", "originalCommit": "9807b73703e827d2be0230cb984197ada56b6ae8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTk5Ng==", "url": "https://github.com/apache/hive/pull/1228#discussion_r457825996", "bodyText": "nit. Some lines are very long. Please split in multiple lines.\nAdditionally, can we some comments to these utility methods?", "author": "jcamachor", "createdAt": "2020-07-21T04:16:24Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/topnkey/TopNKeyPushdownProcessor.java", "diffHunk": "@@ -255,6 +260,88 @@ private void pushdownThroughLeftOuterJoin(TopNKeyOperator topNKey) throws Semant\n     }\n   }\n \n+  private void pushdownInnerJoin(TopNKeyOperator topNKey, int fkJoinInputIndex, boolean nonFkSideIsFiltered) throws SemanticException {\n+    TopNKeyDesc topNKeyDesc = topNKey.getConf();\n+    CommonJoinOperator<? extends JoinDesc> join =\n+            (CommonJoinOperator<? extends JoinDesc>) topNKey.getParentOperators().get(0);\n+    List<Operator<? extends OperatorDesc>> joinInputs = join.getParentOperators();\n+    ReduceSinkOperator fkJoinInput = (ReduceSinkOperator) joinInputs.get(fkJoinInputIndex);\n+    if (nonFkSideIsFiltered) {\n+      LOG.debug(\"Not pushing {} through {} as non FK side of the join is filtered\", topNKey.getName(), join.getName());\n+      return;\n+    }\n+    // Check column origins:\n+    //  1. If all OrderBy columns are coming from the child (FK) table:\n+    //    -> move TopNKeyOperator\n+    //  2. If the first n OrderBy columns are coming from the child (FK) table:\n+    //    -> copy TopNKeyOperator with the first n columns, and leave the original in place\n+    int prefixLength = keyColumnPrefixLength(join, topNKey, fkJoinInputIndex, topNKey.getConf().getKeyColumns());\n+    if (prefixLength == 0) {\n+      LOG.debug(\"Not pushing {} through {} as common key column prefix length is 0\", topNKey.getName(), join.getName());\n+      return;\n+    }\n+    LOG.debug(\"Pushing a copy of {} through {} and {}\",\n+            topNKey.getName(), join.getName(), fkJoinInput.getName());\n+    TopNKeyDesc newTopNKeyDesc = topNKeyDesc.withKeyColumns(prefixLength);\n+    newTopNKeyDesc.setKeyColumns(remapColumns(join, fkJoinInput, newTopNKeyDesc.getKeyColumns()));\n+    pushdown(copyDown(fkJoinInput, newTopNKeyDesc));\n+    if (topNKeyDesc.getKeyColumns().size() == prefixLength) {\n+      LOG.debug(\"Removing {} above {}\", topNKey.getName(), join.getName());\n+      join.removeChildAndAdoptItsChildren(topNKey);\n+    }\n+  }\n+\n+  private int keyColumnPrefixLength(CommonJoinOperator<? extends JoinDesc> join, TopNKeyOperator topNKeyOperator, int expectedTag, List<ExprNodeDesc> keyColumns) {", "originalCommit": "9807b73703e827d2be0230cb984197ada56b6ae8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4d3edd54ad1d83302b09158ce013b43e77c3611f", "url": "https://github.com/apache/hive/commit/4d3edd54ad1d83302b09158ce013b43e77c3611f", "message": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "committedDate": "2020-07-23T14:14:08Z", "type": "forcePushed"}, {"oid": "421b697d86306ab53fd91dd570c323f049e91a93", "url": "https://github.com/apache/hive/commit/421b697d86306ab53fd91dd570c323f049e91a93", "message": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "committedDate": "2020-07-27T07:47:36Z", "type": "commit"}, {"oid": "2a29d86fc5b0993c68aadb6f21baf2c0f993ba05", "url": "https://github.com/apache/hive/commit/2a29d86fc5b0993c68aadb6f21baf2c0f993ba05", "message": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "committedDate": "2020-07-27T08:05:45Z", "type": "commit"}, {"oid": "1ae8cc07c81eb529e10a157dc3fea3e59c98307e", "url": "https://github.com/apache/hive/commit/1ae8cc07c81eb529e10a157dc3fea3e59c98307e", "message": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "committedDate": "2020-07-27T08:05:45Z", "type": "commit"}, {"oid": "1ae8cc07c81eb529e10a157dc3fea3e59c98307e", "url": "https://github.com/apache/hive/commit/1ae8cc07c81eb529e10a157dc3fea3e59c98307e", "message": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "committedDate": "2020-07-27T08:05:45Z", "type": "forcePushed"}, {"oid": "a808f6b22665a4610a951ec8cbaf8eea994cb1bf", "url": "https://github.com/apache/hive/commit/a808f6b22665a4610a951ec8cbaf8eea994cb1bf", "message": "HIVE-23817. Pushing TopN Key operator PKFK inner joins (amagyar)", "committedDate": "2020-07-28T08:20:49Z", "type": "commit"}]}