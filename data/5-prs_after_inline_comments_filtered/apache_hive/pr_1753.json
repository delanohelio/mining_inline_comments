{"pr_number": 1753, "pr_title": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time.", "pr_createdAt": "2020-12-08T11:38:12Z", "pr_url": "https://github.com/apache/hive/pull/1753", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNjEyMQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r538916121", "bodyText": "Can be removed.", "author": "rbalamohan", "createdAt": "2020-12-09T00:40:35Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -61,27 +61,16 @@\n   private Field root;\n \n   private static class Field {\n-    Field[] children;\n-\n-    boolean isPrimitive;\n-    Category category;\n-    PrimitiveCategory primitiveCategory;\n-    TypeInfo typeInfo;\n-\n-    int count;\n-\n-    ObjectInspector objectInspector;\n-    int outputColumnNum;\n-\n+    Field[] children = null;\n+    boolean isPrimitive = false;\n+    Category category = null;\n+    PrimitiveCategory primitiveCategory = null;\n+    TypeInfo typeInfo = null;\n+    int count = 0;\n+    ObjectInspector objectInspector = null;\n+    int outputColumnNum = -1;\n+    VectorSerializeWriter writer = null;\n     Field() {", "originalCommit": "9960d4926e3cbef75919903a094a82b4ed2ea02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzQ2OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r538917469", "bodyText": "Why VectorDeserializerRow needs be passed here again? (\"this\" references in other places as well). If you remove \"static\" class declaration in VectorBatchDeserializer children, you may not need to pass this.  And the patch would become lot lesser changes?", "author": "rbalamohan", "createdAt": "2020-12-09T00:43:52Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java", "diffHunk": "@@ -933,12 +1207,20 @@ private void storeUnionRowColumn(ColumnVector colVector,\n     unionColVector.isNull[batchIndex] = false;\n     unionColVector.tags[batchIndex] = tag;\n \n-    storeComplexFieldRowColumn(\n+    deserializer.storeComplexFieldRowColumn(\n         colVectorFields[tag],\n         unionHelper.getFields()[tag],\n         batchIndex,\n         canRetainByteRef);\n-    deserializeRead.finishComplexVariableFieldsType();\n+    deserializer.deserializeRead.finishComplexVariableFieldsType();\n+  }\n+\n+  abstract static class VectorBatchDeserializer {\n+    abstract void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef,\n+                            VectorDeserializeRow deserializer) throws IOException;", "originalCommit": "9960d4926e3cbef75919903a094a82b4ed2ea02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkxNzg0MA==", "url": "https://github.com/apache/hive/pull/1753#discussion_r538917840", "bodyText": "Same as earlier. VectorSerializeRow need not be passed here. Patch may need lesser changes if you remove static declaration on children.", "author": "rbalamohan", "createdAt": "2020-12-09T00:44:42Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -274,44 +315,25 @@ private void serializeWrite(\n       return;\n     }\n     isAllNulls = false;\n+    field.writer.serialize(colVector, field, adjustedBatchIndex, this);\n+  }\n \n-    if (field.isPrimitive) {\n-      serializePrimitiveWrite(colVector, field, adjustedBatchIndex);\n-      return;\n-    }\n-    final Category category = field.category;\n-    switch (category) {\n-    case LIST:\n-      serializeListWrite(\n-          (ListColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    case MAP:\n-      serializeMapWrite(\n-          (MapColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    case STRUCT:\n-      serializeStructWrite(\n-          (StructColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    case UNION:\n-      serializeUnionWrite(\n-          (UnionColumnVector) colVector,\n-          field,\n-          adjustedBatchIndex);\n-      break;\n-    default:\n-      throw new RuntimeException(\"Unexpected category \" + category);\n+  abstract static class VectorSerializeWriter {\n+    abstract void serialize(Object colVector, Field field, int adjustedBatchIndex,\n+                            VectorSerializeRow serializeRow) throws IOException;", "originalCommit": "9960d4926e3cbef75919903a094a82b4ed2ea02c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "url": "https://github.com/apache/hive/commit/1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time", "committedDate": "2020-12-09T09:12:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzOTk2OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540839969", "bodyText": "Nit: would be cleaner if serializeStructWrite method is be part of the VectorSerializeStructWriter class", "author": "pgaref", "createdAt": "2020-12-11T10:18:06Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -328,6 +345,13 @@ private void serializeUnionWrite(\n     serializeWrite.finishUnion();\n   }\n \n+  class VectorSerializeStructWriter extends VectorSerializeWriter {\n+    @Override\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n+      serializeStructWrite((StructColumnVector)colInfo, field, adjustedBatchIndex);\n+    }\n+  }\n+\n   private void serializeStructWrite(", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODg5Ng==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542158896", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-12-14T07:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgzOTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDE4Mw==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540840183", "bodyText": "Nit: serializeMapWrite part of VectorSerializeMapWriter class?", "author": "pgaref", "createdAt": "2020-12-11T10:18:30Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -355,6 +379,13 @@ private void serializeStructWrite(\n     serializeWrite.finishStruct();\n   }\n \n+  class VectorSerializeMapWriter extends VectorSerializeWriter {\n+    @Override\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n+      serializeMapWrite((MapColumnVector)colInfo, field, adjustedBatchIndex);\n+    }\n+  }\n+\n   private void serializeMapWrite(", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1ODkzNg==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542158936", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-12-14T07:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDM3Mw==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540840373", "bodyText": "Nit: serializeListWrite part of VectorSerializeListWriter?", "author": "pgaref", "createdAt": "2020-12-11T10:18:47Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorSerializeRow.java", "diffHunk": "@@ -383,6 +414,13 @@ private void serializeMapWrite(\n     serializeWrite.finishMap();\n   }\n \n+  class VectorSerializeListWriter extends VectorSerializeWriter {\n+    @Override\n+    void serialize(Object colInfo, Field field, int adjustedBatchIndex) throws IOException {\n+      serializeListWrite((ListColumnVector)colInfo, field, adjustedBatchIndex);\n+    }\n+  }\n+\n   private void serializeListWrite(", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1OTAxNg==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542159016", "bodyText": "done", "author": "maheshk114", "createdAt": "2020-12-14T07:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzE3OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r540843179", "bodyText": "Looks like VectorVarcharDeserializer and VectorCharDeserializer share the same store method -- so maybe make them inherit from a common base class and only Override convert method?", "author": "pgaref", "createdAt": "2020-12-11T10:23:36Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/exec/vector/VectorDeserializeRow.java", "diffHunk": "@@ -564,173 +621,337 @@ public void init() throws HiveException {\n     init(0);\n   }\n \n-  private void storePrimitiveRowColumn(ColumnVector colVector, Field field,\n-      int batchIndex, boolean canRetainByteRef) throws IOException {\n-\n-    switch (field.getPrimitiveCategory()) {\n-    case VOID:\n+  class VectorVoidDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       VectorizedBatchUtil.setNullColIsNullValue(colVector, batchIndex);\n-      return;\n-    case BOOLEAN:\n-      ((LongColumnVector) colVector).vector[batchIndex] = (deserializeRead.currentBoolean ? 1 : 0);\n-      break;\n-    case BYTE:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertVoid();\n+    }\n+  }\n+\n+  class VectorBooleanDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] =\n+              (deserializeRead.currentBoolean ? 1 : 0);\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertBoolean(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorByteDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentByte;\n-      break;\n-    case SHORT:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertByte(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorShortDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentShort;\n-      break;\n-    case INT:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertShort(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorIntDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentInt;\n-      break;\n-    case LONG:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertInt(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorLongDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentLong;\n-      break;\n-    case TIMESTAMP:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertLong(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorTimestampDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((TimestampColumnVector) colVector).set(\n-          batchIndex, deserializeRead.currentTimestampWritable.getTimestamp().toSqlTimestamp());\n-      break;\n-    case DATE:\n-      ((LongColumnVector) colVector).vector[batchIndex] = deserializeRead.currentDateWritable.getDays();\n-      break;\n-    case FLOAT:\n+              batchIndex, deserializeRead.currentTimestampWritable.getTimestamp().toSqlTimestamp());\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertTimestamp(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorDateDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      ((LongColumnVector) colVector).vector[batchIndex] =\n+              deserializeRead.currentDateWritable.getDays();\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertDate(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorFloatDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((DoubleColumnVector) colVector).vector[batchIndex] = deserializeRead.currentFloat;\n-      break;\n-    case DOUBLE:\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertFloat(field.getConversionWritable());\n+    }\n+  }\n+\n+  class VectorDoubleDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n       ((DoubleColumnVector) colVector).vector[batchIndex] = deserializeRead.currentDouble;\n-      break;\n-    case BINARY:\n-    case STRING:\n-      {\n-        final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n-        if (deserializeRead.currentExternalBufferNeeded) {\n-          bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n-          deserializeRead.copyToExternalBuffer(\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertDouble(field.getConversionWritable());\n+    }\n+  }\n+\n+  private void storeString(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+          throws IOException {\n+    final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n+    if (deserializeRead.currentExternalBufferNeeded) {\n+      bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n+      deserializeRead.copyToExternalBuffer(\n               bytesColVec.getValPreallocatedBytes(), bytesColVec.getValPreallocatedStart());\n-          bytesColVec.setValPreallocated(\n+      bytesColVec.setValPreallocated(\n               batchIndex,\n               deserializeRead.currentExternalBufferNeededLen);\n-        } else if (canRetainByteRef && inputBytes == deserializeRead.currentBytes) {\n-          bytesColVec.setRef(\n+    } else if (canRetainByteRef && inputBytes == deserializeRead.currentBytes) {\n+      bytesColVec.setRef(\n               batchIndex,\n               deserializeRead.currentBytes,\n               deserializeRead.currentBytesStart,\n               deserializeRead.currentBytesLength);\n-        } else {\n-          bytesColVec.setVal(\n+    } else {\n+      bytesColVec.setVal(\n               batchIndex,\n               deserializeRead.currentBytes,\n               deserializeRead.currentBytesStart,\n               deserializeRead.currentBytesLength);\n-        }\n-      }\n-      break;\n-    case VARCHAR:\n-      {\n-        // Use the basic STRING bytes read to get access, then use our optimal truncate/trim method\n-        // that does not use Java String objects.\n-        final BytesColumnVector bytesColVec = ((BytesColumnVector) colVector);\n-        if (deserializeRead.currentExternalBufferNeeded) {\n-          // Write directly into our BytesColumnVector value buffer.\n-          bytesColVec.ensureValPreallocated(deserializeRead.currentExternalBufferNeededLen);\n-          final byte[] convertBuffer = bytesColVec.getValPreallocatedBytes();\n-          final int convertBufferStart = bytesColVec.getValPreallocatedStart();\n-          deserializeRead.copyToExternalBuffer(\n-              convertBuffer,\n-              convertBufferStart);\n-          bytesColVec.setValPreallocated(\n-              batchIndex,\n-              StringExpr.truncate(\n-                  convertBuffer,\n-                  convertBufferStart,\n-                  deserializeRead.currentExternalBufferNeededLen,\n-                  field.getMaxLength()));\n-        } else if (canRetainByteRef && inputBytes == deserializeRead.currentBytes) {\n-          bytesColVec.setRef(\n-              batchIndex,\n-              deserializeRead.currentBytes,\n-              deserializeRead.currentBytesStart,\n-              StringExpr.truncate(\n-                  deserializeRead.currentBytes,\n-                  deserializeRead.currentBytesStart,\n-                  deserializeRead.currentBytesLength,\n-                  field.getMaxLength()));\n-        } else {\n-          bytesColVec.setVal(\n-              batchIndex,\n-              deserializeRead.currentBytes,\n-              deserializeRead.currentBytesStart,\n-              StringExpr.truncate(\n-                  deserializeRead.currentBytes,\n-                  deserializeRead.currentBytesStart,\n-                  deserializeRead.currentBytesLength,\n-                  field.getMaxLength()));\n-        }\n+    }\n+  }\n+\n+  class VectorBinaryDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      storeString(colVector, field, batchIndex, canRetainByteRef);\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertBinary(field.getConversionWritable(), batchIndex);\n+    }\n+  }\n+\n+  class VectorStringDeserializer extends VectorBatchDeserializer {\n+    @Override\n+    void store(ColumnVector colVector, Field field, int batchIndex, boolean canRetainByteRef)\n+            throws IOException {\n+      storeString(colVector, field, batchIndex, canRetainByteRef);\n+    }\n+\n+    @Override\n+    Object convert(ColumnVector batch, int batchIndex, Field field) throws IOException {\n+      return convertString(field.getConversionWritable(), batchIndex);\n+    }\n+  }\n+\n+  class VectorVarcharDeserializer extends VectorBatchDeserializer {", "originalCommit": "1f2e2d0d3bc55f8e2e38e91829d3f8ee36076aad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1OTQ0OQ==", "url": "https://github.com/apache/hive/pull/1753#discussion_r542159449", "bodyText": "char uses StringExpr.rightTrimAndTruncate and var char uses StringExpr.truncate(", "author": "maheshk114", "createdAt": "2020-12-14T07:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0MzE3OQ=="}], "type": "inlineReview"}, {"oid": "fe42b2893c06c5a79b6ed83ba8526b92a620e904", "url": "https://github.com/apache/hive/commit/fe42b2893c06c5a79b6ed83ba8526b92a620e904", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time", "committedDate": "2020-12-14T12:12:02Z", "type": "commit"}, {"oid": "7783b36cbc7d94f2c2e672262b31ea3a31a880d7", "url": "https://github.com/apache/hive/commit/7783b36cbc7d94f2c2e672262b31ea3a31a880d7", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time", "committedDate": "2020-12-14T12:12:02Z", "type": "commit"}, {"oid": "dc743c71d06119d946d77f8391a20f9322344fca", "url": "https://github.com/apache/hive/commit/dc743c71d06119d946d77f8391a20f9322344fca", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time : review commnet fix", "committedDate": "2020-12-14T12:12:02Z", "type": "commit"}, {"oid": "dc743c71d06119d946d77f8391a20f9322344fca", "url": "https://github.com/apache/hive/commit/dc743c71d06119d946d77f8391a20f9322344fca", "message": "HIVE-24503 : Optimize vector row serde by avoiding type check at run time : review commnet fix", "committedDate": "2020-12-14T12:12:02Z", "type": "forcePushed"}]}