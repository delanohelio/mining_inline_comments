{"pr_number": 1184, "pr_title": "HIVE-23750: Rewrite plan to join back tables: support function calls in project", "pr_createdAt": "2020-06-25T16:42:22Z", "pr_url": "https://github.com/apache/hive/pull/1184", "timeline": [{"oid": "942831507bda167e56106d5119156ffe9c0110f2", "url": "https://github.com/apache/hive/commit/942831507bda167e56106d5119156ffe9c0110f2", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project", "committedDate": "2020-06-26T12:41:51Z", "type": "forcePushed"}, {"oid": "8b685d9e15e4e2ca1500166ba4b8209c744bb49d", "url": "https://github.com/apache/hive/commit/8b685d9e15e4e2ca1500166ba4b8209c744bb49d", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - prevent adding keys to join condition multiple times", "committedDate": "2020-06-30T09:51:50Z", "type": "forcePushed"}, {"oid": "c504d19d72e153235a9e5c1a74b6185fb2376b87", "url": "https://github.com/apache/hive/commit/c504d19d72e153235a9e5c1a74b6185fb2376b87", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - remove additional feature switch", "committedDate": "2020-07-01T15:37:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODU3MQ==", "url": "https://github.com/apache/hive/pull/1184#discussion_r459818571", "bodyText": "LOG.debug(\"Lineage of expression can not be determined: {}\", expr);", "author": "jcamachor", "createdAt": "2020-07-24T01:58:00Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "diffHunk": "@@ -161,127 +174,118 @@ public RelNode trim(RelBuilder relBuilder, RelNode root) {\n         return root;\n       }\n \n-      // 4. Collect fields for new Project on the top of Join backs\n+      // 3. Join back tables to the top of original plan\n       Mapping newInputMapping = trimResult.right;\n-      RexNode[] newProjects = new RexNode[rootFieldList.size()];\n-      String[] newColumnNames = new String[rootFieldList.size()];\n-      projectsFromOriginalPlan(rexBuilder, newInput.getRowType().getFieldCount(), newInput, newInputMapping,\n-          newProjects, newColumnNames);\n+      Map<RexTableInputRef, Integer> tableInputRefMapping = new HashMap<>();\n \n-      // 5. Join back tables to the top of original plan\n       for (TableToJoinBack tableToJoinBack : tableToJoinBackList) {\n-        LOG.debug(\"Joining back table \" + tableToJoinBack.projectedFields.relOptHiveTable.getName());\n+        LOG.debug(\"Joining back table \" + tableToJoinBack.joinedBackFields.relOptHiveTable.getName());\n \n-        // 5.1 Create new TableScan of tables to join back\n-        RelOptHiveTable relOptTable = tableToJoinBack.projectedFields.relOptHiveTable;\n+        // 3.1. Create new TableScan of tables to join back\n+        RelOptHiveTable relOptTable = tableToJoinBack.joinedBackFields.relOptHiveTable;\n         RelOptCluster cluster = relBuilder.getCluster();\n         HiveTableScan tableScan = new HiveTableScan(cluster, cluster.traitSetOf(HiveRelNode.CONVENTION),\n             relOptTable, relOptTable.getHiveTableMD().getTableName(), null, false, false);\n-        // 5.2 Project only required fields from this table\n+        // 3.2. Create Project with the required fields from this table\n         RelNode projectTableAccessRel = tableScan.project(\n-            tableToJoinBack.projectedFields.fieldsInSourceTable, new HashSet<>(0), REL_BUILDER.get());\n+            tableToJoinBack.joinedBackFields.fieldsInSourceTable, new HashSet<>(0), REL_BUILDER.get());\n \n-        Mapping keyMapping = Mappings.create(MappingType.INVERSE_SURJECTION,\n-            tableScan.getRowType().getFieldCount(), tableToJoinBack.keys.cardinality());\n+        // 3.3. Create mapping between the Project and TableScan\n+        Mapping projectMapping = Mappings.create(MappingType.INVERSE_SURJECTION,\n+            tableScan.getRowType().getFieldCount(),\n+            tableToJoinBack.joinedBackFields.fieldsInSourceTable.cardinality());\n         int projectIndex = 0;\n+        for (int i : tableToJoinBack.joinedBackFields.fieldsInSourceTable) {\n+          projectMapping.set(i, projectIndex);\n+          ++projectIndex;\n+        }\n+\n         int offset = newInput.getRowType().getFieldCount();\n \n-        for (int source : tableToJoinBack.projectedFields.fieldsInSourceTable) {\n-          if (tableToJoinBack.keys.get(source)) {\n-            // 5.3 Map key field to it's index in the Project on the TableScan\n-            keyMapping.set(source, projectIndex);\n-          } else {\n-            // 5.4 if this is not a key field then we need it in the new Project on the top of Join backs\n-            ProjectMapping currentProjectMapping =\n-                tableToJoinBack.projectedFields.mapping.stream()\n-                    .filter(projectMapping -> projectMapping.indexInSourceTable == source)\n-                    .findFirst().get();\n-            addToProject(projectTableAccessRel, projectIndex, rexBuilder,\n-                offset + projectIndex,\n-                currentProjectMapping.indexInRootProject,\n-                newProjects, newColumnNames);\n+        // 3.4. Map rexTableInputRef to the index where it can be found in the new Input row type\n+        for (TableInputRefHolder mapping : tableToJoinBack.joinedBackFields.mapping) {\n+          int indexInSourceTable = mapping.tableInputRef.getIndex();\n+          if (!tableToJoinBack.keys.get(indexInSourceTable)) {\n+            // 3.5. if this is not a key field it is shifted by the left input field count\n+            tableInputRefMapping.put(mapping.tableInputRef, offset + projectMapping.getTarget(indexInSourceTable));\n           }\n-          ++projectIndex;\n         }\n \n-        // 5.5 Create Join\n+        // 3.7. Create Join\n         relBuilder.push(newInput);\n         relBuilder.push(projectTableAccessRel);\n \n         RexNode joinCondition = joinCondition(\n-            newInput, newInputMapping, tableToJoinBack, projectTableAccessRel, keyMapping, rexBuilder);\n+            newInput, newInputMapping, tableToJoinBack, projectTableAccessRel, projectMapping, rexBuilder);\n \n         newInput = relBuilder.join(JoinRelType.INNER, joinCondition).build();\n       }\n \n-      // 6 Create Project on top of all Join backs\n+      // 4. Collect rexNodes for Project\n+      TableInputRefMapper mapper = new TableInputRefMapper(tableInputRefMapping, rexBuilder, newInput);\n+      List<RexNode> rexNodeList = new ArrayList<>(rootInput.getRowType().getFieldCount());\n+      for (int i = 0; i < rootInput.getRowType().getFieldCount(); i++) {\n+        RexNode rexNode = rexNodesToShuttle.get(i);\n+        if (rexNode != null) {\n+          rexNodeList.add(mapper.apply(rexNode));\n+        } else {\n+          int target = newInputMapping.getTarget(i);\n+          rexNodeList.add(\n+              rexBuilder.makeInputRef(newInput.getRowType().getFieldList().get(target).getType(), target));\n+        }\n+      }\n+\n+      // 5. Create Project on top of all Join backs\n       relBuilder.push(newInput);\n-      relBuilder.project(asList(newProjects), asList(newColumnNames));\n+      relBuilder.project(rexNodeList, newColumnNames);\n \n       return root.copy(root.getTraitSet(), singletonList(relBuilder.build()));\n     } finally {\n       REL_BUILDER.remove();\n     }\n   }\n \n-  private List<ProjectedFields> getExpressionLineageOf(\n+  private List<JoinedBackFields> getExpressionLineageOf(\n       List<RexInputRef> projectExpressions, RelNode projectInput) {\n     RelMetadataQuery relMetadataQuery = RelMetadataQuery.instance();\n-    Map<RexTableInputRef.RelTableRef, ProjectedFieldsBuilder> fieldMappingBuilders = new HashMap<>();\n+    Map<RexTableInputRef.RelTableRef, JoinedBackFieldsBuilder> fieldMappingBuilders = new HashMap<>();\n     List<RexTableInputRef.RelTableRef> tablesOrdered = new ArrayList<>(); // use this list to keep the order of tables\n     for (RexInputRef expr : projectExpressions) {\n       Set<RexNode> expressionLineage = relMetadataQuery.getExpressionLineage(projectInput, expr);\n       if (expressionLineage == null || expressionLineage.size() != 1) {\n-        LOG.debug(\"Lineage can not be determined of expression: \" + expr);\n+        LOG.debug(\"Lineage of expression can not be determined: \" + expr);", "originalCommit": "c504d19d72e153235a9e5c1a74b6185fb2376b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4ODQyMg==", "url": "https://github.com/apache/hive/pull/1184#discussion_r460188422", "bodyText": "fixed", "author": "kasakrisz", "createdAt": "2020-07-24T17:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODc0Nw==", "url": "https://github.com/apache/hive/pull/1184#discussion_r459818747", "bodyText": "LOG.debug(\"Joining back table {}\", tableToJoinBack.joinedBackFields.relOptHiveTable.getName());", "author": "jcamachor", "createdAt": "2020-07-24T01:59:06Z", "path": "ql/src/java/org/apache/hadoop/hive/ql/optimizer/calcite/rules/HiveCardinalityPreservingJoinOptimization.java", "diffHunk": "@@ -161,127 +174,118 @@ public RelNode trim(RelBuilder relBuilder, RelNode root) {\n         return root;\n       }\n \n-      // 4. Collect fields for new Project on the top of Join backs\n+      // 3. Join back tables to the top of original plan\n       Mapping newInputMapping = trimResult.right;\n-      RexNode[] newProjects = new RexNode[rootFieldList.size()];\n-      String[] newColumnNames = new String[rootFieldList.size()];\n-      projectsFromOriginalPlan(rexBuilder, newInput.getRowType().getFieldCount(), newInput, newInputMapping,\n-          newProjects, newColumnNames);\n+      Map<RexTableInputRef, Integer> tableInputRefMapping = new HashMap<>();\n \n-      // 5. Join back tables to the top of original plan\n       for (TableToJoinBack tableToJoinBack : tableToJoinBackList) {\n-        LOG.debug(\"Joining back table \" + tableToJoinBack.projectedFields.relOptHiveTable.getName());\n+        LOG.debug(\"Joining back table \" + tableToJoinBack.joinedBackFields.relOptHiveTable.getName());", "originalCommit": "c504d19d72e153235a9e5c1a74b6185fb2376b87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4ODQ4Mw==", "url": "https://github.com/apache/hive/pull/1184#discussion_r460188483", "bodyText": "fixed", "author": "kasakrisz", "createdAt": "2020-07-24T17:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxODc0Nw=="}], "type": "inlineReview"}, {"oid": "4f0c089ca817898b3127d2e2b2f977bbc065c3bf", "url": "https://github.com/apache/hive/commit/4f0c089ca817898b3127d2e2b2f977bbc065c3bf", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - address review comments", "committedDate": "2020-07-24T17:20:11Z", "type": "forcePushed"}, {"oid": "92911de050194bc0af1966f73c1ef9c022837b65", "url": "https://github.com/apache/hive/commit/92911de050194bc0af1966f73c1ef9c022837b65", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project", "committedDate": "2020-07-27T07:26:53Z", "type": "commit"}, {"oid": "10d6005b4b8be9ff40201b3de11549ecea69563b", "url": "https://github.com/apache/hive/commit/10d6005b4b8be9ff40201b3de11549ecea69563b", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - prevent adding keys to join condition multiple times", "committedDate": "2020-07-27T07:26:53Z", "type": "commit"}, {"oid": "f2e27d0bac130d2e6787aa61339e9c4097dea15f", "url": "https://github.com/apache/hive/commit/f2e27d0bac130d2e6787aa61339e9c4097dea15f", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - do not join back tables if only keys are projected", "committedDate": "2020-07-27T07:26:53Z", "type": "commit"}, {"oid": "5f03af244a450d1cd24c2b284ee80ca8abc9fd74", "url": "https://github.com/apache/hive/commit/5f03af244a450d1cd24c2b284ee80ca8abc9fd74", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - remove additional feature switch", "committedDate": "2020-07-27T07:26:53Z", "type": "commit"}, {"oid": "0cce30617faed3ebbc06f33860c41327ad7a06fc", "url": "https://github.com/apache/hive/commit/0cce30617faed3ebbc06f33860c41327ad7a06fc", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - address review comments", "committedDate": "2020-07-27T07:34:34Z", "type": "commit"}, {"oid": "194a6d3064c6473a6d68c1cbec990b838961ee55", "url": "https://github.com/apache/hive/commit/194a6d3064c6473a6d68c1cbec990b838961ee55", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - update q test out", "committedDate": "2020-07-27T08:01:17Z", "type": "commit"}, {"oid": "194a6d3064c6473a6d68c1cbec990b838961ee55", "url": "https://github.com/apache/hive/commit/194a6d3064c6473a6d68c1cbec990b838961ee55", "message": "HIVE-23750: Rewrite plan to join back tables: support function calls in project - update q test out", "committedDate": "2020-07-27T08:01:17Z", "type": "forcePushed"}]}