{"pr_number": 3046, "pr_title": "Debugtypes", "pr_createdAt": "2020-12-04T16:33:38Z", "pr_url": "https://github.com/oracle/graal/pull/3046", "timeline": [{"oid": "1c263a83c0a1c905815d5f8011973ea60ac15b0c", "url": "https://github.com/oracle/graal/commit/1c263a83c0a1c905815d5f8011973ea60ac15b0c", "message": "rebase and correct object header layout", "committedDate": "2020-12-06T17:25:43Z", "type": "forcePushed"}, {"oid": "58a9ea21a49254806ca7721ff2c7462ec14b82ff", "url": "https://github.com/oracle/graal/commit/58a9ea21a49254806ca7721ff2c7462ec14b82ff", "message": "rebase and correct object header layout", "committedDate": "2020-12-06T17:35:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDE2NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547244164", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    elementType = debugInfoBase.lookupTypeEntry(elementTypeName);\n          \n          \n            \n                    this.elementType = debugInfoBase.lookupTypeEntry(elementTypeName);", "author": "zakkak", "createdAt": "2020-12-22T12:14:42Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debugentry;\n+\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugArrayTypeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfo.DebugTypeKind;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+public class ArrayTypeEntry extends TypeEntry {\n+    private TypeEntry elementType;\n+    private int headerSize;\n+    private int lengthOffset;\n+\n+    public ArrayTypeEntry(String typeName, int size) {\n+        super(typeName, size);\n+    }\n+\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.ARRAY;\n+    }\n+\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        DebugArrayTypeInfo debugArrayTypeInfo = (DebugArrayTypeInfo) debugTypeInfo;\n+        String elementTypeName = TypeEntry.canonicalize(debugArrayTypeInfo.elementType());\n+        elementType = debugInfoBase.lookupTypeEntry(elementTypeName);", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTEyOA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547245128", "bodyText": "Wouldn't it be safer to use a different name? e.g. primaryFileEntry", "author": "zakkak", "createdAt": "2020-12-22T12:17:04Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -133,10 +122,14 @@ public void addPrimary(Range primary, List<DebugFrameSizeChange> frameSizeInfos,\n                 /* deopt targets should all come after normal methods */\n                 assert includesDeoptTarget == false;\n             }\n+            @SuppressWarnings(\"hiding\")", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNTcyNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551215725", "bodyText": "yes", "author": "adinn", "createdAt": "2021-01-04T09:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTkxMg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547245912", "bodyText": "As above, I would prevent the hiding (especially here where the SuppressWarnings annotation is \"hidden\" in the method signature) by using a different name, e.g. entry in this case.", "author": "zakkak", "createdAt": "2020-12-22T12:18:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -148,13 +141,18 @@ public void addSubRange(Range subrange, FileEntry subFileEntry) {\n          */\n         assert primaryEntry != null;\n         assert primaryEntry.getClassEntry() == this;\n-        primaryEntry.addSubRange(subrange, subFileEntry);\n+        primaryEntry.addSubRange(subrange);\n+        FileEntry subFileEntry = subrange.getFileEntry();\n         if (subFileEntry != null) {\n-            if (localFilesIndex.get(subFileEntry) == null) {\n-                localFiles.add(subFileEntry);\n-                localFilesIndex.put(subFileEntry, localFiles.size());\n-            }\n-            DirEntry dirEntry = subFileEntry.getDirEntry();\n+            indexFileEntry(subFileEntry);\n+        }\n+    }\n+\n+    private void indexFileEntry(@SuppressWarnings(\"hiding\") FileEntry fileEntry) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDA5Ng==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551234096", "bodyText": "Yes, I renamed this to localFileEntry and also changed the method name to indexLocalFileEntry", "author": "adinn", "createdAt": "2021-01-04T10:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzMyNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547247325", "bodyText": "nitpick: I would move this right after the constructor.", "author": "zakkak", "createdAt": "2020-12-22T12:22:16Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjQwMQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551216401", "bodyText": "yeah that's better", "author": "adinn", "createdAt": "2021-01-04T09:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODE1OA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547248158", "bodyText": "Another hiding :)", "author": "zakkak", "createdAt": "2020-12-22T12:24:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNjM3Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551236377", "bodyText": "renamed to methodFileEntry", "author": "adinn", "createdAt": "2021-01-04T10:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0OTE5Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547249197", "bodyText": "Please don't hide fileEntry especially in this method where both this.fileEntry and fileEntry are being used.", "author": "zakkak", "createdAt": "2020-12-22T12:26:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")\n+        FileEntry fileEntry = debugInfoBase.ensureFileEntry(fileName, filePath, cachePath);\n+        methods.add(new MethodEntry(fileEntry, methodName, this, resultType, paramTypeArray, paramNameArray, modifiers));\n     }\n \n-    public Object primaryIndexFor(Range primaryRange) {\n-        return primaryIndex.get(primaryRange);\n-    }\n+    private static String formatParams(List<String> paramTypes, List<String> paramNames) {\n+        if (paramNames.size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        String separator = \"\";\n+        for (int i = 0; i < paramNames.size(); i++) {\n+            builder.append(separator);\n+            builder.append(paramTypes.get(i));\n+            String paramName = paramNames.get(i);\n+            if (paramName.length() > 0) {\n+                builder.append(' ');\n+                builder.append(paramName);\n+            }\n+            separator = \", \";\n+        }\n \n-    public LinkedList<DirEntry> getLocalDirs() {\n-        return localDirs;\n+        return builder.toString();\n     }\n \n-    public LinkedList<FileEntry> getLocalFiles() {\n-        return localFiles;\n+    public boolean isPrimary() {\n+        return primaryEntries.size() != 0;\n     }\n \n-    public boolean includesDeoptTarget() {\n-        return includesDeoptTarget;\n+    public ClassEntry getSuperClass() {\n+        return superClass;\n     }\n \n-    public String getCachePath() {\n-        if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n-            return \"\";\n+    public Range makePrimaryRange(String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, @SuppressWarnings(\"hiding\") FileEntry fileEntry, int lo,", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNzgwNA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551217804", "bodyText": "ok", "author": "adinn", "createdAt": "2021-01-04T10:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0OTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzE2MQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547253161", "bodyText": "Is there any reason to not use this.dirEntry directly?", "author": "zakkak", "createdAt": "2020-12-22T12:35:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDE4NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551234184", "bodyText": "no", "author": "adinn", "createdAt": "2021-01-04T10:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzI4OA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547253288", "bodyText": "Is there any reason to not use this.dirEntry directly?", "author": "zakkak", "createdAt": "2020-12-22T12:35:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {\n+            return \"\";\n+        } else {\n+            return dirEntry.getPathString();\n+        }\n     }\n \n     public String getFullName() {\n-        return getDirEntry() != null ? getDirEntry().getPath().resolve(getFileName()).toString() : getFileName();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxODYwNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551218605", "bodyText": "No :-)", "author": "adinn", "createdAt": "2021-01-04T10:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1OTc1Mw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547259753", "bodyText": "Shouldn't this be not reachable?", "author": "zakkak", "createdAt": "2020-12-22T12:49:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -38,34 +38,158 @@\n  * underlying object file so that the latter can insert appropriate debug info.\n  */\n public interface DebugInfoProvider {\n-    /**\n-     * Access details of a specific type.\n-     */\n-    interface DebugTypeInfo {\n-    }\n+    boolean useHeapBase();\n+\n+    int oopShiftBitCount();\n+\n+    int oopFlagBitsMask();\n+\n+    int oopReferenceByteCount();\n \n     /**\n-     * Access details of a specific compiled method.\n+     * An interface implemented by items that can be located in a file.\n      */\n-    interface DebugCodeInfo {\n-        void debugContext(Consumer<DebugContext> action);\n-\n+    interface DebugFileInfo {\n         /**\n-         * @return the name of the file containing a compiled method excluding any path.\n+         * @return the name of the file containing a file element excluding any path.\n          */\n         String fileName();\n \n         /**\n-         * @return a relative path to the file containing a compiled method derived from its package\n-         *         name or null if the method is in the empty package.\n+         * @return a relative path to the file containing a file element derived from its package\n+         *         name or {@code null} if the element is in the empty package.\n          */\n         Path filePath();\n \n         /**\n-         * @return a relative path to the source cache containing the sources of a compiled method\n-         *         or {@code null} if sources are not available.\n+         * @return a relative path to the source cache containing the cached source file of a file\n+         *         element or {@code null} if sources are not available.\n          */\n         Path cachePath();\n+    }\n+\n+    interface DebugTypeInfo extends DebugFileInfo {\n+        enum DebugTypeKind {\n+            PRIMITIVE,\n+            ENUM,\n+            INSTANCE,\n+            INTERFACE,\n+            ARRAY,\n+            HEADER;\n+\n+            @Override\n+            public String toString() {\n+                switch (this) {\n+                    case PRIMITIVE:\n+                        return \"primitive\";\n+                    case ENUM:\n+                        return \"enum\";\n+                    case INSTANCE:\n+                        return \"instance\";\n+                    case INTERFACE:\n+                        return \"interface\";\n+                    case ARRAY:\n+                        return \"array\";\n+                    case HEADER:\n+                        return \"header\";\n+                    default:\n+                        return \"???\";", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTQ2NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551235464", "bodyText": "Yes, but tell that to my IDE :-)", "author": "adinn", "createdAt": "2021-01-04T10:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1OTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjkyNA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547262924", "bodyText": "This comment looks like there is something missing here (it is not followed by any command).\nIt should be placed above writeBuiltInUnit if I am not mistaken.", "author": "zakkak", "createdAt": "2020-12-22T12:56:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -61,133 +133,1009 @@ public String getSectionName() {\n         return DW_INFO_SECTION_NAME;\n     }\n \n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        // order all content decisions after all size decisions by\n+        // making info section content depend on abbrev section size\n+        String abbrevSectionName = dwarfSections.getAbbrevSectionImpl().getSectionName();\n+        ELFObjectFile.ELFSection abbrevSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(abbrevSectionName);\n+        LayoutDecision sizeDecision = decisions.get(abbrevSection).getDecision(LayoutDecision.Kind.SIZE);\n+        deps.add(BuildDependency.createOrGet(ourContent, sizeDecision));\n+        return deps;\n+    }\n+\n     @Override\n     public void createContent() {\n-        /*\n-         * We need a single level 0 DIE for each compilation unit (CU). Each CU's Level 0 DIE is\n-         * preceded by a fixed header and terminated by a null DIE:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>uint32 length ......... excluding this length field</code>\n-         *\n-         * <li><code>uint16 dwarf_version .. always 2 ??</code>\n-         *\n-         * <li><code>uint32 abbrev offset .. always 0 ??</code>\n-         *\n-         * <li><code>uint8 address_size .... always 8</code>\n-         *\n-         * <li><code>DIE* .................. sequence of top-level and nested child entries</code>\n-         *\n-         * <li><code>null_DIE .............. == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * A DIE is a recursively defined structure. it starts with a code for the associated abbrev\n-         * entry followed by a series of attribute values, as determined by the entry, terminated by\n-         * a null value and followed by zero or more child DIEs (zero iff has_children ==\n-         * no_children).\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of\n-         * DIE</code>\n-         *\n-         * <li><code>attribute_value* ......... value sequence as determined by abbrev entry</code>\n-         *\n-         * <li><code>DIE* ..................... sequence of child DIEs (if appropriate)</code>\n-         * <li><code>\n-         *\n-         * <li><code>null_value ............... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * Note that a null_DIE looks like:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code ....... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * i.e. it also looks like a null_value.\n-         */\n+        assert !contentByteArrayCreated();\n \n         byte[] buffer = null;\n-        int pos = 0;\n+        int len = generateContent(null, buffer);\n \n-        /* CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(null, classEntry, false, buffer, pos);\n-            /*\n-             * No need to backpatch length at lengthPos.\n-             */\n-        }\n-        /* CUs for deopt targets */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            if (classEntry.includesDeoptTarget()) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(null, classEntry, true, buffer, pos);\n-                /*\n-                 * No need to backpatch length at lengthPos.\n-                 */\n-            }\n-        }\n-        buffer = new byte[pos];\n+        buffer = new byte[len];\n         super.setContent(buffer);\n     }\n \n     @Override\n     public void writeContent(DebugContext context) {\n+        assert contentByteArrayCreated();\n+\n         byte[] buffer = getContent();\n         int size = buffer.length;\n         int pos = 0;\n \n         enableLog(context, pos);\n-\n         log(context, \"  [0x%08x] DEBUG_INFO\", pos);\n         log(context, \"  [0x%08x] size = 0x%08x\", pos, size);\n-        /* write CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            /*\n-             * Save the offset of this file's CU so it can be used when writing the aranges section.\n-             */\n-            classEntry.setCUIndex(pos);\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            log(context, \"  [0x%08x] Compilation Unit\", pos, size);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(context, classEntry, false, buffer, pos);\n-            /*\n-             * Backpatch length at lengthPos (excluding length field).\n-             */\n-            patchLength(lengthPos, buffer, pos);\n+\n+        pos = generateContent(context, buffer);\n+        assert pos == size;\n+    }\n+\n+    byte computeEncoding(int flags, int bitCount) {\n+        assert bitCount > 0;\n+        if ((flags & FLAG_NUMERIC) != 0) {\n+            if (((flags & FLAG_INTEGRAL) != 0)) {\n+                if ((flags & FLAG_SIGNED) != 0) {\n+                    switch (bitCount) {\n+                        case 8:\n+                            return DW_ATE_signed_char;\n+                        default:\n+                            assert bitCount == 16 || bitCount == 32 || bitCount == 64;\n+                            return DW_ATE_signed;\n+                    }\n+                } else {\n+                    assert bitCount == 16;\n+                    return DW_ATE_unsigned; // should be UTF???\n+                }\n+            } else {\n+                assert bitCount == 32 || bitCount == 64;\n+                return DW_ATE_float;\n+            }\n+        } else {\n+            assert bitCount == 1;\n+            return DW_ATE_boolean;\n         }\n-        /* write CUs for deopt targets */\n+    }\n+\n+    public int generateContent(DebugContext context, byte[] buffer) {\n+        int pos = 0;\n+        pos = writeBuiltInUnit(context, buffer, pos);\n+\n+        // write entries for all the types known to the generator", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxOTE1OQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551219159", "bodyText": "Yes it should.", "author": "adinn", "createdAt": "2021-01-04T10:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDgwNA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547264804", "bodyText": "Shouldn't we rename this to DW_VERSION instead? Is there any chance to use different dwarf versions in different places?", "author": "zakkak", "createdAt": "2020-12-22T13:00:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -196,7 +1144,7 @@ private int writeCUHeader(byte[] buffer, int p) {\n             /* CU length. */\n             pos += putInt(0, scratch, 0);\n             /* DWARF version. */\n-            pos += putShort(DW_VERSION_2, scratch, 0);\n+            pos += putShort(DW_VERSION_4, scratch, 0);", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMzg0Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551223847", "bodyText": "I am already doing that. The aranges and line sections are still written as DW_VERSION_2.  n.b. it does not cause a problem for gdb.\nStill, you are right that it would be better to write all sections using a single preferred dwarf version. However, before changing anything we will need to carefully check the spec to see if updating the version of those two sections to 4 also requires changes to their format. This is probably best left for a follow-up issue.", "author": "adinn", "createdAt": "2021-01-04T10:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NzY5Mw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547267693", "bodyText": "Consider extracting a new method ResolvedJavaType getJavaType(ResolvedJavaType, boolean) to reduce code duplication (i.e. keep all the instanceof checks in one place)", "author": "zakkak", "createdAt": "2020-12-22T13:07:19Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +156,132 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();\n+\n+    /*\n+     * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+     * getSourceFilename to the wrapped class so for consistency we need to do type names and path\n+     * lookup relative to the doubly unwrapped HostedType.\n+     *\n+     * However, note that the result of the unwrap on the AnalysisType may be a SubstitutionType\n+     * which wraps both an original type and the annotated type that substitutes it. Unwrapping\n+     * normally returns the AnnotatedType which we need to use to resolve the file name. However, we\n+     * need to use the original to name the owning type to ensure that names found in method param\n+     * and return types resolve correctly.\n      */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n+    protected static ResolvedJavaType getJavaType(HostedType hostedType, boolean wantOriginal) {\n+        ResolvedJavaType javaType;\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n+            if (javaType instanceof SubstitutionType) {\n+                return ((SubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof CustomSubstitutionType<?, ?>) {\n+                return ((CustomSubstitutionType<?, ?>) javaType).getOriginal();\n+            } else if (javaType instanceof LambdaSubstitutionType) {\n+                return ((LambdaSubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof InjectedFieldsType) {\n+                return ((InjectedFieldsType) javaType).getOriginal();\n+            } else {\n+                return javaType;\n+            }\n+        }\n+        return hostedType.getWrapped().getWrapped();\n+    }\n+\n+    protected static ResolvedJavaType getJavaType(HostedMethod hostedMethod, boolean wantOriginal) {\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            HostedType hostedType = hostedMethod.getDeclaringClass();\n+            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzMDk5Ng==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551230996", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-04T10:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NzY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTc3OA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547271778", "bodyText": "Redundant?", "author": "zakkak", "createdAt": "2020-12-22T13:16:07Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +310,593 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.\n+                return ((HostedInstanceClass) hostedType).getInstanceSize();\n+            } else if (hostedType instanceof HostedArrayClass) {\n+                // Use the size of header common to all arrays of this type.\n+                return OBJECTLAYOUT.getArrayBaseOffset(hostedType.getComponentType().getStorageKind());\n+            } else if (hostedType instanceof HostedInterface) {\n+                // Use the size of the header common to all implementors.\n+                return OBJECTLAYOUT.getFirstFieldOffset();\n+            } else {\n+                // Use the number of bytes needed needed to store the value.\n+                assert hostedType instanceof HostedPrimitiveType;\n+                JavaKind javaKind = hostedType.getStorageKind();\n+                return (javaKind == JavaKind.Void ? 0 : javaKind.getByteCount());\n+            }\n+        }\n+    }\n+\n+    private class NativeImageHeaderTypeInfo implements DebugHeaderTypeInfo {\n+        String typeName;\n+        int size;\n+        List<DebugFieldInfo> fieldInfos;\n+\n+        NativeImageHeaderTypeInfo(String typeName, int size) {\n+            this.typeName = typeName;\n+            this.size = size;\n+            this.fieldInfos = new LinkedList<>();\n+        }\n+\n+        void addField(String name, String valueType, int offset, @SuppressWarnings(\"hiding\") int size) {\n+            NativeImageDebugHeaderFieldInfo fieldinfo = new NativeImageDebugHeaderFieldInfo(name, typeName, valueType, offset, size);\n+            fieldInfos.add(fieldinfo);\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return typeName;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.HEADER;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path cachePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            return fieldInfos.stream();\n+        }\n+\n+        private class NativeImageDebugHeaderFieldInfo implements DebugFieldInfo {\n+            private final String name;\n+            private final String ownerType;\n+            private final String valueType;\n+            private final int offset;\n+            private final int size;\n+            private final int modifiers;\n+\n+            NativeImageDebugHeaderFieldInfo(String name, String ownerType, String valueType, int offset, int size) {\n+                this.name = name;\n+                this.ownerType = ownerType;\n+                this.valueType = valueType;\n+                this.offset = offset;\n+                this.size = size;\n+                this.modifiers = Modifier.PUBLIC;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return ownerType;\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return valueType;\n+            }\n+\n+            @Override\n+            public int offset() {\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return size;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return modifiers;\n+            }\n+\n+            @Override\n+            public String fileName() {\n+                return \"\";\n+            }\n+\n+            @Override\n+            public Path filePath() {\n+                return null;\n+            }\n+\n+            @Override\n+            public Path cachePath() {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private Stream<DebugTypeInfo> computeHeaderTypeInfo() {\n+        List<DebugTypeInfo> infos = new LinkedList<>();\n+        int hubOffset = OBJECTLAYOUT.getHubOffset();\n+        int referenceSize = OBJECTLAYOUT.getReferenceSize();\n+        int hubFieldSize = referenceSize;\n+        String hubTypeName = \"java.lang.Class\";\n+        int arrayLengthOffset = OBJECTLAYOUT.getArrayLengthOffset();\n+        int arrayLengthSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int idHashOffset = OBJECTLAYOUT.getIdentityHashCodeOffset();\n+        int idHashSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int objHeaderSize = OBJECTLAYOUT.getFirstFieldOffset();\n+        // we need array headers for all Java kinds\n+\n+        NativeImageHeaderTypeInfo objHeader = new NativeImageHeaderTypeInfo(\"_objhdr\", objHeaderSize);\n+        objHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+        if (idHashOffset > 0) {\n+            objHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+        }\n+        infos.add(objHeader);\n+\n+        // create a header for each\n+        for (JavaKind arrayKind : ARRAY_KINDS) {\n+            String name = \"_arrhdr\" + arrayKind.getTypeChar();\n+            int headerSize = OBJECTLAYOUT.getArrayBaseOffset(arrayKind);\n+            NativeImageHeaderTypeInfo arrHeader = new NativeImageHeaderTypeInfo(name, headerSize);\n+            arrHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+            if (idHashOffset > 0) {\n+                arrHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+            }\n+            arrHeader.addField(\"len\", \"int\", arrayLengthOffset, arrayLengthSize);\n+            infos.add(arrHeader);\n+        }\n+        return infos.stream();\n+    }\n+\n+    private class NativeImageDebugEnumTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugEnumTypeInfo {\n+\n+        NativeImageDebugEnumTypeInfo(HostedInstanceClass enumClass) {\n+            super(enumClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ENUM;\n+        }\n+    }\n+\n+    private class NativeImageDebugInstanceTypeInfo extends NativeImageDebugTypeInfo implements DebugInstanceTypeInfo {\n+        NativeImageDebugInstanceTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INSTANCE;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getFirstFieldOffset();\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            Stream<DebugFieldInfo> instanceFieldsStream = Arrays.stream(hostedType.getInstanceFields(false)).map(this::createDebugFieldInfo);\n+            if (hostedType instanceof HostedInstanceClass && hostedType.getStaticFields().length > 0) {\n+                Stream<DebugFieldInfo> staticFieldsStream = Arrays.stream(hostedType.getStaticFields()).map(this::createDebugStaticFieldInfo);\n+                return Stream.concat(instanceFieldsStream, staticFieldsStream);\n+            } else {\n+                return instanceFieldsStream;\n+            }\n+        }\n+\n+        @Override\n+        public Stream<DebugMethodInfo> methodInfoProvider() {\n+            return Arrays.stream(hostedType.getAllDeclaredMethods()).map(this::createDebugMethodInfo);\n+        }\n+\n+        @Override\n+        public String superName() {\n+            HostedClass superClass = hostedType.getSuperclass();\n+            /*\n+             * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+             * getSourceFilename to the wrapped class so for consistency we need to do the path\n+             * lookup relative to the doubly unwrapped HostedType.\n+             */\n+            if (superClass != null) {\n+                return getJavaType(superClass, true).toJavaName();\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Stream<String> interfaces() {\n+            return Arrays.stream(hostedType.getInterfaces()).map(this::toJavaName);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugFieldInfo(HostedField field) {\n+            return new NativeImageDebugFieldInfo(field);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugStaticFieldInfo(ResolvedJavaField field) {\n+            return new NativeImageDebugFieldInfo((HostedField) field);\n+        }\n+\n+        protected NativeImageDebugMethodInfo createDebugMethodInfo(HostedMethod method) {\n+            return new NativeImageDebugMethodInfo(method);\n+        }\n+\n+        protected class NativeImageDebugFieldInfo extends NativeImageDebugFileInfo implements DebugFieldInfo {\n+            private final HostedField field;\n+\n+            NativeImageDebugFieldInfo(HostedField field) {\n+                super(field);\n+                this.field = field;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return field.getName();\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                HostedType valueType = field.getType();\n+                return toJavaName(valueType);\n+            }\n+\n+            @Override\n+            public int offset() {\n+                int offset = field.getLocation();\n+                // for static fields we need to add in the appropriate partition base\n+                // but only if we have a real offset\n+                if (isStatic() && offset >= 0) {\n+                    if (isPrimitive()) {\n+                        offset += primitiveStartOffset;\n+                    } else {\n+                        offset += referenceStartOffset;\n+                    }\n+                }\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return OBJECTLAYOUT.sizeInBytes(field.getType().getStorageKind());\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return field.getModifiers();\n+            }\n+\n+            private boolean isStatic() {\n+                return Modifier.isStatic(modifiers());\n+            }\n+\n+            private boolean isPrimitive() {\n+                return field.getType().getStorageKind().isPrimitive();\n+            }\n+        }\n+\n+        protected class NativeImageDebugMethodInfo extends NativeImageDebugFileInfo implements DebugMethodInfo {\n+            private final HostedMethod hostedMethod;\n+\n+            NativeImageDebugMethodInfo(HostedMethod hostedMethod) {\n+                super(hostedMethod);\n+                this.hostedMethod = hostedMethod;\n+            }\n+\n+            @Override\n+            public String name() {\n+                String name = hostedMethod.format(\"%n\");\n+                if (\"<init>\".equals(name)) {\n+                    ResolvedJavaMethod unwrapped = hostedMethod.getWrapped().getWrapped();\n+                    if (unwrapped instanceof SubstitutionMethod) {\n+                        unwrapped = ((SubstitutionMethod) unwrapped).getOriginal();\n+                    }\n+                    name = unwrapped.format(\"%h\");\n+                    if (name.indexOf('$') >= 0) {\n+                        name = name.substring(name.lastIndexOf('$') + 1);\n+                    }\n+                }\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return hostedMethod.getSignature().getReturnType(null).toJavaName();\n+            }\n+\n+            @Override\n+            public List<String> paramTypes() {\n+                LinkedList<String> paramTypes = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramTypes.add(signature.getParameterType(i, null).toJavaName());\n+                }\n+                return paramTypes;\n+            }\n+\n+            @Override\n+            public List<String> paramNames() {\n+                // can only provide blank names for now\n+                LinkedList<String> paramNames = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramNames.add(\"\");\n+                }\n+                return paramNames;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return hostedMethod.getModifiers();\n+            }\n+        }\n+    }\n+\n+    private class NativeImageDebugInterfaceTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugInterfaceTypeInfo {\n+\n+        NativeImageDebugInterfaceTypeInfo(HostedInterface interfaceClass) {\n+            super(interfaceClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INTERFACE;\n+        }\n+    }\n+\n+    private class NativeImageDebugArrayTypeInfo extends NativeImageDebugTypeInfo implements DebugArrayTypeInfo {\n+        HostedArrayClass arrayClass;\n+\n+        NativeImageDebugArrayTypeInfo(HostedArrayClass arrayClass) {\n+            super(arrayClass);\n+            this.arrayClass = arrayClass;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ARRAY;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getArrayBaseOffset(arrayClass.getComponentType().getStorageKind());\n+        }\n+\n+        @Override\n+        public int lengthOffset() {\n+            return OBJECTLAYOUT.getArrayLengthOffset();\n+        }\n+\n+        @Override\n+        public String elementType() {\n+            HostedType elementType = arrayClass.getComponentType();\n+            return toJavaName(elementType);\n+        }\n+    }\n+\n+    private class NativeImageDebugPrimitiveTypeInfo extends NativeImageDebugTypeInfo implements DebugPrimitiveTypeInfo {\n+        private final HostedPrimitiveType primitiveType;\n+\n+        NativeImageDebugPrimitiveTypeInfo(HostedPrimitiveType primitiveType) {\n+            super(primitiveType);\n+            this.primitiveType = primitiveType;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.PRIMITIVE;\n+        }\n+\n+        @Override\n+        public int bitCount() {\n+            JavaKind javaKind = primitiveType.getStorageKind();\n+            return (javaKind == JavaKind.Void ? 0 : javaKind.getBitCount());\n+        }\n+\n+        @Override\n+        public char typeChar() {\n+            return primitiveType.getStorageKind().getTypeChar();\n+        }\n+\n+        @Override\n+        public int flags() {\n+            char typeChar = primitiveType.getStorageKind().getTypeChar();\n+            switch (typeChar) {\n+                case 'B':\n+                case 'S':\n+                case 'I':\n+                case 'J': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL | FLAG_SIGNED;\n+                }\n+                case 'C': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL;\n+                }\n+                case 'F':\n+                case 'D': {\n+                    return FLAG_NUMERIC;\n+                }\n+                default: {\n+                    assert typeChar == 'V' || typeChar == 'Z';\n+                    return 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    private NativeImageDebugTypeInfo createDebugTypeInfo(HostedType hostedType) {\n+        if (hostedType.isEnum()) {\n+            return new NativeImageDebugEnumTypeInfo((HostedInstanceClass) hostedType);\n+        } else if (hostedType.isInstanceClass()) {\n+            return new NativeImageDebugInstanceTypeInfo(hostedType);\n+        } else if (hostedType.isInterface()) {\n+            return new NativeImageDebugInterfaceTypeInfo((HostedInterface) hostedType);\n+        } else if (hostedType.isArray()) {\n+            return new NativeImageDebugArrayTypeInfo((HostedArrayClass) hostedType);\n+        } else if (hostedType.isPrimitive()) {\n+            return new NativeImageDebugPrimitiveTypeInfo((HostedPrimitiveType) hostedType);\n+        } else {\n+            throw new RuntimeException(\"Unknown type kind \" + hostedType.getName());\n+        }\n+    }\n+\n+    /**\n+     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo extends NativeImageDebugFileInfo implements DebugCodeInfo {\n+        private final HostedMethod hostedMethod;\n+        private final CompilationResult compilation;\n+\n+        @SuppressWarnings(\"try\")", "originalCommit": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzMTQ0Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551231447", "bodyText": "yes", "author": "adinn", "createdAt": "2021-01-04T10:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTc3OA=="}], "type": "inlineReview"}, {"oid": "637d66a875578c991bb171fe720f41b32601d289", "url": "https://github.com/oracle/graal/commit/637d66a875578c991bb171fe720f41b32601d289", "message": "fix index key duplication when a stub and the method it is derived from both get included with -O0", "committedDate": "2021-01-20T16:04:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNDA4OQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562614089", "bodyText": "// comments should be avoided. mx eclipseformat can behave badly when code gets refactored that uses // comments. Use /* my single line comment */ instead.", "author": "olpaw", "createdAt": "2021-01-22T12:59:10Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +304,594 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3NDQ1NQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563674455", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T12:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNDA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNzU0Mg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562617542", "bodyText": "You could use:\n            while (targetMethod instanceof WrappedJavaMethod) {\n                targetMethod = ((WrappedJavaMethod) targetMethod).getWrapped();\n            }", "author": "olpaw", "createdAt": "2021-01-22T13:06:02Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -291,7 +1000,36 @@ public String className() {\n \n         @Override\n         public String methodName() {\n-            return method.format(\"%n\");\n+            ResolvedJavaMethod targetMethod = method;\n+            if (targetMethod instanceof HostedMethod) {", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU5MTExOQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563591119", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T09:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNzU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjM1NQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562632355", "bodyText": "Start all those comments with uppercase", "author": "olpaw", "createdAt": "2021-01-22T13:32:27Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MTgwNQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563671805", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T12:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjYyMA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562632620", "bodyText": "/* Create all the types */ + use the same format elsewhere below.", "author": "olpaw", "createdAt": "2021-01-22T13:33:01Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save mask for low order flag bits\n+         */\n+        oopFlagBitsMask = debugInfoProvider.oopFlagBitsMask();\n+        // flag bits be bewteen 1 and 32 for us to emit as DW_OP_lit<n>\n+        assert oopFlagBitsMask > 0 && oopFlagBitsMask < 32;\n+        // mask must be contiguous from bit 0\n+        assert ((oopFlagBitsMask + 1) & oopFlagBitsMask) == 0;\n+\n+        /*\n+         * save amount we need to shift references by when loading from an object field\n+         */\n+        oopShiftBitCount = debugInfoProvider.oopShiftBitCount();\n+\n+        /*\n+         * save number of bytes in a reference field\n+         */\n+        oopReferenceByteCount = debugInfoProvider.oopReferenceByteCount();\n+\n         /*\n          * Ensure we have a null string in the string section.\n          */\n         stringTable.uniqueDebugString(\"\");\n \n+        // create all the types", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MTg4MQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563671881", "bodyText": "Done", "author": "adinn", "createdAt": "2021-01-25T12:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0MDA4Nw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562640087", "bodyText": "I'd much prefer if the code below uses e.g. DwarfDebugInfo.DW_ABBREV_CODE_field_declaration1 instead of DW_ABBREV_CODE_field_declaration1 so that we do not need all these static imports.", "author": "olpaw", "createdAt": "2021-01-22T13:45:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -26,27 +26,99 @@\n \n package com.oracle.objectfile.elf.dwarf;\n \n+import com.oracle.objectfile.BuildDependency;\n import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ArrayTypeEntry;\n import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.FieldEntry;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.HeaderTypeEntry;\n+import com.oracle.objectfile.debugentry.InterfaceClassEntry;\n import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.PrimitiveTypeEntry;\n import com.oracle.objectfile.debugentry.Range;\n+import com.oracle.objectfile.debugentry.StructureTypeEntry;\n+import com.oracle.objectfile.debugentry.TypeEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n import org.graalvm.compiler.debug.DebugContext;\n \n+import java.lang.reflect.Modifier;\n import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Set;\n \n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_1;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_subprogram;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_SECTION_NAME;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_INTEGRAL;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_NUMERIC;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_SIGNED;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_data_type;", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzYwOTQzOQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563609439", "bodyText": "Yes, that sounds like a better way to do it. I have actually applied the same transform to all the other files in this package that were using static imports.\nDone.", "author": "adinn", "createdAt": "2021-01-25T10:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0MDA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0NDg4MQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562644881", "bodyText": "Aha there it is!\nIf you also have such code why is the explicit & ~0x7L necessary in the example in DebugInfo.md?", "author": "olpaw", "createdAt": "2021-01-22T13:52:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1221,93 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DW_ACCESS_private;\n+        } else {\n+            // package private -- make it public for now\n+            access = DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeOopRelocationExpression(byte[] buffer, int p) {", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1NDM1Mg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562654352", "bodyText": "Use the\n            /*-\n             *\n             *\n             */\n\nmethod, then eclipseformat will not reformat your comment content. (Note the - after /*)", "author": "olpaw", "createdAt": "2021-01-22T14:08:25Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1221,93 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DW_ACCESS_private;\n+        } else {\n+            // package private -- make it public for now\n+            access = DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeOopRelocationExpression(byte[] buffer, int p) {\n+        int pos = p;\n+        if (dwarfSections.useHeapBase()) {\n+            // oop is 32 bit signed offset, possibly shifted by CompressEncoding.getShift()", "originalCommit": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MzY0NQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563673645", "bodyText": "Yes, thanks for the tip.\nDone.", "author": "adinn", "createdAt": "2021-01-25T12:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1NDM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjczOTIyMQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572739221", "bodyText": "Now that we have all this info in the JavaDoc of com.oracle.svm.core.heap.ReferenceAccess please refer to it here instead of replicating.", "author": "olpaw", "createdAt": "2021-02-09T09:50:11Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1326,207 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_private;\n+        } else {\n+            /* Actually package private -- make it public for now. */\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeIndirectOopConversionExpression(boolean isHub, byte[] buffer, int p) {\n+        int pos = p;\n+        /*\n+         * The conversion rules are different depending on whether they apply to the hub class or", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzYzNzk5Mg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573637992", "bodyText": "Done", "author": "adinn", "createdAt": "2021-02-10T11:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjczOTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572751330", "bodyText": "Never store ImageSingletons in static fields.\nImageSingleton values are only valid for a single native-image compilation. If more than one image gets built within the same JVM instance the OBJECTLAYOUT value of the first build will be reused for the second build. In this particular instance you can replace the static field with a static method ...\nstatic ObjectLayout getObjectLayout() {\nreturn ConfigurationValues.getObjectLayout();\n}\n... if using ConfigurationValues.getObjectLayout() directly feels too verbose.", "author": "olpaw", "createdAt": "2021-02-09T10:07:01Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +160,126 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0MDAyNw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573640027", "bodyText": "Done", "author": "adinn", "createdAt": "2021-02-10T11:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY5MDY4OQ==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573690689", "bodyText": "Hmm ... Did you forget to push the related commit/s ?", "author": "olpaw", "createdAt": "2021-02-10T12:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNTUxMw==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572805513", "bodyText": "/* ... */", "author": "olpaw", "createdAt": "2021-02-09T11:24:24Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -280,9 +250,110 @@ public boolean includesDeoptTarget() {\n \n     public String getCachePath() {\n         if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n+    }\n+\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0NjAxNg==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573646016", "bodyText": "Done. The only remaining // comments are to exclude generation of speculative/currently unavailable field declarations for abbrev record in DwarfAbbrevSectionImpl.java. I really want to leave those as they are place-holders for possible future upgrades.", "author": "adinn", "createdAt": "2021-02-10T11:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNjE4MA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572806180", "bodyText": "Sometimes your comments still start with lowercase ...", "author": "olpaw", "createdAt": "2021-02-09T11:25:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -119,36 +160,95 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          */\n \n         /*\n-         * Ensure we have a null string in the string section.\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save count of low order tag bits that may appear in references\n          */\n+        int oopTagsMask = debugInfoProvider.oopTagsMask();\n+\n+        /* tag bits must be between 1 and 32 for us to emit as DW_OP_lit<n> */\n+        assert oopTagsMask > 0 && oopTagsMask < 32;\n+        /* mask must be contiguous from bit 0 */\n+        assert ((oopTagsMask + 1) & oopTagsMask) == 0;\n+\n+        oopTagsCount = Integer.bitCount(oopTagsMask);\n+\n+        /* Save amount we need to shift references by when loading from an object field. */\n+        oopCompressShift = debugInfoProvider.oopCompressShift();\n+\n+        /* shift bit count must be either 0 or 3 */\n+        assert (oopCompressShift == 0 || oopCompressShift == 3);\n+\n+        /* Save number of bytes in a reference field. */\n+        oopReferenceSize = debugInfoProvider.oopReferenceSize();\n+\n+        /* Save alignment of a reference */\n+        oopAlignment = debugInfoProvider.oopAlignment();\n+\n+        /* Save alignment of a reference */\n+        oopAlignShift = Integer.bitCount(oopAlignment - 1);\n+\n+        /* reference alignment must be 8 bytes */", "originalCommit": "2ef088d7122ed0b7f654bbe07c219344d89cc599", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0Nzg5NA==", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573647894", "bodyText": "Yeah, sorry for that. I keep forgetting about this. I think I have found all such cases and corrected them.", "author": "adinn", "createdAt": "2021-02-10T11:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNjE4MA=="}], "type": "inlineReview"}, {"oid": "e3006a22f50e6d5fd968f37a87b46f988b560ae1", "url": "https://github.com/oracle/graal/commit/e3006a22f50e6d5fd968f37a87b46f988b560ae1", "message": "Basic cut of DebugTypeInfo interface and implementation", "committedDate": "2021-02-10T14:46:07Z", "type": "commit"}, {"oid": "b307ee84155fb340719a658a7be2cc9159c49c02", "url": "https://github.com/oracle/graal/commit/b307ee84155fb340719a658a7be2cc9159c49c02", "message": "Update debug info model to include details of types\n\nfirst cut of debug info model and DWARF generator employing class layouts\n\nrebase on updated master + doc and style fixes\n\nfix problem with method name computation\n\ntest type and instance printing from debuginfotest script building without isolates\n\nfix method name and file lookup\n\nupdate documentation to include details of debug type info support\n\napply consistent file lookup rules", "committedDate": "2021-02-10T14:46:22Z", "type": "commit"}, {"oid": "9c5f2150ac559e086f3f72140060821ab99f6554", "url": "https://github.com/oracle/graal/commit/9c5f2150ac559e086f3f72140060821ab99f6554", "message": "Switch C++ mapping to use Java names for base types and pointers for oops\n\nensure gdb can decode object references to addresses\n\nstyle fixes\n\nrebase and correct object header layout\n\nstyle fixes\n\nfix debuginfotest script\n\neclipse style fixes\n\ndisable test of object layout printing if gdb version less than 10\n\ncorrect pattern for gdb version match\n\ncorrections after zakkak review\n\neclipse style fixes\n\nfix index key duplication when a stub and the method it is derived from both get included with -O0\n\nfix error in lookup of original class for methods and fields\nfix related problem with constructor method names\n\nuse gdb from env var GDB_BIN if available\n\nFix typos and out of date content\n\nsimplify code\n\nadd check for printing of statci fields\n\navoid numerous static imports of constants\n\nstyle fixes\n\nadd details of currently missing features", "committedDate": "2021-02-10T14:46:33Z", "type": "commit"}, {"oid": "9757c9c94e78615d039ded8ee87bc3ab2c0351ce", "url": "https://github.com/oracle/graal/commit/9757c9c94e78615d039ded8ee87bc3ab2c0351ce", "message": "Fix conversion of indirect to war oops using wrapper subclasses", "committedDate": "2021-02-10T14:46:41Z", "type": "commit"}, {"oid": "20618672227ec0e86c17fc4953992966acf3c575", "url": "https://github.com/oracle/graal/commit/20618672227ec0e86c17fc4953992966acf3c575", "message": "Make arrays subtype object and include length as a local field\n\nminor tweak to object sizing routines", "committedDate": "2021-02-10T14:46:48Z", "type": "commit"}, {"oid": "2c3c8abf4c59df5492f9add84f8d5b442c56825d", "url": "https://github.com/oracle/graal/commit/2c3c8abf4c59df5492f9add84f8d5b442c56825d", "message": "Correct debug info test script for new object layout and to bypass latest gdb bug\n\nminor code cleanups\n\nstyle fixes\n\nfix comment text\n\nfurther fixes after latest review", "committedDate": "2021-02-10T14:46:56Z", "type": "commit"}, {"oid": "2c3c8abf4c59df5492f9add84f8d5b442c56825d", "url": "https://github.com/oracle/graal/commit/2c3c8abf4c59df5492f9add84f8d5b442c56825d", "message": "Correct debug info test script for new object layout and to bypass latest gdb bug\n\nminor code cleanups\n\nstyle fixes\n\nfix comment text\n\nfurther fixes after latest review", "committedDate": "2021-02-10T14:46:56Z", "type": "forcePushed"}]}