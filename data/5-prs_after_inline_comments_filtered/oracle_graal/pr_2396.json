{"pr_number": 2396, "pr_title": "Windows debug information prototype", "pr_createdAt": "2020-04-24T20:02:43Z", "pr_url": "https://github.com/oracle/graal/pull/2396", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc0ODk3Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r415748977", "bodyText": "For that I'd use:\npublic static Range withLoHi(int lo, int hi) {\n    Range that = this.clone();\n    that.lo = lo;\n    that.hi = hi;\n}", "author": "olpaw", "createdAt": "2020-04-27T11:55:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -79,6 +83,25 @@ public Range(String fileName, Path filePath, String className, String methodName\n         this.primary = primary;\n     }\n \n+    /*\n+     * Create a slightly different copy of a previously constructed range. Because the previous\n+     * range was constructed by one of the other constructors, a valid assumption is that all the\n+     * strings have previously been inserted int he stringTable, and we can avoid doing that again.\n+     */\n+    public Range(Range other, int lo, int hi) {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1MTU4OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418051589", "bodyText": "This is much cleaner.  My goal was to avoid modifying Range members after construction (I want to make them final), and to avoid calling uniqueString() multiple times.\nWhile your suggestion doesn't help with my goal of immutability, it is much more readable.\nI've adopted it, and may make immutability a separate PR after some discussion.", "author": "stooke", "createdAt": "2020-04-30T14:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc0ODk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r415750301", "bodyText": "It would be great if we find a CLASS_DELIMITER that works for both platforms.", "author": "olpaw", "createdAt": "2020-04-27T11:57:39Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -36,6 +36,10 @@\n  */\n \n public class Range {\n+\n+    /* Use '.' for PECOFF files */\n+    private static final String CLASS_DELIMITER = System.getProperty(\"os.name\").toLowerCase().contains(\"windows\") ? \".\" : \"::\";", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcyOTcwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r416729703", "bodyText": "Well, I only used :: because I was mimicking the format used for C++ code (gdb doesn't really understand Java). Once we embed DWARF method info records into a DWARF type info record this ought not to be a concern. So, I am happy to go with '. as the separator.", "author": "adinn", "createdAt": "2020-04-28T15:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMDUwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417120501", "bodyText": "Yes. Please lets use . as CLASS_DELIMITER for all platforms.", "author": "olpaw", "createdAt": "2020-04-29T07:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwNDIyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418104222", "bodyText": "@adinn, if I change this to always be '.' in this PR, is it too soon, or would you prefer to wait until there are DWARF MethodInfo records?", "author": "stooke", "createdAt": "2020-04-30T15:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1MDY3MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418150671", "bodyText": "No, please change it to use '.' for both.", "author": "adinn", "createdAt": "2020-04-30T16:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1ODc5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r415758796", "bodyText": "This looks a lot like java.nio.ByteBuffer", "author": "olpaw", "createdAt": "2020-04-27T12:11:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc1NTk1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r416755952", "bodyText": "Yes it does, modulo endianness.\nThere is a history as to why Simon is not using a ByteBuffer. I followed a similar path with the Dwarf sections implementation classes where the DwarfSectionsImpl.writeXXX methods bottom out at similar looking base DwarfSectionsImpl.putXXX methods.\nWhen trying to size a section the writeXXX methods are passed a null buffer and they compute the size by recursively writing the relevant contents using further writeXXX or putXXX calls and summing the number of bytes written. When a writeXXX method bottoms out at a putXXX method a scratch buffer is passed when the input buffer is null so the computed size reflects the precise number of bytes written. The same top level writeXXX method can then be used to write a buffer allocated with the required total. I thought about using a ByteBuffer when I wrote it this way but decided to keep the byte[] until I saw that there was no need to be able to do raw byte level peeks and pokes on the underlying array.\nIt would be fairly straightforward to achieve the same outcome by passing a ByteBuffer or null to the writeXXX calls and replacing the putXXX calls with invocations of the relevant ByteBuffer put method. However, what I was planning to do was create a new class, let's call it SectionByteBuffer, with two variants. A StandardSectionByteBuffer would recursively assemble the relevant data into a target byte[] via an encapsulated ByteBuffer. A SizingSectionByteBuffer would throw away the data and simply update a buffer offset to reflect the data written by a putXXX operation.\nI was thinking it would be better to fix this for both implementations as a separate patch. Would that be ok? Alternatively, we could make the change to both Linux and Windows debug code now?", "author": "adinn", "createdAt": "2020-04-28T16:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1ODc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417225125", "bodyText": "Is there a reason why you want a toString for FileEntry but not for other elements of the debug info model?", "author": "adinn", "createdAt": "2020-04-29T10:48:31Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -59,4 +59,14 @@ public String getFullName() {\n     public DirEntry getDirEntry() {\n         return dirEntry;\n     }\n+", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1MTY3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418051672", "bodyText": "Originally, I had them everywhere; it saved much time while debugging. There's one on Range, too. I'm happy to get rid of them or add a couple more.  I think some were lost when we refactored these classes to be shared.", "author": "stooke", "createdAt": "2020-04-30T14:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDk5Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418090992", "bodyText": "Well, if hey are not particularly important then I would say less code is better", "author": "adinn", "createdAt": "2020-04-30T15:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MzAxMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418093011", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-04-30T15:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxNTg1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417915850", "bodyText": "I'm not clear why you need JDK_SOURCE_BASE or GRAAL_SOURCE_BASE. They are not used. Will they be needed?", "author": "adinn", "createdAt": "2020-04-30T10:36:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SYMBOL_SECTION_NAME = \".debug$S\";\n+    static final String CV_TYPE_SECTION_NAME = \".debug$T\";\n+    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n+    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n+    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n+    // static final String TEXT_SECTION_NAME = \".text\";\n+    // static final String DATA_SECTION_NAME = \".data\";\n+\n+    /* CodeView section header signature */\n+    static final int CV_SIGNATURE_C13 = 4;\n+\n+    /*\n+     * Knobs\n+     *\n+     * (some may become Graal options in the future)\n+     */\n+\n+    /*", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1Mzg0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418053841", "bodyText": "They were temporary hooks that could have been turned into svm options; they predate the SourceCache.  Gone.", "author": "stooke", "createdAt": "2020-04-30T14:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxNTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417924749", "bodyText": "It is probably an interesting idea to play with most of the following options but in the end I think we need 1) to implement them uniformly for gdb and CV and 2) converge on a setting that works best rather than expand the already large numebr of config choices. @olpaw may want to chime in here.", "author": "adinn", "createdAt": "2020-04-30T10:53:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SYMBOL_SECTION_NAME = \".debug$S\";\n+    static final String CV_TYPE_SECTION_NAME = \".debug$T\";\n+    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n+    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n+    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n+    // static final String TEXT_SECTION_NAME = \".text\";\n+    // static final String DATA_SECTION_NAME = \".data\";\n+\n+    /* CodeView section header signature */\n+    static final int CV_SIGNATURE_C13 = 4;\n+\n+    /*\n+     * Knobs\n+     *\n+     * (some may become Graal options in the future)\n+     */\n+\n+    /*\n+     * path to JDK source code (for example unzipped src.zip) If set, source paths for JDK classes\n+     * in the object file will be $JDK_SOURCE_BASE/java/package/someclass.java instead of (cache\n+     * directory)/sources/jdk/java/package/someclass.java or (if source cache is disabled)\n+     * java/package/someclass.java\n+     *\n+     * example JDK_SOURCE_BASE = C:\\\\tmp\\\\graal-8\\\\jdk8_jvmci\\\\src\\\\\";\n+     */\n+    static final String JDK_SOURCE_BASE = \"\";\n+\n+    /*\n+     * path to Graal source code base (for examplke checked out Graal source repository) if set\n+     * source paths will be inferred from appropriate Graal package directories (behaves similarly\n+     * to JDK_SOURCE_BASE)\n+     *\n+     * Example: GRAAL_SOURCE_BASE = \"C:\\\\tmp\\\\graal-8\\\\graal8\\\\\";\n+     */\n+    static final String GRAAL_SOURCE_BASE = \"\";\n+\n+    /*\n+     * if true, don't emit debug code for Graal classes.\n+     */\n+    static final boolean skipGraalInternals = false;\n+\n+    /*\n+     * (unimplemented) if true, don't emit debug code for JDK classes.\n+     */\n+    static final boolean skipJDKInternals = false;\n+\n+    /*\n+     * if true, Graal inlined code treated as user generated code. (less complicated for user-level\n+     * debugging)\n+     */\n+    static final boolean skipGraalIntrinsics = false;\n+\n+    /*\n+     * if a line record is the same line in the same file as the previous record, merge them.\n+     */\n+    static final boolean mergeAdjacentLineRecords = true;", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzODM3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417938374", "bodyText": "Every option added increases the risk that any two consumers of debuginfo generated by native-image will see different data. Thus we have to be very careful with adding user adjustable options. Tools that consume our debuginfo (e.g. gdb python helpers) are much easier to write (and maintain) when there is less variability in its generation.", "author": "olpaw", "createdAt": "2020-04-30T11:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1NjExNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418056117", "bodyText": "If two continuous Ranges reference the same source position, isn't it more efficient to merge them? This makes a significant difference in debug information size. Probably the appropriate place to do this would be when creating the Ranges; at one point I had it there.  This would make all debug information consistent.  I will take this out now and make it a separate PR later.", "author": "stooke", "createdAt": "2020-04-30T14:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MjI4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418092285", "bodyText": "Yes, so no switch needed just always do it ... and we can make sure the Linux code does the same.", "author": "adinn", "createdAt": "2020-04-30T15:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODg3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417928874", "bodyText": "I'm not sure this is going to be needed? is there a reason why debugging the native image in a project that uses the cached source bundle is going to be unsatisfactory?\nRemember once again that the target audience for this debug capability is not developers during developement of an app but developers trying to debug a problem in a deployed native app that has already been tested and shown to work on OpenJDK. So, trying to get the debug info back to refer back to an existing dev project source tree should not really be a concern?", "author": "adinn", "createdAt": "2020-04-30T11:01:49Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /*\n+     * Convert a simple path into an absolute path by determining if it's part of Graal, the JDK, or\n+     * use code.\n+     *\n+     * Currently, don't even try; use the SourceCache system\n+     */\n+    private static String fixPath(FileEntry fileEntry) {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1OTIxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418259219", "bodyText": "I've rewritten the comment on this (and coded it better).  It protects against an NPE when there is no DirEntry in the FileEntry.  I don't remember the circumstances, but it happens in this code.", "author": "stooke", "createdAt": "2020-04-30T20:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU0NzUzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418547538", "bodyText": "Hmm, I was not expecting that to happen but I suppose it might occur for a class in the default package.\nI'm not sure this is the right place to fix it though. I think it would be better to fix FileEntry.getFullName to detect that dirEntry is null and in that case just return getFileName().", "author": "adinn", "createdAt": "2020-05-01T13:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNDA3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417934070", "bodyText": "This is very fragile in the face of future GraalVM development. You don't actually need to list every single Graal package just the package roots that can be guaranteed to cover all current packages (and are pretty sure to capture any future additions). If you look at GraalSourceCache it employs a much smaller set of package prefixes to determine that a class is GraalVM code (and hence needs its source located in a src.zip file rather than a jar). It's still fragile in but much less so. If all of this is really needed to allow the skipGraalInternals mode to work then I think maybe that's a good reason not to retain that mode.\nThe same issue arises with the list of intrinsic classes that follows.", "author": "adinn", "createdAt": "2020-04-30T11:12:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVRootPackages.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+\n+abstract class CVRootPackages {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1ODI1NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418258255", "bodyText": "I know.  It hurt to write.  It's gone.", "author": "stooke", "createdAt": "2020-04-30T20:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNzE3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417937179", "bodyText": "I think there may be a problem here that currently exists in the SourceCache code. As far as the source caches are concerned the package filter on \"javax.* packages\" is used to identify that a class belongs to the JDK runtime and that it's source can be found in the src.zip distributed with the JDK. I don't think that is strictly correct as I believe there are implementations of javax.* packages in Java EE components i.e. which ought to be treated as application classes. I'm not clear but I suspect the same problem applies with your test here. Anyway, I'm also still dubious as to why users might want to be able not to see JDK runtime code given the assumed use case for this debug capability.", "author": "adinn", "createdAt": "2020-04-30T11:19:28Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVRootPackages.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+\n+abstract class CVRootPackages {\n+    private static final String[] rootPackageNames = {\n+                    /* substrate root packages */\n+                    \"com.oracle.graal.pointsto\",\n+                    \"com.oracle.objectfile\",\n+                    \"com.oracle.svm.agent\",\n+                    \"com.oracle.svm.configure\",\n+                    \"com.oracle.svm.core\",\n+                    \"com.oracle.svm.core.genscavenge\",\n+                    \"com.oracle.svm.core.graal\",\n+                    \"com.oracle.svm.core.graal.aarch64\",\n+                    \"com.oracle.svm.core.graal.amd64\",\n+                    \"com.oracle.svm.core.graal.llvm\",\n+                    \"com.oracle.svm.core.jdk11\",\n+                    \"com.oracle.svm.core.jdk8\",\n+                    \"com.oracle.svm.core.posix\",\n+                    \"com.oracle.svm.core.posix.jdk11\",\n+                    \"com.oracle.svm.core.windows\",\n+                    \"com.oracle.svm.driver\",\n+                    \"com.oracle.svm.graal\",\n+                    \"com.oracle.svm.graal.hotspot.libgraal\",\n+                    \"com.oracle.svm.hosted\",\n+                    \"com.oracle.svm.jline\",\n+                    \"com.oracle.svm.jni\",\n+                    \"com.oracle.svm.junit\",\n+                    \"com.oracle.svm.libffi\",\n+                    \"com.oracle.svm.native.jvm.posix\",\n+                    \"com.oracle.svm.native.jvm.windows\",\n+                    \"com.oracle.svm.native.libchelper\",\n+                    \"com.oracle.svm.native.strictmath\",\n+                    \"com.oracle.svm.polyglot\",\n+                    \"com.oracle.svm.reflect\",\n+                    \"com.oracle.svm.test\",\n+                    \"com.oracle.svm.test.jdk11\",\n+                    \"com.oracle.svm.thirdparty\",\n+                    \"com.oracle.svm.truffle\",\n+                    \"com.oracle.svm.truffle.nfi\",\n+                    \"com.oracle.svm.truffle.nfi.posix\",\n+                    \"com.oracle.svm.truffle.nfi.windows\",\n+                    \"com.oracle.svm.tutorial\",\n+                    \"com.oracle.svm.util\",\n+                    \"com.oracle.svm.util.jdk11\",\n+                    \"org.graalvm.polyglot.nativeapi\",\n+                    /* compiler root packages */\n+                    \"jdk.tools.jaotc\",\n+                    \"jdk.tools.jaotc.binformat\",\n+                    \"jdk.tools.jaotc\",\n+                    \"org.graalvm.compiler.api.directives\",\n+                    \"org.graalvm.compiler.api.replacements\",\n+                    \"org.graalvm.compiler.api.runtime\",\n+                    \"org.graalvm.compiler.asm\",\n+                    \"org.graalvm.compiler.asm.aarch64\",\n+                    \"org.graalvm.compiler.asm.amd64\",\n+                    \"org.graalvm.compiler.asm.sparc\",\n+                    \"org.graalvm.compiler.bytecode\",\n+                    \"org.graalvm.compiler.code\",\n+                    \"org.graalvm.compiler.core\",\n+                    \"org.graalvm.compiler.core.aarch64\",\n+                    \"org.graalvm.compiler.core.amd64\",\n+                    \"org.graalvm.compiler.core.common\",\n+                    \"org.graalvm.compiler.core.llvm\",\n+                    \"org.graalvm.compiler.core.match.processor\",\n+                    \"org.graalvm.compiler.core.sparc\",\n+                    \"org.graalvm.compiler.debug\",\n+                    \"org.graalvm.compiler.graph\",\n+                    \"org.graalvm.compiler.hotspot\",\n+                    \"org.graalvm.compiler.hotspot.aarch64\",\n+                    \"org.graalvm.compiler.hotspot.amd64\",\n+                    \"org.graalvm.compiler.hotspot.jdk8\",\n+                    \"org.graalvm.compiler.hotspot.management\",\n+                    \"org.graalvm.compiler.hotspot.sparc\",\n+                    \"org.graalvm.compiler.java\",\n+                    \"org.graalvm.compiler.jtt\",\n+                    \"org.graalvm.compiler.lir\",\n+                    \"org.graalvm.compiler.lir.aarch64\",\n+                    \"org.graalvm.compiler.lir.amd64\",\n+                    \"org.graalvm.compiler.lir.jtt\",\n+                    \"org.graalvm.compiler.lir.sparc\",\n+                    \"org.graalvm.compiler.loop\",\n+                    \"org.graalvm.compiler.loop.phases\",\n+                    \"org.graalvm.compiler.microbenchmarks\",\n+                    \"org.graalvm.compiler.nodeinfo\",\n+                    \"org.graalvm.compiler.nodeinfo.processor\",\n+                    \"org.graalvm.compiler.nodes\",\n+                    \"org.graalvm.compiler.options\",\n+                    \"org.graalvm.compiler.options.processor\",\n+                    \"org.graalvm.compiler.phases\",\n+                    \"org.graalvm.compiler.phases.common\",\n+                    \"org.graalvm.compiler.printer\",\n+                    \"org.graalvm.compiler.processor\",\n+                    \"org.graalvm.compiler.replacements\",\n+                    \"org.graalvm.compiler.replacements.aarch64\",\n+                    \"org.graalvm.compiler.replacements.amd64\",\n+                    \"org.graalvm.compiler.replacements.processor\",\n+                    \"org.graalvm.compiler.replacements.sparc\",\n+                    \"org.graalvm.compiler.runtime\",\n+                    \"org.graalvm.compiler.serviceprovider\",\n+                    \"org.graalvm.compiler.serviceprovider.jdk8\",\n+                    \"org.graalvm.compiler.serviceprovider.processor\",\n+                    \"org.graalvm.compiler.truffle.common\",\n+                    \"org.graalvm.compiler.truffle.common.hotspot\",\n+                    \"org.graalvm.compiler.truffle.common.hotspot.libgraal\",\n+                    \"org.graalvm.compiler.truffle.common.processor\",\n+                    \"org.graalvm.compiler.truffle.compiler\",\n+                    \"org.graalvm.compiler.truffle.compiler.amd64\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.aarch64\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.amd64\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.libgraal\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.libgraal.processor\",\n+                    \"org.graalvm.compiler.truffle.compiler.hotspot.sparc\",\n+                    \"org.graalvm.compiler.truffle.runtime\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot.java\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot.jdk8+13\",\n+                    \"org.graalvm.compiler.truffle.runtime.hotspot.libgraal\",\n+                    \"org.graalvm.compiler.truffle.runtime.serviceprovider\",\n+                    \"org.graalvm.compiler.truffle.runtime.serviceprovider.jdk8\",\n+                    \"org.graalvm.compiler.virtual\",\n+                    \"org.graalvm.compiler.virtual.bench\",\n+                    \"org.graalvm.compiler.word\",\n+                    \"org.graalvm.graphio\",\n+                    \"org.graalvm.libgraal\",\n+                    \"org.graalvm.libgraal.jdk8\",\n+                    \"org.graalvm.micro.benchmarks\",\n+                    \"org.graalvm.util\",\n+    };\n+\n+    private static final String[] intrinsicClassNames = {\n+                    \"com.oracle.svm.core.genscavenge.AlignedHeapChunk\",\n+                    \"com.oracle.svm.core.genscavenge.CardTable\",\n+                    \"com.oracle.svm.core.genscavenge.ObjectHeaderImpl\",\n+                    \"com.oracle.svm.core.genscavenge.graal.GenScavengeAllocationSnippets\",\n+                    \"com.oracle.svm.core.genscavenge.graal.BarrierSnippets\",\n+                    \"com.oracle.svm.core.snippets.KnownIntrinsics\",\n+                    \"com.oracle.svm.core.graal.snippets.SubstrateAllocationSnippets\",\n+                    \"com.oracle.svm.core.threadlocal.FastThreadLocalBytes\",\n+                    \"org.graalvm.compiler.replacements.AllocationSnippets\",\n+                    \"org.graalvm.compiler.nodes.PrefetchAllocateNode\",\n+                    \"com.oracle.svm.core.os.CopyingImageHeapProvider\"\n+    };\n+\n+    private static final HashSet<String> rootPackageSet;\n+    private static final HashSet<String> intrinsicClassNameSet;\n+\n+    static {\n+        rootPackageSet = new HashSet<>(rootPackageNames.length);\n+        Collections.addAll(rootPackageSet, rootPackageNames);\n+        intrinsicClassNameSet = new HashSet<>(intrinsicClassNames.length);\n+        Collections.addAll(intrinsicClassNameSet, intrinsicClassNames);\n+    }\n+\n+    static boolean isGraalPackage(String pn) {\n+        return rootPackageSet.contains(pn);\n+    }\n+\n+    private static String getPackagename(String className) {\n+        return className.contains(\".\") ? className.substring(0, className.lastIndexOf('.')) : className;\n+    }\n+\n+    static boolean isGraalClass(String cn) {\n+        final String pn = getPackagename(cn);\n+        return isGraalPackage(pn);\n+    }\n+\n+    /**\n+     * is class a Graal intrinsic class?\n+     *\n+     * @param cn class name of code\n+     * @return true if this is Graal intrinsic code\n+     */\n+    static boolean isGraalIntrinsic(String cn) {\n+        return intrinsicClassNameSet.contains(cn);\n+    }\n+\n+    static boolean isJavaPackage(String pn) {", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5OTcwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r417999709", "bodyText": "I'm not clear where the need for making this public this arose? Can you point at where this is used?", "author": "adinn", "createdAt": "2020-04-30T13:14:48Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageOptions.java", "diffHunk": "@@ -60,7 +60,7 @@\n     public static final HostedOptionKey<Boolean> NativeArchitecture = new HostedOptionKey<>(false);\n \n     @Option(help = \"Define PageSize of a machine that runs the image. The default = 0 (== same as host machine page size)\")//\n-    protected static final HostedOptionKey<Integer> PageSize = new HostedOptionKey<>(0);\n+    public static final HostedOptionKey<Integer> PageSize = new HostedOptionKey<>(0);", "originalCommit": "ae54dad6eebb244a96e6123cb61380f282cece47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1ODkxOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r418058918", "bodyText": "This doesn't belong in this PR, sorry.  At the time it seemed inconsistent, but this isn't the place for it.  Removed.", "author": "stooke", "createdAt": "2020-04-30T14:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk5OTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2Mjk5NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432562995", "bodyText": "This and all other Red Hat copyright lines need to specify \"2020, 2020,\" as per the Oracle copyright line", "author": "adinn", "createdAt": "2020-05-29T15:27:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0ODAxMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438948012", "bodyText": "Done, for the contents of this PR.  Should I fix other Red Hat copyright lines?", "author": "stooke", "createdAt": "2020-06-11T17:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2Mjk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NDM4Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432564382", "bodyText": "I think this argument ought to be CV_SYMBOL_SECTION_NAME from class CVConstants", "author": "adinn", "createdAt": "2020-05-29T15:30:10Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* define the section as a COFF symbol */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n+         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n+         * Other info formats use their own format-specific prefix.\n+         */\n+        assert getSectionName().startsWith(\".debug$\");", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIxNjY2OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433216668", "bodyText": "Actually, it's just the prefix, because there are (at least) several section names used by CV4 (I currently implement only two - symbols and types).  I have added a prefix constant in CVConstants and will use it here.", "author": "stooke", "createdAt": "2020-06-01T12:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIzNTE4Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433235183", "bodyText": "Ah yes, sorry. I missed the extra S at the end of CV_SYMBOL_SECTION_NAME and likewise CV_TYPE_SECTION_NAME ending with T. Adding a final static field for the prefix and using it here as well as to define the other symbols is a good idea.", "author": "adinn", "createdAt": "2020-06-01T13:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTI3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432565273", "bodyText": "This is not called so ought to be deleted", "author": "adinn", "createdAt": "2020-05-29T15:31:38Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.io.PrintStream;\n+\n+final class CVStringTableRecord extends CVSymbolRecord {\n+\n+    private final CVSymbolSectionImpl.CVStringTable stringTable;\n+\n+    CVStringTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable stringTable) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_STRINGTABLE);\n+        this.stringTable = stringTable;\n+    }\n+\n+    int add(String string) {\n+        return stringTable.add(string);\n+    }\n+\n+    @Override\n+    public int computeSize(int pos) {\n+        return computeContents(null, pos);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (CVSymbolSectionImpl.CVStringTable.StringTableEntry entry : stringTable.values()) {\n+            pos = CVUtil.putUTF8StringBytes(entry.text, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVStringTableRecord(type=0x%04x pos=0x%06x count=%d)\", type, recordStartPosition, stringTable.size());\n+    }\n+\n+    public void dump(PrintStream out) {", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDYxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438980619", "bodyText": "Unclear if this comments refers to dump() or toString(); I've assumed the former and deleted it.", "author": "stooke", "createdAt": "2020-06-11T18:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3Njc1NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432576754", "bodyText": "If you pass the debugContext either to the constructor or the build method you can make this debug method do some useful logging. If not then you need to remove it and the debug calls.", "author": "adinn", "createdAt": "2020-05-29T15:50:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+public class CVLineRecordBuilder {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public static void debug(@SuppressWarnings(\"unused\") String format, @SuppressWarnings(\"unused\") Object... args) {", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI2MzU2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433263565", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-06-01T14:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3Njc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDQ4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432580485", "bodyText": "Same thing here with this debug call. If you pass the DebugContext to the builder constructor or build method then you can actually generate debug trace. If not then delete the comments.", "author": "adinn", "createdAt": "2020-05-29T15:55:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    @SuppressWarnings(\"unused\") private DebugContext debugContext = null;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                // for each function\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {\n+                    previousMethodName = newMethodName;\n+                    build(primaryEntry, newMethodName);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required)\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+        // debug(\"addfunc(\" + methodName + \") numtypes = %d\\n\",", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDUzMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438980533", "bodyText": "I deleted these commented out logging statements.", "author": "stooke", "createdAt": "2020-06-11T18:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432584547", "bodyText": "There is no point calling verboseLog when you have set debug = false directly above.\nn.b. In the ELF create/writeContent methods that field stops shared utility methods logging data at both createContent and writeContent time. But your create/write methods just cut and pastes the same inline code. So, you should either omit the log call under createContent or put the common code into a utility method called from both.", "author": "adinn", "createdAt": "2020-05-29T16:01:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        // enableLog(debugContext, pos);\n+        debug = false;\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk3NzIxNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438977214", "bodyText": "the variable 'debug' can be unset at development time; some decisions are made then, so I need a way to see what's happening while working on this code. Logging in createContent() is uninteresting to the end user, but very interesting to the developer.  I've cleaned it up a bit, and I'm open to suggestions that allow me to turn logging during the createContent() phase on and off, but I'm going to need to log this phase until the type information code has been added.", "author": "stooke", "createdAt": "2020-06-11T18:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2MzY3MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r440163671", "bodyText": "Well, logging stuff of interest only to the developer is part of what the debug context code is meant to do. That's why it supports a hierarchical naming scheme for identifying the context. If I want to enable debug during content creation I pass\n-H:Log=DebugCodeInfo:3 -Dgraal.LogFile=$PWD/out.log\n\nLevel 3 enables verbose logging. Keyword DebugCodeInfo matches every log context created under the call to installDebugInfo. If I only wanted log output for processing a specific method I could append the specific method name to the installDebugInfo keyword (with '.' separator).", "author": "adinn", "createdAt": "2020-06-15T13:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2Nzg4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r444167887", "bodyText": "I've simplified the log enablement code to be entirely controlled by the debugContext, and if finer-grained control over loggin ends up being required, will ensure it only uses that mechanism, not compile-time contants.", "author": "stooke", "createdAt": "2020-06-23T11:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NDU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432586551", "bodyText": "Is there really a need for this? If not delete it. If so the maybe mark it as unused because the commented out code won't pass the style formatter without getting munged into a syntactic mess.", "author": "adinn", "createdAt": "2020-05-29T16:05:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,648 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);\n+        }\n+    }\n+\n+    /*-", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3NjUyOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433276528", "bodyText": "These commented out sections implement records that will probably be used once type information is added.  I can mark them unused if that's preferable.\nTIP: Prefixing the command block with \"/*-\" (as seen here) avoids the munging.\nhttps://www.oracle.com/java/technologies/javase/codeconventions-comments.html#680", "author": "stooke", "createdAt": "2020-06-01T14:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxNTMxNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r433315315", "bodyText": "Oh, that tip is good to know. Thanks!\nI think it would be better to leave this marked unused with a comment to explain why it will eventually be needed.", "author": "adinn", "createdAt": "2020-06-01T15:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDE4MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r438980181", "bodyText": "I've added a comment.", "author": "stooke", "createdAt": "2020-06-11T18:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4NjU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU5MjYyMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r432592621", "bodyText": "This change is fine but it is going to change the way both VS and ELF debug info is generated. In the latter case that will cause the mx command mx testdebuginfo and the gate test which drives it to fail. Fixing this requires changing the test script mx.substartevm/testhello.py that drives a gdb session to also expect this separator. Occurrences of :: in both the input commands and the regular expressions used to match debugger output must be modified to a '.' character. n.b. That requires escaping the '.' in the regular expressions and attention needs to be paid to the type of string (raw or normall) in order to get the right number of backslashes (yeah using '.' is a pain in this regard even though it is better from a Java user point of view). I'll do this offline and forward you the edited version to try once you have reworked the code to address the latest round of review feedback.", "author": "adinn", "createdAt": "2020-05-29T16:16:08Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -36,6 +36,9 @@\n  */\n \n public class Range {\n+\n+    private static final char CLASS_DELIMITER = '.';", "originalCommit": "f3fb7861b5c0ca257b5893a8ec59164e78acaf9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE3NTU3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457175573", "bodyText": "@stooke please fix all your comments.\n\nUse of // is discouraged.\nComments almost always start with an uppercase letter in our codebase\nMerge consecutive comment blocks (like this one) (no */ immediately followed by /*)\nIf you want to prevent eclipseformat  to mess with your comment formatting start your comments with /*-.\n\nPlease clean up your commit log.\n\nSquash commits together were possible (use git rebase --interactive origin/master)\nCommit messages should start with an uppercase letter and should not contain spelling errors.", "author": "olpaw", "createdAt": "2020-07-20T08:32:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzODM3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456638373", "bodyText": "These don't seem to be used anywhere but in the myValues array below.", "author": "pejovica", "createdAt": "2020-07-17T19:38:50Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/SectionName.java", "diffHunk": "@@ -94,11 +94,14 @@ public String getFormatDependentName(Format f) {\n     public static final SectionName APPLE_NAMESPACE = new ProgbitsSectionName(\"apple_namespac\");\n     public static final SectionName APPLE_OBJC = new ProgbitsSectionName(\"apple_objc\");\n     public static final SectionName LLVM_STACKMAPS = new ProgbitsSectionName(\"llvm_stackmaps\");\n+    // Windows PECOFF CodeView 4 debug sections\n+    public static final SectionName CV4_DEBUG_SYMBOLS = new ProgbitsSectionName(\"debug$S\");\n+    public static final SectionName CV4_DEBUG_TYPES = new ProgbitsSectionName(\"debug$T\");", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5MzY2Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457693663", "bodyText": "These constants are removed.  (The Apple constants have the same issue so I thought this was appropriate).\nIf PECOFF on arm64 is ever implemented, they'll go back and be used elsewhere.\nIf you have specific TODOs you'd like to see implemented before this is pushed, please let me know.  A number need to wait until I implement type records.", "author": "stooke", "createdAt": "2020-07-20T21:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzODM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0NDY2Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456644666", "bodyText": "Unused method.", "author": "pejovica", "createdAt": "2020-07-17T19:52:53Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -93,6 +94,16 @@ private Range(String fileName, Path filePath, Path cachePath, String className,\n         this.primary = primary;\n     }\n \n+    /*\n+     * Create a copy of a Range with a different lo/hi code range.\n+     */\n+    public static Range withLoHi(Range other, int lo, int hi) throws CloneNotSupportedException {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5NzExMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456697113", "bodyText": "Any reason to keep the machine field?", "author": "pejovica", "createdAt": "2020-07-17T22:18:02Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugInfo.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.DebugInfoBase;\n+import com.oracle.objectfile.pecoff.PECoffMachine;\n+\n+import java.nio.ByteOrder;\n+\n+/**\n+ * CVDebugInfo is a container class for all the CodeView sections to be emitted in the object file.\n+ * Currently, that is .debug$S (CVSymbolSectionImpl) and .debug$T (CVTypeSectionImpl) Common data\n+ * (useful to more than one CodeView section) goes here\n+ */\n+public final class CVDebugInfo extends DebugInfoBase {\n+\n+    @SuppressWarnings(\"unused\") private PECoffMachine machine;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5Mzk5Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457693997", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5NzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMjAwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456702004", "bodyText": "This could be simplified to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n          \n          \n            \n                        TrackNodeSourcePosition.update(values, true);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && !Boolean.FALSE.equals(values.get(DeleteLocalSymbols))) {\n          \n          \n            \n                        DeleteLocalSymbols.update(values, false);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && !TrackNodeSourcePosition.getValueOrDefault(values)) {\n          \n          \n            \n                        TrackNodeSourcePosition.update(values, true);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && DeleteLocalSymbols.getValueOrDefault(values)) {\n          \n          \n            \n                        DeleteLocalSymbols.update(values, false);\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nor maybe even just to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n          \n          \n            \n                        TrackNodeSourcePosition.update(values, true);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (newValue > 0 && !Boolean.FALSE.equals(values.get(DeleteLocalSymbols))) {\n          \n          \n            \n                        DeleteLocalSymbols.update(values, false);\n          \n          \n            \n                    }\n          \n          \n            \n                    TrackNodeSourcePosition.update(values, newValue > 0);\n          \n          \n            \n                    DeleteLocalSymbols.update(values, newValue == 0);", "author": "pejovica", "createdAt": "2020-07-17T22:36:45Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java", "diffHunk": "@@ -492,6 +492,9 @@ private static void defaultDebugInfoValueUpdateHandler(EconomicMap<OptionKey<?>,\n         if (newValue > 0 && !Boolean.TRUE.equals(values.get(TrackNodeSourcePosition))) {\n             TrackNodeSourcePosition.update(values, true);\n         }\n+        if (newValue > 0 && !Boolean.FALSE.equals(values.get(DeleteLocalSymbols))) {\n+            DeleteLocalSymbols.update(values, false);\n+        }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDI1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694257", "bodyText": "I went for the second choice.", "author": "stooke", "createdAt": "2020-07-20T21:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMjcxMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456712710", "bodyText": "You could introduce a constant, e.g. HEADER_SIZE = Integer.BYTES * 2.", "author": "pejovica", "createdAt": "2020-07-17T23:23:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+/*\n+ * A Symbol record is a top-level record in the CodeView .debug$S section\n+ */\n+abstract class CVSymbolRecord {\n+\n+    protected CVDebugInfo cvDebugInfo;\n+    protected int recordStartPosition;\n+    protected final int type;\n+\n+    CVSymbolRecord(CVDebugInfo cvDebugInfo, int type) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.type = type;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.recordStartPosition = initialPos;\n+        int pos = initialPos + Integer.BYTES * 2;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDM3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694370", "bodyText": "True.  I've added constants (with explanations) for a few of the more complex headers, but not all.", "author": "stooke", "createdAt": "2020-07-20T21:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMjcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMzQwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456713401", "bodyText": "With HEADER_SIZE, this could then become\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pos = computeContents(buffer, pos + Integer.BYTES);\n          \n          \n            \n                    /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n          \n          \n            \n                    CVUtil.putInt(pos - lenPos - Integer.BYTES, buffer, lenPos);\n          \n          \n            \n                    pos = computeContents(buffer, initialPos + HEADER_SIZE);\n          \n          \n            \n                    /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n          \n          \n            \n                    CVUtil.putInt(pos - HEADER_SIZE, buffer, lenPos);", "author": "pejovica", "createdAt": "2020-07-17T23:26:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecord.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+/*\n+ * A Symbol record is a top-level record in the CodeView .debug$S section\n+ */\n+abstract class CVSymbolRecord {\n+\n+    protected CVDebugInfo cvDebugInfo;\n+    protected int recordStartPosition;\n+    protected final int type;\n+\n+    CVSymbolRecord(CVDebugInfo cvDebugInfo, int type) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.type = type;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.recordStartPosition = initialPos;\n+        int pos = initialPos + Integer.BYTES * 2;\n+        return computeSize(pos);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = CVUtil.putInt(type, buffer, initialPos);\n+        int lenPos = pos;\n+        pos = computeContents(buffer, pos + Integer.BYTES);\n+        /* length does not include debug record header (4 bytes record id + 4 bytes length) */\n+        CVUtil.putInt(pos - lenPos - Integer.BYTES, buffer, lenPos);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyNzcyNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458827724", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T14:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcxMzQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjEwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456726104", "bodyText": "Unused method.", "author": "pejovica", "createdAt": "2020-07-18T00:38:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+final class CVStringTableRecord extends CVSymbolRecord {\n+\n+    private final CVSymbolSectionImpl.CVStringTable stringTable;\n+\n+    CVStringTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable stringTable) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_STRINGTABLE);\n+        this.stringTable = stringTable;\n+    }\n+\n+    int add(String string) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDQ4OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694489", "bodyText": "Gone", "author": "stooke", "createdAt": "2020-07-20T21:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcyNjEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MTEzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456781134", "bodyText": "When called to compute the size, won't it compute the same value that is already in the CVStringTable.currentOffset field?", "author": "pejovica", "createdAt": "2020-07-18T11:37:25Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVStringTableRecord.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+final class CVStringTableRecord extends CVSymbolRecord {\n+\n+    private final CVSymbolSectionImpl.CVStringTable stringTable;\n+\n+    CVStringTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable stringTable) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_STRINGTABLE);\n+        this.stringTable = stringTable;\n+    }\n+\n+    int add(String string) {\n+        return stringTable.add(string);\n+    }\n+\n+    @Override\n+    public int computeSize(int pos) {\n+        return computeContents(null, pos);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (CVSymbolSectionImpl.CVStringTable.StringTableEntry entry : stringTable.values()) {\n+            pos = CVUtil.putUTF8StringBytes(entry.text, buffer, pos);\n+        }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDU0MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694540", "bodyText": "Only if I coded it correctly!  But thanks - much more efficient.", "author": "stooke", "createdAt": "2020-07-20T21:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5MjMwOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456792308", "bodyText": "This is very similar to CVSymbolRecord, basically the only difference is the \"record header\". Perhaps a common superclass might be appropriate.", "author": "pejovica", "createdAt": "2020-07-18T13:53:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDYzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694634", "bodyText": "It might make the code slightly smaller but would break the abstraction. A SymbolRecord can contain many SymbolSubRecords, and they can have differing alignment, etc restrictions.", "author": "stooke", "createdAt": "2020-07-20T21:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5MjMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5OTA5MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456799090", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int pos = initialPos + Integer.BYTES; /* signature = 0; */\n          \n          \n            \n                        pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n          \n          \n            \n                        return pos;\n          \n          \n            \n                        return computeContents(null, initialPos);", "author": "pejovica", "createdAt": "2020-07-18T15:13:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDc2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694765", "bodyText": "Sold.", "author": "stooke", "createdAt": "2020-07-20T21:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5OTA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwOTcyMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456809723", "bodyText": "I think this should be passed in to CVDebugInfo via DebugInfoProvider.", "author": "pejovica", "createdAt": "2020-07-18T17:18:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDgwNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694806", "bodyText": "DebugInfoProvider is due for a rework when the PRs for Dwarf and PE/Coff typeinfo are submitted.  I'd prefer to leave this for now.  There is other information I can expose in CodeView format; but it's not clear how much is useful.", "author": "stooke", "createdAt": "2020-07-20T21:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwOTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMDEyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456810122", "bodyText": "A leftover?", "author": "pejovica", "createdAt": "2020-07-18T17:23:21Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDg5NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694894", "bodyText": "This is one of those awkward constants I wanted to capture for future use.  You'd think \"no debug info\" would be 0 and \"has debug info\" would be, say, 1.  I've uncommented it and suppressed the \"unused\" warning.", "author": "stooke", "createdAt": "2020-07-20T21:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMDEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTAyNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456811027", "bodyText": "So what is the purpose of this?", "author": "pejovica", "createdAt": "2020-07-18T17:34:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NDk0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457694941", "bodyText": "It's gone.   I have no idea what I was thinking at the time.", "author": "stooke", "createdAt": "2020-07-20T21:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTA3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456811079", "bodyText": "Unused code.", "author": "pejovica", "createdAt": "2020-07-18T17:34:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);\n+        }\n+    }\n+\n+    /*-\n+    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTAyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695025", "bodyText": "Moved in with the unused future code at the bottom.", "author": "stooke", "createdAt": "2020-07-20T21:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTI5MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456811290", "bodyText": "Lots of unused code. \ud83d\ude09", "author": "pejovica", "createdAt": "2020-07-18T17:36:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            cvDebugInfo.getCVSymbolSection().debugAddress = offset;\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);\n+        }\n+    }\n+\n+    /*-\n+    public static final class CVSymbolGProc32IDRecord extends CVSymbolGProc32Record {\n+\n+        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        /* this is almost certainly bad (not enough information); use only for debugging *\n+        CVSymbolGProc32IDRecord(CVDebugInfo cvDebugInfo, String name, int offset, int proclen) {\n+            super(cvDebugInfo, CVDebugConstants.S_GPROC32_ID, name, 0, 0, 0, proclen, 0, 0, 0, offset, (short)0, (byte)0);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_GPROC32_ID(name=%s parent=%d startaddr=0x%x end=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset, typeIndex, flags);\n+        }\n+    }\n+    */\n+\n+    public static final class CVSymbolFrameProcRecord extends CVSymbolSubrecord {\n+\n+        int framelen;\n+        int padLen;\n+        int padOffset;\n+        int saveRegsCount;\n+        int ehOffset;\n+        short ehSection;\n+        int flags;\n+\n+        CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int padLen, int padOffset, int saveRegsCount, int ehOffset, short ehSection, int flags) {\n+            super(cvDebugInfo, CVDebugConstants.S_FRAMEPROC);\n+            this.framelen = framelen;\n+            this.padLen = padLen;\n+            this.padOffset = padOffset;\n+            this.saveRegsCount = saveRegsCount;\n+            this.ehOffset = ehOffset;\n+            this.ehSection = ehSection;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolFrameProcRecord(CVDebugInfo cvDebugInfo, int framelen, int flags) {\n+            this(cvDebugInfo, framelen, 0, 0, 0, 0, (short) 0, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(framelen, buffer, initialPos);\n+            pos = CVUtil.putInt(padLen, buffer, pos);\n+            pos = CVUtil.putInt(padOffset, buffer, pos);\n+            pos = CVUtil.putInt(saveRegsCount, buffer, pos);\n+            pos = CVUtil.putInt(ehOffset, buffer, pos);\n+            pos = CVUtil.putShort(ehSection, buffer, pos);\n+            pos = CVUtil.putInt(flags, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_FRAMEPROC len=0x%x padlen=0x%x paddOffset=0x%x regCount=%d flags=0x%x \", framelen, padLen, padOffset, saveRegsCount, flags);\n+        }\n+    }\n+\n+    public static class CVSymbolEndRecord extends CVSymbolSubrecord {\n+\n+        CVSymbolEndRecord(CVDebugInfo cvDebugInfo, short cmd) {\n+            super(cvDebugInfo, cmd);\n+        }\n+\n+        CVSymbolEndRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, CVDebugConstants.S_END);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            // nothing\n+            return initialPos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_END\";\n+        }\n+    }\n+\n+    /*-\n+\n+    NOTE: All these records are not currently required, but will be (or will be discarded) once type information\n+    has been added.\n+\n+    public static final class CVSymbolRegRel32Record extends CVSymbolSubrecord {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTEyOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695129", "bodyText": "These will be used in the upcoming debug typeinfo PR.", "author": "stooke", "createdAt": "2020-07-20T21:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3MjkwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458372901", "bodyText": "gone for now.", "author": "stooke", "createdAt": "2020-07-21T20:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjUwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456812509", "bodyText": "A debugging leftover?", "author": "pejovica", "createdAt": "2020-07-18T17:51:50Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTE3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695174", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjc5MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456812790", "bodyText": "Seems like a leftover.", "author": "pejovica", "createdAt": "2020-07-18T17:55:06Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTIyNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695226", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMjgyNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456812827", "bodyText": "This as well.", "author": "pejovica", "createdAt": "2020-07-18T17:55:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzE3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456813179", "bodyText": "Same here.", "author": "pejovica", "createdAt": "2020-07-18T17:59:52Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,652 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* room for length and subcommand */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* save room for length (no including length bytes) */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* TODO: how to find the full path to object file we will produce */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Get file from first class object */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            int pos = initialPos + Integer.BYTES; /* signature = 0; */\n+            pos += objName.getBytes(UTF_8).length + 1; /* inline null terminated */\n+            return pos;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* signature = 0 */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /* inline null terminated */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        // private static final byte HAS_NO_DEBUG_FLAG = (byte)0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* current directory */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /* compiler executable */\n+            // map.put(\"cl\", \"cl.exe\");\n+\n+            /* argument list */\n+            // map.put(\"cmd\", \"-Zi -MT -wishfulthinking\");\n+\n+            /*\n+             * find first source file - which, for Graal would be a class file on the command line\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+\n+            /* Graal doesn't yet create PDB files; all type info is stored in object file */\n+            // map.put(\"pdb\", System.getProperty(\"user.dir\") + File.separator + \"vc100.pdb\");\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* flags */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* key/value pairs */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* end marker */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * creating a proc32 record has side effects. - a global symbol is added to the COFF symbol\n+     * section - two relocation entries are added to the section relocation table, they refer to the\n+     * global symbol\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECREL reloc at pos=0x%x for func=%s\n+                // addr=0x%x\\n\", pos, name, offset);\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                // CVUtil.debug(\"CVSymbolGProc32Record() adding SECTION reloc at pos=0x%x for\n+                // func=%s addr=0x%x\\n\", pos, name, offset);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTI3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695272", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxMzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTI4Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456815286", "bodyText": "Seems like a debugging leftover.", "author": "pejovica", "createdAt": "2020-07-18T18:25:40Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {\n+\n+    /* base level put methods that assume a non-null buffer */\n+    static int putByte(byte b, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Byte.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = b;\n+        return pos;\n+    }\n+\n+    static int putShort(short s, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Short.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (s & 0xff);\n+        buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putInt(int i, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Integer.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (i & 0xff);\n+        buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putLong(long l, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Long.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (l & 0xff);\n+        buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putBytes(byte[] inbuff, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + inbuff.length;\n+        }\n+        int pos = initialPos;\n+        for (byte b : inbuff) {\n+            buffer[pos++] = b;\n+        }\n+        return pos;\n+    }\n+\n+    static int putUTF8StringBytes(String s, byte[] buffer, int initialPos) {\n+        return putUTF8StringBytes(s, 0, buffer, initialPos);\n+    }\n+\n+    private static int putUTF8StringBytes(String s, int startChar, byte[] buffer, int initialPos) {\n+        byte[] buff = s.substring(startChar).getBytes(UTF_8);\n+        if (buffer == null) {\n+            return initialPos + buff.length + 1;\n+        }\n+        int pos = initialPos;\n+        for (byte b : buff) {\n+            if (b == 0) {\n+                throw new RuntimeException(\"oops : string has internal NULL character! \" + s);\n+            }\n+            buffer[pos++] = b;\n+        }\n+        buffer[pos++] = '\\0';\n+        return pos;\n+    }\n+\n+    static int getInt(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        int i = buffer[pos++] & 0xff;\n+        i += (buffer[pos++] & 0xff) << 8;\n+        i += (buffer[pos++] & 0xff) << 16;\n+        i += (buffer[pos] & 0xff) << 24;\n+        return i;\n+    }\n+\n+    static short getShort(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        short i = (short) (buffer[pos++] & 0xff);\n+        i = (short) (i + ((buffer[pos] & 0xff) << 8));\n+        return i;\n+    }\n+\n+    /*-\n+    static void dump(String msg, byte[] buffer, int initialPos, int len) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTMyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695325", "bodyText": "Debugging is never finished!  But, it's gone.", "author": "stooke", "createdAt": "2020-07-20T21:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTU2OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456815568", "bodyText": "Outdated comment.", "author": "pejovica", "createdAt": "2020-07-18T18:29:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {\n+\n+    /* base level put methods that assume a non-null buffer */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTM4Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695383", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-20T21:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgxNTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMDg1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456900858", "bodyText": "Why are some constants commented out?", "author": "pejovica", "createdAt": "2020-07-19T12:09:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVDebugConstants {\n+\n+    // static final int DEBUG_S_IGNORE = 0x00;\n+    static final int DEBUG_S_SYMBOLS = 0xf1;\n+    static final int DEBUG_S_LINES = 0xf2;\n+    static final int DEBUG_S_STRINGTABLE = 0xf3;\n+    static final int DEBUG_S_FILECHKSMS = 0xf4;\n+\n+    /* subcommands in DEBUG_S_SYMBOLS section */\n+    // static final short S_COMPILE = 0x0001;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTQ1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695458", "bodyText": "I could suppress unused warnings instead.  Some of these constants will be used for the typeInfo PR, some for future architectures or compilers.  I'd rather pare the list after typeInfo is implemented.", "author": "stooke", "createdAt": "2020-07-20T21:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMDg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3Mjc1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458372758", "bodyText": "gone, for now.", "author": "stooke", "createdAt": "2020-07-21T20:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMDg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMTA4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456901085", "bodyText": "I think we should keep either constants or enums, but not both.", "author": "pejovica", "createdAt": "2020-07-19T12:11:17Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVDebugConstants.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVDebugConstants {\n+\n+    // static final int DEBUG_S_IGNORE = 0x00;\n+    static final int DEBUG_S_SYMBOLS = 0xf1;\n+    static final int DEBUG_S_LINES = 0xf2;\n+    static final int DEBUG_S_STRINGTABLE = 0xf3;\n+    static final int DEBUG_S_FILECHKSMS = 0xf4;\n+\n+    /* subcommands in DEBUG_S_SYMBOLS section */\n+    // static final short S_COMPILE = 0x0001;\n+    static final short S_SSEARCH = 0x0005;\n+    static final short S_END = 0x0006;\n+    static final short S_OBJNAME = 0x1101;\n+    static final short S_LDATA32_ST = 0x1007;\n+    static final short S_FRAMEPROC = 0x1012;\n+    static final short S_CONSTANT = 0x1107;\n+    static final short S_UDT = 0x1108;\n+    static final short S_LDATA32 = 0x110c;\n+    static final short S_GDATA32 = 0x110d;\n+    static final short S_GPROC32 = 0x1110;\n+    static final short S_REGREL32 = 0x1111;\n+    static final short S_COMPILE3 = 0x113c;\n+    static final short S_ENVBLOCK = 0x113d;\n+    static final short S_GPROC32_ID = 0x1147;\n+    static final short S_PROC_ID_END = 0x114f;\n+    // static final short S_BUILDINFO = 0x114c;\n+\n+    /* enums are more typesafe but the IDE no longer knows which enum constant is unused */\n+    @SuppressWarnings(\"unused\")\n+    enum CV_RECORD {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTUyOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695528", "bodyText": "I'll get rid of the enums, because the IDE is less helpful with them.  Basically this was a rant that should have been deleted.", "author": "stooke", "createdAt": "2020-07-20T21:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjE0OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456902149", "bodyText": "I guess you don't need equivalents in SectionName then.", "author": "pejovica", "createdAt": "2020-07-19T12:21:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTU2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457695565", "bodyText": "Not at this time.  (So the SectionName constants have been deleted)", "author": "stooke", "createdAt": "2020-07-20T21:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjg5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456902896", "bodyText": "I would remove these. You can use SectionName.TEXT for the text section, and the rest can be added as needed.", "author": "pejovica", "createdAt": "2020-07-19T12:28:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+public abstract class CVConstants {\n+\n+    /* names of relevant CodeView sections */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n+    static final String TEXT_SECTION_NAME = \".text\";\n+    // static final String CV_RDATA_SECTION_NAME = \".rdata\";\n+    // static final String CV_PDATA_SECTION_NAME = \".pdata\";\n+    // static final String CV_XDATA_SECTION_NAME = \".xdata\";\n+    // static final String DATA_SECTION_NAME = \".data\";", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3Njk1Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458376956", "bodyText": "done.", "author": "stooke", "createdAt": "2020-07-21T20:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwMjg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwNTUyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456905525", "bodyText": "Adding subrecords while computing the size seems a bit out of place.", "author": "pejovica", "createdAt": "2020-07-19T12:54:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A CVSymbolSubsection is s special record in debug$S containing nested symbol records\n+ * (the nested records inherit from CVSymbolSubrecord)\n+ */\n+class CVSymbolSubsection extends CVSymbolRecord {\n+\n+    private static final int SUBCMD_INITIAL_CAPACITY = 100;\n+\n+    private ArrayList<CVSymbolSubrecord> subcmds = new ArrayList<>(SUBCMD_INITIAL_CAPACITY);\n+\n+    CVSymbolSubsection(CVDebugInfo cvDebugInfo) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_SYMBOLS);\n+    }\n+\n+    void addRecord(CVSymbolSubrecord subcmd) {\n+        subcmds.add(subcmd);\n+    }\n+\n+    void addSubrecords() {\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        int pos = initialPos;\n+        addSubrecords();", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgzMzM1OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458833358", "bodyText": "Gone.  Probably you would not have noticed if I called the functions pass1() and pass2().", "author": "stooke", "createdAt": "2020-07-22T14:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkwNTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkxNDIyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456914225", "bodyText": "Unused method (a debugging leftover?).", "author": "pejovica", "createdAt": "2020-07-19T14:16:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = strings.add(fn);\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* stringtable index */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is) */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* checksum type (0x01 == MD5) */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);\n+        return pos;\n+    }\n+\n+    private static byte[] calculateMD5Sum(String fn) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+            md.update(Files.readAllBytes(Paths.get(fn)));\n+            return md.digest();\n+        } catch (NoSuchFileException e) {\n+            return null;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CVFileRecord(type=\" + type + \",pos=\" + recordStartPosition + \", size=\" + fileEntryToOffsetMap.size() + \")\";\n+    }\n+\n+    public void dump(PrintStream out) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3NzUwNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458377505", "bodyText": "There should be a place for these to live.  Gone.", "author": "stooke", "createdAt": "2020-07-21T20:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkxNDIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNTAzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456925038", "bodyText": "Why print a stack trace if you continue with normal execution?", "author": "pejovica", "createdAt": "2020-07-19T15:58:02Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = strings.add(fn);\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* stringtable index */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is) */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* checksum type (0x01 == MD5) */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);\n+        return pos;\n+    }\n+\n+    private static byte[] calculateMD5Sum(String fn) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+            md.update(Files.readAllBytes(Paths.get(fn)));\n+            return md.digest();\n+        } catch (NoSuchFileException e) {\n+            return null;\n+        } catch (Exception e) {\n+            e.printStackTrace();", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5NjA1Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458396053", "bodyText": "Because I didn't know about throw GraalError.shouldNotReachHere().  Fixed.", "author": "stooke", "createdAt": "2020-07-21T21:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNTAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNjI0OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456926249", "bodyText": "Can this be removed as the comments suggest, or is it still necessary?", "author": "pejovica", "createdAt": "2020-07-19T16:10:10Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg1MDkyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458850925", "bodyText": "Still necessary.  Comments have been cleaned up.", "author": "stooke", "createdAt": "2020-07-22T14:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyNjI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyODYzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456928632", "bodyText": "I would add an assertion that we indeed used exactly FILE_RECORD_LENGTH bytes (because that is assumed when computing the size).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pos = CVUtil.align4(pos);\n          \n          \n            \n                    pos = CVUtil.align4(pos);\n          \n          \n            \n                    assert pos == initialPos + FILE_RECORD_LENGTH;", "author": "pejovica", "createdAt": "2020-07-19T16:33:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileRecord.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* create required stringtable entry */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /* add all fileEntries; duplicates are ignored */\n+        /*\n+         * probably don't need to do this because if it isn't already here it's probably referenced\n+         * by the debug info\n+         */\n+        /* consider moving this to CVSymbolSectionImpl */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = strings.add(fn);\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* stringtable index */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is) */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* checksum type (0x01 == MD5) */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg3Mjg3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458872870", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T15:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkyODYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NzEzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456957132", "bodyText": "These fields don\u2019t seem to have any practical use at the moment so I think they should be removed.", "author": "pejovica", "createdAt": "2020-07-19T21:21:19Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5MjQ2MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458392461", "bodyText": "not any more.  Gone.", "author": "stooke", "createdAt": "2020-07-21T21:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1NzEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODA1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456958050", "bodyText": "Should this comment be updated? It does not match the return value.", "author": "pejovica", "createdAt": "2020-07-19T21:31:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* define the section as a COFF symbol */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n+         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n+         * Other info formats use their own format-specific prefix.\n+         */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5MzgzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458393837", "bodyText": "Updated.", "author": "stooke", "createdAt": "2020-07-21T21:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODY0Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456958642", "bodyText": "This looks like a leftover, as well as the unused targetSection above and the commented out targetSectionKinds below.", "author": "pejovica", "createdAt": "2020-07-19T21:39:01Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+    long debugTextBase = 0;\n+    long debugAddress = 0;\n+    int debugBase = 0;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* define the section as a COFF symbol */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Use prefix cv4 plus the section name (which already includes a dot separator) for the\n+         * context key. For example messages for type section will be keyed using \"cv4.debug$T\".\n+         * Other info formats use their own format-specific prefix.\n+         */\n+        assert getSectionName().startsWith(CVConstants.CV_SECTION_NAME_PREFIX);\n+        return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n+    }\n+\n+    protected void enableLog(DebugContext context, int pos) {\n+        /*\n+         * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n+         * writing phases. (Currently turned off in the sizing state) At this time, debugBase and\n+         * debugAddress aren't used but are there for the future.\n+         */\n+        if (context.areScopesEnabled()) {\n+            debug = true;\n+            debugBase = pos;\n+            debugAddress = debugTextBase;\n+        }\n+    }\n+\n+    @Override\n+    public int getAlignment() {\n+        return 1;\n+    }\n+\n+    protected void log(DebugContext context, String format, Object... args) {\n+        if (debug) {\n+            context.logv(DebugContext.INFO_LEVEL, format, args);\n+        }\n+    }\n+\n+    protected void verboseLog(DebugContext context, String format, Object... args) {\n+        if (debug) {\n+            context.logv(DebugContext.VERBOSE_LEVEL, format, args);\n+        }\n+    }\n+\n+    @Override\n+    public byte[] getOrDecideContent(Map<ObjectFile.Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+\n+        /* ensure content byte[] has been created before calling super method */\n+        getOwner().debugContext(debugSectionLogName(), this::createContent);\n+\n+        /* ensure content byte[] has been written before calling super method */\n+        getOwner().debugContext(debugSectionLogName(), this::writeContent);\n+\n+        return super.getOrDecideContent(alreadyDecided, contentHint);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        String targetName = getSectionName();\n+        @SuppressWarnings(\"unused\")\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(targetName);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        // LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+        /* make our content depend on the size and content of the target */\n+        // for (LayoutDecision.Kind targetKind : targetKinds) {\n+        // LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+        // deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+        // }", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5ODI2Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458398263", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-21T21:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk1ODY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MzQ1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456963450", "bodyText": "Why not initialize the fileRecord field in the constructor?", "author": "pejovica", "createdAt": "2020-07-19T22:31:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addTypeRecords() {\n+        /* not yet implemented. S_UDT, etc */\n+        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n+        // addRecord(externs);\n+    }\n+\n+    private void addFileRecords() {\n+        addRecord(getFileRecord());\n+    }\n+\n+    CVFileRecord getFileRecord() {\n+        if (fileRecord == null) {\n+            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4ODk0Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458388942", "bodyText": "I have made this a local variable.", "author": "stooke", "createdAt": "2020-07-21T21:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2NDY2Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456964663", "bodyText": "Maybe something like com.oracle.svm.core.util.Utf8.utf8Length.", "author": "pejovica", "createdAt": "2020-07-19T22:44:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addTypeRecords() {\n+        /* not yet implemented. S_UDT, etc */\n+        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n+        // addRecord(externs);\n+    }\n+\n+    private void addFileRecords() {\n+        addRecord(getFileRecord());\n+    }\n+\n+    CVFileRecord getFileRecord() {\n+        if (fileRecord == null) {\n+            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);\n+        }\n+        return fileRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    /* TODO: use ...objectfile.debugentry.StringTable instead */\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* using LinkedHashMap so order is maintained when writing string table */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* ensure that the empty string has index 0 */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                /*\n+                 * TODO: getting the enecoded size should be made more efficient", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4NTIyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458385222", "bodyText": "done.", "author": "stooke", "createdAt": "2020-07-21T21:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2NDY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2OTkwNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456969906", "bodyText": "Any chance to switch to StringTable on this PR?", "author": "pejovica", "createdAt": "2020-07-19T23:36:43Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        new CVSymbolRecordBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addTypeRecords() {\n+        /* not yet implemented. S_UDT, etc */\n+        // CVSymbolRecord externs = new CVSymbolSubsection.CVExternalSymbolRecord(cvDebugInfo);\n+        // addRecord(externs);\n+    }\n+\n+    private void addFileRecords() {\n+        addRecord(getFileRecord());\n+    }\n+\n+    CVFileRecord getFileRecord() {\n+        if (fileRecord == null) {\n+            this.fileRecord = new CVFileRecord(cvDebugInfo, stringTable);\n+        }\n+        return fileRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    /* TODO: use ...objectfile.debugentry.StringTable instead */", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4NjM3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458386373", "bodyText": "No, the semantics are not the same, especially the way offsets are calculated.  Comment removed.", "author": "stooke", "createdAt": "2020-07-21T21:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2OTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3MTE1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r456971152", "bodyText": "Perhaps a better option would be to pass the subrecords using a constructor or simply add them here using prologue.addRecord.", "author": "pejovica", "createdAt": "2020-07-19T23:48:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private CVFileRecord fileRecord;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * the CodeView symbol section (\"debug$S\") is actually a list of records containing sub-records\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* add header size */\n+        pos += Integer.BYTES;\n+        /* add sum of all record sizes */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* create a buffer that holds it all */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* write section header */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* write all records */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecords();\n+        addFunctionRecords(debugContext);\n+        addTypeRecords();\n+        addFileRecords();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecords() {\n+        CVSymbolRecord prologue = new CVSymbolSubsection(cvDebugInfo) {\n+            @Override\n+            void addSubrecords() {\n+                CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+                if (objectNameRecord.isValid()) {\n+                    addRecord(objectNameRecord);\n+                }\n+                addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+                addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+            }\n+        };", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4NjA5OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458786098", "bodyText": "Better in what sense? I have changed this to use addRecord().", "author": "stooke", "createdAt": "2020-07-22T13:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3MTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMTMwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457131309", "bodyText": "I think this should be renamed to something that better reflects the actual behaviour. Maybe CVSymbolSubsectionBuilder?", "author": "pejovica", "createdAt": "2020-07-20T07:30:49Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgzNjQwMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458836402", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T14:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMTMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMzc4OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457133788", "bodyText": "What's the purpose of this check?", "author": "pejovica", "createdAt": "2020-07-20T07:34:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* look over all classes defined in this module */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* loop over all functions defined in this class */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                /* eliminate ranges with no associated files */\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQzMjEyMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459432120", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-23T13:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzEzMzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0MjA0Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457142042", "bodyText": "I don't quite understand the purpose of this. Why do you handle the main method in such a way?", "author": "pejovica", "createdAt": "2020-07-20T07:46:55Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* look over all classes defined in this module */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* loop over all functions defined in this class */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                /* eliminate ranges with no associated files */\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {\n+                    previousMethodName = newMethodName;\n+                    build(primaryEntry, newMethodName);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required)\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions */\n+        int asynceh = 1 << 9; /* aync eh (msc uses 1, clang uses 0) */\n+        int localBP = 1 << 14; /* local base pointer = SP (0=none, 1=sp, 2=bp 3=r13) */\n+        int paramBP = 1 << 16; /* param base pointer = SP */\n+        int frameFlags = asynceh + localBP + paramBP; /* LLVM uses 0x14000; */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types */\n+        /* TODO: add block definitions */\n+\n+        /* S_END add end record */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * renames a method name ot something user friendly in the debugger. (does not affect external\n+     * symbols used by linker)\n+     *\n+     * first encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null) if functionNamesHashArgs is true (which it must be for the linker to work properly)\n+     * all other functions become class.function.999 (where 999 is a hash of the arglist)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...) */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NjA3Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457696077", "bodyText": "An attempt at usability.  Visual Studio doesn't come up with the main Java class when you start it up with a Graal executable, so the user currently has to set a function breakpoint, and I wanted to make that predictable (i.e. \"stop in Myclass.main\").\nIn earlier discussions, it was agreed to revisit function names in general in a later PR.", "author": "stooke", "createdAt": "2020-07-20T21:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0MjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0NTExNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457145114", "bodyText": "Why have the functionNamesHashArgs flag if there is no alternative?", "author": "pejovica", "createdAt": "2020-07-20T07:51:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolRecordBuilder.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.functionNamesHashArgs;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolRecordBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolRecordBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * build DEBUG_S_SYMBOLS record from all classEntries. (could probably build one per class or\n+     * one per function)\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* look over all classes defined in this module */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables)\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* loop over all functions defined in this class */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            if (primaryRange.getFileName() != null) {\n+                /* eliminate ranges with no associated files */\n+                String newMethodName = fixMethodName(primaryRange);\n+                if (!newMethodName.equals(previousMethodName)) {\n+                    previousMethodName = newMethodName;\n+                    build(primaryEntry, newMethodName);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required)\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions */\n+        int asynceh = 1 << 9; /* aync eh (msc uses 1, clang uses 0) */\n+        int localBP = 1 << 14; /* local base pointer = SP (0=none, 1=sp, 2=bp 3=r13) */\n+        int paramBP = 1 << 16; /* param base pointer = SP */\n+        int frameFlags = asynceh + localBP + paramBP; /* LLVM uses 0x14000; */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types */\n+        /* TODO: add block definitions */\n+\n+        /* S_END add end record */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * renames a method name ot something user friendly in the debugger. (does not affect external\n+     * symbols used by linker)\n+     *\n+     * first encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null) if functionNamesHashArgs is true (which it must be for the linker to work properly)\n+     * all other functions become class.function.999 (where 999 is a hash of the arglist)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...) */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else if (functionNamesHashArgs) {\n+            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n+            methodName = range.getClassAndMethodName() + \".\" + hash;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NjEzNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457696136", "bodyText": "I have removed the constant and conditional, and updated the comments.", "author": "stooke", "createdAt": "2020-07-20T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0NTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUwNzQyNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457507425", "bodyText": "I am aware that support for type records is underway, but there is a lot of unused code here. Basically, everything except CVTypeArglistRecord and CVTypeProcedureRecord is not currently used.", "author": "pejovica", "createdAt": "2020-07-20T15:43:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,700 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BINTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BITFIELD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MODIFIER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRUCTURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_TYPESERVER2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UQUAD;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3MjA0Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458372047", "bodyText": "gone.", "author": "stooke", "createdAt": "2020-07-21T20:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUwNzQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457512070", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return initialPos + Integer.BYTES + Byte.BYTES + Byte.BYTES + Short.BYTES + Integer.BYTES;\n          \n          \n            \n                        return computeContents(null, initialPos);", "author": "pejovica", "createdAt": "2020-07-20T15:49:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,700 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BINTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BITFIELD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MODIFIER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRUCTURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_TYPESERVER2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UQUAD;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* save room for length and leaf type */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int lenPos = initialPos; /* save position of length short */\n+        int pos = initialPos + Short.BYTES; /* save room for length short */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* length does not include record length (2 bytes)) but does include end padding */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - lenPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, lenPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeModifierRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        boolean addConst = false;\n+        boolean addVolatile = false;\n+        boolean addUnaligned = false;\n+\n+        CVTypeModifierRecord(int originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypeModifierRecord(CVTypeRecord originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        CVTypeModifierRecord addConst() {\n+            this.addConst = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addVolatile() {\n+            this.addVolatile = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addUnaligned() {\n+            this.addUnaligned = true;\n+            return this;\n+        }\n+\n+        private short computeFlags() {\n+            return (short) ((addConst ? 0x01 : 0x00) | (addVolatile ? 0x02 : 0x00) | (addUnaligned ? 0x04 : 0));\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Short.BYTES;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putShort(computeFlags(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = String.format(\"LF_MODIFIER 0x%04x\", getSequenceNumber());\n+            if (addConst) {\n+                s += \" const\";\n+            }\n+            if (addVolatile) {\n+                s += \" volatile\";\n+            }\n+            if (addUnaligned) {\n+                s += \"unaligned\";\n+            }\n+            s += String.format(\" 0x%04x\", originalLeaf);\n+            return s;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeFlags();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypePointerRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        int kind = 0;\n+        int mode = 0;\n+        int modifiers = 0;\n+        int size = 4;\n+        int flags = 0;\n+\n+        /*-\n+        int kind      =  attributes & 0x00001f;\n+        int mode      = (attributes & 0x0000e0) >> 5;\n+        int modifiers = (attributes & 0x001f00) >> 8;\n+        int size      = (attributes & 0x07e000) >> 13;\n+        int flags     = (attributes & 0x380000) >> 19;\n+        out.printf(\"LF_POINTER len=%d leaf=0x%04x refType=0x%06x attrib=0x%06x\\n\", len, leaf, referentType, attributes);\n+        out.printf(\"           kind=%d mode=%d modifiers=%d size=%d flags=%d\\n\", kind, mode, modifiers, size, flags);\n+        */\n+\n+        CVTypePointerRecord(int originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypePointerRecord(CVTypeRecord originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        private int computeAttributes() {\n+            return kind | (mode << 5) | (modifiers << 8) | (size << 13) | (flags << 19);\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES * 2;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putInt(computeAttributes(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_POINTER 0x%04x * 0x%04x\", getSequenceNumber(), originalLeaf);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeAttributes();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Byte.BYTES + Byte.BYTES + Short.BYTES + Integer.BYTES;", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMDkxMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458810913", "bodyText": "This code no longer exists.", "author": "stooke", "createdAt": "2020-07-22T13:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4Njg1OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460186859", "bodyText": "No, it's still here. \ud83d\ude09", "author": "pejovica", "createdAt": "2020-07-24T17:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NDExMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460244111", "bodyText": "So it is.  But it's so much more efficient (and prone to coding errors)!  Changed..", "author": "stooke", "createdAt": "2020-07-24T19:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjU4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457512585", "bodyText": "A leftover?", "author": "pejovica", "createdAt": "2020-07-20T15:49:42Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,700 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARRAY;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BCLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BINTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_BITFIELD;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_CLASS;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_INTERFACE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MEMBER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_MODIFIER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_POINTER;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_STRUCTURE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_TYPESERVER2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_UQUAD;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* save room for length and leaf type */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int lenPos = initialPos; /* save position of length short */\n+        int pos = initialPos + Short.BYTES; /* save room for length short */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* length does not include record length (2 bytes)) but does include end padding */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - lenPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, lenPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeModifierRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        boolean addConst = false;\n+        boolean addVolatile = false;\n+        boolean addUnaligned = false;\n+\n+        CVTypeModifierRecord(int originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypeModifierRecord(CVTypeRecord originalLeaf) {\n+            super(LF_MODIFIER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        CVTypeModifierRecord addConst() {\n+            this.addConst = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addVolatile() {\n+            this.addVolatile = true;\n+            return this;\n+        }\n+\n+        CVTypeModifierRecord addUnaligned() {\n+            this.addUnaligned = true;\n+            return this;\n+        }\n+\n+        private short computeFlags() {\n+            return (short) ((addConst ? 0x01 : 0x00) | (addVolatile ? 0x02 : 0x00) | (addUnaligned ? 0x04 : 0));\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Short.BYTES;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putShort(computeFlags(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = String.format(\"LF_MODIFIER 0x%04x\", getSequenceNumber());\n+            if (addConst) {\n+                s += \" const\";\n+            }\n+            if (addVolatile) {\n+                s += \" volatile\";\n+            }\n+            if (addUnaligned) {\n+                s += \"unaligned\";\n+            }\n+            s += String.format(\" 0x%04x\", originalLeaf);\n+            return s;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeFlags();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypePointerRecord extends CVTypeRecord {\n+\n+        int originalLeaf = -1;\n+        int kind = 0;\n+        int mode = 0;\n+        int modifiers = 0;\n+        int size = 4;\n+        int flags = 0;\n+\n+        /*-\n+        int kind      =  attributes & 0x00001f;\n+        int mode      = (attributes & 0x0000e0) >> 5;\n+        int modifiers = (attributes & 0x001f00) >> 8;\n+        int size      = (attributes & 0x07e000) >> 13;\n+        int flags     = (attributes & 0x380000) >> 19;\n+        out.printf(\"LF_POINTER len=%d leaf=0x%04x refType=0x%06x attrib=0x%06x\\n\", len, leaf, referentType, attributes);\n+        out.printf(\"           kind=%d mode=%d modifiers=%d size=%d flags=%d\\n\", kind, mode, modifiers, size, flags);\n+        */\n+\n+        CVTypePointerRecord(int originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf;\n+        }\n+\n+        CVTypePointerRecord(CVTypeRecord originalLeaf) {\n+            super(LF_POINTER);\n+            this.originalLeaf = originalLeaf.getSequenceNumber();\n+        }\n+\n+        private int computeAttributes() {\n+            return kind | (mode << 5) | (modifiers << 8) | (size << 13) | (flags << 19);\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES * 2;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(originalLeaf, buffer, initialPos);\n+            pos = CVUtil.putInt(computeAttributes(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_POINTER 0x%04x * 0x%04x\", getSequenceNumber(), originalLeaf);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + originalLeaf;\n+            h = 31 * h + computeAttributes();\n+            return h;\n+        }\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Byte.BYTES + Byte.BYTES + Short.BYTES + Integer.BYTES;\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); // callType\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); // funcAttr\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            // h = 31 * h + // callType + funcAttr", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc4OTg1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458789851", "bodyText": "comment changed,  the line is commented out because funcAddr and callType are currently always zero.", "author": "stooke", "createdAt": "2020-07-22T13:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5ODY4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457598687", "bodyText": "There seems to be potential for some sharing with CVSymbolSectionImpl, e.g., createContent, writeContent, and even getDependencies are all very similar.", "author": "pejovica", "createdAt": "2020-07-20T18:10:00Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMTc3Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458811773", "bodyText": "Similar but not identical,  Structured almost identically.  I think actual code sharing would make the structure more confusing. I'm happy to revisit this after the type section is fully implemented.", "author": "stooke", "createdAt": "2020-07-22T13:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5ODY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwMDkxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457600919", "bodyText": "I don\u2019t think it makes sense to keep this method at the moment.", "author": "pejovica", "createdAt": "2020-07-20T18:13:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private CVTypeRecordBuilder builder = new CVTypeRecordBuilder(this);\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {\n+        return Collections.unmodifiableList(cvRecords);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T>\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        // verboseLog(debugContext, \"adding type record: %s hash=%d\\n\", newRecord,\n+        // newRecord.hashCode());\n+        T actual = builder.addOrReference(newRecord);\n+        return actual;\n+    }\n+\n+    /**\n+     * Add definitions for all classes.\n+     */\n+    private void addClassRecords() {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg0Nzk2Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458847966", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T14:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwMDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNDc2Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457604767", "bodyText": "A debugging leftover?", "author": "pejovica", "createdAt": "2020-07-20T18:21:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private CVTypeRecordBuilder builder = new CVTypeRecordBuilder(this);\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext, pos);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {\n+        return Collections.unmodifiableList(cvRecords);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T>\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        // verboseLog(debugContext, \"adding type record: %s hash=%d\\n\", newRecord,\n+        // newRecord.hashCode());", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxMjY4Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458812686", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T13:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNDc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzOTg5Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457639893", "bodyText": "This builder seems a bit redundant. Would it make sense to move the handling of sequenceCounter into CVTypeSectionImpl?", "author": "pejovica", "createdAt": "2020-07-20T19:25:24Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecordBuilder.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class CVTypeRecordBuilder {", "originalCommit": "49a24e95b0fd377213c813a00d8cc2947d8fda37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg2NzA4MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458867080", "bodyText": "I wanted to keep the knowledge of the typeid processing separate from the knowledge of the type section overall structure.  But I have combined the two again.", "author": "stooke", "createdAt": "2020-07-22T15:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYzOTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4MjExMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457982111", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        /* If HAS_COLUMNS is true, this formula is incorrect. */\n          \n          \n            \n                        assert !HAS_COLUMNS;\n          \n          \n            \n                        pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n          \n          \n            \n                        pos = CVUtil.putInt(computeSize(0), buffer, pos);", "author": "pejovica", "createdAt": "2020-07-21T10:02:28Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgyMTU0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458821541", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T14:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4MjExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NTY5NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457985695", "bodyText": "Can this field be removed?", "author": "pejovica", "createdAt": "2020-07-21T10:09:19Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxNDgyMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458814823", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T14:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NTY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NjE1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r457986152", "bodyText": "And this field, can it be removed?", "author": "pejovica", "createdAt": "2020-07-21T10:10:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgxNzIyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458817222", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-22T14:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4NjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNjQ0NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458226445", "bodyText": "Are there any plans to support the columns?", "author": "pejovica", "createdAt": "2020-07-21T16:23:04Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTI3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458805272", "bodyText": "Well, at one point I considered the possibility.  Gone.", "author": "stooke", "createdAt": "2020-07-22T13:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNjQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzOTA2MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458239061", "bodyText": "Maybe move this out of the LineEntry class?", "author": "pejovica", "createdAt": "2020-07-21T16:42:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    static class LineEntry {\n+\n+        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgwNTY4MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458805680", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-22T13:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzOTA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0OTc1NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458249754", "bodyText": "Unused constructor. Perhaps to chain it with the next one?", "author": "pejovica", "createdAt": "2020-07-21T16:59:14Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    static class LineEntry {\n+\n+        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+        static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n+\n+        int addr;\n+        int lineAndFLags;\n+\n+        LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5ODYzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458798637", "bodyText": "done.", "author": "stooke", "createdAt": "2020-07-22T13:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI0OTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3NTEyNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458275124", "bodyText": "You could simplify these bits here (and in several other places) by writing the whole header after the content.\nFor example, if the method void computeHeader(byte[] buffer, int initialPos, int contentSize) writes only the header, then writing the content could become something like:\n        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n        for (FileBlock fileBlock : fileBlocks) {\n            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n            pos = fileBlock.computeContents(buffer, pos);\n        }\n        computeHeader(initialPos, buffer, highAddr);\n        return pos;", "author": "pejovica", "createdAt": "2020-07-21T17:40:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    private static final boolean HAS_COLUMNS = false;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    private static final short CB_HAS_COLUMNS_FLAG = 0x01;\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    @SuppressWarnings(\"unused\") private PrimaryEntry primaryEntry;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        @SuppressWarnings(\"unused\") FileEntry file;\n+        int fileId;\n+\n+        FileBlock(FileEntry file, int fileId) {\n+            this.file = file;\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            pos = CVUtil.putInt(Integer.BYTES * 3 + lineEntries.size() * LineEntry.LINE_ENTRY_SIZE, buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            /* If HAS_COLUMNS is true, this formula is incorrect. */\n+            assert !HAS_COLUMNS;\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    static class LineEntry {\n+\n+        /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+        static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+        static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n+\n+        int addr;\n+        int lineAndFLags;\n+\n+        LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {\n+            this.addr = addr;\n+            assert line <= 0xffffff;\n+            assert line >= 0;\n+            assert deltaEnd <= 0x7f;\n+            assert deltaEnd >= 0;\n+            lineAndFLags = line | (deltaEnd << 24) | (isStatement ? 0x80000000 : 0);\n+        }\n+\n+        LineEntry(int addr, int line) {\n+            this.addr = addr;\n+            this.lineAndFLags = line;\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(addr, buffer, pos);\n+            pos = CVUtil.putInt(lineAndFLags, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName, PrimaryEntry entry) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.primaryEntry = entry;\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileRecord fr = cvDebugInfo.getCVSymbolSection().getFileRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(file, fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+\n+        assert symbolName != null;\n+        /* This implementation can't handle columns yet. */\n+        assert !HAS_COLUMNS;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        final short flags = HAS_COLUMNS ? CB_HAS_COLUMNS_FLAG : CB_HAS_NO_COLUMNS_FLAG;\n+        pos = CVUtil.putShort(flags, buffer, pos); /* flags */\n+\n+        /*\n+         * HighAddr = length of this chunk in object file (fill in correctly later).\n+         */\n+        final int cbConPos = pos; /* Save position of length(int32). */\n+        int highAddr = 0;\n+        pos = CVUtil.putInt(highAddr, buffer, pos);", "originalCommit": "85f3abd5ff140b0079a0d35a9f00f6973b60f499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg5NDkwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r458894907", "bodyText": "done (here, at least).", "author": "stooke", "createdAt": "2020-07-22T15:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3NTEyNA=="}], "type": "inlineReview"}, {"oid": "6b5e7101280ba80b98dd45bd2df905479963b5bd", "url": "https://github.com/oracle/graal/commit/6b5e7101280ba80b98dd45bd2df905479963b5bd", "message": "First round of changes after pejovica review", "committedDate": "2020-07-23T17:34:08Z", "type": "forcePushed"}, {"oid": "46d1056558f8ff5a1e7004219de75a046c063991", "url": "https://github.com/oracle/graal/commit/46d1056558f8ff5a1e7004219de75a046c063991", "message": "Changes from pejovica review", "committedDate": "2020-07-23T17:45:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0ODMyMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459948320", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * The address of the object file section containing the relocation's symbol (+addend(\n          \n          \n            \n                     * The address of the object file section containing the relocation's symbol (+addend)", "author": "pejovica", "createdAt": "2020-07-24T09:29:59Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java", "diffHunk": "@@ -252,6 +252,16 @@ public static ObjectFile createRuntimeDebugInfo(int pageSize) {\n          * The relocation's symbol provides high fixup bytes.\n          */\n         DIRECT_HI,\n+        /**\n+         * The index of the object file section containing the relocation's symbol supplies the\n+         * fixup bytes. (used in CodeView debug information)\n+         */\n+        SECTION,\n+        /**\n+         * The address of the object file section containing the relocation's symbol (+addend(", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTc3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241778", "bodyText": "FIxed (and reordered so DIRECT_HI and DIRECT_LOW are consecutive).", "author": "stooke", "createdAt": "2020-07-24T19:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4MjgzOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459982839", "bodyText": "Unused method.", "author": "pejovica", "createdAt": "2020-07-24T10:52:07Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private int sequenceCounter = 0x1000;\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private Map<Integer, CVTypeRecord> typeMap = new HashMap<>();\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    /**\n+     * Add all relevant type records to the type section.\n+     */\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTYzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241637", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-24T19:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4MjgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NTYwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459985603", "bodyText": "Is this necessary given that super.getDependencies does the same?", "author": "pejovica", "createdAt": "2020-07-24T10:59:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private int sequenceCounter = 0x1000;\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private Map<Integer, CVTypeRecord> typeMap = new HashMap<>();\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    /**\n+     * Add all relevant type records to the type section.\n+     */\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n+    }\n+\n+    public List<CVTypeRecord> getRecords() {\n+        return Collections.unmodifiableList(cvRecords);\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T> type of new record.\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        return addOrReference(newRecord);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    private void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(CV_SYMBOL_SECTION_NAME);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        /* Make our content depend on the codeview symbol section. */\n+        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n+        /* Make our size depend on our content. */\n+        deps.add(BuildDependency.createOrGet(ourSize, ourContent));", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTU4MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241581", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-24T19:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NTYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NzY5Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459987697", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* file are added to this record during function record building. */\n          \n          \n            \n                    /* Files are added to this record during function record building. */", "author": "pejovica", "createdAt": "2020-07-24T11:04:31Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+    private CVFileTableRecord fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* file are added to this record during function record building. */", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTUzNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241536", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-24T19:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk4NzY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NTk3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459995979", "bodyText": "You could also update CVUtil.putUTF8StringBytes so that when buffer is null it uses Utf8.utf8Length.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            currentOffset += Utf8.utf8Length(s) + 1;\n          \n          \n            \n                            currentOffset = CVUtil.putUTF8StringBytes(s, null, currentOffset);", "author": "pejovica", "createdAt": "2020-07-24T11:25:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+    private CVFileTableRecord fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* file are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* Use LinkedHashMap so order is maintained when writing string table. */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* Ensure that the empty string has index 0. */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                currentOffset += Utf8.utf8Length(s) + 1;", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NzIwMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460247202", "bodyText": "I've changed CVUtil.putUTF8StringBytes() as per this suggestion, but I think changing this particular call to use a code emitting function (even if no code is emitted) obscures the algorithm.", "author": "stooke", "createdAt": "2020-07-24T19:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5NTk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5ODcwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r459998709", "bodyText": "As in CVTypeSectionImpl, this may be unnecessary.", "author": "pejovica", "createdAt": "2020-07-24T11:32:52Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private CVDebugInfo cvDebugInfo;\n+\n+    private ArrayList<CVSymbolRecord> cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+    private CVStringTable stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+    private CVFileTableRecord fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            verboseLog(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* file are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* Use LinkedHashMap so order is maintained when writing string table. */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* Ensure that the empty string has index 0. */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                currentOffset += Utf8.utf8Length(s) + 1;\n+            }\n+            return entry == null ? newEntry.offset : entry.offset;\n+        }\n+\n+        Collection<StringTableEntry> values() {\n+            return strings.values();\n+        }\n+\n+        int size() {\n+            return strings.size();\n+        }\n+\n+        int getCurrentOffset() {\n+            return currentOffset;\n+        }\n+    }\n+\n+    void addRecord(CVSymbolRecord record) {\n+        cvRecords.add(record);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(TEXT_SECTION_NAME);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+        /* Make our content depend on the compiled code (.text) section. */\n+        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));\n+        /* Make our size depend on our content. */\n+        deps.add(BuildDependency.createOrGet(ourSize, ourContent));", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MjA1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460242057", "bodyText": "Removed.", "author": "stooke", "createdAt": "2020-07-24T19:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk5ODcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMjE2NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460022164", "bodyText": "This should be unnecessary as the elment is already set in PECoffObjectFile.newUserDefinedSection.", "author": "pejovica", "createdAt": "2020-07-24T12:29:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffObjectFile.java", "diffHunk": "@@ -683,4 +688,42 @@ public PECoffRelocationTable getRelocationTable() {\n     protected int getMinimumFileSize() {\n         return 0;\n     }\n+\n+    @Override\n+    public Section newDebugSection(String name, ElementImpl impl) {\n+        PECoffSection coffSection = (PECoffSection) super.newDebugSection(name, impl);\n+        coffSection.getFlags().add(PECoffSectionFlag.DISCARDABLE);\n+        coffSection.getFlags().add(PECoffSectionFlag.READ);\n+        coffSection.getFlags().add(PECoffSectionFlag.INITIALIZED_DATA);\n+        impl.setElement(coffSection);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI1MTQ0Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460251447", "bodyText": "I believe you're right.  The call to setElement() is gone.", "author": "stooke", "createdAt": "2020-07-24T19:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMjE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMzczNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460023735", "bodyText": "Isn't it enough that ObjectFile.newDebugSection already sets the allignment to 1?", "author": "pejovica", "createdAt": "2020-07-24T12:33:16Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSectionImpl.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+abstract class CVSectionImpl extends BasicProgbitsSectionImpl {\n+\n+    boolean debug = false;\n+\n+    CVSectionImpl() {\n+    }\n+\n+    @Override\n+    public void setElement(ObjectFile.Element e) {\n+        super.setElement(e);\n+        /* Define the section as a COFF symbol. */\n+        getOwner().createDefinedSymbol(getSectionName(), getElement(), 0, 0, false, false);\n+    }\n+\n+    private String debugSectionLogName() {\n+        /*\n+         * Log messages for the symbol section will be enabled using \"PeCoffdebug$S\". Log messages\n+         * for the type section will be enabled using \"PeCoffdebug$T\".\n+         */\n+        assert getSectionName().startsWith(CVConstants.CV_SECTION_NAME_PREFIX);\n+        return \"PeCoff\" + getSectionName().replace(\".\", \"\");\n+    }\n+\n+    protected void enableLog(DebugContext context) {\n+        /*\n+         * Unlike in the Dwarf debug code, debug output may be enabled in both the sizing and\n+         * writing phases. (Currently turned off in the sizing state)\n+         */\n+        if (context.areScopesEnabled()) {\n+            debug = true;\n+        }\n+    }\n+\n+    @Override\n+    public int getAlignment() {\n+        return 1;", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI4NzMzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460287337", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-07-24T21:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDAyMzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMDkxNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460120916", "bodyText": "It might make sense to change computeFullSize like this and remove computeSize completely as it doesn't seem to be needed anymore.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n          \n          \n            \n                    return computeSize(initialPos + prologueLength);\n          \n          \n            \n                    return computeFullContents(null, initialPos);", "author": "pejovica", "createdAt": "2020-07-24T15:20:46Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTQ0NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241445", "bodyText": "The intent was that computeSize() could be a quick calculation, but the reality (in this class at least) is that manually keeping track of size was a source of errors.  Changed.", "author": "stooke", "createdAt": "2020-07-24T19:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyMDkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjQ2Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460132462", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n          \n          \n            \n                            textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(TEXT_SECTION_NAME);\n          \n      \n    \n    \n  \n\nAlso, why not change textSection to be an instance field? Then you wouldn't even need getTextSection.", "author": "pejovica", "createdAt": "2020-07-24T15:40:12Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI2OTcyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460269722", "bodyText": "I've changed the code to use CvConstants.TEXT_SECTION_NAME, but I have kept it a global static for performance reasons: elementForName() does a HashMap lookup..", "author": "stooke", "createdAt": "2020-07-24T20:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNzYzNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460137635", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        typeIndex,\n          \n          \n            \n                                        flags);\n          \n          \n            \n                                        typeIndex, flags);", "author": "pejovica", "createdAt": "2020-07-24T15:48:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);\n+            }\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, name, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, name, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(name, buffer, pos);\n+            return pos;\n+        }\n+\n+        private ObjectFile.Element getTextSection() {\n+            if (textSection == null) {\n+                textSection = cvDebugInfo.getCVSymbolSection().getOwner().elementForName(SectionName.TEXT.getFormatDependentName(ObjectFile.Format.PECOFF));\n+            }\n+            return textSection;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_GPROC32   name=%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", name, pparent, debugStart, debugEnd, proclen, offset,\n+                            typeIndex,\n+                            flags);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTMxNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241317", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-24T19:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzNzYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTg3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460145874", "bodyText": "Given its formatting, I think we can remove this comment. \ud83d\ude09\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n          \n          \n            \n                                                                                * This string is inline null\n          \n          \n            \n                                                                                * terminated.\n          \n          \n            \n                                                                                */\n          \n          \n            \n                        pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);", "author": "pejovica", "createdAt": "2020-07-24T16:02:52Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0MTM2Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460241367", "bodyText": "Yes, this was the eclipse formatter.  Gone.", "author": "stooke", "createdAt": "2020-07-24T19:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MTU3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460151579", "bodyText": "I suppose this should ideally be the source file of the class with the main method, right?", "author": "pejovica", "createdAt": "2020-07-24T16:12:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI3NTA1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460275051", "bodyText": "Yes, if there is actually a main().  I could imagine there might not be a main() if Graal were set up to build a library.\nI have expanded the comment.", "author": "stooke", "createdAt": "2020-07-24T20:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MTU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MzEyMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462343120", "bodyText": "In that case, I think the actual main method (if any) should also be passed in to CVDebugInfo via DebugInfoProvider, but that can wait for the rework you mentioned.", "author": "pejovica", "createdAt": "2020-07-29T14:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1MTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MjMyNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460162326", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int pos = initialPos;\n          \n          \n            \n                    for (CVSymbolSubrecord subcmd : subcmds) {\n          \n          \n            \n                        pos = subcmd.computeFullSize(pos);\n          \n          \n            \n                    }\n          \n          \n            \n                    return pos;\n          \n          \n            \n                    return computeContents(null, initialPos);", "author": "pejovica", "createdAt": "2020-07-24T16:33:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsection.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A CVSymbolSubsection is s special record in debug$S containing nested symbol records.\n+ * (the nested records inherit from CVSymbolSubrecord)\n+ */\n+class CVSymbolSubsection extends CVSymbolRecord {\n+\n+    private static final int SUBCMD_INITIAL_CAPACITY = 100;\n+\n+    private ArrayList<CVSymbolSubrecord> subcmds = new ArrayList<>(SUBCMD_INITIAL_CAPACITY);\n+\n+    CVSymbolSubsection(CVDebugInfo cvDebugInfo) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_SYMBOLS);\n+    }\n+\n+    void addRecord(CVSymbolSubrecord subcmd) {\n+        subcmds.add(subcmd);\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        int pos = initialPos;\n+        for (CVSymbolSubrecord subcmd : subcmds) {\n+            pos = subcmd.computeFullSize(pos);\n+        }\n+        return pos;", "originalCommit": "46d1056558f8ff5a1e7004219de75a046c063991", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0ODQ1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r460248457", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-07-24T19:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MjMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5NDA0NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461494044", "bodyText": "I believe you meant the frame size here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n          \n          \n            \n                    addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));", "author": "pejovica", "createdAt": "2020-07-28T10:56:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzMjE4MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466432180", "bodyText": "Good catch.", "author": "stooke", "createdAt": "2020-08-06T13:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5NDA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODcwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461498709", "bodyText": "Why is it necessary to define a new symbol for each function? Was it not possible to use the existing ones?", "author": "pejovica", "createdAt": "2020-07-28T11:06:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.SectionName;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * a CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.subrecordStartPosition = initialPos;\n+        int prologueLength = Short.BYTES * 2; /* Room for length and subcommand. */\n+        return computeSize(initialPos + prologueLength);\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (no including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(cmd=0x%04x pos=0x%06x)\", cmd, subrecordStartPosition);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeSize(int pos);\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Extrapolate object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos); /*\n+                                                                    * This string is inline null\n+                                                                    * terminated.\n+                                                                    */\n+            return pos;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.c\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Find first source file - which, for Graal would be a class file on the command line.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        private static ObjectFile.Element textSection;\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String name;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.name = name;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String name, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset, short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, name, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer == null) {\n+                cvDebugInfo.getCVSymbolSection().getOwner().createDefinedSymbol(name, getTextSection(), offset, proclen, true, true);", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTAzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465699037", "bodyText": "Two reasons: I don't think they actually exist - if Graal produces a single large object file, then there is normally no need to emit externs for non-exported  functions.  Second reason, to emit a non-mangled name that the use can refer to in Visual Studio.", "author": "stooke", "createdAt": "2020-08-05T12:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyNDAzMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461524030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.addr = addr;\n          \n          \n            \n                        this.lineAndFLags = line;", "author": "pejovica", "createdAt": "2020-07-28T11:58:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 4, ObjectFile.RelocationKind.SECREL, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, 2, ObjectFile.RelocationKind.SECTION, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int highAddr = 0; /* Length of this chunk in object file */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        computeHeader(buffer, initialPos, highAddr);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;\n+        }\n+    }\n+\n+    /*\n+     * LineEntry associates some object code (at 'addr', relative to the start of this DEBUG_S_LINES\n+     * record) with a source line in the current FileBlock file.\n+     */\n+    private static class LineEntry {\n+\n+        /* Entry: address(4 bytes) line number+flags (4 bytes) */\n+        static final int LINE_ENTRY_SIZE = 2 * Integer.BYTES;\n+\n+        int addr;\n+        int lineAndFLags;\n+\n+        LineEntry(int addr, int line, int deltaEnd, boolean isStatement) {\n+            this.addr = addr;\n+            assert line <= 0xffffff;\n+            assert line >= 0;\n+            assert deltaEnd <= 0x7f;\n+            assert deltaEnd >= 0;\n+            lineAndFLags = line | (deltaEnd << 24) | (isStatement ? 0x80000000 : 0);\n+        }\n+\n+        LineEntry(int addr, int line) {\n+            this(addr, line, 0, false);\n+            this.addr = addr;\n+            this.lineAndFLags = line;", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3MTU1Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465671553", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-08-05T11:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUyNDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0OTgwOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461749809", "bodyText": "A leftover?", "author": "pejovica", "createdAt": "2020-07-28T17:27:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null). This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information, so\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* in the future, use a \"link.exe-safe\" name instead of a hash function. */\n+            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n+            methodName = range.getClassAndMethodName() + \".\" + hash;\n+        }\n+        // debug(\"replacing %s with %s\\n\", range.getFullMethodName(), methodName);", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3MTQ5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465671496", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-08-05T11:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0OTgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2MjEyNg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r461762126", "bodyText": "Adding a small abstraction for FileTableEntry could help with clarity. Basically, the code is already structured with file table entries in mind, it's just that they are not explicit.", "author": "pejovica", "createdAt": "2020-07-28T17:47:38Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import org.graalvm.compiler.debug.GraalError;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileTableRecord extends CVSymbolRecord {", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk4ODI4NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466988285", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-08-07T11:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2MjEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxODQyMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462218421", "bodyText": "This looks like a bug in FileEntry, so why not fix it there?", "author": "pejovica", "createdAt": "2020-07-29T11:07:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import org.graalvm.compiler.debug.GraalError;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileTableRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* Create required stringtable entry. */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /*\n+         * As part of computing the size, add all fileEntries ignoring duplicates. Most fileEntries\n+         * are created while building the symbol section.\n+         */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);\n+        }\n+        return initialPos + (fileEntryToOffsetMap.size() * FILE_RECORD_LENGTH);\n+    }\n+\n+    @Override\n+    public int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos;\n+        for (FileEntry entry : fileEntryToOffsetMap.keySet()) {\n+            pos = put(entry, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int put(FileEntry entry, byte[] buffer, int initialPos) {\n+        String fn = fixPath(entry);\n+        int stringId = fn != null ? strings.add(fn) : 0; /* If no file, then use string 0 (= \"\"). */\n+        int pos = CVUtil.putInt(stringId, buffer, initialPos); /* Stringtable index. */\n+        pos = CVUtil.putByte(CB_VALUE, buffer, pos); /* Cb (unknown what this is). */\n+        byte[] checksum = calculateMD5Sum(fn);\n+        if (checksum != null) {\n+            pos = CVUtil.putByte(CHECKSUM_MD5, buffer, pos); /* Checksum type (0x01 == MD5). */\n+            pos = CVUtil.putBytes(checksum, buffer, pos);\n+        } else {\n+            pos = CVUtil.putByte(CHECKSUM_NONE, buffer, pos);\n+            pos = CVUtil.putBytes(EMPTY_CHECKSUM, buffer, pos);\n+        }\n+        pos = CVUtil.align4(pos);\n+        assert pos == initialPos + FILE_RECORD_LENGTH;\n+        return pos;\n+    }\n+\n+    private static byte[] calculateMD5Sum(String fn) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+            md.update(Files.readAllBytes(Paths.get(fn)));\n+            return md.digest();\n+        } catch (IOException e) {\n+            return null;\n+        } catch (NoSuchAlgorithmException e) {\n+            throw GraalError.shouldNotReachHere();\n+        }\n+    }\n+\n+    /**\n+     * Convert a FileEntry to a path. Avoid an NPE if there's no DirEntry.\n+     *\n+     * @param fileEntry entry containing uncorrected path.\n+     * @return path string, including directory if it exists.\n+     */\n+    private static String fixPath(FileEntry fileEntry) {\n+        return fileEntry.getDirEntry() != null ? fileEntry.getFullName() : fileEntry.getFileName();\n+    }", "originalCommit": "26825b7727b0cfbcff2dbf28e7fea03b862493ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1OTEwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466659103", "bodyText": "There is a semantic change if I do it there.  But I've done it anyways...", "author": "stooke", "createdAt": "2020-08-06T20:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxODQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI4NTA1Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462285057", "bodyText": "I don't quite understand the purpose of this check. Won't it make you skip a function in case of a hash code collision?", "author": "pejovica", "createdAt": "2020-07-29T13:10:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTQ4NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465699484", "bodyText": "Technically, yes.  But the collusion space is only the argument list for a given overloaded function, and the functions must be declared sequentially, so it is very small.  I actually suspect that the test is completely unnecessary (if a debug info primary entry represents a class function), but this is defensive code.  If I can confirm that, I'll get rid of this test entirely.", "author": "stooke", "createdAt": "2020-08-05T12:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI4NTA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4MzA4Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462883082", "bodyText": "Can we rename symbolRecord to something more descriptive? E.g.,\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final CVSymbolSubsection symbolRecord;\n          \n          \n            \n                private final CVSymbolSubsection cvSymbolSubsection;", "author": "pejovica", "createdAt": "2020-07-30T09:50:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY3MTIzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465671238", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-08-05T11:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4MzA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDUwMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462890500", "bodyText": "This method needs a more descriptive name. Or you could just remove it.", "author": "pejovica", "createdAt": "2020-07-30T10:04:36Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null). This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information, so\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* in the future, use a \"link.exe-safe\" name instead of a hash function. */\n+            long hash = range.getParamNames().hashCode() & 0xffffffffL;\n+            methodName = range.getClassAndMethodName() + \".\" + hash;\n+        }\n+        // debug(\"replacing %s with %s\\n\", range.getFullMethodName(), methodName);\n+        return methodName;\n+    }\n+\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+        /*\n+         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n+         * Graal intrinsics may be uninteresting to some developers.\n+         */\n+        if (record != null) {\n+            cvDebugInfo.getCVSymbolSection().addRecord(record);\n+        }\n+    }\n+\n+    private void addToSymbolRecord(CVSymbolSubrecord record) {", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MTY5Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465691697", "bodyText": "Renamed to \"addToSymbolSubsection()\" and a comment added.", "author": "stooke", "createdAt": "2020-08-05T12:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxODUxMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462918511", "bodyText": "As far as I can see, if there is a new file here, it means that there is no line entry that refers to it, so why add it? How will it be used?", "author": "pejovica", "createdAt": "2020-07-30T11:01:13Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVFileTableRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import org.graalvm.compiler.debug.GraalError;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+final class CVFileTableRecord extends CVSymbolRecord {\n+\n+    private static final byte CHECKSUM_NONE = 0x00;\n+    private static final byte CHECKSUM_MD5 = 0x01;\n+    private static final byte CB_VALUE = 0x10;\n+\n+    private static final int FILE_RECORD_LENGTH = 24;\n+\n+    private static final int CHECKSUM_LENGTH = 16;\n+    private static final byte[] EMPTY_CHECKSUM = new byte[CHECKSUM_LENGTH];\n+\n+    private static final int FILE_TABLE_INITIAL_SIZE = 200;\n+\n+    private final CVSymbolSectionImpl.CVStringTable strings;\n+\n+    private int currentOffset = 0;\n+    private Map<FileEntry, Integer> fileEntryToOffsetMap = new LinkedHashMap<>(FILE_TABLE_INITIAL_SIZE);\n+\n+    CVFileTableRecord(CVDebugInfo cvDebugInfo, CVSymbolSectionImpl.CVStringTable strings) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_FILECHKSMS);\n+        this.strings = strings;\n+    }\n+\n+    int addFile(FileEntry entry) {\n+        if (fileEntryToOffsetMap.containsKey(entry)) {\n+            return fileEntryToOffsetMap.get(entry);\n+        } else {\n+            fileEntryToOffsetMap.put(entry, currentOffset);\n+            /* Create required stringtable entry. */\n+            strings.add(fixPath(entry));\n+            currentOffset += FILE_RECORD_LENGTH;\n+            return currentOffset - FILE_RECORD_LENGTH;\n+        }\n+    }\n+\n+    @Override\n+    public int computeSize(int initialPos) {\n+        /*\n+         * As part of computing the size, add all fileEntries ignoring duplicates. Most fileEntries\n+         * are created while building the symbol section.\n+         */\n+        for (FileEntry entry : cvDebugInfo.getFiles()) {\n+            addFile(entry);", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MjYwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r465692604", "bodyText": "This is partially defensive programming, and partially to account for files that define types without code, which will be used when the type section PR comes along.", "author": "stooke", "createdAt": "2020-08-05T12:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxODUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2NzAyMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502667023", "bodyText": "I fine with being defensive, but I don't think we should be adding files just in case. Therefore, I suggest removing this, or you could try to make an assertion that there are no unused files (I think that should be true at least for now), in which case that assertion should be put in CVSymbolSectionImpl.addFileRecord instead of here.", "author": "pejovica", "createdAt": "2020-10-09T20:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkxODUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyNzU0Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r462927546", "bodyText": "As far as usability goes, I think this is fine. However, I don\u2019t think we need all these \"options\". Could we simplify this and just use the first main we find. This should only be temporary anyway (until the actual main becomes available via DebugInfoProvider as I have already suggested).", "author": "pejovica", "createdAt": "2020-07-30T11:20:40Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.replaceMainFunctionName;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.emitUnadornedMain;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection symbolRecord;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.symbolRecord = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(symbolRecord);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        String previousMethodName = \"\";\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            Range primaryRange = primaryEntry.getPrimary();\n+            String newMethodName = fixMethodName(primaryRange);\n+            if (!newMethodName.equals(previousMethodName)) {\n+                previousMethodName = newMethodName;\n+                build(primaryEntry, newMethodName);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     * @param methodName method name alias as it will be seen by the user\n+     */\n+    private void build(PrimaryEntry primaryEntry, String methodName) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, methodName, 0, 0, 0, primaryRange.getHi() - primaryRange.getLo(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolRecord(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryRange.getHi() - primaryRange.getLo(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolRecord(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+        addLineNumberRecords(primaryEntry, methodName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main (unless replaceMainFunctionName is\n+     * non-null). This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information, so\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String fixMethodName(Range range) {\n+        final String methodName;\n+        if (replaceMainFunctionName != null && noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = replaceMainFunctionName;\n+        } else if (emitUnadornedMain && noMainFound && range.getMethodName().equals(\"main\")) {\n+            /* TODO: check for static void main(String args[]) instead of just main(...). */\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();", "originalCommit": "2b7c351c66a14132a77aef64a09e0d5a6a800367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk5NzUxNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r466997515", "bodyText": "For now, the first main function will be  'package.Class.main' no 'package.Class.main_9999999'.", "author": "stooke", "createdAt": "2020-08-07T12:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjkyNzU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484820335", "bodyText": "This shouldn't be necessary.", "author": "pejovica", "createdAt": "2020-09-08T10:38:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffSymtab.java", "diffHunk": "@@ -299,6 +299,9 @@ public int indexOf(Symbol sym) {\n         if (symtabStruct == null) {\n             throw new IllegalStateException(\"Symbol table content is not decided yet.\");\n         }\n+        if (sym == null) {\n+            throw new NullPointerException(\"symbol doesn't exist yet\");\n+        }", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTQ3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485169479", "bodyText": "This was not my code (you added it in February); are you sure you want me to delete it in this PR?", "author": "stooke", "createdAt": "2020-09-08T20:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ2Nzc1Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485467756", "bodyText": "Yes, please remove it.", "author": "pejovica", "createdAt": "2020-09-09T09:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU3MzE2NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485573164", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-09T12:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgyMDMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODI3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484838278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int hi, int line,\n          \n          \n            \n                                boolean isDeoptTarget) {\n          \n          \n            \n                                int hi, int line, boolean isDeoptTarget) {", "author": "pejovica", "createdAt": "2020-09-08T11:14:21Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -56,23 +60,26 @@\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNDcwNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485124704", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODUxMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484838510", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int hi, int line,\n          \n          \n            \n                                Range primary) {\n          \n          \n            \n                                int hi, int line, Range primary) {", "author": "pejovica", "createdAt": "2020-09-08T11:14:51Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -56,23 +60,26 @@\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     Range primary) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNDg3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485124874", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzODUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzOTE3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484839178", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                int hi, int line,\n          \n          \n            \n                                boolean isDeoptTarget, Range primary) {\n          \n          \n            \n                                int hi, int line, boolean isDeoptTarget, Range primary) {", "author": "pejovica", "createdAt": "2020-09-08T11:16:09Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -56,23 +60,26 @@\n     /*\n      * Create a primary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n+        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, isDeoptTarget, null);\n     }\n \n     /*\n      * Create a secondary range.\n      */\n-    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    public Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     Range primary) {\n-        this(fileName, filePath, cachePath, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n+        this(fileName, filePath, cachePath, className, methodName, symbolName, paramNames, returnTypeName, stringTable, lo, hi, line, false, primary);\n     }\n \n     /*\n      * Create a primary or secondary range.\n      */\n-    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String paramNames, String returnTypeName, StringTable stringTable, int lo, int hi, int line,\n+    private Range(String fileName, Path filePath, Path cachePath, String className, String methodName, String symbolName, String paramNames, String returnTypeName, StringTable stringTable, int lo,\n+                    int hi, int line,\n                     boolean isDeoptTarget, Range primary) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNDk3OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485124978", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDgzOTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg0NDgxMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484844812", "bodyText": "I think this can be simplified to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuilder builder = new StringBuilder();\n          \n          \n            \n                    if (className != null) {\n          \n          \n            \n                        builder.append(className).append(CLASS_DELIMITER);\n          \n          \n            \n                    }\n          \n          \n            \n                    builder.append(methodName);\n          \n          \n            \n                    return builder.toString();\n          \n          \n            \n                    return getExtendedMethodName(false, false);", "author": "pejovica", "createdAt": "2020-09-08T11:27:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -151,6 +163,19 @@ public boolean isDeoptTarget() {\n         return isDeoptTarget;\n     }\n \n+    public String getParamNames() {\n+        return paramNames;\n+    }\n+\n+    public String getClassAndMethodName() {\n+        StringBuilder builder = new StringBuilder();\n+        if (className != null) {\n+            builder.append(className).append(CLASS_DELIMITER);\n+        }\n+        builder.append(methodName);\n+        return builder.toString();", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTIxNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485169214", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T20:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg0NDgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0ODg2MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484948861", "bodyText": "As a result of your latest changes, this should no longer be necessary, i.e., there should be no dependency from the .debug$S section to the .text section, so you can remove the whole getDependencies method.", "author": "pejovica", "createdAt": "2020-09-08T14:07:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.TEXT_SECTION_NAME;\n+\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final ArrayList<CVSymbolRecord> cvRecords;\n+    private final CVStringTable stringTable;\n+    private final CVFileTableRecord fileTableRecord;\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+        this.stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+        this.fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        log(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            log(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* Files are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {\n+        static final class StringTableEntry {\n+            public int offset;\n+            public String text;\n+\n+            StringTableEntry(int offset, String text) {\n+                this.offset = offset;\n+                this.text = text;\n+            }\n+        }\n+\n+        /* Use LinkedHashMap so order is maintained when writing string table. */\n+        private final HashMap<String, StringTableEntry> strings;\n+        private int currentOffset = 0;\n+\n+        CVStringTable(int startSize) {\n+            strings = new LinkedHashMap<>(startSize);\n+            /* Ensure that the empty string has index 0. */\n+            add(\"\");\n+        }\n+\n+        int add(String s) {\n+            StringTableEntry newEntry = new StringTableEntry(currentOffset, s);\n+            StringTableEntry entry = strings.putIfAbsent(s, newEntry);\n+            if (entry == null) {\n+                currentOffset += Utf8.utf8Length(s) + 1;\n+            }\n+            return entry == null ? newEntry.offset : entry.offset;\n+        }\n+\n+        Collection<StringTableEntry> values() {\n+            return strings.values();\n+        }\n+\n+        int size() {\n+            return strings.size();\n+        }\n+\n+        int getCurrentOffset() {\n+            return currentOffset;\n+        }\n+    }\n+\n+    void addRecord(CVSymbolRecord record) {\n+        cvRecords.add(record);\n+    }\n+\n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        PECoffObjectFile.PECoffSection targetSection = (PECoffObjectFile.PECoffSection) getElement().getOwner().elementForName(TEXT_SECTION_NAME);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        /* Make our content depend on the compiled code (.text) section. */\n+        deps.add(BuildDependency.createOrGet(ourContent, decisions.get(targetSection).getDecision(LayoutDecision.Kind.CONTENT)));", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNjg3OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485126879", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0ODg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4MzA5NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484983094", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    int offset, short segment,\n          \n          \n            \n                                    byte flags) {\n          \n          \n            \n                                    int offset, short segment, byte flags) {", "author": "pejovica", "createdAt": "2020-09-08T14:52:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * A CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n+        subrecordStartPosition = initialPos;\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (not including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(pos=0x%06x cmd=0x%04x)\", subrecordStartPosition, cmd);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Infer object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.java\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String externalName;\n+        String debuggerName;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+                        int offset, short segment,\n+                        byte flags) {", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTU2NQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485125565", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4MzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4Mzc4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r484983787", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        proclen, offset,\n          \n          \n            \n                                        typeIndex, flags);\n          \n          \n            \n                                        proclen, offset, typeIndex, flags);", "author": "pejovica", "createdAt": "2020-09-08T14:53:24Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * A CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n+        subrecordStartPosition = initialPos;\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (not including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(pos=0x%06x cmd=0x%04x)\", subrecordStartPosition, cmd);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Infer object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.java\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */\n+    public static class CVSymbolGProc32Record extends CVSymbolSubrecord {\n+\n+        int pparent;\n+        int pend;\n+        int pnext;\n+        int proclen;\n+        int debugStart;\n+        int debugEnd;\n+        int typeIndex;\n+        int offset;\n+        short segment;\n+        byte flags;\n+        String externalName;\n+        String debuggerName;\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, short cmd, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex,\n+                        int offset, short segment,\n+                        byte flags) {\n+            super(cvDebugInfo, cmd);\n+            this.externalName = externalName;\n+            this.debuggerName = debuggerName;\n+            this.pparent = pparent;\n+            this.pend = pend;\n+            this.pnext = pnext;\n+            this.proclen = proclen;\n+            this.debugStart = debugStart;\n+            this.debugEnd = debugEnd;\n+            this.typeIndex = typeIndex;\n+            this.offset = offset;\n+            this.segment = segment;\n+            this.flags = flags;\n+        }\n+\n+        CVSymbolGProc32Record(CVDebugInfo cvDebugInfo, String externalName, String debuggerName, int pparent, int pend, int pnext, int proclen, int debugStart, int debugEnd, int typeIndex, int offset,\n+                        short segment, byte flags) {\n+            this(cvDebugInfo, CVDebugConstants.S_GPROC32, externalName, debuggerName, pparent, pend, pnext, proclen, debugStart, debugEnd, typeIndex, offset, segment, flags);\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(pparent, buffer, initialPos);\n+            pos = CVUtil.putInt(pend, buffer, pos);\n+            pos = CVUtil.putInt(pnext, buffer, pos);\n+            pos = CVUtil.putInt(proclen, buffer, pos);\n+            pos = CVUtil.putInt(debugStart, buffer, pos);\n+            pos = CVUtil.putInt(debugEnd, buffer, pos);\n+            pos = CVUtil.putInt(typeIndex, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, externalName, false, 1L);\n+            }\n+            pos = CVUtil.putInt(0, buffer, pos);\n+            if (buffer != null) {\n+                cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, externalName, false, 1L);\n+            }\n+            pos = CVUtil.putShort((short) 0, buffer, pos);\n+            pos = CVUtil.putByte(flags, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(debuggerName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_GPROC32   name=%s/%s parent=%d debugstart=0x%x debugend=0x%x len=0x%x offset=0x%x type=0x%x flags=0x%x)\", debuggerName, externalName, pparent, debugStart, debugEnd,\n+                            proclen, offset,\n+                            typeIndex, flags);", "originalCommit": "f853143b8b1b99dc5ecb13bc9d3f90133041e58f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTgyOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r485125829", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-08T18:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk4Mzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490134350", "bodyText": "Is ADDR32 needed? It doesn't seem to be used anywhere.", "author": "pejovica", "createdAt": "2020-09-17T10:20:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/PECoffMachine.java", "diffHunk": "@@ -146,6 +150,24 @@ public long toLong() {\n             return IMAGE_RELOCATION.IMAGE_REL_AMD64_ADDR64;\n         }\n     },\n+    ADDR32 {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMjkwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492332907", "bodyText": "Not at this time, but I included it to be more consistent with other code in Graal, (such as PECoff.java).\nMy belief is that when you're defining constants for hardware, you should include them all, not just a subset.\nIt doesn't hurt readability, and may make some coder's life easier in the future.", "author": "stooke", "createdAt": "2020-09-21T20:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMxMzUzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502313538", "bodyText": "Could you then hook it into getRelocation as well, because it's kind of half done right now.", "author": "pejovica", "createdAt": "2020-10-09T09:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyMTQxOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510221418", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T14:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzNDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzOTkwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490139903", "bodyText": "This should no longer be needed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static final String TEXT_SECTION_NAME = SectionName.TEXT.getFormatDependentName(PECOFF);", "author": "pejovica", "createdAt": "2020-09-17T10:30:58Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVConstants.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.SectionName;\n+\n+import static com.oracle.objectfile.ObjectFile.Format.PECOFF;\n+\n+public abstract class CVConstants {\n+\n+    /* The names of relevant CodeView sections. */\n+    static final String CV_SECTION_NAME_PREFIX = \".debug$\";\n+    static final String CV_SYMBOL_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"S\";\n+    static final String CV_TYPE_SECTION_NAME = CV_SECTION_NAME_PREFIX + \"T\";\n+    static final String TEXT_SECTION_NAME = SectionName.TEXT.getFormatDependentName(PECOFF);", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NjA1MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492276051", "bodyText": "done.", "author": "stooke", "createdAt": "2020-09-21T18:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDEzOTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3MjY3Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490172672", "bodyText": "The methodName parameter is no longer needed because you can now get the symbol name via primaryEntry.", "author": "pejovica", "createdAt": "2020-09-17T11:34:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection cvSymbolSubsection;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            build(primaryEntry);\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     */\n+    private void build(PrimaryEntry primaryEntry) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* The name as it will appear in the debugger. */\n+        final String debuggerName = getDebuggerName(primaryRange);\n+\n+        /* The name as exposed to the linker. */\n+        final String externalName = primaryRange.getSymbolName();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryEntry.getFrameSize(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolSubsection(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+\n+        /* Add line number records. */\n+        addLineNumberRecords(primaryEntry, externalName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main. This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information.\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String getDebuggerName(Range range) {\n+        final String methodName;\n+        if (noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* In the future, use a more user-friendly name instead of a hash function. */\n+            methodName = range.getSymbolName();\n+        }\n+        return methodName;\n+    }\n+\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNjcwNQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492326705", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-21T20:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3MjY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3Nzg4Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490177887", "bodyText": "It seems that record is never null, so perhaps code and comment need updating.", "author": "pejovica", "createdAt": "2020-09-17T11:43:48Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection cvSymbolSubsection;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            build(primaryEntry);\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     */\n+    private void build(PrimaryEntry primaryEntry) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* The name as it will appear in the debugger. */\n+        final String debuggerName = getDebuggerName(primaryRange);\n+\n+        /* The name as exposed to the linker. */\n+        final String externalName = primaryRange.getSymbolName();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryEntry.getFrameSize(), 0, 0,\n+                        functionTypeIndex, primaryRange.getLo(), (short) 0, funcFlags);\n+        addToSymbolSubsection(proc32);\n+\n+        /* S_FRAMEPROC add frame definitions. */\n+        int asynceh = 1 << 9; /* Async exception handling (vc++ uses 1, clang uses 0). */\n+        int localBP = 1 << 14; /* Local base pointer = SP (0=none, 1=sp, 2=bp 3=r13). */\n+        int paramBP = 1 << 16; /* Param base pointer = SP. */\n+        int frameFlags = asynceh + localBP + paramBP; /* NB: LLVM uses 0x14000. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolFrameProcRecord(cvDebugInfo, primaryEntry.getFrameSize(), frameFlags));\n+\n+        /* TODO: add local variables, and their types. */\n+        /* TODO: add block definitions. */\n+\n+        /* S_END add end record. */\n+        addToSymbolSubsection(new CVSymbolSubrecord.CVSymbolEndRecord(cvDebugInfo));\n+\n+        /* Add line number records. */\n+        addLineNumberRecords(primaryEntry, externalName);\n+    }\n+\n+    /**\n+     * Rename function names for usability or functionality.\n+     *\n+     * First encountered main function becomes class.main. This is for usability.\n+     *\n+     * All other functions become class.function.999 (where 999 is a hash of the arglist). This is\n+     * because The standard link.exe can't handle odd characters (parentheses or commas, for\n+     * example) in debug information.\n+     *\n+     * This does not affect external symbols used by linker.\n+     *\n+     * TODO: strip illegal characters from arg lists instead (\"link.exe\" - safe names)\n+     *\n+     * @param range Range contained in the method of interest\n+     * @return user debugger friendly method name\n+     */\n+    private String getDebuggerName(Range range) {\n+        final String methodName;\n+        if (noMainFound && range.getMethodName().equals(\"main\")) {\n+            noMainFound = false;\n+            methodName = range.getClassAndMethodName();\n+        } else {\n+            /* In the future, use a more user-friendly name instead of a hash function. */\n+            methodName = range.getSymbolName();\n+        }\n+        return methodName;\n+    }\n+\n+    private void addLineNumberRecords(PrimaryEntry primaryEntry, String methodName) {\n+        CVLineRecord record = lineRecordBuilder.build(primaryEntry, methodName);\n+        /*\n+         * If the builder decides this entry is uninteresting, we don't build a record. for example,\n+         * Graal intrinsics may be uninteresting to some developers.\n+         */\n+        if (record != null) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNjkxOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492306919", "bodyText": "You're right; I changed the code to only add a record if there were fileblock entries.", "author": "stooke", "createdAt": "2020-09-21T19:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE3Nzg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIwOTIzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490209234", "bodyText": "Have you considered using a new builder for each entry? I think that would simplify the code a bit because you would no longer have to think about the state of the builder here (e.g., you would already set primaryEntry in the constructor).", "author": "pejovica", "createdAt": "2020-09-17T12:37:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * to handle this, first we decide if we want to merge this with the previous range (only if\n+ * same file and start of this range is end of previous range) if we are emitting a new range to\n+ * the same file, write the range, save it as the previous range and go on If this is a\n+ * different file, then update the length of the previous file header, write the new file header\n+ * and write the new range At the very end, make sure we update the last file header.\n+ *\n+ * In addition, optionally ignore Ranges that point into Graal innards, just adding them to the\n+ * current enclosing range.\n+ */\n+\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry, String methodName) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNzQzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493037432", "bodyText": "I'd rather not; I don't think the code would be much clearer (but it would be less efficient - I'd like to rewrite it more of a stream handler), and there's a chance that the Builder might in future need to know the previous state when I reimplement some of the code that I've removed.", "author": "stooke", "createdAt": "2020-09-22T21:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIwOTIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxMDM2Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490210366", "bodyText": "A leftover? Same below.", "author": "pejovica", "createdAt": "2020-09-17T12:39:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * to handle this, first we decide if we want to merge this with the previous range (only if\n+ * same file and start of this range is end of previous range) if we are emitting a new range to\n+ * the same file, write the range, save it as the previous range and go on If this is a\n+ * different file, then update the length of the previous file header, write the new file header\n+ * and write the new range At the very end, make sure we update the last file header.\n+ *\n+ * In addition, optionally ignore Ranges that point into Graal innards, just adding them to the\n+ * current enclosing range.\n+ */\n+\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry, String methodName) {\n+        // long lowAddr = Long.MAX_VALUE;\n+        // long highAddr = 0;", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNzU3NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492327574", "bodyText": "Gone.", "author": "stooke", "createdAt": "2020-09-21T20:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxMDM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzMDY4Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490230686", "bodyText": "This is a bit hard to follow. Could you please remove everything that hasn't been fully implemented yet, so that the code (and comments) better reflect what's actually going on.", "author": "pejovica", "createdAt": "2020-09-17T13:10:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * to handle this, first we decide if we want to merge this with the previous range (only if\n+ * same file and start of this range is end of previous range) if we are emitting a new range to\n+ * the same file, write the range, save it as the previous range and go on If this is a\n+ * different file, then update the length of the previous file header, write the new file header\n+ * and write the new range At the very end, make sure we update the last file header.\n+ *\n+ * In addition, optionally ignore Ranges that point into Graal innards, just adding them to the\n+ * current enclosing range.\n+ */\n+\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry, String methodName) {\n+        // long lowAddr = Long.MAX_VALUE;\n+        // long highAddr = 0;\n+        this.primaryEntry = entry;\n+\n+        Range primaryRange = primaryEntry.getPrimary();\n+        Range previousRange = null;\n+\n+        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, methodName);\n+        debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n+        previousRange = processRange(primaryRange, previousRange);\n+        // lowAddr = Math.min(lowAddr, primaryRange.getLo());\n+        // highAddr = Math.max(highAddr, primaryRange.getHi());\n+\n+        for (Range subRange : primaryEntry.getSubranges()) {\n+            debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n+            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n+            if (subFileEntry == null) {\n+                continue;\n+            }\n+            previousRange = processRange(subRange, previousRange);\n+            // lowAddr = Math.min(lowAddr, subRange.getLo());\n+            // highAddr = Math.max(highAddr, subRange.getHi());\n+        }\n+        return lineRecord;\n+    }\n+\n+    /**\n+     * Merge input Range structures into line number table. The Range structures are assumed to be\n+     * ordered by ascending address merge with previous line entry if: - if a Range has a negative\n+     * linenumber - if a range is part of Graal or the JDK, and skipGraalOption is true - if a range\n+     * has the same line number, source file and function\n+     *\n+     * @param range to be merged or added to line number record\n+     * @param oldPreviousRange the previously processed Range\n+     * @return new value for previousRange in caller\n+     */\n+    private Range processRange(Range range, Range oldPreviousRange) {", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNzQ4Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493037483", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-22T21:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzMDY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM1ODQxMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490358411", "bodyText": "I wonder if it is even necessary to compute highAddr? Given that the ranges are already sorted by ascending addresses, shouldn't it be the same as the one from the last fileBlock?", "author": "pejovica", "createdAt": "2020-09-17T15:49:25Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int highAddr = 0; /* Length of this chunk in object file */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            highAddr = Math.max(highAddr, fileBlock.getHighAddr());", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwNDAwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493004007", "bodyText": "done.", "author": "stooke", "createdAt": "2020-09-22T20:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM1ODQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM4MzgxMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490383813", "bodyText": "Assuming the ranges are sorted correctly (which you could assert when adding an entry or line), you could simply return addr of the last line here.", "author": "pejovica", "createdAt": "2020-09-17T16:17:21Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        int highAddr = 0; /* Length of this chunk in object file */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            highAddr = Math.max(highAddr, fileBlock.getHighAddr());\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        computeHeader(buffer, initialPos, highAddr);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        int highAddr = 0;\n+        int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            highAddr = Math.max(highAddr, le.addr);\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return highAddr;", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwNTY0Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r493005646", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-09-22T20:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM4MzgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDUwMA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r490414500", "bodyText": "I think you may have inadvertently changed proclen to primaryEntry.getFrameSize() here (i.e., shouldn't it be primaryRange.getHi() - primaryRange.getLo() as it was before).", "author": "pejovica", "createdAt": "2020-09-17T16:54:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubsectionBuilder.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_NOTYPE;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.T_VOID;\n+\n+final class CVSymbolSubsectionBuilder {\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final CVSymbolSubsection cvSymbolSubsection;\n+    private CVLineRecordBuilder lineRecordBuilder;\n+    private DebugContext debugContext = null;\n+\n+    private boolean noMainFound = true;\n+\n+    CVSymbolSubsectionBuilder(CVDebugInfo cvDebugInfo) {\n+        this.cvSymbolSubsection = new CVSymbolSubsection(cvDebugInfo);\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    /**\n+     * Build DEBUG_S_SYMBOLS record from all classEntries. (CodeView 4 format allows us to build one\n+     * per class or one per function or one big record - which is what we do here).\n+     *\n+     * The CodeView symbol section Prolog is also a CVSymbolSubsection, but it is not build in this\n+     * class.\n+     */\n+    void build(DebugContext theDebugContext) {\n+        this.debugContext = theDebugContext;\n+        this.lineRecordBuilder = new CVLineRecordBuilder(debugContext, cvDebugInfo);\n+        /* loop over all classes defined in this module. */\n+        for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+            build(classEntry);\n+        }\n+        cvDebugInfo.getCVSymbolSection().addRecord(cvSymbolSubsection);\n+    }\n+\n+    /**\n+     * Build all debug info for a classEntry. (does not yet handle member variables).\n+     *\n+     * @param classEntry current class\n+     */\n+    private void build(ClassEntry classEntry) {\n+        /* Loop over all functions defined in this class. */\n+        for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+            build(primaryEntry);\n+        }\n+    }\n+\n+    /**\n+     * Emit records for each function: PROC32 S_FRAMEPROC S_END and line number records. (later:\n+     * type records as required).\n+     *\n+     * @param primaryEntry primary entry for this function\n+     */\n+    private void build(PrimaryEntry primaryEntry) {\n+        final Range primaryRange = primaryEntry.getPrimary();\n+\n+        /* The name as it will appear in the debugger. */\n+        final String debuggerName = getDebuggerName(primaryRange);\n+\n+        /* The name as exposed to the linker. */\n+        final String externalName = primaryRange.getSymbolName();\n+\n+        /* S_PROC32 add function definition. */\n+        int functionTypeIndex = addTypeRecords(primaryEntry);\n+        byte funcFlags = 0;\n+        CVSymbolSubrecord.CVSymbolGProc32Record proc32 = new CVSymbolSubrecord.CVSymbolGProc32Record(cvDebugInfo, externalName, debuggerName, 0, 0, 0, primaryEntry.getFrameSize(), 0, 0,", "originalCommit": "63c089695709a51471b1a8771431e40da7773b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5NzEzMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r492997131", "bodyText": "Done, thanks.", "author": "stooke", "createdAt": "2020-09-22T19:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NDkyNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502384924", "bodyText": "This comment should be updated.", "author": "pejovica", "createdAt": "2020-10-09T12:13:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSubrecord.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/*\n+ * A CVSymbolSubrecord is a record in a DEBUG_S_SYMBOL record within a .debug$S section within a PECOFF file.\n+ */\n+abstract class CVSymbolSubrecord {\n+\n+    private int subrecordStartPosition;\n+\n+    private final short cmd;\n+    CVDebugInfo cvDebugInfo;\n+\n+    CVSymbolSubrecord(CVDebugInfo cvDebugInfo, short cmd) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cmd = cmd;\n+    }\n+\n+    final int computeFullContents(byte[] buffer, int initialPos) {\n+        subrecordStartPosition = initialPos;\n+        int pos = initialPos;\n+        pos += Short.BYTES; /* Save room for length (not including length bytes). */\n+        pos = CVUtil.putShort(cmd, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        short length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort(length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVSymbolSubrecord(pos=0x%06x cmd=0x%04x)\", subrecordStartPosition, cmd);\n+    }\n+\n+    public int getPos() {\n+        return subrecordStartPosition;\n+    }\n+\n+    public int getCommand() {\n+        return cmd;\n+    }\n+\n+    protected abstract int computeContents(byte[] buffer, int pos);\n+\n+    public static final class CVObjectNameRecord extends CVSymbolSubrecord {\n+\n+        String objName; /* find the full path to object file we will produce. */\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo, String objName) {\n+            super(cvDebugInfo, CVDebugConstants.S_OBJNAME);\n+            this.objName = objName;\n+        }\n+\n+        CVObjectNameRecord(CVDebugInfo cvDebugInfo) {\n+            this(cvDebugInfo, findObjectName(cvDebugInfo));\n+        }\n+\n+        private static String findObjectName(CVDebugInfo cvDebugInfo) {\n+            /* Infer object filename from first class definition. */\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    if (fn.endsWith(\".java\")) {\n+                        fn = fn.substring(0, fn.lastIndexOf(\".java\")) + \".obj\";\n+                    }\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        boolean isValid() {\n+            return objName != null;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(0, buffer, initialPos); /* Signature is currently set to 0. */\n+            pos = CVUtil.putUTF8StringBytes(objName, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_OBJNAME \" + objName;\n+        }\n+    }\n+\n+    public static final class CVCompile3Record extends CVSymbolSubrecord {\n+\n+        private static final byte HAS_DEBUG_FLAG = 0;\n+        @SuppressWarnings(\"unused\") private static final byte HAS_NO_DEBUG_FLAG = (byte) 0x80;\n+\n+        private byte language;\n+        private byte cf1;\n+        private byte cf2;\n+        private byte padding;\n+        private short machine;\n+        private short feMajor;\n+        private short feMinor;\n+        private short feBuild;\n+        private short feQFE;\n+        private short beMajor;\n+        private short beMinor;\n+        private short beBuild;\n+        private short beQFE;\n+        private String compiler;\n+\n+        CVCompile3Record(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_COMPILE3);\n+            language = 0;\n+            cf1 = HAS_DEBUG_FLAG;\n+            cf2 = (byte) 0;\n+            padding = (byte) 0;\n+            machine = (short) 208;\n+            feMajor = (short) 2;\n+            feMinor = (short) 3;\n+            feBuild = (short) 4;\n+            feQFE = (short) 5;\n+            beMajor = (short) 6;\n+            beMinor = (short) 7;\n+            beBuild = (short) 8;\n+            beQFE = (short) 9;\n+            compiler = \"graal\";\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putByte(language, buffer, initialPos);\n+            pos = CVUtil.putByte(cf1, buffer, pos);\n+            pos = CVUtil.putByte(cf2, buffer, pos);\n+            pos = CVUtil.putByte(padding, buffer, pos);\n+            pos = CVUtil.putShort(machine, buffer, pos);\n+            pos = CVUtil.putShort(feMajor, buffer, pos);\n+            pos = CVUtil.putShort(feMinor, buffer, pos);\n+            pos = CVUtil.putShort(feBuild, buffer, pos);\n+            pos = CVUtil.putShort(feQFE, buffer, pos);\n+            pos = CVUtil.putShort(beMajor, buffer, pos);\n+            pos = CVUtil.putShort(beMinor, buffer, pos);\n+            pos = CVUtil.putShort(beBuild, buffer, pos);\n+            pos = CVUtil.putShort(beQFE, buffer, pos);\n+            pos = CVUtil.putUTF8StringBytes(compiler, buffer, pos);  // inline null terminated\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"S_COMPILE3 machine=%d fe=%d.%d.%d.%d be=%d.%d.%d%d compiler=%s\", machine, feMajor, feMinor, feBuild, feQFE, beMajor, beMinor, beBuild, beQFE, compiler);\n+        }\n+    }\n+\n+    public static final class CVEnvBlockRecord extends CVSymbolSubrecord {\n+\n+        private static final int ENVMAP_INITIAL_CAPACITY = 10;\n+\n+        private Map<String, String> map = new HashMap<>(ENVMAP_INITIAL_CAPACITY);\n+\n+        /*-\n+         * Example contents of the environment block:\n+         *   cwd = C:\\tmp\\graal-8\n+         *   cl = C:\\tmp\\graal-8\\ojdkbuild\\tools\\toolchain\\vs2010e\\VC\\Bin\\x86_amd64\\cl.exe\n+         *   cmd = -Zi -MT -IC:\\tmp\\graal-8\\tools\\toolchain\\vs2010e\\VC\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE -IC:\\tmp\\graal-8\\tools\\toolchain\\sdk71\\INCLUDE\\gl -TC -X\n+         *   src = helloworld.java\n+         *   pdb = C:\\tmp\\graal-8\\vc100.pdb\n+         */\n+        CVEnvBlockRecord(CVDebugInfo cvDebugInfo) {\n+            super(cvDebugInfo, CVDebugConstants.S_ENVBLOCK);\n+\n+            /* Current directory. */\n+            map.put(\"cwd\", System.getProperty(\"user.dir\"));\n+\n+            /*\n+             * Define the primary source file - ideally, the source file containing main(). (Note\n+             * that if Graal were to be used to compile a library, there may not be a main()). Since\n+             * Graal doesn't work with java source files, use the source file associated with the\n+             * first class that has a source file.\n+             */\n+            String fn = findFirstFile(cvDebugInfo);\n+            if (fn != null) {\n+                map.put(\"src\", fn);\n+            }\n+        }\n+\n+        private static String findFirstFile(CVDebugInfo cvDebugInfo) {\n+            String fn = null;\n+            for (ClassEntry classEntry : cvDebugInfo.getPrimaryClasses()) {\n+                if (classEntry.getFileName() != null) {\n+                    fn = classEntry.getFileEntry().getFileName();\n+                    break;\n+                }\n+            }\n+            return fn;\n+        }\n+\n+        @Override\n+        protected int computeContents(byte[] buffer, int initialPos) {\n+            /* Flags. */\n+            int pos = CVUtil.putByte((byte) 0, buffer, initialPos);\n+\n+            /* Key/value pairs. */\n+            for (Map.Entry<String, String> entry : map.entrySet()) {\n+                pos = CVUtil.putUTF8StringBytes(entry.getKey(), buffer, pos);\n+                pos = CVUtil.putUTF8StringBytes(entry.getValue(), buffer, pos);\n+            }\n+\n+            /* End marker. */\n+            pos = CVUtil.putUTF8StringBytes(\"\", buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"S_ENVBLOCK \" + map.size() + \" entries\";\n+        }\n+    }\n+\n+    /*\n+     * Creating a proc32 record has side effects: a global symbol is added to the COFF symbol\n+     * section, and two relocation entries are added to the section relocation table, they refer\n+     * back to the global symbol.\n+     */", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkyNTU1NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503925554", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-13T12:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NDkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5MjI0Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502492243", "bodyText": "I don't think this is correct. What prevents two records of different types from having the same hash code?", "author": "pejovica", "createdAt": "2020-10-09T15:02:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    private int sequenceCounter = 0x1000;\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+    private Map<Integer, CVTypeRecord> typeMap = new HashMap<>();\n+\n+    CVTypeSectionImpl() {\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_TYPE_SECTION_NAME;\n+    }\n+\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() adding records\");\n+        addRecords();\n+        log(debugContext, \"CVTypeSectionImpl.createContent() start\");\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, null, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            pos = record.computeFullSize(pos);\n+        }\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVTypeSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVTypeSectionImpl.writeContent() start\");\n+        byte[] buffer = getContent();\n+        verboseLog(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        for (CVTypeRecord record : cvRecords) {\n+            verboseLog(debugContext, \"  [0x%08x] 0x%06x %s\", pos, record.getSequenceNumber(), record.toString());\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        verboseLog(debugContext, \"CVTypeSectionImpl.writeContent() end\");\n+    }\n+\n+    /**\n+     * Add all relevant type records to the type section.\n+     */\n+    private void addRecords() {\n+        /* if an external PDB file is generated, add CVTypeServer2Record */\n+        /* for each class, add all members, types, etc */\n+    }\n+\n+    /**\n+     * Add a record to the type section if it has a unique hash.\n+     *\n+     * @param <T> type of new record.\n+     * @param newRecord record to add\n+     * @return newRecord if the hash is unique, or the existing record already in the type table\n+     */\n+    <T extends CVTypeRecord> T addRecord(T newRecord) {\n+        return addOrReference(newRecord);\n+    }\n+\n+    /**\n+     * Add a record (that has a unique hashcode) to the type section.\n+     *\n+     * @param r the record to add\n+     */\n+    private void addUniqueRecord(CVTypeRecord r) {\n+        cvRecords.add(r);\n+    }\n+\n+    /**\n+     * Return either the caller-created instance or a matching existing instance. Every entry in\n+     * typeMap is a T, because it is ONLY this function which inserts entries (of type T).\n+     *\n+     * @param <T> type of new record\n+     * @param newRecord record to add if an existing record with same hash hasn't already been added\n+     * @return the record (if previously unseen) or old record\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private <T extends CVTypeRecord> T addOrReference(T newRecord) {\n+        final T record;\n+        final int hashCode = newRecord.hashCode();\n+        if (typeMap.containsKey(hashCode)) {\n+            record = (T) typeMap.get(hashCode);", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MjAyMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503982022", "bodyText": "I was holding this change off until the type information has been added in a follow-up PR.  Currently there are only two type records, (an empty arglist record and a \"void proc()\" record), so it makes no difference.\nI have added full equals() implementation to avoid this situation.  Note that my design must allow for two type records to differ in type index but still be considered the same.", "author": "stooke", "createdAt": "2020-10-13T14:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5MjI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTIxNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502591217", "bodyText": "This can be moved into computeHeader, i.e., it's no longer necessary to pass highAddr as an argument.\nAlso, you could change computeHeader to return pos and move the call to the beginning of this method.", "author": "pejovica", "createdAt": "2020-10-09T18:01:42Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* has colummns flag = 0x80 - not supported */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private void computeHeader(byte[] buffer, int initialPos, int length) {\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putInt(0, buffer, pos);\n+\n+        if (buffer != null) {\n+            cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        }\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos); /* flags */\n+        CVUtil.putInt(length, buffer, pos);\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int highAddr = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA1MDUzMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r504050531", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-13T15:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYxODM2OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502618368", "bodyText": "I'd change this check to an assertion, e.g.:\nassert !s.contains(\"\\0\");\nPlus, then you could simply delegate to putBytes.", "author": "pejovica", "createdAt": "2020-10-09T18:58:15Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.io.Utf8;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+abstract class CVUtil {\n+\n+    static int putByte(byte b, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Byte.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = b;\n+        return pos;\n+    }\n+\n+    static int putShort(short s, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Short.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (s & 0xff);\n+        buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putInt(int i, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Integer.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (i & 0xff);\n+        buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+        return pos;\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    static int putLong(long l, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Long.BYTES;\n+        }\n+        int pos = initialPos;\n+        buffer[pos++] = (byte) (l & 0xff);\n+        buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+        buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+        return pos;\n+    }\n+\n+    static int putBytes(byte[] inbuff, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + inbuff.length;\n+        }\n+        int pos = initialPos;\n+        for (byte b : inbuff) {\n+            buffer[pos++] = b;\n+        }\n+        return pos;\n+    }\n+\n+    static int putUTF8StringBytes(String s, byte[] buffer, int initialPos) {\n+        if (buffer == null) {\n+            return initialPos + Utf8.utf8Length(s) + 1;\n+        }\n+        byte[] buff = s.getBytes(UTF_8);\n+        int pos = initialPos;\n+        for (byte b : buff) {\n+            if (b == 0) {\n+                throw new RuntimeException(\"oops : string has internal NULL character! \" + s);\n+            }", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkzMzAzNA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503933034", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-13T13:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYxODM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4MDgzMg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502780832", "bodyText": "In case you apply the changes from the following comment, I'd remove this check in favor of the one in processRange.", "author": "pejovica", "createdAt": "2020-10-10T11:33:46Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * If this is a different file, then update the length of the previous file header, write the\n+ * new file header and write the new range At the very end, make sure we update the last file header.\n+ */\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry) {\n+        this.primaryEntry = entry;\n+        Range primaryRange = primaryEntry.getPrimary();\n+\n+        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n+        debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n+        Range previousRange = processRange(primaryRange, null);\n+\n+        for (Range subRange : primaryEntry.getSubranges()) {\n+            debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n+            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n+            if (subFileEntry == null) {\n+                continue;\n+            }", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk0MzA0MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r503943041", "bodyText": "Done and done.", "author": "stooke", "createdAt": "2020-10-13T13:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4MDgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502785103", "bodyText": "What do you think about CVLineRecord deciding if we need a new file?\nIt already contains the necessary data, so adding a method (e.g., maybeAddNewFile) that would add a new file and return true only if the new fileId differs from the fileId of the current FileBlock should be easy.\nThat would allow this method to be simplified as follows (and you could also completely remove previousRange processing).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    Range previousRange = oldPreviousRange;\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"     processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return previousRange;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    /* Is this a new file? if so emit a new file record. */\n          \n          \n            \n                    boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n          \n          \n            \n                    if (wantNewFile) {\n          \n          \n            \n                        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                        if (file != null && file.getFileName() != null) {\n          \n          \n            \n                            debug(\"processRange: addNewFile: %s\\n\", file);\n          \n          \n            \n                            lineRecord.addNewFile(file);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                            return previousRange;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                    if (file == null) {\n          \n          \n            \n                        debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (lineRecord.maybeAddNewFile(file)) {\n          \n          \n            \n                        debug(\"processRange: added new file: %s\\n\", file);\n          \n          \n            \n                    }", "author": "pejovica", "createdAt": "2020-10-10T12:23:37Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecordBuilder.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.Range;\n+\n+/*\n+ * In CV4, the line table consists of a series of file headers followed by line number entries.\n+ * If this is a different file, then update the length of the previous file header, write the\n+ * new file header and write the new range At the very end, make sure we update the last file header.\n+ */\n+public class CVLineRecordBuilder {\n+\n+    private CVDebugInfo cvDebugInfo;\n+    private DebugContext debugContext;\n+    private CVLineRecord lineRecord;\n+    private PrimaryEntry primaryEntry;\n+\n+    CVLineRecordBuilder(DebugContext theDebugContext, CVDebugInfo cvDebugInfo) {\n+        this.debugContext = theDebugContext;\n+        this.cvDebugInfo = cvDebugInfo;\n+    }\n+\n+    public void debug(String format, Object... args) {\n+        cvDebugInfo.getCVSymbolSection().verboseLog(debugContext, format, args);\n+    }\n+\n+    /**\n+     * Build line number records for a function.\n+     *\n+     * @param entry function to build line number table for\n+     * @return CVLineRecord containing any entries generated, or null if no entries generated\n+     */\n+    CVLineRecord build(PrimaryEntry entry) {\n+        this.primaryEntry = entry;\n+        Range primaryRange = primaryEntry.getPrimary();\n+\n+        debug(\"DEBUG_S_LINES linerecord for 0x%05x file: %s:%d\\n\", primaryRange.getLo(), primaryRange.getFileName(), primaryRange.getLine());\n+        this.lineRecord = new CVLineRecord(cvDebugInfo, primaryRange.getSymbolName());\n+        debug(\"CVLineRecord.computeContents: processing primary range %s\\n\", primaryRange);\n+        Range previousRange = processRange(primaryRange, null);\n+\n+        for (Range subRange : primaryEntry.getSubranges()) {\n+            debug(\"CVLineRecord.computeContents: processing range %s\\n\", subRange);\n+            FileEntry subFileEntry = primaryEntry.getSubrangeFileEntry(subRange);\n+            if (subFileEntry == null) {\n+                continue;\n+            }\n+            previousRange = processRange(subRange, previousRange);\n+        }\n+        return lineRecord;\n+    }\n+\n+    /**\n+     * Merge input Range structures into line number table. The Range structures are assumed to be\n+     * ordered by ascending address.\n+     *\n+     * @param range to be merged or added to line number record\n+     * @param oldPreviousRange the previously processed Range\n+     * @return new value for previousRange in caller\n+     */\n+    private Range processRange(Range range, Range oldPreviousRange) {\n+\n+        Range previousRange = oldPreviousRange;\n+\n+        if (range.getLine() == -1) {\n+            debug(\"     processRange: ignoring: bad line number\\n\");\n+            return previousRange;\n+        }\n+\n+        /* Is this a new file? if so emit a new file record. */\n+        boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n+        if (wantNewFile) {\n+            FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n+            if (file != null && file.getFileName() != null) {\n+                debug(\"processRange: addNewFile: %s\\n\", file);\n+                lineRecord.addNewFile(file);\n+            } else {\n+                debug(\"processRange: range has no file: %s\\n\", range);\n+                return previousRange;\n+            }\n+        }", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDExNjk4MQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r504116981", "bodyText": "I'd rather not to this at this time, for a couple of reasons.  First, I'd like to keep all the decisions in the builder, and have the LineRecord class be dumb.  Secondly, I hope to provide a separate PR that reworks this code to (optionally) skip over Graal intrinsics.  In an IDE like Visudal Studio, the constant flipping between source files can be very distracting.", "author": "stooke", "createdAt": "2020-10-13T17:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2OTk0Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r506269943", "bodyText": "I understand that there will be more changes in this code, but at the moment it seems too complicated for what it actually does. In particular, managing previousRange seems completely unnecessary given that CVLineRecord already keeps track of that.\nAs for the first point, let's keep all the logic in the builder then. Assuming that getCurrentFileId returns fileId of the current FileBlock, and that addNewFile is simplified to accept fileId (should resemble addNewLine), how about something like this?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    Range previousRange = oldPreviousRange;\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"     processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return previousRange;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    /* Is this a new file? if so emit a new file record. */\n          \n          \n            \n                    boolean wantNewFile = previousRange == null || !previousRange.getFileAsPath().equals(range.getFileAsPath());\n          \n          \n            \n                    if (wantNewFile) {\n          \n          \n            \n                        FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                        if (file != null && file.getFileName() != null) {\n          \n          \n            \n                            debug(\"processRange: addNewFile: %s\\n\", file);\n          \n          \n            \n                            lineRecord.addNewFile(file);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                            return previousRange;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    FileEntry file = cvDebugInfo.findFile(range.getFileAsPath());\n          \n          \n            \n                    if (file == null) {\n          \n          \n            \n                        debug(\"processRange: range has no file: %s\\n\", range);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (range.getLine() == -1) {\n          \n          \n            \n                        debug(\"processRange: ignoring: bad line number\\n\");\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    int fileId = cvDebugInfo.getCVSymbolSection().getFileTableRecord().addFile(file);\n          \n          \n            \n                    if (lineRecord.isEmpty() || lineRecord.getCurrentFileId() != fileId) {\n          \n          \n            \n                        debug(\"processRange: addNewFile: %s\\n\", file);\n          \n          \n            \n                        lineRecord.addNewFile(fileId);\n          \n          \n            \n                    }", "author": "pejovica", "createdAt": "2020-10-16T10:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3NTI1MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510275250", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T15:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc4NTEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgwNTQzMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r502805431", "bodyText": "This is more of an observation, and while I think it would be good to address this, it\u2019s okay to do it in a follow-up PR as well.\nI find that CVStringTable and CVFileTable are conceptually similar enough that their implementations and use in code should follow similar patterns. However, this is not the case at the moment.\nCVStringTable is a separate class that is passed around directly, and CVStringTableRecord is merely a wrapper. On the other hand, CVFileTableRecord is both a table and a record (there is no separate class CVFileTable), which is accessed via CVDebugInfo. In principle, I don't mind either approach, but what I don't like is that we have both.", "author": "pejovica", "createdAt": "2020-10-10T16:05:12Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVSymbolSectionImpl.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import com.oracle.objectfile.io.Utf8;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+public final class CVSymbolSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_VECTOR_DEFAULT_SIZE = 200;\n+    private static final int CV_STRINGTABLE_DEFAULT_SIZE = 200;\n+\n+    private final CVDebugInfo cvDebugInfo;\n+    private final ArrayList<CVSymbolRecord> cvRecords;\n+    private final CVStringTable stringTable;\n+    private final CVFileTableRecord fileTableRecord;\n+\n+    CVSymbolSectionImpl(CVDebugInfo cvDebugInfo) {\n+        this.cvDebugInfo = cvDebugInfo;\n+        this.cvRecords = new ArrayList<>(CV_VECTOR_DEFAULT_SIZE);\n+        this.stringTable = new CVStringTable(CV_STRINGTABLE_DEFAULT_SIZE);\n+        this.fileTableRecord = new CVFileTableRecord(cvDebugInfo, stringTable);\n+    }\n+\n+    @Override\n+    public String getSectionName() {\n+        return CV_SYMBOL_SECTION_NAME;\n+    }\n+\n+    /*\n+     * Any (there may be sewveral) CodeView symbol section (\"debug$S\") is actually a list of\n+     * records, some of which containing sub-records.\n+     */\n+    @Override\n+    public void createContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() adding records\");\n+        addRecords(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() start\");\n+        /* Add header size. */\n+        pos += Integer.BYTES;\n+        /* Add sum of all record sizes. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            pos = record.computeFullSize(pos);\n+        }\n+        /* Create a buffer that holds it all. */\n+        byte[] buffer = new byte[pos];\n+        super.setContent(buffer);\n+        log(debugContext, \"CVSymbolSectionImpl.createContent() end\");\n+    }\n+\n+    @Override\n+    public void writeContent(DebugContext debugContext) {\n+        int pos = 0;\n+        enableLog(debugContext);\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() start recordcount=%d\", cvRecords.size());\n+        byte[] buffer = getContent();\n+        /* Write section header. */\n+        log(debugContext, \"  [0x%08x] CV_SIGNATURE_C13\", pos);\n+        pos = CVUtil.putInt(CV_SIGNATURE_C13, buffer, pos);\n+        /* Write all records. */\n+        for (CVSymbolRecord record : cvRecords) {\n+            pos = CVUtil.align4(pos);\n+            log(debugContext, \"  [0x%08x] %s\", pos, record.toString());\n+            record.logContents(debugContext);\n+            pos = record.computeFullContents(buffer, pos);\n+        }\n+        log(debugContext, \"CVSymbolSectionImpl.writeContent() end\");\n+    }\n+\n+    private void addRecords(DebugContext debugContext) {\n+        addPrologueRecord();\n+        addFunctionRecords(debugContext);\n+        addFileRecord();\n+        addStringTableRecord();\n+    }\n+\n+    private void addPrologueRecord() {\n+        CVSymbolSubsection prologue = new CVSymbolSubsection(cvDebugInfo);\n+        CVSymbolSubrecord.CVObjectNameRecord objectNameRecord = new CVSymbolSubrecord.CVObjectNameRecord(cvDebugInfo);\n+        if (objectNameRecord.isValid()) {\n+            prologue.addRecord(objectNameRecord);\n+        }\n+        prologue.addRecord(new CVSymbolSubrecord.CVCompile3Record(cvDebugInfo));\n+        prologue.addRecord(new CVSymbolSubrecord.CVEnvBlockRecord(cvDebugInfo));\n+        addRecord(prologue);\n+    }\n+\n+    private void addFunctionRecords(DebugContext debugContext) {\n+        /* This will build and add many records for each function. */\n+        new CVSymbolSubsectionBuilder(cvDebugInfo).build(debugContext);\n+    }\n+\n+    private void addFileRecord() {\n+        /* Files are added to this record during function record building. */\n+        addRecord(fileTableRecord);\n+    }\n+\n+    CVFileTableRecord getFileTableRecord() {\n+        return this.fileTableRecord;\n+    }\n+\n+    private void addStringTableRecord() {\n+        CVSymbolRecord stringTableRecord = new CVStringTableRecord(cvDebugInfo, stringTable);\n+        addRecord(stringTableRecord);\n+    }\n+\n+    static final class CVStringTable {", "originalCommit": "ab2c9a00f48883b83383fd411956082da9f0ac28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0MDE5OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r504040198", "bodyText": "There's also the StringTable in the debugentry package.  I'd leave this to a separate PR.", "author": "stooke", "createdAt": "2020-10-13T15:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgwNTQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1ODM5Ng==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505558396", "bodyText": "To avoid code duplication, I'd move the comments to computeContents and replace this with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* Line record header. */\n          \n          \n            \n                    int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n          \n          \n            \n                    /* All blocks. */\n          \n          \n            \n                    for (FileBlock fileBlock : fileBlocks) {\n          \n          \n            \n                        pos = fileBlock.computeSize(pos);\n          \n          \n            \n                    }\n          \n          \n            \n                    return pos;\n          \n          \n            \n                    return computeContents(null, initialPos);", "author": "pejovica", "createdAt": "2020-10-15T13:50:18Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has colummns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI0NzM2NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510247364", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T15:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1ODM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU2OTk0OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505569948", "bodyText": "And I'd modify this so that it can optimally compute the size as well.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int computeContents(byte[] buffer, int initialPos) {\n          \n          \n            \n                    int computeContents(byte[] buffer, int initialPos) {\n          \n          \n            \n                        if (buffer == null) {\n          \n          \n            \n                            return computeSize(initialPos);\n          \n          \n            \n                        }", "author": "pejovica", "createdAt": "2020-10-15T14:04:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has colummns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int length = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + computeHeader(buffer, initialPos);\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1NDA5OQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510254099", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-22T15:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU2OTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwMDMwMQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505600301", "bodyText": "You have an extra initialPos here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int pos = initialPos + computeHeader(buffer, initialPos);\n          \n          \n            \n                    int pos = computeHeader(buffer, initialPos);", "author": "pejovica", "createdAt": "2020-10-15T14:43:08Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has colummns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(FileEntry file) {\n+        CVFileTableRecord fr = cvDebugInfo.getCVSymbolSection().getFileTableRecord();\n+        int fileId = fr.addFile(file);\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        /* Line record header. */\n+        int pos = initialPos + LINE_RECORD_HEADER_SIZE;\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeSize(pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int length = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + computeHeader(buffer, initialPos);", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5MDgzNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r507990837", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T18:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwMDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMzk5OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505623998", "bodyText": "Perhaps a LinkedHashMap would be a better fit here as it would allow you to remove cvRecords and consolidate the related add* methods.", "author": "pejovica", "createdAt": "2020-10-15T15:11:40Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeSectionImpl.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.pecoff.PECoffObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SIGNATURE_C13;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_SYMBOL_SECTION_NAME;\n+import static com.oracle.objectfile.pecoff.cv.CVConstants.CV_TYPE_SECTION_NAME;\n+\n+public final class CVTypeSectionImpl extends CVSectionImpl {\n+\n+    private static final int CV_RECORD_INITIAL_CAPACITY = 200;\n+\n+    /* CodeView 4 type records below 1000 are pre-defined. */\n+    private int sequenceCounter = 0x1000;\n+\n+    /* A sequential list of type records, starting at 1000 */\n+    private ArrayList<CVTypeRecord> cvRecords = new ArrayList<>(CV_RECORD_INITIAL_CAPACITY);\n+\n+    /* A map to ensure we can efficiently find and reuse records. */\n+    private Map<CVTypeRecord, CVTypeRecord> typeMap = new HashMap<>();", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2NTgzOA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510165838", "bodyText": "Good idea.  Done.", "author": "stooke", "createdAt": "2020-10-22T13:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMzk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMDU0OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505710548", "bodyText": "I don't think this cast is safe without first checking if super.equals(obj) is true.", "author": "pejovica", "createdAt": "2020-10-15T17:18:33Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* Save room for length and leaf type. */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + Short.BYTES; /* Save room for length short. */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* Length does not include record length (2 bytes)) but does include end padding. */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || obj.getClass() != this.getClass()) {\n+            return false;\n+        }\n+        return this.type == ((CVTypeRecord)obj).type;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            /* callType and funcAttr are always zero so do not add them to the hash */\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord)obj;", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5MTMwNw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r507991307", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T18:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMDU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMTA5NA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505711094", "bodyText": "Same for this cast.", "author": "pejovica", "createdAt": "2020-10-15T17:19:27Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* Save room for length and leaf type. */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + Short.BYTES; /* Save room for length short. */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* Length does not include record length (2 bytes)) but does include end padding. */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || obj.getClass() != this.getClass()) {\n+            return false;\n+        }\n+        return this.type == ((CVTypeRecord)obj).type;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            /* callType and funcAttr are always zero so do not add them to the hash */\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord)obj;\n+            return super.equals(obj) && this.returnType == other.returnType && this.argList == other.argList;\n+        }\n+    }\n+\n+    static final class CVTypeArglistRecord extends CVTypeRecord {\n+\n+        ArrayList<Integer> args = new ArrayList<>();\n+\n+        CVTypeArglistRecord() {\n+            super(LF_ARGLIST);\n+        }\n+\n+        CVTypeArglistRecord add(int argType) {\n+            args.add(argType);\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Integer.BYTES * args.size();\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(args.size(), buffer, initialPos);\n+            for (Integer at : args) {\n+                pos = CVUtil.putInt(at, buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int getSize() {\n+            return args.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder s = new StringBuilder(String.format(\"LF_ARGLIST 0x%04x [\", getSequenceNumber()));\n+            for (Integer at : args) {\n+                s.append(String.format(\" 0x%04x\", at));\n+            }\n+            s.append(\"])\");\n+            return s.toString();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = h * 31 + args.size();\n+            for (Integer r : args) {\n+                h = 31 * h + r.hashCode();\n+            }\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeArglistRecord other = (CVTypeArglistRecord)obj;", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5MTQzOQ==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r507991439", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T18:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNTg1Mg==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r505715852", "bodyText": "Why didn't you use args.hashCode here?", "author": "pejovica", "createdAt": "2020-10-15T17:27:44Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVTypeRecord.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import java.util.ArrayList;\n+\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_ARGLIST;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD1;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD2;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PAD3;\n+import static com.oracle.objectfile.pecoff.cv.CVTypeConstants.LF_PROCEDURE;\n+\n+/*\n+ * CV Type Record format (little-endian):\n+ * uint16 length\n+ * uint16 leaf (a.k.a. record type)\n+ * (contents)\n+ */\n+abstract class CVTypeRecord {\n+\n+    protected final short type;\n+    private int startPosition;\n+    private int sequenceNumber; /* CodeView type records are numbered 1000 on up. */\n+\n+    CVTypeRecord(short type) {\n+        this.type = type;\n+        this.startPosition = -1;\n+        this.sequenceNumber = -1;\n+    }\n+\n+    int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+\n+    int computeFullSize(int initialPos) {\n+        this.startPosition = initialPos;\n+        int pos = initialPos + Short.BYTES * 2; /* Save room for length and leaf type. */\n+        pos = computeSize(pos);\n+        pos = alignPadded4(null, pos);\n+        return pos;\n+    }\n+\n+    int computeFullContents(byte[] buffer, int initialPos) {\n+        int pos = initialPos + Short.BYTES; /* Save room for length short. */\n+        pos = CVUtil.putShort(type, buffer, pos);\n+        pos = computeContents(buffer, pos);\n+        /* Length does not include record length (2 bytes)) but does include end padding. */\n+        pos = alignPadded4(buffer, pos);\n+        int length = (short) (pos - initialPos - Short.BYTES);\n+        CVUtil.putShort((short) length, buffer, initialPos);\n+        return pos;\n+    }\n+\n+    protected abstract int computeSize(int initialPos);\n+\n+    protected abstract int computeContents(byte[] buffer, int initialPos);\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || obj.getClass() != this.getClass()) {\n+            return false;\n+        }\n+        return this.type == ((CVTypeRecord)obj).type;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVTypeRecord seq=0x%04x type=0x%04x pos=0x%04x \", sequenceNumber, type, startPosition);\n+    }\n+\n+    private static int alignPadded4(byte[] buffer, int originalpos) {\n+        int pos = originalpos;\n+        int align = pos & 3;\n+        if (align == 1) {\n+            byte[] p3 = {LF_PAD3, LF_PAD2, LF_PAD1};\n+            pos = CVUtil.putBytes(p3, buffer, pos);\n+        } else if (align == 2) {\n+            pos = CVUtil.putByte(LF_PAD2, buffer, pos);\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        } else if (align == 3) {\n+            pos = CVUtil.putByte(LF_PAD1, buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    static final class CVTypeProcedureRecord extends CVTypeRecord {\n+\n+        int returnType = -1;\n+        CVTypeArglistRecord argList = null;\n+\n+        CVTypeProcedureRecord() {\n+            super(LF_PROCEDURE);\n+        }\n+\n+        public CVTypeProcedureRecord returnType(int leaf) {\n+            this.returnType = leaf;\n+            return this;\n+        }\n+\n+        public CVTypeProcedureRecord returnType(CVTypeRecord leaf) {\n+            this.returnType = leaf.getSequenceNumber();\n+            return this;\n+        }\n+\n+        CVTypeProcedureRecord argList(CVTypeArglistRecord leaf) {\n+            this.argList = leaf;\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return computeContents(null, initialPos);\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(returnType, buffer, initialPos);\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* callType */\n+            pos = CVUtil.putByte((byte) 0, buffer, pos); /* funcAttr */\n+            pos = CVUtil.putShort((short) argList.getSize(), buffer, pos);\n+            pos = CVUtil.putInt(argList.getSequenceNumber(), buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LF_PROCEDURE 0x%04x ret=0x%04x arg=0x%04x \", getSequenceNumber(), returnType, argList.getSequenceNumber());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = 31 * h + returnType;\n+            h = 31 * h + argList.hashCode();\n+            /* callType and funcAttr are always zero so do not add them to the hash */\n+            return h;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            CVTypeProcedureRecord other = (CVTypeProcedureRecord)obj;\n+            return super.equals(obj) && this.returnType == other.returnType && this.argList == other.argList;\n+        }\n+    }\n+\n+    static final class CVTypeArglistRecord extends CVTypeRecord {\n+\n+        ArrayList<Integer> args = new ArrayList<>();\n+\n+        CVTypeArglistRecord() {\n+            super(LF_ARGLIST);\n+        }\n+\n+        CVTypeArglistRecord add(int argType) {\n+            args.add(argType);\n+            return this;\n+        }\n+\n+        @Override\n+        public int computeSize(int initialPos) {\n+            return initialPos + Integer.BYTES + Integer.BYTES * args.size();\n+        }\n+\n+        @Override\n+        public int computeContents(byte[] buffer, int initialPos) {\n+            int pos = CVUtil.putInt(args.size(), buffer, initialPos);\n+            for (Integer at : args) {\n+                pos = CVUtil.putInt(at, buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int getSize() {\n+            return args.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder s = new StringBuilder(String.format(\"LF_ARGLIST 0x%04x [\", getSequenceNumber()));\n+            for (Integer at : args) {\n+                s.append(String.format(\" 0x%04x\", at));\n+            }\n+            s.append(\"])\");\n+            return s.toString();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = type;\n+            h = h * 31 + args.size();\n+            for (Integer r : args) {\n+                h = 31 * h + r.hashCode();\n+            }", "originalCommit": "332525ad8af0236272ef3d88bd757b69c8fea09b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA0OTQ5Mw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r508049493", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-19T20:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1NjE2MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510456160", "bodyText": "Since the builder already ensures that this is only called if fileBlocks is not empty, this is not a problem at the moment, but I think that 0 may not be the best choice because it is a valid fileId.\nPerhaps it would be better to simply assert here that fileBlocks is not empty and expect the caller to take care of it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).fileId;\n          \n          \n            \n                    assert !fileBlocks.isEmpty();\n          \n          \n            \n                    return fileBlocks.get(fileBlocks.size() - 1).fileId;", "author": "pejovica", "createdAt": "2020-10-22T21:04:30Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has columns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(int fileId) {\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    int getCurrentFileId() {\n+        return fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).fileId;", "originalCommit": "79594415eb46dc9a9729d50486c7f8d8f1d0e61c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDgzMjY0MA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510832640", "bodyText": "Done.", "author": "stooke", "createdAt": "2020-10-23T11:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1NjE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NTM2Nw==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510465367", "bodyText": "Similarly here. Since the builder already ensures that lineEntries is not empty, it's not a problem at the moment, but I think 0 would be the wrong value if only the last file block was empty.\nSo, again, it might be better to simply assert here that lineEntries is not empty and expect the caller to take care of it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return lineEntries.isEmpty() ? 0 : lineEntries.get(lineEntries.size() - 1).addr;\n          \n          \n            \n                        assert !lineEntries.isEmpty();\n          \n          \n            \n                        return lineEntries.get(lineEntries.size() - 1).addr;", "author": "pejovica", "createdAt": "2020-10-22T21:22:11Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/pecoff/cv/CVLineRecord.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.pecoff.cv;\n+\n+import com.oracle.objectfile.ObjectFile;\n+\n+import java.util.ArrayList;\n+\n+/*\n+ * A line record (DEBUG_S_LINES) consists of a list of (file block record + subrecords).\n+ * Graal will generate one CVLineRecord per function.\n+ */\n+final class CVLineRecord extends CVSymbolRecord {\n+\n+    /* Header: addr (4 bytes):section (2 bytes) flags (2 bytes) chunck length (4 bytes). */\n+    private static final int LINE_RECORD_HEADER_SIZE = Integer.BYTES + Short.BYTES * 2 + Integer.BYTES;\n+\n+    private static final int DEFAULT_LINE_BLOCK_COUNT = 100;\n+    private static final int DEFAULT_LINE_ENTRY_COUNT = 100;\n+\n+    /* Has columns flag = 0x80 - not supported. */\n+    private static final short CB_HAS_NO_COLUMNS_FLAG = 0x00;\n+\n+    private String symbolName;\n+    private ArrayList<FileBlock> fileBlocks = new ArrayList<>(DEFAULT_LINE_BLOCK_COUNT);\n+\n+    CVLineRecord(CVDebugInfo cvDebugInfo, String symbolName) {\n+        super(cvDebugInfo, CVDebugConstants.DEBUG_S_LINES);\n+        this.symbolName = symbolName;\n+    }\n+\n+    void addNewFile(int fileId) {\n+        fileBlocks.add(new FileBlock(fileId));\n+    }\n+\n+    void addNewLine(int addr, int line) {\n+        fileBlocks.get(fileBlocks.size() - 1).addEntry(new LineEntry(addr, line));\n+    }\n+\n+    int getCurrentFileId() {\n+        return fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).fileId;\n+    }\n+\n+    @Override\n+    protected int computeSize(int initialPos) {\n+        return computeContents(null, initialPos);\n+    }\n+\n+    @Override\n+    protected int computeContents(byte[] buffer, int initialPos) {\n+        /* Line record header. */\n+        int pos = computeHeader(buffer, initialPos);\n+        /* All blocks. */\n+        for (FileBlock fileBlock : fileBlocks) {\n+            pos = fileBlock.computeContents(buffer, pos);\n+        }\n+        return pos;\n+    }\n+\n+    private int computeHeader(byte[] buffer, int initialPos) {\n+\n+        if (buffer == null) {\n+            return initialPos + LINE_RECORD_HEADER_SIZE;\n+        }\n+\n+        assert symbolName != null;\n+        int pos = initialPos;\n+\n+        /* Emit addr:section relocation records. */\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECREL_4, symbolName, false, 1L);\n+        pos = CVUtil.putInt(0, buffer, pos);\n+        cvDebugInfo.getCVSymbolSection().markRelocationSite(pos, ObjectFile.RelocationKind.SECTION_2, symbolName, false, 1L);\n+        pos = CVUtil.putShort((short) 0, buffer, pos);\n+\n+        /* Emit flags. */\n+        pos = CVUtil.putShort(CB_HAS_NO_COLUMNS_FLAG, buffer, pos);\n+\n+        /* Length of this chunk in object file (= highAddr since it's zero based. */\n+        int length = fileBlocks.isEmpty() ? 0 : fileBlocks.get(fileBlocks.size() - 1).getHighAddr();\n+        pos = CVUtil.putInt(length, buffer, pos);\n+        return pos;\n+    }\n+\n+    boolean isEmpty() {\n+        return fileBlocks.isEmpty();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"CVLineRecord(type=0x%04x pos=0x%05x size=0x%d)\", type, recordStartPosition, fileBlocks.size());\n+    }\n+\n+    /*\n+     * FileBlock is a section of contiguous code in a compilation unit, associated with a single\n+     * source file. If a function includes inlined code, that code needs its own FileBlock,\n+     * surrounded by FileBlocks describing the enclosing source file. A FileBlock consists of a list\n+     * of LineEntries.\n+     */\n+    private static class FileBlock {\n+\n+        /* Fileblock header: fileId (4 bytes) lineEntry count (4 bytes) tablesize (4 bytes) */\n+        static final int FILE_BLOCK_HEADER_SIZE = Integer.BYTES * 3;\n+\n+        private ArrayList<LineEntry> lineEntries = new ArrayList<>(DEFAULT_LINE_ENTRY_COUNT);\n+        private int fileId;\n+\n+        FileBlock(int fileId) {\n+            this.fileId = fileId;\n+        }\n+\n+        void addEntry(LineEntry le) {\n+            lineEntries.add(le);\n+        }\n+\n+        int computeContents(byte[] buffer, int initialPos) {\n+            if (buffer == null) {\n+                return computeSize(initialPos);\n+            }\n+            int pos = initialPos;\n+            pos = CVUtil.putInt(fileId, buffer, pos);\n+            pos = CVUtil.putInt(lineEntries.size(), buffer, pos);\n+            pos = CVUtil.putInt(computeSize(0), buffer, pos);\n+            for (LineEntry lineEntry : lineEntries) {\n+                pos = lineEntry.computeContents(buffer, pos);\n+            }\n+            return pos;\n+        }\n+\n+        int computeSize(int initialPos) {\n+            return initialPos + FILE_BLOCK_HEADER_SIZE + LineEntry.LINE_ENTRY_SIZE * lineEntries.size();\n+        }\n+\n+        int getHighAddr() {\n+            return lineEntries.isEmpty() ? 0 : lineEntries.get(lineEntries.size() - 1).addr;", "originalCommit": "79594415eb46dc9a9729d50486c7f8d8f1d0e61c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDgzOTE0OA==", "url": "https://github.com/oracle/graal/pull/2396#discussion_r510839148", "bodyText": "Done. (and another assert at line 104).", "author": "stooke", "createdAt": "2020-10-23T12:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NTM2Nw=="}], "type": "inlineReview"}, {"oid": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "url": "https://github.com/oracle/graal/commit/f50a7b99b286efa7c5dafccc49b5c4add62af841", "message": "Add Windows PE/COFF debug information prototype", "committedDate": "2020-10-23T15:29:44Z", "type": "commit"}, {"oid": "f50a7b99b286efa7c5dafccc49b5c4add62af841", "url": "https://github.com/oracle/graal/commit/f50a7b99b286efa7c5dafccc49b5c4add62af841", "message": "Add Windows PE/COFF debug information prototype", "committedDate": "2020-10-23T15:29:44Z", "type": "forcePushed"}]}