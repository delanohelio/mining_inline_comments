{"pr_number": 2945, "pr_title": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "pr_createdAt": "2020-10-27T21:11:05Z", "pr_url": "https://github.com/oracle/graal/pull/2945", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzNjAwNg==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r513036006", "bodyText": "This and getEntryPoint are final in vanilla openjdk11", "author": "zakkak", "createdAt": "2020-10-27T21:13:20Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedCodeInstallBridge.java", "diffHunk": "@@ -59,16 +59,6 @@ public IsolatedCodeInstallBridge(ClientHandle<? extends SubstrateInstalledCode.A\n     private static final String DO_NOT_CALL_REASON = IsolatedCodeInstallBridge.class.getSimpleName() +\n                     \" only acts as an accessor for cross-isolate data. None of the implemented methods may be called.\";\n \n-    @Override\n-    public long getAddress() {", "originalCommit": "a75bea48ba1ecddf5e2e3ece06ead4e72bb5d7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzNjg0NA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r513036844", "bodyText": "This is still an early version to get some feedback. Error checking will be improved once we agree on the core changes.", "author": "zakkak", "createdAt": "2020-10-27T21:14:49Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +54,63 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();", "originalCommit": "a75bea48ba1ecddf5e2e3ece06ead4e72bb5d7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzNzMzNA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r513037334", "bodyText": "Proxy and reflection accessors will eventually be cached in static variables as requested in #2933 (comment)", "author": "zakkak", "createdAt": "2020-10-27T21:15:45Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +54,63 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private byte[] getByteArray(SpeculationReason reason) {\n+        byte[] bytes = null;\n+        if (reason instanceof UnencodedSpeculationReason) {\n+            Object encoding = ((UnencodedSpeculationReason) reason).encode();\n+            assert encoding instanceof IsolatedSpeculationReasonEncoding;\n+            bytes = ((IsolatedSpeculationReasonEncoding) encoding).getByteArray();\n+        } else {\n+            try {\n+                Class<?> speculationReasonEncodingClass = Class.forName(\"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\");\n+                final Object speculationReasonEncodingProxy = Proxy.newProxyInstance(speculationReasonEncodingClass.getClassLoader(),", "originalCommit": "a75bea48ba1ecddf5e2e3ece06ead4e72bb5d7e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxNjI3OA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519816278", "bodyText": "Please do cache the proxy class Proxy.newProxyInstance(...).getClass() in a static final field. Reflection accessors do not need to be cached as long as its arguments are compile-time constants.", "author": "peter-hofer", "createdAt": "2020-11-09T13:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzNzMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODQzNw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r513038437", "bodyText": "I am not sure about this. Please make sure to review thoroughly.", "author": "zakkak", "createdAt": "2020-10-27T21:18:04Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +54,63 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();", "originalCommit": "a75bea48ba1ecddf5e2e3ece06ead4e72bb5d7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAzODk2Mw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r513038963", "bodyText": "SVM code should not be referenced in non-SVM projects.", "author": "dougxc", "createdAt": "2020-10-27T21:19:13Z", "path": "compiler/src/org.graalvm.compiler.serviceprovider/src/org/graalvm/compiler/serviceprovider/UnencodedSpeculationReason.java", "diffHunk": "@@ -60,4 +66,66 @@ public int hashCode() {\n     public String toString() {\n         return String.format(\"%s@%d%s\", groupName, groupId, Arrays.toString(context));\n     }\n+\n+    /** Adapted from {@code jdk.vm.ci.meta.EncodedSpeculationReason#encode}. */\n+    public Object encode() {\n+        if (encoding == null) {\n+            try {\n+                Class<?> c = Class.forName(\"com.oracle.svm.graal.isolated.IsolatedSpeculationReasonEncoding\");", "originalCommit": "a75bea48ba1ecddf5e2e3ece06ead4e72bb5d7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c215690bf8832fcf3f1aca997c457fad99029282", "url": "https://github.com/oracle/graal/commit/c215690bf8832fcf3f1aca997c457fad99029282", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-10-27T21:46:21Z", "type": "forcePushed"}, {"oid": "e81a8ff1b727a7192fc54955ef147d5caaed9ab1", "url": "https://github.com/oracle/graal/commit/e81a8ff1b727a7192fc54955ef147d5caaed9ab1", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-10-27T21:47:31Z", "type": "forcePushed"}, {"oid": "6c6664598166480dc6347e1dad8a237c2fd884e2", "url": "https://github.com/oracle/graal/commit/6c6664598166480dc6347e1dad8a237c2fd884e2", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-02T15:09:17Z", "type": "forcePushed"}, {"oid": "59a23eee247546eebebcd2bb104e72b182151720", "url": "https://github.com/oracle/graal/commit/59a23eee247546eebebcd2bb104e72b182151720", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-02T15:12:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA0MDI5MA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r516040290", "bodyText": "Should we cache the encodings here?", "author": "zakkak", "createdAt": "2020-11-02T15:13:53Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private final Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private byte[] getByteArray(SpeculationReason reason) {\n+        byte[] bytes = null;\n+        if (reason instanceof UnencodedSpeculationReason) {\n+            IsolatedSpeculationReasonEncoding encoding = encode((UnencodedSpeculationReason) reason);\n+            bytes = encoding.getByteArray();\n+        } else {\n+            try {\n+                Class<?> speculationReasonEncodingClass = Class.forName(\"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\");\n+                final Object speculationReasonEncodingProxy = Proxy.newProxyInstance(speculationReasonEncodingClass.getClassLoader(),\n+                                new Class<?>[]{speculationReasonEncodingClass},\n+                                new SpeculationReasonInvocationHandler());\n+                IsolatedSpeculationReasonEncoding encoding = (IsolatedSpeculationReasonEncoding) Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\").getDeclaredMethod(\"encode\").invoke(new SpeculationReasonEncodingSupplier(speculationReasonEncodingProxy));\n+                bytes = encoding.getByteArray();\n+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        return bytes;\n+    }\n+\n+    /** Adapted from {@code jdk.vm.ci.meta.EncodedSpeculationReason#encode}. */\n+    public IsolatedSpeculationReasonEncoding encode(UnencodedSpeculationReason reason) {\n+        IsolatedSpeculationReasonEncoding encoding = null;", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4OTExMw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519789113", "bodyText": "Looks like we can only do that using a WeakIdentityHashMap, but I wouldn't now unless it proves to have a performance impact.", "author": "peter-hofer", "createdAt": "2020-11-09T13:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA0MDI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwMjU0Mg==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520902542", "bodyText": "Not sure how to benchmark this. I will be happy to if you provide instructions though :)", "author": "zakkak", "createdAt": "2020-11-10T22:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA0MDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcyODczMQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519728731", "bodyText": "Remove throws clause: does not throw these exceptions any longer.", "author": "peter-hofer", "createdAt": "2020-11-09T11:11:09Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private final Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private byte[] getByteArray(SpeculationReason reason) {\n+        byte[] bytes = null;\n+        if (reason instanceof UnencodedSpeculationReason) {\n+            IsolatedSpeculationReasonEncoding encoding = encode((UnencodedSpeculationReason) reason);\n+            bytes = encoding.getByteArray();\n+        } else {\n+            try {\n+                Class<?> speculationReasonEncodingClass = Class.forName(\"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\");\n+                final Object speculationReasonEncodingProxy = Proxy.newProxyInstance(speculationReasonEncodingClass.getClassLoader(),\n+                                new Class<?>[]{speculationReasonEncodingClass},\n+                                new SpeculationReasonInvocationHandler());\n+                IsolatedSpeculationReasonEncoding encoding = (IsolatedSpeculationReasonEncoding) Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\").getDeclaredMethod(\"encode\").invoke(new SpeculationReasonEncodingSupplier(speculationReasonEncodingProxy));\n+                bytes = encoding.getByteArray();\n+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        return bytes;\n+    }\n+\n+    /** Adapted from {@code jdk.vm.ci.meta.EncodedSpeculationReason#encode}. */\n+    public IsolatedSpeculationReasonEncoding encode(UnencodedSpeculationReason reason) {\n+        IsolatedSpeculationReasonEncoding encoding = null;\n+        try {\n+            encoding = new IsolatedSpeculationReasonEncoding();\n+            int groupId = UnencodedSpeculationReason.class.getField(\"groupId\").getInt(reason);\n+            Object[] context = (Object[]) UnencodedSpeculationReason.class.getField(\"context\").get(reason);\n+            encoding.addInt(groupId);\n+            for (Object o : context) {\n+                if (o == null) {\n+                    encoding.addInt(0);\n+                } else {\n+                    addNonNullObject(encoding, o);\n+                }\n+            }\n+        } catch (IllegalAccessException | InvocationTargetException | NoSuchFieldException e) {\n+            e.printStackTrace();\n+        }\n+        return encoding;\n+    }\n+\n+    /** Copied from {@code jdk.vm.ci.meta.EncodedSpeculationReason#addNonNullObject}. */\n+    static void addNonNullObject(IsolatedSpeculationReasonEncoding encoding, Object o) throws InvocationTargetException, IllegalAccessException {", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcyODg3Mw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519728873", "bodyText": "Should be a cast to Character.", "author": "peter-hofer", "createdAt": "2020-11-09T11:11:24Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private final Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private byte[] getByteArray(SpeculationReason reason) {\n+        byte[] bytes = null;\n+        if (reason instanceof UnencodedSpeculationReason) {\n+            IsolatedSpeculationReasonEncoding encoding = encode((UnencodedSpeculationReason) reason);\n+            bytes = encoding.getByteArray();\n+        } else {\n+            try {\n+                Class<?> speculationReasonEncodingClass = Class.forName(\"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\");\n+                final Object speculationReasonEncodingProxy = Proxy.newProxyInstance(speculationReasonEncodingClass.getClassLoader(),\n+                                new Class<?>[]{speculationReasonEncodingClass},\n+                                new SpeculationReasonInvocationHandler());\n+                IsolatedSpeculationReasonEncoding encoding = (IsolatedSpeculationReasonEncoding) Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\").getDeclaredMethod(\"encode\").invoke(new SpeculationReasonEncodingSupplier(speculationReasonEncodingProxy));\n+                bytes = encoding.getByteArray();\n+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        return bytes;\n+    }\n+\n+    /** Adapted from {@code jdk.vm.ci.meta.EncodedSpeculationReason#encode}. */\n+    public IsolatedSpeculationReasonEncoding encode(UnencodedSpeculationReason reason) {\n+        IsolatedSpeculationReasonEncoding encoding = null;\n+        try {\n+            encoding = new IsolatedSpeculationReasonEncoding();\n+            int groupId = UnencodedSpeculationReason.class.getField(\"groupId\").getInt(reason);\n+            Object[] context = (Object[]) UnencodedSpeculationReason.class.getField(\"context\").get(reason);\n+            encoding.addInt(groupId);\n+            for (Object o : context) {\n+                if (o == null) {\n+                    encoding.addInt(0);\n+                } else {\n+                    addNonNullObject(encoding, o);\n+                }\n+            }\n+        } catch (IllegalAccessException | InvocationTargetException | NoSuchFieldException e) {\n+            e.printStackTrace();\n+        }\n+        return encoding;\n+    }\n+\n+    /** Copied from {@code jdk.vm.ci.meta.EncodedSpeculationReason#addNonNullObject}. */\n+    static void addNonNullObject(IsolatedSpeculationReasonEncoding encoding, Object o) throws InvocationTargetException, IllegalAccessException {\n+        Class<?> c = o.getClass();\n+        if (c == String.class) {\n+            encoding.addString((String) o);\n+        } else if (c == Byte.class) {\n+            encoding.addByte((Byte) o);\n+        } else if (c == Short.class) {\n+            encoding.addShort((Short) o);\n+        } else if (c == Character.class) {\n+            encoding.addShort((Short) o);", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczMDM0OA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519730348", "bodyText": "Must use getDeclaredField: these fields are package-private.", "author": "peter-hofer", "createdAt": "2020-11-09T11:14:09Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private final Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private byte[] getByteArray(SpeculationReason reason) {\n+        byte[] bytes = null;\n+        if (reason instanceof UnencodedSpeculationReason) {\n+            IsolatedSpeculationReasonEncoding encoding = encode((UnencodedSpeculationReason) reason);\n+            bytes = encoding.getByteArray();\n+        } else {\n+            try {\n+                Class<?> speculationReasonEncodingClass = Class.forName(\"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\");\n+                final Object speculationReasonEncodingProxy = Proxy.newProxyInstance(speculationReasonEncodingClass.getClassLoader(),\n+                                new Class<?>[]{speculationReasonEncodingClass},\n+                                new SpeculationReasonInvocationHandler());\n+                IsolatedSpeculationReasonEncoding encoding = (IsolatedSpeculationReasonEncoding) Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\").getDeclaredMethod(\"encode\").invoke(new SpeculationReasonEncodingSupplier(speculationReasonEncodingProxy));\n+                bytes = encoding.getByteArray();\n+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException | ClassNotFoundException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        return bytes;\n+    }\n+\n+    /** Adapted from {@code jdk.vm.ci.meta.EncodedSpeculationReason#encode}. */\n+    public IsolatedSpeculationReasonEncoding encode(UnencodedSpeculationReason reason) {\n+        IsolatedSpeculationReasonEncoding encoding = null;\n+        try {\n+            encoding = new IsolatedSpeculationReasonEncoding();\n+            int groupId = UnencodedSpeculationReason.class.getField(\"groupId\").getInt(reason);\n+            Object[] context = (Object[]) UnencodedSpeculationReason.class.getField(\"context\").get(reason);", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4MDAzNw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519780037", "bodyText": "Must use signature for lookup and pass receiver:\n                IsolatedSpeculationReasonEncoding encoding = (IsolatedSpeculationReasonEncoding) Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\").getDeclaredMethod(\"encode\", Supplier.class)\n                                .invoke(reason, new SpeculationReasonEncodingSupplier(speculationReasonEncodingProxy));", "author": "peter-hofer", "createdAt": "2020-11-09T12:45:51Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private final Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private byte[] getByteArray(SpeculationReason reason) {\n+        byte[] bytes = null;\n+        if (reason instanceof UnencodedSpeculationReason) {\n+            IsolatedSpeculationReasonEncoding encoding = encode((UnencodedSpeculationReason) reason);\n+            bytes = encoding.getByteArray();\n+        } else {\n+            try {\n+                Class<?> speculationReasonEncodingClass = Class.forName(\"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\");\n+                final Object speculationReasonEncodingProxy = Proxy.newProxyInstance(speculationReasonEncodingClass.getClassLoader(),\n+                                new Class<?>[]{speculationReasonEncodingClass},\n+                                new SpeculationReasonInvocationHandler());\n+                IsolatedSpeculationReasonEncoding encoding = (IsolatedSpeculationReasonEncoding) Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\").getDeclaredMethod(\"encode\").invoke(new SpeculationReasonEncodingSupplier(speculationReasonEncodingProxy));", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxODIwMA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519818200", "bodyText": "Probably best to just do PROXY_CLASS.getDeclaredConstructor(...).newInstance() here so the native image build can fold the reflective instantiation.", "author": "peter-hofer", "createdAt": "2020-11-09T13:35:24Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private final Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwMzA1OQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520903059", "bodyText": "I cached the constructor as well.", "author": "zakkak", "createdAt": "2020-11-10T22:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxODIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519820384", "bodyText": "The invoke call is missing a receiver of type IsolatedSpeculationReasonEncoding, which should first be instantiated in the supplier and passed to this invocation handler class via a constructor.", "author": "peter-hofer", "createdAt": "2020-11-09T13:39:01Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzMDEwMg==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519830102", "bodyText": "I doubt the image build can optimize the reflective accesses, and on top of repeatedly doing lookups at runtime, we will need to register the methods of IsolatedSpeculationReasonEncoding as reflectively accessible in a Feature during the image build.\nSo I'd rather avoid this proxy, but I don't see how we can have a class that directly implements SpeculationReasonEncoding when that interface cannot be referenced in the code.", "author": "peter-hofer", "createdAt": "2020-11-09T13:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2MDUzNQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520660535", "bodyText": "@peter-hofer is there any way to inject this interface to SpeculationLog when using an openJDK which lacks it (using something like com.oracle.svm.core.annotate.TargetClass#onlyWith)\nAlternatively, could we add the interface in the sources and compile it in only when needed? (possibly through mx).", "author": "zakkak", "createdAt": "2020-11-10T15:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY2ODgwOA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520668808", "bodyText": "The invoke call is missing a receiver of type IsolatedSpeculationReasonEncoding, which should first be instantiated in the supplier and passed to this invocation handler class via a constructor.\n\nShouldn't the said IsolatedSpeculationReasonEncoding be instantiated for each new encoding and as a result don't we need a new SpeculationReasonInvocationHandler for each new encoding and consequently a new proxy instance rendering https://github.com/oracle/graal/pull/2945/files#r519816278 impossible?", "author": "zakkak", "createdAt": "2020-11-10T15:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODAxNw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520758017", "bodyText": "Shouldn't the said IsolatedSpeculationReasonEncoding be instantiated for each new encoding and as a result don't we need a new SpeculationReasonInvocationHandler for each new encoding and consequently a new proxy instance rendering https://github.com/oracle/graal/pull/2945/files#r519816278 impossible?\n\nI agree, we do need a separate instance of each of these classes for each encoding operation. Not sure what that contradicts, I think you meant to link to a comment.", "author": "peter-hofer", "createdAt": "2020-11-10T17:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2ODYyNg==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520768626", "bodyText": "@peter-hofer is there any way to inject this interface to SpeculationLog when using an openJDK which lacks it (using something like com.oracle.svm.core.annotate.TargetClass#onlyWith)\nAlternatively, could we add the interface in the sources and compile it in only when needed? (possibly through mx).\n\nUsing substitutions is a clever idea, but they don't support changes to the class hierarchy. What we could try is substituting methods of the dynamic proxy class to call the encoder directly instead. Substituting a generated class like a proxy sounds a bit fragile, though.", "author": "peter-hofer", "createdAt": "2020-11-10T18:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTE3OA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520811178", "bodyText": "Shouldn't the said IsolatedSpeculationReasonEncoding be instantiated for each new encoding and as a result don't we need a new SpeculationReasonInvocationHandler for each new encoding and consequently a new proxy instance rendering https://github.com/oracle/graal/pull/2945/files#r519816278 impossible?\n\nI agree, we do need a separate instance of each of these classes for each encoding operation. Not sure what that contradicts, I think you meant to link to a comment.\n\nIt looks like after force pushing changes links to out-of-date discussions break \ud83e\udd26\u200d\u2642\ufe0f\nNew link after force pushing is #2945 (comment)\nI could use java.lang.reflect.Proxy#getProxyClass to get the proxy class and cache it but it is deprecated.\nEdit: NVM I think I figured how to do this without using getProxyClass", "author": "zakkak", "createdAt": "2020-11-10T19:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0ODYxMg==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r520948612", "bodyText": "I doubt the image build can optimize the reflective accesses, and on top of repeatedly doing lookups at runtime, we will need to register the methods of IsolatedSpeculationReasonEncoding as reflectively accessible in a Feature during the image build.\nSo I'd rather avoid this proxy, but I don't see how we can have a class that directly implements SpeculationReasonEncoding when that interface cannot be referenced in the code.\n\n@peter-hofer please have a look at zakkak@1939801, it removes the proxy and relies solely on our cloned interface.\nIf the original encode gets invoked elsewhere it will essentially generate the same encoding and cache it in the corresponding EncodedSpeculationReason instance.\nIf I am not mistaken this should work without the performance penalty.\nFYI: The full diff of this approach against master can be seen here", "author": "zakkak", "createdAt": "2020-11-10T23:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5NTQwMw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r522095403", "bodyText": "@peter-hofer please have a look at zakkak@1939801, it removes the proxy and relies solely on our cloned interface.\n\nLooks good. I did encounter problems when the proxy class is created at image build time, so that's another reason to avoid it.\nHowever, I would like to have two separate code paths which directly call UnencodedSpeculationReason.class.getDeclaredField(\"...\").get*(reason) and Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\").getDeclaredField(\"...\").get*(reason) and pass the values to a method that does the encoding. That way, we can be sure that these reflective accesses will become direct field accesses during the image build.\nMy only worry other than that is that EncodedSpeculationReason may be changed in the future and this code silently becomes broken, which would have been prevented by using a proxy class.", "author": "peter-hofer", "createdAt": "2020-11-12T13:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQxMjc3OQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r522412779", "bodyText": "My only worry other than that is that EncodedSpeculationReason may be changed in the future and this code silently becomes broken, which would have been prevented by using a proxy class.\n\nYes I also thought about this, but even with the proxy in place this would still be the case for the UnencodedSpeculationReason path, right?\nI guess we should implement some kind of test and add it to mx gate so that if/when EncodedSpeculationReason changes we get notified (the simplest I can think of is comparing the result of the copied methods with the result of the corresponding methods in EncodedSpeculationReason).", "author": "zakkak", "createdAt": "2020-11-12T20:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkyMzM4MQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r523923381", "bodyText": "@peter-hofer the test is now added to the PR, I hope this is enough to detect potential future changes in EncodedSpeculationReason that could cause issues.", "author": "zakkak", "createdAt": "2020-11-16T06:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyMTM4Ng==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r519821386", "bodyText": "Please name this method encodeAsByteArray.", "author": "peter-hofer", "createdAt": "2020-11-09T13:40:37Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,115 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private final Object speculationReasonEncodingProxy;\n+\n+        SpeculationReasonEncodingSupplier(Object speculationReasonEncodingProxy) {\n+            this.speculationReasonEncodingProxy = speculationReasonEncodingProxy;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            try {\n+                return speculationReasonEncodingProxy.getClass().getDeclaredConstructor().newInstance();\n+            } catch (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                e.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private byte[] getByteArray(SpeculationReason reason) {", "originalCommit": "59a23eee247546eebebcd2bb104e72b182151720", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "02915bf4e9fc3cc1c0a8f2f56e885394ccb17b2f", "url": "https://github.com/oracle/graal/commit/02915bf4e9fc3cc1c0a8f2f56e885394ccb17b2f", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-10T15:57:44Z", "type": "forcePushed"}, {"oid": "cc4e19fc9c906397a0168509cce1ebf83be05e3b", "url": "https://github.com/oracle/graal/commit/cc4e19fc9c906397a0168509cce1ebf83be05e3b", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-10T21:49:20Z", "type": "forcePushed"}, {"oid": "71a5d51119850601cc7bd3f6df56749d9c780779", "url": "https://github.com/oracle/graal/commit/71a5d51119850601cc7bd3f6df56749d9c780779", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-10T21:57:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQwNzcxOA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r521407718", "bodyText": "There is a (significant) chance that this class is initialized during the image build and not only when encountering a class other than UnencodedSpeculationReason at runtime, in which case this will likely break the image build. Therefore, we have to just set all the static fields to null in that case.", "author": "peter-hofer", "createdAt": "2020-11-11T14:45:46Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +58,140 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    static class SpeculationReasonInvocationHandler implements InvocationHandler {\n+        private final IsolatedSpeculationReasonEncoding receiver;\n+\n+        SpeculationReasonInvocationHandler(IsolatedSpeculationReasonEncoding receiver) {\n+            this.receiver = receiver;\n+        }\n+\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return IsolatedSpeculationReasonEncoding.class.getDeclaredMethod(method.getName(), method.getParameterTypes()).invoke(receiver, args);\n+        }\n+    }\n+\n+    static class SpeculationReasonEncodingSupplier implements Supplier<Object> {\n+        private static final Class<?> SPECULATION_REASON_ENCODING_PROXY_CLASS;\n+        private static final Constructor<?> SPECULATION_REASON_ENCODING_PROXY_CONSTRUCTOR;\n+        private static final Class<?> SPECULATION_REASON_ENCODING_CLASS;\n+        private static final String SPECULATION_REASON_ENCODING_NAME = \"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\";\n+\n+        static {\n+            Class<?> speculationReasonEncodingClass = null;\n+            try {\n+                speculationReasonEncodingClass = Class.forName(SPECULATION_REASON_ENCODING_NAME);\n+            } catch (ClassNotFoundException e) {\n+                VMError.shouldNotReachHere(SPECULATION_REASON_ENCODING_NAME +\n+                                \" not found in JDK. UnencodedSpeculationReason should have been used as SpeculationReason\");", "originalCommit": "71a5d51119850601cc7bd3f6df56749d9c780779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0Mjc0OA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r521542748", "bodyText": "OK, I changed it to initialize everything to null in that case and catch the NullPointerException in get() to print a hopefully more helpful error message :)\ndiff --git a/substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java b/substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java\nindex 75a3eca830f..eb5a4f915b6 100644\n--- a/substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java\n+++ b/substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java\n@@ -78,31 +78,34 @@ public final class IsolatedSpeculationLog extends IsolatedObjectProxy<Speculatio\n         private static final String CLASS_NAME = \"jdk.vm.ci.meta.SpeculationLog$SpeculationReasonEncoding\";\n \n         static {\n-            Class<?> speculationReasonEncodingClass = null;\n+            Class<?> speculationReasonEncodingClass;\n             try {\n                 speculationReasonEncodingClass = Class.forName(CLASS_NAME);\n             } catch (ClassNotFoundException e) {\n-                VMError.shouldNotReachHere(CLASS_NAME +\n-                                \" not found in JDK. UnencodedSpeculationReason should have been used as SpeculationReason\");\n+                speculationReasonEncodingClass = null;\n             }\n             CLASS = speculationReasonEncodingClass;\n-            assert CLASS != null;\n-            PROXY_CLASS = Proxy.newProxyInstance(CLASS.getClassLoader(), new Class<?>[]{CLASS},\n-                            new SpeculationReasonInvocationHandler(new IsolatedSpeculationReasonEncoding())).getClass();\n-            Constructor<?> declaredConstructor = null;\n-            try {\n-                declaredConstructor = PROXY_CLASS.getDeclaredConstructor(CLASS);\n-            } catch (NoSuchMethodException e) {\n-                VMError.shouldNotReachHere(\"Failed to get constructor for \" + PROXY_CLASS);\n+            if (CLASS != null) {\n+                PROXY_CLASS = Proxy.newProxyInstance(CLASS.getClassLoader(), new Class<?>[]{CLASS},\n+                        new SpeculationReasonInvocationHandler(new IsolatedSpeculationReasonEncoding())).getClass();\n+                Constructor<?> declaredConstructor = null;\n+                try {\n+                    declaredConstructor = PROXY_CLASS.getDeclaredConstructor(CLASS);\n+                } catch (NoSuchMethodException e) {\n+                    VMError.shouldNotReachHere(\"Failed to get constructor for \" + PROXY_CLASS);\n+                }\n+                CONSTRUCTOR = declaredConstructor;\n+            } else {\n+                PROXY_CLASS = null;\n+                CONSTRUCTOR = null;\n             }\n-            CONSTRUCTOR = declaredConstructor;\n         }\n \n         @Override\n         public Object get() {\n             try {\n                 return CONSTRUCTOR.newInstance(new SpeculationReasonInvocationHandler(new IsolatedSpeculationReasonEncoding()));\n-            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n+            } catch (NullPointerException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n                 VMError.shouldNotReachHere(\"Failed to instantiate \" + CLASS_NAME + \"through proxy\", e);\n             }\n             return null;", "author": "zakkak", "createdAt": "2020-11-11T18:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQwNzcxOA=="}], "type": "inlineReview"}, {"oid": "8fada26ee40bb164d87f10a18f23cdfc82c7039a", "url": "https://github.com/oracle/graal/commit/8fada26ee40bb164d87f10a18f23cdfc82c7039a", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-11T18:02:34Z", "type": "forcePushed"}, {"oid": "d488c9f9c16d9e94a4a328e2028c949a3dfaf53a", "url": "https://github.com/oracle/graal/commit/d488c9f9c16d9e94a4a328e2028c949a3dfaf53a", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-14T02:27:24Z", "type": "forcePushed"}, {"oid": "93257038538f3bf852d2f363d4ebfb34889663e8", "url": "https://github.com/oracle/graal/commit/93257038538f3bf852d2f363d4ebfb34889663e8", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-16T06:30:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NzAxNw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r523977017", "bodyText": "If I understand the review conversation, these reflective accesses will be converted to non-reflective accesses during image building. A comment should be added somewhere here explaining that. Does the added unit test check that this happens?", "author": "dougxc", "createdAt": "2020-11-16T08:45:54Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +53,89 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    private static byte[] encodeAsByteArray(SpeculationReason reason) {\n+        int groupId = 0;\n+        Object[] context = null;\n+        try {\n+            final Field groupIdField;", "originalCommit": "93257038538f3bf852d2f363d4ebfb34889663e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNzYzMQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r524017631", "bodyText": "Does the added unit test check that this happens?\n\nNot at its current state. It cannot be compiled with native-image due to the invocation handler that is required to create the supplier that we pass to labsJDK's internal encode.\nWould adding another test that only uses graalvm's implementations and running it with native-unittest be enough?", "author": "zakkak", "createdAt": "2020-11-16T09:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NzAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNDEyNQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r524114125", "bodyText": "If that tests the condition stated in the (to be added) comment, then yes.", "author": "dougxc", "createdAt": "2020-11-16T10:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NzAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2MTgwNw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r524161807", "bodyText": "According to https://www.graalvm.org/reference-manual/native-image/Reflection/\n\nIf the target elements can be resolved, the calls are removed and instead the target elements are embedded in the code. If the target elements cannot be resolved, e.g., a class is not on the classpath or it does not declare a field/method/constructor, then the calls are replaced with a snippet that throws the appropriate exception at run time.\n\nSo to my understanding just compiling and running an image that covers the corresponding code segments should be enough.\nIs there any better way to achieve this?", "author": "zakkak", "createdAt": "2020-11-16T11:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NzAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE2NDY1Nw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r524164657", "bodyText": "Comment and test added.", "author": "zakkak", "createdAt": "2020-11-16T11:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NzAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkyMDQzNA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r527920434", "bodyText": "Indeed, if the members cannot be resolved directly and are not registered by other means, usually a configuration file, using them will fail.", "author": "peter-hofer", "createdAt": "2020-11-20T19:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NzAxNw=="}], "type": "inlineReview"}, {"oid": "237e3fa9836b76fa062b64231b96779393d51ffa", "url": "https://github.com/oracle/graal/commit/237e3fa9836b76fa062b64231b96779393d51ffa", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-16T11:35:54Z", "type": "forcePushed"}, {"oid": "50f65e5e24ca923a340ea6cc04e24a92046abbe6", "url": "https://github.com/oracle/graal/commit/50f65e5e24ca923a340ea6cc04e24a92046abbe6", "message": "Work around the absence of SpeculationReasonEncoding in OpenJDK11", "committedDate": "2020-11-24T11:48:13Z", "type": "commit"}, {"oid": "0ed0307b1129dac119f1b60c89260ceff90bd065", "url": "https://github.com/oracle/graal/commit/0ed0307b1129dac119f1b60c89260ceff90bd065", "message": "Use jdk.vm.ci.meta.EncodedSpeculationReason with jdk8", "committedDate": "2020-11-24T12:10:57Z", "type": "commit"}, {"oid": "0ed0307b1129dac119f1b60c89260ceff90bd065", "url": "https://github.com/oracle/graal/commit/0ed0307b1129dac119f1b60c89260ceff90bd065", "message": "Use jdk.vm.ci.meta.EncodedSpeculationReason with jdk8", "committedDate": "2020-11-24T12:10:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg3NTMyMQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r529875321", "bodyText": "This comment should also explain why copying is necessary so that no one is tempted to \"uncopy\" it.", "author": "dougxc", "createdAt": "2020-11-24T21:02:07Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/SpeculationReasonEncodingClone.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.graal.isolated;\n+\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+\n+/** Copied from {@code jdk.vm.ci.hotspot.HotSpotSpeculationEncoding.SpeculationReasonEncoding}. */", "originalCommit": "0ed0307b1129dac119f1b60c89260ceff90bd065", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r530151095", "bodyText": "Feedback from internal review:\n\nInstead of reflection, it is better to use a method handle returned by MethodHandles.lookup().unreflectGetter and stored in a static final field. The method handle is then really intrinsified to a direct field access.", "author": "peter-hofer", "createdAt": "2020-11-25T07:15:20Z", "path": "substratevm/src/com.oracle.svm.graal/src/com/oracle/svm/graal/isolated/IsolatedSpeculationLog.java", "diffHunk": "@@ -48,19 +53,95 @@ public void collectFailedSpeculations() {\n         collectFailedSpeculations0(IsolatedCompileContext.get().getClient(), handle);\n     }\n \n+    private static byte[] encodeAsByteArray(SpeculationReason reason) {\n+        int groupId = 0;\n+        Object[] context = null;\n+        try {\n+            final Field groupIdField;\n+            final Field contextField;\n+            /*\n+             * The following reflective accesses do not add runtime overhead as they are being\n+             * converted to direct accesses during image building. Maintaining two separate paths\n+             * that invoke {@code getDeclaredField} ensures that the analysis will be able to\n+             * optimize the reflective accesses and convert them to direct ones.\n+             */\n+            if (reason instanceof UnencodedSpeculationReason) {\n+                final Class<?> klass = UnencodedSpeculationReason.class;\n+                groupIdField = klass.getDeclaredField(\"groupId\");\n+                contextField = klass.getDeclaredField(\"context\");\n+            } else {\n+                final Class<?> klass = Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\");\n+                groupIdField = klass.getDeclaredField(\"groupId\");\n+                contextField = klass.getDeclaredField(\"context\");\n+            }\n+            groupIdField.setAccessible(true);\n+            groupId = groupIdField.getInt(reason);", "originalCommit": "0ed0307b1129dac119f1b60c89260ceff90bd065", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIyMzkxOA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r530223918", "bodyText": "I tried this:\nif (reason instanceof UnencodedSpeculationReason) {\n    final Class<?> klass = UnencodedSpeculationReason.class;\n    final Field groupIdField = klass.getDeclaredField(\"groupId\");\n    final Field contextField = klass.getDeclaredField(\"context\");\n    final MethodHandle groupIdHandle = MethodHandles.lookup().unreflectGetter(groupIdField); // fails here\n    final MethodHandle contextHandle = MethodHandles.lookup().unreflectGetter(contextField);\n    groupId = (int) groupIdHandle.invoke(reason);\n    context = (Object[]) contextHandle.invoke(reason);\n} else {\n    final Class<?> klass = Class.forName(\"jdk.vm.ci.meta.EncodedSpeculationReason\");\n    final Field groupIdField = klass.getDeclaredField(\"groupId\");\n    final Field contextField = klass.getDeclaredField(\"context\");\n    final MethodHandle groupIdHandle = MethodHandles.lookup().unreflectGetter(groupIdField);\n    final MethodHandle contextHandle = MethodHandles.lookup().unreflectGetter(contextField);\n    groupId = (int) groupIdHandle.invoke(reason);              // fails here\n    context = (Object[]) contextHandle.invoke(reason);         // and here\n}\nbut the if-case fails with:\nError: com.oracle.svm.hosted.substitute.DeletedElementException: Unsupported type java.lang.invoke.MemberName is reachable: All methods from java.lang.invoke should have been replaced during image building.\nTo diagnose the issue, you can add the option --report-unsupported-elements-at-runtime. The unsupported element is then reported at run time when it is accessed the first time.\n\nfor\n                final MethodHandle groupIdHandle = MethodHandles.lookup().unreflectGetter(groupIdField);\nand the else-case with:\nError: com.oracle.graal.pointsto.constraints.UnsupportedFeatureException: Invoke with MethodHandle argument could not be reduced to at most a single call or single field access. The method handle must be a compile time constant, e.g., be loaded from a `static final` field. Method that contains the method handle invocation: java.lang.invoke.MethodHandle.invokeBasic(Object)\nTo enable method handles that do not require LambdaForm interpretation (e.g. because of a call to MethodHandle.bindTo()) or to diagnose the issue, you can add the option --report-unsupported-elements-at-runtime. The error is then reported at run time when the invoke is executed and the method handle has to be interpreted.\n\nfor\n                groupId = (int) groupIdHandle.invoke(reason);\n                context = (Object[]) contextHandle.invoke(reason);\nWhich, if I am not mistaken, hints that the accesses were not beeing intrinsified before the change as well.", "author": "zakkak", "createdAt": "2020-11-25T09:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2NDE2OQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r531164169", "bodyText": "Looks like the accesses cannot be intrinsified from within the code, but what if you store the accessors in a static final field? It should be possible to move the class detection logic to a static initializer for that.", "author": "peter-hofer", "createdAt": "2020-11-26T17:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4NjQ3NQ==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r531586475", "bodyText": "Tried that as well (see zakkak@8a6a796), but it still gives\nError: com.oracle.graal.pointsto.constraints.UnsupportedFeatureException: Invoke with MethodHandle argument could not be reduced to at most a single call or single field access. The method handle must be a compile time constant, e.g., be loaded from a `static final` field. Method that contains the method handle invocation: java.lang.invoke.LambdaForm$MH/658839328.invoke_MT(Object, Object, Object)\n\nat\nzakkak@8a6a796#diff-603f78c0054580a456da1e1f763e13bd03cd60958a2f5358fb25509c268d57f6R104", "author": "zakkak", "createdAt": "2020-11-27T12:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2OTgwNg==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r537769806", "bodyText": "I finally got around to look into this today, sorry for the delay. The issue is that calling the getter on the interface type (rather than a concrete subclass which is guaranteed to have the accessed fields) introduces a type-check, which makes the method handle logic too complex to inline.\nI'll merge the reflection variant.", "author": "peter-hofer", "createdAt": "2020-12-07T19:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIzMzE0Nw==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r538233147", "bodyText": "Thank you @peter-hofer!\nCould you please outline the process you used to figure this out (if possible with tools available to the community)?\nI tried creating bgv files from building the native native-image but I couldn't find the graph for encodeAsByteArray.", "author": "zakkak", "createdAt": "2020-12-08T10:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyODM5Ng==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r539128396", "bodyText": "From debugging the code that creates the error in IntrinsifyMethodHandlesInvocationPlugin, I could gather that the method handle graph contains an If node where it isn't supported. I then used the command line mx native-unittest IsolatedSpeculationLog --build-args -H:Dump=:1 -H:MethodFilter=encodeAsByteArray to get a bgv file with the method handle graph that cannot be inlined and saw that it has a type check.\nI then consulted with @christianwimmer who told me to look at the parameter node's type. That turned out to be SpeculationReason, which is an interface that of course doesn't have the accessed field(s), so the type check is necessary. Since we use Class.forName and so cannot define a statically typed variable of the subclass with the fields, we cannot proceed.", "author": "peter-hofer", "createdAt": "2020-12-09T09:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyNzM1NA==", "url": "https://github.com/oracle/graal/pull/2945#discussion_r540127354", "bodyText": "That helps a lot, thank you for the information @peter-hofer", "author": "zakkak", "createdAt": "2020-12-10T12:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE1MTA5NQ=="}], "type": "inlineReview"}]}