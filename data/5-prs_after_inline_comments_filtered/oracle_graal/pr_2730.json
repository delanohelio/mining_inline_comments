{"pr_number": 2730, "pr_title": "Support JDK serialization/deserialization features", "pr_createdAt": "2020-08-03T07:31:41Z", "pr_url": "https://github.com/oracle/graal/pull/2730", "timeline": [{"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2", "url": "https://github.com/oracle/graal/commit/d8da62b3f893b6b8717bdd661b10bf0c669262a2", "message": "Support JDK serialization", "committedDate": "2020-08-05T10:32:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzMjU3Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469432576", "bodyText": "This seems to target JDK 8 because these classes have since been moved to jdk.internal.reflect. Have you tested these changes using JDK 11?", "author": "peter-hofer", "createdAt": "2020-08-12T17:44:10Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -1218,6 +1338,9 @@ public static void onUnload() {\n                     brk(\"java/lang/reflect/Proxy\", \"newProxyInstance\",\n                                     \"(Ljava/lang/ClassLoader;[Ljava/lang/Class;Ljava/lang/reflect/InvocationHandler;)Ljava/lang/Object;\", BreakpointInterceptor::newProxyInstance),\n \n+                    brk(\"sun/reflect/MethodAccessorGenerator\", \"generateSerializationConstructor\",\n+                                    \"(Ljava/lang/Class;[Ljava/lang/Class;[Ljava/lang/Class;ILjava/lang/Class;)Lsun/reflect/SerializationConstructorAccessorImpl;\",\n+                                    BreakpointInterceptor::generateSerializationConstructor),", "originalCommit": "d8da62b3f893b6b8717bdd661b10bf0c669262a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3MDkzMw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r471870933", "bodyText": "This PR is only for JDK 8, not tested on JDK 11. Should it support both versions in one patch? I planned to work on JDK 11 after this patch.", "author": "ziyilin", "createdAt": "2020-08-18T02:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzMjU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAzODI3MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472038271", "bodyText": "That would be preferable, we would like to keep the feature set consistent. It might be as simple as just having two optional breakpoints with different signatures (optional so it doesn't matter if one of them cannot be installed).", "author": "peter-hofer", "createdAt": "2020-08-18T09:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzMjU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzMzQzNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472333436", "bodyText": "I would actually be more OK with JDK 11 only support, because JDK 11 is more important than JDK 8.\nSo yes, we do not want to merge a feature like that without JDK 11 support.", "author": "christianwimmer", "createdAt": "2020-08-18T16:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzMjU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzODE4Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472338187", "bodyText": "This seems to work fine:\n                    optionalBrk(\"sun/reflect/MethodAccessorGenerator\", \"generateSerializationConstructor\",\n                                    \"(Ljava/lang/Class;[Ljava/lang/Class;[Ljava/lang/Class;ILjava/lang/Class;)Lsun/reflect/SerializationConstructorAccessorImpl;\",\n                                    BreakpointInterceptor::generateSerializationConstructor),\n                    optionalBrk(\"jdk/internal/reflect/MethodAccessorGenerator\", \"generateSerializationConstructor\",\n                                    \"(Ljava/lang/Class;[Ljava/lang/Class;[Ljava/lang/Class;ILjava/lang/Class;)Ljdk/internal/reflect/SerializationConstructorAccessorImpl;\",\n                                    BreakpointInterceptor::generateSerializationConstructor),", "author": "peter-hofer", "createdAt": "2020-08-18T16:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzMjU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3MzQ4Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472873483", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-08-19T08:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzMjU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzNDk4Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469434987", "bodyText": "Wouldn't this yield something like [I or [[[J for primitive arrays? I believe in order to stay consistent, this should also result in int[] or long[][][].", "author": "peter-hofer", "createdAt": "2020-08-12T17:48:18Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/TypeConfiguration.java", "diffHunk": "@@ -63,7 +63,12 @@ public ConfigurationType getOrCreateType(String qualifiedForNameString) {\n         }\n         if (n > 0) { // transform to Java source syntax\n             StringBuilder sb = new StringBuilder(s.length() + n);\n-            sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            if (s.charAt(n) == 'L' && s.charAt(s.length() - 1) == ';') {\n+                sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            } else {\n+                // Primitive Array\n+                return types.computeIfAbsent(s, ConfigurationType::new);", "originalCommit": "d8da62b3f893b6b8717bdd661b10bf0c669262a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg4OTA4OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r471889088", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-08-18T03:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzNDk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0MDczNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469440736", "bodyText": "Given that native-image does not support anything between JDK 8 and 11, the existing class JDK11OrLater should be sufficient.", "author": "peter-hofer", "createdAt": "2020-08-12T17:57:58Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/JDK9OrLater.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ */\n+package com.oracle.svm.core.jdk;\n+\n+import org.graalvm.compiler.serviceprovider.JavaVersionUtil;\n+\n+import java.util.function.BooleanSupplier;\n+\n+public class JDK9OrLater implements BooleanSupplier {", "originalCommit": "d8da62b3f893b6b8717bdd661b10bf0c669262a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg4OTI1MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r471889250", "bodyText": "Removed class JDK9OrLater", "author": "ziyilin", "createdAt": "2020-08-18T03:15:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0MDczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0MTQ0Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469441447", "bodyText": "minor: accessorDefinitions (+f)", "author": "peter-hofer", "createdAt": "2020-08-12T17:59:16Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.VMError;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport<T> implements SerializationRegistry<T> {\n+    //Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Object> cachedSerializationConstructorAccessors;\n+\n+    /* This map is used to track multiple classloader usage\n+     * Map of serialization target class and a list of class T that stores the parameters to\n+     * generate its SerializationConstructorAccessor class and other relevant information.\n+     *  Each T entity represents one generation. One target class usually has only one generation,\n+     * multiple-generations is a suggestion of multiple classloader usage.\n+     */\n+    private Map<String, List<T>> accessorDeinitions;", "originalCommit": "d8da62b3f893b6b8717bdd661b10bf0c669262a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg4OTEyNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r471889127", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-08-18T03:15:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0MTQ0Nw=="}], "type": "inlineReview"}, {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "url": "https://github.com/oracle/graal/commit/b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "message": "Support JDK serialization", "committedDate": "2020-08-18T03:17:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyMzUyNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472323526", "bodyText": "Needs to be adjusted for JDK 11. Locally I changed Package_jdk_internal_reflect to expose this method so it can be called here:\n    public static String getQualifiedName() {\n        if (JavaVersionUtil.JAVA_SPEC <= 8) {\n            return \"sun.reflect\";\n        } else {\n            return \"jdk.internal.reflect\";\n        }\n    }", "author": "peter-hofer", "createdAt": "2020-08-18T16:25:34Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/FallbackFeature.java", "diffHunk": "@@ -167,7 +168,11 @@ public FallbackFeature() {\n             addCheck(Proxy.class.getMethod(\"newProxyInstance\", ClassLoader.class, Class[].class, InvocationHandler.class), this::collectProxyInvokes);\n \n             addCheck(System.class.getMethod(\"loadLibrary\", String.class), this::collectJNIInvokes);\n-        } catch (NoSuchMethodException e) {\n+\n+            Class<?> generatorClass = Class.forName(\"sun.reflect.MethodAccessorGenerator\");", "originalCommit": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NDI2NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472874264", "bodyText": "Fixed as suggested", "author": "ziyilin", "createdAt": "2020-08-19T08:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyMzUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyNTI5MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472325290", "bodyText": "This file can be deleted once JDK 11 support is in place.", "author": "peter-hofer", "createdAt": "2020-08-18T16:28:18Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_jdk_internal_reflect_AccessorGenerator.java", "diffHunk": "@@ -28,11 +28,6 @@\n import com.oracle.svm.core.annotate.TargetClass;\n \n @Delete\n-@TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"AccessorGenerator\")\n-public final class Target_jdk_internal_reflect_AccessorGenerator {\n-}\n-\n-@Delete\n-@TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"MethodAccessorGenerator\")\n+@TargetClass(className = \"jdk.internal.reflect.MethodAccessorGenerator\", onlyWith = JDK11OrLater.class)\n final class Target_jdk_internal_reflect_MethodAccessorGenerator {\n }", "originalCommit": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NjI4NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472876284", "bodyText": "Put substitution classes in this file", "author": "ziyilin", "createdAt": "2020-08-19T09:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyNTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyNjAxNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472326016", "bodyText": "Use @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"MethodAccessorGenerator\") and @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"SerializationConstructorAccessorImpl\"), then these should work for both JDK 8 and 11. Rename classes to jdk_internal_reflect_* for consistency.", "author": "peter-hofer", "createdAt": "2020-08-18T16:29:23Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/serialize/Target_sun_reflect_MethodAccessorGenerator.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.jdk.serialize;\n+\n+import com.oracle.svm.core.annotate.Substitute;\n+import com.oracle.svm.core.annotate.TargetClass;\n+import com.oracle.svm.core.jdk.JDK8OrEarlier;\n+import org.graalvm.nativeimage.ImageSingletons;\n+\n+@TargetClass(className = \"sun.reflect.MethodAccessorGenerator\", onlyWith = JDK8OrEarlier.class)", "originalCommit": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NjMyOA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472876328", "bodyText": "I deleted this file, and put the substitution classes to src/com/oracle/svm/core/jdk/Target_jdk_internal_reflect_AccessorGenerator.java", "author": "ziyilin", "createdAt": "2020-08-19T09:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyNjAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDg1NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472334855", "bodyText": "It would be cleaner to pass along the field information gathered below in the serialization event above, or in separate serialization events, rather than faking reflection accesses. The TypeConfiguration for reflection can be passed to the SerializationProcessor constructor, which would then be able to register the fields and classes accordingly.", "author": "peter-hofer", "createdAt": "2020-08-18T16:43:03Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +918,119 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"unused\")\n+    private static boolean generateSerializationConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        JNIObjectHandle parameterTypes = getObjectArgument(2);\n+        Object parameterTypeNames = getClassArrayNames(jni, parameterTypes);\n+        JNIObjectHandle checkedExceptions = getObjectArgument(3);\n+        Object checkedExceptionNames = getClassArrayNames(jni, checkedExceptions);\n+        int modifiers = getIntArgument(4);\n+        JNIObjectHandle targetConstructorClass = getObjectArgument(5);\n+        String targetConstructorClassName = getClassNameOrNull(jni, targetConstructorClass);\n+        boolean allowed = (serializationAccessVerifier == null ||\n+                        serializationAccessVerifier.verifyGenerateSerializationConstructor(jni, serializeTargetClassName, parameterTypeNames,\n+                                        checkedExceptionNames, modifiers, targetConstructorClassName));\n+        Object result = false;\n+        if (allowed) {\n+            JNIValue args = StackValue.get(6, JNIValue.class);\n+            args.addressOf(0).setObject(self);\n+            args.addressOf(1).setObject(serializeTargetClass);\n+            args.addressOf(2).setObject(parameterTypes);\n+            args.addressOf(3).setObject(checkedExceptions);\n+            args.addressOf(4).setInt(modifiers);\n+            args.addressOf(5).setObject(targetConstructorClass);\n+            result = nullHandle().notEqual(jniFunctions().getCallObjectMethodA().invoke(jni, bp.clazz, bp.method, args));\n+            if (clearException(jni)) {\n+                result = false;\n+            }\n+        }\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        if (traceWriter != null) {\n+            traceWriter.traceCall(\"serialization\",\n+                            \"generateSerializationConstructor\",\n+                            null,\n+                            null,\n+                            null,\n+                            result,\n+                            serializeTargetClassName, parameterTypeNames,\n+                            checkedExceptionNames, modifiers, targetConstructorClassName);\n+            JNIFunctionPointerTypes.CallIntMethodFunctionPointer noArgRetIntCall = jniFunctions().getCallIntMethod();\n+            int privateStaticFinalMask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;\n+            int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+\n+            // call serializationTargetClass.getDeclaredFields();\n+            JNIObjectHandle javaLangClass = agent.handles().findClass(jni, \"java/lang/Class\");\n+            JNIMethodId getDeclaredFieldsMI = agent.handles().getMethodId(jni, javaLangClass, \"getDeclaredFields\",\n+                            \"()[Ljava/lang/reflect/Field;\", false);\n+            JNIFunctionPointerTypes.CallObjectMethod0FunctionPointer noArgRetObjectCall = jniFunctions().getCallObjectMethod();\n+            JNIObjectHandle fieldsJArray = noArgRetObjectCall.invoke(jni, serializeTargetClass, getDeclaredFieldsMI);\n+\n+            // Prepare JNIMethodIds for later calls\n+            JNIObjectHandle javaLangReflectField = agent.handles().findClass(jni, \"java/lang/reflect/Field\");\n+            JNIMethodId getFieldNameId = agent.handles().getMethodId(jni, javaLangReflectField, \"getName\", \"()Ljava/lang/String;\", false);\n+            JNIMethodId getFieldModifiersId = agent.handles().getMethodId(jni, javaLangReflectField, \"getModifiers\", \"()I\", false);\n+            JNIMethodId getFieldTypeId = agent.handles().getMethodId(jni, javaLangReflectField, \"getType\", \"()Ljava/lang/Class;\", false);\n+            // Add serialize and deserialize fields into reflection configs\n+            // Check each field", "originalCommit": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0MzI0NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472443245", "bodyText": "On second thought, is it even necessary to examine the fields here in the agent? It seems more straightforward to just do that during the image build for all classes in the serialization configuration and register their fields for reflective access then. That way, the reflective access to these fields is considered an implementation detail that does not need to be part of the reflection configuration files (unless they would be traced anyway).", "author": "peter-hofer", "createdAt": "2020-08-18T19:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYwMTk2MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472601961", "bodyText": "Agreed, I can move this part to build time. That would be cleaner and less overhead for agent.", "author": "ziyilin", "createdAt": "2020-08-19T02:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM0MTMwOA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472341308", "bodyText": "This check will also need to look at the caller to determine if it should be ignored (shouldApproveWithoutChecks). The verifiers are part of the agent's restriction mode (as opposed to its tracing mode), I can take care of this part if you prefer.", "author": "peter-hofer", "createdAt": "2020-08-18T16:53:44Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/restrict/SerializationAccessVerifier.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent.restrict;\n+\n+import com.oracle.svm.configure.config.SerializationConfiguration;\n+import com.oracle.svm.configure.trace.AccessAdvisor;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+\n+public class SerializationAccessVerifier extends AbstractAccessVerifier {\n+    private final SerializationConfiguration configuration;\n+\n+    public SerializationAccessVerifier(SerializationConfiguration configuration, AccessAdvisor advisor) {\n+        super(advisor);\n+        this.configuration = configuration;\n+    }\n+\n+    public boolean verifyGenerateSerializationConstructor(JNIEnvironment env, String serializationTargetClass, Object parameterTypes, Object checkedExceptions,\n+                    int modifiers, String targetConstructorClass) {", "originalCommit": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NjU0OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472876548", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-08-19T09:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM0MTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM0NjUxNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472346517", "bodyText": "Should be possible to replace with JavaKind.fromPrimitiveOrVoidTypeChar(s.chartAt(n)).getJavaName() with a check that n == s.length() - 1.", "author": "peter-hofer", "createdAt": "2020-08-18T17:01:59Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/TypeConfiguration.java", "diffHunk": "@@ -63,7 +64,44 @@ public ConfigurationType getOrCreateType(String qualifiedForNameString) {\n         }\n         if (n > 0) { // transform to Java source syntax\n             StringBuilder sb = new StringBuilder(s.length() + n);\n-            sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            if (s.charAt(n) == 'L' && s.charAt(s.length() - 1) == ';') {\n+                sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            } else {\n+                // Primitive Array\n+                String primitiveType = s.substring(n, s.length());\n+                switch (primitiveType) {\n+                    case \"I\":\n+                        s = \"int\";\n+                        break;\n+                    case \"F\":\n+                        s = \"float\";\n+                        break;\n+                    case \"J\":\n+                        s = \"long\";\n+                        break;\n+                    case \"D\":\n+                        s = \"double\";\n+                        break;\n+                    case \"Z\":\n+                        s = \"boolean\";\n+                        break;\n+                    case \"B\":\n+                        s = \"byte\";\n+                        break;\n+                    case \"S\":\n+                        s = \"short\";\n+                        break;\n+                    case \"C\":\n+                        s = \"char\";\n+                        break;\n+                    case \"V\":\n+                        s = \"void\";\n+                        break;\n+                    default:\n+                        throw new JSONParserException(\"Unrecognized primitive type \" + primitiveType);\n+                }", "originalCommit": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NjUyMg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472876522", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-08-19T09:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM0NjUxNw=="}], "type": "inlineReview"}, {"oid": "c6b5fe700fec84f703dc751bdc25a0ebe2b9aa14", "url": "https://github.com/oracle/graal/commit/c6b5fe700fec84f703dc751bdc25a0ebe2b9aa14", "message": "Support JDK serialization", "committedDate": "2020-08-19T08:48:06Z", "type": "forcePushed"}, {"oid": "5df952635dfee8e53ee01e1acf6532706c8462d5", "url": "https://github.com/oracle/graal/commit/5df952635dfee8e53ee01e1acf6532706c8462d5", "message": "Support JDK serialization", "committedDate": "2020-08-19T09:56:53Z", "type": "forcePushed"}, {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "url": "https://github.com/oracle/graal/commit/b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "message": "Support JDK serialization", "committedDate": "2020-08-19T11:23:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIyNTU2NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473225564", "bodyText": "Why the check for String[], isn't it a bug if this is not the case? It should probably be done in the caller and parameters here should have already type String[].", "author": "peter-hofer", "createdAt": "2020-08-19T18:06:17Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/restrict/SerializationAccessVerifier.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent.restrict;\n+\n+import com.oracle.svm.configure.config.SerializationConfiguration;\n+import com.oracle.svm.configure.trace.AccessAdvisor;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public class SerializationAccessVerifier extends AbstractAccessVerifier {\n+    private final SerializationConfiguration configuration;\n+\n+    public SerializationAccessVerifier(SerializationConfiguration configuration, AccessAdvisor advisor) {\n+        super(advisor);\n+        this.configuration = configuration;\n+    }\n+\n+    public boolean verifyGenerateSerializationConstructor(JNIEnvironment env, String serializationTargetClass, Object parameterTypes, Object checkedExceptions,\n+                                                          int modifiers, String targetConstructorClass, JNIObjectHandle queriedClass, JNIObjectHandle callerClass) {\n+        if (shouldApproveWithoutChecks(env, queriedClass, callerClass)) {\n+            return true;\n+        }\n+        return (parameterTypes instanceof String[] && checkedExceptions instanceof String[] &&\n+                        configuration.contains(serializationTargetClass, (String[]) parameterTypes, (String[]) checkedExceptions, modifiers, targetConstructorClass));", "originalCommit": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0Njg5NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473946894", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-08-20T12:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIyNTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIyODA0NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473228045", "bodyText": "Couldn't you make SerializationKey create its flattenString in JSON format and have it implement JsonPrintable and simply call it here?", "author": "peter-hofer", "createdAt": "2020-08-19T18:11:08Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/SerializationConfiguration.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.configure.config;\n+\n+import com.oracle.svm.configure.json.JsonPrintable;\n+import com.oracle.svm.configure.json.JsonWriter;\n+import com.oracle.svm.core.configure.SerializationKey;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationConfiguration implements JsonPrintable {\n+\n+    private final ConcurrentHashMap.KeySetView<SerializationKey<String>, Boolean> serializations = ConcurrentHashMap.newKeySet();\n+\n+    public void add(String serializationTargetClass, String[] parameterTypes, String[] checkedExceptions, int modifiers, String targetConstructorClass) {\n+        SerializationKey<String> key = new SerializationKey<>(serializationTargetClass, parameterTypes, checkedExceptions, modifiers, targetConstructorClass);\n+        add(key);\n+    }\n+\n+    public void add(SerializationKey<String> key) {\n+        serializations.add(key);\n+    }\n+\n+    public boolean contains(String serializationTargetClass, String[] parameterTypes, String[] checkedExceptions, int modifiers, String targetConstructorClass) {\n+        SerializationKey<String> key = new SerializationKey<>(serializationTargetClass, parameterTypes, checkedExceptions, modifiers, targetConstructorClass);\n+        return serializations.contains(key);\n+    }\n+\n+    @Override\n+    public void printJson(JsonWriter writer) throws IOException {\n+        writer.append('[').indent();\n+        String prefix = \"\";\n+        for (SerializationKey<String> skey : serializations) {\n+            writer.append(prefix).newline().append('{');\n+            writer.newline();\n+            String typePrefix = \"\";\n+            writer.quote(\"name\").append(\":\").quote(skey.getSerializationTargetClass()).append(\",\").newline();\n+            writer.quote(\"parameterTypes\").append(\":\").append('[');\n+            for (String parameterType : skey.getParameterTypes()) {\n+                writer.append(typePrefix).quote(parameterType);\n+                typePrefix = \",\";\n+            }\n+            writer.append(']').append(\",\").newline();\n+\n+            typePrefix = \"\";\n+            writer.quote(\"checkedExceptions\").append(\":\").append('[');\n+            for (String checkedException : skey.getCheckedExceptions()) {\n+                writer.append(typePrefix).quote(checkedException);\n+                typePrefix = \",\";\n+            }\n+            writer.append(']').append(\",\").newline();\n+\n+            writer.quote(\"modifiers\").append(':').append(Integer.toString(skey.getModifiers())).append(\",\").newline();\n+            writer.quote(\"targetConstructorClass\").append(':').quote(skey.getTargetConstructorClass()).newline();\n+            writer.append('}');", "originalCommit": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzODQ1NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473938455", "bodyText": "Fixed. But SerializationKey is located in com.svm.core which should not have dependency on com.oracle.svm.configure where  JsonPrintable is located, so I created a sub class of  SerializationKey in com.oracle.svm.configure  to print json.", "author": "ziyilin", "createdAt": "2020-08-20T12:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIyODA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473230002", "bodyText": "Why are these necessary? These rules should cause reflective accesses from the various stream classes to end up in the reflection configuration, but these should be considered implementation details of serialization/deserialization on native-image and we would already register accessible fields separately.", "author": "peter-hofer", "createdAt": "2020-08-19T18:14:51Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/AccessAdvisor.java", "diffHunk": "@@ -78,6 +78,11 @@\n \n         internalCallerFilter.addOrGetChildren(\"org.graalvm.compiler.**\", RuleNode.Inclusion.Exclude);\n         internalCallerFilter.addOrGetChildren(\"org.graalvm.libgraal.**\", RuleNode.Inclusion.Exclude);\n+\n+        // For serializations\n+        internalCallerFilter.addOrGetChildren(\"java.io.ObjectInputStream\", RuleNode.Inclusion.Include);\n+        internalCallerFilter.addOrGetChildren(\"java.io.ObjectOutputStream\", RuleNode.Inclusion.Include);\n+        internalCallerFilter.addOrGetChildren(\"java.io.ObjectStreamClass\", RuleNode.Inclusion.Include);", "originalCommit": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU3NTUwOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473575509", "bodyText": "These rules are included because not all serialization/deserialization calls go to MethodAccessorGeneretor.generateSerializationConstructor. While serializing/deserializing Arrays, Enums, Externalizable classes and classes without proper super constructors, MethodAccessorGeneretor.generateSerializationConstructor will not be invoked (more details can be seen at private ObjectStreamClass(final Class<?> cl) ) .\nIf these rules should not get included, I need to install a new method break point on  private ObjectStreamClass(final Class<?> cl) to cover all target class of serialization/deserialization.", "author": "ziyilin", "createdAt": "2020-08-20T04:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA3MTQ4MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r474071480", "bodyText": "I think it would be preferable to go only through ObjectStreamClass(Class<?>) in general. Currently, as I understand it, both the reflection and serialization configuration files need certain entries to enable object serialization and deserialization. This is not much of a problem when serialization/deserialization at runtime does the exact same things that the agent was able to observe prior, but if the user wants to add a class for serialization that has not been observed by the agent, he/she likely needs to add reflection configuration entries as well. Ideally, I would want these reflection accesses to be implementation details, so that a serialization configuration can look as simple as the following, and code during the image build takes care to register everything necessary, like it is now the case with fields:\n[\n  {  \"name\":\"com.oracle.ClassA\"  },\n  {  \"name\":\"com.oracle.ClassB\"  }\n]", "author": "peter-hofer", "createdAt": "2020-08-20T15:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYwOTA4OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r474609088", "bodyText": "Fixed with a method break point on ObjectStreamClass(Class<?>) instead of generateSerializationConstructor.\nHowever, only the serialization target class information is not sufficient to generate SerializationConstructorAccessor class at build time, so configuration looks like:\n[  \n{\n  \"name\":\"java.lang.String\",\n  \"parameterTypes\":[],\n  \"checkedExceptions\":[],\n  \"modifiers\":1,\n  \"targetConstructorClass\":\"java.lang.Object\"\n  }\n]\n\nparameterTypes, checkedExceptions, modifiers and targetConstructorClass are all for calling generateSerializationConstructor at build time.", "author": "ziyilin", "createdAt": "2020-08-21T10:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwMTQyNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r475701424", "bodyText": "Thanks!\nShouldn't the serialization constructor and other members of an ObjectStreamClass for a specific Class<?> always be the same? If so, then we could (through reflection itself, or via JVMCI) instantiate a specific ObjectStreamClass during the image build, and read its cons, fields, readObjectMethod, ... fields and register these members for reflective access. But actually, maybe registering the members is not even necessary, just having the ObjectStreamClass instances on the image heap could be enough so that everything will be readily accessible at runtime. Since all accesses go through static method ObjectStreamClass.lookup, we could substitute that method to access the collection of ObjectStreamClass instances created during the image build. The same probably applies to ObjectStreamClass.getReflector. We can then probably substitution-delete the Caches class because there is no longer a need for a mutable cache.", "author": "peter-hofer", "createdAt": "2020-08-24T15:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NDAyMQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r476784021", "bodyText": "I experimented a bit with the code today to try (most of) the changes I described: f531e52\nPreparing the collection of ObjectStreamClass objects during the image build works, but then the generated constructors generate the wrong type of object at image runtime, such as just java.lang.Object instead of the specific subclass. Invoking the constructor at image build time in the debugger instantiates the correct class, however. Maybe this is what you hinted at earlier, but I don't quite understand why parameterTypes, checkedExceptions, modifiers and targetConstructorClass would be different between the run with the agent and with the image build.", "author": "peter-hofer", "createdAt": "2020-08-25T22:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NTU3OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r477195579", "bodyText": "I've run the tests in tests.zip with your patch and here's the result:\n\ntestCustomizedClassSerialize.sh crashed at run time. This test serializes and deserializes a class with multiple types of fields. The last stack traces are:\n\nStacktrace Stage 2:\n\n  SP 00007ffd299e91f0 IP 0000000000509fe9  com.oracle.svm.core.code.CodeInfo@0x7f4d58f04860 name = image code\n  SP 00007ffd299e9250 IP 00000000005045a6  [image code] java.io.ObjectStreamClass.getObjFieldValues(ObjectStreamClass.java:1413)\n  SP 00007ffd299e9250 IP 00000000005045a6  [image code] java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1544)\n\nThis crash suggests storing ObjectStreamClass alone at build time in the native heap is not sufficient. ObjectStreamClass 's inner classes are also required to get stored at build time.\n\ntestSerializeArrayList.sh failed with an exception. This test serializes and deserializes the ArrayList class. The exception message is:\n\nCaused by: java.lang.InstantiationException: Cannot instantiate class java.util.AbstractList\n        at java.lang.reflect.Constructor.newInstance(Constructor.java:490)\n        at java.io.ObjectStreamClass.newInstance(ObjectStreamClass.java:1092)\n        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2150)\n\nThe ArrayList class doesn't have so complicated fields as the previous one, so it goes further at runtime. This failure suggests the first unserializable super class of the serialization target class is not prepared at build time. This can be fixed by registering the ObjectStreamClass's cons field into reflectionData at build time.\n\ntestDeserializeStream.sh passed because it deserializes a class of float array, which doesn't have field nor serialization constructor.\n\nFrom the above tests result I think storing ObjectStreamClass in native heap is doable for general cases, but it will fail when any of parameterTypes, checkedExceptions, modifiers and targetConstructorClass is different between agent run time and image build time. This happens when two same name classes with different parameterTypes, checkedExceptions, modifiers or targetConstructorClass are loaded by different classloaders. The native-image can't do the same thing at build time. The test case testDeserializeMultiClassloader.sh in test.zip shows such a case. When all information is kept in the configurations, we can detect such error at image build time and report for the users. According to our adaption experience, reporting error at an early stage saves much time for users than to debug error at run time.", "author": "ziyilin", "createdAt": "2020-08-26T10:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4MTAzNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r480381036", "bodyText": "My patch with build-time ObjectStreamClass is incomplete so failing tests are expected. I have looked into the object instantiation problems further: during the image build, we substitute reflective newInstance with a generated ReflectiveNewInstanceMethod that creates and initializes the object directly without the serialization constructor accessor. Because the serialization constructor is injected into a superclass, our substitution instantiates the wrong class and uses the wrong constructor. I managed to get around that in my updated changes in 7241133, although I still see an aliasing bug between serialization constructors that can break deserialization.\nThe next issue I encountered is that creating an ObjectStreamClass ahead of time will record the object field offsets in FieldReflector during the image build, which can be different from the offsets at image runtime. This can be fixed too of course, but this and other cases probably make creating an ObjectStreamClass at runtime the simpler option. With that variant, the ObjectStreamClass.Caches members should be cleared via @RecomputeFieldValue(kind = NewInstance). This also goes for members of ObjectInputStream.Caches and ObjectOutputStream.Caches and possibly other classes.\nConcerning the multiple class loaders, is it really a common issue to have multiple class loaders that load different classes with the same name for serialization where parameterTypes, checkedExceptions, modifiers or targetConstructorClass differ? Wouldn't it be preferable to include a hash (or just size) or the serialVersionUID of a (de)serializable class in an agent-generated configuration and either print a warning or abort if they mismatch during the image build? (I believe this should be optional in the configuration file)", "author": "peter-hofer", "createdAt": "2020-08-31T20:28:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDY0ODM1OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r480648358", "bodyText": "Concerning the multiple class loaders, is it really a common issue to have multiple class loaders that load different classes with the same name for serialization where parameterTypes, checkedExceptions, modifiers or targetConstructorClass differ?\n\nIt is not common, but we must assure the correctness. One approach is to report multi-classloader usage issue at Agent run time, then we don't need the extra information in configuration file to check at build time. In that case, only keep serialization target class should be sufficient.", "author": "ziyilin", "createdAt": "2020-09-01T02:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxMTg1Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r481311853", "bodyText": "Output from the agent is likely to remain unseen among the output of the observed application, so I would avoid that.\nI still don't quite understand how keeping these four values around helps to identify when different classes are loaded by multiple class loaders. Unless their class hierarchy differs, wouldn't similar classes have identical serialization constructors? For example, if two class loaders load different versions of a class, one of which has an extra field, would that still be detected? And if so, what about when two class loaders load an identical class? I think that is quite possible in very modular applications. Since it is possible that the class path for the image build is different from the application running with the agent, shouldn't a check like this apply to the serialized class itself in the form of a hash code or its serializationVersionUID?", "author": "peter-hofer", "createdAt": "2020-09-01T17:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgwNDYxNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r481804617", "bodyText": "SerializationConstructorAccessor class differs only when class hierarchy changes, while it is not affected by the change of class contents.\nJDK caches ObjectStreamClass instances in ObjectStreamClass.Caches.localDescs which takes the serialization target class' identityHashcode as part of its hash value. Therefore, any different class instances (e.g. same name different hierarchy classes, identical classes loaded by different classloaders) will have their own ObjectStreamClass instances, leading to a creation of new SerializationConstructorAccessor class.\nWe wouldn't support the same name different hierarchy case. Using a checksum like hashcode or serializationVersionUID in configuration can help to tell the different and report issue at build time.\nWe can allow the multiple loading of identical class case. Sharing the same ObjectStreamClass should be fine for them. But hashcode is not suitable for this case, because classes loaded by different classloaders have different hashcodes.  But their serializationVersionUID should be same.\nSo serializationVersionUID is good to use as checksum, but not directly use the class's serializationVersionUID field, because user can set an unchanged serializationVersionUID value event the contents or hierarchy are changed. We can apply the serializationVersionUID's calculation algorithm to set a checksum and verify it through image build time and image run time.\nI think creating ObjectStreamClass at image run time is safer and simpler. We can use serialization target class to create and cache SerializationConstructorAccessor class at build time, and use serializationVersionUID algorithmed checksum to verify the class is identical from Agent run time to image build time and image run time.\nI'll make this change if it sounds good to you.", "author": "ziyilin", "createdAt": "2020-09-02T06:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5NjM4MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r481996381", "bodyText": "I think creating ObjectStreamClass at image run time is safer and simpler. We can use serialization target class to create and cache SerializationConstructorAccessor class at build time, and use serializationVersionUID algorithmed checksum to verify the class is identical from Agent run time to image build time and image run time.\n\nYes, that sounds good to me. I agree about using the hash generated by computeDefaultSUID because I also think that users often don't maintain the serialVersionUID field properly when modifying the class. I would avoid the term \"version UID\" in though because it sounds confusing. Instead, I would call it something like classHashCode. The configuration entry would then look like this the following. If the hash code doesn't match the one computed during the image build, then the build should fail. It should be possible to not provide a hash code in the configuration and pass the build however.\n[\n  {  \"name\":\"com.oracle.ClassA\", \"classHashCode\":-6949620193861773680  },\n  {  \"name\":\"com.oracle.ClassB\", \"classHashCode\":1215806704639619402  }\n]", "author": "peter-hofer", "createdAt": "2020-09-02T11:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzM4NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r482003385", "bodyText": "Maybe a simply checksum would be good.", "author": "ziyilin", "createdAt": "2020-09-02T11:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3MzYwMQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r482073601", "bodyText": "Yes, checksum is even better. I suppose hash code sounds like it is related to Object.hashCode.", "author": "peter-hofer", "createdAt": "2020-09-02T13:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjMxMQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r484202311", "bodyText": "I have committed a modified version. In this version, the checksum is calculated from the serialization constructor class for class hierarchy verification. As the ObjectStreamClass instance is created at image run time, the only thing required to cache at build time is SerializationConstructorAccessor class which is affected by serialization target class and serialization constructor class. Therefore, given the same serialization target class name, checksum on constructor class name is sufficient to distinguish SerializationConstructorAccessor class.\nTwo options -H:+AllowUncheckedSerialization and -R:+AllowUncheckedSerialization are provided to skip checking checksum if user provides a serialization configuration without setting checksum.", "author": "ziyilin", "createdAt": "2020-09-07T06:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDMyNQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473230325", "bodyText": "Is this still needed now that the fake reflection events are gone?", "author": "peter-hofer", "createdAt": "2020-08-19T18:15:25Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/ReflectionProcessor.java", "diffHunk": "@@ -145,7 +145,8 @@ public void processEntry(Map<String, ?> entry) {\n                 memberKind = ConfigurationMemberKind.DECLARED;\n                 // fall through\n             case \"getField\": {\n-                configuration.getOrCreateType(clazzOrDeclaringClass).addField(singleElement(args), memberKind, false, unsafeAccess);\n+                configuration.getOrCreateType(clazzOrDeclaringClass).addField(singleElement(args), memberKind, entry.containsKey(\"allowWrite\") ? (Boolean) entry.get(\"allowWrite\") : false,\n+                                entry.containsKey(\"unsafeAccess\") ? (Boolean) entry.get(\"unsafeAccess\") : unsafeAccess);", "originalCommit": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU3NTg3MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473575871", "bodyText": "not necessary now, I'll revert the change.", "author": "ziyilin", "createdAt": "2020-08-20T04:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MDY2Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473250662", "bodyText": "I think this information can be easily merged into ClassInitializationInfo above by creating another constant like INITIALIZED_INFO_SINGLETON, for example NO_INITIALIZER_INFO_SINGLETON. This way, not every DynamicHub needs to have this extra field.", "author": "peter-hofer", "createdAt": "2020-08-19T18:53:54Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -266,6 +266,12 @@\n      */\n     private ClassInitializationInfo classInitializationInfo;\n \n+    /**\n+     * Indicates if this class originally has a <clinit> method. It is used for serialization\n+     * support.\n+     */\n+    private boolean hasCLinit;", "originalCommit": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgwNjgyNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473806824", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-08-20T09:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MDY2Mg=="}], "type": "inlineReview"}, {"oid": "9ba52977628ed9ecd107dda93ae3b15f80d591ac", "url": "https://github.com/oracle/graal/commit/9ba52977628ed9ecd107dda93ae3b15f80d591ac", "message": "Support JDK serialization", "committedDate": "2020-08-20T09:22:14Z", "type": "forcePushed"}, {"oid": "bdf3f6d2f515516065394168fb28bebe174c6a10", "url": "https://github.com/oracle/graal/commit/bdf3f6d2f515516065394168fb28bebe174c6a10", "message": "Support JDK serialization", "committedDate": "2020-08-20T12:37:15Z", "type": "forcePushed"}, {"oid": "b83c4e0fa7cb44a96700d5cad4f5dfa978caf63b", "url": "https://github.com/oracle/graal/commit/b83c4e0fa7cb44a96700d5cad4f5dfa978caf63b", "message": "Support JDK serialization", "committedDate": "2020-08-20T12:53:48Z", "type": "forcePushed"}, {"oid": "13c898bda3da7dd8b16564f7ab37f2459737f9f1", "url": "https://github.com/oracle/graal/commit/13c898bda3da7dd8b16564f7ab37f2459737f9f1", "message": "Support JDK serialization", "committedDate": "2020-08-21T09:32:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4NDgwNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r475884807", "bodyText": "Do all fields, constructors and methods really need to be registered? It seems to me that only those that are singled out in the ObjectStreamClass(Class<?>) constructor are really relevant. But that might be irrelevant with the approach of populating a collection of ObjectStreamClass at build time.", "author": "peter-hofer", "createdAt": "2020-08-24T20:48:05Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, srtParameterTypes, srtCheckedExceptions, modifiers, strTargetConstructorClass) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            Class<?>[] parameterTypes = Arrays.stream(srtParameterTypes).map(parameterType -> resolveClass(parameterType, imageClassLoader)).toArray(Class[]::new);\n+            Class<?>[] checkedExceptions = Arrays.stream(srtCheckedExceptions).map(parameterType -> resolveClass(parameterType, imageClassLoader)).toArray(Class[]::new);\n+            Class<?> targetConstructor = strTargetConstructorClass.length() == 0 ? null : resolveClass(strTargetConstructorClass, imageClassLoader);\n+            if (targetConstructor != null) {\n+                serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, parameterTypes, checkedExceptions, modifiers, targetConstructor);\n+            }\n+            addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        String exceptionsMsg = serializationSupport.collectMultiDefinitions();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            System.out.println(exceptionsMsg);\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(\"Unsupported dynamic features\", null,\n+                                \"To allow continuing compilation with above unsupported features, set \" +\n+                                                SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\"));\n+            } else {\n+                System.out.println(\"Compilation will continue because \" + SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\") +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            reflectionData.register(targetConstructor.getDeclaredConstructors());\n+        }\n+        reflectionData.register(serializationTargetClass);\n+        for (Field f : serializationTargetClass.getDeclaredFields()) {\n+            int modifiers = f.getModifiers();\n+            boolean allowWrite = false;\n+            boolean allowUnsafeAccess = false;\n+            if (!(Modifier.isFinal(modifiers) && Modifier.isStatic(modifiers))) {\n+                allowWrite = Modifier.isFinal(f.getModifiers());\n+                allowUnsafeAccess = !Modifier.isStatic(f.getModifiers());\n+            }\n+            reflectionData.register(allowWrite, allowUnsafeAccess, f);\n+        }\n+        reflectionData.register(serializationTargetClass.getDeclaredMethods());\n+        reflectionData.register(serializationTargetClass.getDeclaredConstructors());\n+    }", "originalCommit": "13c898bda3da7dd8b16564f7ab37f2459737f9f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1NTU2MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r477255560", "bodyText": "ObjectStreamClass.computeDefaultSUID calls getDeclaredMethods, getDeclaredFields and getDeclaredConstructors to calculate serializationUID when it's absent.\nObjectStreamClass.getDefaultSerialFields calls getDeclaredFields to collect all fields that can be serialized.\nTo sum sup, all constructors, fields and methods are conditionally required in ObjectStreamClass.", "author": "ziyilin", "createdAt": "2020-08-26T12:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4NDgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM2OTY3MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r480369670", "bodyText": "Thanks for clarifying!", "author": "peter-hofer", "createdAt": "2020-08-31T20:06:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4NDgwNw=="}], "type": "inlineReview"}, {"oid": "38b16049e35fa97bdaec7463865525a56e89a678", "url": "https://github.com/oracle/graal/commit/38b16049e35fa97bdaec7463865525a56e89a678", "message": "Support JDK serialization", "committedDate": "2020-08-26T14:44:47Z", "type": "forcePushed"}, {"oid": "f0d49c2393a59a516efc213449368fc3a367209f", "url": "https://github.com/oracle/graal/commit/f0d49c2393a59a516efc213449368fc3a367209f", "message": "Support JDK serialization", "committedDate": "2020-08-27T03:40:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE0MTExOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r478141119", "bodyText": "Should it present License lines here?", "author": "mingjliu9", "createdAt": "2020-08-27T05:33:12Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.oracle.svm.reflect.serialize;", "originalCommit": "f0d49c2393a59a516efc213449368fc3a367209f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE1NTI0OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r478155248", "bodyText": "Thanks, fixed", "author": "ziyilin", "createdAt": "2020-08-27T05:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE0MTExOQ=="}], "type": "inlineReview"}, {"oid": "c4b118335f579e16f358eb32fa42afb34e536da7", "url": "https://github.com/oracle/graal/commit/c4b118335f579e16f358eb32fa42afb34e536da7", "message": "Support JDK serialization", "committedDate": "2020-08-27T05:54:48Z", "type": "forcePushed"}, {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "url": "https://github.com/oracle/graal/commit/b4c3dee22257d87c46be18eb6980f1ff2f294f16", "message": "Support JDK serialization", "committedDate": "2020-09-07T05:44:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxNTQxNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488715414", "bodyText": "This method seems to be no longer needed.", "author": "peter-hofer", "createdAt": "2020-09-15T14:31:08Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/ConfigurationParser.java", "diffHunk": "@@ -71,4 +71,22 @@ protected static boolean asBoolean(Object value, String propertyName) {\n         }\n         throw new JSONParserException(\"Invalid boolean value '\" + value + \"' for element '\" + propertyName + \"'\");\n     }\n+\n+    protected static int asInteger(Object value, String propertyName) {\n+        if (value instanceof Integer) {\n+            return (int) value;\n+        }\n+        throw new JSONParserException(\"Invalid int value '\" + value + \"' for element '\" + propertyName + \"'\");\n+    }", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzMjM1NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489132355", "bodyText": "removed", "author": "ziyilin", "createdAt": "2020-09-16T03:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxNTQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxODcyMw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488718723", "bodyText": "This test should compare the checksum as well.", "author": "peter-hofer", "createdAt": "2020-09-15T14:35:09Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/restrict/SerializationAccessVerifier.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent.restrict;\n+\n+import com.oracle.svm.configure.config.SerializationConfiguration;\n+import com.oracle.svm.configure.trace.AccessAdvisor;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public class SerializationAccessVerifier extends AbstractAccessVerifier {\n+    private final SerializationConfiguration configuration;\n+\n+    public SerializationAccessVerifier(SerializationConfiguration configuration, AccessAdvisor advisor) {\n+        super(advisor);\n+        this.configuration = configuration;\n+    }\n+\n+    public boolean verifyObjectStreamClassConstructor(JNIEnvironment env, String serializationTargetClass, JNIObjectHandle queriedClass, JNIObjectHandle callerClass) {\n+        if (shouldApproveWithoutChecks(env, queriedClass, callerClass)) {\n+            return true;\n+        }\n+        return configuration.contains(serializationTargetClass);", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk2ODAxNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489968017", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T04:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxODcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcyOTc5OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488729798", "bodyText": "Please revert so that RuntimeReflectionSupport is registered only here and use the API class RuntimeReflection to register members for reflective access elsewhere.", "author": "peter-hofer", "createdAt": "2020-09-15T14:49:22Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/hosted/ReflectionFeature.java", "diffHunk": "@@ -62,8 +62,12 @@ public void duringSetup(DuringSetupAccess a) {\n         access.registerSubstitutionProcessor(subst);\n         ImageSingletons.add(ReflectionSubstitution.class, subst);\n \n-        reflectionData = new ReflectionDataBuilder(access);\n-        ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNDc2MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489914761", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcyOTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODczMDg4OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488730889", "bodyText": "Please use RuntimeReflection to register classes and members for reflection and not ReflectionDataBuilder directly. You will have an initialization race with ReflectionFeature, but you can delay parsing serialization configuration until beforeAnalysis.", "author": "peter-hofer", "createdAt": "2020-09-15T14:50:47Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNDgwNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489914806", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODczMDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODczMjAyNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488732024", "bodyText": "Features are initialized only once, so you can unconditionally register SerializationRegistry here.", "author": "peter-hofer", "createdAt": "2020-09-15T14:52:17Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNDg1MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489914850", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODczMjAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NTA1NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488775055", "bodyText": "So a checksum in the configuration is really just the hash code of the name of the declaring class of the generated serialization constructor, right? What kind of guarantees do the checks during the image build provide based on this? From my experiments, I remember that the declaring class of a generated serialization constructor is just a superclass of the target class, like Object, so I would expect that hash codes would be the same for different class loaders. Why not use computeDefaultSUID as discussed earlier?", "author": "peter-hofer", "createdAt": "2020-09-15T15:49:18Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +918,52 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    private static boolean objectStreamClassConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        long checksum = 0;\n+\n+        JNIObjectHandle objectStreamClassInstance = newObjectL(jni, bp.clazz, bp.method, serializeTargetClass);\n+        Object result = nullHandle().notEqual(objectStreamClassInstance);\n+        if (clearException(jni)) {\n+            result = false;\n+        }\n+        if (result.equals(true)) {\n+            JNIObjectHandle cons = getObjectField(jni, bp.clazz, objectStreamClassInstance, \"cons\", \"Ljava/lang/reflect/Constructor;\");\n+            String targetConstructorClassName = \"\";\n+            if (nullHandle().notEqual(cons)) {\n+                JNIObjectHandle constructorClazz = jniFunctions().getGetObjectClass().invoke(jni, cons);\n+                try (CCharPointerHolder getDeclaringClassNameHolder = toCString(\"getDeclaringClass\");\n+                                CCharPointerHolder getDeclaringClassSigHolder = toCString(\"()Ljava/lang/Class;\");) {\n+                    JNIMethodId getDeclaringClassMId = jniFunctions().getGetMethodID().invoke(jni, constructorClazz, getDeclaringClassNameHolder.get(), getDeclaringClassSigHolder.get());\n+                    targetConstructorClassName = getClassNameOrNull(jni, callObjectMethod(jni, cons, getDeclaringClassMId));\n+                    checksum = targetConstructorClassName.hashCode();", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE1NTk4OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489155989", "bodyText": "The constructor's declaring class is not just the superclass. It is the first unserializable super class. The hashcode is enough to tell whether the constructor's declaring class has been changed which may happen if the class' hierarchy is changed among different classloaders.\nI examined the source code of JDK's MethodAccessorGenerator.generateSerializationConstructor(Class<?> declaringClass, Class<?>[] parameterTypes, Class<?>[] checkedExceptions, int modifiers, Class<?> targetConstructorClass) and found the returned SerializationConstructorAccessor instance is determined only by the names of declaringClass(serialization target class) and targetConstructorClass(the first unserializable super class).\nFor example, the following bytecode is from the SerializationConstructorAccessor class generated for java.lang.String. Only instructor 0 and 24 are differed from classes. Instruction 0 new declaringClass and instruction 24 invoke targetConstructorClass's non-parameter-constructor.\n public java.lang.Object newInstance(java.lang.Object[]) throws java.lang.reflect.InvocationTargetException;\n    descriptor: ([Ljava/lang/Object;)Ljava/lang/Object;\n    flags: ACC_PUBLIC\n    Code:\n      stack=6, locals=2, args_size=2\n         0: new           #6                  // class java/lang/String\n         3: dup\n         4: aload_1\n         5: ifnull        24\n         8: aload_1\n         9: arraylength\n        10: sipush        0\n        13: if_icmpeq     24\n        16: new           #22                 // class java/lang/IllegalArgumentException\n        19: dup\n        20: invokespecial #29                 // Method java/lang/IllegalArgumentException.\"<init>\":()V\n        23: athrow\n        24: invokespecial #12                 // Method java/lang/Object.\"<init>\":()V\n        27: areturn\n        28: invokespecial #42                 // Method java/lang/Object.toString:()Ljava/lang/String;\n        31: new           #22                 // class java/lang/IllegalArgumentException\n        34: dup_x1\n        35: swap\n        36: invokespecial #32                 // Method java/lang/IllegalArgumentException.\"<init>\":(Ljava/lang/String;)V\n        39: athrow\n        40: new           #24                 // class java/lang/reflect/InvocationTargetException\n        43: dup_x1\n        44: swap\n        45: invokespecial #35                 // Method java/lang/reflect/InvocationTargetException.\"<init>\":(Ljava/lang/Throwable;)V\n        48: athrow\n\n\nWhile computeDefaultSUID calculates a checksum based on nearly every thing of declaringClass, so we should not use it to match the cached SerializationConstructorAccessor.", "author": "ziyilin", "createdAt": "2020-09-16T04:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NTA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3NzUxMA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r495077510", "bodyText": "Thanks for explaining. So we can tell whether the constructor that we generate during the image build matches the constructor from the agent run, but we cannot tell whether the serializable/deserializable class we have for the image build is the same as the ones seen during the agent run, unless their first unserializable superclass is different.\nIs this really sufficient? Why not just use a computed SUID and ensure that we have an exact match? I'm wondering about the specific use case here, and also worry about extensibility of the configuration in case we want to include more per-class information in the future and want to ensure an exact match for that.", "author": "peter-hofer", "createdAt": "2020-09-25T15:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NTA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTA2OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r502775069", "bodyText": "I have applied the computed SUID. Not only the serialization target class itself's SUID is needed, all its serializable superclasses' SUIDs are also needed.", "author": "ziyilin", "createdAt": "2020-10-10T10:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNzUyNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488827526", "bodyText": "hasInitializer should be sufficient. This is unrelated to the JDK too (it could be any class) and we don't need to mention serializationVersionUID here.", "author": "peter-hofer", "createdAt": "2020-09-15T17:11:02Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/classinitialization/ClassInitializationInfo.java", "diffHunk": "@@ -124,18 +130,37 @@\n      */\n     private Condition initCondition;\n \n+    /**\n+     * Indicates if the class has a {@code <clinit>} method in its original JDK version, no matter\n+     * if it should be initialized at native image's build time or run time . It is used for\n+     * calculating serializationUID when it was not set.\n+     */\n+    private boolean hasOriginalInitializer;", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNDkxNQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489914915", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNzUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNzgwMg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488827802", "bodyText": "Please name hasInitializer, no trouble if it has the same name as the field.", "author": "peter-hofer", "createdAt": "2020-09-15T17:11:35Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/classinitialization/ClassInitializationInfo.java", "diffHunk": "@@ -124,18 +130,37 @@\n      */\n     private Condition initCondition;\n \n+    /**\n+     * Indicates if the class has a {@code <clinit>} method in its original JDK version, no matter\n+     * if it should be initialized at native image's build time or run time . It is used for\n+     * calculating serializationUID when it was not set.\n+     */\n+    private boolean hasOriginalInitializer;\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    private ClassInitializationInfo(InitState initState, boolean hasOriginalInitializer) {\n+        this(initState);\n+        this.hasOriginalInitializer = hasOriginalInitializer;\n+    }\n+\n     @Platforms(Platform.HOSTED_ONLY.class)\n     private ClassInitializationInfo(InitState initState) {\n         this.classInitializer = null;\n         this.initState = initState;\n         this.initLock = initState == InitState.FullyInitialized ? null : new ReentrantLock();\n+        this.hasOriginalInitializer = true;\n     }\n \n     @Platforms(Platform.HOSTED_ONLY.class)\n     public ClassInitializationInfo(CFunctionPointer classInitializer) {\n         this.classInitializer = classInitializer == null || classInitializer.isNull() ? null : new ClassInitializerFunctionPointerHolder(classInitializer);\n         this.initState = InitState.Linked;\n         this.initLock = new ReentrantLock();\n+        this.hasOriginalInitializer = true;\n+    }\n+\n+    public boolean isHasOriginalInitializer() {", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNDk3MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489914971", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNjIyNQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488836225", "bodyText": "These can be final.", "author": "peter-hofer", "createdAt": "2020-09-15T17:23:33Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/SerializationKey.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.configure;\n+\n+public class SerializationKey {\n+    private String serializationTargetClass;\n+    private Long checksum;", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTAwNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915006", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNjIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNzUwNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488837506", "bodyText": "This should be Target_jdk_internal_reflect_SerializationConstructorAccessorImpl.", "author": "peter-hofer", "createdAt": "2020-09-15T17:24:45Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_jdk_internal_reflect_AccessorGenerator.java", "diffHunk": "@@ -24,15 +24,28 @@\n  */\n package com.oracle.svm.core.jdk;\n \n-import com.oracle.svm.core.annotate.Delete;\n+import com.oracle.svm.core.annotate.Substitute;\n import com.oracle.svm.core.annotate.TargetClass;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import org.graalvm.nativeimage.ImageSingletons;\n \n-@Delete\n @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"AccessorGenerator\")\n public final class Target_jdk_internal_reflect_AccessorGenerator {\n }\n \n-@Delete\n @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"MethodAccessorGenerator\")\n final class Target_jdk_internal_reflect_MethodAccessorGenerator {\n+    @Substitute\n+    public Target_SerializationConstructorAccessorImpl generateSerializationConstructor(Class<?> declaringClass,\n+                    Class<?>[] parameterTypes,\n+                    Class<?>[] checkedExceptions,\n+                    int modifiers,\n+                    Class<?> targetConstructorClass) {\n+        SerializationRegistry serializationRegistry = ImageSingletons.lookup(SerializationRegistry.class);\n+        return (Target_SerializationConstructorAccessorImpl) serializationRegistry.getSerializationConstructorAccessorClass(declaringClass, targetConstructorClass.getName());\n+    }\n+}\n+\n+@TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"SerializationConstructorAccessorImpl\")\n+final class Target_SerializationConstructorAccessorImpl {", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTA1Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915052", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMTMwMA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488901300", "bodyText": "Class MethodAccessorGenerator is an implementation detail of object serialization, so the location from where it is used will not be very helpful to users. I think it would be more helpful to check for ObjectInputStream.readObject, .readUnshared, and ObjectOutputStream.writeObject, .writeUnshared (and maybe their String variants).", "author": "peter-hofer", "createdAt": "2020-09-15T19:04:52Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/FallbackFeature.java", "diffHunk": "@@ -167,7 +169,11 @@ public FallbackFeature() {\n             addCheck(Proxy.class.getMethod(\"newProxyInstance\", ClassLoader.class, Class[].class, InvocationHandler.class), this::collectProxyInvokes);\n \n             addCheck(System.class.getMethod(\"loadLibrary\", String.class), this::collectJNIInvokes);\n-        } catch (NoSuchMethodException e) {\n+\n+            Class<?> generatorClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".MethodAccessorGenerator\");\n+            Method generateMethod = generatorClass.getMethod(\"generateSerializationConstructor\", Class.class, Class[].class, Class[].class, int.class, Class.class);\n+            addCheck(generateMethod, this::collectSerializationInvokes);", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTE0MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915141", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMTMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMjgwNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488902807", "bodyText": "Most of the declarations in this file are probably no longer needed, please back them out for a smaller patch.", "author": "peter-hofer", "createdAt": "2020-09-15T19:07:34Z", "path": "substratevm/src/com.oracle.svm.jni/src/com/oracle/svm/jni/nativeapi/JNIFunctionPointerTypes.java", "diffHunk": "@@ -212,6 +217,31 @@\n         CCharPointer invoke(JNIEnvironment env, JNIObjectHandle byteArray, CCharPointer elements, int mode);\n     }\n \n+    public interface CallObjectMethod0FunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        JNIObjectHandle invoke(JNIEnvironment env, JNIObjectHandle objOrClass, JNIMethodId methodID);\n+    }\n+\n+    public interface CallIntMethodFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        int invoke(JNIEnvironment env, JNIObjectHandle objOrClass, JNIMethodId methodID);\n+    }\n+\n+    public interface GetObjectFieldFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        JNIObjectHandle invoke(JNIEnvironment env, JNIObjectHandle obj, JNIFieldId fieldId);\n+    }\n+\n+    public interface CallStaticLongMethodAFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        long invoke(JNIEnvironment env, JNIObjectHandle clazz, JNIMethodId methodID, JNIValue args);\n+    }\n+\n+    public interface CallStaticObjectMethodAFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        JNIObjectHandle invoke(JNIEnvironment env, JNIObjectHandle clazz, JNIMethodId methodID, JNIValue args);\n+    }\n+", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTI0NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915244", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMjgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNDEzMA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488904130", "bodyText": "This should be consistent with the other methods and not throw an exception. It could be solved by passing in a CIntPointer from the caller and returning a boolean whether it was successful. Also, the variable should not be called handlePtr since it does not contain a handle.", "author": "peter-hofer", "createdAt": "2020-09-15T19:10:00Z", "path": "substratevm/src/com.oracle.svm.jvmtiagentbase/src/com/oracle/svm/jvmtiagentbase/Support.java", "diffHunk": "@@ -182,6 +182,15 @@ public static JNIObjectHandle getObjectArgument(int slot) {\n         return handlePtr.read();\n     }\n \n+    public static int getIntArgument(int slot) {\n+        CIntPointer handlePtr = StackValue.get(CIntPointer.class);\n+        JvmtiError error = jvmtiFunctions().GetLocalInt().invoke(jvmtiEnv(), nullHandle(), 0, slot, handlePtr);\n+        if (error != JvmtiError.JVMTI_ERROR_NONE) {\n+            throw new RuntimeException(error.toString());", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTQzNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915436", "bodyText": "Whole method is removed", "author": "ziyilin", "createdAt": "2020-09-17T03:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNDEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNTM2Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488905366", "bodyText": "Please use ReflectionUtil.newInstance, which also takes care of the module system, and ReflectionUtil.lookupMethod for below.", "author": "peter-hofer", "createdAt": "2020-09-15T19:12:23Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/serialize/SerializationRegistry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.jdk.serialize;\n+\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public interface SerializationRegistry {\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long checksum);\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    void reportErrors(FeatureAccess access);\n+\n+    Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass);\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    static Object createSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Class<?>[] parameterTypes, Class<?>[] checkedExceptions,\n+                    int modifiers, Class<?> targetConstructorClass) {\n+        try {\n+            Class<?> generatorClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".MethodAccessorGenerator\");\n+            Constructor<?> c = generatorClass.getDeclaredConstructor();\n+            c.setAccessible(true);\n+            Object generator = c.newInstance();", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTY2OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915669", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNTM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzEwOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488907109", "bodyText": "Typo: registerAllFieds", "author": "peter-hofer", "createdAt": "2020-09-15T19:15:35Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTcyOA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915728", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMTczMQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488911731", "bodyText": "Are the hosted-only methods really needed in this interface? Seems like the serialization code can just use the implementation class directly, and only the runtime methods need to be declared here.", "author": "peter-hofer", "createdAt": "2020-09-15T19:22:45Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/serialize/SerializationRegistry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.jdk.serialize;\n+\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public interface SerializationRegistry {", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTg1MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915850", "bodyText": "fixed.", "author": "ziyilin", "createdAt": "2020-09-17T03:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMTczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5MjE2Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493692167", "bodyText": "There are still hosted methods in this interface.", "author": "peter-hofer", "createdAt": "2020-09-23T15:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMTczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NTExOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r502775119", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-10T10:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMTczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488912599", "bodyText": "I'm not sure if we need such an option, we should just support that the checksum is not present in a configuration file, and then not do any checks.", "author": "peter-hofer", "createdAt": "2020-09-15T19:23:52Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMDM1NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488920355", "bodyText": "Also, this should be a HostedOptionKey, then you can simply call getValue().", "author": "peter-hofer", "createdAt": "2020-09-15T19:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg4NjczNQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489886735", "bodyText": "Checksum is used to verify the assumption that the serialization target class' hierarchy keeps consistent through Agent run time, image build time and image run time is held. This assumption is usually held but not guaranteed. Once the assumption is broken, program will run into unexpected behaviors and will be very difficult to debug. The bottom line is we can accurately report the checksum verification failure at runtime so user knows what's going wrong at once. But of cause the earlier we report the problem the better. That's the reason I verify the checksum at both build time and run time.\nUsers can manually configure serialization item without checksum, but they must acknowledge the risk by explicitly turning on the options.", "author": "ziyilin", "createdAt": "2020-09-17T02:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NzU5Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r494847592", "bodyText": "I'm not arguing that these checks should be disabled. We should always verify the checksum when it is present in the configuration file, and the agent should always include it in its generated configuration files. But we should still support that a user hand-writes a configuration file without knowing the checksum, or chooses to omit the checksum in a generated configuration file, for example to avoid re-running the agent to keep it up to date. Then we also don't need a new option, we can just require a user to not state the checksum in the configuration for that behavior, and it's more selective than disabling checks completely.\nOn that topic: the agent has a configuration-merging feature (config-merge-dir) where we need to think about what to do if the configurations contain the same serializable class with different checksums.", "author": "peter-hofer", "createdAt": "2020-09-25T08:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzOTgxOA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r503139818", "bodyText": "I see, the option is removed.\nIf the configured serialization target class doesn't have checksum, a calculated checksum will be assigned to it at build time.\nTo merge two different checksum classes, currently it will report an error. But two will get merged if one has checksum and another doesn't.", "author": "ziyilin", "createdAt": "2020-10-12T08:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE4ODY5NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r504188695", "bodyText": "Thanks! That merging behavior sounds good.", "author": "peter-hofer", "createdAt": "2020-10-13T19:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjg4MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488912881", "bodyText": "Please use ReflectionUtil below.", "author": "peter-hofer", "createdAt": "2020-09-15T19:24:14Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNTk0Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489915947", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNDg2MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488914861", "bodyText": "Why is field/method access not required when serialVersionUID is present?", "author": "peter-hofer", "createdAt": "2020-09-15T19:26:32Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;\n+        try {\n+            serializationTargetClass.getDeclaredField(\"serialVersionUID\");\n+        } catch (NoSuchFieldException e) {\n+            registerAllMethods = true;\n+            registerAllFieds = true;", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg5MTMwOA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489891308", "bodyText": "getDeclaredMethods, getDeclaredFields and getDeclaredConstructors are only called by method computeDefaultSUID when serialVersionUID is not present.", "author": "ziyilin", "createdAt": "2020-09-17T02:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNDg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNjQ3Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488916477", "bodyText": "registerAllMethods == true should have a short-cut path rather than going through all cases for each method below.", "author": "peter-hofer", "createdAt": "2020-09-15T19:28:24Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;\n+        try {\n+            serializationTargetClass.getDeclaredField(\"serialVersionUID\");\n+        } catch (NoSuchFieldException e) {\n+            registerAllMethods = true;\n+            registerAllFieds = true;\n+            reflectionData.register(serializationTargetClass.getDeclaredConstructors());\n+        }\n+\n+        registerMethods(reflectionData, serializationTargetClass, registerAllMethods);\n+        registerFields(reflectionData, serializationTargetClass, registerAllFieds);\n+    }\n+\n+    private static void registerMethods(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, boolean registerAllMethods) {", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNjA1MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489916051", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNjQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxODcxNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488918717", "bodyText": "Please rewrite using ReflectionUtil and avoid such catch-all constructs.", "author": "peter-hofer", "createdAt": "2020-09-15T19:30:58Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;\n+        try {\n+            serializationTargetClass.getDeclaredField(\"serialVersionUID\");\n+        } catch (NoSuchFieldException e) {\n+            registerAllMethods = true;\n+            registerAllFieds = true;\n+            reflectionData.register(serializationTargetClass.getDeclaredConstructors());\n+        }\n+\n+        registerMethods(reflectionData, serializationTargetClass, registerAllMethods);\n+        registerFields(reflectionData, serializationTargetClass, registerAllFieds);\n+    }\n+\n+    private static void registerMethods(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, boolean registerAllMethods) {\n+        for (Method m : serializationTargetClass.getDeclaredMethods()) {\n+            boolean register;\n+            switch (m.getName()) {\n+                case \"readObject\":\n+                    register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectInputStream\");\n+                    break;\n+                case \"writeObject\":\n+                    register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectOutputStream\");\n+                    break;\n+                case \"readObjectNoData\":\n+                case \"writeReplace\":\n+                case \"readResolve\":\n+                    register = true;\n+                    break;\n+                default:\n+                    register = false;\n+            }\n+            if (register || registerAllMethods) {\n+                reflectionData.register(m);\n+            }\n+        }\n+    }\n+\n+    private static void registerFields(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, boolean registerAllFieds) {\n+        int mask = Modifier.STATIC | Modifier.TRANSIENT;\n+        int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+        int privateStaticFinalMask = Modifier.PRIVATE | staticFinalMask;\n+\n+        Set<String> serialPersistentFieldNames = new HashSet<>();\n+        try {\n+            Field f = serializationTargetClass.getDeclaredField(\"serialPersistentFields\");\n+            if ((f.getModifiers() & privateStaticFinalMask) == privateStaticFinalMask) {\n+                f.setAccessible(true);\n+                ObjectStreamField[] serialPersistentFields = (ObjectStreamField[]) f.get(null);\n+                for (int i = 0; i < serialPersistentFields.length; i++) {\n+                    serialPersistentFieldNames.add(serialPersistentFields[i].getName());\n+                }\n+            }\n+        } catch (Exception e) {", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNjEzNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489916137", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxODcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488922158", "bodyText": "I still think this patch needs substitutions to reset ObjectStreamClass.Caches members as described before.", "author": "peter-hofer", "createdAt": "2020-09-15T19:34:53Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzMzAyOA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489933028", "bodyText": "As we have discussed previously, only substituting the generation of SerializationConstructorAccessor, i.e. method MethodAccessorGenerator.generateSerializationConstructor is simpler and safer than substituting method ObjectStreamClass.lookup with preparing ObjectStreamClass instances at build time. ObjectStreamClass.Caches is still needed then to cache runtime calculated ObjectStreamClass instances.", "author": "ziyilin", "createdAt": "2020-09-17T03:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcwMDgzMA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493700830", "bodyText": "I'm not proposing to remove ObjectStreamClass.Caches, I'm arguing that the maps and reference queues in its fields should be reset via @Alias @RecomputeFieldValue(kind = RecomputeFieldValue.Kind.NewInstance). This way, they will be empty in the image heap, and no unneeded or outdated objects will be carried over from the image builder into the native image, and it will only contain objects created at image runtime through your code.", "author": "peter-hofer", "createdAt": "2020-09-23T15:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzI3MDA3Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r503270072", "bodyText": "I see. But when is the ObjectStreamClass.Caches added into native image heap? I don't think it has been added into native image heap. I've checked with -H:+PrintHeapHistogram but didn't find java.io.ObjectStreamClass$Caches in the heap.", "author": "ziyilin", "createdAt": "2020-10-12T12:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE4NzU0Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r504187547", "bodyText": "It's a class with only static members and no instances, so there won't be any instances, but the static fields would still end up in the image.", "author": "peter-hofer", "createdAt": "2020-10-13T18:59:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM2MTYyNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r504361624", "bodyText": "Thanks for explaining. Fixed.", "author": "ziyilin", "createdAt": "2020-10-14T02:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNDIxNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488924214", "bodyText": "Please use ReflectionUtil here and in the rest of the code.", "author": "peter-hofer", "createdAt": "2020-09-15T19:37:11Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;\n+    private List<String> verifyChecksumErrors;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        serializationTargetAndChecksums = new ConcurrentHashMap<>();\n+        verifyChecksumErrors = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void reportErrors(FeatureAccess access) {\n+        reportMultiClassLoaderIssue((FeatureImpl.DuringSetupAccessImpl) access);\n+        reportVerifyChecksumFail((FeatureImpl.DuringSetupAccessImpl) access);\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportVerifyChecksumFail(FeatureImpl.DuringSetupAccessImpl access) {\n+        if (verifyChecksumErrors.size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"\\nDetected \").append(verifyChecksumErrors.size()).append(\" build time class checksum verify failures.\")\n+                            .append(\" These classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+            for (int i = 0; i < verifyChecksumErrors.size(); i++) {\n+                sb.append(\"(\").append(i + 1).append(\") \").append(verifyChecksumErrors.get(i)).append(\"\\n\");\n+            }\n+            String errorMsg = sb.toString();\n+            String option = SubstrateOptionsParser.commandArgument(SerializationFeatureOptions.AllowUncheckedSerialization, \"+\");\n+            if (!SerializationFeatureOptions.AllowUncheckedSerialization.getValue(HostedOptionValues.singleton())) {\n+                BigBang bb = access.getBigBang();\n+                String className = \"MethodAccessorGenerator\";\n+\n+                bb.getUnsupportedFeatures().addMessage(CHECKSUM_VERIFY_FAIL, null,\n+                                errorMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" +\n+                                                option);\n+            } else {\n+                System.out.println(errorMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportMultiClassLoaderIssue(FeatureImpl.DuringSetupAccessImpl access) {\n+        StringBuilder sb = new StringBuilder();\n+        serializationTargetAndChecksums.forEach((targetClass, definitions) -> {\n+            int size = definitions.size();\n+            if (size > 1) {\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"There are \" + size + \" SerializationConstructorAccessor classes have been defined for the same serialization target class:\\n\\n\");\n+                int i = 0;\n+                while (i < size) {\n+                    sb.append(\"(\").append((i + 1)).append(\")\");\n+                    sb.append(definitions.get(i).toString());\n+                    sb.append(\"\\n\");\n+                    i++;\n+                }\n+            }\n+        });\n+        String exceptionsMsg = sb.toString();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(MULTIPLE_CHECKSUMS, null,\n+                                exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+            } else {\n+                System.out.println(exceptionsMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    @Override\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum) {\n+        if (serializationTargetClass.isArray() || serializationTargetClass.isEnum()) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ObjectStreamClass.class.getDeclaredMethod(\"getExternalizableConstructor\", Class.class);\n+                getExternalizableConstructor.setAccessible(true);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNjIxNQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489916215", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcwMzc1OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493703758", "bodyText": "There is no need to call setAccessible when using ReflectionUtil, please remove here and check for any other usages.", "author": "peter-hofer", "createdAt": "2020-09-23T15:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NDQ5MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r502774490", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-10T10:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4NDMzMQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r503084331", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-12T07:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNjgzMw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488926833", "bodyText": "Please use a simple POJO class for the value here rather than an entire key-value map.", "author": "peter-hofer", "createdAt": "2020-09-15T19:40:09Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxNjI3MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489916271", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-09-17T03:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNjgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyODYzOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488928639", "bodyText": "I don't really see the need to track these duplicates and checksums separately -- instead, the only error should be a mismatching checksum, and we can just record these as messages when we see them and submit to bb.getUnsupportedFeatures().", "author": "peter-hofer", "createdAt": "2020-09-15T19:42:16Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg5MzY5MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489893691", "bodyText": "Using serializationTargetAndChecksums can keep all error messages at one place when there are more than two checksum mismatches (although is rare)", "author": "ziyilin", "createdAt": "2020-09-17T02:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyODYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg4NTI4OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r494885289", "bodyText": "It's sufficient to check whether cachedSerializationConstructorAccessors already contains the class. Trying to register multiple classes with different checksums does not make sense because we only have a single image classloader. We can always call bb.getUnsupportedFeatures().addMessage() when that happens and print the two checksums, there is no need to collect the messages here first.\nWith verifyChecksumErrors, the code should also call bb.getUnsupportedFeatures().addMessage() immediately whenever there is a checksum mismatch.", "author": "peter-hofer", "createdAt": "2020-09-25T10:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyODYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE3NDY0Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r503174643", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-12T09:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyODYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyOTIxOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488929219", "bodyText": "As I mentioned elsewhere, I don't think the checksum should be required (although the agent should set it).", "author": "peter-hofer", "createdAt": "2020-09-15T19:42:56Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;\n+    private List<String> verifyChecksumErrors;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        serializationTargetAndChecksums = new ConcurrentHashMap<>();\n+        verifyChecksumErrors = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void reportErrors(FeatureAccess access) {\n+        reportMultiClassLoaderIssue((FeatureImpl.DuringSetupAccessImpl) access);\n+        reportVerifyChecksumFail((FeatureImpl.DuringSetupAccessImpl) access);\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportVerifyChecksumFail(FeatureImpl.DuringSetupAccessImpl access) {\n+        if (verifyChecksumErrors.size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"\\nDetected \").append(verifyChecksumErrors.size()).append(\" build time class checksum verify failures.\")\n+                            .append(\" These classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+            for (int i = 0; i < verifyChecksumErrors.size(); i++) {\n+                sb.append(\"(\").append(i + 1).append(\") \").append(verifyChecksumErrors.get(i)).append(\"\\n\");\n+            }\n+            String errorMsg = sb.toString();\n+            String option = SubstrateOptionsParser.commandArgument(SerializationFeatureOptions.AllowUncheckedSerialization, \"+\");\n+            if (!SerializationFeatureOptions.AllowUncheckedSerialization.getValue(HostedOptionValues.singleton())) {\n+                BigBang bb = access.getBigBang();\n+                String className = \"MethodAccessorGenerator\";\n+\n+                bb.getUnsupportedFeatures().addMessage(CHECKSUM_VERIFY_FAIL, null,\n+                                errorMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" +\n+                                                option);\n+            } else {\n+                System.out.println(errorMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportMultiClassLoaderIssue(FeatureImpl.DuringSetupAccessImpl access) {\n+        StringBuilder sb = new StringBuilder();\n+        serializationTargetAndChecksums.forEach((targetClass, definitions) -> {\n+            int size = definitions.size();\n+            if (size > 1) {\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"There are \" + size + \" SerializationConstructorAccessor classes have been defined for the same serialization target class:\\n\\n\");\n+                int i = 0;\n+                while (i < size) {\n+                    sb.append(\"(\").append((i + 1)).append(\")\");\n+                    sb.append(definitions.get(i).toString());\n+                    sb.append(\"\\n\");\n+                    i++;\n+                }\n+            }\n+        });\n+        String exceptionsMsg = sb.toString();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(MULTIPLE_CHECKSUMS, null,\n+                                exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+            } else {\n+                System.out.println(exceptionsMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    @Override\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum) {\n+        if (serializationTargetClass.isArray() || serializationTargetClass.isEnum()) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ObjectStreamClass.class.getDeclaredMethod(\"getExternalizableConstructor\", Class.class);\n+                getExternalizableConstructor.setAccessible(true);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        SerializationKey serializationKey = new SerializationKey(targetClassName, configuredChecksum);\n+        ReflectionFactory reflFactory = ReflectionFactory.getReflectionFactory();\n+        Constructor<?> buildTimeConstructor = reflFactory.newConstructorForSerialization(serializationTargetClass);\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        if (configuredChecksum != null) {\n+            long buildTimeChecksum = getSerializationChecksum(buildTimeConsClass.getName());\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                verifyChecksumErrors.add(sb.toString());\n+            }\n+        } else {\n+            verifyChecksumErrors.add(\"Checksum for class \" + targetClassName + \" was not set in configuration\");", "originalCommit": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk0MDk1MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r489940951", "bodyText": "Replied at #2730 (comment)", "author": "ziyilin", "createdAt": "2020-09-17T03:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyOTIxOQ=="}], "type": "inlineReview"}, {"oid": "69562906cdc41eef2d3436247d95d4d863f6d7ad", "url": "https://github.com/oracle/graal/commit/69562906cdc41eef2d3436247d95d4d863f6d7ad", "message": "Support JDK serialization", "committedDate": "2020-09-16T02:59:07Z", "type": "forcePushed"}, {"oid": "d6b08b48efdf82f912c35e40495b108381746da4", "url": "https://github.com/oracle/graal/commit/d6b08b48efdf82f912c35e40495b108381746da4", "message": "Support JDK serialization", "committedDate": "2020-09-17T02:30:47Z", "type": "forcePushed"}, {"oid": "60ba70e4c95381643f894bbe2b6d58897bfb975f", "url": "https://github.com/oracle/graal/commit/60ba70e4c95381643f894bbe2b6d58897bfb975f", "message": "Support JDK serialization", "committedDate": "2020-09-17T04:46:23Z", "type": "forcePushed"}, {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "url": "https://github.com/oracle/graal/commit/fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "message": "Support JDK serialization", "committedDate": "2020-09-23T06:15:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5MDA3NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493690074", "bodyText": "Please rename to hasInitializer().", "author": "peter-hofer", "createdAt": "2020-09-23T15:33:06Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/classinitialization/ClassInitializationInfo.java", "diffHunk": "@@ -124,18 +130,36 @@\n      */\n     private Condition initCondition;\n \n+    /**\n+     * Indicates if the class has a {@code <clinit>} method, no matter if it should be initialized\n+     * at native image's build time or run time.\n+     */\n+    private boolean hasInitializer;\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    private ClassInitializationInfo(InitState initState, boolean hasInitializer) {\n+        this(initState);\n+        this.hasInitializer = hasInitializer;\n+    }\n+\n     @Platforms(Platform.HOSTED_ONLY.class)\n     private ClassInitializationInfo(InitState initState) {\n         this.classInitializer = null;\n         this.initState = initState;\n         this.initLock = initState == InitState.FullyInitialized ? null : new ReentrantLock();\n+        this.hasInitializer = true;\n     }\n \n     @Platforms(Platform.HOSTED_ONLY.class)\n     public ClassInitializationInfo(CFunctionPointer classInitializer) {\n         this.classInitializer = classInitializer == null || classInitializer.isNull() ? null : new ClassInitializerFunctionPointerHolder(classInitializer);\n         this.initState = InitState.Linked;\n         this.initLock = new ReentrantLock();\n+        this.hasInitializer = true;\n+    }\n+\n+    public boolean isHasInitializer() {", "originalCommit": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NDI1Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r502774257", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-10T10:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5MDA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcxNTY2Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493715667", "bodyText": "Thanks for adding this comment.", "author": "peter-hofer", "createdAt": "2020-09-23T16:08:52Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFields = false;\n+        try {\n+            ReflectionUtil.lookupField(serializationTargetClass, \"serialVersionUID\");\n+        } catch (ReflectionUtil.ReflectionUtilError e) {\n+            /**\n+             * No field serialVersionUID suggests method ObjectSteamClass.computeDefaultSUID() shall\n+             * be called, and it will eventually call getDeclaredMethods, getDeclaredFields and\n+             * getDeclaredConstructors. So we need to prepare reflection data for them.\n+             */", "originalCommit": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0MDMzOA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r495040338", "bodyText": "Please use throw VMError.shouldNotReachHere(e) to preserve the exception (also applies below and possibly elsewhere).", "author": "peter-hofer", "createdAt": "2020-09-25T14:48:50Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;\n+    private List<String> verifyChecksumErrors;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        serializationTargetAndChecksums = new ConcurrentHashMap<>();\n+        verifyChecksumErrors = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void reportErrors(FeatureAccess access) {\n+        reportMultiClassLoaderIssue((FeatureImpl.BeforeAnalysisAccessImpl) access);\n+        reportVerifyChecksumFail((FeatureImpl.BeforeAnalysisAccessImpl) access);\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportVerifyChecksumFail(FeatureImpl.BeforeAnalysisAccessImpl access) {\n+        if (verifyChecksumErrors.size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"\\nDetected \").append(verifyChecksumErrors.size()).append(\" build time class checksum verify failures.\")\n+                            .append(\" These classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+            for (int i = 0; i < verifyChecksumErrors.size(); i++) {\n+                sb.append(\"(\").append(i + 1).append(\") \").append(verifyChecksumErrors.get(i)).append(\"\\n\");\n+            }\n+            String errorMsg = sb.toString();\n+            String option = SubstrateOptionsParser.commandArgument(SerializationFeatureOptions.AllowUncheckedSerialization, \"+\");\n+            if (!SerializationFeatureOptions.AllowUncheckedSerialization.getValue(HostedOptionValues.singleton())) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(CHECKSUM_VERIFY_FAIL, null,\n+                                errorMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" +\n+                                                option);\n+            } else {\n+                System.out.println(errorMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportMultiClassLoaderIssue(FeatureImpl.BeforeAnalysisAccessImpl access) {\n+        StringBuilder sb = new StringBuilder();\n+        serializationTargetAndChecksums.forEach((targetClass, definitions) -> {\n+            int size = definitions.size();\n+            if (size > 1) {\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"There are \" + size + \" SerializationConstructorAccessor classes have been defined for the same serialization target class:\\n\\n\");\n+                int i = 0;\n+                while (i < size) {\n+                    sb.append(\"(\").append((i + 1)).append(\")\");\n+                    sb.append(definitions.get(i).toString());\n+                    sb.append(\"\\n\");\n+                    i++;\n+                }\n+            }\n+        });\n+        String exceptionsMsg = sb.toString();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(MULTIPLE_CHECKSUMS, null,\n+                                exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+            } else {\n+                System.out.println(exceptionsMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    @Override\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum) {\n+        if (serializationTargetClass.isArray() || serializationTargetClass.isEnum()) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                getExternalizableConstructor.setAccessible(true);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                VMError.shouldNotReachHere();", "originalCommit": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjc3NDQxNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r502774417", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-10T10:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0MDMzOA=="}], "type": "inlineReview"}, {"oid": "3f0103f851701e72ed2c40d51711120af5bfd107", "url": "https://github.com/oracle/graal/commit/3f0103f851701e72ed2c40d51711120af5bfd107", "message": "Support JDK serialization", "committedDate": "2020-10-10T10:17:50Z", "type": "forcePushed"}, {"oid": "f7d02a0e2629eb85e1b2521ecf654a5da7d76fa0", "url": "https://github.com/oracle/graal/commit/f7d02a0e2629eb85e1b2521ecf654a5da7d76fa0", "message": "Support JDK serialization", "committedDate": "2020-10-12T07:14:19Z", "type": "forcePushed"}, {"oid": "ee5a5ed39d22caf078a534c63020b47bcc4feee5", "url": "https://github.com/oracle/graal/commit/ee5a5ed39d22caf078a534c63020b47bcc4feee5", "message": "Support JDK serialization", "committedDate": "2020-10-12T11:16:24Z", "type": "forcePushed"}, {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "url": "https://github.com/oracle/graal/commit/f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "message": "Support JDK serialization", "committedDate": "2020-10-14T02:22:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5MDE2Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506690162", "bodyText": "This method can be reduced to this line (and inlined) because registerAllMethods is always true.", "author": "peter-hofer", "createdAt": "2020-10-16T19:51:08Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum, access);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        /**\n+         * ObjectStreamClass.computeDefaultSUID is always called at runtime to verify serialization\n+         * class consistency, so need to register all constructors, methods and fields/\n+         */\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredConstructors());\n+        registerMethods(serializationTargetClass, true);\n+        registerFields(serializationTargetClass, true);\n+    }\n+\n+    private static void registerMethods(Class<?> serializationTargetClass, boolean registerAllMethods) {\n+        Method[] allMethods = serializationTargetClass.getDeclaredMethods();\n+        if (registerAllMethods) {\n+            RuntimeReflection.register(allMethods);", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODI5Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058296", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5MDE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5MDg3MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506690871", "bodyText": "This method can also be simplified significantly because registerAllFields is always true.", "author": "peter-hofer", "createdAt": "2020-10-16T19:52:47Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum, access);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        /**\n+         * ObjectStreamClass.computeDefaultSUID is always called at runtime to verify serialization\n+         * class consistency, so need to register all constructors, methods and fields/\n+         */\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredConstructors());\n+        registerMethods(serializationTargetClass, true);\n+        registerFields(serializationTargetClass, true);\n+    }\n+\n+    private static void registerMethods(Class<?> serializationTargetClass, boolean registerAllMethods) {\n+        Method[] allMethods = serializationTargetClass.getDeclaredMethods();\n+        if (registerAllMethods) {\n+            RuntimeReflection.register(allMethods);\n+        } else {\n+            for (Method m : allMethods) {\n+                boolean register;\n+                switch (m.getName()) {\n+                    case \"readObject\":\n+                        register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectInputStream\");\n+                        break;\n+                    case \"writeObject\":\n+                        register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectOutputStream\");\n+                        break;\n+                    case \"readObjectNoData\":\n+                    case \"writeReplace\":\n+                    case \"readResolve\":\n+                        register = true;\n+                        break;\n+                    default:\n+                        register = false;\n+                }\n+                if (register) {\n+                    RuntimeReflection.register(m);\n+                }\n+            }\n+        }\n+\n+        // computeDefaultSUID will be reflectively called at runtime to verify class consistency\n+        Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+        RuntimeReflection.register(computeDefaultSUID);\n+    }\n+\n+    private static void registerFields(Class<?> serializationTargetClass, boolean registerAllFields) {\n+        int mask = Modifier.STATIC | Modifier.TRANSIENT;\n+        int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+        int privateStaticFinalMask = Modifier.PRIVATE | staticFinalMask;\n+\n+        Set<String> serialPersistentFieldNames = new HashSet<>();\n+        try {\n+            Field f = ReflectionUtil.lookupField(serializationTargetClass, \"serialPersistentFields\");\n+            if ((f.getModifiers() & privateStaticFinalMask) == privateStaticFinalMask) {\n+                f.setAccessible(true);\n+                ObjectStreamField[] serialPersistentFields = (ObjectStreamField[]) f.get(null);\n+                for (int i = 0; i < serialPersistentFields.length; i++) {\n+                    serialPersistentFieldNames.add(serialPersistentFields[i].getName());\n+                }\n+            }\n+        } catch (ReflectionUtil.ReflectionUtilError | ReflectiveOperationException e) {\n+        }\n+\n+        for (Field f : serializationTargetClass.getDeclaredFields()) {\n+            int modifiers = f.getModifiers();\n+            boolean allowWrite = false;\n+            boolean allowUnsafeAccess = false;\n+            if ((modifiers & staticFinalMask) != staticFinalMask) {\n+                allowWrite = Modifier.isFinal(f.getModifiers());\n+                allowUnsafeAccess = !Modifier.isStatic(f.getModifiers());\n+            }\n+            boolean registerField = false;\n+            String fieldName = f.getName();\n+            if (serialPersistentFieldNames.contains(fieldName)) {\n+                registerField = true;\n+            } else {\n+                switch (fieldName) {\n+                    case \"serialPersistentFields\":\n+                        if ((modifiers & privateStaticFinalMask) == privateStaticFinalMask) {\n+                            registerField = true;\n+                        }\n+                        break;\n+                    case \"serialVersionUID\":\n+                        if ((modifiers & staticFinalMask) == staticFinalMask) {\n+                            registerField = true;\n+                        }\n+                        break;\n+                    default:\n+                        if ((modifiers & mask) == 0) {\n+                            registerField = true;\n+                        }\n+                }\n+            }\n+            if (registerField || registerAllFields) {\n+                RuntimeReflection.register(allowWrite, allowUnsafeAccess, f);", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODI3Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058272", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5MDg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwNzk4MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506707981", "bodyText": "Out of curiosity, what problem did you encounter here?", "author": "peter-hofer", "createdAt": "2020-10-16T20:33:29Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/json/JSONParser.java", "diffHunk": "@@ -278,6 +278,7 @@ private void skipDigits() {\n     }\n \n     private Number parseNumber() {\n+        boolean isFloating = false;", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQzMjQ4Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r507432483", "bodyText": "Parsing the long type checksum is wrong here.\nGiven literalValue=\"3123594215063866280\"\nThe value of (long)Double.parseDouble(literalValue) is 3123594215063866368", "author": "ziyilin", "createdAt": "2020-10-19T04:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwNzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwOTc0NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506709744", "bodyText": "These can be final (and don't need to be public since the class is private).", "author": "peter-hofer", "createdAt": "2020-10-16T20:38:00Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODIyNw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058227", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwOTc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMDYzMQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506710631", "bodyText": "existingEntity?", "author": "peter-hofer", "createdAt": "2020-10-16T20:40:22Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODIwOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058209", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMDYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMTQ2MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506711460", "bodyText": "Why do the check again at image runtime? It should be sufficient to check at image build time for the class provided by the image class loader.", "author": "peter-hofer", "createdAt": "2020-10-16T20:42:14Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODE5Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058192", "bodyText": "It would be safer to put a runtime check here in case user ignores the build time error by setting --report-unsupported-elements-at-runtime.", "author": "ziyilin", "createdAt": "2020-10-21T07:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMjg2Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506712863", "bodyText": "This should not be needed: 0 ^ x == x", "author": "peter-hofer", "createdAt": "2020-10-16T20:45:27Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        try {\n+            if (constructorClassName != null && constructorClassName.length() > 0) {\n+                long checksum = 0L;\n+                String currentClassName = serializationTargetClass.getName();\n+                Class<?> currentClass = serializationTargetClass;\n+                // Compute SUID for each serializable superclass\n+                while (!constructorClassName.equals(currentClassName)) {\n+                    Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    if (checksum == 0L) {\n+                        checksum = classSUID;\n+                    } else {\n+                        checksum = checksum ^ classSUID;\n+                    }", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODE4MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058181", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMjg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNDM0Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506714343", "bodyText": "It would be preferable to incrementally compute the hash with something like h = h * 31 + x rather than xor-ing all values together, which might result in a weaker hash with a higher chance of collision.", "author": "peter-hofer", "createdAt": "2020-10-16T20:49:07Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        try {\n+            if (constructorClassName != null && constructorClassName.length() > 0) {\n+                long checksum = 0L;\n+                String currentClassName = serializationTargetClass.getName();\n+                Class<?> currentClass = serializationTargetClass;\n+                // Compute SUID for each serializable superclass\n+                while (!constructorClassName.equals(currentClassName)) {\n+                    Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    if (checksum == 0L) {\n+                        checksum = classSUID;\n+                    } else {\n+                        checksum = checksum ^ classSUID;\n+                    }\n+                    currentClass = currentClass.getSuperclass();\n+                    currentClassName = currentClass.getName();\n+                }\n+\n+                // Combine checksum with first unserializable superclass\n+                return checksum ^ constructorClassName.hashCode();", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODE2NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058164", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNDM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNDY0Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506714646", "bodyText": "Why are exceptions caught here and not handled in a caller class? Does this code frequently throw under some circumstances?", "author": "peter-hofer", "createdAt": "2020-10-16T20:49:49Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        try {\n+            if (constructorClassName != null && constructorClassName.length() > 0) {\n+                long checksum = 0L;\n+                String currentClassName = serializationTargetClass.getName();\n+                Class<?> currentClass = serializationTargetClass;\n+                // Compute SUID for each serializable superclass\n+                while (!constructorClassName.equals(currentClassName)) {\n+                    Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    if (checksum == 0L) {\n+                        checksum = classSUID;\n+                    } else {\n+                        checksum = checksum ^ classSUID;\n+                    }\n+                    currentClass = currentClass.getSuperclass();\n+                    currentClassName = currentClass.getName();\n+                }\n+\n+                // Combine checksum with first unserializable superclass\n+                return checksum ^ constructorClassName.hashCode();\n+            } else {\n+                return 0L;\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            return 0;", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODE0Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058146", "bodyText": "removed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNDY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjYzOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506726639", "bodyText": "If I understand correctly, the actions in this method can cause other ObjectStreamClass instances to be initialized and we miss that because the breakpoint is not triggered recursively. In that case, we should change the breakpoint to be in ObjectStreamClass.lookup(Class<?>, boolean) instead, which is called each time when a class is used in serialization, so we should never miss a class. For efficiency, we can just check in a map whether we have already handled this class, but we should still emit an event (with cached data) and do the access check with serializationAccessVerifier. This should be simpler and more reliable than trying to infer those classes from the descriptor cache.", "author": "peter-hofer", "createdAt": "2020-10-16T21:21:22Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +922,123 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    private static boolean objectStreamClassConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        long checksum = 0;\n+        List<SerializationInfo> traceCandidates = new ArrayList<>();\n+        JNIObjectHandle javaIOObjectStreamCaches = agent.handles().findClass(jni, \"java/io/ObjectStreamClass$Caches\");\n+        JNIFieldId localDescsFId = agent.handles().getFieldId(jni, javaIOObjectStreamCaches, \"localDescs\", \"Ljava/util/concurrent/ConcurrentMap;\", true);\n+        JNIObjectHandle concurrentHashMap = agent.handles().findClass(jni, \"Ljava/util/concurrent/ConcurrentHashMap;\");\n+\n+        /** Get ObjectStreamClass.Caches.localDescs' size before init */\n+        JNIObjectHandle localDescs = jniFunctions().getGetStaticObjectField().invoke(jni, javaIOObjectStreamCaches, localDescsFId);\n+        JNIMethodId sizeMId = agent.handles().getMethodId(jni, concurrentHashMap, \"size\", \"()I\", false);\n+        int oldCacheSize = jniFunctions().getCallIntMethodA().invoke(jni, localDescs, sizeMId, nullPointer());\n+\n+        JNIObjectHandle objectStreamClassInstance = newObjectL(jni, bp.clazz, bp.method, serializeTargetClass);\n+        Object result = nullHandle().notEqual(objectStreamClassInstance);\n+        if (clearException(jni)) {\n+            result = false;\n+        }\n+        if (result.equals(true)) {\n+            checksum = getChecksumFromOSC(jni, bp.clazz, objectStreamClassInstance, serializeTargetClass, serializeTargetClassName);\n+        }\n+        traceCandidates.add(new SerializationInfo(serializeTargetClassName, checksum));\n+\n+        /**\n+         * Check if ObjectStreamClass.Caches.localDescs has been changed If there are more elements\n+         * after the execution of ObjectStreamClass.<init>, it suggests the super class(es) of\n+         * current serialization target class get(s) serialized recursively during the process of\n+         * initialization. We need to find out the corresponding classes and checksums and add them\n+         * to the serialization configurations.\n+         */", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1Mjk1MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509052951", "bodyText": "Method ObjectStreamClass.lookup(Class<?>, boolean) is still recursively called during serialization. Given the followsing class hierarchy for example:\n\nIt has the following call chain when serialize the Child object. The lookup method is recursively invoked for each class along the class hierarchy. So it is no need to change to set break point on lookup method.", "author": "ziyilin", "createdAt": "2020-10-21T07:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2NTg5OA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r515865898", "bodyText": "You're right, that doesn't help either.\nStill, figuring out which classes were added to the cache seems unreliable for the task of determining the classes that are referenced by the current class. Other threads might add entries to the cache at the same time.\nI think what we should do instead is find the descriptors ourselves. This means reading fields superDesc, iterating dataLayout and reading ClassDataSlot.desc, and perhaps localDesc, and following them recursively (stopping if a descriptor we have already seen and processed a certain descriptor).", "author": "peter-hofer", "createdAt": "2020-11-02T10:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk0NjExMw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r521946113", "bodyText": "Fixed. dataLayout is null until method ObjectStreamClass.getClassDataLayout is called. I call method ObjectStreamClass.getClassDataLayout0() which returns an array of ClassDataSlot in which all necessary data can be found but doesn't fill dataLayout.", "author": "ziyilin", "createdAt": "2020-11-12T09:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjg3MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506726871", "bodyText": "Why these new imports?", "author": "peter-hofer", "createdAt": "2020-10-16T21:21:54Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java", "diffHunk": "@@ -26,10 +26,13 @@\n \n import static com.oracle.svm.jni.JNIObjectHandles.nullHandle;\n \n+import com.oracle.svm.jni.nativeapi.JNIFieldId;\n import com.oracle.svm.jvmtiagentbase.JNIHandleSet;\n import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n import com.oracle.svm.jni.nativeapi.JNIMethodId;\n import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+import com.oracle.svm.jvmtiagentbase.Support;\n+import org.graalvm.compiler.lir.util.GenericValueMap;", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1ODA2Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509058066", "bodyText": "removed", "author": "ziyilin", "createdAt": "2020-10-21T07:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNzM1Nw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506727357", "bodyText": "Eventually, we should add frequently used JNIMethodId and JNIObjectHandle values in the new code to this class, ideally initializing them lazily, so we can avoid repeated lookups by name.", "author": "peter-hofer", "createdAt": "2020-10-16T21:23:20Z", "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java", "diffHunk": "@@ -26,10 +26,13 @@\n \n import static com.oracle.svm.jni.JNIObjectHandles.nullHandle;\n \n+import com.oracle.svm.jni.nativeapi.JNIFieldId;\n import com.oracle.svm.jvmtiagentbase.JNIHandleSet;\n import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n import com.oracle.svm.jni.nativeapi.JNIMethodId;\n import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+import com.oracle.svm.jvmtiagentbase.Support;\n+import org.graalvm.compiler.lir.util.GenericValueMap;\n \n public class NativeImageAgentJNIHandleSet extends JNIHandleSet {", "originalCommit": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE0MTQ3Mg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r509141472", "bodyText": "I have moved them into NativeImageAgentJNIHandleSet.java.", "author": "ziyilin", "createdAt": "2020-10-21T09:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNzM1Nw=="}], "type": "inlineReview"}, {"oid": "3c6fb3646345af992772bb355c6fa9ccf44208bf", "url": "https://github.com/oracle/graal/commit/3c6fb3646345af992772bb355c6fa9ccf44208bf", "message": "Support JDK serialization", "committedDate": "2020-10-21T07:43:05Z", "type": "forcePushed"}, {"oid": "b89aad09c7921013af649d726b0e503c5df7e6f2", "url": "https://github.com/oracle/graal/commit/b89aad09c7921013af649d726b0e503c5df7e6f2", "message": "Support JDK serialization", "committedDate": "2020-10-21T09:43:14Z", "type": "forcePushed"}, {"oid": "73ff3a91936d23b224a8062aeb884005e4ae4cfa", "url": "https://github.com/oracle/graal/commit/73ff3a91936d23b224a8062aeb884005e4ae4cfa", "message": "Support JDK serialization", "committedDate": "2020-11-12T08:58:05Z", "type": "forcePushed"}, {"oid": "cf7defe36271537f22e7b7623261eef8930b15c5", "url": "https://github.com/oracle/graal/commit/cf7defe36271537f22e7b7623261eef8930b15c5", "message": "Support JDK serialization", "committedDate": "2020-11-20T12:08:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzODM4Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r527938386", "bodyText": "This try-catch block should probably apply only to the reflective field lookup.", "author": "peter-hofer", "createdAt": "2020-11-20T19:55:22Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum, access);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        /**\n+         * ObjectStreamClass.computeDefaultSUID is always called at runtime to verify serialization\n+         * class consistency, so need to register all constructors, methods and fields/\n+         */\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredConstructors());\n+        registerMethods(serializationTargetClass);\n+        registerFields(serializationTargetClass);\n+    }\n+\n+    private static void registerMethods(Class<?> serializationTargetClass) {\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredMethods());\n+        // computeDefaultSUID will be reflectively called at runtime to verify class consistency\n+        Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+        RuntimeReflection.register(computeDefaultSUID);\n+    }\n+\n+    private static void registerFields(Class<?> serializationTargetClass) {\n+        int mask = Modifier.STATIC | Modifier.TRANSIENT;\n+        int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+        int privateStaticFinalMask = Modifier.PRIVATE | staticFinalMask;\n+\n+        Set<String> serialPersistentFieldNames = new HashSet<>();\n+        try {\n+            Field f = ReflectionUtil.lookupField(serializationTargetClass, \"serialPersistentFields\");\n+            if ((f.getModifiers() & privateStaticFinalMask) == privateStaticFinalMask) {\n+                f.setAccessible(true);\n+                ObjectStreamField[] serialPersistentFields = (ObjectStreamField[]) f.get(null);\n+                for (int i = 0; i < serialPersistentFields.length; i++) {\n+                    serialPersistentFieldNames.add(serialPersistentFields[i].getName());\n+                }\n+            }\n+        } catch (ReflectionUtil.ReflectionUtilError | ReflectiveOperationException e) {", "originalCommit": "cf7defe36271537f22e7b7623261eef8930b15c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI0MTI2Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r529241263", "bodyText": "There two exceptions should be caught, one is from looking up field, another one is from getting value of the field. So still need this block.", "author": "ziyilin", "createdAt": "2020-11-24T06:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzODM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzOTc0OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r527939749", "bodyText": "It seems like these can be deleted since they make no changes to the original class.", "author": "peter-hofer", "createdAt": "2020-11-20T19:58:16Z", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/JavaIOSubstitutions.java", "diffHunk": "@@ -47,31 +51,54 @@\n @TargetClass(java.io.ObjectInputStream.class)\n @SuppressWarnings({\"static-method\"})\n final class Target_java_io_ObjectInputStream {\n-\n+    /**\n+     * Private method latestUserDefinedLoader is called by\n+     * java.io.ObjectInputStream.resolveProxyClass and java.io.ObjectInputStream.resolveClass. The\n+     * returned classloader is eventually used in Class.forName and Proxy.getProxyClass0 which are\n+     * substituted by Substrate VM and the classloader is ignored. Therefore, this substitution is\n+     * safe.\n+     *\n+     * @return The only classloader in native image\n+     */\n     @Substitute\n-    private Object readObject() {\n-        throw VMError.unsupportedFeature(\"ObjectInputStream.readObject()\");\n+    private static ClassLoader latestUserDefinedLoader() {\n+        return Target_java_io_ObjectInputStream.class.getClassLoader();\n     }\n+}\n+\n+@TargetClass(java.io.ObjectStreamClass.class)\n+final class Target_java_io_ObjectStreamClass {\n \n     @Substitute\n-    private Object readUnshared() {\n-        throw VMError.unsupportedFeature(\"ObjectInputStream.readUnshared()\");\n+    private static boolean hasStaticInitializer(Class<?> cl) {\n+        return DynamicHub.fromClass(cl).getClassInitializationInfo().hasInitializer();\n     }\n }\n \n-@TargetClass(java.io.ObjectOutputStream.class)\n-@SuppressWarnings({\"static-method\", \"unused\"})\n-final class Target_java_io_ObjectOutputStream {\n+@TargetClass(value = java.io.ObjectStreamClass.class,  innerClass = \"Caches\")\n+final class Target_java_io_ObjectStreamClass_Caches {\n \n-    @Substitute\n-    private void writeObject(Object obj) {\n-        throw VMError.unsupportedFeature(\"ObjectOutputStream.writeObject()\");\n-    }\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ConcurrentHashMap.class)\n+    static ConcurrentMap<Target_java_io_ObjectStreamClass_WeakClassKey, Reference<?>> localDescs;\n+\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ConcurrentHashMap.class)\n+    static ConcurrentMap<Target_java_io_ObjectStreamClass_FieldReflectorKey, Reference<?>> reflectors;\n+\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ReferenceQueue.class)\n+    private static ReferenceQueue<Class<?>> localDescsQueue;\n+\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ReferenceQueue.class)\n+    private static ReferenceQueue<Class<?>> reflectorsQueue;\n+}\n+\n+@TargetClass(value = java.io.ObjectStreamClass.class, innerClass = \"WeakClassKey\")\n+final class Target_java_io_ObjectStreamClass_WeakClassKey{\n+\n+}\n+\n+@TargetClass(value = java.io.ObjectStreamClass.class, innerClass = \"FieldReflectorKey\")\n+final class Target_java_io_ObjectStreamClass_FieldReflectorKey {\n \n-    @Substitute\n-    private void writeUnshared(Object obj) {\n-        throw VMError.unsupportedFeature(\"ObjectOutputStream.writeUnshared()\");\n-    }\n }", "originalCommit": "cf7defe36271537f22e7b7623261eef8930b15c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI0MDYwNg==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r529240606", "bodyText": "removed", "author": "ziyilin", "createdAt": "2020-11-24T06:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzOTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Mjg1MA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r527942850", "bodyText": "Please try extracting the common algorithm in this method and in BreakpointInterceptor.getChecksumFromOSC into a method that can be called from both places with values from the different sources.", "author": "peter-hofer", "createdAt": "2020-11-20T20:04:59Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");188\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitingEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitingEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitingEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        if (constructorClassName != null && constructorClassName.length() > 0) {\n+            long checksum = 0L;\n+            String currentClassName = serializationTargetClass.getName();\n+            Class<?> currentClass = serializationTargetClass;\n+            // Compute SUID for each serializable superclass\n+            while (!constructorClassName.equals(currentClassName)) {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                try {\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    checksum = checksum * 31 + classSUID;\n+                    currentClass = currentClass.getSuperclass();\n+                    currentClassName = currentClass.getName();\n+                } catch (InvocationTargetException | IllegalAccessException e) {\n+                    throw VMError.shouldNotReachHere(e);\n+                }\n+            }\n+\n+            // Combine checksum with first unserializable superclass\n+            return checksum * 31 + constructorClassName.hashCode();\n+        } else {\n+            return 0L;\n+        }\n+    }", "originalCommit": "cf7defe36271537f22e7b7623261eef8930b15c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIzMDQ1NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r529230454", "bodyText": "I found it's difficult to apply a common method for Java and JVMTI Agent code because Object and Word are two incompatible systems. I tried to extract the algorithm into the following code:\npublic class SerializationChecksumCalculator<T> {\n    public long calculate(String targetConstructorClassName,\n                                String serializationClassName,\n                                T serializationClass,\n                                Function<T, Long> calculateFromComputeDefaultSUID,\n                                Function<T, String> getClassName,\n                                Function<T, T> getSuperClass\n    ) {\n        long checksum = 0L;\n        if (targetConstructorClassName != null && targetConstructorClassName.length() > 0) {\n            String currentClassName = serializationClassName;\n            T currentClass = serializationClass;\n            while (!targetConstructorClassName.equals(currentClassName)) {\n                long classSUID = calculateFromComputeDefaultSUID.apply(currentClass);\n                checksum = checksum * 31 + classSUID;\n                currentClass = getSuperClass.apply(currentClass);\n                currentClassName = getClassName.apply(currentClass);\n            }\n            checksum = checksum * 31 + targetConstructorClassName.hashCode();\n        }\n        return checksum;\n    }\n}\nT is supposed to be Class<?> when it is called from SerializationSupport, and to be JNIObjectHandler when it is called from BreakpointInterceptor. But in fact JNIObjectHandler is Word based and incompatible with Object.", "author": "ziyilin", "createdAt": "2020-11-24T06:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Mjg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzMzkyOQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r529433929", "bodyText": "I see. Perhaps we can put the two methods in the same class then, so that it is more obvious that both must be changed, or at least add a comment to that effect.", "author": "peter-hofer", "createdAt": "2020-11-24T10:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Mjg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA2MjIxMw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r530062213", "bodyText": "I have put them into a single location com.oracle.svm.util.SerializationChecksumCalculator.", "author": "ziyilin", "createdAt": "2020-11-25T02:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Mjg1MA=="}], "type": "inlineReview"}, {"oid": "1a4fd2efbd30c9cc65dc421ca1e1240fdd2443a9", "url": "https://github.com/oracle/graal/commit/1a4fd2efbd30c9cc65dc421ca1e1240fdd2443a9", "message": "Support JDK serialization", "committedDate": "2020-11-24T06:56:30Z", "type": "forcePushed"}, {"oid": "0a30a3050836f5184bcd912311cc7b6177f90c22", "url": "https://github.com/oracle/graal/commit/0a30a3050836f5184bcd912311cc7b6177f90c22", "message": "Support JDK serialization", "committedDate": "2020-11-24T08:43:38Z", "type": "forcePushed"}, {"oid": "fe6adf251182a9d526a54b35a2f867c4f8f2f708", "url": "https://github.com/oracle/graal/commit/fe6adf251182a9d526a54b35a2f867c4f8f2f708", "message": "Support JDK serialization", "committedDate": "2020-11-24T09:57:49Z", "type": "forcePushed"}, {"oid": "90d868edf83f86f4e8ac8e900fc8d248aa3bcdb1", "url": "https://github.com/oracle/graal/commit/90d868edf83f86f4e8ac8e900fc8d248aa3bcdb1", "message": "Support JDK serialization", "committedDate": "2020-11-24T12:58:29Z", "type": "forcePushed"}, {"oid": "a51061feb65463853df995fd55eac04da045f740", "url": "https://github.com/oracle/graal/commit/a51061feb65463853df995fd55eac04da045f740", "message": "Support JDK serialization", "committedDate": "2020-11-25T02:02:47Z", "type": "forcePushed"}, {"oid": "8843fc96827d361f8e5b8fc0bc7e529a0ab456f2", "url": "https://github.com/oracle/graal/commit/8843fc96827d361f8e5b8fc0bc7e529a0ab456f2", "message": "Support JDK serialization", "committedDate": "2020-11-26T09:35:11Z", "type": "forcePushed"}, {"oid": "5992410139d58cf6b7902ec60d7207541632d681", "url": "https://github.com/oracle/graal/commit/5992410139d58cf6b7902ec60d7207541632d681", "message": "Support JDK serialization", "committedDate": "2020-11-26T12:56:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4MjQ2NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r531682464", "bodyText": "newConstructorForSerialization will try to find a constructor in the given class or in any of its parent:\nSo it's possible that buildTimeConstructor is null in case no constructor is found. Even though Java generates empty constructors automatically, the section 2.9.1 of the JVM specs says that:\nA class has zero or more instance initialization methods\n\nHaving no constructor happens only for inner classes in Java but is more common in Scala. So long story short, we need to handle the null case (maybe by skipping this case in beforeAnalysis), otherwise calling buildTimeConstructor.getDeclaringClass() below will generate an NPE.", "author": "farquet", "createdAt": "2020-11-27T16:13:25Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import com.oracle.svm.util.SerializationChecksumCalculator;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    class ChecksumCalculator extends SerializationChecksumCalculator.JavaCalculator {\n+        @Override\n+        protected String getClassName(Class<?> clazz) {\n+            return clazz.getName();\n+        }\n+\n+        @Override\n+        protected Class<?> getSuperClass(Class<?> clazz) {\n+            return clazz.getSuperclass();\n+        }\n+\n+        @Override\n+        protected Long calculateFromComputeDefaultSUID(Class<?> clazz) {\n+            try {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", java.lang.Class.class);\n+                return (Long) computeDefaultSUID.invoke(null, clazz);\n+            } catch (ReflectionUtil.ReflectionUtilError | InvocationTargetException | IllegalAccessException e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+    }\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    private final ChecksumCalculator checksumCalculator;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        checksumCalculator = new ChecksumCalculator();\n+    }\n+\n+    private static void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = access.findClassByName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);", "originalCommit": "5992410139d58cf6b7902ec60d7207541632d681", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjQ1ODY1OQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r532458659", "bodyText": "Fixed by skipping the null buildTimeConstructor.", "author": "ziyilin", "createdAt": "2020-11-30T09:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4MjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4Njc4NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r532586785", "bodyText": "Perfect. Looks good to me!", "author": "farquet", "createdAt": "2020-11-30T13:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4MjQ2NA=="}], "type": "inlineReview"}, {"oid": "b891054cbc6cd2513e03d2673a703336296e3f7a", "url": "https://github.com/oracle/graal/commit/b891054cbc6cd2513e03d2673a703336296e3f7a", "message": "Support JDK serialization", "committedDate": "2020-11-30T09:09:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0Mjc4NA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r533242784", "bodyText": "A javadoc comment should be added here to match the other register methods.", "author": "olpaw", "createdAt": "2020-12-01T09:47:59Z", "path": "sdk/src/org.graalvm.nativeimage/src/org/graalvm/nativeimage/hosted/RuntimeReflection.java", "diffHunk": "@@ -107,6 +107,10 @@ public static void register(boolean finalIsWritable, Field... fields) {\n         ImageSingletons.lookup(RuntimeReflectionSupport.class).register(finalIsWritable, false, fields);\n     }\n \n+    public static void register(boolean finalIsWritable, boolean allowUnsafeAccess, Field... fields) {", "originalCommit": "b891054cbc6cd2513e03d2673a703336296e3f7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIxMjQ4NQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535212485", "bodyText": "fixed", "author": "ziyilin", "createdAt": "2020-12-03T13:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0Mjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4ODA0MQ==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r533588041", "bodyText": "This is too strict. We have to be able to handle redundant / overlapping serialization-config.json entries (jar file from project X might have an embedded serialization config that overlaps with another one in project Y). Otherwise the accumulative nature of our configurations will interact badly with serialization configuration data.", "author": "olpaw", "createdAt": "2020-12-01T17:22:27Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import com.oracle.svm.util.SerializationChecksumCalculator;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    class ChecksumCalculator extends SerializationChecksumCalculator.JavaCalculator {\n+        @Override\n+        protected String getClassName(Class<?> clazz) {\n+            return clazz.getName();\n+        }\n+\n+        @Override\n+        protected Class<?> getSuperClass(Class<?> clazz) {\n+            return clazz.getSuperclass();\n+        }\n+\n+        @Override\n+        protected Long calculateFromComputeDefaultSUID(Class<?> clazz) {\n+            try {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", java.lang.Class.class);\n+                return (Long) computeDefaultSUID.invoke(null, clazz);\n+            } catch (ReflectionUtil.ReflectionUtilError | InvocationTargetException | IllegalAccessException e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Using a separated classloader for serialization checksum computation to avoid initializing\n+     * Classes that should be initialized at run time.\n+     */\n+    class SerializationChecksumClassLoader extends URLClassLoader {\n+\n+        SerializationChecksumClassLoader(URL[] urls, ClassLoader parent) {\n+            super(urls, parent);\n+        }\n+\n+    }\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    private SerializationChecksumClassLoader serializationChecksumClassLoader;\n+    private final ChecksumCalculator checksumCalculator;\n+\n+    public SerializationSupport(ImageClassLoader imageClassLoader) {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        checksumCalculator = new ChecksumCalculator();\n+        URLClassLoader cl = (URLClassLoader) imageClassLoader.getClassLoader();\n+        serializationChecksumClassLoader = new SerializationChecksumClassLoader(cl.getURLs(), cl.getParent());\n+    }\n+\n+    private static void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = access.findClassByName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        if (buildTimeConstructor == null) {\n+            return null;\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        // this class is getting from SerializationChecksumClassLoader classloader\n+        Class<?> checksumCalculationTargetClass;\n+        try {\n+            // Checkstyle: stop\n+            checksumCalculationTargetClass = Class.forName(serializationTargetClass.getName(), false, serializationChecksumClassLoader);\n+            // Checkstyle resume\n+        } catch (ClassNotFoundException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        long buildTimeChecksum = checksumCalculator.calculateChecksum(buildTimeConsClass.getName(), serializationTargetClass.getName(), checksumCalculationTargetClass);\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitingEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitingEntity != null) {\n+                StringBuilder sb = new StringBuilder();", "originalCommit": "b891054cbc6cd2513e03d2673a703336296e3f7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIxMjI4Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535212283", "bodyText": "Loose this check by adding a checksum compare. Only report error for same name different checksum case.", "author": "ziyilin", "createdAt": "2020-12-03T13:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4ODA0MQ=="}], "type": "inlineReview"}, {"oid": "9948ed89131ecfd69f44375cdd8b33b0c4c94028", "url": "https://github.com/oracle/graal/commit/9948ed89131ecfd69f44375cdd8b33b0c4c94028", "message": "Support JDK serialization", "committedDate": "2020-12-03T13:06:32Z", "type": "forcePushed"}, {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747", "url": "https://github.com/oracle/graal/commit/e42caa9ddd3bdace7f2a89482d879ca778c39747", "message": "Support JDK serialization", "committedDate": "2020-12-03T13:13:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI2ODcwNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535268704", "bodyText": "All Rights Reserved. causes problems. Please fix all header files to use\nAll rights reserved. (after Alibaba Group Holding Limited)\nSo that it matches exactly All rights reserved. (lowercase rights and lowercase reserved", "author": "olpaw", "createdAt": "2020-12-03T14:25:23Z", "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/SerializationConfiguration.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.", "originalCommit": "e42caa9ddd3bdace7f2a89482d879ca778c39747", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4MjYyNA==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535282624", "bodyText": "@ziyilin please also remove this bit. We have to allow overlapping/redundant entries in serialization-config.json files.", "author": "olpaw", "createdAt": "2020-12-03T14:38:19Z", "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import com.oracle.svm.util.SerializationChecksumCalculator;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    class ChecksumCalculator extends SerializationChecksumCalculator.JavaCalculator {\n+        @Override\n+        protected String getClassName(Class<?> clazz) {\n+            return clazz.getName();\n+        }\n+\n+        @Override\n+        protected Class<?> getSuperClass(Class<?> clazz) {\n+            return clazz.getSuperclass();\n+        }\n+\n+        @Override\n+        protected Long calculateFromComputeDefaultSUID(Class<?> clazz) {\n+            try {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", java.lang.Class.class);\n+                return (Long) computeDefaultSUID.invoke(null, clazz);\n+            } catch (ReflectionUtil.ReflectionUtilError | InvocationTargetException | IllegalAccessException e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        @Override\n+        protected boolean isClassAbstract(Class<?> clazz) {\n+            return Modifier.isAbstract(clazz.getModifiers());\n+        }\n+    }\n+\n+    /**\n+     * Method MethodAccessorGenerator.generateSerializationConstructor dynamically defines a\n+     * SerializationConstructorAccessorImpl type class. The class has a newInstance method which\n+     * news the class specified by generateSerializationConstructor's first\n+     * parameter--declaringClass and then calls declaringClass' first non-serializable superclass.\n+     * The bytecode of the generated class like :\n+     * <code>\n+     * jdk.internal.reflect.GeneratedSerializationConstructorAccessor2.newInstance(Unknown Source)\n+     * [bci: 0, intrinsic: false] \n+     * 0: new #6 // declaringClass \n+     * 3: dup \n+     * 4: aload_1 \n+     * 5: ifnull 24 \n+     * 8: aload_1 \n+     * 9: arraylength \n+     * 10: sipush 0\n+     *  ...\n+     * </code>\n+     * The declaringClass could be an abstract class. At deserialization time,\n+     * SerializationConstructorAccessorImpl classes are generated for the target class and all of\n+     * its serializable super classes. The super classes could be abstract. So it is possible to\n+     * generate bytecode that new an abstract class. In JDK, the super class' generated newInstance\n+     * method shall never get invoked, so the \"new abstract class\" code won't cause any error. But\n+     * in Substrate VM, the generated class gets compiled at build time and the \"new abstract class\"\n+     * code causes compilation error.\n+     *\n+     * We introduce this StubForAbstractClass class to replace any abstract classes at method\n+     * generateSerializationConstructor's declaringClass parameter place. So there won't be \"new\n+     * abstract class\" bytecode anymore, and it's also safe for runtime as the corresponding\n+     * newInstance method is never actually called.\n+     */\n+    static class StubForAbstractClass implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    private static Object stubAccessor = null;\n+\n+    /**\n+     * Using a separated classloader for serialization checksum computation to avoid initializing\n+     * Classes that should be initialized at run time.\n+     */\n+    class SerializationChecksumClassLoader extends URLClassLoader {\n+\n+        SerializationChecksumClassLoader(URL[] urls, ClassLoader parent) {\n+            super(urls, parent);\n+        }\n+\n+    }\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    private SerializationChecksumClassLoader serializationChecksumClassLoader;\n+    private final ChecksumCalculator checksumCalculator;\n+\n+    public SerializationSupport(ImageClassLoader imageClassLoader) {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        checksumCalculator = new ChecksumCalculator();\n+        URLClassLoader cl = (URLClassLoader) imageClassLoader.getClassLoader();\n+        serializationChecksumClassLoader = new SerializationChecksumClassLoader(cl.getURLs(), cl.getParent());\n+    }\n+\n+    private static void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        Class<?> buildTimeConsClass;\n+        long checksum = 0;\n+        Object constructorAccessor;\n+        String targetClassName = serializationTargetClass.getName();\n+        boolean isAbstract = Modifier.isAbstract(serializationTargetClass.getModifiers());\n+        Constructor<?> stubConstructor = null;\n+        try {\n+            Class<?> reflectionFactoryClass = access.findClassByName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+\n+            // Calculate GeneratedSerializationConstructor for StubForAbstractClass only once\n+            if (isAbstract && stubAccessor == null) {\n+                stubConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, StubForAbstractClass.class);\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        if (buildTimeConstructor == null) {\n+            return null;\n+        }\n+        buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+\n+        if (isAbstract && stubAccessor != null) {\n+            constructorAccessor = stubAccessor;\n+            targetClassName = StubForAbstractClass.class.getName();\n+        } else {\n+            // Prepare build time checksum and verify with configured checksum only for non-abstract\n+            // classes. Abstract class' checksum is always 0.\n+            if (!isAbstract) {\n+                checksum = getChecksum(serializationTargetClass, configuredChecksum, (FeatureImpl.BeforeAnalysisAccessImpl) access, buildTimeConsClass, targetClassName);\n+            }\n+            try {\n+                Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+                constructorAccessor = getConstructorAccessor.invoke(isAbstract ? stubConstructor : buildTimeConstructor);\n+                if (isAbstract) {\n+                    assert constructorAccessor != null;\n+                    stubAccessor = constructorAccessor;\n+                    targetClassName = StubForAbstractClass.class.getName();\n+                }\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+        // Cache constructorAccessor\n+        CachedEntity exitingEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                        new CachedEntity(constructorAccessor, checksum));\n+        if (exitingEntity != null && exitingEntity.configuredChecksum != checksum) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+            sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+            sb.append(\" is already registered with checksum \").append(exitingEntity.configuredChecksum);\n+            reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+        }", "originalCommit": "e42caa9ddd3bdace7f2a89482d879ca778c39747", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI5NzY3Mw==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535297673", "bodyText": "I've loosed the check by adding exitingEntity.configuredChecksum != checksum. Only the same name class with different checksum will be considered as error.\nI'm afraid we can't report multi-classloader usage error if the whole check is removed.", "author": "ziyilin", "createdAt": "2020-12-03T14:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4MjYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMwODE1Ng==", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535308156", "bodyText": "Ok. That should also do it. Thanks!", "author": "olpaw", "createdAt": "2020-12-03T15:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4MjYyNA=="}], "type": "inlineReview"}, {"oid": "c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "url": "https://github.com/oracle/graal/commit/c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "message": "Support JDK serialization", "committedDate": "2020-12-03T15:23:00Z", "type": "commit"}, {"oid": "c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "url": "https://github.com/oracle/graal/commit/c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "message": "Support JDK serialization", "committedDate": "2020-12-03T15:23:00Z", "type": "forcePushed"}]}