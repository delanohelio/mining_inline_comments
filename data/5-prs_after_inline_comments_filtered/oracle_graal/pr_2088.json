{"pr_number": 2088, "pr_title": "Debug info prototype", "pr_createdAt": "2020-01-22T10:51:13Z", "pr_url": "https://github.com/oracle/graal/pull/2088", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMTEwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r370021108", "bodyText": "Can you please convert all these C++ style comments to proper javadoc.", "author": "dougxc", "createdAt": "2020-01-23T09:52:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.util.List;\n+\n+// class defining interfaces used to allow a native image", "originalCommit": "7138edc94f05596cf2d70d158f317cad5abb5178", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA3MzEyNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r370073127", "bodyText": "Yes, of course -- I should have been on the ball from the start.\nI have converted almost all of these existing comments to javadoc, updated the content to be more informative and added a lot more missing javadoc comments.\nI have (deliberately) not javadoc commented all the final values that clearly identify DWARF constants -- there is the DWARF spec for that.\nI have also not (yet) javadoc commented some of the internal details of DwarfSectionImpl and its subclasses, most notably the various putXXX and writeXXX methods that insert simple data records to the ELF sections in a variety of different formats. The higher level methods which invoke them provide comments detailing the data layouts so this omission should not be not critical when it comes to understanding the code.", "author": "adinn", "createdAt": "2020-01-23T11:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMTEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1MzY1Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372353653", "bodyText": "No point in assigning to an unused local. Just use newUserDefinedSection( ..... I know the names of these methods are stupid.", "author": "olpaw", "createdAt": "2020-01-29T12:27:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java", "diffHunk": "@@ -1155,4 +1157,46 @@ public SymbolTable getSymbolTable() {\n     protected int getMinimumFileSize() {\n         return 0;\n     }\n+\n+    @Override\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        DwarfSections dwarfSections = new DwarfSections(getMachine());\n+        // we need an implementation for each section\n+        DwarfSections.DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n+        DwarfSections.DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n+        DwarfSections.DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n+        DwarfSections.DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n+        DwarfSections.DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n+        DwarfSections.DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n+        // now we can create the section elements with empty content\n+        @SuppressWarnings(\"unused\")\n+        ELFSection strSection = (ELFSection) newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTM0NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375789344", "bodyText": "Yes, indeed. Removed.", "author": "adinn", "createdAt": "2020-02-06T11:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1MzY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358061", "bodyText": "I did not see the code where your elf.darf entities get transformed into their binary representations. Do I miss something or is this simply not ready yet?", "author": "olpaw", "createdAt": "2020-01-29T12:38:06Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * details of a specific address range in a compiled method\n+ * either a primary range identifying a whole method\n+ * or a sub-range identifying a sequence of\n+ * instructions that belong to an inlined method\n+ */\n+\n+public class Range {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NzE0NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372387145", "bodyText": "Sorry for the noise. Found it in DwarfSections.java (github did not show me that file first because it too large ... and it really is ;-) )", "author": "olpaw", "createdAt": "2020-01-29T13:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTY4Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375789682", "bodyText": "Yes, I will split out the embedded classes so the code can be in separate files.", "author": "adinn", "createdAt": "2020-02-06T11:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODg5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358896", "bodyText": "We would want to have a hosted option. e.g GenerateDebugInfo that would ensure TrackNodeSourcePosition is enabled whenever GenerateDebugInfo > 0", "author": "olpaw", "createdAt": "2020-01-29T12:40:12Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -458,6 +473,12 @@ public void build(DebugContext debug, ImageHeapLayouter layouter) {\n             cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\n             defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\n \n+            // if we have constructed any debug info then\n+            // give the object file a chance to install it\n+            if (GraalOptions.TrackNodeSourcePosition.getValue(HostedOptionValues.singleton())) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMDI5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376330296", "bodyText": "Answered in another comment", "author": "adinn", "createdAt": "2020-02-07T10:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NjM3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372366372", "bodyText": "We have org.graalvm.compiler.debug.DebugContext for logging. See e.g. com.oracle.svm.hosted.ResourcesFeature#scanDirectory", "author": "olpaw", "createdAt": "2020-01-29T12:57:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTYyNQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372369625", "bodyText": "afaics you only ever add to this list without every using it afterwards", "author": "olpaw", "createdAt": "2020-01-29T13:04:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NTM5MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375795391", "bodyText": "Yes, I was hedging on the idea that it might be necessary at some point to iterate over (outer) compiled methods in address order. At present all iteration is by methods within each owning class (using the list of ClassEntry) which is effectively the same. I have removed this list and updated the comments regarding iteration options.", "author": "adinn", "createdAt": "2020-02-06T12:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MDg5Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372370897", "bodyText": "Maybe Charset.forName(\"US-ASCII\").newEncoder().canEncode ?", "author": "olpaw", "createdAt": "2020-01-29T13:07:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MjI3OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372372279", "bodyText": "CUDOs for documenting the binary representations. Please use\n/*\n * This style for code comments wherever possible.\n *\n */", "author": "olpaw", "createdAt": "2020-01-29T13:10:31Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MzI1NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372373255", "bodyText": "This file would profit from getting partitioned into multiple source files.", "author": "olpaw", "createdAt": "2020-01-29T13:12:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg2NzcyNA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375867724", "bodyText": "All the section implementation classes are now in separat efiles and they are no longer inner classes of class SwarfSections", "author": "adinn", "createdAt": "2020-02-06T14:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDQ3Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372380476", "bodyText": "Why not use Path for path-like entities?", "author": "olpaw", "createdAt": "2020-01-29T13:28:02Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DirEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track the directory associated with one or\n+ * more source files.\n+ */\n+public class DirEntry {\n+    private String path;", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MjcwNg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383972706", "bodyText": "Done", "author": "adinn", "createdAt": "2020-02-25T15:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372381712", "bodyText": "Use Path here an you get Platform portability for free.", "author": "olpaw", "createdAt": "2020-01-29T13:30:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzAzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377773031", "bodyText": "I have pushed some changes which address this problem. I modified the interface between the native image writer and the object file to pass a String for file name and Path for directory. The object file writer also employs Path internally to store both dir names and full (dir-qualfiied) file names. This avoids issues any need to handle path separators.\nI'm not sure yet that this is all done though. In particular, the info in the hosted class and source node positions does not contain any information about original source file locations. So, the native image writer is still populating Path instances with the component elements of the hosted class's package name or the inlined class's qualified name, respectively.", "author": "adinn", "createdAt": "2020-02-11T17:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTMxMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383975310", "bodyText": "Thsi has been reworked. See other comments.", "author": "adinn", "createdAt": "2020-02-25T16:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MjkxMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372382910", "bodyText": "Should be a static class. Others likely as well. Event better split out into several source files", "author": "olpaw", "createdAt": "2020-01-29T13:32:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMTM5Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376331392", "bodyText": "Fixed as part of the move to separate files.", "author": "adinn", "createdAt": "2020-02-07T10:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MjkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NDk2MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372384961", "bodyText": "That is the right place to switch from Path to String objects.", "author": "olpaw", "createdAt": "2020-01-29T13:36:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+             ", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NjQwNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377776407", "bodyText": "Yes, uses of file names and paths are now converted at the point of use.", "author": "adinn", "createdAt": "2020-02-11T17:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NDk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372385631", "bodyText": "Strings ...", "author": "olpaw", "createdAt": "2020-01-29T13:38:12Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/FileEntry.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track debug info associated with a Java source file.\n+ */\n+public class FileEntry {\n+    // the name of the associated file including path\n+    private String fileName;\n+    // the name of the associated file excluding path\n+    private String baseName;\n+    // the directory entry associated with this file entry\n+    DirEntry dirEntry;\n+\n+    public FileEntry(String fileName, String baseName, DirEntry dirEntry) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NjU4NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377776585", "bodyText": "See the last commit.", "author": "adinn", "createdAt": "2020-02-11T17:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTY1Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383975656", "bodyText": "Yes, now using Path. See other comments", "author": "adinn", "createdAt": "2020-02-25T16:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjIzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372386231", "bodyText": "Always start JavaDoc with capital letter.", "author": "olpaw", "createdAt": "2020-01-29T13:39:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/PrimaryEntry.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * track debug info associated with a primary method.", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzM1MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377777350", "bodyText": "I have done a global update to all Javadoc and will endeavour to stick to this from now on. I will do a final pass once the other comments have been addressed.", "author": "adinn", "createdAt": "2020-02-11T17:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4ODQwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372388408", "bodyText": "afaics this is the only thing used atm, right?", "author": "olpaw", "createdAt": "2020-01-29T13:43:27Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NzY1OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375797658", "bodyText": "Yes, at present. However, the plan is to also allow the debug writer to iterate over types and details of heap contents courtesy of a DebugTypeInfoProvider and DebugDataInfoProvider. The details of those interfaces still need to be fully worked out.", "author": "adinn", "createdAt": "2020-02-06T12:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372390309", "bodyText": "In Java 11 the module base-name is also part of the full file path with the src.zip. e.g.\nsrc.zip contains /java.base/java/util/Set.class", "author": "olpaw", "createdAt": "2020-01-29T13:47:11Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2MTAwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378261008", "bodyText": "Well, I finally managed to rebuild using jdk11 (I had to nuke all the mxbuild dirs to get it to stop using cached jdk8 code) and found out some interesting things about pathe that probably need to be discussed and decided upon.\nI tweaked the path generation to add the result of ModuleSupport.getModuleName(javaClass) to the head of the path expression. So, for jdk11 runtime classes that will add e.g. \"java.base\" to the list of Path elements whereas for jdk8 runtime classes it will add nothing since  the module name is returned as \"\". This means that unzipped jdk sources are now being located correctly on both jdk8 and jdk11 assuming the root dir for the unzipped src.zip is added to the source path.\nI prefixed the module name to the file path for all classes that belong to a module on the assumption that this action would only apply for JDK runtime code. However, this assumption is not strictly correct as some Graal classes reside in JDK runtime modules.\nI noticed that, for example, class AllocationSnippets in package org/graalvm/compiler/replacements turns out to belong to module jdk.internal.vm.compiler. The source for this class actually sits in the Graal tree under root compiler/src/org.graalvm.compiler.replacements/src. Another example is class PrefetchAllocateNode which also belongs to module jdk.internal.vm.compiler. The source for this class also sits in the Graal tree under root compiler/src/org.graalvm.compiler.nodes/src.\nI also noticed that various of the Graal class sources are bundled into the src.zip for the jdk11 release I am using (labsjdk-ce-11.0.6+9-jvmci-20.0-b02-linux-amd64) and indeed are bundled into stock jdk11u releases. The source for PrefetchAllocateNode is present under root jdk.internal.vm.compiler/org.graalvm.compiler.nodes/src. However, the source for AllocationSnippets is not present. It looks as if these are present by because they are present in the OpenJDK repo (which may explain why AllocationSnippets.java is missing).\nSo, in order to find the correct versions of these sources from the Graal tree rather than from the OpenJDK src.zip it appears I will need to special case classes that are in certain well-known org.graal and com.oracle packages and not prefix the module to the file path for those cases. For example, the file path for PrefetchAllocateNode will need to be org/graalvm/compiler/nodes rather than jdk.internal.vm.compiler/org/graalvm/compiler/nodes.\nIn order to minimize the number of source roots needed to locate Graal sources it might also be helpful to insert the required overarching src root into the file path. For example, PrefetchAllocateNode might be better associated with file path org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/. That would  mean that only  compiler/src, substratevm/src etc would need to be supplied as source root dirs.\nThe difficutly with this is that it is not always clear what the oevrarching top level directory needs to be. For example, class CodeInfo.java sits under dir com.oracle.svm.core/src but resides in subdir com/oracle/svm/core/code because its is in a subpackage com.oracle.svm.core.code. Given any Graal class the overarching root dir always comprises some initial segment of the package name but it is not always clear which elements to include. This is slightly complicated by the need to recognize that classes in package com.oracle.svm.core.code map to root dir com.oracle.svm.core/src but that classes in package com.oracle.svm.core.graal map to root dir com.oracle.svm.core.graal/src\nI did actually implement a variant of the filepath computation some while back which used a hard-wired list of known root packages. I could easily do that again. However, the problem is keeping the list of source roots up to date with any changes. Do you have any other suggestions as to how to do this? Input from other Graal community devs woudl be very welcome.", "author": "adinn", "createdAt": "2020-02-12T13:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNTAxNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378315017", "bodyText": "This means that unzipped jdk sources are now being located correctly on both jdk8 and jdk11 assuming the root dir for the unzipped src.zip is added to the source path.\n\nUnzipping should happen transparently. Just use Zip File System Provider instead of requiring the user to unzip src.zip. See https://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html - For examples in our code base where we make use of Zip File System Provider see e.g. com.oracle.svm.driver.NativeImage#processClasspathNativeImageMetaInf(java.nio.file.Path, com.oracle.svm.driver.NativeImage.NativeImageMetaInfResourceProcessor)", "author": "olpaw", "createdAt": "2020-02-12T15:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyNTgyMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378325821", "bodyText": "Another example is class PrefetchAllocateNode which also belongs to module jdk.internal.vm.compiler. The source for this class also sits in the Graal tree under root compiler/src/org.graalvm.compiler.nodes/src.\n\nAs you noticed even vanilla JDK11 releases contain Graal. For debuginfo generation this version of Graal should be ignored (it exists so that vanilla JDK can provide Graal as tier-4 JIT compiler when using -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler). When we build native images we always use the version of Graal that is shipped as part of a GraalVM release. Thus any Graal related source files that exist in src.zip are irrelevant for us.", "author": "olpaw", "createdAt": "2020-02-12T15:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNDA5NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378334095", "bodyText": "However, the problem is keeping the list of source roots up to date with any changes.\n\nSure you could diff each file do decide if you need to update a preexisting target file but it is probably easier to simply copy over based on timestamps (if src or zip file that contains src is newer -> update)", "author": "olpaw", "createdAt": "2020-02-12T15:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM3MjY3Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378372673", "bodyText": "source roots needed to locate Graal sources\n\nA good heuristic for the roots is to inspect the jar files that are on the image classpath and check if you find a corresponding sibling file. E.g. for <graalvm>/lib/svm/builder/svm.jar you probe for <graalvm>/lib/svm/builder/svm.src.zip. If the classpath entry is a directory <dir> instead you probe for <dir>/src and <dir>/src_gen as roots. For each source file lookup you check against these roots for a match. (src.zip from jdk is a special case and should always be in the list of roots (obviously as last entry))", "author": "olpaw", "createdAt": "2020-02-12T16:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc3NDAzNg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378774036", "bodyText": "Unzipping should happen transparently. Just use Zip File System Provider instead of requiring the user to unzip src.zip. See https://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html - For examples in our code base where we make use of Zip File System Provider see e.g. com.oracle.svm.driver.NativeImage#processClasspathNativeImageMetaInf(java.nio.file.Path, com.oracle.svm.driver.NativeImage.NativeImageMetaInfResourceProcessor)\n\nI'm not clear what you are suggesting here. I understand how to use a zip file provider from Java. However, the problem I am looking at is how to allow gdb to locate a source file for a JDK class when it is running. gdb needs to be pointed at a root directory under which it can locate the sources. It is not going to unzip any files to do that.\nI believe the model you are proposing for resolving that requirement is that the native image generator should attempt to locate all the relevant JDK, Graal (and, perhaps, application) source files at image build time, bundling them into a jar/zip file provided as a secondary deliverable. If that jar/zip deliverable is correctly structured then it could be unzipped into a single root source directory from which all file paths and name nstalled into the debuginfo could be successfully resolved to the required source file at debug time. Is that a fair summary?\n\nA good heuristic for the roots is to inspect the jar files that are on the image classpath and check if you find a corresponding sibling file. E.g. for /lib/svm/builder/svm.jar you probe for /lib/svm/builder/svm.src.zip. If the classpath entry is a directory  instead you probe for /src and /src_gen as roots. For each source file lookup you check against these roots for a match. (src.zip from jdk is a special case and should always be in the list of roots (obviously as last entry))\n\nYes, I am sure I can implement a lookup model like that.\n\nAs you noticed even vanilla JDK11 releases contain Graal.  . . . Thus any Graal related source files that exist in src.zip are irrelevant for us.\n\nYes, I will ignore those files.", "author": "adinn", "createdAt": "2020-02-13T10:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc5NjA3NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378796074", "bodyText": "I'm not clear what you are suggesting here.\n\nI'm just saying the mechanism should be able to process zip-files, jar-files & directories alike as inputs (roots) and copy files referenced in debuginfo (--x-->) from those roots into one single output directory (preferably named sources) (the one that gdb will then use for file retrival):\n[... foo/prjx/src]\n[... foo/lib/gson.sources.jar]\n[...]                                           --x-->     [... foo/sources]\n[<graalvm>/lib/svm/builder/svm.src.zip]\n[<graalvm> ...]\n[<graalvm>/src.zip]\n\n(assuming an image gets built to ... foo (e.g. ... foo/myimage)\n\nbundling them into a jar/zip file\n\nJust building them into a sources sibling directory next to the image so that gdb can use it as is (also a directory is easier to keep up to date with changes from the roots side if you are rebuilding the image).", "author": "olpaw", "createdAt": "2020-02-13T11:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgwMTAwMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378801002", "bodyText": "Ok, that sounds fine. I'll work on adding that.", "author": "adinn", "createdAt": "2020-02-13T11:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyMDE4Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378820186", "bodyText": "n.b. I just updated the issue to record this conversation with a more precise 'spec'", "author": "adinn", "createdAt": "2020-02-13T12:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MzI5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383973296", "bodyText": "This has now been implemented -- see my other comment", "author": "adinn", "createdAt": "2020-02-25T16:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372406708", "bodyText": "Sometimes the source file isn't actually a .java file.  Is there any way to get access to the source name that was specified in the original .class file?  Or is this code only used when there is no debug info available?", "author": "dmlloyd", "createdAt": "2020-01-29T14:17:29Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3OTc3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375879777", "bodyText": "That's what is going on here. The call to declaringClass.getSourceFileName() actually reads the value from the class file -- well, strictly it finds the underlying Java class and reads the name out of the constant poll associated with the corresponding JVM InstanceKlass. So the code that constructs a name with extension java is just a fallback for when the bytecode contains no such entry.", "author": "adinn", "createdAt": "2020-02-06T14:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxOTEyMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375919123", "bodyText": "Ah, understood.  Thanks!", "author": "dmlloyd", "createdAt": "2020-02-06T15:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NDMwNA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383974304", "bodyText": "This has been reworked but the new code is still using the classfile info where it exists and defaulting to append .java to the class name (or its initial segment up to $) otherwise.", "author": "adinn", "createdAt": "2020-02-25T16:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372429201", "bodyText": "How about something more modern than Iterable. E.g. like:\n@Override\npublic Stream<DebugCodeInfo> codeInfoProvider() {\n    return compilations.entrySet().stream().map(NativeImageDebugCodeInfo::new);\n}", "author": "olpaw", "createdAt": "2020-01-29T14:54:03Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjAzMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376332030", "bodyText": "Yes, that would be neater.", "author": "adinn", "createdAt": "2020-02-07T10:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MTc0Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383971742", "bodyText": "@olpaw I just pushed another fix where I modified the DebugInfo interfaces to use Stream and tweaked the producers and consumers accordingly.", "author": "adinn", "createdAt": "2020-02-25T15:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372432668", "bodyText": "Does DWARF have a fixed endianness, or should it be using the ELFDATA value to determine this?", "author": "dmlloyd", "createdAt": "2020-01-29T14:59:28Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNzc1NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375917754", "bodyText": "Hmm, the DWARF standard didn't really make that clear but I talked to one of our debug experts (Mark Wielaard) and he confirmed that most numeric values need to follow target arch endianness. The special cases are ULEB and SLEB encoded numerics. So, I will update the code accordingly.", "author": "adinn", "createdAt": "2020-02-06T15:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5NTI3NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376995274", "bodyText": "I have pushed a fix that addresses the byte order issue.", "author": "adinn", "createdAt": "2020-02-10T11:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyODg5Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384528893", "bodyText": "Typo", "author": "olpaw", "createdAt": "2020-02-26T14:32:49Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringTable.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+ * Allows incoming strings to be reduced to unique (up\n+ * to equals) instances and supports marking of strings\n+ * which need to be written to the debug_str section\n+ * and retrieval of the location offset after writing.\n+ */\n+public class StringTable implements Iterable<StringEntry> {\n+\n+    private final HashMap<String, StringEntry> table;\n+\n+    public StringTable() {\n+        this.table = new HashMap<>();\n+    }\n+\n+    /**\n+     * Wnsures a unique instance of a string exists in the", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDY5OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384570699", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyODg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyOTU3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384529577", "bodyText": "I still see many of these comments starting with lowercase letters", "author": "olpaw", "createdAt": "2020-02-26T14:33:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringEntry.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * Used to retain a unique (up to equals) copy of a\n+ * String. Also flag swhether the String needs to be\n+ * located in the debug_string section and, if so,\n+ * tracks the offset at which it gets written.\n+ */\n+public class StringEntry {\n+    private String string;\n+    private int offset;\n+    private boolean addToStrSection;\n+\n+    StringEntry(String string) {\n+        this.string = string;\n+        this.offset = -1;\n+    }\n+\n+    public String getString() {\n+        return string;\n+    }\n+\n+    public int getOffset() {\n+        /*\n+         * offset must be set before this can be fetched", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NjgwOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384546809", "bodyText": "Yes. I cleaned up a lot of them before fixing the other issues but I have not yet done a second pass over them. I will do that as part of the next cleanup that handles all this feedback.", "author": "adinn", "createdAt": "2020-02-26T14:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyOTU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDg5OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550899", "bodyText": "dead code", "author": "olpaw", "createdAt": "2020-02-26T15:05:11Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODA1NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558055", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDk3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550977", "bodyText": "dead code", "author": "olpaw", "createdAt": "2020-02-26T15:05:19Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODQxMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558412", "bodyText": "fixed", "author": "adinn", "createdAt": "2020-02-26T15:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MTA3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384551072", "bodyText": "dead code", "author": "olpaw", "createdAt": "2020-02-26T15:05:27Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODE4NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558184", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384562450", "bodyText": "How about\npublic enum SourceCacheType {\n    JDK(\"jdk\"),\n    GRAALVM(\"graal\"),\n    APPLICATION(\"src\");\n\n    final Path subdir;\n\n    SourceCacheType(String subdir) {\n        this.subdir = Paths.get(subdir);\n    }\n}\ninstead of those protected static final fields ?", "author": "olpaw", "createdAt": "2020-02-26T15:21:52Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {\n+\n+    /*\n+     * properties needed to locate relevant JDK and app source roots\n+     */\n+    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n+    protected static final String JAVA_HOME_PROP = \"java.home\";\n+    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    /**\n+     * A list of root directories which may contain source files\n+     * from which this cache can be populated\n+     */\n+    protected List<Path> srcRoots;\n+\n+    /**\n+     * Create a source cache with a specific base type.\n+     * @param key a String identifying the subdir under\n+     * which sources should be cached which should also\n+     * match the type of content being cached\n+     */\n+    protected SourceCache(String key) {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+        srcRoots = new ArrayList<>();\n+\n+    }\n+\n+    /**\n+     * A local directory serving as the root for all\n+     * source trees maintained by the different\n+     * available source caches.\n+     */\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n+    /**\n+     * The top level path relative to the root directory\n+     * under which files belonging to this specific cache\n+     * are located.\n+     */\n+    private Path basePath;\n+    /**\n+     * JDK runtime code sources are cached using this key as a\n+     * leading path prefix with a module name as a sub-path\n+     * prefix when we have a modular JDK.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n+     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     */\n+    protected static final String JDK_CACHE_KEY = \"jdk\";", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MjY4OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384582688", "bodyText": "Yes, that looks better.", "author": "adinn", "createdAt": "2020-02-26T15:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNzM3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385127372", "bodyText": "I pushed this and used it to clean up the constructors for SourceCache and its subclasses", "author": "adinn", "createdAt": "2020-02-27T13:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDA4OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384580088", "bodyText": "adding\nabstract SourceCacheType getType();\n\ncould probably be handy at some point.", "author": "olpaw", "createdAt": "2020-02-26T15:46:25Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNzYzOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385127639", "bodyText": "Yes, I now use this in the cache constructors.", "author": "adinn", "createdAt": "2020-02-27T13:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDA4OA=="}], "type": "inlineReview"}, {"oid": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "url": "https://github.com/oracle/graal/commit/ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "message": "more format changes and fix some small errors in graal cache", "committedDate": "2020-03-10T14:47:11Z", "type": "forcePushed"}, {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "url": "https://github.com/oracle/graal/commit/c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "message": "support tracing of DWARF debug info modelling and generation to file using a debugContext provided via either the DebugInfoProvider API or via the ObjectFile", "committedDate": "2020-03-17T15:13:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395079448", "bodyText": "If the return value is not used anywhere use java.util.function.Consumer instead Function of to avoid pointless code such as\n    // doesn't actually matter what we return\n    return true;", "author": "olpaw", "createdAt": "2020-03-19T14:43:33Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java", "diffHunk": "@@ -1725,4 +1741,49 @@ public final SymbolTable getOrCreateSymbolTable() {\n             return createSymbolTable();\n         }\n     }\n+\n+    /**\n+     * Temporary storage for a debug context installed in a nested scope under a call.\n+     * to {@link #withDebugContext}\n+     */\n+    private DebugContext debugContext = null;\n+\n+    /**\n+     * Allows a function to be executed with a specific debug context in a named subscope bound to\n+     * the object file and accessible to code invoked during the lifetime of the function. Invoked\n+     * code may obtain access to the debug context using method {@link #debugContext}.\n+     * @param context a context to be bound toin the object file for the duration of the function\n+     *        execution.\n+     * @param scopeName a name to be used to define a subscope current while the function is being\n+     *        executed.\n+     * @param t a value to be injected into the function that performs the action.\n+     * @param function a function to be executed while the context is bound to the object file.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public <T, R> R withDebugContext(DebugContext context,  String scopeName, T t, Function<T, R> function) {", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MTU3MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395091570", "bodyText": "Actually you can even make that a Runnable. The passing of the channel like this is pointless ceremony.\nThen in com/oracle/svm/hosted/image/NativeBootImage.java you just have\ntry (FileChannel channel = FileChannel.open(outputFile, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE)) {\n    objectFile.withDebugContext(context, \"ObjectFile.write\", () -> {\n        objectFile.write(channel);\n    });\n}\n\nRemember this is not C++ ;-)", "author": "olpaw", "createdAt": "2020-03-19T14:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0MDAwNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395140007", "bodyText": "Well, I did start with a Consumer and then changed to a Function just in case you might want a more future-proof API. I was thinking it might later be decided that some other step of the ObjectFile write might need tracing and we could employ this Function flavour of withDebugContext where the operation needs to return a result. I'll happily switch to Consumer/Runnable. We can always switch back to Function if the need arises.\nAnd don't worry I have as little urge to use C++ features as the next OpenJDK programmer (well, modulo a few project 'enthusiasts' whose love of obscure C++ truly baffles me). Now Lisp would be a different matter . . . ;-)", "author": "adinn", "createdAt": "2020-03-19T16:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395097513", "bodyText": "Since we will also have Windows debug info generation it might be better to use\nreturn \"debug.dwarf.\" + getSectionName();\n\nhere so that we can have\nreturn \"debug.pdb.\" + getSectionName();\n\nfor Windows.", "author": "olpaw", "createdAt": "2020-03-19T15:07:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;\n+\n+    public DwarfSectionImpl(DwarfSections dwarfSections) {\n+        this.dwarfSections = dwarfSections;\n+    }\n+\n+    /**\n+     * creates the target byte[] array used to define the section contents.\n+     *\n+     * the main task of this method is to precompute the size of the debug section. given the\n+     * complexity of the data layouts that invariably requires performing a dummy write of the\n+     * contents, inserting bytes into a small, scratch buffer only when absolutely necessary.\n+     * subclasses may also cache some information for use when writing the contents.\n+     */\n+    public abstract void createContent();\n+\n+    /**\n+     * populates the byte[] array used to contain the section contents.\n+     *\n+     * in most cases this task reruns the operations performed under createContent but this time\n+     * actually writing data to the target byte[].\n+     */\n+    public abstract void writeContent(DebugContext debugContext);\n+\n+    @Override\n+    public boolean isLoadable() {\n+        /*\n+         * even though we're a progbits section impl we're not actually loadable\n+         */\n+        return false;\n+    }\n+\n+    public String debugSectionLogName() {", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzMTc4Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395131787", "bodyText": "Sure will correct that. I guess I should also leave the section name in lower case as well.", "author": "adinn", "createdAt": "2020-03-19T15:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzNTUwMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395135503", "bodyText": "I guess I should also leave the section name in lower case as well.\n\nYes. That would fit better to our existing use of scope names.", "author": "olpaw", "createdAt": "2020-03-19T15:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExOTA0OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395119048", "bodyText": "Is this a write-only field?", "author": "olpaw", "createdAt": "2020-03-19T15:35:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzMTA4Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395131087", "bodyText": "These are used when trace logging is enabled. They are updated in method enableLog(). n.b. currently only 3 of the DwarfSectionImpl subclasses generate trace. However, I have added the trace log functionality at the superclass level so that all Impl classes use it if/when it turns out to be needed.", "author": "adinn", "createdAt": "2020-03-19T15:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExOTA0OA=="}], "type": "inlineReview"}, {"oid": "648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "url": "https://github.com/oracle/graal/commit/648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "message": "Checkstyle adjustments for copyright header", "committedDate": "2020-03-20T12:00:30Z", "type": "forcePushed"}, {"oid": "536baf5fca1685afe4205fc2bca846568ab5043b", "url": "https://github.com/oracle/graal/commit/536baf5fca1685afe4205fc2bca846568ab5043b", "message": "avoid repeated dot in scope name", "committedDate": "2020-03-20T16:16:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTk3OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400235978", "bodyText": "@adinn, I think I already mentioned it, it's rather unusual in our codebase to start comments with lowercase.", "author": "olpaw", "createdAt": "2020-03-30T14:28:07Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debugentry;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Details of a specific address range in a compiled method either a primary range identifying a\n+ * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n+ * method.\n+ */\n+\n+public class Range {\n+    private String fileName;\n+    private Path filePath;\n+    private String className;\n+    private String methodName;\n+    private String paramNames;\n+    private String returnTypeName;\n+    private String fullMethodName;\n+    private int lo;\n+    private int hi;\n+    private int line;\n+    /*\n+     * this is null for a primary range", "originalCommit": "b17a12e2847085772f41ef3e9762d957865bcd05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NjU3MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400396571", "bodyText": "Hmm, yes. A-and also this specific case is very wrong ... this can never be null :-)\nI'll get my coat . . .\nSorry. I thought I had fixed all these but I clearly missed some. I have just done a full pass through all the new/changed files. I am fairly sure I now have all comments starting with a capital letter and ending with a full stop.", "author": "adinn", "createdAt": "2020-03-30T18:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTk3OA=="}], "type": "inlineReview"}, {"oid": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "url": "https://github.com/oracle/graal/commit/0a0b19984f6a90726dbff59cd65e05e260de6d81", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-03-31T11:25:21Z", "type": "forcePushed"}, {"oid": "b4680c224c85730ac0221155bab5881b98ea5bc1", "url": "https://github.com/oracle/graal/commit/b4680c224c85730ac0221155bab5881b98ea5bc1", "message": "Code cleanups", "committedDate": "2020-03-31T13:30:27Z", "type": "forcePushed"}, {"oid": "51c8f8f55d012aa5f073a608de6b66931c419c00", "url": "https://github.com/oracle/graal/commit/51c8f8f55d012aa5f073a608de6b66931c419c00", "message": "Code cleanups", "committedDate": "2020-03-31T13:46:17Z", "type": "forcePushed"}, {"oid": "dc16efa8528c7fb20a3bee0671214eee15edecff", "url": "https://github.com/oracle/graal/commit/dc16efa8528c7fb20a3bee0671214eee15edecff", "message": "use unique name for debuginfo gate test", "committedDate": "2020-04-01T09:41:07Z", "type": "forcePushed"}, {"oid": "ab1cb427a768786f0e6a70ae58e907861d8969de", "url": "https://github.com/oracle/graal/commit/ab1cb427a768786f0e6a70ae58e907861d8969de", "message": "Implement basic debuginfo generation for ELF objects", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "84516d367c30a9493ceab8b96043512a45442536", "url": "https://github.com/oracle/graal/commit/84516d367c30a9493ceab8b96043512a45442536", "message": "Add option GenerateDebugInfo=<level>", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "25c7101fcc02d41865ef60545b6177ee7842dbef", "url": "https://github.com/oracle/graal/commit/25c7101fcc02d41865ef60545b6177ee7842dbef", "message": "Use Path expressions for directories and file names", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "url": "https://github.com/oracle/graal/commit/53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "message": "Implement source file cache", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "url": "https://github.com/oracle/graal/commit/4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "message": "Modify debug info API to use streams instead of iterators", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "259171c5618e71769cbc7610e0ffc136d7d77562", "url": "https://github.com/oracle/graal/commit/259171c5618e71769cbc7610e0ffc136d7d77562", "message": "Added option DebugInfoSourceSearchPath=<path>\n\nTweak SourceCacheType enum\n\nClean up SourceCache initialization\n\nMemoize source cache checks", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "4b0aec7af896b5b20a0cbee931cf963906187669", "url": "https://github.com/oracle/graal/commit/4b0aec7af896b5b20a0cbee931cf963906187669", "message": "Support hierarchical logging", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "url": "https://github.com/oracle/graal/commit/1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-03T10:55:26Z", "type": "forcePushed"}, {"oid": "e4c876066b1122091bcaf68d869f94961d751724", "url": "https://github.com/oracle/graal/commit/e4c876066b1122091bcaf68d869f94961d751724", "message": "Abstract generic code for modelling debug info from DwarfSections into DebugInfoBase\n\nRename subclass DwarfSections to DwarfDebugInfo", "committedDate": "2020-04-06T09:44:26Z", "type": "commit"}, {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-06T09:45:25Z", "type": "commit"}, {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-06T09:45:25Z", "type": "forcePushed"}]}