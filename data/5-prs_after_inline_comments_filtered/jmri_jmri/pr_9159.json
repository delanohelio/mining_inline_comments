{"pr_number": 9159, "pr_title": "Preparation for LogixNG", "pr_createdAt": "2020-11-18T18:35:58Z", "pr_url": "https://github.com/JMRI/JMRI/pull/9159", "timeline": [{"oid": "da0c706fd16d14e7a89ff06892075d2722150791", "url": "https://github.com/JMRI/JMRI/commit/da0c706fd16d14e7a89ff06892075d2722150791", "message": "Preparation for LogixNG", "committedDate": "2020-11-18T18:30:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MTg3OA==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526341878", "bodyText": "Could you say a bit more about the motivation for this?  it's replacing a one-line common Java idiom with something JMRI specific.", "author": "bobjacobsen", "createdAt": "2020-11-18T18:54:57Z", "path": "java/src/jmri/util/TypeConversionUtil.java", "diffHunk": "@@ -0,0 +1,321 @@\n+package jmri.util;\n+\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckForNull;\n+import jmri.Reportable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Converts between java types, for example String to Double and double to boolean.\n+ * \n+ * @author Daniel Bergqvist Copyright 2019\n+ */\n+public final class TypeConversionUtil {\n+    \n+    /**\n+     * Is this object a Boolean?\n+     * @param object the object to check\n+     * @return true if the object is a Boolean, false otherwise\n+     */\n+    public static boolean isBoolean(Object object) {", "originalCommit": "da0c706fd16d14e7a89ff06892075d2722150791", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2MDE1MA==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526360150", "bodyText": "I don't remember but I think I added this method for completeness when I added the other similar methods. But I don't use it so I have removed it.", "author": "danielb987", "createdAt": "2020-11-18T19:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MTg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MjQ4OQ==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526342489", "bodyText": "This comment looks like a copy and paste, as it mentions integers instead of floats", "author": "bobjacobsen", "createdAt": "2020-11-18T18:55:53Z", "path": "java/src/jmri/util/TypeConversionUtil.java", "diffHunk": "@@ -0,0 +1,321 @@\n+package jmri.util;\n+\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckForNull;\n+import jmri.Reportable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Converts between java types, for example String to Double and double to boolean.\n+ * \n+ * @author Daniel Bergqvist Copyright 2019\n+ */\n+public final class TypeConversionUtil {\n+    \n+    /**\n+     * Is this object a Boolean?\n+     * @param object the object to check\n+     * @return true if the object is a Boolean, false otherwise\n+     */\n+    public static boolean isBoolean(Object object) {\n+        return object instanceof Boolean;\n+    }\n+    \n+    /**\n+     * Is this object an integer number?\n+     * <P>\n+     * The method returns true if the object is any of these classes:\n+     * <ul>\n+     *   <li>AtomicInteger</li>\n+     *   <li>AtomicLong</li>\n+     *   <li>BigInteger</li>\n+     *   <li>Byte</li>\n+     *   <li>Short</li>\n+     *   <li>Integer</li>\n+     *   <li>Long</li>\n+     * </ul>\n+     * @param object the object to check\n+     * @return true if the object is an object that is an integer, false otherwise\n+     */\n+    public static boolean isIntegerNumber(Object object) {\n+        return (object instanceof java.util.concurrent.atomic.AtomicInteger)\n+                || (object instanceof java.util.concurrent.atomic.AtomicLong)\n+                || (object instanceof java.math.BigInteger)\n+                || (object instanceof Byte)\n+                || (object instanceof Short)\n+                || (object instanceof Integer)\n+                || (object instanceof Long);\n+    }\n+    \n+    /**\n+     * Is this object an integer number?", "originalCommit": "da0c706fd16d14e7a89ff06892075d2722150791", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM2MTI0OQ==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526361249", "bodyText": "Yes, it is. Thanks.", "author": "danielb987", "createdAt": "2020-11-18T19:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0MjQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0NTMxNw==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526345317", "bodyText": "Could you please add some discussion as to when this type-not-safe method should be used, and when not?  Java has spent a decade moving toward type-safety via generics, multiple methods, etc.  So this is a bit off to the side.\nFor example, another approach would be have parallel methods with arguments typed Map, Collection, etc instead of decoding the type.\nIs there some motivation for actually carrying variables of Object type around?", "author": "bobjacobsen", "createdAt": "2020-11-18T19:00:19Z", "path": "java/src/jmri/util/TypeConversionUtil.java", "diffHunk": "@@ -0,0 +1,321 @@\n+package jmri.util;\n+\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckForNull;\n+import jmri.Reportable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Converts between java types, for example String to Double and double to boolean.\n+ * \n+ * @author Daniel Bergqvist Copyright 2019\n+ */\n+public final class TypeConversionUtil {\n+    \n+    /**\n+     * Is this object a Boolean?\n+     * @param object the object to check\n+     * @return true if the object is a Boolean, false otherwise\n+     */\n+    public static boolean isBoolean(Object object) {\n+        return object instanceof Boolean;\n+    }\n+    \n+    /**\n+     * Is this object an integer number?\n+     * <P>\n+     * The method returns true if the object is any of these classes:\n+     * <ul>\n+     *   <li>AtomicInteger</li>\n+     *   <li>AtomicLong</li>\n+     *   <li>BigInteger</li>\n+     *   <li>Byte</li>\n+     *   <li>Short</li>\n+     *   <li>Integer</li>\n+     *   <li>Long</li>\n+     * </ul>\n+     * @param object the object to check\n+     * @return true if the object is an object that is an integer, false otherwise\n+     */\n+    public static boolean isIntegerNumber(Object object) {\n+        return (object instanceof java.util.concurrent.atomic.AtomicInteger)\n+                || (object instanceof java.util.concurrent.atomic.AtomicLong)\n+                || (object instanceof java.math.BigInteger)\n+                || (object instanceof Byte)\n+                || (object instanceof Short)\n+                || (object instanceof Integer)\n+                || (object instanceof Long);\n+    }\n+    \n+    /**\n+     * Is this object an integer number?\n+     * <P>\n+     * The method returns true if the object is any of these classes:\n+     * <ul>\n+     *   <li>AtomicInteger</li>\n+     *   <li>AtomicLong</li>\n+     *   <li>BigInteger</li>\n+     *   <li>Byte</li>\n+     *   <li>Short</li>\n+     *   <li>Integer</li>\n+     *   <li>Long</li>\n+     *   <li>BigDecimal</li>\n+     *   <li>Float</li>\n+     *   <li>Double</li>\n+     * </ul>\n+     * @param object the object to check\n+     * @return true if the object is an object that is either an integer or a\n+     * float, false otherwise\n+     */\n+    public static boolean isFloatingNumber(Object object) {\n+        return isIntegerNumber(object)\n+                || (object instanceof java.math.BigDecimal)\n+                || (object instanceof Float)\n+                || (object instanceof Double);\n+    }\n+    \n+    /**\n+     * Is this object a String?\n+     * @param object the object to check\n+     * @return true if the object is a String, false otherwise\n+     */\n+    public static boolean isString(Object object) {\n+        return object instanceof String;\n+    }\n+    \n+    \n+    private static boolean convertStringToBoolean(@Nonnull String str, boolean do_i18n) {\n+        // try to parse the string as a number\n+        try {\n+            double number;\n+            if (do_i18n) {\n+                number = IntlUtilities.doubleValue(str);\n+            } else {\n+                number = Double.parseDouble(str);\n+            }\n+//                System.err.format(\"The string: '%s', result: %1.4f%n\", str, (float)number);\n+            return ! ((-0.5 < number) && (number < 0.5));\n+        } catch (NumberFormatException | ParseException ex) {\n+            log.debug(\"The string '{}' cannot be parsed as a number\", str);\n+        }\n+\n+//            System.err.format(\"The string: %s, %s%n\", str, value.getClass().getName());\n+        String patternString = \"^0(\\\\.0+)?$\";\n+        Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\n+        Matcher matcher = pattern.matcher(str);\n+        if (matcher.matches()) {\n+//                System.err.format(\"The string: '%s', result: %b%n\", str, false);\n+            return false;\n+        }\n+//            System.err.format(\"The string: '%s', result: %b%n\", str, !str.isEmpty());\n+        return !str.isEmpty();\n+    }\n+    \n+    /**\n+     * Convert a value to a boolean.\n+     * <P>\n+     * Rules:\n+     * null is converted to false\n+     * empty string is converted to false\n+     * \"0\" string is converted to false\n+     * \"0.000\" string is converted to false, if the number of decimals is &gt; 0\n+     * empty map is converted to false\n+     * empty collection is converted to false\n+     * An integer number is converted to false if the number is 0\n+     * A floating number is converted to false if the number is -0.5 &lt; x &lt; 0.5\n+     * Everything else is converted to true\n+     * <P>\n+     * For objects that implement the Reportable interface, the value is fetched\n+     * from the method toReportString().\n+     * \n+     * @param value the value to convert\n+     * @param do_i18n true if internationalization should be done, false otherwise\n+     * @return the boolean value\n+     */\n+    public static boolean convertToBoolean(@CheckForNull Object value, boolean do_i18n) {", "originalCommit": "da0c706fd16d14e7a89ff06892075d2722150791", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNjE1Ng==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526506156", "bodyText": "Expressions in LogixNG evaluates to a specific type, for example the ExpressionTurnout checks if a turnout has a specific state and returns true or false. And the StringExpressionMemory reads a memory and returns its value as a string. If a LocoNet device supports sending analog values, for example an axle counter, an analog expression could read that analog value and return it as such.\nBut what if you want to do some calculations? You might have stored the previous value from the axle counter in a memory and you now want to add the memory value to the current value of the axle counter. For this purpose, there is the expression Formula, which takes a number of expressions and a formula and calculates the formula and returns the result.\nBut what if you want to calculate some things that has different types? If you have axle counter A from Digitrax that sends the value as a string and you have axle counter B from Roco that sends the value as an integer? How do you add an integer to a string?\nThe expression Formula can handle this. Its child expressions can be of any type, for example analog expression or string expression, and you can tell Formula to convert the expression E2 to an integer and then add it to expression E1.\nThis example shows a ConditionalNG that has an action that reads an analog value and then sets an analog value. It reads the result of a formula, which in this case is E1 + int(E2). E1 is the analog value of memory IM_91 and E2 is the string value of memory IM_92. int(x) do the conversion from string to integer. It then puts the sum in the memory IM_100.\n\nThis is not limited to simple addition or multiplication. The expression Formula supports different functions, for example sin(x), which may be useful if you want to take the hour of the fast clock, convert it to a sine wave and use it to set the intensity of the light in the room to get the impression of day and night in the room.\nDue to this, I don't know in advance which type of data Formula will handle. The expression E1 may be a string, expression E2 an analog value and expression E3 may be a boolean. You might want a formula like this:\n(E1 == \"Big yard\") && ((E2 < 32) || E3)\nThis is a valid formula if E1 is a string, E2 an double and E3 a boolean.", "author": "danielb987", "createdAt": "2020-11-19T00:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0NTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyMjUwMA==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526522500", "bodyText": "Thanks for the detail.  What does the expression\n(E1 == \"Big yard\") && ((E2 < 32) || E3)\n\ndo if  E1 is a double, E2 a string and E3 a string?\nI'd expect that the E1 comparison would always fail, so this would evaluated to false always.  Setting that aside, there's probably rules for converting a string to a Boolean, so the E3 term can be handled.  But what happens to E2 < 32?  Can you guarantee that exactly one of E2<32, E2==32, and E2>32 is true?", "author": "bobjacobsen", "createdAt": "2020-11-19T00:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0NTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUyNzg2Mw==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526527863", "bodyText": "I try to follow the rules of Jython since I expect that that is what most users are familiar with. It was maybe a year ago I wrote the formula expression so I don't remember the details, but I tried different expressions in Jython and did the same thing in Formula.\nprint 10 + \"Hello\" causes an error in Jython, so I do the same in Formula.\nprint 10 < \"0\" returns true and print 10 > \"0\" returns false, and Formula does the same.", "author": "danielb987", "createdAt": "2020-11-19T01:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0NTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMjUzMw==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r526532533", "bodyText": "Can you guarantee that exactly one of E2<32, E2==32, and E2>32 is true?\n\nThe comparision method is here:\nhttps://github.com/danielb987/JMRI/blob/26e005cc5808aed457401fd79889de673ec1de47/java/src/jmri/jmrit/logixng/util/parser/ExpressionNodeComparingOperator.java#L39\nThe method calculate() at lines 39 - 107 does the evaluation.\nThe arithmetic operators are here:\nhttps://github.com/danielb987/JMRI/blob/26e005cc5808aed457401fd79889de673ec1de47/java/src/jmri/jmrit/logixng/util/parser/ExpressionNodeArithmeticOperator.java#L45\nThe method calculate() at lines 141 - 180 uses the methods add(), sub(), ...", "author": "danielb987", "createdAt": "2020-11-19T01:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0NTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjQ2MQ==", "url": "https://github.com/JMRI/JMRI/pull/9159#discussion_r528042461", "bodyText": "Can you guarantee that exactly one of E2<32, E2==32, and E2>32 is true?\n\nThanks for asking. While taking a second look at the code, I found a couple of bugs. I also added tests for the compare operatiors.\nExpressionNodeComparingOperator\nhttps://github.com/danielb987/JMRI/blob/LogixNG_new5_006/java/src/jmri/jmrit/logixng/util/parser/ExpressionNodeComparingOperator.java\nExpressionNodeComparingOperatorTest\nhttps://github.com/danielb987/JMRI/blob/LogixNG_new5_006/java/test/jmri/jmrit/logixng/util/parser/ExpressionNodeComparingOperatorTest.java", "author": "danielb987", "createdAt": "2020-11-21T00:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjM0NTMxNw=="}], "type": "inlineReview"}, {"oid": "152088207e2f64416f49119ae443941b1d3d6e15", "url": "https://github.com/JMRI/JMRI/commit/152088207e2f64416f49119ae443941b1d3d6e15", "message": "Remove unneeded method. Fix copy/paste error", "committedDate": "2020-11-18T19:23:13Z", "type": "commit"}]}