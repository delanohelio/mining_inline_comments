{"pr_number": 9009, "pr_title": "Initial IPOCS implementation", "pr_createdAt": "2020-09-10T15:38:08Z", "pr_url": "https://github.com/JMRI/JMRI/pull/9009", "timeline": [{"oid": "456c45254dcb0c00fea88dbfbdb31e1d23a01626", "url": "https://github.com/JMRI/JMRI/commit/456c45254dcb0c00fea88dbfbdb31e1d23a01626", "message": "Initial IPOCS implementation", "committedDate": "2020-09-10T15:51:15Z", "type": "forcePushed"}, {"oid": "19e22710996229c22d5b5b48fd9fb0ea253d1a30", "url": "https://github.com/JMRI/JMRI/commit/19e22710996229c22d5b5b48fd9fb0ea253d1a30", "message": "Initial IPOCS implementation", "committedDate": "2020-09-10T15:54:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MzY5NA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r486473694", "bodyText": "This class is in the src tree but I think it should be in the test tree.\njava/src/jmri/jmrix/configurexml/AbstractConfigXmlTestBase.java\nshould be\njava/test/jmri/jmrix/configurexml/AbstractConfigXmlTestBase.java", "author": "danielb987", "createdAt": "2020-09-10T16:23:12Z", "path": "java/src/jmri/jmrix/configurexml/AbstractConfigXmlTestBase.java", "diffHunk": "@@ -0,0 +1,5 @@\n+package jmri.jmrix.configurexml;\n+\n+public class AbstractConfigXmlTestBase {", "originalCommit": "19e22710996229c22d5b5b48fd9fb0ea253d1a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDAzMg==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r486484032", "bodyText": "Thanks for spotting it - it wasn't supposed to be there at all. An autocreated file because I hit the wrong option when I was writing a test :p", "author": "elestedt", "createdAt": "2020-09-10T16:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MzY5NA=="}], "type": "inlineReview"}, {"oid": "1d38c6dcedb53862f81cb83a0916cbd60b717a7b", "url": "https://github.com/JMRI/JMRI/commit/1d38c6dcedb53862f81cb83a0916cbd60b717a7b", "message": "Initial IPOCS implementation", "committedDate": "2020-09-10T16:39:40Z", "type": "forcePushed"}, {"oid": "cf8e2128ecd0c1355fc18a6dffc8356a6c5364fa", "url": "https://github.com/JMRI/JMRI/commit/cf8e2128ecd0c1355fc18a6dffc8356a6c5364fa", "message": "Fix compilation issues", "committedDate": "2020-09-11T18:34:10Z", "type": "forcePushed"}, {"oid": "e50ca88068736cc453122e2011c3839364c1dfe9", "url": "https://github.com/JMRI/JMRI/commit/e50ca88068736cc453122e2011c3839364c1dfe9", "message": "Fix compilation issues", "committedDate": "2020-09-11T18:43:43Z", "type": "forcePushed"}, {"oid": "e8994f2705dedcd787494d0b1f7d7b2d127c4730", "url": "https://github.com/JMRI/JMRI/commit/e8994f2705dedcd787494d0b1f7d7b2d127c4730", "message": "Fix compilation issues", "committedDate": "2020-09-11T19:55:07Z", "type": "forcePushed"}, {"oid": "139a9c5681df98126b897deebba68291a3ea3f1d", "url": "https://github.com/JMRI/JMRI/commit/139a9c5681df98126b897deebba68291a3ea3f1d", "message": "Fix compilation issues", "committedDate": "2020-09-11T21:00:45Z", "type": "forcePushed"}, {"oid": "6782ee9f348e9f2106daacae4893722cc57e8e01", "url": "https://github.com/JMRI/JMRI/commit/6782ee9f348e9f2106daacae4893722cc57e8e01", "message": "Upgrade mockito and to tests", "committedDate": "2020-09-12T15:30:38Z", "type": "forcePushed"}, {"oid": "914d551f607a8024360a02b6b73ee0f2c89e9505", "url": "https://github.com/JMRI/JMRI/commit/914d551f607a8024360a02b6b73ee0f2c89e9505", "message": "Last tests", "committedDate": "2020-09-12T17:33:20Z", "type": "forcePushed"}, {"oid": "41f5ab5f0f126ce4242ad346a95af19e6a619f74", "url": "https://github.com/JMRI/JMRI/commit/41f5ab5f0f126ce4242ad346a95af19e6a619f74", "message": "Updated documentation", "committedDate": "2020-09-12T18:41:21Z", "type": "forcePushed"}, {"oid": "a40c02e6f1dea59c150681fa38a89da7224f81fa", "url": "https://github.com/JMRI/JMRI/commit/a40c02e6f1dea59c150681fa38a89da7224f81fa", "message": "Futureproof unit ID", "committedDate": "2020-09-12T19:14:06Z", "type": "forcePushed"}, {"oid": "159990ee7cd5b68608fb1ca054d1eabb85d4b605", "url": "https://github.com/JMRI/JMRI/commit/159990ee7cd5b68608fb1ca054d1eabb85d4b605", "message": "Futureproof unit ID", "committedDate": "2020-09-12T19:38:04Z", "type": "forcePushed"}, {"oid": "99f9303761f40e679e10e92fe4214a57e55631f1", "url": "https://github.com/JMRI/JMRI/commit/99f9303761f40e679e10e92fe4214a57e55631f1", "message": "Add class comments/copyright notice", "committedDate": "2020-09-13T07:41:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5MzM1NQ==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r487593355", "bodyText": "Should these methods never be called? If so, it would be better if they throw an UnsupportedOperationException(\"Not supported\"), since that would throw an exception when the method is called and not when the returned stream is used.", "author": "danielb987", "createdAt": "2020-09-13T23:45:45Z", "path": "java/src/jmri/jmrix/ipocs/IpocsPortController.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package jmri.jmrix.ipocs;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.StandardSocketOptions;\n+import java.nio.channels.AsynchronousServerSocketChannel;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jmri.jmrix.AbstractPortController;\n+import jmri.jmrix.ipocs.protocol.Message;\n+import jmri.util.zeroconf.ZeroConfService;\n+\n+/**\n+ *\n+ * @author Fredrik Elestedt Copyright (C) 2020\n+ * @since 4.21.2\n+ */\n+public class IpocsPortController extends AbstractPortController implements IpocsClientListener {\n+  private final static Logger log = LoggerFactory.getLogger(IpocsPortController.class);\n+  private static String INADDR_ANY = \"0.0.0.0\";\n+  private AsynchronousServerSocketChannel serverSocket = null;\n+  private IpocsSocketAcceptor socketAcceptor;\n+  private ZeroConfService zeroConfService = null;\n+  private final List<IpocsClientListener> clientListeners = new ArrayList<IpocsClientListener>();\n+  private Map<String, IpocsClientHandler> clients = new HashMap<>();\n+  private Map<String, Message> lastMessage = new HashMap<>();\n+\n+  public IpocsPortController(IpocsSystemConnectionMemo memo) {\n+    super(memo);\n+    super.setManufacturer(IpocsConnectionTypeList.IPOCSMR);\n+    final Option o1 = new Option(\"Listing port\", new String[]{\"10000\"}, false, Option.Type.TEXT);\n+    super.options.put(super.option1Name, o1);\n+  }\n+\n+  @Override\n+  public IpocsSystemConnectionMemo getSystemConnectionMemo() {\n+    return (IpocsSystemConnectionMemo) super.getSystemConnectionMemo();\n+  }\n+\n+  @Override\n+  public void configure() {\n+    if (getSystemConnectionMemo().getPortController() == null) {\n+      getSystemConnectionMemo().setPortController(this);\n+    }\n+    getSystemConnectionMemo().configureManagers();\n+  }\n+\n+  @Override\n+  public void connect() throws IOException {\n+    log.info(\"Setting up service\");\n+    serverSocket = AsynchronousServerSocketChannel.open();\n+    socketAcceptor = new IpocsSocketAcceptor(this, serverSocket);\n+    final int port = Integer.parseInt(super.getOptionState(super.option1Name));\n+    final InetSocketAddress address = new InetSocketAddress(INADDR_ANY, port);\n+    serverSocket.bind(address);\n+    serverSocket.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n+    serverSocket.accept(null, socketAcceptor);\n+    log.info(\"Starting ZeroConfService _ipocs._tcp.local\");\n+    zeroConfService = ZeroConfService.create(\"_ipocs._tcp.local.\", \"ipocs\", 10000, 0, 0, new HashMap<String, String>());\n+    zeroConfService.publish();\n+  }\n+\n+  @Override\n+  public DataInputStream getInputStream() {\n+    // This will never return anything, since this is a server port controller\n+    return null;\n+  }\n+\n+  @Override\n+  public DataOutputStream getOutputStream() {\n+    // This will never return anything, since this is a server port controller\n+    return null;\n+  }", "originalCommit": "99f9303761f40e679e10e92fe4214a57e55631f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4NzY5Ng==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r487687696", "bodyText": "I opted against that since I did not know if any part of JMRI called these funtions and expected a return or null if the streams should not be used.\nIf they aren't called by any other part of JMRI - why are they there?", "author": "elestedt", "createdAt": "2020-09-14T06:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5MzM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU1MDg3OA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r488550878", "bodyText": "Changed", "author": "elestedt", "createdAt": "2020-09-15T10:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5MzM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5Mzg5MA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r487593890", "bodyText": "Is this code that's not finished? Just checking so you haven't forgotten about it.", "author": "danielb987", "createdAt": "2020-09-13T23:50:38Z", "path": "java/src/jmri/jmrix/ipocs/configurexml/IpocsConnectionConfigXml.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package jmri.jmrix.ipocs.configurexml;\n+\n+import java.io.IOException;\n+\n+import org.jdom2.Element;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jmri.configurexml.JmriConfigureXmlException;\n+import jmri.jmrix.configurexml.AbstractConnectionConfigXml;\n+import jmri.jmrix.ipocs.IpocsConnectionConfig;\n+import jmri.jmrix.ipocs.IpocsPortController;\n+import jmri.jmrix.ipocs.IpocsSystemConnectionMemo;\n+\n+/**\n+ *\n+ * @author Fredrik Elestedt Copyright (C) 2020\n+ * @since 4.21.2\n+ */\n+public class IpocsConnectionConfigXml extends AbstractConnectionConfigXml {\n+  private final static Logger log = LoggerFactory.getLogger(IpocsConnectionConfigXml.class);\n+  IpocsPortController portController;\n+\n+  public IpocsConnectionConfigXml() {\n+    super();\n+  }\n+\n+  @Override\n+  public Element store(Object o) {\n+    Element e = new Element(\"connection\");\n+    getInstance((IpocsConnectionConfig)o);\n+\n+    storeCommon(e, portController);\n+    e.setAttribute(\"port\", \"10000\");\n+    e.setAttribute(\"enableAutoConf\", \"true\");\n+    e.setAttribute(\"class\", this.getClass().getName());\n+\n+    extendElement(e);\n+    return e;\n+  }\n+\n+  @Override\n+  public boolean load(Element shared, Element perNode) throws JmriConfigureXmlException {\n+    getInstance();\n+    try {\n+      // TODO do this\n+      //int port = Integer.parseInt(shared.getAttribute(\"port\").getValue());\n+      //portController.setPort(port);\n+    } catch (NullPointerException ex) {\n+    }\n+    try {\n+      // TODO do this\n+      //boolean autoConf = shared.getAttribute(\"enableAutoConf\").getValue().equals(\"true\");\n+      //portController.setAutoConf(hostName);\n+    } catch (NullPointerException ex) {\n+    }", "originalCommit": "99f9303761f40e679e10e92fe4214a57e55631f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4NjY3MQ==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r487686671", "bodyText": "I originally planed to have the port it uses configurable - but just couldn't get it to work... I tried - and failed with the graphical parts of it. Any pointers would be appriciated.\nAlso, the 2nd option, to disable auto configuration (mDNS) I think can be removed - as the entire IPOCSMR requires it in order to connect.", "author": "elestedt", "createdAt": "2020-09-14T06:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5Mzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU1MDk1MA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r488550950", "bodyText": "Fixed", "author": "elestedt", "createdAt": "2020-09-15T10:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5Mzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5NjE2Mw==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r487596163", "bodyText": "Should this line put the size of the buffer at byte 0? If so, are you sure that the length of the serialized packets will not exceed 255 bytes?", "author": "danielb987", "createdAt": "2020-09-14T00:08:58Z", "path": "java/src/jmri/jmrix/ipocs/protocol/Message.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package jmri.jmrix.ipocs.protocol;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import jmri.jmrix.ipocs.protocol.packets.Packet;\n+\n+/**\n+ * Represents a IPOCS Message.\n+ *\n+ * Protocol details can be found on the project website, https://ipocsmr.github.io\n+ *\n+ * @author Fredrik Elestedt Copyright (C) 2020\n+ * @since 4.21.2\n+ */\n+public class Message {\n+  private final static Logger log = LoggerFactory.getLogger(Message.class);\n+  private byte length;\n+  private String objectName;\n+  private List<Packet> packets = new ArrayList<Packet>();\n+\n+  public byte getLength() {\n+    return length;\n+  }\n+\n+  public String getObjectName() {\n+    return objectName;\n+  }\n+\n+  public void setObjectName(String objectName) {\n+      this.objectName = objectName;\n+  }\n+\n+  public List<Packet> getPackets() {\n+    return packets;\n+  }\n+\n+  public static Message parse(ByteBuffer buffer, Integer contentSize) {\n+    int startPos = buffer.position();\n+    Message msg = new Message();\n+    // Get length\n+    msg.length = buffer.get();\n+    // Ensure that there are enough bytes in the buffer:\n+    if (msg.length > contentSize) {\n+      return null;\n+    }\n+    // Get object name\n+    StringBuilder sb = new StringBuilder();\n+    byte last;\n+    while ((last = buffer.get()) != 0x00) {\n+      sb.append((char) last);\n+    }\n+    msg.objectName = sb.toString();\n+    // Parse packets\n+    Packet packet;\n+    log.debug(\"Message for {}\", msg.objectName);\n+    while (buffer.position() - startPos < msg.length && (packet = Packet.parse(buffer)) != null) {\n+      msg.packets.add(packet);\n+    }\n+    return msg;\n+  }\n+\n+  public ByteBuffer serialize() {\n+    ByteBuffer buffer = ByteBuffer.allocate(1 + objectName.length() + 1);\n+    buffer.put(length);\n+    buffer.put(objectName.getBytes());\n+    buffer.put((byte)0);\n+    for (Packet packet : packets) {\n+      ByteBuffer serPacket = packet.serialize();\n+      ByteBuffer oldBuffer = buffer;\n+      oldBuffer.rewind();\n+      serPacket.rewind();\n+      buffer = ByteBuffer.allocate(buffer.capacity() + serPacket.capacity());\n+      buffer.put(oldBuffer);\n+      buffer.put(serPacket);\n+    }\n+    buffer.put(0, (byte)buffer.capacity());", "originalCommit": "99f9303761f40e679e10e92fe4214a57e55631f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4ODU0MA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r487688540", "bodyText": "Yes, it's supposed to go at byte 0. It's not until the rest of the serialisation is done that we know the length of the message.\nThe protocol does not allow for longer messages - so yes :D but you're right - probably should add checks in various places (like checking the length of the beans user names) to make sure it will never happen.", "author": "elestedt", "createdAt": "2020-09-14T06:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5NjE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU5Mzc3NA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r488593774", "bodyText": "Please add a check that the buffer is not greater than 255 bytes. At least write a message to the log:\nif (buffer.capacity() > 255) log.error(\"Serialized message is longer than 255 bytes\");\nThat gives us an error message in the log in case it goes wrong for a user. Or you may throw an exception if this happens.", "author": "danielb987", "createdAt": "2020-09-15T11:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5NjE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU5NTEyMg==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r488595122", "bodyText": "Yeah - I will throw an exception there. The only way that will happen is if a userName on a object in the layout is longer than say 230 characters...", "author": "elestedt", "createdAt": "2020-09-15T11:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5NjE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY0MDYzOA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r488640638", "bodyText": "Thanks!", "author": "danielb987", "createdAt": "2020-09-15T12:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU5NjE2Mw=="}], "type": "inlineReview"}, {"oid": "6366f0be10426c52ec2b31664883dff2e07acd01", "url": "https://github.com/JMRI/JMRI/commit/6366f0be10426c52ec2b31664883dff2e07acd01", "message": "Allow changing listening port", "committedDate": "2020-09-15T10:13:44Z", "type": "forcePushed"}, {"oid": "6cc4ec2a65b18199162d0231b617cc3fab699870", "url": "https://github.com/JMRI/JMRI/commit/6cc4ec2a65b18199162d0231b617cc3fab699870", "message": "Add bundle", "committedDate": "2020-09-15T11:59:13Z", "type": "forcePushed"}, {"oid": "d52d03778cf3bd2716f29a42e732a153a9a663fe", "url": "https://github.com/JMRI/JMRI/commit/d52d03778cf3bd2716f29a42e732a153a9a663fe", "message": "Add bundle", "committedDate": "2020-09-15T12:37:11Z", "type": "forcePushed"}, {"oid": "3d0488529a4ed597ae19f51376db2dc04ad3f8a3", "url": "https://github.com/JMRI/JMRI/commit/3d0488529a4ed597ae19f51376db2dc04ad3f8a3", "message": "Add bundle", "committedDate": "2020-09-15T13:14:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4MjEyMw==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r488982123", "bodyText": "What is the commented code for? Old code that isn't used any more or an unfinished test?", "author": "danielb987", "createdAt": "2020-09-15T21:25:32Z", "path": "java/test/jmri/jmrix/ipocs/IpocsClientHandlerTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package jmri.jmrix.ipocs;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousSocketChannel;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+import jmri.jmrix.ipocs.protocol.Message;\n+import jmri.jmrix.ipocs.protocol.packets.ConnectionRequestPacket;\n+import jmri.jmrix.ipocs.protocol.packets.SignOfLifePacket;\n+\n+public class IpocsClientHandlerTest {\n+\n+  @Mock\n+  public AsynchronousSocketChannel client;\n+\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private final IpocsClientListener listener = new IpocsClientListener() {\n+    @Override\n+    public String getUserName() {\n+      return null;\n+    }\n+\n+    @Override\n+    public void clientConnected(final IpocsClientHandler client) {\n+    }\n+\n+    @Override\n+    public void clientDisconnected(final IpocsClientHandler client) {\n+    }\n+\n+    @Override\n+    public void onMessage(final IpocsClientHandler client, final Message msg) {\n+    }\n+  };\n+\n+  @Test\n+  public void constructorTest() {\n+    assertNotNull(new IpocsClientHandler(client));\n+  }\n+\n+  @Test\n+  public void getUnitIdTest() {\n+    assertEquals(null, new IpocsClientHandler(client).getUnitId());\n+  }\n+\n+  @Test\n+  public void completedClosedTest() throws IOException {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    ch.addClientListener(listener);\n+    ch.completed(-1, null);\n+    doThrow(new IOException()).when(client).close();\n+    ch.completed(-1, null);\n+  }\n+\n+  @Test\n+  public void completedReceived1Test() throws IOException {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    ch.addClientListener(listener);\n+    final Message msg = new Message();\n+    msg.setObjectName(\"testing\");\n+    final ByteBuffer buff = msg.serialize();\n+    buff.position(buff.capacity());\n+    ch.completed(buff.capacity(), buff);\n+  }\n+\n+  @Test\n+  public void completedReceived2Test() throws IOException {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    ch.addClientListener(listener);\n+    final Message msg = new Message();\n+    msg.setObjectName(\"testing\");\n+    msg.getPackets().add(new SignOfLifePacket());\n+    final ByteBuffer buff = msg.serialize();\n+    buff.position(buff.capacity());\n+    ch.completed(buff.capacity(), buff);\n+  }\n+\n+  @Test\n+  public void completedReceived3Test() throws IOException {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    ch.addClientListener(listener);\n+    final Message msg = new Message();\n+    msg.setObjectName(\"5\");\n+    final ConnectionRequestPacket pkt = new ConnectionRequestPacket();\n+    pkt.setProtocolVersion((short) 0x0000);\n+    pkt.setSiteDataVersion(\"3df43d\");\n+    msg.getPackets().add(pkt);\n+    final ByteBuffer buff = msg.serialize();\n+    buff.position(buff.capacity());\n+    ch.completed(buff.capacity(), buff);\n+  }\n+\n+  @Test\n+  public void failedTest() throws IOException {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    ch.failed(new Exception(\"Error\"), null);\n+    jmri.util.JUnitAppender.suppressErrorMessage(\"Error closing connection\");\n+    ch.addClientListener(listener);\n+    doThrow(new IOException()).when(client).close();\n+    ch.failed(new Exception(\"Error\"), null);\n+    jmri.util.JUnitAppender.suppressErrorMessage(\"Error closing connection\");\n+  }\n+\n+  @Test\n+  public void addClientListenerTest() {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    ch.addClientListener(listener);\n+  }\n+\n+  @Test\n+  public void removeClientListenerTest() {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    ch.removeClientListener(listener);\n+  }\n+\n+  @Test\n+  public void sendMessageTest() {\n+    final IpocsClientHandler ch = new IpocsClientHandler(client);\n+    final Message msg = mock(Message.class);\n+    //final ArgumentCaptor<ByteBuffer> captor = ArgumentCaptor.forClass(ByteBuffer.class);\n+    when(msg.serialize()).thenReturn(ByteBuffer.wrap(new byte[] {}));\n+    //verify(client).write(captor.capture());\n+    ch.send(msg);\n+    //final ByteBuffer argument = captor.getValue();\n+\n+    //assertEquals(0, argument.capacity());\n+  }", "originalCommit": "3d0488529a4ed597ae19f51376db2dc04ad3f8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4NjU1MA==", "url": "https://github.com/JMRI/JMRI/pull/9009#discussion_r488986550", "bodyText": "thrown away code from when I was testing mocking and stuff. removed.", "author": "elestedt", "createdAt": "2020-09-15T21:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4MjEyMw=="}], "type": "inlineReview"}, {"oid": "decc0d5b754ca56548d97bdad5d21f8e6eb58951", "url": "https://github.com/JMRI/JMRI/commit/decc0d5b754ca56548d97bdad5d21f8e6eb58951", "message": "Initial IPOCS implementation", "committedDate": "2020-09-15T21:30:48Z", "type": "commit"}, {"oid": "809116d4f60fb285e751b841d714d6504fa7086a", "url": "https://github.com/JMRI/JMRI/commit/809116d4f60fb285e751b841d714d6504fa7086a", "message": "Add Message test", "committedDate": "2020-09-15T21:30:56Z", "type": "commit"}, {"oid": "e4d87254ce7b8e97dab754efa6ca62607759053a", "url": "https://github.com/JMRI/JMRI/commit/e4d87254ce7b8e97dab754efa6ca62607759053a", "message": "Added more tests", "committedDate": "2020-09-15T21:30:56Z", "type": "commit"}, {"oid": "a86632153c161736601311397aaa3e36dd9a5537", "url": "https://github.com/JMRI/JMRI/commit/a86632153c161736601311397aaa3e36dd9a5537", "message": "Fix compilation issues", "committedDate": "2020-09-15T21:30:56Z", "type": "commit"}, {"oid": "4b53f813b121bf9b5fc7663bcf70fabdd6711487", "url": "https://github.com/JMRI/JMRI/commit/4b53f813b121bf9b5fc7663bcf70fabdd6711487", "message": "Fixed tests", "committedDate": "2020-09-15T21:30:57Z", "type": "commit"}, {"oid": "6e3db6486203c9f671158a933faccbe3958473ec", "url": "https://github.com/JMRI/JMRI/commit/6e3db6486203c9f671158a933faccbe3958473ec", "message": "More tests", "committedDate": "2020-09-15T21:32:20Z", "type": "commit"}, {"oid": "d452f063ee11ce40cbcbe80455623c67f95c39b9", "url": "https://github.com/JMRI/JMRI/commit/d452f063ee11ce40cbcbe80455623c67f95c39b9", "message": "Upgrade mockito and to tests", "committedDate": "2020-09-15T21:33:37Z", "type": "commit"}, {"oid": "5d5c958f3a606ec66d270637662bd56473784979", "url": "https://github.com/JMRI/JMRI/commit/5d5c958f3a606ec66d270637662bd56473784979", "message": "Last tests", "committedDate": "2020-09-15T21:33:42Z", "type": "commit"}, {"oid": "4fee183bbe90c54bf8e3956635c6aeda7c7b6103", "url": "https://github.com/JMRI/JMRI/commit/4fee183bbe90c54bf8e3956635c6aeda7c7b6103", "message": "Updated documentation", "committedDate": "2020-09-15T21:33:43Z", "type": "commit"}, {"oid": "5f9b6e35cec6032cb7a115eb14efada9fffa137c", "url": "https://github.com/JMRI/JMRI/commit/5f9b6e35cec6032cb7a115eb14efada9fffa137c", "message": "Futureproof unit ID", "committedDate": "2020-09-15T21:33:43Z", "type": "commit"}, {"oid": "19e7118b9fd13c41c876bc3eb985f3e0b5eb5a59", "url": "https://github.com/JMRI/JMRI/commit/19e7118b9fd13c41c876bc3eb985f3e0b5eb5a59", "message": "Draft release notes", "committedDate": "2020-09-15T21:33:43Z", "type": "commit"}, {"oid": "f7a741d7501f2b3ea50387b5e7e769ef1df1245a", "url": "https://github.com/JMRI/JMRI/commit/f7a741d7501f2b3ea50387b5e7e769ef1df1245a", "message": "Fix styles import", "committedDate": "2020-09-15T21:33:43Z", "type": "commit"}, {"oid": "00b0c48a4504d79249f03d45ea3b7e4f060aaad2", "url": "https://github.com/JMRI/JMRI/commit/00b0c48a4504d79249f03d45ea3b7e4f060aaad2", "message": "Add class comments/copyright notice", "committedDate": "2020-09-15T21:33:43Z", "type": "commit"}, {"oid": "e70d8621b6dbd30bd7bddb24a1e051bba2d304a2", "url": "https://github.com/JMRI/JMRI/commit/e70d8621b6dbd30bd7bddb24a1e051bba2d304a2", "message": "Throw exception on calls which should not happen", "committedDate": "2020-09-15T21:33:43Z", "type": "commit"}, {"oid": "e6d9e88a2964ab77910d7e3eab88def5aaef4494", "url": "https://github.com/JMRI/JMRI/commit/e6d9e88a2964ab77910d7e3eab88def5aaef4494", "message": "Allow changing listening port", "committedDate": "2020-09-15T21:33:43Z", "type": "commit"}, {"oid": "dc5002fce1816d7fddc9407bd8fd48bdcd7a305a", "url": "https://github.com/JMRI/JMRI/commit/dc5002fce1816d7fddc9407bd8fd48bdcd7a305a", "message": "Throw exception if Message is too long", "committedDate": "2020-09-15T21:33:44Z", "type": "commit"}, {"oid": "bbd4440c2dcc50e5ab23b52d0b79c86932cd33d5", "url": "https://github.com/JMRI/JMRI/commit/bbd4440c2dcc50e5ab23b52d0b79c86932cd33d5", "message": "Add bundle", "committedDate": "2020-09-15T21:33:44Z", "type": "commit"}, {"oid": "bbd4440c2dcc50e5ab23b52d0b79c86932cd33d5", "url": "https://github.com/JMRI/JMRI/commit/bbd4440c2dcc50e5ab23b52d0b79c86932cd33d5", "message": "Add bundle", "committedDate": "2020-09-15T21:33:44Z", "type": "forcePushed"}]}