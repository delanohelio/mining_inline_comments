{"pr_number": 8958, "pr_title": "Add AnalogIOManager and StringIOManager", "pr_createdAt": "2020-08-22T09:39:13Z", "pr_url": "https://github.com/JMRI/JMRI/pull/8958", "timeline": [{"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd", "url": "https://github.com/JMRI/JMRI/commit/aefa68527aa6b1946b4861181fc6ab09b03b58bd", "message": "Add AnalogIOManager and StringIOManager", "committedDate": "2020-08-22T08:36:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NTg3NA==", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475095874", "bodyText": "(Not a request for change, I'm just curious) Why do you handle NEGATIVE_INFINITY and POSITIVE_INFINITY with a IllegalArgumentException, and outside min-max with a JmriException?  The JmriException appears in the signature and has to be caught in any case.", "author": "bobjacobsen", "createdAt": "2020-08-22T14:23:08Z", "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");", "originalCommit": "aefa68527aa6b1946b4861181fc6ab09b03b58bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5ODgzNg==", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475098836", "bodyText": "Good point. There is a difference between the two cases. NEGATIVE_INFINITY, POSITIVE_INFINITY and NaN is always illegal, and if it happens, it's a software error.\nBut a value outside min and max may or may not be valid depending on cutOutOfBoundsValues(). So for one device, a value too small or too big could be valid, and for another device it could be invalid. A good example for StringIO devices is that a filename for a MP3 player that gets truncated is invalid, but a string to be displayed on a small screen is valid. It's no problem if you don't see the entire string on the screen, but if the filename is truncated, the MP3 player will look for a different file.\nA possible example for AnalogIO could be that a position for a servo is invalid outside min and max, but the intensity of a light could be safe to truncate.", "author": "danielb987", "createdAt": "2020-08-22T14:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NTg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5OTEyNQ==", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475099125", "bodyText": "If you look at the JavaDoc for AnalogIO, it clearly tells that NEGATIVE_INFINITY, POSITIVE_INFINITY and NaN will throw an IllegalArgumentException.\nhttps://github.com/JMRI/JMRI/blob/master/java/src/jmri/AnalogIO.java#L50", "author": "danielb987", "createdAt": "2020-08-22T15:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NjA3NQ==", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475096075", "bodyText": "(Again, not a request for change). Particularly for scripting, have getState() and setState() work can be very helpful; Python programmers tend to expect it.  Would it make sense to add a getState(double ..)?  And have getState return the (nearest?) int value?", "author": "bobjacobsen", "createdAt": "2020-08-22T14:25:21Z", "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");\n+        }\n+        if (value == Double.POSITIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is positive infinity\");\n+        }\n+        if (Double.isNaN(value)) {\n+            throw new IllegalArgumentException(\"value is not-a-number\");\n+        }\n+        \n+        double min = getMin();\n+        double max = getMax();\n+        \n+        if (value < min) {\n+            if (cutOutOfBoundsValues()) value = min;\n+            else throw new JmriException(\"value out of bounds\");\n+        }\n+        if (value > max) {\n+            if (cutOutOfBoundsValues()) value = max;\n+            else throw new JmriException(\"value out of bounds\");\n+        }\n+        _commandedValue = value;\n+        sendValueToLayout(_commandedValue);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    @Nonnull\n+    public double getCommandedAnalogValue() {\n+        return _commandedValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getKnownAnalogValue() {\n+        return _knownValue;\n+    }\n+\n+    /**\n+     * Cut out of bounds values instead of throwing an exception?\n+     * For example, if the AnalogIO is a display, it could be desired to\n+     * accept too long strings.\n+     * On the other hand, if the AnalogIO is used to send a command, a too\n+     * long string is an error.\n+     *\n+     * @return true if long strings should be cut\n+     */\n+    abstract protected boolean cutOutOfBoundsValues();\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getState() {\n+        // A AnalogIO doesn't have a state\n+        return NamedBean.UNKNOWN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setState(int newState) {", "originalCommit": "aefa68527aa6b1946b4861181fc6ab09b03b58bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a9e5f867014e639fdafaf93ab2aed5f7c88d44f", "url": "https://github.com/JMRI/JMRI/commit/8a9e5f867014e639fdafaf93ab2aed5f7c88d44f", "message": "Add feedback mode. Add setState(double)", "committedDate": "2020-08-22T21:53:43Z", "type": "commit"}, {"oid": "7b3b4fe46a0cd20181364e59a581260db5659e4c", "url": "https://github.com/JMRI/JMRI/commit/7b3b4fe46a0cd20181364e59a581260db5659e4c", "message": "Fix error in test. Remove FeedbackMode", "committedDate": "2020-08-22T23:57:19Z", "type": "commit"}]}