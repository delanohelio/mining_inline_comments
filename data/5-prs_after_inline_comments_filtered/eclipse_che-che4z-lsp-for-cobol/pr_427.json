{"pr_number": 427, "pr_title": "Introduce Use Case Preprocessor", "pr_createdAt": "2020-07-14T16:05:11Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427", "timeline": [{"oid": "8df544c5ab23513b19a3d90d38b91f8a36367219", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8df544c5ab23513b19a3d90d38b91f8a36367219", "message": "test: Introduce use case preprocessor to simplify testing GH-426", "committedDate": "2020-07-14T15:07:38Z", "type": "commit"}, {"oid": "17b322362183e60affd3b72546e4f2e0f7082151", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/17b322362183e60affd3b72546e4f2e0f7082151", "message": "refactor: Extract source info text as an enum", "committedDate": "2020-07-14T15:14:21Z", "type": "commit"}, {"oid": "db34dd94b6285d5b75b3b0f01ca9173a7e634d1d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/db34dd94b6285d5b75b3b0f01ca9173a7e634d1d", "message": "test: Refactor tests with the Use Case Engine #426", "committedDate": "2020-07-14T15:47:36Z", "type": "commit"}, {"oid": "d0d5bb636036338355807fa0076170caf2ff48ee", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d0d5bb636036338355807fa0076170caf2ff48ee", "message": "refactor: Fix too long line error position counting", "committedDate": "2020-07-14T15:51:34Z", "type": "commit"}, {"oid": "227d35b53ded871be1bbeb192a22f4c1e702a3a2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/227d35b53ded871be1bbeb192a22f4c1e702a3a2", "message": "test: Add copyright headers to Use Case Engine files #426", "committedDate": "2020-07-14T16:01:37Z", "type": "commit"}, {"oid": "1cbc55aaf6839713e5ffb7e4efcf0c88616ef5ec", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1cbc55aaf6839713e5ffb7e4efcf0c88616ef5ec", "message": "Merge branch 'mapping' into usecase-preprocessor", "committedDate": "2020-07-15T08:31:25Z", "type": "commit"}, {"oid": "81eba78935cc9b99e572f8a61d1966638acc9de3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/81eba78935cc9b99e572f8a61d1966638acc9de3", "message": "test: Remove duplicated test", "committedDate": "2020-07-15T08:40:17Z", "type": "commit"}, {"oid": "81eba78935cc9b99e572f8a61d1966638acc9de3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/81eba78935cc9b99e572f8a61d1966638acc9de3", "message": "test: Remove duplicated test", "committedDate": "2020-07-15T08:40:17Z", "type": "forcePushed"}, {"oid": "b8680b0ad7ef69b31999966dcdc28b6d70a8bbcb", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b8680b0ad7ef69b31999966dcdc28b6d70a8bbcb", "message": "Merge branch 'mapping' into usecase-preprocessor", "committedDate": "2020-07-15T11:34:55Z", "type": "commit"}, {"oid": "fb1604fb1938ac36002afc1945b2c459850f5758", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fb1604fb1938ac36002afc1945b2c459850f5758", "message": "test: Remove outdated methods from UseCaseUtils #426", "committedDate": "2020-07-15T12:25:39Z", "type": "commit"}, {"oid": "fb1604fb1938ac36002afc1945b2c459850f5758", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fb1604fb1938ac36002afc1945b2c459850f5758", "message": "test: Remove outdated methods from UseCaseUtils #426", "committedDate": "2020-07-15T12:25:39Z", "type": "forcePushed"}, {"oid": "f29dbdb936e8897157028e156296352f596846ce", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f29dbdb936e8897157028e156296352f596846ce", "message": "test: Fix replacing copybook names on UseCaseEngine", "committedDate": "2020-07-15T14:59:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4OTE5OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455889198", "bodyText": "\"I\", I guess point is \"Hint\" is \"Info\" at the end, right?", "author": "asatklichov", "createdAt": "2020-07-16T15:49:26Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/SourceInfoLevels.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.validations;\n+\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * This class contains human-readable text describing the source of diagnostics, including severity\n+ * level.\n+ */\n+@AllArgsConstructor\n+public enum SourceInfoLevels {\n+  ERROR(\"E\"),\n+  WARNING(\"W\"),\n+  INFO(\"I\"),\n+  HINT(\"I\");", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5OTQ0Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455899442", "bodyText": "Oh, it's a typo, my bad.\nThe order is Error > Warning > Info > Hint", "author": "temanbrcom", "createdAt": "2020-07-16T16:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4OTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MTEyOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455891129", "bodyText": "In comment use @deprecated", "author": "asatklichov", "createdAt": "2020-07-16T15:52:07Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -79,9 +85,13 @@ public static void runTextValidation(TextDocumentService service, String text) {\n    * implementation uses the default time to await. Checker example: await( () -> { return\n    * !client.getReceivedDiagnostics().isEmpty(); });\n    *\n+   * <p>Deprecated - try using analyze, analyzeForErrors, or {@link", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MTI2NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455891264", "bodyText": "@deprecated", "author": "asatklichov", "createdAt": "2020-07-16T15:52:20Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -92,10 +102,14 @@ public static void await(Callable<Boolean> checker) {\n    * implementation uses the default time to await. Checker example: await( () -> { return\n    * !client.getReceivedDiagnostics().isEmpty(); });\n    *\n+   * <p>Deprecated - try using analyze, analyzeForErrors, or {@link", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MTQzOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455891439", "bodyText": "@deprecated", "author": "asatklichov", "createdAt": "2020-07-16T15:52:33Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -105,11 +119,15 @@ private static void await(Callable<Boolean> checker, String description) {\n    * occurred. WARNING: use only in the thread that has been used to run the server. Checker\n    * example: await( () -> { return !client.getReceivedDiagnostics().isEmpty(); });\n    *\n+   * <p>Deprecated - try using analyze, analyzeForErrors, or {@link", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eaf685edcd9bc6922c0e2fa2284a5ab6dae68ed0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/eaf685edcd9bc6922c0e2fa2284a5ab6dae68ed0", "message": "refactor: Fix source info identifier", "committedDate": "2020-07-16T16:00:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTk4Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455905982", "bodyText": "I think you could overload processToken like:\nprocessToken(WordContext wc, Map<String, List<Location>> theMap, VariableStatementContext ctx):\nAnd inside this function extract text, replacement and diagnostic.", "author": "grianbrcom", "createdAt": "2020-07-16T16:13:22Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/engine/TestPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases.engine;\n+\n+import com.ca.lsp.cobol.usecases.engine.parser.TestPreprocessorBaseListener;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.Token;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+\n+import javax.annotation.Nonnull;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import static com.ca.lsp.cobol.usecases.engine.parser.TestPreprocessorParser.*;\n+import static java.util.Collections.singletonList;\n+import static java.util.Optional.ofNullable;\n+import static java.util.stream.Collectors.joining;\n+import static org.antlr.v4.runtime.Lexer.HIDDEN;\n+\n+/**\n+ * This ANTLR listener removes all the technical tokens from the given text, extracts semantic\n+ * context and diagnostics applying correct positions. The grammar for this listener written inside\n+ * TestPreprocessor.g4\n+ */\n+public class TestPreprocessorListenerImpl extends TestPreprocessorBaseListener {\n+  private Map<String, List<Diagnostic>> diagnostics = new HashMap<>();\n+  private Map<String, List<Location>> variableDefinitions = new HashMap<>();\n+  private Map<String, List<Location>> variableUsages = new HashMap<>();\n+  private Map<String, List<Location>> paragraphDefinitions = new HashMap<>();\n+  private Map<String, List<Location>> paragraphUsages = new HashMap<>();\n+  private Map<String, List<Location>> copybookDefinitions = new HashMap<>();\n+  private Map<String, List<Location>> copybookUsages = new HashMap<>();\n+\n+  private Deque<StringBuilder> contexts = new ArrayDeque<>();\n+\n+  private int[] lineShifts;\n+  private CommonTokenStream tokens;\n+  private String documentUri;\n+  private String copybookName;\n+  private Map<String, Diagnostic> expectedDiagnostics;\n+\n+  TestPreprocessorListenerImpl(\n+      CommonTokenStream tokens,\n+      String documentName,\n+      String documentUri,\n+      int numberOfLines,\n+      Map<String, Diagnostic> expectedDiagnostics) {\n+    this.tokens = tokens;\n+    this.documentUri = documentUri;\n+    this.copybookName = documentName;\n+    lineShifts = new int[numberOfLines];\n+    this.expectedDiagnostics = expectedDiagnostics;\n+    contexts.push(new StringBuilder());\n+    diagnostics.put(documentUri, new ArrayList<>());\n+    ofNullable(documentName).ifPresent(defineCopybook(documentUri));\n+  }\n+\n+  /**\n+   * Get result of processing, including cleaned-up text, semantic context and diagnostics\n+   *\n+   * @return a {@link TestData} of the processing\n+   */\n+  @Nonnull\n+  TestData getProcessingResult() {\n+    return new TestData(\n+        peek().toString(),\n+        copybookName,\n+        diagnostics,\n+        variableDefinitions,\n+        variableUsages,\n+        paragraphDefinitions,\n+        paragraphUsages,\n+        copybookDefinitions,\n+        copybookUsages);\n+  }\n+\n+  @Override\n+  public void enterErrorStatement(ErrorStatementContext ctx) {\n+    push();\n+  }\n+\n+  @Override\n+  public void exitErrorStatement(ErrorStatementContext ctx) {\n+    pop();\n+    ReplacementContext replacementContext =\n+        ofNullable(ctx.word()).map(WordContext::replacement).orElse(null);\n+    String text =\n+        ofNullable(ctx.word())\n+            .map(WordContext::identifier)\n+            .map(RuleContext::getText)\n+            .orElse(ofNullable(ctx.STRINGLITERAL()).map(ParseTree::getText).orElse(\"\"));\n+\n+    processToken(text, ctx, replacementContext, null, ctx.diagnostic());\n+  }\n+\n+  @Override\n+  public void enterCopybookStatement(CopybookStatementContext ctx) {\n+    push();\n+  }\n+\n+  @Override\n+  public void exitCopybookStatement(CopybookStatementContext ctx) {\n+    pop();\n+    ofNullable(ctx.copybookUsage())\n+        .map(CopybookUsageContext::cpyIdentifier)\n+        .ifPresent(processCopybook(ctx, copybookUsages));\n+    ofNullable(ctx.copybookDefinition())\n+        .map(CopybookDefinitionContext::cpyIdentifier)\n+        .ifPresent(processCopybook(ctx, copybookDefinitions));\n+  }\n+\n+  private Consumer<CpyIdentifierContext> processCopybook(\n+      CopybookStatementContext ctx, Map<String, List<Location>> copybookUsages) {\n+    return it ->\n+        processToken(\n+            it.cpyName().getText(), ctx, it.replacement(), copybookUsages, ctx.diagnostic());\n+  }\n+\n+  @Override\n+  public void enterVariableStatement(VariableStatementContext ctx) {\n+    push();\n+  }\n+\n+  @Override\n+  public void exitVariableStatement(VariableStatementContext ctx) {\n+    pop();\n+    ofNullable(ctx.variableUsage())\n+        .map(VariableUsageContext::word)\n+        .ifPresent(\n+            it ->\n+                processToken(", "originalCommit": "e17a0fca11d010c0e6befeb186718b6a14241928", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyNzY1Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r456327652", "bodyText": "Not exactly - it should consume different types of statement contexts, e.g. ParagparphStatementContext or ErrorStatementContext. They have a quite similar structure, but the limitations of the Java object model won't allow using it this way", "author": "temanbrcom", "createdAt": "2020-07-17T09:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyOTY4Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r456329682", "bodyText": "Yes, I see.", "author": "grianbrcom", "createdAt": "2020-07-17T09:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MTczMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455891730", "bodyText": "same", "author": "asatklichov", "createdAt": "2020-07-16T15:52:58Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -121,33 +139,16 @@ private static void await(Callable<Boolean> checker, Long time, String descripti\n    * Await when the client will receive the diagnostics in case if there are some syntax or format\n    * errors.\n    *\n+   * <p>Deprecated - try using analyze, analyzeForErrors, or {@link", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMTQ1Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455901456", "bodyText": "in lsp4j  Diagnostic constructor defined with @nonnull, is that validation strict enough or ignored?  Same for all constructor where \"null\" used.", "author": "asatklichov", "createdAt": "2020-07-16T16:07:01Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestCopybookWithIndirectRecursiveDependencyIsDetected.java", "diffHunk": "@@ -15,54 +15,63 @@\n package com.ca.lsp.cobol.usecases;\n \n import com.ca.lsp.cobol.positive.CobolText;\n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.Range;\n import org.junit.Test;\n \n-import java.util.List;\n+import java.util.HashMap;\n+import java.util.Map;\n \n-import static org.junit.Assert.assertEquals;\n+import static com.ca.lsp.cobol.service.delegates.validations.SourceInfoLevels.ERROR;\n+import static com.ca.lsp.cobol.service.delegates.validations.SourceInfoLevels.INFO;\n+import static java.util.Arrays.asList;\n+import static org.eclipse.lsp4j.DiagnosticSeverity.Error;\n+import static org.eclipse.lsp4j.DiagnosticSeverity.Information;\n \n /**\n- * This test checks the error shown if the copybook that is used in the Cobol file contains a link\n+ * This test checks the error shown if the copybook that is used in the COBOL file contains a link\n  * to another one, that has a dependency to the first copybook.\n  */\n-public class TestCopybookWithIndirectRecursiveDependencyIsDetected extends NegativeUseCase {\n+public class TestCopybookWithIndirectRecursiveDependencyIsDetected {\n \n   private static final String TEXT =\n-      \"        IDENTIFICATION DIVISION.\\r\\n\"\n-          + \"        PROGRAM-ID. test1.\\r\\n\"\n-          + \"        DATA DIVISION.\\r\\n\"\n-          + \"        WORKING-STORAGE SECTION.\\r\\n\"\n-          + \"        COPY INDIRECT-COPY.\\n\\n\"\n-          + \"        PROCEDURE DIVISION.\\n\\n\";\n+      \"        IDENTIFICATION DIVISION.\\n\"\n+          + \"        PROGRAM-ID. test1.\\n\"\n+          + \"        DATA DIVISION.\\n\"\n+          + \"        WORKING-STORAGE SECTION.\\n\"\n+          + \"        COPY {~INDIRECT-COPY|1|3}.\\n\"\n+          + \"        PROCEDURE DIVISION.\\n\";\n \n-  private static final String INDIRECT_COPY = \"        COPY INNER-COPY.\";\n-  private static final String INNER_COPY = \"        COPY INDIRECT-COPY.\";\n+  private static final String INDIRECT = \"        COPY {~INNER-COPY|2|4}.\";\n+  private static final String INNER_COPY = \"        COPY {~INDIRECT-COPY|3}.\";\n \n-  public TestCopybookWithIndirectRecursiveDependencyIsDetected() {\n-    super(TEXT);\n-  }\n+  private static final String INDIRECT_NAME = \"INDIRECT-COPY\";\n+  private static final String INNER_COPY_NAME = \"INNER-COPY\";\n+\n+  private static final String MESSAGE_RECURSION = \"Recursive copybook declaration for: \";\n+  private static final String MESSAGE_LONG_DECLARATION =\n+      \"Copybook declaration has more than 8 characters for: \";\n \n-  @Override\n   @Test\n   public void test() {\n-    super.test(\n-        List.of(\n-            new CobolText(\"INNER-COPY\", INNER_COPY),\n-            new CobolText(\"INDIRECT-COPY\", INDIRECT_COPY)));\n-  }\n+    Map<String, Diagnostic> expectedDiagnostics = new HashMap<>();\n+    expectedDiagnostics.put(\n+        \"1\", new Diagnostic(null, MESSAGE_RECURSION + INDIRECT_NAME, Error, ERROR.getText()));", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MzA1OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r456293059", "bodyText": "If I understand correctly, this validation applies only while serialization to JSON.\nTechnically, this usage is not correct, but this check won't be applied in this scenario.", "author": "temanbrcom", "createdAt": "2020-07-17T08:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMzg3Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455903872", "bodyText": "If list usage immutable then better use List.of( .... )", "author": "asatklichov", "createdAt": "2020-07-16T16:10:26Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestEntireProgramInCopybook.java", "diffHunk": "@@ -16,109 +16,37 @@\n package com.ca.lsp.cobol.usecases;\n \n import com.ca.lsp.cobol.positive.CobolText;\n-import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.Location;\n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n import org.junit.Test;\n \n-import java.util.List;\n-import java.util.Map;\n-\n-import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n import static java.util.Arrays.asList;\n-import static org.junit.Assert.assertEquals;\n+import static java.util.Collections.emptyMap;\n \n /** This test checks that the grammar may process the entire program put into a copybook */\n public class TestEntireProgramInCopybook {\n-  private static final String TEXT = \"0       COPY PROGA.\";\n+  private static final String TEXT = \"0       COPY {~PROGA}.\";\n+\n   private static final String PROGA =\n       \"0       IDENTIFICATION DIVISION.\\n\"\n           + \"1      PROGRAM-ID. BKP92S1.        \\n\"\n           + \"2      DATA DIVISION.              \\n\"\n           + \"3      WORKING-STORAGE SECTION.    \\n\"\n-          + \"4      01  PARENT.  COPY STRUCT1.  \\n\"\n+          + \"4      01  {$*PARENT}.  COPY {~STRUCT1}.  \\n\"\n           + \"5      PROCEDURE DIVISION.\\n\"\n-          + \"6      MAINLINE.\\n\"\n-          + \"7        MOVE 1 TO CHILD1.\\n\"\n+          + \"6      {#*MAINLINE}.\\n\"\n+          + \"7        MOVE 1 TO {$CHILD1}.\\n\"\n           + \"8      GOBACK. \";\n \n-  private static final String STRUCT1 = \"           03  CHILD1         PIC 9   VALUE IS '0'.\\n\";\n+  private static final String STRUCT1 = \"           03  {$*CHILD1}         PIC 9   VALUE IS '0'.\\n\";\n \n   private static final String PROGA_NAME = \"PROGA\";\n-  private static final String PROGA_URI = toURI(PROGA_NAME);\n   private static final String STRUCT1_NAME = \"STRUCT1\";\n-  private static final String STRUCT1_URI = toURI(STRUCT1_NAME);\n-  private static final String CHILD1 = \"CHILD1\";\n-  private static final String PARENT = \"PARENT\";\n-  private static final String MAINLINE = \"MAINLINE\";\n \n   @Test\n-  public void assertAnalysisResult() {\n-    AnalysisResult result =\n-        analyze(\n-            TEXT, asList(new CobolText(PROGA_NAME, PROGA), new CobolText(STRUCT1_NAME, STRUCT1)));\n-\n-    assertDiagnostics(result.getDiagnostics());\n-\n-    assertCopybookUsages(result.getCopybookUsages());\n-    assertCopybookDefinitions(result.getCopybookDefinitions());\n-\n-    assertVariableUsages(result.getVariableUsages());\n-    assertVariableDefinitions(result.getVariableDefinitions());\n-\n-    assertParagraphDefinitions(result.getParagraphDefinitions());\n-    assertParagraphUsages(result.getParagraphUsages());\n-  }\n-\n-  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n-    String message = \"Diagnostics: \" + diagnostics.toString();\n-    assertEquals(message, 3, diagnostics.size());\n-    assertEquals(message, 0, diagnostics.get(DOCUMENT_URI).size());\n-    assertEquals(message, 0, diagnostics.get(PROGA_URI).size());\n-    assertEquals(message, 0, diagnostics.get(STRUCT1_URI).size());\n-  }\n-\n-  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n-  }\n-\n-  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n-    assertNumberOfLocations(definitions, MAINLINE, 1);\n-    assertLocation(definitions, MAINLINE, PROGA_URI, 6, 7);\n-  }\n-\n-  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n-    assertEquals(\n-        \"Copybook definitions: \" + copybookDefinitions.toString(), 2, copybookDefinitions.size());\n-    assertCopybookDefinition(copybookDefinitions, PROGA_NAME);\n-    assertCopybookDefinition(copybookDefinitions, STRUCT1_NAME);\n-  }\n-\n-  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n-    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 2, copybookUsages.size());\n-\n-    assertNumberOfLocations(copybookUsages, STRUCT1_NAME, 1);\n-    assertLocation(copybookUsages, STRUCT1_NAME, PROGA_URI, 4, 25);\n-\n-    assertNumberOfLocations(copybookUsages, PROGA_NAME, 1);\n-    assertLocation(copybookUsages, PROGA_NAME, DOCUMENT_URI, 0, 13);\n-  }\n-\n-  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Variable definitions: \" + definitions.toString(), 2, definitions.size());\n-\n-    assertNumberOfLocations(definitions, PARENT, 1);\n-    assertLocation(definitions, PARENT, PROGA_URI, 4, 11);\n-\n-    assertNumberOfLocations(definitions, CHILD1, 1);\n-    assertLocation(definitions, CHILD1, STRUCT1_URI, 0, 15);\n-  }\n-\n-  private void assertVariableUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Variable usages: \" + usages.toString(), 1, usages.size());\n-\n-    assertNumberOfLocations(usages, CHILD1, 1);\n-    assertLocation(usages, CHILD1, PROGA_URI, 7, 19);\n+  public void test() {\n+    UseCaseEngine.runTest(\n+        TEXT,\n+        asList(new CobolText(PROGA_NAME, PROGA), new CobolText(STRUCT1_NAME, STRUCT1)),", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNDE4MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455904180", "bodyText": "Map.of()   (for all occurrences)", "author": "asatklichov", "createdAt": "2020-07-16T16:10:54Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestEntireProgramInCopybook.java", "diffHunk": "@@ -16,109 +16,37 @@\n package com.ca.lsp.cobol.usecases;\n \n import com.ca.lsp.cobol.positive.CobolText;\n-import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.Location;\n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n import org.junit.Test;\n \n-import java.util.List;\n-import java.util.Map;\n-\n-import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n import static java.util.Arrays.asList;\n-import static org.junit.Assert.assertEquals;\n+import static java.util.Collections.emptyMap;\n \n /** This test checks that the grammar may process the entire program put into a copybook */\n public class TestEntireProgramInCopybook {\n-  private static final String TEXT = \"0       COPY PROGA.\";\n+  private static final String TEXT = \"0       COPY {~PROGA}.\";\n+\n   private static final String PROGA =\n       \"0       IDENTIFICATION DIVISION.\\n\"\n           + \"1      PROGRAM-ID. BKP92S1.        \\n\"\n           + \"2      DATA DIVISION.              \\n\"\n           + \"3      WORKING-STORAGE SECTION.    \\n\"\n-          + \"4      01  PARENT.  COPY STRUCT1.  \\n\"\n+          + \"4      01  {$*PARENT}.  COPY {~STRUCT1}.  \\n\"\n           + \"5      PROCEDURE DIVISION.\\n\"\n-          + \"6      MAINLINE.\\n\"\n-          + \"7        MOVE 1 TO CHILD1.\\n\"\n+          + \"6      {#*MAINLINE}.\\n\"\n+          + \"7        MOVE 1 TO {$CHILD1}.\\n\"\n           + \"8      GOBACK. \";\n \n-  private static final String STRUCT1 = \"           03  CHILD1         PIC 9   VALUE IS '0'.\\n\";\n+  private static final String STRUCT1 = \"           03  {$*CHILD1}         PIC 9   VALUE IS '0'.\\n\";\n \n   private static final String PROGA_NAME = \"PROGA\";\n-  private static final String PROGA_URI = toURI(PROGA_NAME);\n   private static final String STRUCT1_NAME = \"STRUCT1\";\n-  private static final String STRUCT1_URI = toURI(STRUCT1_NAME);\n-  private static final String CHILD1 = \"CHILD1\";\n-  private static final String PARENT = \"PARENT\";\n-  private static final String MAINLINE = \"MAINLINE\";\n \n   @Test\n-  public void assertAnalysisResult() {\n-    AnalysisResult result =\n-        analyze(\n-            TEXT, asList(new CobolText(PROGA_NAME, PROGA), new CobolText(STRUCT1_NAME, STRUCT1)));\n-\n-    assertDiagnostics(result.getDiagnostics());\n-\n-    assertCopybookUsages(result.getCopybookUsages());\n-    assertCopybookDefinitions(result.getCopybookDefinitions());\n-\n-    assertVariableUsages(result.getVariableUsages());\n-    assertVariableDefinitions(result.getVariableDefinitions());\n-\n-    assertParagraphDefinitions(result.getParagraphDefinitions());\n-    assertParagraphUsages(result.getParagraphUsages());\n-  }\n-\n-  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n-    String message = \"Diagnostics: \" + diagnostics.toString();\n-    assertEquals(message, 3, diagnostics.size());\n-    assertEquals(message, 0, diagnostics.get(DOCUMENT_URI).size());\n-    assertEquals(message, 0, diagnostics.get(PROGA_URI).size());\n-    assertEquals(message, 0, diagnostics.get(STRUCT1_URI).size());\n-  }\n-\n-  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n-  }\n-\n-  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n-    assertNumberOfLocations(definitions, MAINLINE, 1);\n-    assertLocation(definitions, MAINLINE, PROGA_URI, 6, 7);\n-  }\n-\n-  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n-    assertEquals(\n-        \"Copybook definitions: \" + copybookDefinitions.toString(), 2, copybookDefinitions.size());\n-    assertCopybookDefinition(copybookDefinitions, PROGA_NAME);\n-    assertCopybookDefinition(copybookDefinitions, STRUCT1_NAME);\n-  }\n-\n-  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n-    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 2, copybookUsages.size());\n-\n-    assertNumberOfLocations(copybookUsages, STRUCT1_NAME, 1);\n-    assertLocation(copybookUsages, STRUCT1_NAME, PROGA_URI, 4, 25);\n-\n-    assertNumberOfLocations(copybookUsages, PROGA_NAME, 1);\n-    assertLocation(copybookUsages, PROGA_NAME, DOCUMENT_URI, 0, 13);\n-  }\n-\n-  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Variable definitions: \" + definitions.toString(), 2, definitions.size());\n-\n-    assertNumberOfLocations(definitions, PARENT, 1);\n-    assertLocation(definitions, PARENT, PROGA_URI, 4, 11);\n-\n-    assertNumberOfLocations(definitions, CHILD1, 1);\n-    assertLocation(definitions, CHILD1, STRUCT1_URI, 0, 15);\n-  }\n-\n-  private void assertVariableUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Variable usages: \" + usages.toString(), 1, usages.size());\n-\n-    assertNumberOfLocations(usages, CHILD1, 1);\n-    assertLocation(usages, CHILD1, PROGA_URI, 7, 19);\n+  public void test() {\n+    UseCaseEngine.runTest(\n+        TEXT,\n+        asList(new CobolText(PROGA_NAME, PROGA), new CobolText(STRUCT1_NAME, STRUCT1)),\n+        emptyMap());", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTA0Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455905042", "bodyText": "List.of(), Map.of(),  immutable empty", "author": "asatklichov", "createdAt": "2020-07-16T16:12:03Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestCobolStringWithContinuationLineConcatenatedCorrectly.java", "diffHunk": "@@ -13,32 +13,42 @@\n  */\n package com.ca.lsp.cobol.usecases;\n \n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+\n /**\n- * This test checks that there are no errors thrown if a keyword split and concatenated by a\n+ * This test checks that there are no errors thrown if a string literal split and concatenated by a\n  * concatenation line.\n  */\n-public class TestCobolStringWithContinuationLineConcatenatedCorrectly extends PositiveUseCase {\n+public class TestCobolStringWithContinuationLineConcatenatedCorrectly {\n \n   private static final String TEXT =\n-      \"000100 IDENTIFICATION DIVISION.\\r\\n\"\n-          + \"000200 PROGRAM-ID.   TEST1.\\r\\n\"\n-          + \"000301 AUTHOR.       A PROGRAMMER.\\r\\n\"\n-          + \"000400 PROCEDURE DIVISION.\\r\\n\"\n-          + \"078070 000-000.\\r\\n\"\n-          + \"078076     EVALUATE TRUE\\r\\n\"\n-          + \"078081         WHEN PROGRAM1\\r\\n\"\n-          + \"078089                 MOVE 'PRESS \\\"CLEAR\\\" OR \\\"ENTER\\\" TO RETURN TO THE M\\r\\n\"\n-          + \"078089-                     'ENU WHEN FINISHED' TO ID1\\r\\n\"\n-          + \"078091                 PERFORM PROGRAM2.\";\n-\n-  public TestCobolStringWithContinuationLineConcatenatedCorrectly() {\n-    super(TEXT);\n-  }\n+      \"000100 IDENTIFICATION DIVISION.\\n\"\n+          + \"000200 PROGRAM-ID.   TEST1.\\n\"\n+          + \"000301 AUTHOR.       A PROGRAMMER.\\n\"\n+          + \"000000 DATA DIVISION.\\n\"\n+          + \"000000 WORKING-STORAGE SECTION.\\n\"\n+          + \"000000  01 {$*ID1}.\\n\"\n+          + \"000000  01 {$*ID2}.\\n\"\n+          + \"000400 PROCEDURE DIVISION.\\n\"\n+          + \"078070 {#*000-MAIN}.\\n\"\n+          + \"078076     EVALUATE TRUE\\n\"\n+          + \"078081         WHEN {$ID1}\\n\"\n+          + \"078089                 MOVE 'PRESS \\\"CLEAR\\\" OR \\\"ENTER\\\" TO RETURN TO THE M\\n\"\n+          + \"078089-                     'ENU WHEN FINISHED' TO {$ID2}\\n\"\n+          + \"078091                 PERFORM {#PROGRAM2}\\n\"\n+          + \"000000     END-EVALUATE.\\n\"\n+          + \"000000 {#*PROGRAM2}.\\n\"\n+          + \"000000  DISPLAY 'HELLO'.\";\n \n+  @Ignore(\"Continuation line cause a semantic error #414\")\n+  // TODO: #414\n   @Test\n   public void test() {\n-    super.test();\n+    UseCaseEngine.runTest(TEXT, emptyList(), emptyMap());", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNzY5Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r456227697", "bodyText": "https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--\nemptyList() returns immutable list too", "author": "ishche", "createdAt": "2020-07-17T05:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNjQ1NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r456306454", "bodyText": "Yes, but List.of() is much more safer, e.g. you can deserialize emptyList() on JDK 8 and previous, but not List.of.", "author": "asatklichov", "createdAt": "2020-07-17T08:44:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNTA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNjA2Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455906066", "bodyText": "List.of()    (for all occurrences)", "author": "asatklichov", "createdAt": "2020-07-16T16:13:29Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestExtraSymbolsNotCauseErrorOnNextLine.java", "diffHunk": "@@ -13,43 +13,33 @@\n  */\n package com.ca.lsp.cobol.usecases;\n \n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.DiagnosticSeverity;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n-import java.util.List;\n-\n-import static org.junit.Assert.assertEquals;\n+import static com.ca.lsp.cobol.service.delegates.validations.SourceInfoLevels.ERROR;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonMap;\n \n /** This use case checks if extra symbols on one line do not cause any errors on the next line. */\n-public class TestExtraSymbolsNotCauseErrorOnNextLine extends NegativeUseCase {\n+public class TestExtraSymbolsNotCauseErrorOnNextLine {\n \n   private static final String TEXT =\n-      \"000000 Identification DIVISION.                                         23323232extra\\r\\n\" // Extra symbols at the end of this line\n+      \"000000 Identification DIVISION.                                         23323232{extra|1}\\r\\n\" // Extra symbols at the end of this line\n           + \"002800 Program-ID.                                                      23323232\\r\\n\" // Should not show an error on this line\n           + \"002800  HELLOWORLD.                                                     23323232\\r\\n\"\n           + \"024200 PROCEDURE DIVISION .                                             CM1014.2\";\n \n-  public TestExtraSymbolsNotCauseErrorOnNextLine() {\n-    super(TEXT);\n-  }\n+  private static final String MESSAGE = \"The line doesn't match the fixed format\";\n \n   @Test\n   public void test() {\n-    super.test();\n-  }\n-\n-  @Override\n-  protected void assertDiagnostics(List<Diagnostic> diagnostics) {\n-    assertEquals(\"Number of diagnostics\", 1, diagnostics.size());\n-    Diagnostic diagnostic = diagnostics.get(0);\n-    assertEquals(\"The line doesn't match the fixed format\", diagnostic.getMessage());\n-\n-    // The position of dot at the end of line \"INITIALIZE ID4(ROW-SUB).\"\n-    Range range = diagnostic.getRange();\n-    assertEquals(\"Diagnostic start line\", 0, range.getStart().getLine());\n-    assertEquals(\"Diagnostic start character\", 80, range.getStart().getCharacter());\n-    assertEquals(\"Diagnostic end line\", 0, range.getEnd().getLine());\n-    assertEquals(\"Diagnostic end character\", 86, range.getEnd().getCharacter());\n+    UseCaseEngine.runTest(\n+        TEXT,\n+        emptyList(),", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNjQyNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455906424", "bodyText": "List.of()", "author": "asatklichov", "createdAt": "2020-07-16T16:13:59Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestExtraneousInputEOFExpecting.java", "diffHunk": "@@ -13,52 +13,41 @@\n  */\n package com.ca.lsp.cobol.usecases;\n \n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.DiagnosticSeverity;\n import org.junit.Test;\n \n-import java.util.List;\n-\n-import static org.junit.Assert.assertEquals;\n+import static com.ca.lsp.cobol.service.delegates.validations.SourceInfoLevels.ERROR;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonMap;\n \n /** This use case checks if the absence of dot at the end recognized as an error. */\n-public class TestExtraneousInputEOFExpecting extends NegativeUseCase {\n+public class TestExtraneousInputEOFExpecting {\n \n   private static final String TEXT =\n       \"        IDENTIFICATION DIVISION.\\r\\n\"\n           + \"        PROGRAM-ID. test1.\\r\\n\"\n           + \"        DATA DIVISION.\\r\\n\"\n           + \"        WORKING-STORAGE SECTION.\\r\\n\"\n           + \"        PROCEDURE DIVISION.\\r\\n\"\n-          + \"           if (1 > 0) NEXT SENTENCE\"; // No dot at the end of file\n+          + \"           if (1 > 0) NEXT SENTENCE{|1}\"; // No dot at the end of file\n \n-  public TestExtraneousInputEOFExpecting() {\n-    super(TEXT);\n-  }\n+  private static final String MESSAGE =\n+      \"Extraneous input '<EOF>' expected {ACCEPT, ADD, ALTER, CALL, CANCEL, CLOSE, \"\n+          + \"COMPUTE, CONTINUE, DELETE, DISABLE, DISPLAY, DIVIDE, ENABLE, ENTRY, EVALUATE, \"\n+          + \"EXHIBIT, EXIT, GENERATE, GOBACK, GO, IF, INITIALIZE, INITIATE, INSPECT, MERGE, \"\n+          + \"MOVE, MULTIPLY, OPEN, PERFORM, PURGE, READ, RECEIVE, RELEASE, RETURN, REWRITE, \"\n+          + \"SEARCH, SEND, SERVICE, SET, SORT, START, STOP, STRING, SUBTRACT, TERMINATE, TITLE, \"\n+          + \"UNSTRING, WRITE, XML, DOT_FS, COPYENTRY, '*>CPYEXIT', EXECCICSLINE, EXECSQLIMSLINE, \"\n+          + \"EXECSQLLINE}\";\n \n   @Test\n   public void test() {\n-    super.test();\n-  }\n-\n-  @Override\n-  protected void assertDiagnostics(List<Diagnostic> diagnostics) {\n-    assertEquals(\"Number of diagnostics\", 1, diagnostics.size());\n-    Diagnostic diagnostic = diagnostics.get(0);\n-    assertEquals(\n-        \"Extraneous input '<EOF>' expected {ACCEPT, ADD, ALTER, CALL, CANCEL, CLOSE, \"\n-            + \"COMPUTE, CONTINUE, DELETE, DISABLE, DISPLAY, DIVIDE, ENABLE, ENTRY, EVALUATE, \"\n-            + \"EXHIBIT, EXIT, GENERATE, GOBACK, GO, IF, INITIALIZE, INITIATE, INSPECT, MERGE, \"\n-            + \"MOVE, MULTIPLY, OPEN, PERFORM, PURGE, READ, RECEIVE, RELEASE, RETURN, REWRITE, \"\n-            + \"SEARCH, SEND, SERVICE, SET, SORT, START, STOP, STRING, SUBTRACT, TERMINATE, TITLE, \"\n-            + \"UNSTRING, WRITE, XML, DOT_FS, COPYENTRY, '*>CPYEXIT', EXECCICSLINE, EXECSQLIMSLINE, \"\n-            + \"EXECSQLLINE}\",\n-        diagnostic.getMessage());\n-\n-    Range range = diagnostic.getRange();\n-    assertEquals(\"Diagnostic start line\", 5, range.getStart().getLine());\n-    assertEquals(\"Diagnostic start character\", 35, range.getStart().getCharacter());\n-    assertEquals(\"Diagnostic end line\", 5, range.getEnd().getLine());\n-    assertEquals(\"Diagnostic end character\", 35, range.getEnd().getCharacter());\n+    UseCaseEngine.runTest(\n+        TEXT,\n+        emptyList(),", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNzE1Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455907153", "bodyText": "Map.of()", "author": "asatklichov", "createdAt": "2020-07-16T16:15:00Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestIdentificationDivisionInCopybook.java", "diffHunk": "@@ -16,112 +16,39 @@\n package com.ca.lsp.cobol.usecases;\n \n import com.ca.lsp.cobol.positive.CobolText;\n-import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.Location;\n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n import org.junit.Test;\n \n-import java.util.List;\n-import java.util.Map;\n-\n-import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n import static java.util.Arrays.asList;\n-import static org.junit.Assert.assertEquals;\n+import static java.util.Collections.emptyMap;\n \n /**\n  * This test checks the insertion of IDENTIFICATION DIVISION statement with a copybook doesn't\n  * produce any error\n  */\n public class TestIdentificationDivisionInCopybook {\n   private static final String TEXT =\n-      \"0      COPY IDDIV.\\n\"\n+      \"0      COPY {~IDDIV}.\\n\"\n           + \"1      PROGRAM-ID. BKP92S1.        \\n\"\n           + \"2      DATA DIVISION.              \\n\"\n           + \"3      WORKING-STORAGE SECTION.    \\n\"\n-          + \"4      01  PARENT.  COPY STRUCT1.  \\n\"\n+          + \"4      01  {$*PARENT}.  COPY {~STRUCT1}.  \\n\"\n           + \"5      PROCEDURE DIVISION.\\n\"\n-          + \"6      MAINLINE.\\n\"\n-          + \"7        MOVE 1 TO CHILD1.\\n\"\n+          + \"6      {#*MAINLINE}.\\n\"\n+          + \"7        MOVE 1 TO {$CHILD1}.\\n\"\n           + \"8      GOBACK. \";\n \n-  private static final String STRUCT1 = \"           03  CHILD1         PIC 9   VALUE IS '0'.\\n\";\n+  private static final String STRUCT1 = \"           03  {$*CHILD1}         PIC 9   VALUE IS '0'.\\n\";\n   private static final String IDDIV = \"       IDENTIFICATION DIVISION.\";\n \n   private static final String IDDIV_NAME = \"IDDIV\";\n-  private static final String IDDIV_URI = toURI(IDDIV_NAME);\n   private static final String STRUCT1_NAME = \"STRUCT1\";\n-  private static final String STRUCT1_URI = toURI(STRUCT1_NAME);\n-  private static final String CHILD1 = \"CHILD1\";\n-  private static final String PARENT = \"PARENT\";\n-  private static final String MAINLINE = \"MAINLINE\";\n \n   @Test\n-  public void assertAnalysisResult() {\n-    AnalysisResult result =\n-        analyze(\n-            TEXT, asList(new CobolText(IDDIV_NAME, IDDIV), new CobolText(STRUCT1_NAME, STRUCT1)));\n-\n-    assertDiagnostics(result.getDiagnostics());\n-\n-    assertCopybookUsages(result.getCopybookUsages());\n-    assertCopybookDefinitions(result.getCopybookDefinitions());\n-\n-    assertVariableUsages(result.getVariableUsages());\n-    assertVariableDefinitions(result.getVariableDefinitions());\n-\n-    assertParagraphDefinitions(result.getParagraphDefinitions());\n-    assertParagraphUsages(result.getParagraphUsages());\n-  }\n-\n-  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n-    String message = \"Diagnostics: \" + diagnostics.toString();\n-    assertEquals(message, 3, diagnostics.size());\n-    assertEquals(message, 0, diagnostics.get(DOCUMENT_URI).size());\n-    assertEquals(message, 0, diagnostics.get(IDDIV_URI).size());\n-    assertEquals(message, 0, diagnostics.get(STRUCT1_URI).size());\n-  }\n-\n-  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n-  }\n-\n-  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n-    assertNumberOfLocations(definitions, MAINLINE, 1);\n-    assertLocation(definitions, MAINLINE, DOCUMENT_URI, 6, 7);\n-  }\n-\n-  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n-    assertEquals(\n-        \"Copybook definitions: \" + copybookDefinitions.toString(), 2, copybookDefinitions.size());\n-    assertCopybookDefinition(copybookDefinitions, IDDIV_NAME);\n-    assertCopybookDefinition(copybookDefinitions, STRUCT1_NAME);\n-  }\n-\n-  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n-    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 2, copybookUsages.size());\n-\n-    assertNumberOfLocations(copybookUsages, STRUCT1_NAME, 1);\n-    assertLocation(copybookUsages, STRUCT1_NAME, DOCUMENT_URI, 4, 25);\n-\n-    assertNumberOfLocations(copybookUsages, IDDIV_NAME, 1);\n-    assertLocation(copybookUsages, IDDIV_NAME, DOCUMENT_URI, 0, 12);\n-  }\n-\n-  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Variable definitions: \" + definitions.toString(), 2, definitions.size());\n-\n-    assertNumberOfLocations(definitions, PARENT, 1);\n-    assertLocation(definitions, PARENT, DOCUMENT_URI, 4, 11);\n-\n-    assertNumberOfLocations(definitions, CHILD1, 1);\n-    assertLocation(definitions, CHILD1, STRUCT1_URI, 0, 15);\n-  }\n-\n-  private void assertVariableUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Variable usages: \" + usages.toString(), 1, usages.size());\n-\n-    assertNumberOfLocations(usages, CHILD1, 1);\n-    assertLocation(usages, CHILD1, DOCUMENT_URI, 7, 19);\n+  public void test() {\n+    UseCaseEngine.runTest(\n+        TEXT,\n+        asList(new CobolText(IDDIV_NAME, IDDIV), new CobolText(STRUCT1_NAME, STRUCT1)),\n+        emptyMap());", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNzQ3MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455907470", "bodyText": "List.of(... ) if immutable usage,   (for all occurrences)", "author": "asatklichov", "createdAt": "2020-07-16T16:15:24Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestIdentificationDivisionInCopybook.java", "diffHunk": "@@ -16,112 +16,39 @@\n package com.ca.lsp.cobol.usecases;\n \n import com.ca.lsp.cobol.positive.CobolText;\n-import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.Location;\n+import com.ca.lsp.cobol.usecases.engine.UseCaseEngine;\n import org.junit.Test;\n \n-import java.util.List;\n-import java.util.Map;\n-\n-import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n import static java.util.Arrays.asList;\n-import static org.junit.Assert.assertEquals;\n+import static java.util.Collections.emptyMap;\n \n /**\n  * This test checks the insertion of IDENTIFICATION DIVISION statement with a copybook doesn't\n  * produce any error\n  */\n public class TestIdentificationDivisionInCopybook {\n   private static final String TEXT =\n-      \"0      COPY IDDIV.\\n\"\n+      \"0      COPY {~IDDIV}.\\n\"\n           + \"1      PROGRAM-ID. BKP92S1.        \\n\"\n           + \"2      DATA DIVISION.              \\n\"\n           + \"3      WORKING-STORAGE SECTION.    \\n\"\n-          + \"4      01  PARENT.  COPY STRUCT1.  \\n\"\n+          + \"4      01  {$*PARENT}.  COPY {~STRUCT1}.  \\n\"\n           + \"5      PROCEDURE DIVISION.\\n\"\n-          + \"6      MAINLINE.\\n\"\n-          + \"7        MOVE 1 TO CHILD1.\\n\"\n+          + \"6      {#*MAINLINE}.\\n\"\n+          + \"7        MOVE 1 TO {$CHILD1}.\\n\"\n           + \"8      GOBACK. \";\n \n-  private static final String STRUCT1 = \"           03  CHILD1         PIC 9   VALUE IS '0'.\\n\";\n+  private static final String STRUCT1 = \"           03  {$*CHILD1}         PIC 9   VALUE IS '0'.\\n\";\n   private static final String IDDIV = \"       IDENTIFICATION DIVISION.\";\n \n   private static final String IDDIV_NAME = \"IDDIV\";\n-  private static final String IDDIV_URI = toURI(IDDIV_NAME);\n   private static final String STRUCT1_NAME = \"STRUCT1\";\n-  private static final String STRUCT1_URI = toURI(STRUCT1_NAME);\n-  private static final String CHILD1 = \"CHILD1\";\n-  private static final String PARENT = \"PARENT\";\n-  private static final String MAINLINE = \"MAINLINE\";\n \n   @Test\n-  public void assertAnalysisResult() {\n-    AnalysisResult result =\n-        analyze(\n-            TEXT, asList(new CobolText(IDDIV_NAME, IDDIV), new CobolText(STRUCT1_NAME, STRUCT1)));\n-\n-    assertDiagnostics(result.getDiagnostics());\n-\n-    assertCopybookUsages(result.getCopybookUsages());\n-    assertCopybookDefinitions(result.getCopybookDefinitions());\n-\n-    assertVariableUsages(result.getVariableUsages());\n-    assertVariableDefinitions(result.getVariableDefinitions());\n-\n-    assertParagraphDefinitions(result.getParagraphDefinitions());\n-    assertParagraphUsages(result.getParagraphUsages());\n-  }\n-\n-  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n-    String message = \"Diagnostics: \" + diagnostics.toString();\n-    assertEquals(message, 3, diagnostics.size());\n-    assertEquals(message, 0, diagnostics.get(DOCUMENT_URI).size());\n-    assertEquals(message, 0, diagnostics.get(IDDIV_URI).size());\n-    assertEquals(message, 0, diagnostics.get(STRUCT1_URI).size());\n-  }\n-\n-  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n-  }\n-\n-  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n-    assertNumberOfLocations(definitions, MAINLINE, 1);\n-    assertLocation(definitions, MAINLINE, DOCUMENT_URI, 6, 7);\n-  }\n-\n-  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n-    assertEquals(\n-        \"Copybook definitions: \" + copybookDefinitions.toString(), 2, copybookDefinitions.size());\n-    assertCopybookDefinition(copybookDefinitions, IDDIV_NAME);\n-    assertCopybookDefinition(copybookDefinitions, STRUCT1_NAME);\n-  }\n-\n-  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n-    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 2, copybookUsages.size());\n-\n-    assertNumberOfLocations(copybookUsages, STRUCT1_NAME, 1);\n-    assertLocation(copybookUsages, STRUCT1_NAME, DOCUMENT_URI, 4, 25);\n-\n-    assertNumberOfLocations(copybookUsages, IDDIV_NAME, 1);\n-    assertLocation(copybookUsages, IDDIV_NAME, DOCUMENT_URI, 0, 12);\n-  }\n-\n-  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n-    assertEquals(\"Variable definitions: \" + definitions.toString(), 2, definitions.size());\n-\n-    assertNumberOfLocations(definitions, PARENT, 1);\n-    assertLocation(definitions, PARENT, DOCUMENT_URI, 4, 11);\n-\n-    assertNumberOfLocations(definitions, CHILD1, 1);\n-    assertLocation(definitions, CHILD1, STRUCT1_URI, 0, 15);\n-  }\n-\n-  private void assertVariableUsages(Map<String, List<Location>> usages) {\n-    assertEquals(\"Variable usages: \" + usages.toString(), 1, usages.size());\n-\n-    assertNumberOfLocations(usages, CHILD1, 1);\n-    assertLocation(usages, CHILD1, DOCUMENT_URI, 7, 19);\n+  public void test() {\n+    UseCaseEngine.runTest(\n+        TEXT,\n+        asList(new CobolText(IDDIV_NAME, IDDIV), new CobolText(STRUCT1_NAME, STRUCT1)),", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwOTY1Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455909657", "bodyText": "same", "author": "asatklichov", "createdAt": "2020-07-16T16:18:37Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestMappingWithMultiDefinitions.java", "diffHunk": "@@ -95,151 +89,15 @@\n \n   @Test\n   public void test() {\n-    AnalysisResult result =\n-        analyze(\n-            DOCUMENT,\n-            asList(\n-                new CobolText(STRUC_NAME + \".CPY\", STRUC),\n-                new CobolText(WITHNEST_NAME + \".CPY\", WITHNEST),\n-                new CobolText(NESTED_NAME + \".CPY\", NESTED),\n-                new CobolText(NESTED1_NAME + \".CPY\", NESTED1),\n-                new CobolText(NESTED2_NAME + \".CPY\", NESTED2),\n-                new CobolText(PARS_NAME + \".CPY\", PARS)));\n-\n-    assertDiagnostics(result.getDiagnostics());\n-\n-    assertCopybookUsages(result.getCopybookUsages());\n-    assertCopybookDefinitions(result.getCopybookDefinitions());\n-\n-    assertVariableDefinitions(result.getVariableDefinitions());\n-    assertVariableUsages(result.getVariableUsages());\n-\n-    assertParagraphDefinitions(result.getParagraphDefinitions());\n-    assertParagraphUsages(result.getParagraphUsages());\n-  }\n-\n-  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n-    String message = \"Diagnostics: \" + diagnostics.toString();\n-    assertEquals(message, 7, diagnostics.size());\n-    assertEquals(message, 0, diagnostics.get(DOCUMENT_URI).size());\n-    assertEquals(message, 0, diagnostics.get(toURI(STRUC_NAME)).size());\n-    assertEquals(message, 0, diagnostics.get(toURI(WITHNEST_NAME)).size());\n-    assertEquals(message, 0, diagnostics.get(toURI(PARS_NAME)).size());\n-    assertEquals(message, 0, diagnostics.get(toURI(NESTED_NAME)).size());\n-    assertEquals(message, 0, diagnostics.get(toURI(NESTED1_NAME)).size());\n-    assertEquals(message, 0, diagnostics.get(toURI(NESTED2_NAME)).size());\n-  }\n-\n-  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n-    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 6, copybookUsages.size());\n-\n-    assertNumberOfLocations(copybookUsages, STRUC_NAME, 2);\n-    assertLocation(copybookUsages, STRUC_NAME, DOCUMENT_URI, 4, 23);\n-    assertLocation(copybookUsages, STRUC_NAME, DOCUMENT_URI, 5, 24);\n-\n-    assertNumberOfLocations(copybookUsages, WITHNEST_NAME, 1);\n-    assertLocation(copybookUsages, WITHNEST_NAME, DOCUMENT_URI, 6, 12);\n-    assertNumberOfLocations(copybookUsages, PARS_NAME, 1);\n-    assertLocation(copybookUsages, PARS_NAME, DOCUMENT_URI, 9, 12);\n-    assertNumberOfLocations(copybookUsages, NESTED_NAME, 1);\n-    assertLocation(copybookUsages, NESTED_NAME, toURI(WITHNEST_NAME), 2, 16);\n-    assertNumberOfLocations(copybookUsages, NESTED1_NAME, 1);\n-    assertLocation(copybookUsages, NESTED1_NAME, toURI(WITHNEST_NAME), 4, 16);\n-    assertNumberOfLocations(copybookUsages, NESTED2_NAME, 1);\n-    assertLocation(copybookUsages, NESTED2_NAME, toURI(NESTED1_NAME), 3, 16);\n-  }\n-\n-  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n-    assertEquals(\n-        \"Copybook definitions: \" + copybookDefinitions.toString(), 6, copybookDefinitions.size());\n-    assertCopybookDefinition(copybookDefinitions, STRUC_NAME);\n-    assertCopybookDefinition(copybookDefinitions, WITHNEST_NAME);\n-    assertCopybookDefinition(copybookDefinitions, PARS_NAME);\n-    assertCopybookDefinition(copybookDefinitions, NESTED_NAME);\n-    assertCopybookDefinition(copybookDefinitions, NESTED1_NAME);\n-    assertCopybookDefinition(copybookDefinitions, NESTED2_NAME);\n-  }\n-\n-  private void assertParagraphUsages(Map<String, List<Location>> paragraphUsages) {\n-    assertEquals(\"Paragraph usages: \" + paragraphUsages.toString(), 2, paragraphUsages.size());\n-\n-    assertNumberOfLocations(paragraphUsages, \"PAR1\", 1);\n-    assertLocation(paragraphUsages, \"PAR1\", DOCUMENT_URI, 13, 19);\n-    assertNumberOfLocations(paragraphUsages, \"MAIN-LINE\", 1);\n-    assertLocation(paragraphUsages, \"MAIN-LINE\", DOCUMENT_URI, 8, 15);\n-  }\n-\n-  private void assertParagraphDefinitions(Map<String, List<Location>> paragraphDefinitions) {\n-    assertEquals(\n-        \"Paragraph definitions: \" + paragraphDefinitions.toString(),\n-        2,\n-        paragraphDefinitions.size());\n-    assertLocation(paragraphDefinitions, \"PAR1\", toURI(PARS_NAME), 0, 7);\n-    assertLocation(paragraphDefinitions, \"MAIN-LINE\", DOCUMENT_URI, 10, 7);\n-  }\n-\n-  private void assertVariableUsages(Map<String, List<Location>> variableUsages) {\n-    assertEquals(\"Variable usages: \" + variableUsages.toString(), 6, variableUsages.size());\n-\n-    assertNumberOfLocations(variableUsages, \"CHILD2\", 3);\n-    assertLocation(variableUsages, \"CHILD2\", toURI(PARS_NAME), 3, 26);\n-    assertLocation(variableUsages, \"CHILD2\", toURI(PARS_NAME), 5, 26);\n-    assertLocation(variableUsages, \"CHILD2\", DOCUMENT_URI, 11, 22);\n-\n-    assertNumberOfLocations(variableUsages, \"PARENT\", 1);\n-    assertLocation(variableUsages, \"PARENT\", DOCUMENT_URI, 11, 32);\n-\n-    assertNumberOfLocations(variableUsages, \"CHILD1\", 1);\n-    assertLocation(variableUsages, \"CHILD1\", toURI(PARS_NAME), 1, 14);\n-\n-    assertNumberOfLocations(variableUsages, \"CHILD3-NESTED\", 1);\n-    assertLocation(variableUsages, \"CHILD3-NESTED\", DOCUMENT_URI, 12, 22);\n-\n-    assertNumberOfLocations(variableUsages, \"PARENT-NESTED\", 1);\n-    assertLocation(variableUsages, \"PARENT-NESTED\", DOCUMENT_URI, 12, 39);\n-\n-    assertNumberOfLocations(variableUsages, \"PARENT3\", 1);\n-    assertLocation(variableUsages, \"PARENT3\", DOCUMENT_URI, 12, 56);\n-  }\n-\n-  private void assertVariableDefinitions(Map<String, List<Location>> variableDefinitions) {\n-    assertEquals(\n-        \"Variable definitions: \" + variableDefinitions.toString(), 15, variableDefinitions.size());\n-\n-    assertNumberOfLocations(variableDefinitions, \"PARENT\", 1);\n-    assertLocation(variableDefinitions, \"PARENT\", DOCUMENT_URI, 4, 10);\n-    assertNumberOfLocations(variableDefinitions, \"PARENT2\", 1);\n-    assertLocation(variableDefinitions, \"PARENT2\", DOCUMENT_URI, 5, 10);\n-\n-    assertNumberOfLocations(variableDefinitions, \"CHILD1\", 1);\n-    assertLocation(variableDefinitions, \"CHILD1\", toURI(STRUC_NAME), 0, 15);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD2\", 1);\n-    assertLocation(variableDefinitions, \"CHILD2\", toURI(STRUC_NAME), 1, 15);\n-\n-    assertNumberOfLocations(variableDefinitions, \"PARENT3\", 1);\n-    assertLocation(variableDefinitions, \"PARENT3\", toURI(WITHNEST_NAME), 0, 10);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD3\", 1);\n-    assertLocation(variableDefinitions, \"CHILD3\", toURI(WITHNEST_NAME), 1, 15);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD4\", 1);\n-    assertLocation(variableDefinitions, \"CHILD4\", toURI(WITHNEST_NAME), 3, 15);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD5\", 1);\n-    assertLocation(variableDefinitions, \"CHILD5\", toURI(WITHNEST_NAME), 5, 15);\n-\n-    assertNumberOfLocations(variableDefinitions, \"CHILD6\", 1);\n-    assertLocation(variableDefinitions, \"CHILD6\", toURI(NESTED_NAME), 0, 15);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD7\", 1);\n-    assertLocation(variableDefinitions, \"CHILD7\", toURI(NESTED_NAME), 1, 15);\n-\n-    assertNumberOfLocations(variableDefinitions, \"PARENT-NESTED\", 1);\n-    assertLocation(variableDefinitions, \"PARENT-NESTED\", toURI(NESTED1_NAME), 0, 10);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD1-NESTED\", 1);\n-    assertLocation(variableDefinitions, \"CHILD1-NESTED\", toURI(NESTED1_NAME), 1, 15);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD2-NESTED\", 1);\n-    assertLocation(variableDefinitions, \"CHILD2-NESTED\", toURI(NESTED1_NAME), 2, 15);\n-\n-    assertNumberOfLocations(variableDefinitions, \"CHILD3-NESTED\", 1);\n-    assertLocation(variableDefinitions, \"CHILD3-NESTED\", toURI(NESTED2_NAME), 0, 15);\n-    assertNumberOfLocations(variableDefinitions, \"CHILD4-NESTED\", 1);\n-    assertLocation(variableDefinitions, \"CHILD4-NESTED\", toURI(NESTED2_NAME), 1, 15);\n+    UseCaseEngine.runTest(\n+        DOCUMENT,\n+        asList(", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxNzMxMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/427#discussion_r455917311", "bodyText": "\ud83d\udc4d", "author": "asatklichov", "createdAt": "2020-07-16T16:30:51Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/engine/UseCaseEngine.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases.engine;\n+\n+import com.ca.lsp.cobol.positive.CobolText;\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.cobol.usecases.engine.parser.TestPreprocessorLexer;\n+import com.ca.lsp.cobol.usecases.engine.parser.TestPreprocessorParser;\n+import com.ca.lsp.cobol.usecases.engine.parser.TestPreprocessorParser.StartRuleContext;\n+import lombok.experimental.UtilityClass;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTreeWalker;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+\n+import java.util.*;\n+import java.util.function.Function;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static java.util.Comparator.comparing;\n+import static java.util.stream.Collectors.toList;\n+import static org.antlr.v4.runtime.CharStreams.fromString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * This class applies syntax and semantic analysis for COBOL texts using the actual Language Engine.\n+ * For test purpose, it is required to mark all the syntax and semantic elements (i.e. errors,\n+ * variables, paragraphs, and copybooks) in the text. The affected token should be wrapped with\n+ * curly braces {} with special tags. Diagnostic ID is optional for the elements. Without special\n+ * tags token inside curly braces considered as a diagnostic of syntax error.\n+ *\n+ * <p>Tags:\n+ * <li>$ - Variable\n+ * <li># - Paragraph\n+ * <li>~ - Copybook\n+ * <li>* - Definition\n+ * <li>| - Diagnostic\n+ * <li>^ - Replacement\n+ * <li>{_ _} - Multi-token error\n+ *\n+ *     <p>By default, tags treated as an element usage. With '*' specified the occurrence will be\n+ *     treated as a definition. For example, {$*VAR1} is a definition for VAR1, and {#PAR2} is a\n+ *     usage of PAR2. Copybook definitions are optional, by default they point to the beginning of\n+ *     the copybook.\n+ *\n+ *     <p>Diagnostic is optional for semantic elements. To specify a semantic error, add '|', and\n+ *     the ID of the expected diagnostic at this position: {$CHILD|InvalidDefinition}. In this case,\n+ *     there should be an according to key-value pair inside expected diagnostics.\n+ *\n+ *     <p>Syntax error may defined as follows: {DIVISIONs|1}. So, map of expected tokens should\n+ *     contain '1' as a key, and a diagnostic with message \"Syntax error on 'DIVISIONs' expected\n+ *     DIVISION\". The position of the diagnostic should be null. This pattern you may use only for\n+ *     one-token syntax or semantic errors.\n+ *\n+ *     <p>To show that the token will be replaced during the pre-processing on the actual language\n+ *     engine, you may mark it with '^' character with the result specified after. For example,\n+ *     {$*:TAG:-ID^CSTOUT-ID} will return ':TAG:-ID' as the text, and CSTOUT-ID as a variable\n+ *     definition. The position will be calculated as for the replacement.\n+ *\n+ *     <p>Some semantic errors may consist of several tokens. In order to show this, you may use\n+ *     multi-token error declaration: {_{$CHILD} OF {$PARENT}|id_}. The included semantic elements\n+ *     will be also processed as usual.\n+ *\n+ *     <p>All the tags will be removed during the processing, so \"MOVE 00 TO {_{$CHILD} OF\n+ *     {$PARENT}|id_}.\" will be treated as \"MOVE 00 TO CHILD OF PARENT.\" with positions according to\n+ *     the resulting text.\n+ *\n+ *     <p>After the analysis finished, the AnalysisResult of the actual Language engine will be\n+ *     compared with expected one. Notice, that while checking lists, the order of elements doesn't\n+ *     matter.\n+ */\n+@UtilityClass\n+public class UseCaseEngine {\n+\n+  /**\n+   * Check if the language engine applies required syntax and semantic checks. All the semantic\n+   * elements in the given text, as well as syntax errors, should be wrapped with according tags.\n+   * The same extraction operation applied also for the given copybooks.\n+   *\n+   * <p>Expected diagnostics should contain the full of list of syntax and semantic\n+   * errors/warnings/info messages for the document and copybooks. Existing positions, if they are,\n+   * for the diagnostics will be dropped and replaced with ones extracted by engine by their IDs.\n+   *\n+   * @param text - COBOL text to analyse. It will be cleaned up before analysis to exclude all the\n+   *     technical tokens and collect syntax and semantic elements.\n+   * @param copybooks - list of the copybooks used in the document\n+   * @param expectedDiagnostics - map of IDs and diagnostics that are expected to appear in the\n+   *     document or copybooks. IDs are the same as in the diagnostic sections inside the text.\n+   */\n+  public void runTest(\n+      String text, List<CobolText> copybooks, Map<String, Diagnostic> expectedDiagnostics) {\n+\n+    PreprocessedDocument document = prepareDocument(text, copybooks, expectedDiagnostics);\n+    AnalysisResult actual = analyze(document.getText(), document.getCopybooks());\n+    TestData expected = document.getTestData();\n+\n+    assertResultEquals(actual, expected);\n+  }\n+\n+  private PreprocessedDocument prepareDocument(\n+      String text, List<CobolText> copybooks, Map<String, Diagnostic> expectedDiagnostics) {\n+\n+    TestData testData = processDocument(text, expectedDiagnostics);\n+\n+    return new PreprocessedDocument(\n+        testData.getText(), processCopybooks(copybooks, expectedDiagnostics, testData), testData);\n+  }\n+\n+  private List<CobolText> processCopybooks(\n+      List<CobolText> copybooks, Map<String, Diagnostic> expectedDiagnostics, TestData testData) {\n+    return copybooks.stream()\n+        .map(\n+            it ->\n+                processDocument(\n+                    it.getFullText(),\n+                    it.getFileName(),\n+                    toURI(it.getFileName()),\n+                    expectedDiagnostics))\n+        .map(collectDataFromCopybooks(testData))\n+        .map(it -> new CobolText(it.getCopybookName(), it.getText()))\n+        .collect(toList());\n+  }\n+\n+  private TestData processDocument(String text, Map<String, Diagnostic> expectedDiagnostics) {\n+    return processDocument(text, null, DOCUMENT_URI, expectedDiagnostics);\n+  }\n+\n+  private TestData processDocument(\n+      String text, String documentName, String uri, Map<String, Diagnostic> expectedDiagnostics) {\n+    int numberOfLines = text.split(\"\\r\\n|\\r|\\n\").length;\n+\n+    TestPreprocessorLexer lexer = new TestPreprocessorLexer(fromString(text));\n+    lexer.removeErrorListeners();\n+\n+    CommonTokenStream tokens = new CommonTokenStream(lexer);\n+    TestPreprocessorParser parser = new TestPreprocessorParser(tokens);\n+    parser.removeErrorListeners();\n+\n+    StartRuleContext startRule = parser.startRule();\n+\n+    ParseTreeWalker walker = new ParseTreeWalker();\n+\n+    TestPreprocessorListenerImpl listener =\n+        new TestPreprocessorListenerImpl(\n+            tokens, documentName, uri, numberOfLines, expectedDiagnostics);\n+    walker.walk(listener, startRule);\n+    return listener.getProcessingResult();\n+  }\n+\n+  private static void assertResultEquals(AnalysisResult actual, TestData expected) {\n+    assertDiagnostics(expected.getDiagnostics(), actual.getDiagnostics());\n+\n+    assertResult(\n+        \"Copybook definitions:\",\n+        expected.getCopybookDefinitions(),\n+        actual.getCopybookDefinitions());\n+    assertResult(\"Copybook usages:\", expected.getCopybookUsages(), actual.getCopybookUsages());\n+\n+    assertResult(\n+        \"Variable definition:\", expected.getVariableDefinitions(), actual.getVariableDefinitions());\n+    assertResult(\"Variable usages:\", expected.getVariableUsages(), actual.getVariableUsages());\n+\n+    assertResult(\n+        \"Paragraph definition:\",\n+        expected.getParagraphDefinitions(),\n+        actual.getParagraphDefinitions());\n+    assertResult(\"Paragraph usage:\", expected.getParagraphUsages(), actual.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(\n+      Map<String, List<Diagnostic>> expected, Map<String, List<Diagnostic>> actual) {\n+    String message = \"Diagnostics: \" + actual.toString();\n+    assertEquals(message, expected.size(), actual.size());\n+    assertEquals(\n+        message,\n+        expected.values().stream().flatMap(Collection::stream).filter(Objects::nonNull).count(),\n+        actual.values().stream().mapToLong(Collection::size).sum());\n+    expected.forEach(\n+        (key, value) ->\n+            actual\n+                .get(key)\n+                .forEach(\n+                    actualDiag ->\n+                        assertTrue(\n+                            \"Diagnostic not found: \" + actualDiag.toString(),\n+                            value.contains(actualDiag))));\n+  }\n+\n+  private void assertResult(\n+      String message, Map<String, List<Location>> expected, Map<String, List<Location>> actual) {\n+    assertEquals(message, expected.keySet(), actual.keySet());\n+    expected.forEach(\n+        (key, value) ->\n+            assertEquals(\n+                message,\n+                value.stream().sorted(getLocationComparator()).collect(toList()),\n+                actual.get(key).stream().sorted(getLocationComparator()).collect(toList())));\n+  }\n+\n+  private Comparator<Location> getLocationComparator() {\n+    return comparing(Location::getUri)\n+        .thenComparingInt(location -> location.getRange().getStart().getLine())", "originalCommit": "f29dbdb936e8897157028e156296352f596846ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "16924d49150529a7ab5b0e0e0a8c73a8a7ac99fe", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/16924d49150529a7ab5b0e0e0a8c73a8a7ac99fe", "message": "test: Fix annotations in javadoc for tests", "committedDate": "2020-07-17T08:26:10Z", "type": "commit"}, {"oid": "532d08130fdd739583b1d70aedae7544c3b3b280", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/532d08130fdd739583b1d70aedae7544c3b3b280", "message": "refactor: Refaactor use cases with Java 11 collections", "committedDate": "2020-07-17T10:11:58Z", "type": "forcePushed"}, {"oid": "a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "message": "refactor: Refactor use cases with Java 11 collections", "committedDate": "2020-07-17T10:12:58Z", "type": "commit"}, {"oid": "a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "message": "refactor: Refactor use cases with Java 11 collections", "committedDate": "2020-07-17T10:12:58Z", "type": "forcePushed"}]}