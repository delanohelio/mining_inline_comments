{"pr_number": 376, "pr_title": "Support Copybooks in the Local Workspace", "pr_createdAt": "2020-06-02T10:01:35Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NDgxNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434494814", "bodyText": "I suggest start using, in next time,  \"org.hamcrest.core\" assertThat  instead of Assert methods. We can look at it once we discuss in deep about TDD/BDD.\ne.g.\nassertThat(1, is(params.getRegistrations().size()));\nassertThat(registration.getId(), notNullValue());", "author": "asatklichov", "createdAt": "2020-06-03T11:23:14Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WatcherServiceImplTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.providers.ClientProvider;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * This class is a unit test for the {@link WatcherServiceImpl} and asserts that it creates correct\n+ * JSON object structures on each watching request.\n+ */\n+public class WatcherServiceImplTest {\n+\n+  @Test\n+  public void watchConfigurationChange() {\n+    LanguageClient client = mock(LanguageClient.class);\n+    ClientProvider provider = new ClientProvider();\n+    provider.set(client);\n+    ArgumentCaptor<RegistrationParams> captor = forClass(RegistrationParams.class);\n+    WatcherService watcherService = new WatcherServiceImpl(provider);\n+\n+    watcherService.watchConfigurationChange();\n+\n+    verify(client).registerCapability(captor.capture());\n+\n+    RegistrationParams params = captor.getValue();", "originalCommit": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTIyMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434531221", "bodyText": "It depends on if we have TPSR and IP checks for that", "author": "temanbrcom", "createdAt": "2020-06-03T12:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NDgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMzg2MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434533860", "bodyText": "It depends on if we have TPSR and IP checks for that\n\nWe have it already, I even tested, it works fine.", "author": "asatklichov", "createdAt": "2020-06-03T12:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxMzgxMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434513813", "bodyText": "\"copybooks\" may be defined as an element of SettingsParametersEnum", "author": "temanbrcom", "createdAt": "2020-06-03T12:00:48Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,122 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final SettingsService settingsService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+          DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.settingsService = settingsService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n-  /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n-   *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n   @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n+  public void invalidateURICache() {\n+    copybookPath.clear();\n   }\n \n   /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n+   *\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      settingsService\n+          .getConfiguration(\"copybook\", cobolFileName, requiredCopybookName)", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNTkwNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434515904", "bodyText": "Missing Override annotation", "author": "temanbrcom", "createdAt": "2020-06-03T12:04:59Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjQwOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434516408", "bodyText": "Not descriptive var name", "author": "temanbrcom", "createdAt": "2020-06-03T12:05:55Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {\n+    register(\n+        paths.stream()\n+            .map(\n+                it -> {\n+                  folderWatchers.add(it);\n+                  return new Registration(\n+                      it,\n+                      WATCH_FILES,\n+                      new DidChangeWatchedFilesRegistrationOptions(\n+                          singletonList(\n+                              new FileSystemWatcher(\"**/\" + it + \"/**/*\", WATCH_ALL_KIND))));\n+                })\n+            .collect(toList()));\n+  }\n+\n+  @Override\n+  public void removeWatchers(@Nonnull List<String> paths) {\n+    List<String> collect = paths.stream().filter(folderWatchers::remove).collect(toList());", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjk2MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434516961", "bodyText": "\"**/\" + it + \"/**/*\" is on a lower abstracion layer and should be exctracted", "author": "temanbrcom", "createdAt": "2020-06-03T12:07:00Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {\n+    register(\n+        paths.stream()\n+            .map(\n+                it -> {\n+                  folderWatchers.add(it);\n+                  return new Registration(\n+                      it,\n+                      WATCH_FILES,\n+                      new DidChangeWatchedFilesRegistrationOptions(\n+                          singletonList(\n+                              new FileSystemWatcher(\"**/\" + it + \"/**/*\", WATCH_ALL_KIND))));", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODU4NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434518584", "bodyText": "Outdated javadoc. Probably, the whole method may be removed", "author": "temanbrcom", "createdAt": "2020-06-03T12:09:56Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.utils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+\n+/** This interface represents API for low-level file systems access */\n+public interface FileSystemService {\n+  /**\n+   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n+   * the FileSystemService, example: [input:\n+   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n+   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n+   *\n+   * @param uri URI string representation of a file\n+   * @return the {@link Path} representation of the given URI in input\n+   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n+   */\n+  @Nullable\n+  Path getPathFromURI(@Nonnull String uri);\n+\n+  /**\n+   * This method extracts the name of a file from a valid {@link URI} and return the name back to\n+   * the client as String or null in case of error.\n+   *\n+   * @param uri the reference of the file from where extract the name\n+   * @return the String representation of the file name or null if any {@link URISyntaxException} is\n+   *     caught.\n+   */\n+  @Nullable\n+  String getNameFromURI(@Nonnull String uri);\n+\n+  /**\n+   * Retrieve the content of the file as a string.\n+   *\n+   * @param file URI from where extract the content\n+   * @return content of the file as String representation\n+   */\n+  @Nullable\n+  String getContentByPath(@Nonnull Path file);\n+\n+  /**\n+   * Check if the file with the given path exists\n+   *\n+   * @param file NIO path of the file to check\n+   * @return true if the path represent a valid file, false otherwise\n+   */\n+  boolean fileExists(@Nullable Path file);\n+\n+  /**\n+   * Replace special chars (as parenthesis, spaces and so on) that are encoded by the LSP protocol\n+   * on the client side. Needs to be encoded in order to display to the user the uri correctly.\n+   *\n+   * @param uri provided by the {@link org.eclipse.lsp4j.services.TextDocumentService}\n+   * @return a new String decoded with UTF8\n+   */\n+  @Nonnull\n+  String decodeURI(@Nonnull String uri);\n+\n+  /**\n+   * Retrieve the content of a dependency file and return it back to the callee.", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMDk3MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434520971", "bodyText": "Incorrect method javadoc pattern - should start with a verb in the active voice", "author": "temanbrcom", "createdAt": "2020-06-03T12:14:27Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyOTY1NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434529655", "bodyText": "The method called asynchronously. Inside we add and remove watchers. It could cause us an issue if this method will be called in two threads. Is it make sense to use a synchronized method here?", "author": "grianbrcom", "createdAt": "2020-06-03T12:30:03Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CobolWorkspaceServiceImpl.java", "diffHunk": "@@ -67,66 +76,72 @@ public CobolWorkspaceServiceImpl(DataBusBroker dataBus, Provider<LanguageClient>\n   @Nonnull\n   @Override\n   public CompletableFuture<Object> executeCommand(@Nonnull ExecuteCommandParams params) {\n+    runAsync(executeCopybookFix(params)).whenComplete(reportExceptionIfFound(params));\n+\n     return completedFuture(null);\n   }\n \n+  private Runnable executeCopybookFix(@Nonnull ExecuteCommandParams params) {\n+    return () -> {\n+      if (MISSING_COPYBOOK.name().equals(params.getCommand())) {\n+        rerunAnalysis();\n+      }\n+    };\n+  }\n+\n   /**\n-   * This is a notification triggered automatically when the user modify configuration settings in\n-   * the client\n+   * Process changed configuration on the client state. This notification triggered automatically\n+   * when the user modify configuration settings in the client. Invalidate all the caches to avoid\n+   * dirty state.\n    *\n    * @param params - LSPSpecification -> The actual changed settings; Actually -> null all the time.\n    */\n   @Override\n   public void didChangeConfiguration(DidChangeConfigurationParams params) {\n-    try {\n-\n-      // invalidate cache to avoid false positive\n-      dataBus.invalidateCache();\n-      fetchSettings(LSP_PREFIX.label + \".\" + CPY_MANAGER.label, null)\n-          .thenAccept(e -> dataBus.postData(FetchedSettingsEvent.builder().content(e).build()));\n-    } catch (RuntimeException e) {\n-      log.error(e.getMessage());\n-    }\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> acceptSettingsChange(toStrings(it)));\n   }\n \n-  /**\n-   * After client notifies the server that there is a setting change we need to request the client\n-   * those changing by sending a workspace/configuration JSON request\n-   *\n-   * @param section - The configuration section asked for.\n-   * @param scope - The scope to get the configuration section for.\n-   * @return - CompletedFuture which contains an object with the settings asked for.\n-   */\n-  private CompletableFuture<List<Object>> fetchSettings(String section, String scope) {\n-    ConfigurationParams params =\n-        new ConfigurationParams(provideConfigurationItemList(section, scope));\n-    return clientProvider.get().configuration(params);\n+  private void acceptSettingsChange(List<String> localFolders) {", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MTA5NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434561094", "bodyText": "I think it is better to mark WatcherServiceImpl#addWatchers and WatcherServiceImpl#removeWatchers as synchronized to reduce the sync area", "author": "temanbrcom", "createdAt": "2020-06-03T13:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyOTY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMzY0OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434533649", "bodyText": "The same as CobolWorkspaceServiceImpl#toString. I think that it could be a method of SettingsService.", "author": "grianbrcom", "createdAt": "2020-06-03T12:37:13Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "diffHunk": "@@ -162,10 +106,23 @@ void retrieveAndStoreConfiguration() {\n         new WorkspaceServerCapabilities(workspaceFoldersOptions);\n     capabilities.setWorkspace(workspaceServiceCapabilities);\n \n-    copybookService.setWorkspaceFolders(params.getWorkspaceFolders());\n     return supplyAsync(() -> new InitializeResult(capabilities));\n   }\n \n+  private void addLocalFilesWatcher() {\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> watchingService.addWatchers(toStrings(it)));\n+  }\n+\n+  private List<String> toStrings(List<Object> it) {", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MTkyNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434551927", "bodyText": "This line doesn't cover all cases. It converts Unix separators to Windows, but leave Windows separators unchanged for Unix.", "author": "grianbrcom", "createdAt": "2020-06-03T13:07:12Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MzA0MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434553041", "bodyText": "Not sure that it will be safe to delete \" symbol.", "author": "grianbrcom", "createdAt": "2020-06-03T13:09:02Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5Nzk0OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434597948", "bodyText": "Seems like we may drop this entire method, It was used to process URIs with profile and DS name", "author": "temanbrcom", "createdAt": "2020-06-03T14:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MzA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NTA3Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434555076", "bodyText": "It creates the file only if needed. Could it be renamed like ensureFile?", "author": "grianbrcom", "createdAt": "2020-06-03T13:12:14Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NjQwNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434556405", "bodyText": "We could use System.lineSeparator() here.", "author": "grianbrcom", "createdAt": "2020-06-03T13:14:12Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDEyOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434560129", "bodyText": "It makes sense to use Set here instead of List.", "author": "grianbrcom", "createdAt": "2020-06-03T13:20:03Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NTg5Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434585897", "bodyText": "depends on caseinsensitive, or  equalsIgnoreCase  usage", "author": "asatklichov", "createdAt": "2020-06-03T13:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MTg2Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434561863", "bodyText": "This check is useless. The file couldn't be a file and a directory at the same time.", "author": "grianbrcom", "createdAt": "2020-06-03T13:22:41Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NDczOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434564739", "bodyText": "Probably, some forgotten code", "author": "temanbrcom", "createdAt": "2020-06-03T13:26:53Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "diffHunk": "@@ -47,48 +51,171 @@\n  * implementation.\n  */\n @Slf4j\n+@SuppressWarnings(\"unchecked\")\n public class WorkspaceServiceTest {\n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n-   * not recognized.\n+   * Test of the workspace/executeCommand entry point. Assert that on a MISSING_COPYBOOK the {@link\n+   * RequiredCopybookEvent} fired.\n    */\n   @Test\n-  public void testExecuteNonExistingCommand() {\n+  public void testExecuteCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    String copybookName = \"COPYBOOK\";\n+\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n+        service.executeCommand(\n+            new ExecuteCommandParams(\n+                MISSING_COPYBOOK.name(),\n+                asList(new JsonPrimitive(copybookName), new JsonPrimitive(DOCUMENT_URI))));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, timeout(1000).times(0)).postData(any());\n+    verify(broker, timeout(10000)).invalidateCache();\n+    verify(broker, timeout(10000)).postData(any(RunAnalysisEvent.class));\n   }\n \n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the argument\n-   * list is incomplete.\n+   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n+   * not recognized.\n    */\n   @Test\n-  public void testExecuteCommandIncorrectArguments() {\n+  public void testExecuteNonExistingCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(\n-            new ExecuteCommandParams(\n-                MISSING_COPYBOOK.name(), singletonList(new JsonPrimitive(DOCUMENT_URI))));\n+        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, never()).postData(any());\n+    verify(broker, timeout(1000).times(0)).postData(any());\n+  }\n+\n+  /** Test a new watcher created when a new path add in setting.json */\n+  @Test\n+  public void testChangeConfigurationNewPath() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(watcherCaptor.capture());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path list not changed */\n+  @Test\n+  public void testChangeConfigurationNoChangesInPaths() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n   }\n+\n+  /** Test an existing watcher removed when its path doesn't exist in setting.json */\n+  @Test\n+  public void testChangeConfigurationPathRemoved() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(watcherCaptor.capture());\n+    verify(copybookService).invalidateURICache();\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path is empty */\n+  @Test\n+  public void testChangeConfigurationNoPathToRegister() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+  }\n+\n+  /**\n+   * This test verifies that the Workspace Service reacts on the file created watcher's\n+   * notifications\n+   */\n+  @Test\n+  public void testDidChangeWatchedFilesExistingFileCreated() {\n+    log.error(\"asdd\", new Error());", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NzQxOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434567419", "bodyText": "hasFileValidExtension function use equalsIgnoreCase, we can drop .toLowerCase() here.", "author": "grianbrcom", "createdAt": "2020-06-03T13:30:46Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")\n+        && FilenameUtils.getBaseName(currentFile.getName()).equalsIgnoreCase(requiredName)\n+        && hasFileValidExtension(currentFile.getAbsoluteFile().toString().toLowerCase());", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NTY1Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434595653", "bodyText": "Good catch, I agree", "author": "temanbrcom", "createdAt": "2020-06-03T14:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMDM3NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434610375", "bodyText": "I would suggest to make it plural", "author": "zacanbrcom", "createdAt": "2020-06-03T14:27:57Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,122 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final SettingsService settingsService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+          DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.settingsService = settingsService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n-  /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n-   *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n   @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n+  public void invalidateURICache() {\n+    copybookPath.clear();", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMTU2MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434611560", "bodyText": "Do we really need this message?", "author": "grianbrcom", "createdAt": "2020-06-03T14:29:31Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "diffHunk": "@@ -47,48 +51,171 @@\n  * implementation.\n  */\n @Slf4j\n+@SuppressWarnings(\"unchecked\")\n public class WorkspaceServiceTest {\n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n-   * not recognized.\n+   * Test of the workspace/executeCommand entry point. Assert that on a MISSING_COPYBOOK the {@link\n+   * RequiredCopybookEvent} fired.\n    */\n   @Test\n-  public void testExecuteNonExistingCommand() {\n+  public void testExecuteCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    String copybookName = \"COPYBOOK\";\n+\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n+        service.executeCommand(\n+            new ExecuteCommandParams(\n+                MISSING_COPYBOOK.name(),\n+                asList(new JsonPrimitive(copybookName), new JsonPrimitive(DOCUMENT_URI))));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, timeout(1000).times(0)).postData(any());\n+    verify(broker, timeout(10000)).invalidateCache();\n+    verify(broker, timeout(10000)).postData(any(RunAnalysisEvent.class));\n   }\n \n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the argument\n-   * list is incomplete.\n+   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n+   * not recognized.\n    */\n   @Test\n-  public void testExecuteCommandIncorrectArguments() {\n+  public void testExecuteNonExistingCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(\n-            new ExecuteCommandParams(\n-                MISSING_COPYBOOK.name(), singletonList(new JsonPrimitive(DOCUMENT_URI))));\n+        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, never()).postData(any());\n+    verify(broker, timeout(1000).times(0)).postData(any());\n+  }\n+\n+  /** Test a new watcher created when a new path add in setting.json */\n+  @Test\n+  public void testChangeConfigurationNewPath() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(watcherCaptor.capture());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path list not changed */\n+  @Test\n+  public void testChangeConfigurationNoChangesInPaths() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n   }\n+\n+  /** Test an existing watcher removed when its path doesn't exist in setting.json */\n+  @Test\n+  public void testChangeConfigurationPathRemoved() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(watcherCaptor.capture());\n+    verify(copybookService).invalidateURICache();\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path is empty */\n+  @Test\n+  public void testChangeConfigurationNoPathToRegister() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+  }\n+\n+  /**\n+   * This test verifies that the Workspace Service reacts on the file created watcher's\n+   * notifications\n+   */\n+  @Test\n+  public void testDidChangeWatchedFilesExistingFileCreated() {\n+    log.error(\"asdd\", new Error());", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzE2MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434613160", "bodyText": "But this method is not returning a String but a List of strings.. I am not sure that is correct this name..", "author": "zacanbrcom", "createdAt": "2020-06-03T14:31:32Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "diffHunk": "@@ -162,10 +106,23 @@ void retrieveAndStoreConfiguration() {\n         new WorkspaceServerCapabilities(workspaceFoldersOptions);\n     capabilities.setWorkspace(workspaceServiceCapabilities);\n \n-    copybookService.setWorkspaceFolders(params.getWorkspaceFolders());\n     return supplyAsync(() -> new InitializeResult(capabilities));\n   }\n \n+  private void addLocalFilesWatcher() {\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> watchingService.addWatchers(toStrings(it)));\n+  }\n+\n+  private List<String> toStrings(List<Object> it) {", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2NDY1Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434664652", "bodyText": "The name here is plural. In fact, this is kinda monade and toStrings sounds more or less functinal", "author": "temanbrcom", "createdAt": "2020-06-03T15:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzM3NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434613375", "bodyText": "Newline here! Is it a time to enable static code checks as part of CI?", "author": "grianbrcom", "createdAt": "2020-06-03T14:31:52Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/actions/FindCopybookCommandTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.actions;\n+\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static java.util.Collections.singletonList;\n+import static org.eclipse.lsp4j.CodeActionKind.QuickFix;\n+import static org.eclipse.lsp4j.DiagnosticSeverity.Error;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+/**\n+ * Test {@link FindCopybookCommand} code action provider that resolves diagnostics for missing\n+ * copybooks.\n+ */\n+public class FindCopybookCommandTest {\n+\n+    private static final String TITLE = \"Fetch copybook\";\n+    private static final String COPYBOOK_NAME = \"CPYNAME\";\n+\n+    private static final Range RANGE = new Range(new Position(0, 0), new Position(0, 1));\n+    private static final Diagnostic SYNTAX_ERROR =\n+            new Diagnostic(RANGE, \"Syntax error\", Error, null, null);\n+    private static final Diagnostic COPYBOOK_ERROR =\n+            new Diagnostic(\n+                    RANGE, COPYBOOK_NAME + \": Copybook not found\", Error, null, MISSING_COPYBOOK.name());\n+\n+    /** Test a code action to resolve the required copybook created for the missing copybook error. */\n+    @Test\n+    public void testCollectCommandsOrActionsPositive() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    /** Test nothing created for a syntax error. */\n+    @Test\n+    public void testCollectCommandsOrActionsNegative() {\n+\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(SYNTAX_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(0, actions.size());\n+    }\n+\n+    /** Test only correct errors processed. */\n+    @Test\n+    public void testCollectCommandsOrActionsMixed() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = Arrays.asList(SYNTAX_ERROR, COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    private void assertCorrectCodeAction(CodeAction action) {\n+        assertEquals(TITLE, action.getTitle());\n+        assertEquals(QuickFix, action.getKind());\n+        assertEquals(COPYBOOK_ERROR, action.getDiagnostics().get(0));\n+        assertNull(action.getEdit());\n+\n+        Command command = action.getCommand();\n+        assertEquals(TITLE, command.getTitle());\n+        assertEquals(MISSING_COPYBOOK.name(), command.getCommand());\n+\n+        List<Object> arguments = command.getArguments();\n+        assertEquals(2, arguments.size());\n+        assertEquals(COPYBOOK_NAME, arguments.get(0));\n+        assertEquals(DOCUMENT_URI, arguments.get(1));\n+    }\n+}", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0Nzk0Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434647946", "bodyText": "well..I think that an IDE with configured google format enabled and reformat option after save should be enough", "author": "zacanbrcom", "createdAt": "2020-06-03T15:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2MDUwMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434660500", "bodyText": "Why not?", "author": "temanbrcom", "createdAt": "2020-06-03T15:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNjk2NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434616965", "bodyText": "what about to introduce a small Facade that accept the mode (DID_OPEN or DID_CHANGE) and invoke the correct implementation? The thing that analyzeDocumentFirstTime could be executed when we need to use DID_OPEN mode could not be clear for the developer", "author": "zacanbrcom", "createdAt": "2020-06-03T14:36:30Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -195,7 +198,7 @@ public void didSave(DidSaveTextDocumentParams params) {\n \n   @Override\n   public void observerCallback(@Nonnull RunAnalysisEvent event) {\n-    docs.forEach((key, value) -> analyzeChanges(key, value.getText()));\n+    docs.forEach((key, value) -> analyzeDocumentFirstTime(key, value.getText()));", "originalCommit": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2MjkwNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434662906", "bodyText": "In fact, we just need to create a more descriptive name for these methods. Something like analyzeCompleteDocument and analyzeIncompleteDocument", "author": "temanbrcom", "createdAt": "2020-06-03T15:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNjk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTE0MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434731141", "bodyText": "Better naming would be ClientSettingsService or LanguageClientSettingsService", "author": "asatklichov", "createdAt": "2020-06-03T17:20:40Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsService.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ *\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.", "originalCommit": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwODQ4MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r435108481", "bodyText": "As for me, the current name is descriptive enough", "author": "temanbrcom", "createdAt": "2020-06-04T09:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMDMxOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r435130319", "bodyText": "In server we use terms client provider and, client-language,  lsp4j uses the same approach client...  And we get client-configuration.", "author": "asatklichov", "createdAt": "2020-06-04T09:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTQwNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434731407", "bodyText": "respective to above interface", "author": "asatklichov", "createdAt": "2020-06-03T17:21:06Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsServiceImpl.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.", "originalCommit": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b1522423610609b80eaeccb91c13259602e91d5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3b1522423610609b80eaeccb91c13259602e91d5", "message": "refactor: Remove POC vsc commands GH-376", "committedDate": "2020-06-04T10:11:01Z", "type": "commit"}, {"oid": "4445649ea0b39c6a4ab5ebf1df27ca3506eac3a6", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4445649ea0b39c6a4ab5ebf1df27ca3506eac3a6", "message": "refactor: Invoke handleQueue() from start() GH-376", "committedDate": "2020-06-04T10:11:18Z", "type": "commit"}, {"oid": "4ddb641328b520948fbb5e810f02dc87ee7e11e0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4ddb641328b520948fbb5e810f02dc87ee7e11e0", "message": "refactor: Remove unused function GH-376", "committedDate": "2020-06-04T10:11:33Z", "type": "commit"}, {"oid": "caec99f76090d57624096d0e637c0910123796b3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/caec99f76090d57624096d0e637c0910123796b3", "message": "refactor: Use fs API for Node 10x and apply linting GH-376", "committedDate": "2020-06-04T10:11:44Z", "type": "commit"}, {"oid": "7c2e9dbf71fbf67cfbd490f7ff8aabf4ab5b3b84", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7c2e9dbf71fbf67cfbd490f7ff8aabf4ab5b3b84", "message": "refactor: Apply linting GH-23 GH-376", "committedDate": "2020-06-04T10:11:58Z", "type": "commit"}, {"oid": "932ffb8f3115933233b5981ee4e240a15970e5eb", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/932ffb8f3115933233b5981ee4e240a15970e5eb", "message": "refactor: Don't resolve copybooks in unregistered local folders GH-355\nInvalidate cached URIs when watcher list chagned.", "committedDate": "2020-06-04T10:12:13Z", "type": "commit"}, {"oid": "6bd5a017a9a2c25b1abba883122e1918f0bbb7b2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6bd5a017a9a2c25b1abba883122e1918f0bbb7b2", "message": "refactor: Rename ClientService to SettingsService\n\nAdd the header to Middleware.ts\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-04T10:12:24Z", "type": "commit"}, {"oid": "dfe575ae00412b4a9ad50add97fe1094e4c6381d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/dfe575ae00412b4a9ad50add97fe1094e4c6381d", "message": "refactor: Remove dead code #23", "committedDate": "2020-06-04T10:12:25Z", "type": "commit"}, {"oid": "b6be411b01298b38c02c4b844192fa673a7a2539", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b6be411b01298b38c02c4b844192fa673a7a2539", "message": "refactor: Remove obsolete code #23", "committedDate": "2020-06-04T10:12:25Z", "type": "commit"}, {"oid": "989a279ed02e9753e46c1bfeeed6aa9ec9690e4d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/989a279ed02e9753e46c1bfeeed6aa9ec9690e4d", "message": "refactor: Apply linting GH-23 GH-376", "committedDate": "2020-06-04T10:12:25Z", "type": "commit"}, {"oid": "43413f657530a08ffdb87189e0055002a6efcddc", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/43413f657530a08ffdb87189e0055002a6efcddc", "message": "refactor: Make watchers registration thread-safe GH-355", "committedDate": "2020-06-04T10:12:25Z", "type": "commit"}, {"oid": "6aa6321f9b2178c603ea783d990ebbb4d3e98273", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6aa6321f9b2178c603ea783d990ebbb4d3e98273", "message": "Merge remote-tracking branch 'origin/fetch-priority-final' into fetch-priority-final\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/Middleware.ts", "committedDate": "2020-06-04T10:12:43Z", "type": "commit"}, {"oid": "8e489c0665e725771722ea9a387cd5049b0f7db0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8e489c0665e725771722ea9a387cd5049b0f7db0", "message": "refactor: Address request of change GH-376", "committedDate": "2020-06-04T10:12:44Z", "type": "commit"}, {"oid": "40b79841619dcea771476cc9722d4715e2e53801", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/40b79841619dcea771476cc9722d4715e2e53801", "message": "Merge remote-tracking branch 'origin/fetch-priority-final' into fetch-priority-final", "committedDate": "2020-06-04T10:12:53Z", "type": "commit"}, {"oid": "21387d29a6d2cb67334aa6b1c0416c28b0b8de26", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/21387d29a6d2cb67334aa6b1c0416c28b0b8de26", "message": "refactor: Address request of change GH-23 GH-376", "committedDate": "2020-06-04T10:12:54Z", "type": "commit"}, {"oid": "ea7c0706577299a017ba6ea66993bc1dcc99c2d5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ea7c0706577299a017ba6ea66993bc1dcc99c2d5", "message": "refactor: Extract monade method to reduce code duplication GH-23", "committedDate": "2020-06-04T10:13:06Z", "type": "commit"}, {"oid": "47b6a434b339b0de832aec354816f7caec9c5e50", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/47b6a434b339b0de832aec354816f7caec9c5e50", "message": "Merge branch 'fetch-priority-final' of https://github.com/eclipse/che-che4z-lsp-for-cobol into fetch-priority-final", "committedDate": "2020-06-04T10:14:23Z", "type": "commit"}, {"oid": "875815ae7a7fbb2974146bf8f0097e8f98b34530", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/875815ae7a7fbb2974146bf8f0097e8f98b34530", "message": "refactor: Address request of change GH-23 GH-376", "committedDate": "2020-06-04T10:14:24Z", "type": "commit"}, {"oid": "278f2981bbe67a9014aab6874e1bfeaddd0b3ce8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/278f2981bbe67a9014aab6874e1bfeaddd0b3ce8", "message": "refactor: Move all the posiible settings parameters to one enum #327", "committedDate": "2020-06-04T10:14:37Z", "type": "commit"}, {"oid": "b18e141049bbf3df56f257ae0d46bc92ad8a58c6", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b18e141049bbf3df56f257ae0d46bc92ad8a58c6", "message": "refactor: Make response parsing null safe #327", "committedDate": "2020-06-04T10:14:37Z", "type": "commit"}, {"oid": "5e5cf34d287effef08ccf00c8f953999c398d289", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5e5cf34d287effef08ccf00c8f953999c398d289", "message": "refactor: Adjust class indentation #23", "committedDate": "2020-06-04T10:14:37Z", "type": "commit"}, {"oid": "80220be25da328e2d2e4f168f7bb17310832fa11", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/80220be25da328e2d2e4f168f7bb17310832fa11", "message": "test: Remove folder structure to avoid dirty state #23", "committedDate": "2020-06-04T10:14:37Z", "type": "commit"}, {"oid": "80220be25da328e2d2e4f168f7bb17310832fa11", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/80220be25da328e2d2e4f168f7bb17310832fa11", "message": "test: Remove folder structure to avoid dirty state #23", "committedDate": "2020-06-04T10:14:37Z", "type": "forcePushed"}, {"oid": "681cb50681ff03b860271ba4a5b1ff0027256163", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/681cb50681ff03b860271ba4a5b1ff0027256163", "message": "Add test to parse json like settings", "committedDate": "2020-04-16T11:09:56Z", "type": "commit"}, {"oid": "4a9db1f5f3f93a7384a997389668551cdf4d9c23", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4a9db1f5f3f93a7384a997389668551cdf4d9c23", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T10:50:56Z", "type": "forcePushed"}, {"oid": "8d13d50e421b0f0bdcbfa37fcf58eb75c3bad258", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8d13d50e421b0f0bdcbfa37fcf58eb75c3bad258", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T11:32:20Z", "type": "forcePushed"}, {"oid": "3fa27292b279346025b333a08f8e3103742c735a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3fa27292b279346025b333a08f8e3103742c735a", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T11:50:06Z", "type": "forcePushed"}, {"oid": "fe352b6ceda6a5fb98aef425dab1f65809a95905", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fe352b6ceda6a5fb98aef425dab1f65809a95905", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T11:56:45Z", "type": "forcePushed"}, {"oid": "e65fcb569c535189d26074d8c73180264f4e4939", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e65fcb569c535189d26074d8c73180264f4e4939", "message": "refactor: Introduce on-demand client configuration calls GH-327\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:19:36Z", "type": "commit"}, {"oid": "3029af7b967ba7eaa794bad5208fa48b61aa3940", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3029af7b967ba7eaa794bad5208fa48b61aa3940", "message": "Merge pull request #360 from grianbrcom/hackathon\n\nSettings request PoC.", "committedDate": "2020-06-02T12:21:47Z", "type": "commit"}, {"oid": "e00072c4ce656db9ef5b88c11bce5f8f7b3880a0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e00072c4ce656db9ef5b88c11bce5f8f7b3880a0", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T12:22:32Z", "type": "forcePushed"}, {"oid": "098f4bc4fab1476f6f9faad5f07182bba639784f", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/098f4bc4fab1476f6f9faad5f07182bba639784f", "message": "feat: Fetch copybooks without .dep files GH-327\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:29:03Z", "type": "commit"}, {"oid": "49ea34b7de8d6c58e09c243a0c7ccad93aa414ab", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/49ea34b7de8d6c58e09c243a0c7ccad93aa414ab", "message": "refactor: Clean-up ClientService GH-327\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:29:43Z", "type": "commit"}, {"oid": "9550d1186d2649763d31ed809b113c01665f2571", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9550d1186d2649763d31ed809b113c01665f2571", "message": "Merge pull request #361 from grianbrcom/hackathon\n\nHackathon", "committedDate": "2020-06-02T12:31:26Z", "type": "commit"}, {"oid": "70aad367972fa8a12c2fcfdb198917d9c9419f1c", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/70aad367972fa8a12c2fcfdb198917d9c9419f1c", "message": "Merge pull request #362 from grianbrcom/hackathon\n\nFix analyse and rewrite ClientService", "committedDate": "2020-06-02T12:31:27Z", "type": "commit"}, {"oid": "cc95d6978e0fbfff3764c9e5cbedacc9059b09db", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cc95d6978e0fbfff3764c9e5cbedacc9059b09db", "message": "refactor: Move copybook fetch Quick Fix to the server GH-327", "committedDate": "2020-06-02T12:31:27Z", "type": "commit"}, {"oid": "fa665044793615413805367db574a1bdd818a490", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fa665044793615413805367db574a1bdd818a490", "message": "refactor: Interrupt a thread that had an exception #355", "committedDate": "2020-06-02T12:31:59Z", "type": "commit"}, {"oid": "3909b849ec0d5fe8494614a305351fe5a58e8a0d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3909b849ec0d5fe8494614a305351fe5a58e8a0d", "message": "refactor: Remove deprecated settings provider #355", "committedDate": "2020-06-02T12:31:59Z", "type": "commit"}, {"oid": "84df73adba5b9d9fa790141725c55af05dcc09c4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/84df73adba5b9d9fa790141725c55af05dcc09c4", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T12:34:53Z", "type": "forcePushed"}, {"oid": "0358b9541c2a9e0b9410c43a3a6b13ab324cb5e2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0358b9541c2a9e0b9410c43a3a6b13ab324cb5e2", "message": "feat: Introduce dynamic registration for watchers GH-355", "committedDate": "2020-06-02T12:37:47Z", "type": "commit"}, {"oid": "f6510533cf02ca74cf83911f0b8bcd5e1d2db763", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f6510533cf02ca74cf83911f0b8bcd5e1d2db763", "message": "tests: Adjust Workspace Service unit test #355", "committedDate": "2020-06-02T12:37:56Z", "type": "commit"}, {"oid": "0e3eeb57da431594cb28ba79216b52b66e5c553d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0e3eeb57da431594cb28ba79216b52b66e5c553d", "message": "refactor: Make configuration calls async #355", "committedDate": "2020-06-02T12:37:56Z", "type": "commit"}, {"oid": "715179e5fed2342fb5a97d317bddaac15205030d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/715179e5fed2342fb5a97d317bddaac15205030d", "message": "refactor:Make Watching Service a singleton #355", "committedDate": "2020-06-02T12:37:56Z", "type": "commit"}, {"oid": "7117683e8ff09c067d850cda9be2f7957630bca1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7117683e8ff09c067d850cda9be2f7957630bca1", "message": "fix: Fix glob pattern for dynamic registration #355", "committedDate": "2020-06-02T12:37:56Z", "type": "commit"}, {"oid": "010b756f3b5c70e3c218a40661943a200cd642c3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/010b756f3b5c70e3c218a40661943a200cd642c3", "message": "test: Adjust Language Server test to the new requirements #355", "committedDate": "2020-06-02T12:37:56Z", "type": "commit"}, {"oid": "3b42dbc079c4df8a2a20b2cc492ea403944b5e9e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3b42dbc079c4df8a2a20b2cc492ea403944b5e9e", "message": "tests: Adjust tests to new requirements #355", "committedDate": "2020-06-02T12:37:56Z", "type": "commit"}, {"oid": "9b82e96461195421724f6494ef76a7edefcaed26", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9b82e96461195421724f6494ef76a7edefcaed26", "message": "test: Remove deprecated tests #355", "committedDate": "2020-06-02T12:37:56Z", "type": "commit"}, {"oid": "177be4fd2bb27d904f093bf06346947531684156", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/177be4fd2bb27d904f093bf06346947531684156", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T12:38:41Z", "type": "forcePushed"}, {"oid": "3ea69edf69923f6afec650bde6c1b51ff010aff9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3ea69edf69923f6afec650bde6c1b51ff010aff9", "message": "test: Add test related to path validation GH-355", "committedDate": "2020-06-02T12:44:31Z", "type": "commit"}, {"oid": "6b594f074ca1dda3751fd92574d523dc365d6c39", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6b594f074ca1dda3751fd92574d523dc365d6c39", "message": "refactor: Exclude invalid URIs on paths parsing GH-355", "committedDate": "2020-06-02T12:44:46Z", "type": "commit"}, {"oid": "859c3f53593741475f546ecfe2892bc7d92b39e7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/859c3f53593741475f546ecfe2892bc7d92b39e7", "message": "refactor: Introduce URI validation in the Local Copybook Resolver GH-355", "committedDate": "2020-06-02T12:46:08Z", "type": "commit"}, {"oid": "3781fc6f259ef463e1fa9cf61e37e728913902fe", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3781fc6f259ef463e1fa9cf61e37e728913902fe", "message": "refactor: Apply more descriptive name for class and test GH-23", "committedDate": "2020-06-02T12:46:30Z", "type": "commit"}, {"oid": "96d3c99093bd1f2bf82801dd9f95b2569d25c090", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/96d3c99093bd1f2bf82801dd9f95b2569d25c090", "message": "test: Add unit test to avoid duplicates in URI list GH-355", "committedDate": "2020-06-02T12:47:23Z", "type": "commit"}, {"oid": "6a053212accd15c3c28f3a190c9ba977e326021b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6a053212accd15c3c28f3a190c9ba977e326021b", "message": "test: Polish test suite and minor changes GH-23", "committedDate": "2020-06-02T12:47:37Z", "type": "commit"}, {"oid": "5c614a695862f5114237f14742da888e630b79e8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5c614a695862f5114237f14742da888e630b79e8", "message": "refactor: Minor changes on API naming and documentation GH-355", "committedDate": "2020-06-02T12:47:54Z", "type": "commit"}, {"oid": "f76c5226a4119a65edfcca0fd1de7ec4fba9874b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f76c5226a4119a65edfcca0fd1de7ec4fba9874b", "message": "refactor: Minor changes on API GH-355", "committedDate": "2020-06-02T12:48:23Z", "type": "commit"}, {"oid": "a8ccdb983b43055dad6ae9cbc97b684614f7a2fc", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a8ccdb983b43055dad6ae9cbc97b684614f7a2fc", "message": "Merge remote-tracking branch 'remotes/origin/development' into POC_LocalURISetting\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts", "committedDate": "2020-06-02T12:48:47Z", "type": "commit"}, {"oid": "572c86ee036b8d9b8334b4699f8698c5729d02a3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/572c86ee036b8d9b8334b4699f8698c5729d02a3", "message": "Address merge conflicts with development", "committedDate": "2020-06-02T12:48:48Z", "type": "commit"}, {"oid": "286daefb632119f89e47e59fc8065decf2edc99e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/286daefb632119f89e47e59fc8065decf2edc99e", "message": "refactor: Address conflict with existent path key in json definition GH-327", "committedDate": "2020-06-02T12:48:55Z", "type": "commit"}, {"oid": "89555943a5d26b08e6d2544799521ac62a9dff05", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/89555943a5d26b08e6d2544799521ac62a9dff05", "message": "refactor: Add URI normalize to avoid unexpected result - as double slashes GH-355", "committedDate": "2020-06-02T12:49:57Z", "type": "commit"}, {"oid": "09b8016fefdfa414faebf6b6d0c5f78eafd3b5db", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/09b8016fefdfa414faebf6b6d0c5f78eafd3b5db", "message": "Update API to return URI in the result array", "committedDate": "2020-06-02T12:50:08Z", "type": "commit"}, {"oid": "7d3a06880c5080ba42ef232bf189846d99f625f6", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7d3a06880c5080ba42ef232bf189846d99f625f6", "message": "feat: Retrieve local copybooks if exists GH-327", "committedDate": "2020-06-02T12:50:08Z", "type": "commit"}, {"oid": "2a82ee02d2b5d866550d12dfed4ad793789c7864", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a82ee02d2b5d866550d12dfed4ad793789c7864", "message": "Merge remote-tracking branch 'origin/development' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/package.json\n#\tclients/cobol-lsp-vscode-extension/src/__tests__/LocalCopybookResolverTest.ts\n#\tclients/cobol-lsp-vscode-extension/src/constants.ts\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksPathGenerator.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/settings/LocalCopybookResolver.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/settings/util/SettingsUtils.ts", "committedDate": "2020-06-02T12:50:16Z", "type": "commit"}, {"oid": "4ebe933fc02d9fcca212b78ec586082e413e0727", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4ebe933fc02d9fcca212b78ec586082e413e0727", "message": "refactor: Adjust variable declaration GH-23", "committedDate": "2020-06-02T12:50:17Z", "type": "commit"}, {"oid": "d44c31426a24e47bd0237886267e07713026982c", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d44c31426a24e47bd0237886267e07713026982c", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "committedDate": "2020-06-02T12:50:21Z", "type": "commit"}, {"oid": "0bbf921e0c0d4a4904a1281a1ce05c5d114d5aa8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0bbf921e0c0d4a4904a1281a1ce05c5d114d5aa8", "message": "Test sending local URI from client to server GH-327", "committedDate": "2020-06-02T12:50:22Z", "type": "commit"}, {"oid": "678b9181159a278a62bb9a947c316473faa9ea34", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/678b9181159a278a62bb9a947c316473faa9ea34", "message": "Address request change to readability improvements", "committedDate": "2020-06-02T12:50:24Z", "type": "commit"}, {"oid": "838ab89c97baf44cf28d08d314df5fd0198752b8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/838ab89c97baf44cf28d08d314df5fd0198752b8", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "committedDate": "2020-06-02T12:50:29Z", "type": "commit"}, {"oid": "c4b945eefa9d6bda6a295a08aa6c65f267893f1b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c4b945eefa9d6bda6a295a08aa6c65f267893f1b", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "committedDate": "2020-06-02T12:50:36Z", "type": "commit"}, {"oid": "f540302efb8d9542f830e101908a5a3cb7e3822e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f540302efb8d9542f830e101908a5a3cb7e3822e", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "committedDate": "2020-06-02T12:50:36Z", "type": "commit"}, {"oid": "2482c926dd9b4ff9cee64bdc1c82fb41b4ae486b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2482c926dd9b4ff9cee64bdc1c82fb41b4ae486b", "message": "Merge remote-tracking branch 'origin/fetch-priority' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "committedDate": "2020-06-02T12:50:40Z", "type": "commit"}, {"oid": "781137d136e6746e52ff8bdae83b62ff3a98b426", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/781137d136e6746e52ff8bdae83b62ff3a98b426", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "018694134e19d64565ff552b15acd67085ef9dd2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/018694134e19d64565ff552b15acd67085ef9dd2", "message": "test: Clean unit test for Copybook Resolver GH-355", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "64ac0fa46330b13c67b8d78081fa11c73eaec2cc", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/64ac0fa46330b13c67b8d78081fa11c73eaec2cc", "message": "refactor: Clean up client part GH-23", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "9292bd6d9ffcb4f2f574b346ef0b74fd4b2392cb", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9292bd6d9ffcb4f2f574b346ef0b74fd4b2392cb", "message": "refactor: Refactor Middleware client part (GH-364)\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "92de7e33f68ef000bea797ac4f65dd38034c3fd1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/92de7e33f68ef000bea797ac4f65dd38034c3fd1", "message": "refactor: Clean up client part of copybook resolution GH-355", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "130bbe553896ebba481de0cdd8b7933b752d9636", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/130bbe553896ebba481de0cdd8b7933b752d9636", "message": "refactor: Fix middleware issue (GH-365)\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "1afe03985110b5b71004a57953221c8c61a3c510", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1afe03985110b5b71004a57953221c8c61a3c510", "message": "fix: Fix issue with indirect overwrite settings conf for dsn paths", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "49d5730708035682fb3ef2fe5431c2122f6794fe", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/49d5730708035682fb3ef2fe5431c2122f6794fe", "message": "refactor: Remove obsolete prioritization on the client side", "committedDate": "2020-06-02T12:50:41Z", "type": "commit"}, {"oid": "ee86a20208d0e4786be3929e7af072b27182bfb0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ee86a20208d0e4786be3929e7af072b27182bfb0", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "committedDate": "2020-06-02T12:50:45Z", "type": "commit"}, {"oid": "9ac90c31f45c33e783e74cac7ff1be424a14f2eb", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9ac90c31f45c33e783e74cac7ff1be424a14f2eb", "message": "refactor: Fix cobol name extraction (GH-366)\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:50:45Z", "type": "commit"}, {"oid": "58048f62c926c9728de07fe5a748fff8289f0c14", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/58048f62c926c9728de07fe5a748fff8289f0c14", "message": "refactor: Introduce method to handle responsability for just add missing copybook in the internal queue", "committedDate": "2020-06-02T12:50:45Z", "type": "commit"}, {"oid": "9552e3b51e607efbf9f00c70fd47257a7744e4f1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9552e3b51e607efbf9f00c70fd47257a7744e4f1", "message": "test: Add client tests for middleware (GH-367)\n\nFiltering fetch copybook events only for didOpen.\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:50:45Z", "type": "commit"}, {"oid": "6657ccd6f53c7b285412b464a44ee47063580f56", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6657ccd6f53c7b285412b464a44ee47063580f56", "message": "refactor: Remove unused methods GH-23", "committedDate": "2020-06-02T12:50:45Z", "type": "commit"}, {"oid": "39169e2c57e2e748990b95f1697a3b678c917691", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/39169e2c57e2e748990b95f1697a3b678c917691", "message": "fix: Fix issue related to copybook with extension that were not recognized as valid URI GH-355", "committedDate": "2020-06-02T12:50:45Z", "type": "commit"}, {"oid": "842cfcc9451baba457b39d40f8b855850b833eb5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/842cfcc9451baba457b39d40f8b855850b833eb5", "message": "Merge branch 'copybooks-middleware' into fetch-priority", "committedDate": "2020-06-02T12:50:46Z", "type": "commit"}, {"oid": "783716b52d9c427884a2eefe8230d8fb6e9568a8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/783716b52d9c427884a2eefe8230d8fb6e9568a8", "message": "test: Provide a unit test for Watching Service #355", "committedDate": "2020-06-02T12:50:46Z", "type": "commit"}, {"oid": "58e8305c23dac7a22bcd1d2809e54674de4624af", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/58e8305c23dac7a22bcd1d2809e54674de4624af", "message": "test: Improve CopybookURI.ts code coverage and address lint of javadoc", "committedDate": "2020-06-02T12:50:49Z", "type": "commit"}, {"oid": "163bee3dd43efbaae91ceea88203e3bceb315ff9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/163bee3dd43efbaae91ceea88203e3bceb315ff9", "message": "Merge remote-tracking branch 'origin/fetch-priority' into fetch-priority", "committedDate": "2020-06-02T12:50:50Z", "type": "commit"}, {"oid": "6e67f5b626e109aad45788805b0f3f9846abed86", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6e67f5b626e109aad45788805b0f3f9846abed86", "message": "Merge remote-tracking branch 'origin/fetch-priority' into fetch-priority", "committedDate": "2020-06-02T12:50:55Z", "type": "commit"}, {"oid": "a16eeb1993a523d759738f7e8586ce8dd3e81399", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a16eeb1993a523d759738f7e8586ce8dd3e81399", "message": "Merge branch 'development' into fetch-priority", "committedDate": "2020-06-02T12:50:56Z", "type": "commit"}, {"oid": "3713b3a2701016ab72670135065974fdaace8a87", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3713b3a2701016ab72670135065974fdaace8a87", "message": "refactor: Remove deprected tests #355", "committedDate": "2020-06-02T12:50:56Z", "type": "commit"}, {"oid": "0898b9a6ec8609ee4c4615bd8656f071a4f6ca80", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0898b9a6ec8609ee4c4615bd8656f071a4f6ca80", "message": "refactor: Delete unused classes GH-23\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-06-02T12:50:56Z", "type": "commit"}, {"oid": "fb8074847eec320e0e899f0d3c19b82135756ab8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fb8074847eec320e0e899f0d3c19b82135756ab8", "message": "test: Improved SettingsUtils unit test", "committedDate": "2020-06-02T12:50:56Z", "type": "commit"}, {"oid": "3791c50c3df3689ea360b6a7d044c95545f3779b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3791c50c3df3689ea360b6a7d044c95545f3779b", "message": "Merge pull request #370 from grianbrcom/fp_fix\n\ndelete unused class", "committedDate": "2020-06-02T12:50:56Z", "type": "commit"}, {"oid": "b305bc91f9952767ec52908cdd435a17970ccbf2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b305bc91f9952767ec52908cdd435a17970ccbf2", "message": "Merge pull request GH-370 from grianbrcom/fp_fix", "committedDate": "2020-06-02T12:50:57Z", "type": "commit"}, {"oid": "4c1242bddfcbd5bcda943a7a414e1eab5550c963", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4c1242bddfcbd5bcda943a7a414e1eab5550c963", "message": "Merge pull request GH-370 from grianbrcom/fp_fix", "committedDate": "2020-06-02T12:50:57Z", "type": "commit"}, {"oid": "63fc95ed19e23a40224a2508ee82cd67ad3c75b5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/63fc95ed19e23a40224a2508ee82cd67ad3c75b5", "message": "refactor: Add File Service to simplify testing GH-355", "committedDate": "2020-06-02T12:50:57Z", "type": "commit"}, {"oid": "51b944819b4e267da8e8179319146297a7aba087", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/51b944819b4e267da8e8179319146297a7aba087", "message": "Merge from fet priority\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>", "committedDate": "2020-06-02T12:50:58Z", "type": "commit"}, {"oid": "9474e2a6433e0c1a1034ad0e0eeecded8be56438", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9474e2a6433e0c1a1034ad0e0eeecded8be56438", "message": "Merge pull request #371 from asatklichov/fetch-priority-gitignore\n\nFetch priority gitignore", "committedDate": "2020-06-02T12:50:58Z", "type": "commit"}, {"oid": "e7ed36583ad8ab467bcb07f80987f8677a54cfa5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e7ed36583ad8ab467bcb07f80987f8677a54cfa5", "message": "refactor: Make URI resolution work with .c4z folder #355", "committedDate": "2020-06-02T12:50:59Z", "type": "commit"}, {"oid": "e28e508453cc1d020ace7556922139b90884514f", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e28e508453cc1d020ace7556922139b90884514f", "message": "refactor: Remove deprecated URI resolution #355", "committedDate": "2020-06-02T12:50:59Z", "type": "commit"}, {"oid": "61fd795630f9c9b5e828d5d92fa5a52f23739ec2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/61fd795630f9c9b5e828d5d92fa5a52f23739ec2", "message": "test: Skip not finalized tests #355", "committedDate": "2020-06-02T12:50:59Z", "type": "commit"}, {"oid": "a0d2e4a36f36100cea7a930d2cd78405f9b722f3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a0d2e4a36f36100cea7a930d2cd78405f9b722f3", "message": "test: Define PathsService.ts unit test GH-355", "committedDate": "2020-06-02T12:50:59Z", "type": "commit"}, {"oid": "b760bd532d827afab0c6b458cb6d993d32f78a54", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b760bd532d827afab0c6b458cb6d993d32f78a54", "message": "refactor: Add check for non-existing copybook file #355", "committedDate": "2020-06-02T12:50:59Z", "type": "commit"}, {"oid": "c907a621a9a2edffdd7de7fc610fe9948d341c85", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c907a621a9a2edffdd7de7fc610fe9948d341c85", "message": "refactor: Remove unused files GH-23", "committedDate": "2020-06-02T13:08:21Z", "type": "commit"}, {"oid": "c907a621a9a2edffdd7de7fc610fe9948d341c85", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c907a621a9a2edffdd7de7fc610fe9948d341c85", "message": "refactor: Remove unused files GH-23", "committedDate": "2020-06-02T13:08:21Z", "type": "forcePushed"}, {"oid": "adb2a7aa7d35b0f756a244639793eb529b3384a2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/adb2a7aa7d35b0f756a244639793eb529b3384a2", "message": "refactor: Add missing copyright header GH-23\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>", "committedDate": "2020-06-02T14:30:42Z", "type": "commit"}, {"oid": "ddd3cc9f358c1114c445cee9dd4d1e8b2b33168a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ddd3cc9f358c1114c445cee9dd4d1e8b2b33168a", "message": "test: Update test to work with temp folder GH-23\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>", "committedDate": "2020-06-02T14:34:48Z", "type": "commit"}, {"oid": "343697768b8d1df42b3eb106519c085ca45a6c0c", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/343697768b8d1df42b3eb106519c085ca45a6c0c", "message": "ci: Add Jest treshold for client tests\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>", "committedDate": "2020-06-02T14:41:31Z", "type": "commit"}, {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f8ea14e2fec6f2793b0b997ea00c8958d031b640", "message": "refactor: Remove duplicated method calls GH-23\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>", "committedDate": "2020-06-02T14:44:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434380968", "bodyText": "@grianbrcom it's time to get rid of this TODO", "author": "zacanbrcom", "createdAt": "2020-06-03T08:01:08Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/ClientService.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.ca.lsp.cobol.service;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface ClientService {\n+  // TODO:provide more descriptive name for this class", "originalCommit": "f8ea14e2fec6f2793b0b997ea00c8958d031b640", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0NTYzOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434445639", "bodyText": "Let's discuss it. Basically it should be \"SettingsService\". With method name \"getConfiguration\".\nAnd we use the class for reading the settings.\nBut we also use it for generating URI on the fly in the Middleware. Do we need to take it into account?\nSo, my proposal is SettingsService::getConfiguration.", "author": "grianbrcom", "createdAt": "2020-06-03T09:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1MTE3MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434451170", "bodyText": "for me sounds ok because the LSP server doesn't know anything about middleware, he just asked for some properties from settings and getConfiguration looks appropriate to me", "author": "zacanbrcom", "createdAt": "2020-06-03T09:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTY5Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434465692", "bodyText": "I agree, sounds good", "author": "temanbrcom", "createdAt": "2020-06-03T10:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434442937", "bodyText": "is result null-safe ?", "author": "asatklichov", "createdAt": "2020-06-03T09:44:01Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,117 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final ClientService clientService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+      DataBusBroker dataBus, ClientService clientService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.clientService = clientService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n   /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n    *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n-  @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      clientService\n+          .callClient(\"copybook\", cobolFileName, requiredCopybookName)\n+          .thenAccept(sendResponse(requiredCopybookName));\n     } else {\n-      publishOnDatabus(requiredCopybookName);\n+      sendResponse(requiredCopybookName, null, null);\n     }\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName, String content, Path path) {\n+  private Consumer<List<Object>> sendResponse(String requiredCopybookName) {\n+    return result -> dataBus.postData(fetchCopybook(requiredCopybookName, retrieveURI(result)));\n+  }\n+\n+  private void sendResponse(String requiredCopybookName, String content, Path path) {\n     dataBus.postData(\n         FetchedCopybookEvent.builder()\n             .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n+            .uri(toURI(path))\n             .content(content)\n             .build());\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName) {\n-    dataBus.postData(FetchedCopybookEvent.builder().name(requiredCopybookName).build());\n+  private FetchedCopybookEvent fetchCopybook(String requiredCopybookName, String uri) {\n+    if (uri.isEmpty()) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    Path file = files.getPathFromURI(uri);\n+    if (file == null) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    copybookPath.put(requiredCopybookName, file);\n+\n+    return FetchedCopybookEvent.builder()\n+        .name(requiredCopybookName)\n+        .uri(toURI(file))\n+        .content(files.getContentByPath(file))\n+        .build();\n+  }\n+\n+  private String toURI(Path file) {\n+    return ofNullable(file).map(Path::toUri).map(URI::toString).orElse(null);\n+  }\n+\n+  private String retrieveURI(List<Object> result) {\n+    return result.isEmpty() ? \"\" : ((JsonPrimitive) result.get(0)).getAsString();", "originalCommit": "6948538f01f06238c1de7b912f057d84122c6574", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NDUyOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434464529", "bodyText": "Good catch! So if LSP sends us NULL we will have null here.\nIt's not clear from LSP spec is it possible or not.", "author": "grianbrcom", "createdAt": "2020-06-03T10:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NjI5OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434466298", "bodyText": "It should not send null, but we also shouldn't trust the client", "author": "temanbrcom", "createdAt": "2020-06-03T10:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNzY2Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434517667", "bodyText": "I agree with Andrei, plus I think at initialize handshake server receives null", "author": "zacanbrcom", "createdAt": "2020-06-03T12:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTA5OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434465098", "bodyText": "Is DATASETS used?  If yes, we can still alphabetize.", "author": "asatklichov", "createdAt": "2020-06-03T10:23:35Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/SettingsParametersEnum.java", "diffHunk": "@@ -20,7 +20,9 @@\n  */\n public enum SettingsParametersEnum {\n   CPY_MANAGER(\"cpy-manager\"),\n-  LSP_PREFIX(\"broadcom-cobol-lsp\");\n+  LSP_PREFIX(\"broadcom-cobol-lsp\"),\n+  LOCAL_PATHS(\"cpy-manager.paths.local\"),\n+  DATASETS(\"cpy-manager.paths.dsn\");", "originalCommit": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NzQwNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434467406", "bodyText": "We don't use it on the server, but it is a value that we support on the client. I would prefer to leave it here to keep consistency.", "author": "temanbrcom", "createdAt": "2020-06-03T10:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2OTIwMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434469201", "bodyText": "Then let's alphabetize the enum-list", "author": "asatklichov", "createdAt": "2020-06-03T10:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDQ4NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434474485", "bodyText": "return null? Optional will help also get-rid off null-checks.", "author": "asatklichov", "createdAt": "2020-06-03T10:41:43Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;", "originalCommit": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDU4MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434474581", "bodyText": "same", "author": "asatklichov", "createdAt": "2020-06-03T10:41:54Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;", "originalCommit": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MDc0NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434640744", "bodyText": "There is a logic related to null, I don't want to refactor it now", "author": "temanbrcom", "createdAt": "2020-06-03T15:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434475890", "bodyText": "pattern should be in argument", "author": "asatklichov", "createdAt": "2020-06-03T10:44:34Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "originalCommit": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMTI4NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434521284", "bodyText": "What pattern? The dot?", "author": "temanbrcom", "createdAt": "2020-06-03T12:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTgzNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434531836", "bodyText": "What pattern? The dot?\n\nYes, what is searched.  e.g.  String searchTxt", "author": "asatklichov", "createdAt": "2020-06-03T12:34:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NDk3Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434564977", "bodyText": "Maybe it will be good to have a constant instead of an argument.", "author": "grianbrcom", "createdAt": "2020-06-03T13:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3Mzg0OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434573849", "bodyText": "Constant can be used during call to this method. My point is we need to make method reusable with any searchTxt", "author": "asatklichov", "createdAt": "2020-06-03T13:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjE1Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434592157", "bodyText": "I disagree. We have a specific logic here and it doesn't make sense to check with other patterns", "author": "temanbrcom", "createdAt": "2020-06-03T14:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5ODE4NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434598184", "bodyText": "hard-coded  search makes this method non re-usable", "author": "asatklichov", "createdAt": "2020-06-03T14:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}], "type": "inlineReview"}]}