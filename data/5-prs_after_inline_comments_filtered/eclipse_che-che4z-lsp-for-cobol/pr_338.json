{"pr_number": 338, "pr_title": "Introduce Extended Document Building and Replacing Statements Support", "pr_createdAt": "2020-05-11T08:57:34Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338", "timeline": [{"oid": "b9930e67f782f58f1403da47d2205e4da3a5efe9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b9930e67f782f58f1403da47d2205e4da3a5efe9", "message": "refactor: Prevent NPE if END-PERFORM missing on inline statements", "committedDate": "2020-07-17T16:55:08Z", "type": "commit"}, {"oid": "7debe578042136ce437281d67d5d385eafc1ec5a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7debe578042136ce437281d67d5d385eafc1ec5a", "message": "perf: Replace token string check with type check to speed it up", "committedDate": "2020-07-20T11:15:12Z", "type": "commit"}, {"oid": "daf96754548ca086e1368f669cfeaee78d45d837", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/daf96754548ca086e1368f669cfeaee78d45d837", "message": "refactor: Remove copy tags ambiguities to speed up processing", "committedDate": "2020-07-23T08:46:15Z", "type": "forcePushed"}, {"oid": "a3e1c7b57ba0ff5cebc4d8d9b74f268b3545a78b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a3e1c7b57ba0ff5cebc4d8d9b74f268b3545a78b", "message": "refactor: Make visitor work with pre-calculated mapping", "committedDate": "2020-07-24T20:27:49Z", "type": "forcePushed"}, {"oid": "8a4261d9d227faec7b4ad358610f1789f0f098cc", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8a4261d9d227faec7b4ad358610f1789f0f098cc", "message": "refactor: Make visitor work with pre-calculated mapping\nExtract initial positions and shifts of copy statement replacings in preprocessor and map  the tokens of main parser to them after syntax analysis.", "committedDate": "2020-07-27T09:29:58Z", "type": "forcePushed"}, {"oid": "03abd454e50232eda93d134dd4edb10ce93527b4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/03abd454e50232eda93d134dd4edb10ce93527b4", "message": "refactor: Make visitor work with pre-calculated mapping\nExtract initial positions and shifts of copy statement replacings in preprocessor and map  the tokens of main parser to them after syntax analysis.", "committedDate": "2020-07-27T13:34:57Z", "type": "forcePushed"}, {"oid": "ca1da876efc93291738f78037175d9db2d29f9c0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ca1da876efc93291738f78037175d9db2d29f9c0", "message": "refactor: Remove unused rules from preprocessor grammar", "committedDate": "2020-07-31T08:29:45Z", "type": "forcePushed"}, {"oid": "7329a64c3017fd19cbaa868905033d3e11ffc685", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7329a64c3017fd19cbaa868905033d3e11ffc685", "message": "test: Make test work with Junit 5", "committedDate": "2020-07-31T09:29:11Z", "type": "forcePushed"}, {"oid": "8fa00c50335f72456bc201b56341ccf9ddea09e6", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8fa00c50335f72456bc201b56341ccf9ddea09e6", "message": "feat: Syntax coloring support\n\nCloses #421\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-07-31T09:32:14Z", "type": "commit"}, {"oid": "29929be47f3b57b8998a9d7a4876097a50fcdfac", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/29929be47f3b57b8998a9d7a4876097a50fcdfac", "message": "feat: Show rulers in editor\n\nIn editor rulers shown on positions 7, 11, 72 and 80\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-07-31T09:32:14Z", "type": "commit"}, {"oid": "faa95950b4fccb6dba8893c62dfea329cd3f801f", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/faa95950b4fccb6dba8893c62dfea329cd3f801f", "message": "test: Make Use Case Engine work with unexpected symbols", "committedDate": "2020-07-31T09:32:14Z", "type": "commit"}, {"oid": "23e6e4345ca3bd4245e93c9b9922ca3e56fc760f", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/23e6e4345ca3bd4245e93c9b9922ca3e56fc760f", "message": "refactor: Make Cobol Parser process all the syntax errors", "committedDate": "2020-07-31T09:32:14Z", "type": "commit"}, {"oid": "7abf90e5f70e00a855e92bc8475fe8907f31ffff", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7abf90e5f70e00a855e92bc8475fe8907f31ffff", "message": "perf: Fix collecting unnecessary positions", "committedDate": "2020-07-31T09:32:15Z", "type": "commit"}, {"oid": "149b5d96d45183d0265fba00d284ef84a2d10e4c", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/149b5d96d45183d0265fba00d284ef84a2d10e4c", "message": "perf: Drop unnecesary text writing operations", "committedDate": "2020-07-31T09:32:27Z", "type": "commit"}, {"oid": "a1e42f6851b615205b409f19461b91b3c1abbd33", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a1e42f6851b615205b409f19461b91b3c1abbd33", "message": "perf: Remove copy tags ambiguities to speed up processing", "committedDate": "2020-07-31T09:32:35Z", "type": "commit"}, {"oid": "aec7c09025a67bb6082748ec34cde50f84734d3e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/aec7c09025a67bb6082748ec34cde50f84734d3e", "message": "test: Make log level for tests configurable", "committedDate": "2020-07-31T09:32:43Z", "type": "commit"}, {"oid": "c30ddcb02610d9b525eff0cc313d80c1553b4606", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c30ddcb02610d9b525eff0cc313d80c1553b4606", "message": "refactor: Fix closing copybook content after comment", "committedDate": "2020-07-31T09:32:43Z", "type": "commit"}, {"oid": "4ad572acc2e03b29c20b0707fa3367ffc317cc4d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4ad572acc2e03b29c20b0707fa3367ffc317cc4d", "message": "test: Make tests provide file name to simplify debug", "committedDate": "2020-07-31T09:32:43Z", "type": "commit"}, {"oid": "8fdd5ea3ca3fd291edb5df1a89a489dbca22abc9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8fdd5ea3ca3fd291edb5df1a89a489dbca22abc9", "message": "refactor: Make visitor work with pre-calculated mapping\nExtract initial positions and shifts of copy statement replacings in preprocessor and map  the tokens of main parser to them after syntax analysis.", "committedDate": "2020-07-31T09:32:43Z", "type": "commit"}, {"oid": "9e388bcf0654da03d25f2e4e0b6936b3d6077d8a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9e388bcf0654da03d25f2e4e0b6936b3d6077d8a", "message": "refactor: Extract PIC preprocessor grammar to support PIC clauses\nSeparate lexer gramamar required to split PIC clauses by tokens correctly to simplify the mapping of positions.", "committedDate": "2020-07-31T09:32:43Z", "type": "commit"}, {"oid": "adc160a09c7665b4d30c4d68e83336751504a07b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/adc160a09c7665b4d30c4d68e83336751504a07b", "message": "build: Migration to jUnit5 #432\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>", "committedDate": "2020-07-31T09:32:59Z", "type": "commit"}, {"oid": "d0218c4173102138bb0951de9864f5e8aea0e9f6", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d0218c4173102138bb0951de9864f5e8aea0e9f6", "message": "test: Skip postive tests if filesToTestPath is not provided\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>", "committedDate": "2020-07-31T09:34:54Z", "type": "commit"}, {"oid": "92c0c93e9c7dd455a163a9a81904d068a3ab962b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/92c0c93e9c7dd455a163a9a81904d068a3ab962b", "message": "perf: Move EXEC statements processing to parser", "committedDate": "2020-07-31T09:34:54Z", "type": "commit"}, {"oid": "d3d44049fc9b534046c0d3b1efe42db4ef02b26c", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d3d44049fc9b534046c0d3b1efe42db4ef02b26c", "message": "perf: Adjust copybook position shifts on mapping", "committedDate": "2020-07-31T09:35:02Z", "type": "commit"}, {"oid": "01460430d83e72c76e1fc2954f403049910b2b9b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/01460430d83e72c76e1fc2954f403049910b2b9b", "message": "refactor: Move EJECT statement to the parser to simplify mapping", "committedDate": "2020-07-31T09:35:11Z", "type": "commit"}, {"oid": "5a9b005484a7d39cec3cb64a08ab6420b3fc6e40", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5a9b005484a7d39cec3cb64a08ab6420b3fc6e40", "message": "perf: Remove unused rules from preprocessor grammar", "committedDate": "2020-07-31T09:35:11Z", "type": "commit"}, {"oid": "c6f73bf87e7646dbeb4c8af506ccfb9ea05951da", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c6f73bf87e7646dbeb4c8af506ccfb9ea05951da", "message": "style: Remove resolved TODOs", "committedDate": "2020-07-31T09:35:19Z", "type": "commit"}, {"oid": "ccfef0d77d343552c70c83134baafb4daf8d568b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ccfef0d77d343552c70c83134baafb4daf8d568b", "message": "test: Remove obsolete test suites", "committedDate": "2020-07-31T09:35:39Z", "type": "commit"}, {"oid": "6d3a10dcd533da92414803ce716f74a0ae8cab2d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6d3a10dcd533da92414803ce716f74a0ae8cab2d", "message": "test: Make test work with Junit 5", "committedDate": "2020-07-31T09:35:39Z", "type": "commit"}, {"oid": "6d3a10dcd533da92414803ce716f74a0ae8cab2d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6d3a10dcd533da92414803ce716f74a0ae8cab2d", "message": "test: Make test work with Junit 5", "committedDate": "2020-07-31T09:35:39Z", "type": "forcePushed"}, {"oid": "3960ce70a55667d80ca87e2f99b3a4a4a5316ac9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3960ce70a55667d80ca87e2f99b3a4a4a5316ac9", "message": "refactor: Remove obsolete preprocessor cleaning delegate", "committedDate": "2020-07-31T09:53:08Z", "type": "commit"}, {"oid": "c97770d1275f7fdefd2eda796290244137cb8764", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c97770d1275f7fdefd2eda796290244137cb8764", "message": "perf: Add position shifts for compiler directives", "committedDate": "2020-07-31T12:28:45Z", "type": "commit"}, {"oid": "a9188f6be77ce007d9084cdbf4313fe0cfd09916", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a9188f6be77ce007d9084cdbf4313fe0cfd09916", "message": "test: Fix mock to avoid NPE on build", "committedDate": "2020-07-31T12:35:50Z", "type": "commit"}, {"oid": "ad0c2df53496fb7385ed4a520b92d1c6fbd756f7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ad0c2df53496fb7385ed4a520b92d1c6fbd756f7", "message": "refactor: Clean-up mapping classes", "committedDate": "2020-07-31T15:25:53Z", "type": "commit"}, {"oid": "0371c116ce647f7a138016f1c07ceff3afdb38e7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0371c116ce647f7a138016f1c07ceff3afdb38e7", "message": "Merge branch 'development' into mapping", "committedDate": "2020-08-03T13:54:15Z", "type": "commit"}, {"oid": "cb85d853f311cfe4ede365f963583ccb056faa3e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cb85d853f311cfe4ede365f963583ccb056faa3e", "message": "test: Remove public declarations from tests as a part of JUnit 5 migration", "committedDate": "2020-08-03T16:41:44Z", "type": "commit"}, {"oid": "cb85d853f311cfe4ede365f963583ccb056faa3e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cb85d853f311cfe4ede365f963583ccb056faa3e", "message": "test: Remove public declarations from tests as a part of JUnit 5 migration", "committedDate": "2020-08-03T16:41:44Z", "type": "forcePushed"}, {"oid": "998ca192c6d6156ed0316a2fae5d5d8cbb8dda42", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/998ca192c6d6156ed0316a2fae5d5d8cbb8dda42", "message": "ci: Set Java language level to 11 for SonarCloud", "committedDate": "2020-08-04T08:53:06Z", "type": "forcePushed"}, {"oid": "cb85d853f311cfe4ede365f963583ccb056faa3e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cb85d853f311cfe4ede365f963583ccb056faa3e", "message": "test: Remove public declarations from tests as a part of JUnit 5 migration", "committedDate": "2020-08-03T16:41:44Z", "type": "forcePushed"}, {"oid": "29f19e526ad739c2cc0c582b80a183061af73bb6", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/29f19e526ad739c2cc0c582b80a183061af73bb6", "message": "test: Cover PositionMappingUtils with unit test", "committedDate": "2020-08-04T12:34:52Z", "type": "commit"}, {"oid": "c9234ba2b44816ef361ae5ab5c2278426a0bb97d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c9234ba2b44816ef361ae5ab5c2278426a0bb97d", "message": "refactor: Skip null positions on the visitor to avoid exceptions", "committedDate": "2020-08-04T12:35:45Z", "type": "commit"}, {"oid": "2158bbed28673ea1a5f293bdb0886bea150f15ea", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2158bbed28673ea1a5f293bdb0886bea150f15ea", "message": "refactor: Change CobolVisitor API to simplify testng", "committedDate": "2020-08-04T12:51:54Z", "type": "commit"}, {"oid": "168303b96bf7b309e7da850ec26d7b13a9f28d84", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/168303b96bf7b309e7da850ec26d7b13a9f28d84", "message": "test: Cover CobolLanguageEngine with unit test", "committedDate": "2020-08-04T13:38:35Z", "type": "commit"}, {"oid": "ffa280f6b3c4b24b807bba1a8c26cac3df35f7da", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ffa280f6b3c4b24b807bba1a8c26cac3df35f7da", "message": "refactor: Log syntax errors immediately to simlify debugging #342", "committedDate": "2020-08-04T15:23:58Z", "type": "commit"}, {"oid": "043f05acecd305b0fe26f4ef8e05988ef6573335", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/043f05acecd305b0fe26f4ef8e05988ef6573335", "message": "refactor: Group alternatives with anchors in regex", "committedDate": "2020-08-04T15:47:43Z", "type": "commit"}, {"oid": "2de5916655829f6a72c22cce52fc62c2fc7c63c7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2de5916655829f6a72c22cce52fc62c2fc7c63c7", "message": "refactor: Decrease log level of copybook resolution error to avoid unnecessary logging on production", "committedDate": "2020-08-04T16:08:12Z", "type": "commit"}, {"oid": "57094634b328bf55744dd8a87460857e7d5284ed", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/57094634b328bf55744dd8a87460857e7d5284ed", "message": "test: Introduce test coverage for GrammarPreprocessorListenerImpl", "committedDate": "2020-08-05T15:09:32Z", "type": "commit"}, {"oid": "c5260076fb66b30bdef759d0e83f848ed3c8402c", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c5260076fb66b30bdef759d0e83f848ed3c8402c", "message": "fix: Allow keyword as a copybook name #304", "committedDate": "2020-08-06T12:23:41Z", "type": "commit"}, {"oid": "90301f0152f6051444308702b8737cd8863d50d0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/90301f0152f6051444308702b8737cd8863d50d0", "message": "refactor: Make REPLACING accept everything in pseudo-text pattern", "committedDate": "2020-08-07T14:52:30Z", "type": "commit"}, {"oid": "90301f0152f6051444308702b8737cd8863d50d0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/90301f0152f6051444308702b8737cd8863d50d0", "message": "refactor: Make REPLACING accept everything in pseudo-text pattern", "committedDate": "2020-08-07T14:52:30Z", "type": "forcePushed"}, {"oid": "1e953fa974a582ccd26a082a0fe59cb47863a7d8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1e953fa974a582ccd26a082a0fe59cb47863a7d8", "message": "Merge branch 'development' into mapping", "committedDate": "2020-08-07T14:57:21Z", "type": "commit"}, {"oid": "22c29fff10b95e6ba577040abe6053d04fbed142", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/22c29fff10b95e6ba577040abe6053d04fbed142", "message": "refactor: Extract error message as a constant", "committedDate": "2020-08-10T14:47:06Z", "type": "commit"}, {"oid": "36bda6abc1e1b8eb0330d975ba044096249d528a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/36bda6abc1e1b8eb0330d975ba044096249d528a", "message": "feat: Underline the entire incorrect variable structure #321", "committedDate": "2020-08-10T15:04:22Z", "type": "commit"}, {"oid": "1d06306127a169064db80eb372f20262087d61c0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1d06306127a169064db80eb372f20262087d61c0", "message": "Merge branch 'development' into mapping", "committedDate": "2020-08-10T16:24:34Z", "type": "commit"}, {"oid": "7f0559923fe2977b23a4b27459b916fff8375225", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7f0559923fe2977b23a4b27459b916fff8375225", "message": "style: Use general return for copybook resolution as a best practice", "committedDate": "2020-08-11T09:50:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMzQxNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468523415", "bodyText": "You could use Map::getOrDefault here and in the initialForward methods.", "author": "grianbrcom", "createdAt": "2020-08-11T11:54:24Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/model/DocumentHierarchyLevel.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.model;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Optional.ofNullable;\n+\n+public class DocumentHierarchyLevel {\n+  private int index;\n+  private List<Position> positions;\n+  private Map<Integer, Integer> shifts;\n+\n+  public DocumentHierarchyLevel(DocumentMapping documentMapping) {\n+    index = 0;\n+    positions = documentMapping.getPositions();\n+    shifts = documentMapping.getShifts();\n+    initialForward();\n+  }\n+\n+  public Position getCurrent() {\n+    return index < positions.size() ? positions.get(index) : null;\n+  }\n+\n+  public void forward() {\n+    index += ofNullable(shifts.get(index)).orElse(1);", "originalCommit": "7f0559923fe2977b23a4b27459b916fff8375225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0MjI4NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468642285", "bodyText": "That's true, I will do it", "author": "temanbrcom", "createdAt": "2020-08-11T14:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMzQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMjQ4MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468532480", "bodyText": "We need to think about watchdog here to handle look ahead infinity loop. It could be a feature for future implementation.", "author": "grianbrcom", "createdAt": "2020-08-11T12:11:13Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PositionMappingUtils.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.DocumentHierarchyLevel;\n+import com.ca.lsp.core.cobol.model.DocumentMapping;\n+import lombok.experimental.UtilityClass;\n+import org.antlr.v4.runtime.Token;\n+\n+import javax.annotation.Nonnull;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYENTRY;\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYEXIT;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class maps positions of extended document to the original ones.\n+ *\n+ * <p>Preprocessor may internally change the content of the processing document, so the resulting\n+ * positions of syntax and semantic analysis won't match the user expectations. In order to avoid\n+ * it, the tokens provided by {@link com.ca.lsp.core.cobol.parser.CobolLexer} should be compared\n+ * with ones provided by {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorLexer}. The comparison\n+ * applied by string equity.\n+ */\n+@UtilityClass\n+public class PositionMappingUtils {\n+\n+  private static final int URI_PREFIX_LENGTH = CPY_ENTER_TAG.length() + CPY_URI_OPEN.length();\n+  private static final int URI_SUFFIX_LENGTH = CPY_URI_CLOSE.length();\n+\n+  /**\n+   * Map the tokens of the extended document to original ones using document mapping, collected by\n+   * {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorListener}.\n+   *\n+   * @param tokens - tokens of extended documents, provided by {@link\n+   *     com.ca.lsp.core.cobol.parser.CobolLexer}\n+   * @param documentPositions - initial document and copybooks positions\n+   * @param documentUri - URI of the current document\n+   * @return map of tokens and original positions.\n+   */\n+  public Map<Token, Position> createPositionMapping(\n+      List<Token> tokens, Map<String, DocumentMapping> documentPositions, String documentUri) {\n+    Map<Token, Position> result = new HashMap<>();\n+    Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+    enterDocument(documentUri, documentPositions, documentHierarchyStack);\n+    tokens.forEach(mapToken(documentPositions, result, documentHierarchyStack));\n+    return result;\n+  }\n+\n+  private Consumer<Token> mapToken(\n+      Map<String, DocumentMapping> documentPositions,\n+      Map<Token, Position> result,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    return token -> {\n+      if (token.getType() == COPYENTRY) {\n+        enterDocument(\n+            extractCopybookName(token.getText()), documentPositions, documentHierarchyStack);\n+      } else if (token.getType() == COPYEXIT) {\n+        exitDocument(documentHierarchyStack);\n+      } else {\n+        mapTokenToPosition(token, result, documentHierarchyStack);\n+      }\n+    };\n+  }\n+\n+  private void mapTokenToPosition(\n+      Token token,\n+      Map<Token, Position> mappingAccumulator,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    Position position = currentDocument(documentHierarchyStack).getCurrent();\n+    if (position == null) return;\n+    if (tokenMatches(token.getText(), position.getToken())) {\n+      mappingAccumulator.put(token, position);\n+      currentDocument(documentHierarchyStack).forward();\n+    } else {\n+      applyLookAhead(token, mappingAccumulator, documentHierarchyStack);", "originalCommit": "7f0559923fe2977b23a4b27459b916fff8375225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyOTE2MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468629161", "bodyText": "I don't think an infinity loop may appear here: if the token not mapped, it is skipped", "author": "temanbrcom", "createdAt": "2020-08-11T14:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMjQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzg3Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468537877", "bodyText": "Are you sure about that? Never seen formatting string with groups like (? ... )\nOr maybe you use the result inside the Antlr engine?", "author": "grianbrcom", "createdAt": "2020-08-11T12:21:12Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/ReplacingServiceImpl.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceClauseContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplacePseudoTextContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceSameElementContext;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceliteralContext;\n+import static java.lang.String.format;\n+import static java.util.Arrays.stream;\n+import static java.util.Optional.ofNullable;\n+import static java.util.regex.Matcher.quoteReplacement;\n+import static java.util.stream.Collectors.joining;\n+import static org.apache.commons.lang3.StringUtils.split;\n+\n+/**\n+ * This service applies replacing for given text by replace clauses and tokens. It may work with\n+ * REPLACING and REPLACE statements.\n+ */\n+@Singleton\n+public class ReplacingServiceImpl implements ReplacingService {\n+  /**\n+   * Look-before and look-ahead pattern to check that the token wrapped with separators, i.e.\n+   * whitespaces, dots ot line breaks. Not includes separators to the found substring.\n+   */\n+  private static final String SEPARATE_TOKEN_PATTERN = \"(?<=[\\\\.\\\\s\\\\r\\\\n])%s(?=[\\\\.\\\\s\\\\r\\\\n])\";", "originalCommit": "7f0559923fe2977b23a4b27459b916fff8375225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYxNzAwOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468617008", "bodyText": "It is to require, but not include some value into the matching pattern", "author": "temanbrcom", "createdAt": "2020-08-11T14:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzg3Nw=="}], "type": "inlineReview"}, {"oid": "6363a22a01d3b00cc6cc989371483052f34ebd21", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6363a22a01d3b00cc6cc989371483052f34ebd21", "message": "refactor: Decrease visibility of DocumentHierarchyLevel and provide Javadocs", "committedDate": "2020-08-11T15:05:11Z", "type": "commit"}, {"oid": "363fd7be9400050f828fec198858cb27d484486e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/363fd7be9400050f828fec198858cb27d484486e", "message": "refactor: Remove unused grammar listener nodes from preporcessor", "committedDate": "2020-08-12T14:03:08Z", "type": "commit"}, {"oid": "7e33ca760bc50e135aece08c84184d6a9da1833d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7e33ca760bc50e135aece08c84184d6a9da1833d", "message": "test: Add unit test coverage for all the copybook processing cases", "committedDate": "2020-08-12T14:31:45Z", "type": "commit"}, {"oid": "33fb92ad466276f768385f5d48ae7e93394d71b1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/33fb92ad466276f768385f5d48ae7e93394d71b1", "message": "refactor: Remove redundand REPLACE OFF processing", "committedDate": "2020-08-13T16:58:28Z", "type": "commit"}, {"oid": "ae810f0a0768d1d02c2e1da1221944350e66c34f", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ae810f0a0768d1d02c2e1da1221944350e66c34f", "message": "Merge branch 'development' into mapping", "committedDate": "2020-08-14T09:01:02Z", "type": "commit"}, {"oid": "98c6b8b2c56d04ed2153da2bf756fa530ed55701", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/98c6b8b2c56d04ed2153da2bf756fa530ed55701", "message": "docs: Update readme and changelog for REPLACING etc.", "committedDate": "2020-08-14T11:12:12Z", "type": "commit"}, {"oid": "7218af23ce90fe431f4117be815051c480a78540", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7218af23ce90fe431f4117be815051c480a78540", "message": "refactor: Prevent index exception on replacing", "committedDate": "2020-08-14T16:42:48Z", "type": "commit"}, {"oid": "ba0b3191760f86c4e57b45587c00c8b74fbb2aef", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ba0b3191760f86c4e57b45587c00c8b74fbb2aef", "message": "test: Add test coverage for ReplacingServiceImpl", "committedDate": "2020-08-14T16:43:19Z", "type": "commit"}, {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7d8eecf03fed651573eabfac80f249865c7fe741", "message": "refactor: Make preprocessor grammar less eager to validate pseudo-text replacing correctly", "committedDate": "2020-08-17T11:39:57Z", "type": "commit"}, {"oid": "5a89002df6587955c953ec002998f2bf98b5a57b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5a89002df6587955c953ec002998f2bf98b5a57b", "message": "feat: Introduce replacing support GH-335\nAdd capability to replace copybook content by the pattern provided in a REPLACING statement.\nIntroduce synchronous building for the extend document.\nRemove deprecated async copybook processing.", "committedDate": "2020-05-06T10:42:09Z", "type": "commit"}, {"oid": "a54d1879e1a2fa811c7471084ac2f55547f2f5a8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a54d1879e1a2fa811c7471084ac2f55547f2f5a8", "message": "perf: Move document cleaning to cobol preprocessor GH-220", "committedDate": "2020-05-06T11:52:19Z", "type": "commit"}, {"oid": "d3dfa8868d86e89779e5536d9590eecb6903036a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d3dfa8868d86e89779e5536d9590eecb6903036a", "message": "perf: Move exec statements to Preprocessor GH-220", "committedDate": "2020-05-06T11:52:32Z", "type": "commit"}, {"oid": "da1102682c28e6410e15fa783f527798862d4ca4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/da1102682c28e6410e15fa783f527798862d4ca4", "message": "perf: Remove separate cleaner on preprocessor stage GH-220", "committedDate": "2020-05-06T11:52:50Z", "type": "commit"}, {"oid": "2f1566e08782b59cf2f795d99db726018ff9a304", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2f1566e08782b59cf2f795d99db726018ff9a304", "message": "perf: Remove deprecated parallel copybooks processing infrastructure GH-220", "committedDate": "2020-05-06T11:52:50Z", "type": "commit"}, {"oid": "cfe38659609d772d0f687d12e6549916185d899a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cfe38659609d772d0f687d12e6549916185d899a", "message": "refactor: Fix variable structure building GH-220\nMake it work with the extended document.", "committedDate": "2020-05-06T11:55:01Z", "type": "commit"}, {"oid": "08c9ac856e5ea4ede08110c6ea512b32ee6fae30", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/08c9ac856e5ea4ede08110c6ea512b32ee6fae30", "message": "test: Improve functional coverage of use cases GH-23", "committedDate": "2020-05-06T11:56:18Z", "type": "commit"}, {"oid": "1f1596361c32d6a69ce28cee760ca55635469116", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1f1596361c32d6a69ce28cee760ca55635469116", "message": "perf: Remove unnecessary preprocessor grammar rules GH-220", "committedDate": "2020-05-06T12:01:30Z", "type": "commit"}, {"oid": "6250c8a4bf8a5a3801676648368c3fc92721b783", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6250c8a4bf8a5a3801676648368c3fc92721b783", "message": "perf: Remove redudant cleaner grammar GH-220", "committedDate": "2020-05-06T12:02:19Z", "type": "commit"}, {"oid": "2cd70fbc3c0500c641e5ef7152c54d231180a669", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2cd70fbc3c0500c641e5ef7152c54d231180a669", "message": "refactor: Allow variable structure rebuild on each change GH-220", "committedDate": "2020-05-06T12:02:19Z", "type": "commit"}, {"oid": "5918ba72edd6ac9e54301690c41f7fb6bcf0c243", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5918ba72edd6ac9e54301690c41f7fb6bcf0c243", "message": "refactor: Collect initial postions on preprocessor GH-220\nInitial positons needed to build mapping between extended and original document.", "committedDate": "2020-05-06T12:04:40Z", "type": "commit"}, {"oid": "8a3cde8df7ffbf7028bc03050ba922e8d957e1b7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8a3cde8df7ffbf7028bc03050ba922e8d957e1b7", "message": "refactor: Add copybooks entry/exit marker GH-220", "committedDate": "2020-05-06T12:07:52Z", "type": "commit"}, {"oid": "9132ee74a296a58c3cc5f1fdd95ac009ba5e974e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9132ee74a296a58c3cc5f1fdd95ac009ba5e974e", "message": "refactor: Introduce stack-based position calculation GH-220\nUse the Preprocessor to collect the initial document positions before expansions and copybook deltas (the difference between copybook definition and copybook size).\nUse a stack inside the Visitor to track the currently processing document hierarchy level. Calculate current token index shift based on accumulated deltas of the current stack head.\nLocate positions by token names.", "committedDate": "2020-05-06T12:10:06Z", "type": "commit"}, {"oid": "2a73c38ef05a67ee856f2604784196b16b4b9bd3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a73c38ef05a67ee856f2604784196b16b4b9bd3", "message": "fix: Make variable usage processing left-to-right GH-220\nRight-to-to-left processing order for usages of structured variables may cause errors in position retrieving.\nThe reason is that in this case variable to the right shifts the current processing index too far and the position of the variable to the left is lost.", "committedDate": "2020-05-06T12:10:22Z", "type": "commit"}, {"oid": "12439a83abc1ed52515830168b2a621c9db25136", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/12439a83abc1ed52515830168b2a621c9db25136", "message": "test: Adjust tests to the extended document building GH-220", "committedDate": "2020-05-06T12:10:22Z", "type": "commit"}, {"oid": "fa0db94c2366d55086a675cb603cbac4a523aa1b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fa0db94c2366d55086a675cb603cbac4a523aa1b", "message": "feat: Introduce full document syntax analysis GH-220\nBuild an the extended document by replacing copy statements with copybook content.\nRetrieve postions from the initial documents to map token positions from the extended document to the original ones.\nCollect the tokens of syntax errors found by the Parser grammar, semantic errors found by the CobolVisitor and the semantic elements positions and usages, and map them to the previosly collected initial positions.\nRemove duplicated children visiting in the Visitor.", "committedDate": "2020-05-06T12:10:22Z", "type": "commit"}, {"oid": "b601672b357ca3290c0c7ffe69a5231c836366f1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b601672b357ca3290c0c7ffe69a5231c836366f1", "message": "Merge branch 'development' into mapping", "committedDate": "2020-05-06T16:31:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0MTA5OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423141098", "bodyText": "To be refactored in #342", "author": "temanbrcom", "createdAt": "2020-05-11T15:52:48Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));", "originalCommit": "4482b739663663c61d6f040812ed278d8b08ba4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0MzU5NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423143595", "bodyText": "The logic of calling this method is going to be changed in #340", "author": "temanbrcom", "createdAt": "2020-05-11T15:56:22Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {", "originalCommit": "4482b739663663c61d6f040812ed278d8b08ba4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0Mzg2Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423143862", "bodyText": "To be used in #339", "author": "temanbrcom", "createdAt": "2020-05-11T15:56:46Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitStatement(StatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfThen(IfThenContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfElse(IfElseContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitPerformInlineStatement(PerformInlineStatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitSentence(SentenceContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIdentifier(IdentifierContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitEvaluateWhenOther(EvaluateWhenOtherContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n-  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n-    if (ctx.dataName() != null) {\n-      String variable = ctx.dataName().getText().toUpperCase();\n-      checkForVariable(\n-          variable,\n-          ctx.getStart().getLine(),\n-          ctx.dataName().getStart().getCharPositionInLine(),\n-          ctx);\n-    }\n+  public Class visitParagraphName(ParagraphNameContext ctx) {\n+    paragraphs.define(ctx.getText().toUpperCase(), ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  public Class visitDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (checkForVariable(\n-        ctx.getText(), ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine(), null)) {\n-      checkParentContainsChildren(ctx.getText(), child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitDataDescriptionEntryFormat1(DataDescriptionEntryFormat1Context ctx) {\n+\n+    String levelNumber = ctx.otherLevel().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInData(\n-      String child, int childStartLine, int childPositionInLine, InDataContext ctx) {\n-    checkForDataName2(ctx.dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat2(DataDescriptionEntryFormat2Context ctx) {\n+\n+    String levelNumber = ctx.LEVEL_NUMBER_66().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInTable(\n-      String child, int childStartLine, int childPositionInLine, InTableContext ctx) {\n-    checkForDataName2(ctx.tableCall().dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat3(DataDescriptionEntryFormat3Context ctx) {\n+    String levelNumber = ctx.LEVEL_NUMBER_88().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n+  private void defineVariable(String level, String name, Token token) {\n+    variables.define(new Variable(level, name), token);\n+  }\n+\n   @Override\n   public Class visitParagraphNameUsage(ParagraphNameUsageContext ctx) {\n-    addUsage(semanticContext.getParagraphs(), ctx);\n+    String name = ctx.getText().toUpperCase();\n+    addUsage(paragraphs, name, ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  private void checkForDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (ctx != null) {\n-      visitDataName2(ctx, child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n+    ofNullable(ctx.dataName())\n+        .map(it -> it.getText().toUpperCase())\n+        .ifPresent(variable -> checkForVariable(variable, ctx));\n+    return visitChildren(ctx);\n   }\n \n-  private void throwWarning(String wrongToken, int startLine, int charPositionInLine) {\n-    MisspelledKeywordDistance.calculateDistance(wrongToken.toUpperCase())\n-        .ifPresent(\n-            correctWord ->\n-                getSemanticError(wrongToken, startLine, charPositionInLine, correctWord));\n-  }\n+  @Override\n+  public Class visitTerminal(TerminalNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n \n-  private void throwSuggestion(String wrongToken, int startLine, int charPositionInLine) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"Invalid definition for: \" + wrongToken)\n-            .severity(INFO_LEVEL)\n-            .build());\n+    return super.visitTerminal(node);\n   }\n \n-  private void getSemanticError(\n-      String wrongToken, int startLine, int charPositionInLine, String correctWord) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"A misspelled word, maybe you want to put \" + correctWord)\n-            .severity(WARNING_LEVEL)\n-            .build());\n+  @Override\n+  public Class visitErrorNode(ErrorNode node) {", "originalCommit": "4482b739663663c61d6f040812ed278d8b08ba4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "message": "refactor: Add caching for copybooks on preprocessor #220", "committedDate": "2020-05-12T09:50:24Z", "type": "commit"}, {"oid": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "message": "refactor: Add caching for copybooks on preprocessor #220", "committedDate": "2020-05-12T09:50:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzIwNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r424257205", "bodyText": "This may throw similar semantic errors for different reasons. To be fixed in #321", "author": "temanbrcom", "createdAt": "2020-05-13T08:19:13Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitStatement(StatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfThen(IfThenContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfElse(IfElseContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitPerformInlineStatement(PerformInlineStatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitSentence(SentenceContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIdentifier(IdentifierContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitEvaluateWhenOther(EvaluateWhenOtherContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n-  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n-    if (ctx.dataName() != null) {\n-      String variable = ctx.dataName().getText().toUpperCase();\n-      checkForVariable(\n-          variable,\n-          ctx.getStart().getLine(),\n-          ctx.dataName().getStart().getCharPositionInLine(),\n-          ctx);\n-    }\n+  public Class visitParagraphName(ParagraphNameContext ctx) {\n+    paragraphs.define(ctx.getText().toUpperCase(), ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  public Class visitDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (checkForVariable(\n-        ctx.getText(), ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine(), null)) {\n-      checkParentContainsChildren(ctx.getText(), child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitDataDescriptionEntryFormat1(DataDescriptionEntryFormat1Context ctx) {\n+\n+    String levelNumber = ctx.otherLevel().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInData(\n-      String child, int childStartLine, int childPositionInLine, InDataContext ctx) {\n-    checkForDataName2(ctx.dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat2(DataDescriptionEntryFormat2Context ctx) {\n+\n+    String levelNumber = ctx.LEVEL_NUMBER_66().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInTable(\n-      String child, int childStartLine, int childPositionInLine, InTableContext ctx) {\n-    checkForDataName2(ctx.tableCall().dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat3(DataDescriptionEntryFormat3Context ctx) {\n+    String levelNumber = ctx.LEVEL_NUMBER_88().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n+  private void defineVariable(String level, String name, Token token) {\n+    variables.define(new Variable(level, name), token);\n+  }\n+\n   @Override\n   public Class visitParagraphNameUsage(ParagraphNameUsageContext ctx) {\n-    addUsage(semanticContext.getParagraphs(), ctx);\n+    String name = ctx.getText().toUpperCase();\n+    addUsage(paragraphs, name, ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  private void checkForDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (ctx != null) {\n-      visitDataName2(ctx, child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n+    ofNullable(ctx.dataName())\n+        .map(it -> it.getText().toUpperCase())\n+        .ifPresent(variable -> checkForVariable(variable, ctx));\n+    return visitChildren(ctx);\n   }\n \n-  private void throwWarning(String wrongToken, int startLine, int charPositionInLine) {\n-    MisspelledKeywordDistance.calculateDistance(wrongToken.toUpperCase())\n-        .ifPresent(\n-            correctWord ->\n-                getSemanticError(wrongToken, startLine, charPositionInLine, correctWord));\n-  }\n+  @Override\n+  public Class visitTerminal(TerminalNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n \n-  private void throwSuggestion(String wrongToken, int startLine, int charPositionInLine) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"Invalid definition for: \" + wrongToken)\n-            .severity(INFO_LEVEL)\n-            .build());\n+    return super.visitTerminal(node);\n   }\n \n-  private void getSemanticError(\n-      String wrongToken, int startLine, int charPositionInLine, String correctWord) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"A misspelled word, maybe you want to put \" + correctWord)\n-            .severity(WARNING_LEVEL)\n-            .build());\n+  @Override\n+  public Class visitErrorNode(ErrorNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n+\n+    return super.visitTerminal(node);\n   }\n \n-  private boolean checkForVariable(\n-      String variable, int startLine, int charPositionInLine, ParserRuleContext ctx) {\n-    if (!semanticContext.getVariables().contains(variable)) {\n-      throwSuggestion(variable, startLine, charPositionInLine);\n-      return false;\n-    } else if (ctx instanceof QualifiedDataNameFormat1Context\n-        && ((QualifiedDataNameFormat1Context) ctx).qualifiedInData() != null) {\n-      iterateOverQualifiedDataNames(\n-          (QualifiedDataNameFormat1Context) ctx, variable, startLine, charPositionInLine);\n-      addUsage(semanticContext.getVariables(), variable, ctx);\n+  private void checkForVariable(String variable, QualifiedDataNameFormat1Context ctx) {\n+    checkVariableDefinition(variable, ctx.getStart());\n+    addUsage(variables, variable, ctx.getStart());\n+\n+    if (ctx.qualifiedInData() != null) {\n+      iterateOverQualifiedDataNames(ctx, variable);\n     }\n-    return true;\n   }\n \n-  private void iterateOverQualifiedDataNames(\n-      QualifiedDataNameFormat1Context ctx, String variable, int startLine, int charPositionInLine) {\n+  private void iterateOverQualifiedDataNames(QualifiedDataNameFormat1Context ctx, String variable) {\n+    String child = variable;\n+    Token childToken = ctx.getStart();\n     for (QualifiedInDataContext node : ctx.qualifiedInData()) {\n-      if (node.inData() != null) {\n-        visitInData(variable, startLine, charPositionInLine, node.inData());\n-        DataName2Context context = node.inData().dataName2();\n-        variable = context.getText();\n-        addUsage(semanticContext.getVariables(), context);\n-      } else {\n-        visitInTable(variable, startLine, charPositionInLine, node.inTable());\n-        DataName2Context context = node.inTable().tableCall().dataName2();\n-        variable = context.getText();\n-        addUsage(semanticContext.getVariables(), context);\n-      }\n+\n+      DataName2Context context = getDataName2Context(node);\n+      String parent = context.getText().toUpperCase();\n+      Token parentToken = context.getStart();\n+\n+      checkVariableDefinition(parent, parentToken);\n+      checkVariableStructure(parent, child, childToken);", "originalCommit": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86a8ba02a349f03403100796dac7b401d9b705e7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/86a8ba02a349f03403100796dac7b401d9b705e7", "message": "refactor: Make CPY tags work with URIs #220", "committedDate": "2020-05-13T11:38:27Z", "type": "commit"}, {"oid": "60c0734c5e4335c72b7767c574e59082f4f77bd9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/60c0734c5e4335c72b7767c574e59082f4f77bd9", "message": "Merge branch 'development' into mapping", "committedDate": "2020-05-13T13:00:06Z", "type": "commit"}, {"oid": "f6266e5221c343270be3fddaa79748c525536272", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f6266e5221c343270be3fddaa79748c525536272", "message": "Merge branch 'development' into mapping", "committedDate": "2020-06-05T09:38:36Z", "type": "commit"}, {"oid": "537aee56929b078633a15ad75aaa3c9fec855e65", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/537aee56929b078633a15ad75aaa3c9fec855e65", "message": "Merge branch 'development' into mapping", "committedDate": "2020-06-08T13:06:59Z", "type": "commit"}, {"oid": "4fc5ab4c5119fb1dfb29af11df39b19a4f5f6504", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4fc5ab4c5119fb1dfb29af11df39b19a4f5f6504", "message": "feat: Introduce Go To Definition for copybooks #387", "committedDate": "2020-06-10T14:56:04Z", "type": "commit"}, {"oid": "72f3cfecdaaeca9b896b411f7f0b163097a0f793", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/72f3cfecdaaeca9b896b411f7f0b163097a0f793", "message": "feat: Show syntax and semantic errors in copybooks GH-351\nSend errors found in the extended document to the related files in correct postitions.", "committedDate": "2020-06-11T09:21:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4Mzc0MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r439483741", "bodyText": "Don't ask, I know it is disgusting. To be rewritten later.", "author": "temanbrcom", "createdAt": "2020-06-12T15:19:49Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/strategy/CobolErrorStrategy.java", "diffHunk": "@@ -84,12 +77,32 @@ public void reportError(Parser recognizer, RecognitionException e) {\n     }\n   }\n \n+  @Override\n+  public void sync(Parser recognizer) {\n+    Token currentToken = recognizer.getCurrentToken();\n+    String terminal = currentToken.getText();\n+    // If the processing stopped at the copybook enter tag and cannot be recovered in place, it\n+    // means that there are, in fact, two affected tokens\n+    if (terminal.startsWith(\"*>CPYENTER\")) {\n+      int nextTokenType = recognizer.getInputStream().LA(3);\n+      IntervalSet expecting = getExpectedTokens(recognizer);\n+      if (expecting.contains(nextTokenType)) {\n+        // Move processing forward two times\n+        recognizer.consume();\n+        recognizer.consume();\n+      }\n+    }\n+    super.sync(recognizer);\n+  }", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440020588", "bodyText": "Adjective is used for Interface naming  -  ResolvableCopybook", "author": "asatklichov", "createdAt": "2020-06-15T08:44:20Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4NjQ0Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440086446", "bodyText": "I disagree - this object is not a copybook itself, is just a helper for them", "author": "temanbrcom", "createdAt": "2020-06-15T10:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyMTg2OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440121869", "bodyText": "@temanbrcom It is Java naming rule, existing even from Sun time.  CopybookResolution is  noun.", "author": "asatklichov", "createdAt": "2020-06-15T11:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNzUxMg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440127512", "bodyText": "Interface naming convention\nIn Java, interfaces names, generally, should be adjectives. Interfaces should be in titlecase with the first letter of each separate word capitalized. In same cases, interfaces can be nouns as well when they present a family of classes e.g. List and Map.\nsource\n\nHere, I recognize this interface as a representation of a family of classes", "author": "temanbrcom", "createdAt": "2020-06-15T12:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNzc0OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440037749", "bodyText": "replaceable with reduce(0, Integer::sum)", "author": "asatklichov", "createdAt": "2020-06-15T09:13:06Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -14,130 +14,297 @@\n package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n \n import com.broadcom.lsp.domain.common.model.Position;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.SyntaxError;\n-import com.ca.lsp.core.cobol.model.Variable;\n+import com.ca.lsp.core.cobol.model.*;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n import com.ca.lsp.core.cobol.preprocessor.sub.document.CobolSemanticParserListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorStringUtils;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorCleanerServiceImpl;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n import org.antlr.v4.runtime.BufferedTokenStream;\n import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n import org.antlr.v4.runtime.tree.TerminalNode;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n+import java.util.*;\n \n-import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.COMMENT_TAG;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.convertTokensToPositions;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.retrieveTokens;\n+import static java.lang.String.format;\n import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n \n /**\n- * ANTLR visitor, which preprocesses a given COBOL program by executing COPY and REPLACE statements.\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n  */\n @Slf4j\n public class CobolSemanticParserListenerImpl extends CobolPreprocessorBaseListener\n     implements CobolSemanticParserListener {\n   private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n   private static final String COPYBOOK_OVER_8_CHARACTERS =\n       \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n \n   @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n \n-  private final PreprocessorCleanerServiceImpl preprocessorCleanerService;\n-  private final String documentUri;\n-  private final BufferedTokenStream tokens;\n-  private final SemanticContext semanticContext;\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n \n+  private PreprocessorCleanerServiceImpl cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+\n+  @Inject\n   CobolSemanticParserListenerImpl(\n-      String documentUri, BufferedTokenStream tokens, SemanticContext semanticContext) {\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerServiceImpl cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions) {\n     this.documentUri = documentUri;\n     this.tokens = tokens;\n-    this.semanticContext = semanticContext;\n-\n-    preprocessorCleanerService = new PreprocessorCleanerServiceImpl();\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n   }\n \n   @Nonnull\n   @Override\n-  public CobolDocumentContext context() {\n-    return preprocessorCleanerService.context();\n+  public String getResult() {\n+    return cleaner.peek().read();\n   }\n \n   @Override\n-  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // push a new context for the COMPILER OPTIONS terminals\n-    preprocessorCleanerService.push();\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n   }\n \n   @Override\n-  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterParagraphName(@Nonnull ParagraphNameContext ctx) {\n-    semanticContext.getParagraphs().define(ctx.getText().toUpperCase(), retrievePosition(ctx));\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // throw away COMPILER OPTIONS terminals\n-    preprocessorCleanerService.pop();\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat1(@Nonnull DataDescriptionEntryFormat1Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat2(@Nonnull DataDescriptionEntryFormat2Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat3(@Nonnull DataDescriptionEntryFormat3Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n   }\n \n   @Override\n   public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+\n+    // throw away COPY terminals\n+    cleaner.pop();\n+\n+    // a new context for the copy book content\n+    cleaner.peek().write(CPY_ENTER_TAG);\n     /*\n-     * define the copy book\n+     * copy the copy book\n      */\n-    CopySourceContext copySource = ctx.copySource();\n-    String copybookName = retrieveCopybookName(copySource);\n-    Position position = retrievePosition(copySource);\n-    defineCopybook(copybookName, position);\n+    String copybookName = retrieveCopybookName(ctx.copySource());\n+    Position position = retrievePosition(ctx.copySource());\n+\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String copybookContent = model.getContent();\n+\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, model.getUri());\n+\n+    List<ReplacingPhraseContext> replacingPhraseContexts = ctx.replacingPhrase();\n+    if (!replacingPhraseContexts.isEmpty()) {\n+      applyReplacing(copybookName, model.getUri(), copybookContent, replacingPhraseContexts);\n+    } else {\n+      writeCopybookContent(\"<URI>\" + model.getUri() + \"</URI>\", copybookContent);\n+    }\n+\n+    String content = cleaner.peek().read();\n+    cleaner.pop();\n+\n+    cleaner.peek().write(content);\n+  }\n+\n+  private void applyReplacing(\n+      String copybookName,\n+      String uri,\n+      String copybookContent,\n+      List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    String copybookWithReplacingName =\n+        getUniqueNameForReplacing(copybookName, replacingPhraseContexts);\n+\n+    cleaner.peek().write(\"<URI>\" + copybookWithReplacingName + \"</URI>. \");\n+    CobolDocumentContext documentContext = cleaner.push();\n+    replacingPhraseContexts.forEach(\n+        it -> documentContext.storeReplaceablesAndReplacements(it.replaceClause()));\n+\n+    documentContext.write(copybookContent);\n+    documentContext.replaceReplaceablesByReplacements(tokens);\n+\n+    documentMappings.put(\n+        copybookWithReplacingName,\n+        convertTokensToPositions(uri, retrieveTokens(documentContext.read())));\n+    documentContext.write(CPY_EXIT_TAG);\n+  }\n+\n+  private String getUniqueNameForReplacing(\n+      String copybookName, List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    return copybookName\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce((r1, r2) -> r1 + r2)", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4NTMyOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440085328", "bodyText": "Why? r1 and r2 are strings", "author": "temanbrcom", "createdAt": "2020-06-15T10:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNzc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA5MDc5OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440090799", "bodyText": "Sorry, I mean:  reduce(\"\", String::concat)", "author": "asatklichov", "createdAt": "2020-06-15T10:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNzc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2OTc2MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440069761", "bodyText": "both by default null", "author": "asatklichov", "createdAt": "2020-06-15T10:08:13Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving = null;", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3NDg4OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440074889", "bodyText": "This if block can be removed, if rootVariable != null used, we have false return at the end.", "author": "asatklichov", "createdAt": "2020-06-15T10:17:52Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/CobolVariableContext.java", "diffHunk": "@@ -94,6 +92,10 @@ public Variable get(String name) {\n   public boolean parentContainsSpecificChild(String rootVariableName, String targetVariableName) {\n     Variable rootVariable = get(rootVariableName);\n \n+    if (rootVariable == null) {", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNTA5MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440125091", "bodyText": "Ok, it seems reasonable to refactor this method", "author": "temanbrcom", "createdAt": "2020-06-15T12:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3NDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440078353", "bodyText": "Should be documented, not merging into one, but onto two different collections", "author": "asatklichov", "createdAt": "2020-06-15T10:24:38Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/NamedSubContext.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import lombok.Getter;\n+\n+import java.util.Collection;\n+\n+public class NamedSubContext<T> implements SubContext<String, T> {\n+\n+  @Getter private final Multimap<String, T> definitions = HashMultimap.create();\n+\n+  @Getter private final Multimap<String, T> usages = HashMultimap.create();\n+\n+  @Override\n+  public void define(String name, T token) {\n+    definitions.put(name, token);\n+  }\n+\n+  @Override\n+  public void addUsage(String name, T token) {\n+    usages.put(name, token);\n+  }\n+\n+  @Override\n+  public Collection<String> getAll() {\n+    return definitions.keySet();\n+  }\n+\n+  @Override\n+  public boolean contains(String name) {\n+    return definitions.containsKey(name);\n+  }\n+\n+  @Override\n+  public void merge(SubContext<String, T> subContext) {", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNDYzOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440124639", "bodyText": "Agree, I'll update the documentation", "author": "temanbrcom", "createdAt": "2020-06-15T11:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDg1NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447830854", "bodyText": "Or just rename the method", "author": "asatklichov", "createdAt": "2020-06-30T16:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEwNDI1Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440104256", "bodyText": "same, by default null", "author": "asatklichov", "createdAt": "2020-06-15T11:17:16Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestCopybookCaching.java", "diffHunk": "@@ -24,64 +25,54 @@\n import com.ca.lsp.cobol.positive.CobolText;\n import com.ca.lsp.cobol.service.mocks.MockCopybookService;\n import com.ca.lsp.cobol.service.mocks.MockCopybookServiceImpl;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.PreprocessedInput;\n-import com.ca.lsp.core.cobol.model.ResultWithErrors;\n-import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n-import com.ca.lsp.core.cobol.preprocessor.sub.copybook.AnalyseCopybookTask;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.impl.CopybookResolutionProvider;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.MultiMapSerializableHelper;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n import com.google.inject.Guice;\n+import com.google.inject.Injector;\n import lombok.extern.slf4j.Slf4j;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n \n-import static java.util.Collections.emptyList;\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n import static java.util.Collections.singletonList;\n import static junit.framework.TestCase.assertTrue;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n \n /**\n- * This test checks the logic of caching logic performed by copybook analyzer. The cache invalidated\n- * before each test run. The runAnalysis() method starts the analyzing task synchronously, and after\n- * finish the content of the copybook should appear in cache managing by databus. After accessing\n- * the cache element its hit counter should increase to maintain the element persistence. Also, all\n- * the objects in cache expected to be serializable.\n+ * This test checks the caching logic performed by copybook resolution. The cache invalidated before\n+ * each test run. The runAnalysis() method starts the resolving task synchronously, and after finish\n+ * the content of the copybook should appear in cache managing by data bus. After accessing the\n+ * cache element its hit counter should increase to maintain the element persistence. Also, all the\n+ * objects in cache expected to be serializable.\n  */\n @Slf4j\n-public class AnalyzeCopybookCaching {\n+public class TestCopybookCaching {\n   private final String COPYBOOK_NAME = \"copy\";\n   private final String COPYBOOK_CONTENT = \"000230 77  REPORT-STATUS           PIC 99 VALUE ZERO.\";\n \n-  private final Position POSITION_FIRST_OCCURRENCE = new Position(null, 0, 0, 0, 0);\n-  private final Position POSITION_SECOND_OCCURRENCE = new Position(null, 10, 10, 10, 10);\n+  private final Position POSITION_FIRST_OCCURRENCE = new Position(null, 0, 0, 0, 0, null);\n+  private final Position POSITION_SECOND_OCCURRENCE = new Position(null, 10, 10, 10, 10, null);\n   private final Multimap<String, Position> paragraphDefinitions = HashMultimap.create();\n \n-  private final DataBusBroker databus =\n-      Guice.createInjector(new DatabusModule()).getInstance(DataBusBroker.class);\n-\n-  private CobolPreprocessor preprocessor = mock(CobolPreprocessor.class);\n+  private DataBusBroker databus = null;", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440119648", "bodyText": "In many tests, there are similar/same testing steps with different value.\nIt would be perfect to extract it to a single method.", "author": "asatklichov", "createdAt": "2020-06-15T11:49:52Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "originalCommit": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNDA4NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440124084", "bodyText": "I agree, but I didn't find a way how to do it handily", "author": "temanbrcom", "createdAt": "2020-06-15T11:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyOTE4Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440129186", "bodyText": "Most similar steps can be extracted into method via parameters, actually you have used such approaches already.", "author": "asatklichov", "createdAt": "2020-06-15T12:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE1NTQ5Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440155497", "bodyText": "I'll suggest planning the activity regarding tests refactoring, maybe on the innovation week, because it is not the only problem here.", "author": "temanbrcom", "createdAt": "2020-06-15T12:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDI3NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442724274", "bodyText": "I am preparing some topics regarding this theme because I am focusing on testing for copybook replace in extended document.\nI skipped the static analysis of the code, but if u think that I could contribute on that as well let me know.", "author": "zacanbrcom", "createdAt": "2020-06-19T09:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYyNjc4MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455626781", "bodyText": "#427", "author": "temanbrcom", "createdAt": "2020-07-16T08:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}], "type": "inlineReview"}, {"oid": "ee1f38ae68b2ab6d83ad412f00883abf7237ddb8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ee1f38ae68b2ab6d83ad412f00883abf7237ddb8", "message": "feat: Support copybook usages everywhere GH-352", "committedDate": "2020-06-15T12:49:46Z", "type": "commit"}, {"oid": "2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "message": "refactor: Introduce replacing statements with several patterns #350", "committedDate": "2020-06-15T12:49:55Z", "type": "commit"}, {"oid": "2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "message": "refactor: Introduce replacing statements with several patterns #350", "committedDate": "2020-06-15T12:49:55Z", "type": "forcePushed"}, {"oid": "400d15f67cb7dc0f041740abd26ffb7055e2b47a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/400d15f67cb7dc0f041740abd26ffb7055e2b47a", "message": "doc: Update javadocs for semantic context models", "committedDate": "2020-06-15T15:05:49Z", "type": "commit"}, {"oid": "c932ab348ce5aa01e9980a274848be7f2ec14730", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c932ab348ce5aa01e9980a274848be7f2ec14730", "message": "refactor: Use a predefined operator to simplify lambda #23", "committedDate": "2020-06-15T15:12:24Z", "type": "commit"}, {"oid": "d74e2576393b6b24ef7de4a9ea49c8ab9c24e350", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d74e2576393b6b24ef7de4a9ea49c8ab9c24e350", "message": "refactor: Remove unnecessary default field declaration #23", "committedDate": "2020-06-16T08:11:54Z", "type": "commit"}, {"oid": "beed215ee23dce6de0a96f2964210665cf55ee5c", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/beed215ee23dce6de0a96f2964210665cf55ee5c", "message": "Merge branch 'development' into mapping", "committedDate": "2020-06-16T08:12:32Z", "type": "commit"}, {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "message": "refactor: Add null check for element with duplicated definitions #220", "committedDate": "2020-06-16T11:03:43Z", "type": "commit"}, {"oid": "69bc6f8d480460a49f701f52f878719f17bec9e3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/69bc6f8d480460a49f701f52f878719f17bec9e3", "message": "refactor: Make replacing applicable immediately", "committedDate": "2020-06-18T17:05:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNjYzNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442106634", "bodyText": "Multimap goes on input and outputs Map. We could lose data here. Is it possible to have many tokens for one key in source?", "author": "grianbrcom", "createdAt": "2020-06-18T09:50:24Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()", "originalCommit": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMjkwNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442402907", "bodyText": "Yes, there may be multiple variable definitions and usages. The output Map has Collection as a value type, so all the positions should be mapped, at least the tests passed well", "author": "temanbrcom", "createdAt": "2020-06-18T17:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNjYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5OTYyNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442699625", "bodyText": "Indeed, the Map with Collection inside. You are right.", "author": "grianbrcom", "createdAt": "2020-06-19T08:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNjYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMDYyOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442110628", "bodyText": "You could use copy builder here like:\n    return err -> err.toBuilder()\n            .position(convertPositionRange(err.getStartToken(), err.getStopToken(), mapping))\n            .build();\n\nThe annotation for SyntaxError constructor must be changed to:\n  @Builder(builderMethodName = \"syntaxError\", toBuilder = true)", "author": "grianbrcom", "createdAt": "2020-06-18T09:57:09Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()\n+        .collect(toMap(Map.Entry::getKey, mapPositions(mapping)));\n+  }\n+\n+  private Function<Map.Entry<String, Collection<Token>>, Collection<Position>> mapPositions(\n+      Map<Token, Position> mapping) {\n+    return it -> it.getValue().stream().map(mapping::get).collect(toSet());\n+  }\n+\n+  private List<SyntaxError> finalizeErrors(List<SyntaxError> errors, Map<Token, Position> mapping) {\n+    return errors.stream()\n+        .map(convertError(mapping))\n+        .filter(it -> it.getPosition() != null)\n+        .collect(toList());\n+  }\n+\n+  private Function<SyntaxError, SyntaxError> convertError(Map<Token, Position> mapping) {\n+    return err ->\n+        SyntaxError.syntaxError()\n+            .severity(err.getSeverity())\n+            .ruleStack(err.getRuleStack())\n+            .suggestion(err.getSuggestion())\n+            .errorCode(err.getErrorCode())\n+            .position(convertPositionRange(err.getStartToken(), err.getStopToken(), mapping))\n+            .build();", "originalCommit": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4ODE2NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r443488164", "bodyText": "Good idea, thanks!", "author": "temanbrcom", "createdAt": "2020-06-22T11:18:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMDYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExODgyNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442118827", "bodyText": "Something seems to have interrupted you here.", "author": "grianbrcom", "createdAt": "2020-06-18T10:11:48Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {\n+\n+  /**\n+   * Retrieve and return the copybook by its name. C", "originalCommit": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNjg4OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442126889", "bodyText": "You have deleted @Nonnull for ctx, but don't check the null before first use.", "author": "grianbrcom", "createdAt": "2020-06-18T10:26:45Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -152,39 +319,48 @@ private void checkCopybookNameLength(String copybookName, Position position) {\n   }\n \n   @Override\n-  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+  public void exitReplaceArea(ReplaceAreaContext ctx) {\n     /*\n      * replacement phrase\n      */\n-    preprocessorCleanerService.pop();\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();", "originalCommit": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5NzQ3MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442397470", "bodyText": "Oops, putting it back", "author": "temanbrcom", "createdAt": "2020-06-18T17:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNjg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyOTgxMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442329810", "bodyText": "A bunch of methods visitSomething starts with throwWarning. It scares me.\nCould it be like throwWarningForMisspelledKeyword?", "author": "grianbrcom", "createdAt": "2020-06-18T15:52:20Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +47,275 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());", "originalCommit": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5OTkwNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442399906", "bodyText": "It was just a PoC for misspelled keywords check. It should be not only rewritten but refactored and finalized", "author": "temanbrcom", "createdAt": "2020-06-18T17:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyOTgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NDQ5MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r444754491", "bodyText": "Regarding activity planned for the upcoming PI, Github Issues to come.", "author": "temanbrcom", "createdAt": "2020-06-24T09:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyOTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MjIwMg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442352202", "bodyText": "It could be done like this:\n.collect(groupingBy(error -> error.getPosition().getDocumentURI(), mapping(toDiagnostic(), toList())));", "author": "grianbrcom", "createdAt": "2020-06-18T16:26:57Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +76,69 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();\n+    return new AnalysisResult(\n+        collectDiagnosticsForAffectedDocuments(\n+            convertErrors(result.getErrors()), context.getCopybookDefinitions(), uri),\n+        convertPositions(context.getVariableDefinitions()),\n+        convertPositions(context.getVariableUsages()),\n+        convertPositions(context.getParagraphDefinitions()),\n+        convertPositions(context.getParagraphUsages()),\n+        convertPositions(context.getCopybookDefinitions()),\n+        convertPositions(context.getCopybookUsages()));\n+  }\n+\n+  /**\n+   * Collect diagnostics for each document, used in the analysis - the main COBOL file and all the\n+   * copybooks. If there were no errors for some URI, then provide an empty list to clean-up the\n+   * errors after the previous analysis.\n+   *\n+   * @param diagnostics - list of found syntax and semantic errors\n+   * @param copybookDefinitions - list of copybook definitions used in this analysis\n+   * @param uri - current document URI\n+   * @return map with file URI as a key, and lists of diagnostics as values\n+   */\n+  private Map<String, List<Diagnostic>> collectDiagnosticsForAffectedDocuments(\n+      Map<String, List<Diagnostic>> diagnostics,\n+      Map<String, Collection<Position>> copybookDefinitions,\n+      String uri) {\n+    Map<String, List<Diagnostic>> result = new HashMap<>(diagnostics);\n+    copybookDefinitions.values().stream()\n+        .flatMap(Collection::stream)\n+        .map(Position::getDocumentURI)\n+        .forEach(it -> result.putIfAbsent(it, emptyList()));\n+    result.putIfAbsent(uri, emptyList());\n+    return result;\n+  }\n+\n+  private static Map<String, List<Diagnostic>> convertErrors(List<SyntaxError> errors) {\n     return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+        .map(SyntaxError::getPosition)\n+        .map(Position::getDocumentURI)\n+        .distinct()\n+        .collect(toMap(uri -> uri, toDiagnostics(errors)));", "originalCommit": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NTI3Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r443495273", "bodyText": "wow", "author": "temanbrcom", "createdAt": "2020-06-22T11:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MjIwMg=="}], "type": "inlineReview"}, {"oid": "31462a39a249ec0a869ac6fac9c6b6e4991e83ca", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/31462a39a249ec0a869ac6fac9c6b6e4991e83ca", "message": "doc: Fix Javadoc for CopybookResolution", "committedDate": "2020-06-18T17:50:03Z", "type": "commit"}, {"oid": "c9bb71ef06e9d929e9870e58dbcc1068cc5a7c06", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c9bb71ef06e9d929e9870e58dbcc1068cc5a7c06", "message": "refactor: Extract REPLACING as a separate service #335", "committedDate": "2020-06-19T13:44:09Z", "type": "commit"}, {"oid": "c822649ceb76b7382780113d8a2066578accf173", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c822649ceb76b7382780113d8a2066578accf173", "message": "refactor: Collapse function duplication in Prerpocessor listener #335", "committedDate": "2020-06-19T14:45:13Z", "type": "commit"}, {"oid": "98da0d1e89526a642ad4361202485c41efa58afd", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/98da0d1e89526a642ad4361202485c41efa58afd", "message": "refactor: Remove redundant conditional clause in replacing application #335", "committedDate": "2020-06-19T15:09:09Z", "type": "commit"}, {"oid": "104190aacc2d57af0e35dd7942f2251b34f660be", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/104190aacc2d57af0e35dd7942f2251b34f660be", "message": "refactor: Apply replacing for copybook before processing #335", "committedDate": "2020-06-19T16:02:55Z", "type": "commit"}, {"oid": "eca869dd1d2ccb7d901767ce94b7bac54c15f7be", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/eca869dd1d2ccb7d901767ce94b7bac54c15f7be", "message": "refactor: Simplify preprocessor cleaning API #335", "committedDate": "2020-06-19T16:39:34Z", "type": "commit"}, {"oid": "c2012ac504b4db4df8b1bc96cd0396a3c8fb81d9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c2012ac504b4db4df8b1bc96cd0396a3c8fb81d9", "message": "refactor: Remove redundant null check", "committedDate": "2020-06-19T16:45:23Z", "type": "commit"}, {"oid": "85acdca0274f3c5b508ff8dcd1f040706b0e81b1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/85acdca0274f3c5b508ff8dcd1f040706b0e81b1", "message": "refactor: Make visitor accept missing copybook names #355", "committedDate": "2020-06-22T11:14:10Z", "type": "commit"}, {"oid": "33af0bb2c603fc59873f6c30dc717c85cb22bda9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/33af0bb2c603fc59873f6c30dc717c85cb22bda9", "message": "refactor: Simplify adjusting syntax errors using toBuilder() #23", "committedDate": "2020-06-22T11:19:38Z", "type": "commit"}, {"oid": "a8db4b56ccb64b3e85c9a4b92a09c55084e2326f", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a8db4b56ccb64b3e85c9a4b92a09c55084e2326f", "message": "refactor: Simplify syntax error conversion #23", "committedDate": "2020-06-22T11:36:08Z", "type": "commit"}, {"oid": "56a454e9c0d7ddd308056497a0cf21297759b760", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/56a454e9c0d7ddd308056497a0cf21297759b760", "message": "Merge branch 'development' into mapping", "committedDate": "2020-06-22T13:13:46Z", "type": "commit"}, {"oid": "ff1218129ce6538128f8732ddbff068f91a86e3e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ff1218129ce6538128f8732ddbff068f91a86e3e", "message": "fix: Make COPY accept only one REPLACING with multiple patterns #335", "committedDate": "2020-06-24T14:45:11Z", "type": "commit"}, {"oid": "ad03ee843214c8d80ec28a37bf976637c145a47b", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ad03ee843214c8d80ec28a37bf976637c145a47b", "message": "refactor: Clean-up replacing infrastructure", "committedDate": "2020-06-25T13:13:24Z", "type": "commit"}, {"oid": "83aa91138d24f2b7474338e5878db9704ad7b9d1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/83aa91138d24f2b7474338e5878db9704ad7b9d1", "message": "refactor: Make literal replacing applicable only for full tokens #335", "committedDate": "2020-06-25T16:11:05Z", "type": "commit"}, {"oid": "7f03d0bca35cadd9dbcdb4fc5a58313ccf6a96a7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7f03d0bca35cadd9dbcdb4fc5a58313ccf6a96a7", "message": "refactor: Exstract replacing logic to increase testability #335", "committedDate": "2020-06-26T08:08:36Z", "type": "commit"}, {"oid": "22eef64502a017908d5a96cfab71e40f5d077a06", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/22eef64502a017908d5a96cfab71e40f5d077a06", "message": "refactor: Extract token utils to provide DI #24", "committedDate": "2020-06-26T10:30:20Z", "type": "commit"}, {"oid": "69283e391feb9c63678ad0cfab9ad6de9f9944dd", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/69283e391feb9c63678ad0cfab9ad6de9f9944dd", "message": "refactor: Remove redundant method to simplify token utils API", "committedDate": "2020-06-26T12:52:55Z", "type": "commit"}, {"oid": "47be51219c7ea7d822342b11e8bcad0be9268afd", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/47be51219c7ea7d822342b11e8bcad0be9268afd", "message": "refactor: Move value class to the appropriate place", "committedDate": "2020-06-26T13:08:44Z", "type": "commit"}, {"oid": "b408f09304f082171b2e609884c22ec5b3eab66e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b408f09304f082171b2e609884c22ec5b3eab66e", "message": "refactor: Bind preprocessor cleaner to increase testability #24", "committedDate": "2020-06-26T14:52:13Z", "type": "commit"}, {"oid": "bdfdf706a8e1b2510a43240535ae328d2fd463d1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/bdfdf706a8e1b2510a43240535ae328d2fd463d1", "message": "refactor: Move classes to the appropriate packages", "committedDate": "2020-06-26T15:45:48Z", "type": "commit"}, {"oid": "470825ce3075e1b58964484415043d80ae9df449", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/470825ce3075e1b58964484415043d80ae9df449", "message": "refactor: Change out-of-date name of preprocessor", "committedDate": "2020-06-26T16:36:35Z", "type": "commit"}, {"oid": "3a8948e156deaa357f8179d50484136219c597ac", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3a8948e156deaa357f8179d50484136219c597ac", "message": "Merge branch 'development' into mapping", "committedDate": "2020-06-29T08:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyNjgxMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447526810", "bodyText": "Is it still valid? We must expect .c4z/.copybooks.", "author": "grianbrcom", "createdAt": "2020-06-30T08:59:55Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -31,45 +30,36 @@\n import com.google.inject.Injector;\n import lombok.experimental.UtilityClass;\n import org.awaitility.Awaitility;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.DidOpenTextDocumentParams;\n-import org.eclipse.lsp4j.TextDocumentItem;\n-import org.eclipse.lsp4j.services.LanguageClient;\n+import org.eclipse.lsp4j.*;\n import org.eclipse.lsp4j.services.TextDocumentService;\n \n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /** This utility class provides methods to run use cases with Cobol code examples. */\n @UtilityClass\n public class UseCaseUtils {\n   public static final String DOCUMENT_URI = \"file:///c%3A/workspace/document.cbl\";\n   public static final String DOCUMENT_2_URI = \"file:///c%3A/workspace/document2.cbl\";\n+  private static final String CPY_URI_PREFIX = \"file:///c%3A/workspace/.copybooks/\";", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDUwNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447534504", "bodyText": "That's correct, but we don't apply any actual file system calls, and this value is just a mock.\nI will fix it", "author": "temanbrcom", "createdAt": "2020-06-30T09:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyNjgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMjc0OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455012749", "bodyText": "fixed in #427", "author": "temanbrcom", "createdAt": "2020-07-15T12:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyNjgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzM5OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447783398", "bodyText": "Just initialize copybookName during declaration, then this line can be removed.", "author": "asatklichov", "createdAt": "2020-06-30T15:40:57Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0MDMzMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455140331", "bodyText": "The grammar here guarantees that we won't reach the else clause, I may simplify this clause", "author": "temanbrcom", "createdAt": "2020-07-15T15:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4OTM3MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447789371", "bodyText": "!( isEmpty(copybookName) || isEmpty(uri) ) is simpler and no double-negate", "author": "asatklichov", "createdAt": "2020-06-30T15:49:15Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0MDYwNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455140605", "bodyText": "Ok, makes sense", "author": "temanbrcom", "createdAt": "2020-07-15T15:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4OTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTE0Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447791142", "bodyText": "Why hard coded? better use existing meaningful constant.\nseverity(DiagnosticSeverity.Error.getValue())", "author": "asatklichov", "createdAt": "2020-06-30T15:51:34Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTI4MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447791281", "bodyText": "same", "author": "asatklichov", "createdAt": "2020-06-30T15:51:44Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)\n+            .suggestion(String.format(RECURSION_DETECTED, usage.getName()))\n+            .position(usage.getPosition())\n+            .build());\n+  }\n+\n+  private void reportMissingCopybooks(String copybookName, Position position) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .position(position)\n+            .suggestion(format(ERROR_SUGGESTION, copybookName))\n+            .severity(1)", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjE5MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447792191", "bodyText": ".severity(DiagnosticSeverity.Information.getValue())", "author": "asatklichov", "createdAt": "2020-06-30T15:52:39Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)\n+            .suggestion(String.format(RECURSION_DETECTED, usage.getName()))\n+            .position(usage.getPosition())\n+            .build());\n+  }\n+\n+  private void reportMissingCopybooks(String copybookName, Position position) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .position(position)\n+            .suggestion(format(ERROR_SUGGESTION, copybookName))\n+            .severity(1)\n+            .errorCode(MISSING_COPYBOOK)\n+            .build());\n+  }\n+\n+  private void checkCopybookNameLength(String copybookName, Position position) {\n+    if (copybookName != null && copybookName.length() > 8) {\n+      errors.add(\n+          SyntaxError.syntaxError()\n+              .severity(3)", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDQ5MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447794490", "bodyText": "Better practice is use a general return at the end of method, especially if catch block logs the exception.", "author": "asatklichov", "createdAt": "2020-06-30T15:55:42Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving;\n+  private String copybookName;\n+\n+  SynchronousCopybookResolution(DataBusBroker broker) {\n+    this.broker = broker;\n+    broker.subscribe(FETCHED_COPYBOOK_EVENT, this);\n+  }\n+\n+  /**\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param syncType - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content; or null in case\n+   *     of severe issue.\n+   * @throws IllegalStateException if the instance reused.\n+   */\n+  @Nullable\n+  @Override\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName, @Nonnull String documentUri, @Nonnull String syncType) {\n+    checkState();\n+\n+    if (isCopybookInCache(copybookName)) {\n+      broker.unSubscribe(this);\n+      return getContentFromCache(copybookName);\n+    }\n+\n+    this.copybookName = copybookName;\n+    waitForResolving = new CompletableFuture<>();\n+    broker.postData(\n+        RequiredCopybookEvent.builder()\n+            .name(copybookName)\n+            .documentUri(documentUri)\n+            .textDocumentSyncType(syncType)\n+            .build());\n+    try {\n+      return waitForResolving.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      LOG.error(\"Error resolving copybook: \", e);\n+      currentThread().interrupt();\n+      return null;", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NzIxNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447797216", "bodyText": "Please, move this uri, and content retrieval logic after checking !copybookName.equals(name),  so it will not create redundant objects here.", "author": "asatklichov", "createdAt": "2020-06-30T15:59:38Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving;\n+  private String copybookName;\n+\n+  SynchronousCopybookResolution(DataBusBroker broker) {\n+    this.broker = broker;\n+    broker.subscribe(FETCHED_COPYBOOK_EVENT, this);\n+  }\n+\n+  /**\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param syncType - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content; or null in case\n+   *     of severe issue.\n+   * @throws IllegalStateException if the instance reused.\n+   */\n+  @Nullable\n+  @Override\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName, @Nonnull String documentUri, @Nonnull String syncType) {\n+    checkState();\n+\n+    if (isCopybookInCache(copybookName)) {\n+      broker.unSubscribe(this);\n+      return getContentFromCache(copybookName);\n+    }\n+\n+    this.copybookName = copybookName;\n+    waitForResolving = new CompletableFuture<>();\n+    broker.postData(\n+        RequiredCopybookEvent.builder()\n+            .name(copybookName)\n+            .documentUri(documentUri)\n+            .textDocumentSyncType(syncType)\n+            .build());\n+    try {\n+      return waitForResolving.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      LOG.error(\"Error resolving copybook: \", e);\n+      currentThread().interrupt();\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void observerCallback(@Nonnull FetchedCopybookEvent event) {\n+    if (copybookName == null) {\n+      LOG.warn(\"A disposed instance of copybook resolver used: \" + toString());\n+      return;\n+    }\n+    String name = event.getName();\n+    String uri = event.getUri();", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjAxOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447802019", "bodyText": "Inconsistent injection, one is via constructor, other inline [I saw usage: new PreprocessorCleanerServiceImpl(new TokenUtilsImpl());].  Should be both either via constructor, or both via inline.", "author": "asatklichov", "createdAt": "2020-06-30T16:06:47Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PreprocessorCleanerServiceImpl.java", "diffHunk": "@@ -27,36 +27,67 @@\n import java.util.Scanner;\n \n import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n \n public class PreprocessorCleanerServiceImpl implements PreprocessorCleanerService {\n-  private Deque<CobolDocumentContext> contexts = new ArrayDeque<>();\n+  private Deque<StringBuilder> contexts = new ArrayDeque<>();\n+  private TokenUtils tokenUtils;\n \n-  public PreprocessorCleanerServiceImpl() {\n-    contexts.push(new CobolDocumentContext());\n+  @Inject\n+  public PreprocessorCleanerServiceImpl(TokenUtils tokenUtils) {\n+    this.tokenUtils = tokenUtils;\n+    contexts.push(new StringBuilder());", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzMDYzNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455630634", "bodyText": "The injection in the given example is in the unit test, and the best practice is to avoid using dependency injection in tests", "author": "temanbrcom", "createdAt": "2020-07-16T08:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNzQ0OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447807449", "bodyText": "Please change hardcoded value,  DiagnosticSeverity.Error.getValue() == it.getSeverity().getValue()", "author": "asatklichov", "createdAt": "2020-06-30T16:14:35Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors\n    */\n   public static List<Diagnostic> analyzeForErrors(String text, List<CobolText> copybooks) {\n-    return analyze(text, copybooks).getDiagnostics().stream()\n-        .filter(it -> it.getSeverity().getValue() == 1)\n-        .collect(toList());\n+    return ofNullable(analyze(text, copybooks).getDiagnostics().get(DOCUMENT_URI))\n+        .map(\n+            diagnostics ->\n+                diagnostics.stream()\n+                    .filter(it -> it.getSeverity().getValue() == 1)", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMzAwNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455013006", "bodyText": "fixed in #427", "author": "temanbrcom", "createdAt": "2020-07-15T12:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNzQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwOTA4OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447809088", "bodyText": "But return type is List", "author": "asatklichov", "createdAt": "2020-06-30T16:17:02Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMzA3Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455013077", "bodyText": "fixed in #427", "author": "temanbrcom", "createdAt": "2020-07-15T12:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwOTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjk1NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447816954", "bodyText": "Is context non-null all the time ?", "author": "asatklichov", "createdAt": "2020-06-30T16:27:00Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +75,60 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n-    return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyNjI4Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455026282", "bodyText": "Yes, it is either fulfilled or empty. Added annotations to assure that.", "author": "temanbrcom", "createdAt": "2020-07-15T12:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyMzg3OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447823878", "bodyText": "Here no need unnecessary line-comments, see TokenUtilsImpl#retrieveTokens similar method quite readable", "author": "asatklichov", "createdAt": "2020-06-30T16:36:05Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorImpl.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.CopybookUsage;\n+import com.ca.lsp.core.cobol.model.ExtendedDocument;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorLexer;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.StartRuleContext;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListenerFactory;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.google.inject.Inject;\n+import org.antlr.v4.runtime.CharStreams;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTreeWalker;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This class runs pre-processing for COBOL using CobolPreprocessor.g4 grammar file. As a result, it\n+ * returns an extended document with all the available copybooks included, with their definitions\n+ * and usages specified, as well as related errors.\n+ */\n+public class GrammarPreprocessorImpl implements GrammarPreprocessor {\n+  private GrammarPreprocessorListenerFactory listenerFactory;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  public GrammarPreprocessorImpl(\n+      GrammarPreprocessorListenerFactory listenerFactory, TokenUtils tokenUtils) {\n+    this.listenerFactory = listenerFactory;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public ResultWithErrors<ExtendedDocument> buildExtendedDocument(\n+      @Nonnull String uri,\n+      @Nonnull String code,\n+      @Nonnull Deque<CopybookUsage> copybookStack,\n+      @Nonnull String textDocumentSyncType) {\n+    // run the lexer", "originalCommit": "3a8948e156deaa357f8179d50484136219c597ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e961f05766de669cd76fad406c09aeb72ecbbf84", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e961f05766de669cd76fad406c09aeb72ecbbf84", "message": "Merge branch 'development' into mapping", "committedDate": "2020-07-02T11:25:48Z", "type": "commit"}, {"oid": "8df544c5ab23513b19a3d90d38b91f8a36367219", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8df544c5ab23513b19a3d90d38b91f8a36367219", "message": "test: Introduce use case preprocessor to simplify testing GH-426", "committedDate": "2020-07-14T15:07:38Z", "type": "commit"}, {"oid": "17b322362183e60affd3b72546e4f2e0f7082151", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/17b322362183e60affd3b72546e4f2e0f7082151", "message": "refactor: Extract source info text as an enum", "committedDate": "2020-07-14T15:14:21Z", "type": "commit"}, {"oid": "db34dd94b6285d5b75b3b0f01ca9173a7e634d1d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/db34dd94b6285d5b75b3b0f01ca9173a7e634d1d", "message": "test: Refactor tests with the Use Case Engine #426", "committedDate": "2020-07-14T15:47:36Z", "type": "commit"}, {"oid": "d0d5bb636036338355807fa0076170caf2ff48ee", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d0d5bb636036338355807fa0076170caf2ff48ee", "message": "refactor: Fix too long line error position counting", "committedDate": "2020-07-14T15:51:34Z", "type": "commit"}, {"oid": "227d35b53ded871be1bbeb192a22f4c1e702a3a2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/227d35b53ded871be1bbeb192a22f4c1e702a3a2", "message": "test: Add copyright headers to Use Case Engine files #426", "committedDate": "2020-07-14T16:01:37Z", "type": "commit"}, {"oid": "a7cc8abb2184192d6f4948d71b3cac758060ab3a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a7cc8abb2184192d6f4948d71b3cac758060ab3a", "message": "Merge branch 'development' into mapping", "committedDate": "2020-07-15T08:00:34Z", "type": "commit"}, {"oid": "1cbc55aaf6839713e5ffb7e4efcf0c88616ef5ec", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1cbc55aaf6839713e5ffb7e4efcf0c88616ef5ec", "message": "Merge branch 'mapping' into usecase-preprocessor", "committedDate": "2020-07-15T08:31:25Z", "type": "commit"}, {"oid": "81eba78935cc9b99e572f8a61d1966638acc9de3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/81eba78935cc9b99e572f8a61d1966638acc9de3", "message": "test: Remove duplicated test", "committedDate": "2020-07-15T08:40:17Z", "type": "commit"}, {"oid": "83aac6e3a9dd8458e07aa5780a9b5eb3fa5ae3f1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/83aac6e3a9dd8458e07aa5780a9b5eb3fa5ae3f1", "message": "refactor: Define error severity levels as an enum", "committedDate": "2020-07-15T11:28:36Z", "type": "commit"}, {"oid": "b8680b0ad7ef69b31999966dcdc28b6d70a8bbcb", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b8680b0ad7ef69b31999966dcdc28b6d70a8bbcb", "message": "Merge branch 'mapping' into usecase-preprocessor", "committedDate": "2020-07-15T11:34:55Z", "type": "commit"}, {"oid": "fb1604fb1938ac36002afc1945b2c459850f5758", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fb1604fb1938ac36002afc1945b2c459850f5758", "message": "test: Remove outdated methods from UseCaseUtils #426", "committedDate": "2020-07-15T12:25:39Z", "type": "commit"}, {"oid": "93d9e49803b64d05a90201c7e73f01c574aa2b98", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/93d9e49803b64d05a90201c7e73f01c574aa2b98", "message": "refactor: Assure null-safety for the language engine", "committedDate": "2020-07-15T12:46:46Z", "type": "commit"}, {"oid": "f29dbdb936e8897157028e156296352f596846ce", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f29dbdb936e8897157028e156296352f596846ce", "message": "test: Fix replacing copybook names on UseCaseEngine", "committedDate": "2020-07-15T14:59:05Z", "type": "commit"}, {"oid": "60824ec989a0f3ff7a36d4475692039171cafe1e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/60824ec989a0f3ff7a36d4475692039171cafe1e", "message": "refactor: Remove redundant operations on copybook name retrieving", "committedDate": "2020-07-16T08:41:30Z", "type": "commit"}, {"oid": "ac83016dd7dd26fe1d1b7e30981e762c32cb3c94", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ac83016dd7dd26fe1d1b7e30981e762c32cb3c94", "message": "refactor: Move check to prevent redundant objects creation", "committedDate": "2020-07-16T08:43:00Z", "type": "commit"}, {"oid": "fe657254335a8121c2b64d8c85e4a6cadeeb84f3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fe657254335a8121c2b64d8c85e4a6cadeeb84f3", "message": "test: Add unit test for grammar preprocessor", "committedDate": "2020-07-16T11:46:22Z", "type": "commit"}, {"oid": "f69232b09a90465ee58f06758ab52b4272b2a77f", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f69232b09a90465ee58f06758ab52b4272b2a77f", "message": "refactor: Remove redundant checks on syntax error registration", "committedDate": "2020-07-16T14:16:39Z", "type": "commit"}, {"oid": "12ad47aaf984d714f2547786a2707cc9aceffba1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/12ad47aaf984d714f2547786a2707cc9aceffba1", "message": "fix: Remove techincal tokens from keyword completion suggestions #348", "committedDate": "2020-07-16T14:46:20Z", "type": "commit"}, {"oid": "eaf685edcd9bc6922c0e2fa2284a5ab6dae68ed0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/eaf685edcd9bc6922c0e2fa2284a5ab6dae68ed0", "message": "refactor: Fix source info identifier", "committedDate": "2020-07-16T16:00:39Z", "type": "commit"}, {"oid": "16924d49150529a7ab5b0e0e0a8c73a8a7ac99fe", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/16924d49150529a7ab5b0e0e0a8c73a8a7ac99fe", "message": "test: Fix annotations in javadoc for tests", "committedDate": "2020-07-17T08:26:10Z", "type": "commit"}, {"oid": "a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "message": "refactor: Refactor use cases with Java 11 collections", "committedDate": "2020-07-17T10:12:58Z", "type": "commit"}, {"oid": "e01d8851a515c458653c6e8dedd65cb9bfc9172e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e01d8851a515c458653c6e8dedd65cb9bfc9172e", "message": "Merge pull request #427 from eclipse/usecase-preprocessor\n\nIntroduce Use Case Preprocessor", "committedDate": "2020-07-17T10:17:21Z", "type": "commit"}, {"oid": "67352b8e361d9543c702e9a615bdf9449e852913", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/67352b8e361d9543c702e9a615bdf9449e852913", "message": "Merge branch 'development' into mapping", "committedDate": "2020-07-17T10:45:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMzgwNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456433806", "bodyText": "names of this classes makes me think you are speaking about antlr auto generated classes", "author": "sergiuilie", "createdAt": "2020-07-17T13:14:17Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/broadcom/lsp/cdi/EngineModule.java", "diffHunk": "@@ -32,9 +38,12 @@\n   protected void configure() {\n     bind(CobolLanguageEngine.class);\n     bind(CobolPreprocessor.class).to(CobolPreprocessorImpl.class);\n-    bind(CopybookAnalysis.class).to(CopybookParallelAnalysis.class);\n-    install(new FactoryModuleBuilder().build(AnalyseCopybookTaskFactory.class));\n     bind(CobolPreprocessor.class).to(CobolPreprocessorImpl.class);\n-    bind(CobolSemanticParser.class).to(CobolSemanticParserImpl.class);\n+    bind(GrammarPreprocessor.class).to(GrammarPreprocessorImpl.class);", "originalCommit": "67352b8e361d9543c702e9a615bdf9449e852913", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}