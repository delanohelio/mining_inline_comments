{"pr_number": 517, "pr_title": "refactor: rewrite CopybookRepository to use Guava cache", "pr_createdAt": "2020-09-11T10:29:53Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDUxOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r486964519", "bodyText": "Maybe, it would be better to make these values configurable too", "author": "temanbrcom", "createdAt": "2020-09-11T10:46:09Z", "path": "server/src/main/java/com/broadcom/lsp/domain/cobol/databus/impl/CopybookRepositoryLRU.java", "diffHunk": "@@ -40,111 +39,55 @@\n @Singleton\n public class CopybookRepositoryLRU implements CopybookRepository {\n   @Getter private final int cacheMaxSize;\n-  @Setter @NonNull private ArrayList<CopybookStorable> cpyRepo;\n-  private final Comparator<CopybookStorable> storableComparator =\n-      Comparator.comparingInt(CopybookStorable::getHit); // Time last recently used\n-  private final Comparator<CopybookStorable> timeComparator =\n-      Comparator.comparingLong(CopybookStorable::getGenDt);\n-\n-  @NonNull private final AtomicBoolean isSort = new AtomicBoolean(false);\n+  private Cache<String, CopybookModel> cache;\n \n   @Inject\n   public CopybookRepositoryLRU(@Named(\"CACHE-MAX-SIZE\") int cacheSize) {\n     cacheMaxSize = cacheSize;\n-    cpyRepo = new ArrayList<>(cacheMaxSize);\n-  }\n-\n-  @Override\n-  public synchronized void sortCache() {\n-    if (!isSort.get()) {\n-      cpyRepo.sort(storableComparator.reversed().thenComparing(timeComparator));\n-    }\n-    isSort.set(true);\n-  }\n-\n-  @Override\n-  public Optional<CopybookStorable> getCopybookStorableFromCache(@NonNull long uuid) {\n-    ArrayList<CopybookStorable> shallowCpy = (ArrayList<CopybookStorable>) cpyRepo.clone();\n-    Optional<CopybookStorable> cpy =\n-        shallowCpy.stream().filter(copy -> uuid == copy.getId()).findAny();\n-    if (cpy.isPresent()) return cpy.map(SerializationUtils::clone);\n-    return cpy;\n+    cache = CacheBuilder.newBuilder()\n+        .maximumSize(cacheMaxSize)\n+        .expireAfterAccess(3, TimeUnit.HOURS)", "originalCommit": "129e8022cce87060d269afe45217ecb14d7bc898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyMzYzMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487123633", "bodyText": "I rewrite that has been. In CopybookStorable we had this:\n  private static final long TTU = 3600000L * 3L;\n\nThis means hardcoded 3 hours after writing to the cache. I've decided to change it to 3 hours after the last access.\nI agree that we could make this value configurable. Do you think that we need this configurable value in hours or minutes? In case when retention policy will be half an hour.", "author": "grianbrcom", "createdAt": "2020-09-11T15:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMjk1NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487132954", "bodyText": "I think that 3 hours after writing is ok. We may either provide the time unit as a configuration or use hardcoded seconds or milliseconds and provide only the value.\nDue to it is not something that we are going to change rarely, I would prefer the second option.", "author": "temanbrcom", "createdAt": "2020-09-11T15:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MTAyNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487781024", "bodyText": "Since we're planning here to do refactor here I think could be nice to move those config in a property file in order to have a better customization for future needs", "author": "zacanbrcom", "createdAt": "2020-09-14T09:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NjkwOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487786908", "bodyText": "All right. I will make duration and time unit configurable but initialize them as we do for cache-max-size already.\nI agree, that having a separate property file will be a good option. I'll do it in a separate PR.", "author": "grianbrcom", "createdAt": "2020-09-14T09:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk2NDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0Nzk1MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487047951", "bodyText": "Shouldn't we copy the object? Or it is assured by the Cache?", "author": "temanbrcom", "createdAt": "2020-09-11T13:33:55Z", "path": "server/src/main/java/com/broadcom/lsp/domain/cobol/databus/impl/DefaultDataBusBroker.java", "diffHunk": "@@ -92,31 +90,21 @@ public void unSubscribe(@NonNull RegistryId registryId, @NonNull S dataSubscribe\n   }\n \n   @Override\n-  public CopybookStorable storeData(@NonNull CopybookStorable storable) {\n-    CopybookStorable deepCopy = SerializationUtils.clone(storable);", "originalCommit": "129e8022cce87060d269afe45217ecb14d7bc898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExOTA5NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487119094", "bodyText": "We don't need to copy an object in the current implementation. The thing is that CopybookStorable is modifiable, and maybe that why the object is copied before storing. But current implementation uses CopybookModel which is unmodifiable, it is safe to use one instance everywhere.", "author": "grianbrcom", "createdAt": "2020-09-11T15:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0Nzk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MzIwMg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487783202", "bodyText": "I think you may extract this builder and reuse the code for both constructors", "author": "zacanbrcom", "createdAt": "2020-09-14T09:42:08Z", "path": "server/src/main/java/com/broadcom/lsp/domain/cobol/databus/impl/CopybookRepositoryLRU.java", "diffHunk": "@@ -40,111 +39,55 @@\n @Singleton\n public class CopybookRepositoryLRU implements CopybookRepository {\n   @Getter private final int cacheMaxSize;\n-  @Setter @NonNull private ArrayList<CopybookStorable> cpyRepo;\n-  private final Comparator<CopybookStorable> storableComparator =\n-      Comparator.comparingInt(CopybookStorable::getHit); // Time last recently used\n-  private final Comparator<CopybookStorable> timeComparator =\n-      Comparator.comparingLong(CopybookStorable::getGenDt);\n-\n-  @NonNull private final AtomicBoolean isSort = new AtomicBoolean(false);\n+  private Cache<String, CopybookModel> cache;\n \n   @Inject\n   public CopybookRepositoryLRU(@Named(\"CACHE-MAX-SIZE\") int cacheSize) {\n     cacheMaxSize = cacheSize;\n-    cpyRepo = new ArrayList<>(cacheMaxSize);\n-  }\n-\n-  @Override\n-  public synchronized void sortCache() {\n-    if (!isSort.get()) {\n-      cpyRepo.sort(storableComparator.reversed().thenComparing(timeComparator));\n-    }\n-    isSort.set(true);\n-  }\n-\n-  @Override\n-  public Optional<CopybookStorable> getCopybookStorableFromCache(@NonNull long uuid) {\n-    ArrayList<CopybookStorable> shallowCpy = (ArrayList<CopybookStorable>) cpyRepo.clone();\n-    Optional<CopybookStorable> cpy =\n-        shallowCpy.stream().filter(copy -> uuid == copy.getId()).findAny();\n-    if (cpy.isPresent()) return cpy.map(SerializationUtils::clone);\n-    return cpy;\n+    cache = CacheBuilder.newBuilder()\n+        .maximumSize(cacheMaxSize)\n+        .expireAfterAccess(3, TimeUnit.HOURS)\n+        .build();\n   }\n \n-  private Optional<CopybookStorable> getCopybookStorableInstance(@NonNull long uuid) {\n-    return cpyRepo.stream().filter(copy -> uuid == copy.getId()).findAny();\n+  /** For test purpose only */\n+  CopybookRepositoryLRU(@Named(\"CACHE-MAX-SIZE\") int cacheSize, Ticker ticker) {\n+    cacheMaxSize = cacheSize;\n+    cache = CacheBuilder.newBuilder()\n+        .maximumSize(cacheMaxSize)\n+        .expireAfterAccess(3, TimeUnit.HOURS)\n+        .ticker(ticker)\n+        .build();", "originalCommit": "129e8022cce87060d269afe45217ecb14d7bc898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUxNjgyMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r488516820", "bodyText": "I'm not sure that now it is better.", "author": "grianbrcom", "createdAt": "2020-09-15T09:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4MzIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NjI4MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487786281", "bodyText": "I think is more safety to use Math.toIntExact(cache.size())", "author": "zacanbrcom", "createdAt": "2020-09-14T09:47:25Z", "path": "server/src/main/java/com/broadcom/lsp/domain/cobol/databus/impl/CopybookRepositoryLRU.java", "diffHunk": "@@ -40,111 +39,55 @@\n @Singleton\n public class CopybookRepositoryLRU implements CopybookRepository {\n   @Getter private final int cacheMaxSize;\n-  @Setter @NonNull private ArrayList<CopybookStorable> cpyRepo;\n-  private final Comparator<CopybookStorable> storableComparator =\n-      Comparator.comparingInt(CopybookStorable::getHit); // Time last recently used\n-  private final Comparator<CopybookStorable> timeComparator =\n-      Comparator.comparingLong(CopybookStorable::getGenDt);\n-\n-  @NonNull private final AtomicBoolean isSort = new AtomicBoolean(false);\n+  private Cache<String, CopybookModel> cache;\n \n   @Inject\n   public CopybookRepositoryLRU(@Named(\"CACHE-MAX-SIZE\") int cacheSize) {\n     cacheMaxSize = cacheSize;\n-    cpyRepo = new ArrayList<>(cacheMaxSize);\n-  }\n-\n-  @Override\n-  public synchronized void sortCache() {\n-    if (!isSort.get()) {\n-      cpyRepo.sort(storableComparator.reversed().thenComparing(timeComparator));\n-    }\n-    isSort.set(true);\n-  }\n-\n-  @Override\n-  public Optional<CopybookStorable> getCopybookStorableFromCache(@NonNull long uuid) {\n-    ArrayList<CopybookStorable> shallowCpy = (ArrayList<CopybookStorable>) cpyRepo.clone();\n-    Optional<CopybookStorable> cpy =\n-        shallowCpy.stream().filter(copy -> uuid == copy.getId()).findAny();\n-    if (cpy.isPresent()) return cpy.map(SerializationUtils::clone);\n-    return cpy;\n+    cache = CacheBuilder.newBuilder()\n+        .maximumSize(cacheMaxSize)\n+        .expireAfterAccess(3, TimeUnit.HOURS)\n+        .build();\n   }\n \n-  private Optional<CopybookStorable> getCopybookStorableInstance(@NonNull long uuid) {\n-    return cpyRepo.stream().filter(copy -> uuid == copy.getId()).findAny();\n+  /** For test purpose only */\n+  CopybookRepositoryLRU(@Named(\"CACHE-MAX-SIZE\") int cacheSize, Ticker ticker) {\n+    cacheMaxSize = cacheSize;\n+    cache = CacheBuilder.newBuilder()\n+        .maximumSize(cacheMaxSize)\n+        .expireAfterAccess(3, TimeUnit.HOURS)\n+        .ticker(ticker)\n+        .build();\n   }\n \n   @Override\n-  public void setSort(boolean isSort) {\n-    this.isSort.set(isSort);\n+  public Optional<CopybookModel> getCopybookStorableFromCache(@NonNull String name) {\n+    return Optional.ofNullable(cache.getIfPresent(name));\n   }\n \n   @Override\n-  public synchronized void persist(@NonNull CopybookStorable deepCopy) {\n-    cpyRepo.removeIf(CopybookStorable::isExpired);\n-\n-    if (!isStored(deepCopy.getId())) {\n-      if (cpyRepo.size() < getCacheMaxSize()) {\n-        cpyRepo.add(deepCopy);\n-        return;\n-      }\n-      cpyRepo.remove(cpyRepo.size() - 1);\n-      cpyRepo.add(deepCopy);\n-    }\n+  public synchronized void persist(@NonNull CopybookModel copybookModel) {\n+    cache.put(copybookModel.getName(), copybookModel);\n   }\n \n   @Override\n   public String logContent() {\n-    StringBuilder chars = new StringBuilder();\n-    cpyRepo.forEach(\n-        l ->\n-            chars\n-                .append(System.getProperty(\"line.separator\"))\n-                .append(l)\n-                .append(System.getProperty(\"line.separator\")));\n-    return chars.toString();\n+    return cache.asMap().toString();\n   }\n \n   @Override\n   public int size() {\n-    return cpyRepo.size();\n-  }\n-\n-  public Optional<CopybookStorable> topItem() {\n-    return (cpyRepo.isEmpty()) ? Optional.empty() : Optional.of(cpyRepo.get(0));\n-  }\n-\n-  public Optional<CopybookStorable> lastItem() {\n-    return (cpyRepo.isEmpty()) ? Optional.empty() : Optional.of(cpyRepo.get(size() - 1));\n-  }\n-\n-  @Override\n-  public boolean isStored(@NonNull StringBuilder id) {\n-    long uuid = CopybookRepository.calculateUUID(id);\n-    return isStored(uuid);\n-  }\n-\n-  @Override\n-  public boolean isStored(@NonNull String id) {\n-    long uuid = CopybookRepository.calculateUUID(id);\n-    return isStored(uuid);\n+    return (int)cache.size();", "originalCommit": "129e8022cce87060d269afe45217ecb14d7bc898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ5NTAzNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r488495037", "bodyText": "Yes, it will be safe. Didn't know about this one.", "author": "grianbrcom", "createdAt": "2020-09-15T08:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NjI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxOTk4Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487819983", "bodyText": "can we safely reuse the instance of CopybookModel instead to create a new one?", "author": "zacanbrcom", "createdAt": "2020-09-14T10:47:26Z", "path": "server/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -113,7 +111,8 @@ public void observerCallback(@Nonnull FetchedCopybookEvent event) {\n     String content = event.getContent();\n \n     broker.unSubscribe(this);\n-    ofNullable(content).ifPresent(it -> broker.storeData(new CopybookStorable(name, uri, content)));\n+    CopybookModel copybookModel = new CopybookModel(name, uri, content);\n+    ofNullable(content).ifPresent(it -> broker.storeData(copybookModel));\n     waitForResolving.complete(new CopybookModel(name, uri, content));", "originalCommit": "129e8022cce87060d269afe45217ecb14d7bc898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ5NTg1OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r488495859", "bodyText": "Oops, my fault, I was planned to use the same copybookModel instance.", "author": "grianbrcom", "createdAt": "2020-09-15T08:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxOTk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNDE3Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487824173", "bodyText": "I think we may get rid of the \"dummy stuff\" loaded in this provider, I saw that in some test we create an instance of CopybookModel directly though its constuctor", "author": "zacanbrcom", "createdAt": "2020-09-14T10:55:43Z", "path": "server/src/test/java/com/broadcom/lsp/domain/CopybookStorableProvider.java", "diffHunk": "@@ -29,10 +29,10 @@\n   private static final String COPYBOOK_CONTENT = \"000000 IDENTIFICATION DIVISION.\";\n \n   @Singleton\n-  private static CopybookStorable STORABLE_INSTANCE =\n-      new CopybookStorable(COPYBOOK_NAME, COPYBOOK_URI, COPYBOOK_CONTENT);\n+  private static CopybookModel STORABLE_INSTANCE =\n+      new CopybookModel(COPYBOOK_NAME, COPYBOOK_URI, COPYBOOK_CONTENT);\n \n-  protected CopybookStorable getDummyStorable() {\n+  protected CopybookModel getDummyStorable() {", "originalCommit": "129e8022cce87060d269afe45217ecb14d7bc898", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNzAyMg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r487827022", "bodyText": "Question - not sure: can we use Duration.ofHours(3).toNanos()?", "author": "zacanbrcom", "createdAt": "2020-09-14T11:01:14Z", "path": "server/src/test/java/com/broadcom/lsp/domain/cobol/databus/impl/CopybookRepositoryLRUTest.java", "diffHunk": "@@ -58,37 +55,52 @@ void cacheSizeIsNotNegative() {\n   }\n \n   /**\n-   * This test verifies that a CopybookStorable object stored successfully in the cache. After\n+   * This test verifies that a CopybookModel object stored successfully in the cache. After\n    * calling the persist method, the cache size increased by one\n    */\n   @Test\n   void testPersist() {\n     var prevCacheSize = repository.size();\n-    repository.persist(new CopybookStorable(\"NEW_STO\", \"URI\", \"DUMMY CONTENT\"));\n+    repository.persist(new CopybookModel(\"NEW_STO\", \"URI\", \"DUMMY CONTENT\"));\n     assertEquals(repository.size(), prevCacheSize + 1);\n   }\n \n   /**\n    * This test validates that the cache is throwing the expired elements away, the elements which\n    * are older than 3h\n    *\n-   * @throws NoSuchFieldException\n    */\n   @Test\n-  void testCacheExpiration() throws NoSuchFieldException {\n-    var genDt = Instant.now().minus(4, ChronoUnit.HOURS).getEpochSecond();\n-    var storableCpy = new CopybookStorable(\"REMOVE\", \"URI\", \"DUMMY CONTENT\");\n+  void testCacheExpiration() {\n+    SettableTicker ticker = new SettableTicker();\n+    repository = new CopybookRepositoryLRU(CACHE_SIZE, ticker);\n+    repository.persist(new CopybookModel(\"REMOVE\", \"URI\", \"DUMMY CONTENT\"));\n+    ticker.incrementNanoseconds(1);\n+\n+    // then passed 3 hours\n+    ticker.incrementNanoseconds((long)3 * 60 * 60 * 1000000000);", "originalCommit": "129e8022cce87060d269afe45217ecb14d7bc898", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUwMzY3NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/517#discussion_r488503675", "bodyText": "Perfect! Thanks.", "author": "grianbrcom", "createdAt": "2020-09-15T08:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyNzAyMg=="}], "type": "inlineReview"}, {"oid": "551a51232283faf89a752a6bac3312d5587dfd4e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/551a51232283faf89a752a6bac3312d5587dfd4e", "message": "refactor: rewrite CopybookRepository to use Guava cache\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-09-15T09:20:21Z", "type": "commit"}, {"oid": "551a51232283faf89a752a6bac3312d5587dfd4e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/551a51232283faf89a752a6bac3312d5587dfd4e", "message": "refactor: rewrite CopybookRepository to use Guava cache\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-09-15T09:20:21Z", "type": "forcePushed"}]}