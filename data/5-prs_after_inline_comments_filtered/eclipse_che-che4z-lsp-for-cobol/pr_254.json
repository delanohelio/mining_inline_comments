{"pr_number": 254, "pr_title": "#251 - Fix nested copybook issue", "pr_createdAt": "2020-03-26T13:35:29Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254", "timeline": [{"oid": "c4b75eaf29a6963a6bf3a68a2dd450740ce1dbed", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c4b75eaf29a6963a6bf3a68a2dd450740ce1dbed", "message": "Move responsability on DependencyService and adjust unit test", "committedDate": "2020-03-16T11:44:12Z", "type": "commit"}, {"oid": "708562617e6ed5e71f4053455f01bb7f2d99b9de", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/708562617e6ed5e71f4053455f01bb7f2d99b9de", "message": "Refactor FSConfig file", "committedDate": "2020-03-20T09:00:52Z", "type": "commit"}, {"oid": "1955e9620852abcce2b851a85aeba80517c038bf", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1955e9620852abcce2b851a85aeba80517c038bf", "message": "update unit test and concrete implementation in CopybookDependencyServiceImpl", "committedDate": "2020-03-20T10:45:07Z", "type": "commit"}, {"oid": "335d28357e703ab0ebd3b66d817089c9c24a184d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/335d28357e703ab0ebd3b66d817089c9c24a184d", "message": "Fix lombok issue - need deep investigation", "committedDate": "2020-03-24T08:29:03Z", "type": "commit"}, {"oid": "2e0234e0afa9169c93f134b0383b64348fb100ca", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2e0234e0afa9169c93f134b0383b64348fb100ca", "message": "Add e2e test involving preprocessor and copybook service", "committedDate": "2020-03-26T07:55:38Z", "type": "commit"}, {"oid": "2b9c7edf64bd6732bf0e5246c9ad9150e46ae3fd", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2b9c7edf64bd6732bf0e5246c9ad9150e46ae3fd", "message": "Remove commented code after unit test refactoring", "committedDate": "2020-03-26T13:38:30Z", "type": "commit"}, {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "message": "Update Changelog", "committedDate": "2020-03-26T15:14:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MTIzMg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r398661232", "bodyText": "are you setting the workspaceFolders in dependencyService somewhere else?", "author": "sergiuilie", "createdAt": "2020-03-26T15:25:07Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())\n         .map(Collection::stream)\n         .orElseGet(Stream::empty)\n         .filter(Objects::nonNull)\n-        .map(this::resolveUriPath)\n+        .map(this::resolveURI)\n         .collect(Collectors.toList());\n   }\n \n   private List<WorkspaceFolder> getWorkspaceFolders() {\n     return workspaceFolders;\n   }\n \n-  /**\n-   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n-   * the FileSystemService, example: [input:\n-   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n-   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n-   *\n-   * @param it workspace folder\n-   * @return the Path of the workspace folder\n-   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n-   */\n-  private Path resolveUriPath(WorkspaceFolder it) {\n-    try {\n-      return Paths.get(new URI(it.getUri()).normalize());\n-    } catch (URISyntaxException e) {\n-      log.error(e.getMessage());\n-    }\n-    return null;\n+  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n+    return getPathFromURI(workspaceFolder.getUri());\n   }\n \n-  private Path getCopybookFolder(Path workspaceFolderPath) {\n+  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n     return Paths.get(workspaceFolderPath + filesystemSeparator() + COPYBOOK_FOLDER_NAME);\n   }\n \n   /** create the task and pass it to the executor service */\n   @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n     String requiredCopybookName = event.getName();\n-    String content = null;\n-    Path path;\n-\n-    // if the document is in DID_OPEN mode is possible write on dependency file..\n-    if (isFileInDidOpen(event)) {\n-      dependencyService.setWorkspaceFolderPaths(getWorkspaceFoldersAsPathList());", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDM3Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r398664373", "bodyText": "I guess here is the answer to the question if you are setting the workspaceFolders, correct?", "author": "sergiuilie", "createdAt": "2020-03-26T15:29:01Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())\n         .map(Collection::stream)\n         .orElseGet(Stream::empty)\n         .filter(Objects::nonNull)\n-        .map(this::resolveUriPath)\n+        .map(this::resolveURI)\n         .collect(Collectors.toList());\n   }\n \n   private List<WorkspaceFolder> getWorkspaceFolders() {\n     return workspaceFolders;\n   }\n \n-  /**\n-   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n-   * the FileSystemService, example: [input:\n-   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n-   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n-   *\n-   * @param it workspace folder\n-   * @return the Path of the workspace folder\n-   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n-   */\n-  private Path resolveUriPath(WorkspaceFolder it) {\n-    try {\n-      return Paths.get(new URI(it.getUri()).normalize());\n-    } catch (URISyntaxException e) {\n-      log.error(e.getMessage());\n-    }\n-    return null;\n+  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n+    return getPathFromURI(workspaceFolder.getUri());\n   }\n \n-  private Path getCopybookFolder(Path workspaceFolderPath) {\n+  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n     return Paths.get(workspaceFolderPath + filesystemSeparator() + COPYBOOK_FOLDER_NAME);\n   }\n \n   /** create the task and pass it to the executor service */\n   @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n     String requiredCopybookName = event.getName();\n-    String content = null;\n-    Path path;\n-\n-    // if the document is in DID_OPEN mode is possible write on dependency file..\n-    if (isFileInDidOpen(event)) {\n-      dependencyService.setWorkspaceFolderPaths(getWorkspaceFoldersAsPathList());\n-      dependencyService.addCopybookInDepFile(requiredCopybookName, event.getDocumentUri());\n-    }\n-\n-    if (missingInformationToSearchCopybooks()) {\n-      selectAppropriateMessageForCommunication();\n \n-      dataBus.postData(\n-          FetchedCopybookEvent.builder()\n-              .name(requiredCopybookName)\n-              .uri(null)\n-              .content(null)\n-              .build());\n-      return;\n-    }\n-\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-\n-    // search the copybook against the target folders provided from the settings\n-    path =\n-        findCopybook(\n-            requiredCopybookName,\n-            (String) configurationSettingsStorable.getProfiles(),\n-            configurationSettingsStorable.getPaths());\n-\n-    if (isFileExists(path)) {\n-      content = retrieveContentByPath(path);\n-    }\n-\n-    dataBus.postData(\n-        FetchedCopybookEvent.builder()\n-            .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n-            .content(content)\n-            .build());\n+    dependencyService.addCopybookInDepFile(\n+        event, requiredCopybookName, getWorkspaceFoldersAsPathList());", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY3NTMwNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r398675307", "bodyText": "if two dependency files are created then do we need to update both .dep files?", "author": "sergiuilie", "createdAt": "2020-03-26T15:42:28Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/CopybookServiceE2ETest.java", "diffHunk": "@@ -158,4 +162,60 @@ private void waitAndAssert(Boolean expected) {\n       fail(e.getMessage());\n     }\n   }\n+\n+  /**\n+   * This test verify that when a nested copybook is processed a new dependency file is created. So", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTExNDY3NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r399114675", "bodyText": "Well..is not a easy question: if the user modify the copy instruction in the cobol file only the first dep file created should be modified. I think the implementation on your side is still ok.", "author": "zacanbrcom", "createdAt": "2020-03-27T08:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY3NTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI3Njc2Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400276767", "bodyText": "Paths#get() documentation recommends to use workspaceFolderPath.resolve(COPYBOOK_FOLDER_NAME) here", "author": "temanbrcom", "createdAt": "2020-03-30T15:19:33Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())\n         .map(Collection::stream)\n         .orElseGet(Stream::empty)\n         .filter(Objects::nonNull)\n-        .map(this::resolveUriPath)\n+        .map(this::resolveURI)\n         .collect(Collectors.toList());\n   }\n \n   private List<WorkspaceFolder> getWorkspaceFolders() {\n     return workspaceFolders;\n   }\n \n-  /**\n-   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n-   * the FileSystemService, example: [input:\n-   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n-   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n-   *\n-   * @param it workspace folder\n-   * @return the Path of the workspace folder\n-   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n-   */\n-  private Path resolveUriPath(WorkspaceFolder it) {\n-    try {\n-      return Paths.get(new URI(it.getUri()).normalize());\n-    } catch (URISyntaxException e) {\n-      log.error(e.getMessage());\n-    }\n-    return null;\n+  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n+    return getPathFromURI(workspaceFolder.getUri());\n   }\n \n-  private Path getCopybookFolder(Path workspaceFolderPath) {\n+  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n     return Paths.get(workspaceFolderPath + filesystemSeparator() + COPYBOOK_FOLDER_NAME);", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg4OTk4Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400889986", "bodyText": "For what I read from the documentation:\n\nNote that while this method is very convenient, using it will imply an assumed reference to the default FileSystem and limit the utility of the calling code. Hence it should not be used in library code intended for flexible reuse. A more flexible alternative is to use an existing Path instance as an anchor, such as:\nPath dir = ...\nPath path = dir.resolve(\"file\");\n\n\nthe recommendation is to use dir.resolve to avoid problem with different filesystems, but cause in my implementation I have the method filesystemSeparator() that should avoid problems with different FS I think we can choose to modify or leave like this. BTW I will give a try as low priority request of change if you agree.", "author": "zacanbrcom", "createdAt": "2020-03-31T12:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI3Njc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MDc3Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400290776", "bodyText": "The file separators are not required for the Paths#get() method", "author": "temanbrcom", "createdAt": "2020-03-30T15:37:27Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java", "diffHunk": "@@ -108,4 +114,143 @@ public static String decodeURI(String uri) {\n       return uri;\n     }\n   }\n+\n+  /**\n+   * This method return a {@link Path} representation of a bunch of {@link String} given as input or\n+   * null if is not possible get the path. After each pah a FS separator is added automatically\n+   *\n+   * @param basePath the string that represent the base path\n+   * @param more additional String used to compose the path\n+   * @return the {@link Path} that contains all the given segment, null if the path doesn't exists.\n+   */\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MzYzOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400293639", "bodyText": "You may use Files#exists to match the Law of Demetra", "author": "temanbrcom", "createdAt": "2020-03-30T15:41:06Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java", "diffHunk": "@@ -108,4 +114,143 @@ public static String decodeURI(String uri) {\n       return uri;\n     }\n   }\n+\n+  /**\n+   * This method return a {@link Path} representation of a bunch of {@link String} given as input or\n+   * null if is not possible get the path. After each pah a FS separator is added automatically\n+   *\n+   * @param basePath the string that represent the base path\n+   * @param more additional String used to compose the path\n+   * @return the {@link Path} that contains all the given segment, null if the path doesn't exists.\n+   */\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(\n+        basePath,\n+        filesystemSeparator(),\n+        Arrays.stream(more)\n+            .map(path -> path + filesystemSeparator())\n+            .collect(Collectors.joining()));\n+  }\n+\n+  /**\n+   * This method create a folder from a given path\n+   *\n+   * @param path in input that will be used to create the folder\n+   */\n+  public void createFolder(Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a file on filesystem from a given {@link Path}\n+   *\n+   * @param path target path that will be used to create the file\n+   */\n+  public void createFile(Path path) {\n+    if (!path.toFile().exists()) {", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMwNDY1Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400304652", "bodyText": "Nice reference to the Demetra's Law!\nBtw I followed this suggestion from sonarcloud: https://rules.sonarsource.com/java/tag/performance/RSPEC-3725", "author": "andzac", "createdAt": "2020-03-30T15:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MzYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgwMTEyOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400801129", "bodyText": "Oh, I didn't know that, thanks!", "author": "temanbrcom", "createdAt": "2020-03-31T10:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MzYzOQ=="}], "type": "inlineReview"}, {"oid": "9cb39ef8ac7bd1371edaa69cb4ca142edc7700a9", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9cb39ef8ac7bd1371edaa69cb4ca142edc7700a9", "message": "Merge remote-tracking branch 'remotes/origin/development' into 251_AddNestedCpyInDep\n\n# Conflicts:\n#\tCHANGELOG.md\n#\tclients/cobol-lsp-vscode-extension/CHANGELOG.md\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/FileSystemConfiguration.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/DependencyServiceTest.java", "committedDate": "2020-03-31T07:35:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc1NjcwNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400756706", "bodyText": "why are there two methods which are doing most likely the same thing? isDocumentInDidOpen and isFileInDidOpen", "author": "sergiuilie", "createdAt": "2020-03-31T09:07:59Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java", "diffHunk": "@@ -40,6 +36,46 @@\n   private static final String DEP_EXTENSION = \".dep\";\n   @Getter private List<Path> workspaceFolderPaths;\n \n+  /**\n+   * This method is invoked to handle the insertion of a copybook name into the dependency file\n+   *\n+   * @param event contains information the copybook (document URI and event sync type)\n+   * @param requiredCopybookName name that represent the new copybook that is supposed to be written\n+   * @param targetPaths the reference path where create or search a dependency file.\n+   */\n+  @Override\n+  public void addCopybookInDepFile(\n+      RequiredCopybookEvent event, String requiredCopybookName, List<Path> targetPaths) {\n+    setWorkspaceFolderPaths(targetPaths);\n+    if (isFileInDidOpen(event) || isNestedCopybookBeProcessed(event)) {\n+      writeCopybookInDepFile(requiredCopybookName, event.getDocumentUri());\n+    }\n+  }\n+\n+  private boolean isNestedCopybookBeProcessed(RequiredCopybookEvent event) {\n+    return isDocumentInDidOpen(event)\n+        && getExtensionFromURI(event.getDocumentUri()).equalsIgnoreCase(\"cpy\");\n+  }\n+\n+  private boolean isDocumentInDidOpen(RequiredCopybookEvent event) {", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MjcxNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400772716", "bodyText": "cause I missed it \ud83d\udc4d", "author": "zacanbrcom", "createdAt": "2020-03-31T09:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc1NjcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3Njg5NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400776894", "bodyText": "\ud83e\udd84", "author": "sergiuilie", "createdAt": "2020-03-31T09:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc1NjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5NjAzMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400796031", "bodyText": "As I can see, here you change the internal state with the same information every time. Maybe, you may set the workspaceFolderPaths on initialization or pass it to the following methods, not touching the state of the object?", "author": "temanbrcom", "createdAt": "2020-03-31T10:11:18Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java", "diffHunk": "@@ -40,6 +36,46 @@\n   private static final String DEP_EXTENSION = \".dep\";\n   @Getter private List<Path> workspaceFolderPaths;\n \n+  /**\n+   * This method is invoked to handle the insertion of a copybook name into the dependency file\n+   *\n+   * @param event contains information the copybook (document URI and event sync type)\n+   * @param requiredCopybookName name that represent the new copybook that is supposed to be written\n+   * @param targetPaths the reference path where create or search a dependency file.\n+   */\n+  @Override\n+  public void addCopybookInDepFile(\n+      RequiredCopybookEvent event, String requiredCopybookName, List<Path> targetPaths) {\n+    setWorkspaceFolderPaths(targetPaths);", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5ODU3MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400798570", "bodyText": "Do we assume the workspace folders as static? If yes, we may save the result of getWorkspaceFoldersAsPathList() instead of storing the workspaceFolders. It will allow us not to repeat this conversion every time.", "author": "temanbrcom", "createdAt": "2020-03-31T10:15:35Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQxNDI1Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401414256", "bodyText": "Is allowed to change the value of WorkspaceFolders cause the user can open a new workspace and at the initialize handshake we'll get the new value of that.\nI solved in a way that when setWorkspaceFolders() is triggered, we calculate the List<Path> from that and store it internally. No one will calculate again this list (until you close and open a new workspace in the IDE)", "author": "zacanbrcom", "createdAt": "2020-04-01T07:40:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5ODU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNzk5NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401437995", "bodyText": "If I understand correctly, we will restart the server if the user does this due to the client also restarts. If yes, then from our point of view the workspace folders are static and may be set at the initialization.", "author": "temanbrcom", "createdAt": "2020-04-01T08:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5ODU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NDg1Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401444853", "bodyText": "But if you close a workspace folder the server will go in shutdown? If yes what you said is correct but more in general I prefer don't rely on static things, we control when the List is generated and I think it should be enough robust - is my opinion of course.", "author": "zacanbrcom", "createdAt": "2020-04-01T08:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5ODU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2OTk4Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401469982", "bodyText": "Static here is not from the Java point of view, it is more about that this won't change during the application lifecycle", "author": "temanbrcom", "createdAt": "2020-04-01T09:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5ODU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ4MDQwNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401480407", "bodyText": "I'd like to postpone this discussion when I will commit the changes, I found a violation of responsibility in the CopybookDependencyServiceImpl and I'm working hard to refactor this thing.", "author": "zacanbrcom", "createdAt": "2020-04-01T09:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5ODU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgwMDUzMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400800530", "bodyText": "Due to we call this setter only on the initialization, we may replace it with an assisted injection to disallow the changing of the object's internal state.", "author": "temanbrcom", "createdAt": "2020-03-31T10:18:53Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -80,21 +75,6 @@ public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n     this.workspaceFolders = workspaceFolders;", "originalCommit": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQyNTcxNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401425715", "bodyText": "Not sure I can apply this due to my reply here", "author": "zacanbrcom", "createdAt": "2020-04-01T08:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgwMDUzMA=="}], "type": "inlineReview"}, {"oid": "8f624c3754e2964eeb0a05fadc8bbb21d6c59cdb", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8f624c3754e2964eeb0a05fadc8bbb21d6c59cdb", "message": "Address request of change", "committedDate": "2020-04-01T08:02:54Z", "type": "commit"}, {"oid": "2a3bbeb6ee3d1f277b59e009d3e090edbef6c930", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a3bbeb6ee3d1f277b59e009d3e090edbef6c930", "message": "Refactor CopybookDependencyServiceImpl.java", "committedDate": "2020-04-01T11:36:27Z", "type": "commit"}, {"oid": "3f7c9367178af65605d1c59635a5d777c1b43a5e", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3f7c9367178af65605d1c59635a5d777c1b43a5e", "message": "Polish CopybookDependencyServiceImpl & FileSystemUtils.java", "committedDate": "2020-04-01T11:47:18Z", "type": "commit"}, {"oid": "d7052edcd559b47a5c154597b449d469d5ae2cbf", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d7052edcd559b47a5c154597b449d469d5ae2cbf", "message": "Fix extra chars in javadoc", "committedDate": "2020-04-01T12:50:53Z", "type": "commit"}, {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/795d4728b44d2a7f039d0e6e67e36eab727d1af8", "message": "Cleanup FileSystemUtils.java", "committedDate": "2020-04-01T12:53:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2MTQ4Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401661487", "bodyText": "Seems like you don't need to store the list of WorkspaceFolder at all - you convert them on the initialization and then don't use anymore", "author": "temanbrcom", "createdAt": "2020-04-01T14:31:34Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -52,6 +46,8 @@\n   private static final String COPYBOOK_FOLDER_NAME = \".copybooks\";\n   private final DataBusBroker dataBus;\n   private List<WorkspaceFolder> workspaceFolders;", "originalCommit": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNjIwOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401716209", "bodyText": "Correct, I will simplify the chain to create the list of paths", "author": "zacanbrcom", "createdAt": "2020-04-01T15:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2MTQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2NDI3Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401664273", "bodyText": "Seems like this is the responsibility of MyLanguageServer on the initialization or of Guice using assisted injection.", "author": "temanbrcom", "createdAt": "2020-04-01T14:35:10Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -71,28 +67,23 @@ public CopybookServiceImpl(\n   }\n \n   /**\n-   * Store the informations about the workspace folder defined by the client IDE\n+   * Store the information about the workspace folders defined by the client IDE\n    *\n    * @param workspaceFolders list of workspace folders sent by the client to the server\n    */\n   @Override\n   public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n     this.workspaceFolders = workspaceFolders;\n+    createPathListFromWorkspaceFolders();\n+    setPathListInDependencyFile();\n   }\n \n-  /**\n-   * @param uriForFileName of copybook found under workspace folder\n-   * @return content of the file as String content\n-   */\n-  @Nullable\n-  String retrieveContentByPath(Path uriForFileName) {\n-    String content = null;\n-    try (Stream<String> stream = Files.lines(uriForFileName)) {\n-      content = stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-    }\n-    return content;\n+  private void createPathListFromWorkspaceFolders() {\n+    workspaceFolderPaths = getWorkspaceFoldersAsPathList();\n+  }\n+\n+  private void setPathListInDependencyFile() {", "originalCommit": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2OTA1MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401669051", "bodyText": "The resolveUriPath() is not used", "author": "temanbrcom", "createdAt": "2020-04-01T14:41:44Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java", "diffHunk": "@@ -112,43 +114,153 @@ public static String decodeURI(String uri) {\n   }\n \n   /**\n-   * @param workspaceFolders folders which are provided at the init moment\n-   * @return a list of path of those folders\n+   * This method return a {@link Path} representation of a bunch of {@link String} given as input or\n+   * null if is not possible get the path. After each pah a FS separator is added automatically\n+   *\n+   * @param basePath the string that represent the base path\n+   * @param more additional String used to compose the path\n+   * @return the {@link Path} that contains all the given segment, null if the path doesn't exists.\n    */\n-  public List<Path> getWorkspaceFoldersAsPathList(List<WorkspaceFolder> workspaceFolders) {\n-    return Optional.ofNullable(workspaceFolders)\n-        .map(Collection::stream)\n-        .orElseGet(Stream::empty)\n-        .filter(Objects::nonNull)\n-        .map(FileSystemUtils::resolveUriPath)\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  /**\n+   * This method return the list of paths represented by a fixed part (outer + inner) and a variable\n+   * part iterated to obtains path in this form: {[base,middle,v1],[base,middle,v2], ...}\n+   *\n+   * @param outer first level of folder\n+   * @param inner second level of folder (represent the name of an inner folder)\n+   * @param variablePart list of names of folders that are contained inside the inner\n+   * @return a lis of paths represented in the way: {[outer,inner,v1],[outer,inner,v2], ...}\n+   */\n+  public List<Path> getPathList(@Nonnull String outer, String inner, List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, inner, it))\n+        .filter(Files::exists)\n         .collect(Collectors.toList());\n   }\n \n   /**\n-   * This method can be used to extract the name of a given COBOL file from the URI\n+   * This method create a folder from a given path\n+   *\n+   * @param path in input that will be used to create the folder\n+   */\n+  public void createFolder(Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a file on filesystem from a given {@link Path}\n    *\n-   * @param documentUri\n-   * @return the cobol program name from the given URI\n+   * @param path target path that will be used to create the file\n    */\n-  public String getFileNameFromURI(String documentUri) {\n-    String result = null;\n+  public void createFile(Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(e.getMessage());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method extract the name of a file from a valid {@link URI} and return the name back to the\n+   * client as String or null in case of error.\n+   *\n+   * @param uri the reference of the file from where extract the name\n+   * @return the String representation of the file name or null if any {@link URISyntaxException} is\n+   *     caught.\n+   */\n+  public String getNameFromURI(String uri) {\n     try {\n-      result = FilenameUtils.getBaseName(Paths.get(new URI(documentUri)).getFileName().toString());\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n     } catch (URISyntaxException e) {\n       log.error(e.getMessage());\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * This method extract the file extension from the {@link URI} given as input\n+   *\n+   * @param uri reference to the file from where extract the file extension\n+   * @return the String representation of the file extension or null if the URI is not valid\n+   */\n+  public String getExtensionFromURI(String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  /**\n+   * This method retrieve the content of a dependency file and return it back to the callee.\n+   *\n+   * @param filePath target path of the file\n+   * @return the content of the dependency file or null if doesn't exists\n+   */\n+  public List<String> getContentFromFile(Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  /**\n+   * @param path URI from where extract the content\n+   * @return content of the file as String representation\n+   */\n+  @Nullable\n+  public String getContentByPath(Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * @param fileName file to search\n+   * @param targetFolderPath physical path where to search for the file\n+   * @return Path of the found copybook in the target folder.\n+   */\n+  public Path applySearch(String fileName, Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+      return null;\n     }\n-    return result;\n   }\n \n   /**\n-   * This method provides the path to a specific file based on the COBOL file\n+   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n+   * the FileSystemService, example: [input:\n+   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n+   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n    *\n-   * @param dependencyFolderPath the folder where we are creating the dependency file\n-   * @param cobolFileName\n-   * @return the path of the dependency file\n+   * @param uri {@link URI} representation of a file\n+   * @return the {@link Path} representation of the given URI in input\n+   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n    */\n-  public Path retrieveDependencyFile(Path dependencyFolderPath, String cobolFileName) {\n-    return Paths.get(dependencyFolderPath + filesystemSeparator() + cobolFileName + DEP_EXTENSION);\n+  public Path getPathFromURI(String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(e.getMessage());\n+      return null;\n+    }\n   }\n \n   /**", "originalCommit": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxMTc5NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401711794", "bodyText": ":( I missed that good guy, now is gone!", "author": "zacanbrcom", "createdAt": "2020-04-01T15:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2OTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MTM3OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401671378", "bodyText": "This is an exposure of implementation details to the public interface. Not critical, just bad practice.", "author": "temanbrcom", "createdAt": "2020-04-01T14:44:46Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyService.java", "diffHunk": "@@ -24,11 +26,14 @@\n  * management\n  */\n public interface CopybookDependencyService {\n+\n+  void addCopybookInDepFile(RequiredCopybookEvent event, String requiredCopybookName);\n+\n+  boolean isFileInDidOpen(RequiredCopybookEvent event);", "originalCommit": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxMDc2Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401710767", "bodyText": "It was a temporary solution waiting for Powermock since I need to use this method in unit test.", "author": "zacanbrcom", "createdAt": "2020-04-01T15:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MjMxMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401672311", "bodyText": "A typo in the method name", "author": "temanbrcom", "createdAt": "2020-04-01T14:45:54Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java", "diffHunk": "@@ -64,24 +58,62 @@ public CopybookDependencyServiceImpl(\n   }\n \n   /**\n-   * This method write the copybook name sent by the {@link CopybookServiceImpl} into the dependency\n-   * file.\n+   * This method is invoked to handle the insertion of a copybook name into the dependency file\n    *\n-   * @param requiredCopybookName copybook name that should be written in the dependency file\n-   * @param documentUri extract the name of the cobol file from the URI\n+   * @param event contains information the copybook (document URI and event sync type)\n+   * @param requiredCopybookName name that represent the new copybook that is supposed to be written\n    */\n-  @Beta\n   @Override\n-  public void addCopybookInDepFile(String requiredCopybookName, String documentUri) {\n-    String cobolFileName = getFileNameFromURI(documentUri);\n-    Path dependencyFolderPath = createDependencyFileFolder();\n-    Path dependencyFile = retrieveDependencyFile(dependencyFolderPath, cobolFileName);\n+  public void addCopybookInDepFile(RequiredCopybookEvent event, String requiredCopybookName) {\n+    if (isFileInDidOpen(event) || isProcessingACopybbok(event)) {\n+      writeCopybookInDepFile(requiredCopybookName, event.getDocumentUri());\n+    }\n+  }\n+\n+  private boolean isProcessingACopybbok(RequiredCopybookEvent event) {", "originalCommit": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3NzQ2Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401677467", "bodyText": "I think we will receive a method name code smell here and for two more methods in this class", "author": "temanbrcom", "createdAt": "2020-04-01T14:52:41Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/CopybookServiceE2ETest.java", "diffHunk": "@@ -79,62 +84,60 @@ public void initActivities() {\n    * file.\n    */\n   @Test\n-  public void generateDependencyFileOnCallbackPositiveTest() {\n-\n-    // generate a required copybook event\n+  public void publishRequestOfCopybook_createDependencyFile() {\n     broker.postData(\n         RequiredCopybookEvent.builder()\n             .name(CPY_NAME_WITHOUT_EXT)\n-            .documentUri(DOCUMENT_URI)\n+            .documentUri(COBOL_FILE_DOCUMENT_URI)\n             .textDocumentSyncType(\"DID_OPEN\")\n             .build());\n+\n     // after one second is expected to found the dep file on filesystem\n-    waitAndAssert(Boolean.TRUE);\n+    waitAndAssert_DepFileIsCreated(Boolean.TRUE);\n   }\n \n   /**\n    * This test verify that when the preprocessor publish a require copybook event without specifying\n    * the TextDocumentSync type, the FileSystem service will not write/update any dependency file.\n    */\n   @Test\n-  public void NotGenerateDependencyFileOnCallbackNegativeTest() {\n-    // generate a required copybook event\n+  public void noTextDocSyncTypeDefined_NoDependencyFileIsCreated() {\n     broker.postData(\n         RequiredCopybookEvent.builder()\n             .name(CPY_NAME_WITHOUT_EXT)\n-            .documentUri(DOCUMENT_URI)\n+            .documentUri(COBOL_FILE_DOCUMENT_URI)\n             .build());\n+\n     // after one second is expected to found the dep file on filesystem\n-    waitAndAssert(Boolean.FALSE);\n+    waitAndAssert_DepFileIsCreated(Boolean.FALSE);\n   }\n \n   /**\n    * This test verify that when the preprocessor publish a require copybook event when the document\n    * is in DID_CHANGE mode and the FileSystem service will not write/update any dependency file.\n    */\n   @Test\n-  public void NotGenerateDependencyFileOnDidChangeTest() {\n-    // generate a required copybook event\n+  public void DocumentInDidChangeMode_NoDepFileIsCreated() {\n     broker.postData(\n         RequiredCopybookEvent.builder()\n             .name(CPY_NAME_WITHOUT_EXT)\n-            .documentUri(DOCUMENT_URI)\n+            .documentUri(COBOL_FILE_DOCUMENT_URI)\n             .textDocumentSyncType(\"DID_CHANGE\")\n             .build());\n     // after one second is expected to found the dep file on filesystem\n-    waitAndAssert(Boolean.FALSE);\n+    waitAndAssert_DepFileIsCreated(Boolean.FALSE);\n   }\n \n   /**\n    * This test verify that when a non required event is published on the databus, the dependency\n    * file is not created. This test assume that .cobdep folder exists but no depfile is created.\n    */\n   @Test\n-  public void noDependencyFileWithOtherEvent() {\n+  public void unknownEventPublished_NoDepFileIsCreated() {", "originalCommit": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcwNjcxMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401706713", "bodyText": "Purpose of unit test is to be clear for who run the test. There is a code smell about regex for the method (underline is not allowed). But for me help the developer to understand the purpose of the tests is much more important then the camel case that in past created cryptic method name.\nAnd I applied this practice only on unit test methods.", "author": "zacanbrcom", "createdAt": "2020-04-01T15:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3NzQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3OTQ3NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401679475", "bodyText": "I would prefer to avoid using Guice in tests and call the observer callback directly, but it is not critical at the moment and we may do it later", "author": "temanbrcom", "createdAt": "2020-04-01T14:55:12Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/DependencyServiceTest.java", "diffHunk": "@@ -45,53 +47,77 @@\n /** This class represent all the unit test for the copybook dependency managament service */\n @Slf4j\n public class DependencyServiceTest extends FileSystemConfiguration {\n+  public static final String NESTED_CPY_NAME = \"CPYNEST2\";\n   private final DataBusBroker broker =\n       Guice.createInjector(new DatabusModule()).getInstance(DataBusBroker.class);", "originalCommit": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxMjU3MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401712570", "bodyText": "I agree to postpone, since many unit test classes are affected by this problem. We can wrap all together in a TD userstory.", "author": "zacanbrcom", "createdAt": "2020-04-01T15:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3OTQ3NQ=="}], "type": "inlineReview"}]}