{"pr_number": 439, "pr_title": "feat: Outline view support", "pr_createdAt": "2020-07-23T14:02:37Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439", "timeline": [{"oid": "bfcbc0889d7e5e7548da611d9d78118db624e863", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/bfcbc0889d7e5e7548da611d9d78118db624e863", "message": "feat: Outline view support\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-07-27T13:57:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MDA2Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462870067", "bodyText": "no need this null init.", "author": "asatklichov", "createdAt": "2020-07-30T09:27:47Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/SemanticContext.java", "diffHunk": "@@ -18,16 +18,30 @@\n \n import com.ca.lsp.core.cobol.model.CopybookUsage;\n import com.ca.lsp.core.cobol.model.CopybookSemanticContext;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n import lombok.Value;\n \n import java.util.List;\n \n @Value\n+@AllArgsConstructor()\n+@Builder(toBuilder = true)\n public class SemanticContext {\n-  private CobolVariableContext variables = new CobolVariableContext();\n-  private SubContext<String> paragraphs = new CobolNamedContext();\n-  private SubContext<String> copybooks = new CobolNamedContext();\n+  private CobolVariableContext variables;\n+  private SubContext<String> paragraphs;\n+  private SubContext<String> copybooks;\n   private List<CopybookUsage> copybookUsageTracker;\n+  private OutlineTree outlineTree;\n+\n+  public SemanticContext(List<CopybookUsage> copybookUsageTracker) {\n+    variables = new CobolVariableContext();\n+    paragraphs = new CobolNamedContext();\n+    copybooks = new CobolNamedContext();\n+    this.copybookUsageTracker = copybookUsageTracker;\n+    outlineTree = null;", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY0NDAxNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r463644016", "bodyText": "It needs to be here because of Lombok magic. We use Lombok for this class and that means no default initialization.", "author": "grianbrcom", "createdAt": "2020-07-31T14:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg3MDA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1MTIzNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462951235", "bodyText": "name.strip() is unicode aware on whitespaces", "author": "asatklichov", "createdAt": "2020-07-30T12:11:27Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/outline/OutlineTreeBuilder.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.Token;\n+\n+import java.util.*;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+@Slf4j\n+public class OutlineTreeBuilder {\n+  private List<OutlineNode> rootNodes = new ArrayList<>();\n+  private Map<ParserRuleContext, OutlineNode> nodesByContext = new HashMap<>();\n+  private Deque<Variable> variables;\n+  private OutlineNode latestVariable;\n+\n+  public void addProgram(ParserRuleContext parserRuleContext) {\n+    OutlineNode outlineNode = constructNode(null, NodeType.PROGRAM, parserRuleContext);\n+    rootNodes.add(outlineNode);\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+  }\n+\n+  public void addNodeToParent(String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    name = name.trim();\n+    OutlineNode outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    addNodeToParent(outlineNode, parserRuleContext);\n+  }\n+\n+  private void addNodeToParent(OutlineNode outlineNode, ParserRuleContext parserRuleContext) {\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      OutlineNode parentNode = nodesByContext.get(parent);\n+      if (parentNode != null) {\n+        parentNode.getNestedNodes().add(outlineNode);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    rootNodes.add(outlineNode);\n+  }\n+\n+  public void renameProgram(String name, ParserRuleContext parserRuleContext) {\n+    name = name.trim();", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY0NDA3Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r463644073", "bodyText": "You are right, but I realize that I don't need to do it here. Antlr did all the job.", "author": "grianbrcom", "createdAt": "2020-07-31T14:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1MTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1MjQ5OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462952499", "bodyText": "name.strip()", "author": "asatklichov", "createdAt": "2020-07-30T12:13:59Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/outline/OutlineTreeBuilder.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.Token;\n+\n+import java.util.*;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+@Slf4j\n+public class OutlineTreeBuilder {\n+  private List<OutlineNode> rootNodes = new ArrayList<>();\n+  private Map<ParserRuleContext, OutlineNode> nodesByContext = new HashMap<>();\n+  private Deque<Variable> variables;\n+  private OutlineNode latestVariable;\n+\n+  public void addProgram(ParserRuleContext parserRuleContext) {\n+    OutlineNode outlineNode = constructNode(null, NodeType.PROGRAM, parserRuleContext);\n+    rootNodes.add(outlineNode);\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+  }\n+\n+  public void addNodeToParent(String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    name = name.trim();\n+    OutlineNode outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    addNodeToParent(outlineNode, parserRuleContext);\n+  }\n+\n+  private void addNodeToParent(OutlineNode outlineNode, ParserRuleContext parserRuleContext) {\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      OutlineNode parentNode = nodesByContext.get(parent);\n+      if (parentNode != null) {\n+        parentNode.getNestedNodes().add(outlineNode);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    rootNodes.add(outlineNode);\n+  }\n+\n+  public void renameProgram(String name, ParserRuleContext parserRuleContext) {\n+    name = name.trim();\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      OutlineNode parentNode = nodesByContext.get(parent);\n+      if (parentNode != null && parentNode.getNodeType() == NodeType.PROGRAM) {\n+        parentNode.setName(name);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    LOG.warn(\"Can't rename program '{}'. Program node is not found.\", name);\n+  }\n+\n+  public void initVariables() {\n+    variables = new ArrayDeque<>();\n+    latestVariable = null;\n+  }\n+\n+  public void addVariable(int level, String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    name = name.trim();", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1NDAxMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462954010", "bodyText": "List.of()", "author": "asatklichov", "createdAt": "2020-07-30T12:16:56Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/outline/OutlineTreeBuilder.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.Token;\n+\n+import java.util.*;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+@Slf4j\n+public class OutlineTreeBuilder {\n+  private List<OutlineNode> rootNodes = new ArrayList<>();\n+  private Map<ParserRuleContext, OutlineNode> nodesByContext = new HashMap<>();\n+  private Deque<Variable> variables;\n+  private OutlineNode latestVariable;\n+\n+  public void addProgram(ParserRuleContext parserRuleContext) {\n+    OutlineNode outlineNode = constructNode(null, NodeType.PROGRAM, parserRuleContext);\n+    rootNodes.add(outlineNode);\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+  }\n+\n+  public void addNodeToParent(String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    name = name.trim();\n+    OutlineNode outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    addNodeToParent(outlineNode, parserRuleContext);\n+  }\n+\n+  private void addNodeToParent(OutlineNode outlineNode, ParserRuleContext parserRuleContext) {\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      OutlineNode parentNode = nodesByContext.get(parent);\n+      if (parentNode != null) {\n+        parentNode.getNestedNodes().add(outlineNode);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    rootNodes.add(outlineNode);\n+  }\n+\n+  public void renameProgram(String name, ParserRuleContext parserRuleContext) {\n+    name = name.trim();\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      OutlineNode parentNode = nodesByContext.get(parent);\n+      if (parentNode != null && parentNode.getNodeType() == NodeType.PROGRAM) {\n+        parentNode.setName(name);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    LOG.warn(\"Can't rename program '{}'. Program node is not found.\", name);\n+  }\n+\n+  public void initVariables() {\n+    variables = new ArrayDeque<>();\n+    latestVariable = null;\n+  }\n+\n+  public void addVariable(int level, String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    name = name.trim();\n+    while (!variables.isEmpty() && variables.peekLast().level >= level) {\n+      variables.removeLast();\n+    }\n+    Variable groupItem = variables.peekLast();\n+    OutlineNode outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    if (level == 88) {\n+      if (latestVariable == null) {\n+        addNodeToParent(outlineNode, parserRuleContext);\n+      } else {\n+        latestVariable.getNestedNodes().add(outlineNode);\n+      }\n+      return;\n+    }\n+    latestVariable = outlineNode;\n+    if (groupItem != null) {\n+      groupItem.outlineNode.getNestedNodes().add(outlineNode);\n+    } else {\n+      addNodeToParent(outlineNode, parserRuleContext);\n+    }\n+    if (NodeType.STRUCT == nodeType ||\n+        NodeType.REDEFINES == nodeType) {\n+      variables.addLast(new Variable(level, outlineNode));\n+    }\n+  }\n+\n+  public OutlineTree build(Multimap<String, Position> copybookUsages) {\n+    rootNodes.forEach(this::recalculateStructRange);\n+    for (Map.Entry<String, Position> copybook: copybookUsages.entries()) {\n+      String name = copybook.getKey();\n+      Position position = copybook.getValue();\n+      OutlineRange outlineRange = new OutlineRange(\n+          new OutlinePosition(position.getLine(), position.getCharPositionInLine()),\n+          new OutlinePosition(position.getLine(), position.getCharPositionInLine()+name.length())\n+      );\n+      OutlineNode outlineNode = new OutlineNode(\"COPY \" + name, NodeType.COPYBOOK, outlineRange, ImmutableList.of());", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1NjQ1MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462956450", "bodyText": "These divisions are good candidates to be reused, would be better to define them either const or enum \"PROCEDURE DIVISION\", \"ENVIRONMENT DIVISION\", \"DATA DIVISION\"", "author": "asatklichov", "createdAt": "2020-07-30T12:21:31Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -64,35 +70,31 @@ public CobolVisitor(\n   public Class visitIdentificationDivision(IdentificationDivisionContext ctx) {\n     Token token = ctx.getStart();\n     areaAWarning(ctx.start.getCharPositionInLine(), token.getText(), token.getLine());\n-    return visitChildren(ctx);\n-  }\n-\n-  @Override\n-  public Class visitProgramIdParagraph(ProgramIdParagraphContext ctx) {\n-    if (ctx.programName() != null) {\n-      programName = ctx.programName().getText();\n-    }\n+    outlineTreeBuilder.addNodeToParent(\"IDENTIFICATION DIVISION\", NodeType.DIVISION, ctx);\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitProcedureDivision(ProcedureDivisionContext ctx) {\n     Token token = ctx.getStart();\n     areaAWarning(ctx.start.getCharPositionInLine(), token.getText(), token.getLine());\n+    outlineTreeBuilder.addNodeToParent(\"PROCEDURE DIVISION\", NodeType.DIVISION, ctx);", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2NTUwOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462965509", "bodyText": "Same, const/enum for SECTIONs (6 of them), like didvisions", "author": "asatklichov", "createdAt": "2020-07-30T12:38:41Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -186,6 +222,64 @@ public Class visitEndProgramStatement(EndProgramStatementContext ctx) {\n     return visitChildren(ctx);\n   }\n \n+  @Override\n+  public Class visitProgramIdParagraph(ProgramIdParagraphContext ctx) {\n+    Optional<String> programName = Optional.ofNullable(ctx.programName()).map(RuleContext::getText);\n+    if (programName.isPresent()) {\n+      String name = programName.get();\n+      this.programName = name;\n+      outlineTreeBuilder.renameProgram(name, ctx);\n+      outlineTreeBuilder.addNodeToParent(\"PROGRAM-ID \" + name, NodeType.PROGRAM_ID, ctx);\n+    }\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitConfigurationSection(ConfigurationSectionContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(\"CONFIGURATION SECTION\", NodeType.SECTION, ctx);", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2NzEyNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462967126", "bodyText": "List.of()", "author": "asatklichov", "createdAt": "2020-07-30T12:41:37Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/OutlineService.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.AnalysisFinishedEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlinePosition;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineRange;\n+import com.google.inject.Inject;\n+import com.google.inject.assistedinject.Assisted;\n+import com.google.inject.internal.cglib.core.$CollectionUtils;\n+import lombok.extern.slf4j.Slf4j;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OutlineService implements EventObserver<AnalysisFinishedEvent> {\n+\n+  private transient DataBusBroker databus;\n+  private transient MyTextDocumentService textDocumentService;\n+  private String documentUri;\n+  private transient CompletableFuture<MyDocumentModel> waitForDocumentModel;\n+\n+  @Inject\n+  public OutlineService(\n+      DataBusBroker databus,\n+      MyTextDocumentService textDocumentService,\n+      @Assisted(\"documentUri\") String documentUri) {\n+    this.databus = databus;\n+    this.textDocumentService = textDocumentService;\n+    this.documentUri = documentUri;\n+    this.waitForDocumentModel = new CompletableFuture<>();\n+  }\n+\n+  public List<Either<SymbolInformation, DocumentSymbol>> collectSymbols() {\n+    return collectSymbols(extractDocumentModel());\n+  }\n+\n+  static List<Either<SymbolInformation, DocumentSymbol>>collectSymbols(MyDocumentModel documentModel) {\n+    if (documentModel == null || documentModel.getAnalysisResult().getOutlineTree() == null) {\n+      return Collections.emptyList();", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2NzMyNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462967325", "bodyText": "is getAnalysisResult() safe for NPE ?", "author": "asatklichov", "createdAt": "2020-07-30T12:41:59Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/OutlineService.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.AnalysisFinishedEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlinePosition;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineRange;\n+import com.google.inject.Inject;\n+import com.google.inject.assistedinject.Assisted;\n+import com.google.inject.internal.cglib.core.$CollectionUtils;\n+import lombok.extern.slf4j.Slf4j;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OutlineService implements EventObserver<AnalysisFinishedEvent> {\n+\n+  private transient DataBusBroker databus;\n+  private transient MyTextDocumentService textDocumentService;\n+  private String documentUri;\n+  private transient CompletableFuture<MyDocumentModel> waitForDocumentModel;\n+\n+  @Inject\n+  public OutlineService(\n+      DataBusBroker databus,\n+      MyTextDocumentService textDocumentService,\n+      @Assisted(\"documentUri\") String documentUri) {\n+    this.databus = databus;\n+    this.textDocumentService = textDocumentService;\n+    this.documentUri = documentUri;\n+    this.waitForDocumentModel = new CompletableFuture<>();\n+  }\n+\n+  public List<Either<SymbolInformation, DocumentSymbol>> collectSymbols() {\n+    return collectSymbols(extractDocumentModel());\n+  }\n+\n+  static List<Either<SymbolInformation, DocumentSymbol>>collectSymbols(MyDocumentModel documentModel) {\n+    if (documentModel == null || documentModel.getAnalysisResult().getOutlineTree() == null) {", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY1NDQ1OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r463654458", "bodyText": "Good question. Looks like we never put the null as analysisResult value. Usually, in the rest of the code, no one checks for null.", "author": "grianbrcom", "createdAt": "2020-07-31T14:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2NzMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1NzcxMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464257710", "bodyText": "It is safe, but we have an unused constructor that may allow injecting a null AnalysisResult. it should be deleted by another PR", "author": "temanbrcom", "createdAt": "2020-08-03T08:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2NzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2OTcxOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462969718", "bodyText": "consturctor with nulls, ... better define explicit default constructor.", "author": "asatklichov", "createdAt": "2020-07-30T12:46:11Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/OutlineServiceTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.*;\n+import lombok.Value;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class OutlineServiceTest {\n+  @Test\n+  public void collectSymbols() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null,\n+            new OutlineTree(List.of(outlineNode(\"FOO\", NodeType.FIELD, from(3, 3), to(4, 4))))));\n+    List<Either<SymbolInformation, DocumentSymbol>> expectedResult = List.of(Either.forRight(\n+        documentSymbol(\"FOO\", SymbolKind.Variable, from(2, 3), to(3, 4))\n+    ));\n+    assertEquals(expectedResult, OutlineService.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullDocumentModel() {\n+    assertEquals(Collections.EMPTY_LIST, OutlineService.collectSymbols(null));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullOutlineTree() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null, null));", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MDU4MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462970581", "bodyText": "consturctor with nulls, ... better define explicit default constructor.", "author": "asatklichov", "createdAt": "2020-07-30T12:47:41Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/MyTextDocumentServiceTest.java", "diffHunk": "@@ -175,9 +175,9 @@ public void observerCallback() {\n     // created two dummy analysis result, one with error and another without\n     // those object will be used as result of dynamic stubbing stage\n     AnalysisResult resultNoErrors =\n-        new AnalysisResult(diagnosticsNoErrors, null, null, null, null, null, null);\n+        new AnalysisResult(diagnosticsNoErrors, null, null, null, null, null, null, null);", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3OTQzOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462979439", "bodyText": "Maybe, even provide a builder", "author": "temanbrcom", "createdAt": "2020-07-30T13:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MDU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk0MTYyNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462941627", "bodyText": "I think you may remove this line, the stack will be printed on the next one", "author": "temanbrcom", "createdAt": "2020-07-30T11:50:46Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/OutlineService.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.AnalysisFinishedEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlinePosition;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineRange;\n+import com.google.inject.Inject;\n+import com.google.inject.assistedinject.Assisted;\n+import com.google.inject.internal.cglib.core.$CollectionUtils;\n+import lombok.extern.slf4j.Slf4j;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class OutlineService implements EventObserver<AnalysisFinishedEvent> {\n+\n+  private transient DataBusBroker databus;\n+  private transient MyTextDocumentService textDocumentService;\n+  private String documentUri;\n+  private transient CompletableFuture<MyDocumentModel> waitForDocumentModel;\n+\n+  @Inject\n+  public OutlineService(\n+      DataBusBroker databus,\n+      MyTextDocumentService textDocumentService,\n+      @Assisted(\"documentUri\") String documentUri) {\n+    this.databus = databus;\n+    this.textDocumentService = textDocumentService;\n+    this.documentUri = documentUri;\n+    this.waitForDocumentModel = new CompletableFuture<>();\n+  }\n+\n+  public List<Either<SymbolInformation, DocumentSymbol>> collectSymbols() {\n+    return collectSymbols(extractDocumentModel());\n+  }\n+\n+  static List<Either<SymbolInformation, DocumentSymbol>>collectSymbols(MyDocumentModel documentModel) {\n+    if (documentModel == null || documentModel.getAnalysisResult().getOutlineTree() == null) {\n+      return Collections.emptyList();\n+    }\n+    return documentModel.getAnalysisResult().getOutlineTree().getOutlineNodes().stream()\n+        .map(OutlineService::convert)\n+        .map(Either::<SymbolInformation, DocumentSymbol>forRight)\n+        .collect(Collectors.toList());\n+  }\n+\n+  static DocumentSymbol convert(OutlineNode outlineNode) {\n+    return new DocumentSymbol(\n+        outlineNode.getName(),\n+        convert(outlineNode.getNodeType()),\n+        convert(outlineNode.getOutlineRange()),\n+        convert(outlineNode.getOutlineRange()),\n+        \"\",\n+        outlineNode.getNestedNodes().stream()\n+            .map(OutlineService::convert)\n+            .collect(Collectors.toList())\n+    );\n+  }\n+\n+  static SymbolKind convert(NodeType nodeType) {\n+    switch (nodeType) {\n+      case PROGRAM:\n+        return SymbolKind.Class;\n+      case DIVISION:\n+      case PROCEDURE:\n+      case PROCEDURE_SECTION:\n+      case PROGRAM_ID:\n+        return SymbolKind.Method;\n+      case FIELD:\n+      case FIELD_66:\n+        return SymbolKind.Variable;\n+      case FIELD_88:\n+        return SymbolKind.EnumMember;\n+      case STRUCT:\n+        return SymbolKind.Struct;\n+      case SECTION:\n+        return SymbolKind.Object;\n+      case FILE:\n+      case COPYBOOK:\n+        return SymbolKind.File;\n+      case REDEFINES:\n+        return SymbolKind.Constant;\n+      default:\n+        return SymbolKind.Null;\n+    }\n+  }\n+\n+  static Range convert(OutlineRange outlineRange) {\n+    return new Range(convert(outlineRange.getStart()), convert(outlineRange.getEnd()));\n+  }\n+\n+  static Position convert(OutlinePosition outlinePosition) {\n+    return new Position(outlinePosition.getLine() - 1, outlinePosition.getCharacter());\n+  }\n+\n+  private MyDocumentModel extractDocumentModel() {\n+    Object subscriber = databus.subscribe(DataEventType.ANALYSIS_FINISHED_EVENT, this);\n+    try {\n+      MyDocumentModel documentModel = textDocumentService.getDocs().get(documentUri);\n+      if (documentModel.getAnalysisResult().getOutlineTree() != null) {\n+        return documentModel;\n+      }\n+      return waitForDocumentModel.get(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException | ExecutionException e) {\n+      e.printStackTrace();", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk0MjU0NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462942545", "bodyText": "In this case, you will create a new service on each request, isn't it too expensive?", "author": "temanbrcom", "createdAt": "2020-07-30T11:52:42Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -272,6 +274,13 @@ private void notifyAnalysisFinished(String uri, Map<String, List<Location>> copy\n             .build());\n   }\n \n+  @Override\n+  public CompletableFuture<List<Either<SymbolInformation, DocumentSymbol>>> documentSymbol(DocumentSymbolParams params) {\n+    String uri = params.getTextDocument().getUri();\n+    return supplyAsync(() -> outlineServiceFactory.create(uri).collectSymbols())", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzgwMDk2MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r473800960", "bodyText": "Renamed it into OutlineTask. Now it feels good.", "author": "grianbrcom", "createdAt": "2020-08-20T09:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk0MjU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk0MzI0MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462943240", "bodyText": "The action message here should be human-readable, something like \"symbol analysis\"", "author": "temanbrcom", "createdAt": "2020-07-30T11:54:17Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -272,6 +274,13 @@ private void notifyAnalysisFinished(String uri, Map<String, List<Location>> copy\n             .build());\n   }\n \n+  @Override\n+  public CompletableFuture<List<Either<SymbolInformation, DocumentSymbol>>> documentSymbol(DocumentSymbolParams params) {\n+    String uri = params.getTextDocument().getUri();\n+    return supplyAsync(() -> outlineServiceFactory.create(uri).collectSymbols())\n+        .whenComplete(reportExceptionIfThrown(createDescriptiveErrorMessage(\"documentSymbol\", uri)));", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk1MDczOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462950738", "bodyText": "?", "author": "temanbrcom", "createdAt": "2020-07-30T12:10:30Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/test/java/com/ca/lsp/core/cobol/visitor/VisitorOutlineAnalysisTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.ca.lsp.core.cobol.visitor;\n+\n+import com.broadcom.lsp.cdi.EngineModule;\n+import com.broadcom.lsp.cdi.LangServerCtx;\n+import com.broadcom.lsp.cdi.module.databus.DatabusModule;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.ca.lsp.core.cobol.engine.CobolLanguageEngine;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import com.google.common.io.Resources;\n+import edu.emory.mathcs.backport.java.util.Arrays;", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2NjMzMg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462966332", "bodyText": "Maybe, if you add a ThreadLocal with CompletableFuture that will be waiting for the analysis result, you won't need this complicated structure. You may complete this future in notifyAnalysisFinished.\nIn this case, you will send the response only when analysis finished, even if you receive the request too early", "author": "temanbrcom", "createdAt": "2020-07-30T12:40:11Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -272,6 +274,13 @@ private void notifyAnalysisFinished(String uri, Map<String, List<Location>> copy\n             .build());\n   }\n \n+  @Override\n+  public CompletableFuture<List<Either<SymbolInformation, DocumentSymbol>>> documentSymbol(DocumentSymbolParams params) {\n+    String uri = params.getTextDocument().getUri();\n+    return supplyAsync(() -> outlineServiceFactory.create(uri).collectSymbols())\n+        .whenComplete(reportExceptionIfThrown(createDescriptiveErrorMessage(\"documentSymbol\", uri)));\n+  }", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2OTY1Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462969652", "bodyText": "You may define it as a use-case test and simplify the preparation for it.\nAlso, using DI in tests is a bad practice, so it would be better to avoid as much as we can.", "author": "temanbrcom", "createdAt": "2020-07-30T12:46:04Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/test/java/com/ca/lsp/core/cobol/visitor/VisitorOutlineAnalysisTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.ca.lsp.core.cobol.visitor;", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5MTYyMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r474691623", "bodyText": "The test now is based on UseCaseUtils.", "author": "grianbrcom", "createdAt": "2020-08-21T13:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2OTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MTY0NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462971645", "bodyText": "You may just put it in ifPresent()", "author": "temanbrcom", "createdAt": "2020-07-30T12:49:35Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -186,6 +222,64 @@ public Class visitEndProgramStatement(EndProgramStatementContext ctx) {\n     return visitChildren(ctx);\n   }\n \n+  @Override\n+  public Class visitProgramIdParagraph(ProgramIdParagraphContext ctx) {\n+    Optional<String> programName = Optional.ofNullable(ctx.programName()).map(RuleContext::getText);\n+    if (programName.isPresent()) {\n+      String name = programName.get();\n+      this.programName = name;\n+      outlineTreeBuilder.renameProgram(name, ctx);\n+      outlineTreeBuilder.addNodeToParent(\"PROGRAM-ID \" + name, NodeType.PROGRAM_ID, ctx);\n+    }", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY0NjMwMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r463646303", "bodyText": "Yes, make sense.", "author": "grianbrcom", "createdAt": "2020-07-31T14:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MTY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NTMwNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r462975305", "bodyText": "I think you don't really need this assignment, you may trim the name directly on the next line, the same for some of the following cases", "author": "temanbrcom", "createdAt": "2020-07-30T12:55:54Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/outline/OutlineTreeBuilder.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.Token;\n+\n+import java.util.*;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+@Slf4j\n+public class OutlineTreeBuilder {\n+  private List<OutlineNode> rootNodes = new ArrayList<>();\n+  private Map<ParserRuleContext, OutlineNode> nodesByContext = new HashMap<>();\n+  private Deque<Variable> variables;\n+  private OutlineNode latestVariable;\n+\n+  public void addProgram(ParserRuleContext parserRuleContext) {\n+    OutlineNode outlineNode = constructNode(null, NodeType.PROGRAM, parserRuleContext);\n+    rootNodes.add(outlineNode);\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+  }\n+\n+  public void addNodeToParent(String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    name = name.trim();", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzMDQ1NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464230454", "bodyText": "Missing header! (in multiple places!)", "author": "zacanbrcom", "createdAt": "2020-08-03T07:06:27Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/outline/NodeType.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+public enum NodeType {\n+  PROGRAM,\n+  PROGRAM_ID,\n+  DIVISION,\n+  SECTION,\n+  STRUCT,\n+  REDEFINES,\n+  FIELD,\n+  FIELD_66,\n+  FIELD_88,\n+  COPYBOOK,\n+  PROCEDURE,\n+  PROCEDURE_SECTION,\n+  FILE\n+}", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzMDU5MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464230591", "bodyText": "And a clear description about that enum", "author": "zacanbrcom", "createdAt": "2020-08-03T07:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzMDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1Mjc4NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464252785", "bodyText": "optional: we could extract the number associated with the enum field 66, ... since will never change", "author": "zacanbrcom", "createdAt": "2020-08-03T07:58:27Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -117,9 +119,35 @@ public Class visitProcedureSectionHeader(ProcedureSectionHeaderContext ctx) {\n     return visitChildren(ctx);\n   }\n \n+  @Override\n+  public Class visitWorkingStorageSection(WorkingStorageSectionContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(\"WORKING-STORAGE SECTION\", NodeType.SECTION, ctx);\n+    outlineTreeBuilder.initVariables();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryFormat2(DataDescriptionEntryFormat2Context ctx) {\n+    outlineTreeBuilder.addVariable(66, ctx.dataName1().getText(), NodeType.FIELD_66, ctx);", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1NTQ4OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464255488", "bodyText": "I would suggest a more clear name that reflect the check in a range", "author": "zacanbrcom", "createdAt": "2020-08-03T08:04:10Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/outline/OutlineNode.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.Setter;\n+\n+import java.util.List;\n+\n+@AllArgsConstructor\n+@Data\n+@Setter(AccessLevel.PACKAGE)\n+public class OutlineNode {\n+  String name;\n+  NodeType nodeType;\n+  OutlineRange outlineRange;\n+  List<OutlineNode> nestedNodes;\n+\n+  public boolean isInside(OutlineNode outlineNode) {", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4NTkwNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464285905", "bodyText": "Would be better to rename this method since what is doing at this level is to add a new node. the inner private method will be responsible to put that node at the right level", "author": "zacanbrcom", "createdAt": "2020-08-03T09:03:34Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -186,6 +222,64 @@ public Class visitEndProgramStatement(EndProgramStatementContext ctx) {\n     return visitChildren(ctx);\n   }\n \n+  @Override\n+  public Class visitProgramIdParagraph(ProgramIdParagraphContext ctx) {\n+    Optional<String> programName = Optional.ofNullable(ctx.programName()).map(RuleContext::getText);\n+    if (programName.isPresent()) {\n+      String name = programName.get();\n+      this.programName = name;\n+      outlineTreeBuilder.renameProgram(name, ctx);\n+      outlineTreeBuilder.addNodeToParent(\"PROGRAM-ID \" + name, NodeType.PROGRAM_ID, ctx);\n+    }\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitConfigurationSection(ConfigurationSectionContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(\"CONFIGURATION SECTION\", NodeType.SECTION, ctx);\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitInputOutputSection(InputOutputSectionContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(\"INPUT-OUTPUT SECTION\", NodeType.SECTION, ctx);\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitSelectClause(SelectClauseContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(ctx.fileName().getText(), NodeType.FILE, ctx);\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitFileSection(FileSectionContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(\"FILE SECTION\", NodeType.SECTION, ctx);\n+    outlineTreeBuilder.initVariables();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitLinkageSection(LinkageSectionContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(\"LINKAGE SECTION\", NodeType.SECTION, ctx);\n+    outlineTreeBuilder.initVariables();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitLocalStorageSection(LocalStorageSectionContext ctx) {\n+    outlineTreeBuilder.addNodeToParent(\"LOCAL STORAGE SECTION\", NodeType.SECTION, ctx);", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4OTk4Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464289982", "bodyText": "optional: it's super cool but I am afraid that will be a bit complicated for the developer understand what is going on here,\nmaybe extract the last  part ( hasRedefines ? NodeType.REDEFINES : NodeType.STRUCT) may help", "author": "zacanbrcom", "createdAt": "2020-08-03T09:11:23Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -138,13 +167,20 @@ public Class visitDataDescriptionEntryFormat1(DataDescriptionEntryFormat1Context\n     if (tokenText.equals(\"01\") || tokenText.equals(\"1\") || tokenText.equals(\"77\")) {\n       areaAWarning(ctx.start.getCharPositionInLine(), tokenText, token.getLine());\n     }\n+    String name = Optional.ofNullable(ctx.dataName1()).map(RuleContext::getText).orElse(\"FILLER\");\n+    int level = Integer.parseInt(ctx.otherLevel().getText());\n+    boolean hasPic = !ctx.dataPictureClause().isEmpty();\n+    boolean hasRedefines = !ctx.dataRedefinesClause().isEmpty();\n+    NodeType nodeType = hasPic ? NodeType.FIELD : hasRedefines ? NodeType.REDEFINES : NodeType.STRUCT;", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0NjQyNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464546427", "bodyText": "I tried to improve this part by comments. Is it good now?", "author": "grianbrcom", "createdAt": "2020-08-03T17:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4OTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5NDYwMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464294600", "bodyText": "Any plan to test also some negative scenarios?", "author": "zacanbrcom", "createdAt": "2020-08-03T09:20:11Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/test/java/com/ca/lsp/core/cobol/semantics/outline/OutlineNodeTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import edu.emory.mathcs.backport.java.util.Arrays;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import static org.junit.Assert.*;\n+\n+@RunWith(Parameterized.class)\n+public class OutlineNodeTest {\n+\n+  private static OutlineNode constructNode(int startLine, int startSymbol, int stopLine, int stopSymbol) {\n+    return new OutlineNode(\"\", NodeType.FIELD,\n+        new OutlineRange(new OutlinePosition(startLine, startSymbol), new OutlinePosition(stopLine, stopSymbol)),\n+        Collections.emptyList());\n+  }\n+\n+  @Parameterized.Parameters\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(new Object[][] {\n+        {constructNode(1, 1, 10, 1), constructNode(3, 40, 5, 10), true},\n+        {constructNode(5, 1, 5, 20), constructNode(5, 3, 5, 10), true},\n+        {constructNode(4, 1, 6, 7), constructNode(3, 40, 6, 3), false},\n+        {constructNode(4, 1, 6, 8), constructNode(4, 5, 7, 5), false},\n+        {constructNode(2, 1, 2, 9), constructNode(3, 1, 3, 8), false},\n+        {constructNode(5, 1, 5, 20), constructNode(5, 3, 5, 30), false},\n+    });\n+  }\n+\n+  private final OutlineNode first, second;\n+  private final boolean result;\n+\n+  public OutlineNodeTest(OutlineNode first, OutlineNode second, boolean result) {\n+    this.first = first;\n+    this.second = second;\n+    this.result = result;\n+  }\n+\n+  @Test\n+  public void isInside() {", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzMDAyNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464530025", "bodyText": "The negative scenarios are here. It is a parameterized test and it includes positive and negative results.", "author": "grianbrcom", "createdAt": "2020-08-03T16:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5NDYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgzMjU4NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464832585", "bodyText": "got it!", "author": "zacanbrcom", "createdAt": "2020-08-04T06:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5NDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5NTUxMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464295513", "bodyText": "You can think a better name for that test! ;)", "author": "zacanbrcom", "createdAt": "2020-08-03T09:21:48Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/test/java/com/ca/lsp/core/cobol/visitor/VisitorOutlineAnalysisTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.ca.lsp.core.cobol.visitor;\n+\n+import com.broadcom.lsp.cdi.EngineModule;\n+import com.broadcom.lsp.cdi.LangServerCtx;\n+import com.broadcom.lsp.cdi.module.databus.DatabusModule;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.ca.lsp.core.cobol.engine.CobolLanguageEngine;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import com.google.common.io.Resources;\n+import edu.emory.mathcs.backport.java.util.Arrays;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.ca.lsp.core.cobol.semantics.outline.NodeType.*;\n+import static org.junit.Assert.assertEquals;\n+\n+public class VisitorOutlineAnalysisTest {\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    LangServerCtx.getGuiceCtx(new EngineModule(), new DatabusModule());\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    LangServerCtx.shutdown();\n+  }\n+\n+  private OutlineTree extractOutlineTree(String srcName) throws IOException {\n+    DataBusBroker dataBus = LangServerCtx.getInjector().getInstance(DataBusBroker.class);\n+    for (String name: List.of(\"FOO\", \"BAR\", \"BAZ\")) {\n+      dataBus.storeData(CopybookStorable.builder()\n+          .name(name)\n+          .content(\"\")\n+          .uri(name)\n+          .build());\n+    }\n+    CobolLanguageEngine engine = LangServerCtx.getInjector().getInstance(CobolLanguageEngine.class);\n+    String program = Resources.toString(Resources.getResource(srcName), Charset.defaultCharset());\n+    ResultWithErrors<SemanticContext> result = engine.run(\"\", program, \"\");\n+    return result.getResult().getOutlineTree();\n+  }\n+\n+  @Test\n+  public void testIt() throws IOException {", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5NjE3Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464296177", "bodyText": "extract this in a separate method will made your test much easier to read..", "author": "zacanbrcom", "createdAt": "2020-08-03T09:23:02Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/test/java/com/ca/lsp/core/cobol/visitor/VisitorOutlineAnalysisTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.ca.lsp.core.cobol.visitor;\n+\n+import com.broadcom.lsp.cdi.EngineModule;\n+import com.broadcom.lsp.cdi.LangServerCtx;\n+import com.broadcom.lsp.cdi.module.databus.DatabusModule;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.ca.lsp.core.cobol.engine.CobolLanguageEngine;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import com.google.common.io.Resources;\n+import edu.emory.mathcs.backport.java.util.Arrays;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.ca.lsp.core.cobol.semantics.outline.NodeType.*;\n+import static org.junit.Assert.assertEquals;\n+\n+public class VisitorOutlineAnalysisTest {\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    LangServerCtx.getGuiceCtx(new EngineModule(), new DatabusModule());\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    LangServerCtx.shutdown();\n+  }\n+\n+  private OutlineTree extractOutlineTree(String srcName) throws IOException {\n+    DataBusBroker dataBus = LangServerCtx.getInjector().getInstance(DataBusBroker.class);\n+    for (String name: List.of(\"FOO\", \"BAR\", \"BAZ\")) {\n+      dataBus.storeData(CopybookStorable.builder()\n+          .name(name)\n+          .content(\"\")\n+          .uri(name)\n+          .build());\n+    }\n+    CobolLanguageEngine engine = LangServerCtx.getInjector().getInstance(CobolLanguageEngine.class);\n+    String program = Resources.toString(Resources.getResource(srcName), Charset.defaultCharset());\n+    ResultWithErrors<SemanticContext> result = engine.run(\"\", program, \"\");\n+    return result.getResult().getOutlineTree();\n+  }\n+\n+  @Test\n+  public void testIt() throws IOException {\n+    OutlineTree tree = extractOutlineTree(\"outline/TwoPrograms.cbl\");\n+    List<OutlineNode> expectedNodes = nested(\n+        node(\"COPY FOO\", COPYBOOK),\n+        node(\"HELLO-WORLD\", PROGRAM, nested(\n+            node(\"IDENTIFICATION DIVISION\", DIVISION, nested(\n+                node(\"PROGRAM-ID HELLO-WORLD\", PROGRAM_ID)\n+            )),\n+            node(\"DATA DIVISION\", DIVISION, nested(\n+                node(\"WORKING-STORAGE SECTION\", SECTION, nested(\n+                    node(\"COPY BAR\", COPYBOOK),\n+                    node(\"User-Num1\", FIELD),\n+                    node(\"User-Num2\", FIELD),\n+                    node(\"User-Address\", STRUCT, nested(\n+                        node(\"COPY BAZ\", COPYBOOK),\n+                        node(\"User-City\", FIELD),\n+                        node(\"User-Country\", FIELD),\n+                        node(\"User-Index\", FIELD),\n+                        node(\"User-Phone\", FIELD)\n+                    )),\n+                    node(\"FILLER\", STRUCT, nested(\n+                        node(\"FOO\", FIELD)\n+                    ))\n+                ))\n+            )),\n+            node(\"PROCEDURE DIVISION\", DIVISION, nested(\n+                node(\"000-Main-Logic\", PROCEDURE),\n+                node(\"100-Print-User\", PROCEDURE)\n+            ))\n+        )),\n+        node(\"OUTLINE\", PROGRAM, nested(\n+            node(\"IDENTIFICATION DIVISION\", DIVISION, nested(\n+                node(\"PROGRAM-ID OUTLINE\", PROGRAM_ID)\n+            )),\n+            node(\"ENVIRONMENT DIVISION\", DIVISION, nested(\n+                node(\"CONFIGURATION SECTION\", SECTION),\n+                node(\"INPUT-OUTPUT SECTION\", SECTION, nested(\n+                    node(\"TRANS-FILE-IN\", FILE)\n+                ))\n+            )),\n+            node(\"DATA DIVISION\", DIVISION, nested(\n+                node(\"FILE SECTION\", SECTION, nested(\n+                    node(\"TRANS-FILE-IN\", FILE, nested(\n+                        node(\"FILE-RECORD\", FIELD)\n+                    )),\n+                    node(\"TERMS-FILE\", FILE, nested(\n+                        node(\"TERMS-RECORD\", STRUCT, nested(\n+                            node(\"TERMS-KEY\", FIELD),\n+                            node(\"FILLER\", FIELD)\n+                        ))\n+                    ))\n+                )),\n+                node(\"WORKING-STORAGE SECTION\", SECTION, nested(\n+                    node(\"COLR-DISPLAY\", FIELD),\n+                    node(\"CTLFILE-REC\", STRUCT, nested(\n+                        node(\"CTLFILE-PRIME\", FIELD),\n+                        node(\"CTLFILE-PAST-DUE-DIFF\", FIELD)\n+                    )),\n+                    node(\"CTLFILE-REC-12\", REDEFINES, nested(\n+                        node(\"CTLFILE-DB-DATE\", FIELD),\n+                        node(\"CTLFILE-ATB-DATE\", FIELD),\n+                        node(\"COST-RECORD-CODE\", FIELD, nested(\n+                            node(\"HEADER\", FIELD_88),\n+                            node(\"SUPPLR\", FIELD_88),\n+                            node(\"WREHOUSE\", FIELD_88)\n+                        ))\n+                    ))\n+                )),\n+                node(\"LINKAGE SECTION\", SECTION, nested(\n+                    node(\"LINK-PRM0\", STRUCT, nested(\n+                        node(\"PARM-LENGTH\", FIELD),\n+                        node(\"PARM\", FIELD)\n+                    ))\n+                ))\n+            )),\n+            node(\"PROCEDURE DIVISION\", DIVISION, nested(\n+                node(\"000-PROGRAM-DRIVER\", PROCEDURE_SECTION),\n+                node(\"100-HOUSEKEEPING\", PROCEDURE_SECTION, nested(\n+                    node(\"110-OPEN-FILES\", PROCEDURE),\n+                    node(\"112-READ-WAREHOUS-FILE\", PROCEDURE),\n+                    node(\"199-EXIT\", PROCEDURE)\n+                ))\n+            ))\n+        ))\n+    );", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5ODQxMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464298410", "bodyText": "which is the benefit to use the google.io library instead of use the built-in NIO?", "author": "zacanbrcom", "createdAt": "2020-08-03T09:27:06Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/test/java/com/ca/lsp/core/cobol/visitor/VisitorOutlineAnalysisTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.ca.lsp.core.cobol.visitor;\n+\n+import com.broadcom.lsp.cdi.EngineModule;\n+import com.broadcom.lsp.cdi.LangServerCtx;\n+import com.broadcom.lsp.cdi.module.databus.DatabusModule;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.ca.lsp.core.cobol.engine.CobolLanguageEngine;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import com.google.common.io.Resources;\n+import edu.emory.mathcs.backport.java.util.Arrays;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.ca.lsp.core.cobol.semantics.outline.NodeType.*;\n+import static org.junit.Assert.assertEquals;\n+\n+public class VisitorOutlineAnalysisTest {\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    LangServerCtx.getGuiceCtx(new EngineModule(), new DatabusModule());\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    LangServerCtx.shutdown();\n+  }\n+\n+  private OutlineTree extractOutlineTree(String srcName) throws IOException {\n+    DataBusBroker dataBus = LangServerCtx.getInjector().getInstance(DataBusBroker.class);\n+    for (String name: List.of(\"FOO\", \"BAR\", \"BAZ\")) {\n+      dataBus.storeData(CopybookStorable.builder()\n+          .name(name)\n+          .content(\"\")\n+          .uri(name)\n+          .build());\n+    }\n+    CobolLanguageEngine engine = LangServerCtx.getInjector().getInstance(CobolLanguageEngine.class);\n+    String program = Resources.toString(Resources.getResource(srcName), Charset.defaultCharset());", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk0OTEzNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464949134", "bodyText": "I could use Files.readString from NIO, instead of Resources.toString, but building a path is a nightmare. The possible result could be:\nString program = Files.readString(Paths.get(getClass().getClassLoader().getResource(srcName).toURI()));\n\nAnd I also need to care about URISyntaxException. That's why I decided to use Google library.", "author": "grianbrcom", "createdAt": "2020-08-04T10:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5ODQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk3MzQ2OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464973468", "bodyText": "I got your point and I can accept your impl. Minor thing - bare in mind that Resources class is in @Beta according with doc, probably is not a problem for us!\n@Beta\n@GwtIncompatible\npublic final class Resources {\n//...\n}", "author": "zacanbrcom", "createdAt": "2020-08-04T11:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5ODQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxODU2NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r465018564", "bodyText": "Yeah, you are right. But it since the very beginning and still here... OK than.", "author": "grianbrcom", "createdAt": "2020-08-04T12:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI5ODQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxMTI2MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464311261", "bodyText": "If I understood correctly looks like you used iteration and recursion in the same method.\nI would prefer to separate the complexity for create the structure from the visiting and assert", "author": "zacanbrcom", "createdAt": "2020-08-03T09:51:10Z", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/test/java/com/ca/lsp/core/cobol/visitor/VisitorOutlineAnalysisTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.ca.lsp.core.cobol.visitor;\n+\n+import com.broadcom.lsp.cdi.EngineModule;\n+import com.broadcom.lsp.cdi.LangServerCtx;\n+import com.broadcom.lsp.cdi.module.databus.DatabusModule;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.ca.lsp.core.cobol.engine.CobolLanguageEngine;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import com.google.common.io.Resources;\n+import edu.emory.mathcs.backport.java.util.Arrays;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.ca.lsp.core.cobol.semantics.outline.NodeType.*;\n+import static org.junit.Assert.assertEquals;\n+\n+public class VisitorOutlineAnalysisTest {\n+\n+  @BeforeClass\n+  public static void setUp() {\n+    LangServerCtx.getGuiceCtx(new EngineModule(), new DatabusModule());\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() {\n+    LangServerCtx.shutdown();\n+  }\n+\n+  private OutlineTree extractOutlineTree(String srcName) throws IOException {\n+    DataBusBroker dataBus = LangServerCtx.getInjector().getInstance(DataBusBroker.class);\n+    for (String name: List.of(\"FOO\", \"BAR\", \"BAZ\")) {\n+      dataBus.storeData(CopybookStorable.builder()\n+          .name(name)\n+          .content(\"\")\n+          .uri(name)\n+          .build());\n+    }\n+    CobolLanguageEngine engine = LangServerCtx.getInjector().getInstance(CobolLanguageEngine.class);\n+    String program = Resources.toString(Resources.getResource(srcName), Charset.defaultCharset());\n+    ResultWithErrors<SemanticContext> result = engine.run(\"\", program, \"\");\n+    return result.getResult().getOutlineTree();\n+  }\n+\n+  @Test\n+  public void testIt() throws IOException {\n+    OutlineTree tree = extractOutlineTree(\"outline/TwoPrograms.cbl\");\n+    List<OutlineNode> expectedNodes = nested(\n+        node(\"COPY FOO\", COPYBOOK),\n+        node(\"HELLO-WORLD\", PROGRAM, nested(\n+            node(\"IDENTIFICATION DIVISION\", DIVISION, nested(\n+                node(\"PROGRAM-ID HELLO-WORLD\", PROGRAM_ID)\n+            )),\n+            node(\"DATA DIVISION\", DIVISION, nested(\n+                node(\"WORKING-STORAGE SECTION\", SECTION, nested(\n+                    node(\"COPY BAR\", COPYBOOK),\n+                    node(\"User-Num1\", FIELD),\n+                    node(\"User-Num2\", FIELD),\n+                    node(\"User-Address\", STRUCT, nested(\n+                        node(\"COPY BAZ\", COPYBOOK),\n+                        node(\"User-City\", FIELD),\n+                        node(\"User-Country\", FIELD),\n+                        node(\"User-Index\", FIELD),\n+                        node(\"User-Phone\", FIELD)\n+                    )),\n+                    node(\"FILLER\", STRUCT, nested(\n+                        node(\"FOO\", FIELD)\n+                    ))\n+                ))\n+            )),\n+            node(\"PROCEDURE DIVISION\", DIVISION, nested(\n+                node(\"000-Main-Logic\", PROCEDURE),\n+                node(\"100-Print-User\", PROCEDURE)\n+            ))\n+        )),\n+        node(\"OUTLINE\", PROGRAM, nested(\n+            node(\"IDENTIFICATION DIVISION\", DIVISION, nested(\n+                node(\"PROGRAM-ID OUTLINE\", PROGRAM_ID)\n+            )),\n+            node(\"ENVIRONMENT DIVISION\", DIVISION, nested(\n+                node(\"CONFIGURATION SECTION\", SECTION),\n+                node(\"INPUT-OUTPUT SECTION\", SECTION, nested(\n+                    node(\"TRANS-FILE-IN\", FILE)\n+                ))\n+            )),\n+            node(\"DATA DIVISION\", DIVISION, nested(\n+                node(\"FILE SECTION\", SECTION, nested(\n+                    node(\"TRANS-FILE-IN\", FILE, nested(\n+                        node(\"FILE-RECORD\", FIELD)\n+                    )),\n+                    node(\"TERMS-FILE\", FILE, nested(\n+                        node(\"TERMS-RECORD\", STRUCT, nested(\n+                            node(\"TERMS-KEY\", FIELD),\n+                            node(\"FILLER\", FIELD)\n+                        ))\n+                    ))\n+                )),\n+                node(\"WORKING-STORAGE SECTION\", SECTION, nested(\n+                    node(\"COLR-DISPLAY\", FIELD),\n+                    node(\"CTLFILE-REC\", STRUCT, nested(\n+                        node(\"CTLFILE-PRIME\", FIELD),\n+                        node(\"CTLFILE-PAST-DUE-DIFF\", FIELD)\n+                    )),\n+                    node(\"CTLFILE-REC-12\", REDEFINES, nested(\n+                        node(\"CTLFILE-DB-DATE\", FIELD),\n+                        node(\"CTLFILE-ATB-DATE\", FIELD),\n+                        node(\"COST-RECORD-CODE\", FIELD, nested(\n+                            node(\"HEADER\", FIELD_88),\n+                            node(\"SUPPLR\", FIELD_88),\n+                            node(\"WREHOUSE\", FIELD_88)\n+                        ))\n+                    ))\n+                )),\n+                node(\"LINKAGE SECTION\", SECTION, nested(\n+                    node(\"LINK-PRM0\", STRUCT, nested(\n+                        node(\"PARM-LENGTH\", FIELD),\n+                        node(\"PARM\", FIELD)\n+                    ))\n+                ))\n+            )),\n+            node(\"PROCEDURE DIVISION\", DIVISION, nested(\n+                node(\"000-PROGRAM-DRIVER\", PROCEDURE_SECTION),\n+                node(\"100-HOUSEKEEPING\", PROCEDURE_SECTION, nested(\n+                    node(\"110-OPEN-FILES\", PROCEDURE),\n+                    node(\"112-READ-WAREHOUS-FILE\", PROCEDURE),\n+                    node(\"199-EXIT\", PROCEDURE)\n+                ))\n+            ))\n+        ))\n+    );\n+    check(expectedNodes, tree.getOutlineNodes(), \"\");\n+  }\n+\n+  private void check(List<OutlineNode> expected, List<OutlineNode> actual, String level) {\n+    Map<String, OutlineNode> expectedMap = toMap(expected);\n+    Map<String, OutlineNode> actualMap = toMap(actual);\n+    assertEquals(\"Elements on level \" + level, expectedMap.keySet(), actualMap.keySet());\n+    for (String nodeName: expectedMap.keySet()) {\n+      OutlineNode expectedNode = expectedMap.get(nodeName);\n+      OutlineNode actualNode = actualMap.get(nodeName);\n+      String newLevel = level + '/' + nodeName;\n+      assertEquals(\"Node types for \" + newLevel, expectedNode.getNodeType(), actualNode.getNodeType());\n+      check(expectedNode.getNestedNodes(), actualNode.getNestedNodes(), newLevel);\n+    }\n+  }", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyNTQ5Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r465025496", "bodyText": "I've split it into two methods for a list of nodes check and for each node check.", "author": "grianbrcom", "createdAt": "2020-08-04T12:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxMTI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMxNjA4NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464316085", "bodyText": "There are some unused imports", "author": "zacanbrcom", "createdAt": "2020-08-03T10:00:56Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/OutlineService.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.AnalysisFinishedEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineNode;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlinePosition;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineRange;\n+import com.google.inject.Inject;\n+import com.google.inject.assistedinject.Assisted;\n+import com.google.inject.internal.cglib.core.$CollectionUtils;\n+import lombok.extern.slf4j.Slf4j;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMyNjE2OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464326168", "bodyText": "not sure if might create strange results but I would recommend to use an empty outline object rather than a null reference", "author": "zacanbrcom", "createdAt": "2020-08-03T10:22:17Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/AnalysisResult.java", "diffHunk": "@@ -42,7 +44,8 @@ public static AnalysisResult empty() {\n         Collections.emptyMap(),\n         Collections.emptyMap(),\n         Collections.emptyMap(),\n-        Collections.emptyMap());\n+        Collections.emptyMap(),\n+        null);", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMDMwNA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464330304", "bodyText": "I will suggest to don't ignore it until we can still use socket communication (for developer purposes)", "author": "zacanbrcom", "createdAt": "2020-08-03T10:31:27Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/LangServerBootstrapTest.java", "diffHunk": "@@ -78,6 +79,7 @@ public void isPipeEnabledInvalidArgument() {\n   }\n \n   @Test\n+  @Ignore", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0NDE5NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464544194", "bodyText": "Oops...", "author": "grianbrcom", "createdAt": "2020-08-03T17:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzMDMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDU2Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464334567", "bodyText": "please add a brief explanation of the purpose", "author": "zacanbrcom", "createdAt": "2020-08-03T10:41:34Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/OutlineServiceTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.*;\n+import lombok.Value;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class OutlineServiceTest {\n+  @Test\n+  public void collectSymbols() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null,\n+            new OutlineTree(List.of(outlineNode(\"FOO\", NodeType.FIELD, from(3, 3), to(4, 4))))));\n+    List<Either<SymbolInformation, DocumentSymbol>> expectedResult = List.of(Either.forRight(\n+        documentSymbol(\"FOO\", SymbolKind.Variable, from(2, 3), to(3, 4))\n+    ));\n+    assertEquals(expectedResult, OutlineService.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullDocumentModel() {\n+    assertEquals(Collections.EMPTY_LIST, OutlineService.collectSymbols(null));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullOutlineTree() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null, null));\n+    assertEquals(Collections.EMPTY_LIST, OutlineService.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void convert() {", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDkzNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464334935", "bodyText": "might be better to wrap it in a method to improve readability", "author": "zacanbrcom", "createdAt": "2020-08-03T10:42:27Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/OutlineServiceTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.*;\n+import lombok.Value;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class OutlineServiceTest {\n+  @Test\n+  public void collectSymbols() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null,\n+            new OutlineTree(List.of(outlineNode(\"FOO\", NodeType.FIELD, from(3, 3), to(4, 4))))));\n+    List<Either<SymbolInformation, DocumentSymbol>> expectedResult = List.of(Either.forRight(\n+        documentSymbol(\"FOO\", SymbolKind.Variable, from(2, 3), to(3, 4))\n+    ));\n+    assertEquals(expectedResult, OutlineService.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullDocumentModel() {\n+    assertEquals(Collections.EMPTY_LIST, OutlineService.collectSymbols(null));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullOutlineTree() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null, null));\n+    assertEquals(Collections.EMPTY_LIST, OutlineService.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void convert() {\n+    // The structure is the following:\n+    // root\n+    // |- first\n+    // |  |- FILLER\n+    // |- second\n+    OutlineNode outlineNode = outlineNode(\"root\", NodeType.PROGRAM, from(1, 1), to(10, 45),\n+        outlineNode(\"first\", NodeType.DIVISION, from(2, 2), to(2, 10),\n+            outlineNode(\"FILLER\", NodeType.STRUCT, from(3, 4), to(3, 8))),\n+        outlineNode(\"second\", NodeType.COPYBOOK, from(5, 3), to(5, 20)));\n+    DocumentSymbol expectedDocumentSymbol = documentSymbol(\"root\", SymbolKind.Class, from(0, 1), to(9, 45),\n+        documentSymbol(\"first\", SymbolKind.Method, from(1, 2), to(1, 10),\n+            documentSymbol(\"FILLER\", SymbolKind.Struct, from(2, 4), to(2, 8))),\n+        documentSymbol(\"second\", SymbolKind.File, from(4, 3), to(4, 20)));", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxNzY3Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r465017676", "bodyText": "I decided to keep them in one place because it easy to understand how the outline structure must be converted into a document symbol. Like: \"first\" DIVISION from outline node became \"first\" Method as a document symbol.\nOr from(2, 2) for the \"first\" must become from(1, 2).\nIf I split the code by methods it will be hard to visually compare these two formats.", "author": "grianbrcom", "createdAt": "2020-08-04T12:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMzIzOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r465023238", "bodyText": "\ud83d\udc4d", "author": "zacanbrcom", "createdAt": "2020-08-04T12:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzNTc3Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r464335776", "bodyText": "can be renamed as Cursor?", "author": "zacanbrcom", "createdAt": "2020-08-03T10:44:29Z", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/OutlineServiceTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.*;\n+import lombok.Value;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class OutlineServiceTest {\n+  @Test\n+  public void collectSymbols() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null,\n+            new OutlineTree(List.of(outlineNode(\"FOO\", NodeType.FIELD, from(3, 3), to(4, 4))))));\n+    List<Either<SymbolInformation, DocumentSymbol>> expectedResult = List.of(Either.forRight(\n+        documentSymbol(\"FOO\", SymbolKind.Variable, from(2, 3), to(3, 4))\n+    ));\n+    assertEquals(expectedResult, OutlineService.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullDocumentModel() {\n+    assertEquals(Collections.EMPTY_LIST, OutlineService.collectSymbols(null));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullOutlineTree() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\",\n+        new AnalysisResult(null, null, null, null, null, null, null, null));\n+    assertEquals(Collections.EMPTY_LIST, OutlineService.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void convert() {\n+    // The structure is the following:\n+    // root\n+    // |- first\n+    // |  |- FILLER\n+    // |- second\n+    OutlineNode outlineNode = outlineNode(\"root\", NodeType.PROGRAM, from(1, 1), to(10, 45),\n+        outlineNode(\"first\", NodeType.DIVISION, from(2, 2), to(2, 10),\n+            outlineNode(\"FILLER\", NodeType.STRUCT, from(3, 4), to(3, 8))),\n+        outlineNode(\"second\", NodeType.COPYBOOK, from(5, 3), to(5, 20)));\n+    DocumentSymbol expectedDocumentSymbol = documentSymbol(\"root\", SymbolKind.Class, from(0, 1), to(9, 45),\n+        documentSymbol(\"first\", SymbolKind.Method, from(1, 2), to(1, 10),\n+            documentSymbol(\"FILLER\", SymbolKind.Struct, from(2, 4), to(2, 8))),\n+        documentSymbol(\"second\", SymbolKind.File, from(4, 3), to(4, 20)));\n+    assertEquals(expectedDocumentSymbol, OutlineService.convert(outlineNode));\n+  }\n+\n+  private OutlineNode outlineNode(String name, NodeType nodeType, Point from, Point to, OutlineNode... nestedNodes) {\n+    return new OutlineNode(name, nodeType,\n+        new OutlineRange(new OutlinePosition(from.line, from.character), new OutlinePosition(to.line, to.character)),\n+        Arrays.asList(nestedNodes));\n+  }\n+\n+  private Point from(int line, int character) {\n+    return new Point(line, character);\n+  }\n+\n+  private Point to(int line, int character) {\n+    return new Point(line, character);\n+  }\n+\n+  private DocumentSymbol documentSymbol(String name, SymbolKind kind, Point from, Point to, DocumentSymbol... children) {\n+    Range range = new Range(new Position(from.line, from.character), new Position(to.line, to.character));\n+    return new DocumentSymbol(name, kind, range, range, \"\", Arrays.asList(children));\n+  }\n+\n+  @Value\n+  private class Point {", "originalCommit": "bfcbc0889d7e5e7548da611d9d78118db624e863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "579a98427e803035895d8676d87dfd8ea1a193a1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/579a98427e803035895d8676d87dfd8ea1a193a1", "message": "feat: Outline view support\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-08-21T15:21:44Z", "type": "forcePushed"}, {"oid": "ba804e9a2113d0490ec91b431213eb399fb508c7", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ba804e9a2113d0490ec91b431213eb399fb508c7", "message": "feat: Outline view support\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-08-24T16:36:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzAyMA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476217020", "bodyText": "Optional (2x):  List.of()", "author": "asatklichov", "createdAt": "2020-08-25T06:53:11Z", "path": "server/src/test/java/com/ca/lsp/cobol/service/delegates/outline/OutlineTaskTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.outline;\n+\n+import com.ca.lsp.cobol.service.MyDocumentModel;\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import lombok.Value;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class OutlineTaskTest {\n+  @Test\n+  public void collectSymbols() {\n+    DocumentSymbol theDocumentSymbol = new DocumentSymbol();\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\", AnalysisResult.builder().outlineTree(\n+        new OutlineTree(List.of(theDocumentSymbol), true)).build());\n+    List<Either<SymbolInformation, DocumentSymbol>> expectedResult = List.of(Either.forRight(theDocumentSymbol));\n+    assertEquals(expectedResult, OutlineTask.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullDocumentModel() {\n+    assertEquals(Collections.EMPTY_LIST, OutlineTask.collectSymbols(null));", "originalCommit": "ba804e9a2113d0490ec91b431213eb399fb508c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3MDA0MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476270040", "bodyText": "Yes. It's probably because I started to implement it in Java 8.", "author": "grianbrcom", "createdAt": "2020-08-25T08:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIxNzk1OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476217959", "bodyText": "Optional: List.of()", "author": "asatklichov", "createdAt": "2020-08-25T06:55:16Z", "path": "server/src/test/java/com/ca/lsp/cobol/usecases/TestOutlineTree.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.positive.CobolText;\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.analyze;\n+import static com.ca.lsp.core.cobol.semantics.outline.NodeType.*;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestOutlineTree {\n+  @Test\n+  void test() throws IOException {\n+    String TEXT = IOUtils.toString(\n+        getClass().getClassLoader().getResourceAsStream(\"usecases/TestOutlineTree.cbl\"), StandardCharsets.UTF_8);\n+    List<CobolText> copybooks = List.of(\n+        new CobolText(\"FOO\", \"\"),\n+        new CobolText(\"BAR\", \"000100     01 HIDE-IT PIC 9(9).\"),\n+        new CobolText(\"BAZ\", \"\")\n+    );\n+    List<DocumentSymbol> expectedNodes = getExpectedOutlineNodes();\n+    AnalysisResult result = analyze(DOCUMENT_URI, TEXT, copybooks);\n+    assertNodeListEquals(expectedNodes, result.getOutlineTree().getOutlineNodes(), \"/\");\n+  }\n+\n+  private List<DocumentSymbol> getExpectedOutlineNodes() {\n+    return nested(\n+        node(\"COPY FOO\", COPYBOOK),\n+        node(\"PROGRAM: HELLO-WORLD\", PROGRAM, nested(\n+            node(\"IDENTIFICATION DIVISION\", DIVISION, nested(\n+                node(\"PROGRAM-ID HELLO-WORLD\", PROGRAM_ID)\n+            )),\n+            node(\"DATA DIVISION\", DIVISION, nested(\n+                node(\"WORKING-STORAGE SECTION\", SECTION, nested(\n+                    node(\"COPY BAR\", COPYBOOK),\n+                    node(\"User-Num1\", FIELD),\n+                    node(\"User-Num2\", FIELD),\n+                    node(\"User-Address\", STRUCT, nested(\n+                        node(\"COPY BAZ\", COPYBOOK),\n+                        node(\"User-City\", FIELD),\n+                        node(\"User-Country\", FIELD),\n+                        node(\"User-Index\", FIELD),\n+                        node(\"User-Phone\", FIELD)\n+                    )),\n+                    node(\"FILLER\", STRUCT, nested(\n+                        node(\"FOO\", FIELD)\n+                    ))\n+                ))\n+            )),\n+            node(\"PROCEDURE DIVISION\", DIVISION, nested(\n+                node(\"000-Main-Logic\", PROCEDURE),\n+                node(\"100-Print-User\", PROCEDURE)\n+            ))\n+        )),\n+        node(\"PROGRAM: OUTLINE\", PROGRAM, nested(\n+            node(\"IDENTIFICATION DIVISION\", DIVISION, nested(\n+                node(\"PROGRAM-ID OUTLINE\", PROGRAM_ID)\n+            )),\n+            node(\"ENVIRONMENT DIVISION\", DIVISION, nested(\n+                node(\"CONFIGURATION SECTION\", SECTION),\n+                node(\"INPUT-OUTPUT SECTION\", SECTION, nested(\n+                    node(\"TRANS-FILE-IN\", FILE)\n+                ))\n+            )),\n+            node(\"DATA DIVISION\", DIVISION, nested(\n+                node(\"FILE SECTION\", SECTION, nested(\n+                    node(\"TRANS-FILE-IN\", FILE, nested(\n+                        node(\"FILE-RECORD\", FIELD)\n+                    )),\n+                    node(\"TERMS-FILE\", FILE, nested(\n+                        node(\"TERMS-RECORD\", STRUCT, nested(\n+                            node(\"TERMS-KEY\", FIELD),\n+                            node(\"FILLER\", FIELD)\n+                        ))\n+                    ))\n+                )),\n+                node(\"WORKING-STORAGE SECTION\", SECTION, nested(\n+                    node(\"COLR-DISPLAY\", FIELD),\n+                    node(\"CTLFILE-REC\", STRUCT, nested(\n+                        node(\"CTLFILE-PRIME\", FIELD),\n+                        node(\"CTLFILE-PAST-DUE-DIFF\", FIELD)\n+                    )),\n+                    node(\"CTLFILE-REC-12\", REDEFINES, nested(\n+                        node(\"CTLFILE-DB-DATE\", FIELD),\n+                        node(\"CTLFILE-ATB-DATE\", FIELD),\n+                        node(\"COST-RECORD-CODE\", FIELD, nested(\n+                            node(\"HEADER\", FIELD_88),\n+                            node(\"SUPPLR\", FIELD_88),\n+                            node(\"WREHOUSE\", FIELD_88)\n+                        ))\n+                    ))\n+                )),\n+                node(\"LINKAGE SECTION\", SECTION, nested(\n+                    node(\"LINK-PRM0\", STRUCT, nested(\n+                        node(\"PARM-LENGTH\", FIELD),\n+                        node(\"PARM\", FIELD)\n+                    ))\n+                ))\n+            )),\n+            node(\"PROCEDURE DIVISION\", DIVISION, nested(\n+                node(\"000-PROGRAM-DRIVER\", PROCEDURE_SECTION),\n+                node(\"100-HOUSEKEEPING\", PROCEDURE_SECTION, nested(\n+                    node(\"110-OPEN-FILES\", PROCEDURE),\n+                    node(\"112-READ-WAREHOUS-FILE\", PROCEDURE),\n+                    node(\"199-EXIT\", PROCEDURE)\n+                ))\n+            ))\n+        ))\n+    );\n+  }\n+\n+  private void assertNodeListEquals(List<DocumentSymbol> expected, List<DocumentSymbol> actual, String level) {\n+    Map<String, DocumentSymbol> expectedMap = toMap(expected);\n+    Map<String, DocumentSymbol> actualMap = toMap(actual);\n+    assertEquals(\"Elements on level \" + level, expectedMap.keySet(), actualMap.keySet());\n+    for (DocumentSymbol expectedNode: expectedMap.values()) {\n+      assertNodeEquals(expectedNode, actualMap.get(expectedNode.getName()), level);\n+    }\n+  }\n+\n+  /**\n+   * The method compares only node types and nested nodes.\n+   * Two outline nodes with different ranges will be equal.\n+   */\n+  private void assertNodeEquals(DocumentSymbol expected, DocumentSymbol actual, String oldLevel) {\n+    String level = oldLevel + '/' + expected.getName();\n+    assertEquals(\"Node types for \" + level, expected.getKind(), actual.getKind());\n+    assertNodeListEquals(expected.getChildren(), actual.getChildren(), level);\n+  }\n+\n+  private Map<String, DocumentSymbol> toMap(List<DocumentSymbol> nodes) {\n+    return nodes.stream().collect(Collectors.toMap(DocumentSymbol::getName, Function.identity()));\n+  }\n+\n+  private List<DocumentSymbol> nested(DocumentSymbol... nodes) {\n+    return Arrays.asList(nodes);\n+  }\n+\n+  private DocumentSymbol node(String name, NodeType nodeType) {\n+    return node(name, nodeType, Collections.emptyList());", "originalCommit": "ba804e9a2113d0490ec91b431213eb399fb508c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3d493cc60c9894c198bdd4d3a6e7102d00efb126", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3d493cc60c9894c198bdd4d3a6e7102d00efb126", "message": "feat: Outline view support #481\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-08-25T08:40:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2Mzg5MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476263891", "bodyText": "I don't really like that the task is required to retrieve some data itself because it violates the purity principle. I will accept it now, but I feel like it might be improved later.", "author": "temanbrcom", "createdAt": "2020-08-25T08:16:31Z", "path": "server/src/main/java/com/ca/lsp/cobol/service/delegates/outline/OutlineTask.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.outline;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.AnalysisFinishedEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n+import com.ca.lsp.cobol.service.MyDocumentModel;\n+import com.ca.lsp.cobol.service.MyTextDocumentService;\n+import com.google.inject.Inject;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.extern.slf4j.Slf4j;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This task provides DocumentSymbol structure for the document. This structure is used for Outlive view.\n+ */\n+@Slf4j\n+public class OutlineTask implements EventObserver<AnalysisFinishedEvent> {\n+\n+  private transient DataBusBroker databus;\n+  private transient MyTextDocumentService textDocumentService;\n+  private String documentUri;\n+  private transient CompletableFuture<MyDocumentModel> waitForDocumentModel;\n+\n+  @Inject\n+  public OutlineTask(\n+      DataBusBroker databus,\n+      MyTextDocumentService textDocumentService,\n+      @Assisted(\"documentUri\") String documentUri) {\n+    this.databus = databus;\n+    this.textDocumentService = textDocumentService;\n+    this.documentUri = documentUri;\n+    this.waitForDocumentModel = new CompletableFuture<>();\n+  }\n+\n+  public List<Either<SymbolInformation, DocumentSymbol>> collectSymbols() {\n+    return collectSymbols(extractDocumentModel());", "originalCommit": "ba804e9a2113d0490ec91b431213eb399fb508c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwMzgyMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476503821", "bodyText": "I've rewritten the logic here, probably, you will like it more.", "author": "grianbrcom", "createdAt": "2020-08-25T14:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2Mzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2OTE3OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476269178", "bodyText": "Missing javadoc for test class", "author": "temanbrcom", "createdAt": "2020-08-25T08:24:54Z", "path": "server/src/test/java/com/ca/lsp/cobol/service/delegates/outline/OutlineTaskTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.outline;\n+\n+import com.ca.lsp.cobol.service.MyDocumentModel;\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import lombok.Value;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+", "originalCommit": "ba804e9a2113d0490ec91b431213eb399fb508c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNTYwMQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476505601", "bodyText": "No test - no documentation. Easy!", "author": "grianbrcom", "createdAt": "2020-08-25T14:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2OTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwODc5NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476308794", "bodyText": "Please, add a javadoc here", "author": "temanbrcom", "createdAt": "2020-08-25T09:25:06Z", "path": "server/src/test/java/com/ca/lsp/cobol/usecases/TestOutlineTree.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.positive.CobolText;\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.NodeType;\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.analyze;\n+import static com.ca.lsp.core.cobol.semantics.outline.NodeType.*;\n+import static org.junit.Assert.assertEquals;\n+", "originalCommit": "3d493cc60c9894c198bdd4d3a6e7102d00efb126", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzYzMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476317633", "bodyText": "May it be something like \"VariableNode\" not to have name interferences", "author": "temanbrcom", "createdAt": "2020-08-25T09:39:35Z", "path": "server/src/main/java/com/ca/lsp/core/cobol/semantics/outline/OutlineTreeBuilder.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.google.common.collect.Multimap;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.Token;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The builder for constructing outline tree.\n+ *\n+ * Uses ParserRuleContext for finding the element's parent.\n+ */\n+@Slf4j\n+public class OutlineTreeBuilder {\n+  private List<DocumentSymbol> rootNodes = new ArrayList<>();\n+  private Map<ParserRuleContext, DocumentSymbol> nodesByContext = new HashMap<>();\n+  private Deque<Variable> variables;\n+  private DocumentSymbol latestVariable;\n+  private Map<Token, Position> positionMapping;\n+\n+  public OutlineTreeBuilder(String documentUri, Map<Token, Position> positionMapping) {\n+    this.positionMapping = Collections.unmodifiableMap(positionMapping.entrySet().stream()\n+        .filter(tokenPositionEntry -> tokenPositionEntry.getValue().getDocumentURI().equals(documentUri))\n+        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));\n+  }\n+\n+  public void addProgram(ParserRuleContext parserRuleContext) {\n+    DocumentSymbol outlineNode = constructNode(\"PROGRAM\", NodeType.PROGRAM, parserRuleContext);\n+    if (outlineNode == null) {\n+      return;\n+    }\n+    rootNodes.add(outlineNode);\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+  }\n+\n+  public void addNode(String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    DocumentSymbol outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    if (outlineNode == null) {\n+      return;\n+    }\n+    addNodeToParent(outlineNode, parserRuleContext);\n+  }\n+\n+  private void addNodeToParent(DocumentSymbol outlineNode, ParserRuleContext parserRuleContext) {\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      DocumentSymbol parentNode = nodesByContext.get(parent);\n+      if (parentNode != null) {\n+        parentNode.getChildren().add(outlineNode);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    rootNodes.add(outlineNode);\n+  }\n+\n+  public void renameProgram(String name, ParserRuleContext parserRuleContext) {\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      DocumentSymbol parentNode = nodesByContext.get(parent);\n+      if (parentNode != null && parentNode.getKind() == NodeType.PROGRAM.getSymbolKind()) {\n+        parentNode.setName(\"PROGRAM: \" + name);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    LOG.warn(\"Can't rename program '{}'. Program node is not found.\", name);\n+  }\n+\n+  public void initVariables() {\n+    variables = new ArrayDeque<>();\n+    latestVariable = null;\n+  }\n+\n+  public void addVariable(int level, String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    DocumentSymbol outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    if (outlineNode == null) {\n+      return;\n+    }\n+    while (!variables.isEmpty() && variables.peekLast().level >= level) {\n+      variables.removeLast();\n+    }\n+    Variable groupItem = variables.peekLast();\n+    if (level == 88) {\n+      if (latestVariable == null) {\n+        addNodeToParent(outlineNode, parserRuleContext);\n+      } else {\n+        latestVariable.getChildren().add(outlineNode);\n+      }\n+      return;\n+    }\n+    latestVariable = outlineNode;\n+    if (groupItem != null) {\n+      groupItem.outlineNode.getChildren().add(outlineNode);\n+    } else {\n+      addNodeToParent(outlineNode, parserRuleContext);\n+    }\n+    if (NodeType.STRUCT == nodeType ||\n+        NodeType.REDEFINES == nodeType) {\n+      variables.addLast(new Variable(level, outlineNode));\n+    }\n+  }\n+\n+  public OutlineTree build(Multimap<String, Position> copybookUsages) {\n+    rootNodes.forEach(this::recalculateStructRange);\n+    for (Map.Entry<String, Position> copybook: copybookUsages.entries()) {\n+      String name = copybook.getKey();\n+      Position position = copybook.getValue();\n+      Range outlineRange = new Range(\n+          new org.eclipse.lsp4j.Position(position.getLine(), position.getCharPositionInLine()),\n+          new org.eclipse.lsp4j.Position(position.getLine(), position.getCharPositionInLine()+name.length())\n+      );\n+      DocumentSymbol outlineNode = new DocumentSymbol(\"COPY \" + name, NodeType.COPYBOOK.getSymbolKind(), outlineRange, outlineRange, \"\", List.of());\n+      addOutlineNodeToTree(rootNodes, outlineNode);\n+    }\n+    return new OutlineTree(rootNodes, true);\n+  }\n+\n+  private void recalculateStructRange(DocumentSymbol node) {\n+    node.getChildren().forEach(this::recalculateStructRange);\n+    if (node.getKind() == NodeType.STRUCT.getSymbolKind()) {\n+      node.getRange().setEnd(node.getChildren().stream()\n+          .map(DocumentSymbol::getRange)\n+          .map(Range::getEnd)\n+          .max(Comparator.comparingInt(org.eclipse.lsp4j.Position::getLine)\n+              .thenComparingInt(org.eclipse.lsp4j.Position::getCharacter))\n+          .orElse(node.getRange().getEnd()));\n+    }\n+  }\n+\n+  private void addOutlineNodeToTree(List<DocumentSymbol> outlineNodes, DocumentSymbol outlineNode) {\n+    outlineNodes.stream()\n+        .filter(it -> RangeUtils.isInsideRange(it, outlineNode))\n+        .findFirst()\n+        .ifPresentOrElse(\n+            it -> addOutlineNodeToTree(it.getChildren(), outlineNode),\n+            () -> outlineNodes.add(outlineNode));\n+  }\n+\n+  private DocumentSymbol constructNode(String name, NodeType type, ParserRuleContext parserRuleContext) {\n+    Range range = extractRange(parserRuleContext);\n+    if (range == null) {\n+      return null;\n+    }\n+    return new DocumentSymbol(name, type.getSymbolKind(), range, range, \"\", new ArrayList<>());\n+  }\n+\n+  private Range extractRange(ParserRuleContext parserRuleContext) {\n+    org.eclipse.lsp4j.Position start = extractPosition(parserRuleContext.start);\n+    org.eclipse.lsp4j.Position stop = extractPosition(parserRuleContext.stop);\n+    if (start == null || stop == null) {\n+      return null;\n+    }\n+    return new Range(start, stop);\n+  }\n+\n+  private org.eclipse.lsp4j.Position extractPosition(Token token) {\n+    Position position = positionMapping.get(token);\n+    if (position == null) {\n+      return null;\n+    }\n+    return new org.eclipse.lsp4j.Position(position.getLine(), position.getCharPositionInLine());\n+  }\n+\n+  @Value\n+  private class Variable {", "originalCommit": "3d493cc60c9894c198bdd4d3a6e7102d00efb126", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMzMjQ5OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476332498", "bodyText": "In this case, the positions will be null if the rule is adjacent to a copybook. I would recommend a filtration for tokens by channel 0 - they are guaranteed to present in the mapping.  The tokens might be taken from the BufferedTokenStream by the source interval", "author": "temanbrcom", "createdAt": "2020-08-25T10:04:17Z", "path": "server/src/main/java/com/ca/lsp/core/cobol/semantics/outline/OutlineTreeBuilder.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics.outline;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.google.common.collect.Multimap;\n+import lombok.Value;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.Token;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.eclipse.lsp4j.Range;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The builder for constructing outline tree.\n+ *\n+ * Uses ParserRuleContext for finding the element's parent.\n+ */\n+@Slf4j\n+public class OutlineTreeBuilder {\n+  private List<DocumentSymbol> rootNodes = new ArrayList<>();\n+  private Map<ParserRuleContext, DocumentSymbol> nodesByContext = new HashMap<>();\n+  private Deque<Variable> variables;\n+  private DocumentSymbol latestVariable;\n+  private Map<Token, Position> positionMapping;\n+\n+  public OutlineTreeBuilder(String documentUri, Map<Token, Position> positionMapping) {\n+    this.positionMapping = Collections.unmodifiableMap(positionMapping.entrySet().stream()\n+        .filter(tokenPositionEntry -> tokenPositionEntry.getValue().getDocumentURI().equals(documentUri))\n+        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));\n+  }\n+\n+  public void addProgram(ParserRuleContext parserRuleContext) {\n+    DocumentSymbol outlineNode = constructNode(\"PROGRAM\", NodeType.PROGRAM, parserRuleContext);\n+    if (outlineNode == null) {\n+      return;\n+    }\n+    rootNodes.add(outlineNode);\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+  }\n+\n+  public void addNode(String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    DocumentSymbol outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    if (outlineNode == null) {\n+      return;\n+    }\n+    addNodeToParent(outlineNode, parserRuleContext);\n+  }\n+\n+  private void addNodeToParent(DocumentSymbol outlineNode, ParserRuleContext parserRuleContext) {\n+    nodesByContext.put(parserRuleContext, outlineNode);\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      DocumentSymbol parentNode = nodesByContext.get(parent);\n+      if (parentNode != null) {\n+        parentNode.getChildren().add(outlineNode);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    rootNodes.add(outlineNode);\n+  }\n+\n+  public void renameProgram(String name, ParserRuleContext parserRuleContext) {\n+    ParserRuleContext parent = parserRuleContext.getParent();\n+    while (parent != null) {\n+      DocumentSymbol parentNode = nodesByContext.get(parent);\n+      if (parentNode != null && parentNode.getKind() == NodeType.PROGRAM.getSymbolKind()) {\n+        parentNode.setName(\"PROGRAM: \" + name);\n+        return;\n+      }\n+      parent = parent.getParent();\n+    }\n+    LOG.warn(\"Can't rename program '{}'. Program node is not found.\", name);\n+  }\n+\n+  public void initVariables() {\n+    variables = new ArrayDeque<>();\n+    latestVariable = null;\n+  }\n+\n+  public void addVariable(int level, String name, NodeType nodeType, ParserRuleContext parserRuleContext) {\n+    DocumentSymbol outlineNode = constructNode(name, nodeType, parserRuleContext);\n+    if (outlineNode == null) {\n+      return;\n+    }\n+    while (!variables.isEmpty() && variables.peekLast().level >= level) {\n+      variables.removeLast();\n+    }\n+    Variable groupItem = variables.peekLast();\n+    if (level == 88) {\n+      if (latestVariable == null) {\n+        addNodeToParent(outlineNode, parserRuleContext);\n+      } else {\n+        latestVariable.getChildren().add(outlineNode);\n+      }\n+      return;\n+    }\n+    latestVariable = outlineNode;\n+    if (groupItem != null) {\n+      groupItem.outlineNode.getChildren().add(outlineNode);\n+    } else {\n+      addNodeToParent(outlineNode, parserRuleContext);\n+    }\n+    if (NodeType.STRUCT == nodeType ||\n+        NodeType.REDEFINES == nodeType) {\n+      variables.addLast(new Variable(level, outlineNode));\n+    }\n+  }\n+\n+  public OutlineTree build(Multimap<String, Position> copybookUsages) {\n+    rootNodes.forEach(this::recalculateStructRange);\n+    for (Map.Entry<String, Position> copybook: copybookUsages.entries()) {\n+      String name = copybook.getKey();\n+      Position position = copybook.getValue();\n+      Range outlineRange = new Range(\n+          new org.eclipse.lsp4j.Position(position.getLine(), position.getCharPositionInLine()),\n+          new org.eclipse.lsp4j.Position(position.getLine(), position.getCharPositionInLine()+name.length())\n+      );\n+      DocumentSymbol outlineNode = new DocumentSymbol(\"COPY \" + name, NodeType.COPYBOOK.getSymbolKind(), outlineRange, outlineRange, \"\", List.of());\n+      addOutlineNodeToTree(rootNodes, outlineNode);\n+    }\n+    return new OutlineTree(rootNodes, true);\n+  }\n+\n+  private void recalculateStructRange(DocumentSymbol node) {\n+    node.getChildren().forEach(this::recalculateStructRange);\n+    if (node.getKind() == NodeType.STRUCT.getSymbolKind()) {\n+      node.getRange().setEnd(node.getChildren().stream()\n+          .map(DocumentSymbol::getRange)\n+          .map(Range::getEnd)\n+          .max(Comparator.comparingInt(org.eclipse.lsp4j.Position::getLine)\n+              .thenComparingInt(org.eclipse.lsp4j.Position::getCharacter))\n+          .orElse(node.getRange().getEnd()));\n+    }\n+  }\n+\n+  private void addOutlineNodeToTree(List<DocumentSymbol> outlineNodes, DocumentSymbol outlineNode) {\n+    outlineNodes.stream()\n+        .filter(it -> RangeUtils.isInsideRange(it, outlineNode))\n+        .findFirst()\n+        .ifPresentOrElse(\n+            it -> addOutlineNodeToTree(it.getChildren(), outlineNode),\n+            () -> outlineNodes.add(outlineNode));\n+  }\n+\n+  private DocumentSymbol constructNode(String name, NodeType type, ParserRuleContext parserRuleContext) {\n+    Range range = extractRange(parserRuleContext);\n+    if (range == null) {\n+      return null;\n+    }\n+    return new DocumentSymbol(name, type.getSymbolKind(), range, range, \"\", new ArrayList<>());\n+  }\n+\n+  private Range extractRange(ParserRuleContext parserRuleContext) {\n+    org.eclipse.lsp4j.Position start = extractPosition(parserRuleContext.start);\n+    org.eclipse.lsp4j.Position stop = extractPosition(parserRuleContext.stop);", "originalCommit": "3d493cc60c9894c198bdd4d3a6e7102d00efb126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2MDYyOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476360628", "bodyText": "There is another restriction in the Outline view. We must show things that belong only to the opened program file.\nIDE can't navigate the user to another file from the Outline view. There is no way to open a copybook when the user clicks on some Outline view element. The main idea of that behavior is hiding things that came from copybooks.", "author": "grianbrcom", "createdAt": "2020-08-25T10:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMzMjQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMDc1NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476400755", "bodyText": "looks like this class is no longer used", "author": "zacanbrcom", "createdAt": "2020-08-25T12:14:13Z", "path": "server/src/test/java/com/ca/lsp/cobol/service/delegates/outline/OutlineTaskTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.outline;\n+\n+import com.ca.lsp.cobol.service.MyDocumentModel;\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import com.ca.lsp.core.cobol.semantics.outline.OutlineTree;\n+import lombok.Value;\n+import org.eclipse.lsp4j.DocumentSymbol;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class OutlineTaskTest {\n+  @Test\n+  public void collectSymbols() {\n+    DocumentSymbol theDocumentSymbol = new DocumentSymbol();\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\", AnalysisResult.builder().outlineTree(\n+        new OutlineTree(List.of(theDocumentSymbol), true)).build());\n+    List<Either<SymbolInformation, DocumentSymbol>> expectedResult = List.of(Either.forRight(theDocumentSymbol));\n+    assertEquals(expectedResult, OutlineTask.collectSymbols(documentModel));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullDocumentModel() {\n+    assertEquals(List.of(), OutlineTask.collectSymbols(null));\n+  }\n+\n+  @Test\n+  public void collectSymbolsForNullOutlineTree() {\n+    MyDocumentModel documentModel = new MyDocumentModel(\"\", AnalysisResult.builder().build());\n+    assertEquals(List.of(), OutlineTask.collectSymbols(documentModel));\n+  }\n+\n+  @Value\n+  private class Cursor {\n+    int line;\n+    int character;\n+  }", "originalCommit": "3d493cc60c9894c198bdd4d3a6e7102d00efb126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwMzA2Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476503062", "bodyText": "Oops. You are right. I deleted the whole test to be sure =)", "author": "grianbrcom", "createdAt": "2020-08-25T14:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMDc1NQ=="}], "type": "inlineReview"}, {"oid": "f520ff96a29a66db4318ad588a21e422a76663bf", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f520ff96a29a66db4318ad588a21e422a76663bf", "message": "feat: Outline view support #481\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-08-25T14:45:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMTk2Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476521967", "bodyText": "Will it work if we receive this request two times for one analysis? I.e. when we receive didOpen and outline, then didChange and outline again, but at the time when the didChange has not put the new feature to the map?", "author": "temanbrcom", "createdAt": "2020-08-25T15:05:52Z", "path": "server/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -276,6 +280,16 @@ private void notifyAnalysisFinished(String uri, Map<String, List<Location>> copy\n             .build());\n   }\n \n+  @Override\n+  public CompletableFuture<List<Either<SymbolInformation, DocumentSymbol>>> documentSymbol(DocumentSymbolParams params) {\n+    String uri = params.getTextDocument().getUri();\n+    return outlineMap.get(uri)\n+        .thenApply(documentSymbols -> documentSymbols.stream()", "originalCommit": "f520ff96a29a66db4318ad588a21e422a76663bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MzM0OA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r476553348", "bodyText": "I think since the didChange is doing his stuff on the client side there is the \"old\" version of the outline view that should be replaced on the client (I am testing that behavior)", "author": "zacanbrcom", "createdAt": "2020-08-25T15:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0MTI4Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/439#discussion_r477141287", "bodyText": "Here is the simple test for future:\n  @Test\n  void test() throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> cf = new CompletableFuture<>();\n    cf.complete(42);\n    System.out.println(process(cf));\n    System.out.println(process(cf));\n  }\n\n  int process(CompletableFuture<Integer> cf) throws ExecutionException, InterruptedException {\n    return cf.thenApply(i -> i*2).get();\n  }\n\nIt works well. I think that it will be safe to resolve the Future twice.", "author": "grianbrcom", "createdAt": "2020-08-26T08:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMTk2Nw=="}], "type": "inlineReview"}, {"oid": "f6034fd67b4daf24055c3bbb35bd70ed752c3d0d", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f6034fd67b4daf24055c3bbb35bd70ed752c3d0d", "message": "feat: Outline view support #481\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-08-26T09:56:32Z", "type": "forcePushed"}, {"oid": "16ba495c5226575a2d530a3c1bc9a9dec156d2d5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/16ba495c5226575a2d530a3c1bc9a9dec156d2d5", "message": "feat: Outline view support #481\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-08-26T11:12:48Z", "type": "commit"}, {"oid": "16ba495c5226575a2d530a3c1bc9a9dec156d2d5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/16ba495c5226575a2d530a3c1bc9a9dec156d2d5", "message": "feat: Outline view support #481\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-08-26T11:12:48Z", "type": "forcePushed"}]}