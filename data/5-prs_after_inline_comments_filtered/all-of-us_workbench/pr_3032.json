{"pr_number": 3032, "pr_title": "[risk=no][RW-2957] Moodle v2 API Integration", "pr_createdAt": "2020-01-23T20:26:42Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3032", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODEwNg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338106", "bodyText": "names up for debate. it's easy enough to change this, but the keys are different and I do have to go push files around in GCS to change the name.", "author": "als364", "createdAt": "2020-01-23T20:28:38Z", "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,11 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return readCredentialsBucketString(\"moodle-key.txt\");\n+    if (configProvider.get().featureFlags.enableMoodleV2Api) {", "originalCommit": "fbb3a5a298cbf80282f117b86ac7a4665b9e976e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "url": "https://github.com/all-of-us/workbench/commit/e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "message": "test and local in sync...", "committedDate": "2020-01-23T20:37:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODIzMg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338232", "bodyText": "Why did we move to the deprecated class here? Should this method be marked deprecated as well?", "author": "jaycarlton", "createdAt": "2020-01-23T20:28:58Z", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -22,5 +24,16 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetails> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadge(int userMoodleId) throws ApiException;", "originalCommit": "0fae3b654761a25daf0d901b6302d3d67db04bdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzODcxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370338719", "bodyText": "Can you please return an empty map instead of null? Otherwise, the next best thing is Optional<Map>, which is no less awkward. In general, if I call a method returning a collection in Java, I don't expect nor do I check for null.", "author": "jaycarlton", "createdAt": "2020-01-23T20:30:03Z", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +92,33 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return null;", "originalCommit": "0fae3b654761a25daf0d901b6302d3d67db04bdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzOTUxNg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370339516", "bodyText": "Please log this at a WARNING level (or at least INFO), so that we can track this down.", "author": "jaycarlton", "createdAt": "2020-01-23T20:31:54Z", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +92,33 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return null;\n+    }\n+\n+    UserBadgeResponse response =\n+        moodleApiProvider.get().getMoodleBadge(RESPONSE_FORMAT, getToken(), email);\n+    if (response.getException() != null && response.getException().equals(MOODLE_EXCEPTION)) {\n+      if (response.getErrorcode().equals(MOODLE_USER_NOT_ALLOWED_ERROR_CODE)) {\n+        throw new ApiException(HttpStatus.NOT_FOUND.value(), response.getMessage());", "originalCommit": "0fae3b654761a25daf0d901b6302d3d67db04bdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MDM1Ng==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370340356", "bodyText": "This function is over a hundred lines long now. Can we split it into 4-5 pieces? I generally consider 20-line functions in need of a haircut.", "author": "jaycarlton", "createdAt": "2020-01-23T20:34:07Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -555,46 +557,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;", "originalCommit": "0fae3b654761a25daf0d901b6302d3d67db04bdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MTE3Mw==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370341173", "bodyText": "Please add a clearComplianceTrainingCompletion() and clearComplianceTrainingExpiration() methods on DbUser so you don't have to pass null as your only argument. This will also help sweep the nullability of the timestamp under the rug in the entity class, so at the service level we don't need to think about it.", "author": "jaycarlton", "createdAt": "2020-01-23T20:36:04Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -555,46 +557,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {\n+        List<BadgeDetailsDeprecated> badgeResponse = complianceService.getUserBadge(moodleId);\n+        // The assumption here is that the User will always get 1 badge which will be AoU\n+        if (badgeResponse != null && badgeResponse.size() > 0) {\n+          BadgeDetailsDeprecated badge = badgeResponse.get(0);\n+          expiryEpoch = badge.getDateexpire();\n+        } else {\n+          // Moodle has returned zero badges for the given user -- we should clear the user's\n+          // training completion & expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);", "originalCommit": "0fae3b654761a25daf0d901b6302d3d67db04bdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MzgwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370343805", "bodyText": "The mapper impl files are generated at compile time, and should not be checked into source control.", "author": "jaycarlton", "createdAt": "2020-01-23T20:42:17Z", "path": "api/src/main/generated/org/pmiops/workbench/utils/WorkspaceMapperImpl.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.pmiops.workbench.utils;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import javax.annotation.Generated;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbWorkspace;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspace;\n+import org.pmiops.workbench.model.ResearchPurpose;\n+import org.pmiops.workbench.model.SpecificPopulationEnum;\n+import org.pmiops.workbench.model.UserRole;\n+import org.pmiops.workbench.model.Workspace;\n+import org.pmiops.workbench.utils.mappers.CommonMappers;\n+import org.springframework.stereotype.Component;\n+\n+@Generated(", "originalCommit": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NTU1MA==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370865550", "bodyText": "something is clearly broken with gitignore.", "author": "als364", "createdAt": "2020-01-24T22:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0MzgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDIxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370344215", "bodyText": "There's lots of nesting and mutable state going on here, which makes it easy to write bugs.", "author": "jaycarlton", "createdAt": "2020-01-23T20:43:13Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {", "originalCommit": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDQ4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370344485", "bodyText": "Please put these constants into a config file, and also rename them to indicate v1 vs v2 somehow.", "author": "jaycarlton", "createdAt": "2020-01-23T20:43:54Z", "path": "api/src/main/java/org/pmiops/workbench/google/CloudStorageServiceImpl.java", "diffHunk": "@@ -47,7 +47,12 @@ public String readMandrillApiKey() {\n \n   @Override\n   public String getMoodleApiKey() {\n-    return getCredentialsBucketString(\"moodle-key.txt\");\n+    if(configProvider.get().featureFlags.enableMoodleV2Api) {\n+      return getCredentialsBucketString(\"moodle.txt\");", "originalCommit": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM0NzE0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371347142", "bodyText": "We don't yet have application config patterns, which is where these might need to go, or a parent JSON file that individual environments could override. I would still rename the credentials files moodle-key-v1.txt and moodle-key-v2.txt (or leave the current one alone).", "author": "jaycarlton", "createdAt": "2020-01-27T16:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM1MDk0OA==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371350948", "bodyText": "Because we push these creds manually to google buckets I have to leave the current one alone for the meantime. I can rename the new one v2 though.", "author": "als364", "createdAt": "2020-01-27T16:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NDQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NTY5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370345696", "bodyText": "I'm wondering why the badge- and moodle-specific logic needs to live in the UserService.", "author": "jaycarlton", "createdAt": "2020-01-23T20:46:47Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =", "originalCommit": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NjM0MQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370346341", "bodyText": "Please make expiryEpoch an Optional, since it's not guaranteed to be there. You can do that with badgeResponse.stream().findFirst(), so you get rid of the scary get(0).", "author": "jaycarlton", "createdAt": "2020-01-23T20:48:05Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -582,46 +584,71 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n       return dbUser;\n     }\n \n-    Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n     try {\n       Integer moodleId = dbUser.getMoodleId();\n+      String email = dbUser.getUsername();\n       if (moodleId == null) {\n-        moodleId = complianceService.getMoodleId(dbUser.getUsername());\n+        moodleId = complianceService.getMoodleId(email);\n         if (moodleId == null) {\n           // User has not yet created/logged into MOODLE\n           return dbUser;\n         }\n         dbUser.setMoodleId(moodleId);\n       }\n \n-      List<BadgeDetails> badgeResponse = complianceService.getUserBadge(moodleId);\n-      // The assumption here is that the User will always get 1 badge which will be AoU\n-      if (badgeResponse != null && badgeResponse.size() > 0) {\n-        BadgeDetails badge = badgeResponse.get(0);\n-        Timestamp badgeExpiration =\n-            badge.getDateexpire() == null\n-                ? null\n-                : new Timestamp(Long.parseLong(badge.getDateexpire()));\n+      String expiryEpoch = null;\n+      if (configProvider.get().featureFlags.enableMoodleV2Api) {\n+        Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(email);\n+        if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+          BadgeDetails badge =\n+              userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+          expiryEpoch =\n+              badge.getGlobalexpiration() == null\n+                  ? badge.getDateexpire()\n+                  : badge.getGlobalexpiration();\n+        } else {\n+          // Moodle has not returned research ethics training information for the given user --\n+          // we should clear the user's training completion and expiration time.\n+          dbUser.setComplianceTrainingCompletionTime(null);\n+          dbUser.setComplianceTrainingExpirationTime(null);\n+        }\n+      } else {\n+        List<BadgeDetailsDeprecated> badgeResponse = complianceService.getUserBadge(moodleId);\n+        // The assumption here is that the User will always get 1 badge which will be AoU\n+        if (badgeResponse != null && badgeResponse.size() > 0) {\n+          BadgeDetailsDeprecated badge = badgeResponse.get(0);\n+          expiryEpoch = badge.getDateexpire();", "originalCommit": "e79eb7e8593888376eee7c6dc8aeca6ff3b82be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5NTU2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370895563", "bodyText": "Please also add the @Deprecated annotation, which will make this more obvious. I'd probably just name it getUserBadgeV1(), in case you have to support more than one deprecated version. Let's hope not.\nThere's also a @deprecated javadoc annotation FWIW.", "author": "jaycarlton", "createdAt": "2020-01-25T00:25:51Z", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -24,7 +24,7 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetailsDeprecated> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadgeDeprecated(int userMoodleId) throws ApiException;", "originalCommit": "f81728e28a0f64597e24129deb0de4a0909fefe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MjIwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371272205", "bodyText": "Hmm. Somehow, the workspace mapper impl file lives in a genenrated dir, which explians why it doesn't get picked up: workbench/api/build/generated/sources/annotationProcessor/java/main/org/pmiops/workbench/utils/WorkspaceMapperImpl.java\nI don't believe we want to . mask *Impl.java, as it would match lots fo our implementation services.", "author": "jaycarlton", "createdAt": "2020-01-27T14:31:48Z", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -1,14 +1,20 @@\n package org.pmiops.workbench.compliance;\n \n+import java.util.HashMap;", "originalCommit": "f81728e28a0f64597e24129deb0de4a0909fefe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMzODMyNw==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371338327", "bodyText": "What is this comment in reference to? I don't think it is actually about importing HashMap", "author": "als364", "createdAt": "2020-01-27T16:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MjIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDcyNQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950725", "bodyText": "Terminology note / nitpick: I think we should be consistent in how we're referring to v1 vs. v2 of the API.\nThe config feature flag implies we're treating these as \"v1\" vs \"v2\", but the code implies we're treating these as \"the deprecated version\" versus \"the current version\".\nMy slight preference would be to align on the v1-v2 distinction, partly because \"deprecated\" is long-winded, and partly because it's more clearly referring to different API versions.\nObviously, once this has rolled to prod and we clean up the feature flag, this would go back to having no distinction at all.", "author": "gjuggler", "createdAt": "2020-01-25T19:18:28Z", "path": "api/src/main/java/org/pmiops/workbench/api/OfflineUserController.java", "diffHunk": "@@ -66,7 +73,12 @@ private boolean timestampsEqual(Timestamp a, Timestamp b) {\n         Timestamp oldTime = user.getComplianceTrainingCompletionTime();\n         DataAccessLevel oldLevel = user.getDataAccessLevelEnum();\n \n-        DbUser updatedUser = userService.syncComplianceTrainingStatus(user);\n+        DbUser updatedUser;\n+        if(workbenchConfigProvider.get().featureFlags.enableMoodleV2Api) {\n+          updatedUser = userService.syncComplianceTrainingStatus(user);\n+        } else {\n+          updatedUser = userService.syncComplianceTrainingStatusDeprecated(user);", "originalCommit": "f81728e28a0f64597e24129deb0de4a0909fefe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDgxMg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950812", "bodyText": "[Naming super-nitpick] When I first read this method name, I thought the parameter would be a username. But the \"byName\" is saying something about the return map, not the parameter.\nIt might be slightly cleaner to call this \"getUserBadgesByBadgeName\", or maybe \"getUserBadgesMap\" which is more concise but less specific.", "author": "gjuggler", "createdAt": "2020-01-25T19:20:13Z", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceService.java", "diffHunk": "@@ -22,5 +24,16 @@\n    * @return list of badges/completed training by user\n    * @throws ApiException\n    */\n-  List<BadgeDetails> getUserBadge(int userMoodleId) throws ApiException;\n+  List<BadgeDetailsDeprecated> getUserBadgeDeprecated(int userMoodleId) throws ApiException;\n+\n+  /**\n+   * Get details about the Research Ethics Training and the Data Use Agreement badges for a user\n+   *\n+   * @param email\n+   * @return map of badge name to badge details\n+   * @throws ApiException\n+   */\n+  Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException;", "originalCommit": "f81728e28a0f64597e24129deb0de4a0909fefe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMzODU4NQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371338585", "bodyText": "I'm happy being verbose as long as I can tab-complete names", "author": "als364", "createdAt": "2020-01-27T16:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDk1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370950955", "bodyText": "[Naming nit] Inconsistency here: the map is called \"badges by name\", but the key variables are called \"fields\". Consider aligning everything with the \"name\" terminology, e.g. rename the constants to\nDATA_USE_AGREEMENT_BADGE or\nDUA_BADGE_NAME\nor something similar.", "author": "gjuggler", "createdAt": "2020-01-25T19:23:20Z", "path": "api/src/main/java/org/pmiops/workbench/compliance/ComplianceServiceImpl.java", "diffHunk": "@@ -84,4 +96,34 @@ public Integer getMoodleId(String email) throws ApiException {\n     }\n     return response.getBadges();\n   }\n+\n+  @Override\n+  public Map<String, BadgeDetails> getUserBadgesByName(String email) throws ApiException {\n+    if (!enableMoodleCalls()) {\n+      return new HashMap<>();\n+    }\n+\n+    UserBadgeResponse response =\n+        moodleApiProvider.get().getMoodleBadge(RESPONSE_FORMAT, getToken(), email);\n+    if (response.getException() != null && response.getException().equals(MOODLE_EXCEPTION)) {\n+      logger.warning(response.getMessage());\n+      if (response.getErrorcode().equals(MOODLE_USER_NOT_ALLOWED_ERROR_CODE)) {\n+        throw new ApiException(HttpStatus.NOT_FOUND.value(), response.getMessage());\n+      } else {\n+        throw new ApiException(response.getMessage());\n+      }\n+    }\n+    Map<String, BadgeDetails> userBadgesByName = new HashMap<>();\n+    if (response.getDua() != null) {\n+      userBadgesByName.put(DUA_FIELD, response.getDua());", "originalCommit": "f81728e28a0f64597e24129deb0de4a0909fefe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMyMjg4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371322887", "bodyText": "This is probably a holdover from how Zak and/or Moodle talks about the data they return.", "author": "als364", "createdAt": "2020-01-27T15:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MDk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370953006", "bodyText": "Shouldn't these lines be in the form: u.setFoo(dbUser.getFoo())", "author": "gjuggler", "createdAt": "2020-01-25T20:04:20Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());", "originalCommit": "f81728e28a0f64597e24129deb0de4a0909fefe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMyOTE0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371329142", "bodyText": "dbUser is u here. I just kind of cargo culted this block over from the last function.\nLooking at updateUserWithRetries now, it applies the function passed to it to the user passed to it and also sets lastModifiedTime and enforces data access level changes as a side effect of aforementioned function.\nThese Moodle functions are the only place we do something like this - everywhere else we pass in a value unattached to the dbUser we're changing.  I think that, as originally intended, this function was mean to apply changes calculated elsewhere and we're just mutating dbUser so as to not have to think about nullity semantics\nWhat do you think about something like:\nTimestamp newComplianceTrainingCompletionTime = null;\nTimestamp newComplianceTrainingExpirationTime = null;\n{...}\nif (badge valid) {\n    if (badge was previously invalid and is now valid) {\n        newComplianceTrainingCompletionTime = now\n    } else if (old expiry time is not new expiry time) {\n        newComplianceTrainingCompletionTime = now\n    }\n    newComplianceTrainingExpirationTime = badgeExpiryDate\n}\n// get rid of all the lines nulling out timestamps and get rid of those 'clear' functions\n{...}\nreturn updateUserWithRetries(u -> {\n    u.setComplianceTrainingCompletionTime(newComplianceTrainingCompletionTime);\n    u.setComplianceTrainingExpirationTime(newComplianceTrainingExpirationTime);\n}, dbUser);", "author": "als364", "createdAt": "2020-01-27T16:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM0MTM4Mw==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371341383", "bodyText": "\ud83d\udc4d That approach seems much better, especially if it's more consistent with how we do it elsewhere.", "author": "gjuggler", "createdAt": "2020-01-27T16:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM0NjEzNg==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371346136", "bodyText": "nit: This still feels more badgey than usery, and like the kind of thing that could go in its own little service. While we have a very wide data model for the user table, we don't have to make its service know everything about how to calculate those columns.\nFWIW, there are a handful of things whose recalculation is triggered on every user \"change\", and that's one of the main motivations of the withRetries() stuff.", "author": "jaycarlton", "createdAt": "2020-01-27T16:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM1MDMwMQ==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371350301", "bodyText": "I'd be ok with moving it, but I'd rather do so after deprecating the old call so that I don't have to either have the v1 and v2 in separate places or move the deprecated function.", "author": "als364", "createdAt": "2020-01-27T16:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzA2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r370953063", "bodyText": "I think it would be helpful to have this log for other types of error codes too \u2013\u00a0maybe bump this up a couple lines outside of the if-else block?", "author": "gjuggler", "createdAt": "2020-01-25T20:05:35Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -646,6 +648,78 @@ public DbUser syncComplianceTrainingStatus(DbUser dbUser)\n     }\n   }\n \n+  /** Syncs the current user's training status from Moodle. */\n+  public DbUser syncComplianceTrainingStatus() throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    return syncComplianceTrainingStatus(userProvider.get());\n+  }\n+\n+  /**\n+   * Updates the given user's training status from Moodle.\n+   *\n+   * <p>We can fetch Moodle data for arbitrary users since we use an API key to access Moodle,\n+   * rather than user-specific OAuth tokens.\n+   *\n+   * <p>Using the user's email, we can get their badges from Moodle's APIs. If the badges are marked\n+   * valid, we store their completion/expiration dates in the database. If they are marked invalid,\n+   * we clear the completion/expiration dates from the database as the user will need to complete a\n+   * new training.\n+   */\n+  public DbUser syncComplianceTrainingStatus(DbUser dbUser) throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n+    // Skip sync for service account user rows.\n+    if (isServiceAccount(dbUser)) {\n+      return dbUser;\n+    }\n+\n+    try {\n+      Timestamp now = new Timestamp(clock.instant().toEpochMilli());\n+      Map<String, BadgeDetails> userBadgesByName = complianceService.getUserBadgesByName(dbUser.getUsername());\n+      if (userBadgesByName.containsKey(complianceService.getResearchEthicsTrainingField())) {\n+        BadgeDetails complianceBadge = userBadgesByName.get(complianceService.getResearchEthicsTrainingField());\n+        if(complianceBadge.getValid()) {\n+          if (dbUser.getComplianceTrainingCompletionTime() == null) {\n+            // The badge was previously invalid and is now valid.\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          } else if (!dbUser.getComplianceTrainingExpirationTime().equals(new Timestamp(complianceBadge.getDateexpire()))) {\n+            // The badge was previously valid, but has a new expiration date (and so is a new training)\n+            dbUser.setComplianceTrainingCompletionTime(now);\n+          }\n+          // Always update the expiration time.\n+          dbUser.setComplianceTrainingExpirationTime(new Timestamp(complianceBadge.getDateexpire()));\n+        }\n+        else {\n+          // The current badge is invalid or expired, the training must be completed or retaken.\n+          dbUser.clearComplianceTrainingCompletionTime();\n+          dbUser.clearComplianceTrainingExpirationTime();\n+        }\n+      }\n+      else {\n+        // There is no record of this person having taken the training.\n+        dbUser.clearComplianceTrainingCompletionTime();\n+        dbUser.clearComplianceTrainingExpirationTime();\n+      }\n+\n+      return updateUserWithRetries(\n+          u -> {\n+            u.setComplianceTrainingExpirationTime(u.getComplianceTrainingExpirationTime());\n+            u.setComplianceTrainingCompletionTime(u.getComplianceTrainingCompletionTime());\n+            return u;\n+          },\n+          dbUser);\n+    } catch (NumberFormatException e) {\n+      log.severe(\"Incorrect date expire format from Moodle\");\n+      throw e;\n+    } catch (org.pmiops.workbench.moodle.ApiException ex) {\n+      if (ex.getCode() == HttpStatus.NOT_FOUND.value()) {\n+        log.severe(", "originalCommit": "f81728e28a0f64597e24129deb0de4a0909fefe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMzNTQwNA==", "url": "https://github.com/all-of-us/workbench/pull/3032#discussion_r371335404", "bodyText": "I'll put a different log but this one is for a specific reason, the message is just unclear", "author": "als364", "createdAt": "2020-01-27T16:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk1MzA2Mw=="}], "type": "inlineReview"}, {"oid": "cd0dedb85c19b65293c698c59039f13e370d2f39", "url": "https://github.com/all-of-us/workbench/commit/cd0dedb85c19b65293c698c59039f13e370d2f39", "message": "add feature flag, first pass on implementation", "committedDate": "2020-01-29T19:47:37Z", "type": "commit"}, {"oid": "ced91dc6dbb8149e962dd2910b39d3c9ee4fa151", "url": "https://github.com/all-of-us/workbench/commit/ced91dc6dbb8149e962dd2910b39d3c9ee4fa151", "message": "actually hitting v2 server", "committedDate": "2020-01-29T19:47:37Z", "type": "commit"}, {"oid": "25381e8b897c8fd01ca628c0f836d732a37d7de5", "url": "https://github.com/all-of-us/workbench/commit/25381e8b897c8fd01ca628c0f836d732a37d7de5", "message": "change v1 to deprecated", "committedDate": "2020-01-29T19:47:38Z", "type": "commit"}, {"oid": "fa9ac275508ad60ef7a4573bd51da12319de35fe", "url": "https://github.com/all-of-us/workbench/commit/fa9ac275508ad60ef7a4573bd51da12319de35fe", "message": "test in sync with local", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "874cbea22a2b98406609a6dcf1ce0037d9a7ea39", "url": "https://github.com/all-of-us/workbench/commit/874cbea22a2b98406609a6dcf1ce0037d9a7ea39", "message": "correct comments", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "e46c180b822b77bea1971eee21ea0cafc1f91a52", "url": "https://github.com/all-of-us/workbench/commit/e46c180b822b77bea1971eee21ea0cafc1f91a52", "message": "remove v1s...", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "c11c83e14a4b9b661f614107d87e437f43102535", "url": "https://github.com/all-of-us/workbench/commit/c11c83e14a4b9b661f614107d87e437f43102535", "message": "spotless", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "809f68ca85b2a50343444cc199b0babcd1a78d3a", "url": "https://github.com/all-of-us/workbench/commit/809f68ca85b2a50343444cc199b0babcd1a78d3a", "message": "new test, remove snark, remove print statements", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "26950b849183645a0b9cf983ab2743d365549c8f", "url": "https://github.com/all-of-us/workbench/commit/26950b849183645a0b9cf983ab2743d365549c8f", "message": "globalexpiration", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "24bc835dcbe9b6f993f19d30117962ee7bc49f95", "url": "https://github.com/all-of-us/workbench/commit/24bc835dcbe9b6f993f19d30117962ee7bc49f95", "message": "better tests", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "b39593bfb6021f14166976b2973e3223262bf43e", "url": "https://github.com/all-of-us/workbench/commit/b39593bfb6021f14166976b2973e3223262bf43e", "message": "test and local in sync...", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "e7b96c03ade23a09fc370b2fa14dd2b242d9d744", "url": "https://github.com/all-of-us/workbench/commit/e7b96c03ade23a09fc370b2fa14dd2b242d9d744", "message": "some review comments", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "9992b0497cee291b8261fd411efc37da4f8621ff", "url": "https://github.com/all-of-us/workbench/commit/9992b0497cee291b8261fd411efc37da4f8621ff", "message": "two separate functions", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "ef10a957237dec79600927e10500c0817b30442e", "url": "https://github.com/all-of-us/workbench/commit/ef10a957237dec79600927e10500c0817b30442e", "message": "intify", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "701412b57611710c9af2472640fa7fa40f39700c", "url": "https://github.com/all-of-us/workbench/commit/701412b57611710c9af2472640fa7fa40f39700c", "message": "wtf", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "49f4fe8ee265dd05948f88af2dcbd9f5127f3ab0", "url": "https://github.com/all-of-us/workbench/commit/49f4fe8ee265dd05948f88af2dcbd9f5127f3ab0", "message": "ugh further cleanup", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "6fc7c21747b5cac76b89bba069c82f8966e2d732", "url": "https://github.com/all-of-us/workbench/commit/6fc7c21747b5cac76b89bba069c82f8966e2d732", "message": "one more Deprecated tag", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "c8dfa5d3da04703c9762f4d229bccb3c94b18a94", "url": "https://github.com/all-of-us/workbench/commit/c8dfa5d3da04703c9762f4d229bccb3c94b18a94", "message": "second round of feedback", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "e05c99bdb8e86cc86654f10f710a0f3b5a99bace", "url": "https://github.com/all-of-us/workbench/commit/e05c99bdb8e86cc86654f10f710a0f3b5a99bace", "message": "offlineusercontrollertest", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "5a2fa2f052fcf7a06369ba7cf9a5d24718b185a1", "url": "https://github.com/all-of-us/workbench/commit/5a2fa2f052fcf7a06369ba7cf9a5d24718b185a1", "message": "rename a couple more Deprecateds, rename new moodle credential key in buckets", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "6b02fc96ca55d0d776b28127e735e1fa330a8225", "url": "https://github.com/all-of-us/workbench/commit/6b02fc96ca55d0d776b28127e735e1fa330a8225", "message": "stateful bad four legs good", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "url": "https://github.com/all-of-us/workbench/commit/e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "message": "spotless", "committedDate": "2020-01-29T19:47:51Z", "type": "commit"}, {"oid": "e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "url": "https://github.com/all-of-us/workbench/commit/e19901eb2bd32d0bf57d0ec17b7fc644bde23670", "message": "spotless", "committedDate": "2020-01-29T19:47:51Z", "type": "forcePushed"}]}