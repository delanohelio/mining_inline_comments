{"pr_number": 3139, "pr_title": "[risk=low][RW-4259]Enforce Verified Institutional Affiliation for new account creation if feature flag is set", "pr_createdAt": "2020-02-16T14:52:35Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3139", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkwOTU3MA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r379909570", "bodyText": "I chose 409 but I'm open to discussion here - will remove the comments when we come to consensus", "author": "jmthibault79", "createdAt": "2020-02-16T15:01:33Z", "path": "api/src/main/java/org/pmiops/workbench/api/InstitutionController.java", "diffHunk": "@@ -29,11 +31,24 @@\n   @Override\n   @AuthorityRequired({Authority.INSTITUTION_ADMIN})\n   public ResponseEntity<Void> deleteInstitution(final String shortName) {\n-    if (institutionService.deleteInstitution(shortName)) {\n-      return ResponseEntity.noContent().build();\n-    } else {\n-      throw new NotFoundException(String.format(\"Could not delete Institution %s\", shortName));\n+    final DeletionResult result = institutionService.deleteInstitution(shortName);\n+\n+    // I wanted to use a switch here but Java complained about lacking a return value\n+    if (result == DeletionResult.HAS_VERIFIED_AFFILIATIONS) {\n+      // TODO: 405 or 409?", "originalCommit": "c7c0461728be4df83df20e6f3a35d751ad3f43f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "843e226490b4afa6d1ab1887140e913d50a824c5", "url": "https://github.com/all-of-us/workbench/commit/843e226490b4afa6d1ab1887140e913d50a824c5", "message": "RW-4259 User model updates for Verified Inst Affil", "committedDate": "2020-02-16T15:39:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkxMzQwNw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r379913407", "bodyText": "EAGER fetching became problematic when this was fetched transitively by VerifiedInstitutionalAffiliation.\nTODO: try to understand the Hibernate fetching model better to understand why this was the case", "author": "jmthibault79", "createdAt": "2020-02-16T15:57:13Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -81,7 +81,7 @@ public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherTe\n     return this;\n   }\n \n-  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL)", "originalCommit": "843e226490b4afa6d1ab1887140e913d50a824c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkxMzQ2OQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r379913469", "bodyText": "since we make any input into a set we can relax the requirement", "author": "jmthibault79", "createdAt": "2020-02-16T15:58:06Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -96,20 +96,22 @@ public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherTe\n    *\n    * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n    *\n-   * @param emailDomains the new set of domains for this Institution\n+   * @param emailDomains the new collection of domains for this Institution", "originalCommit": "843e226490b4afa6d1ab1887140e913d50a824c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkxNTY0OQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r379915649", "bodyText": "@Context lets us use the service in @AfterMapping below", "author": "jmthibault79", "createdAt": "2020-02-16T16:31:25Z", "path": "api/src/main/java/org/pmiops/workbench/institution/VerifiedInstitutionalAffiliationMapper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.pmiops.workbench.institution;\n+\n+import org.mapstruct.AfterMapping;\n+import org.mapstruct.Context;\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.MappingTarget;\n+import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n+import org.pmiops.workbench.model.VerifiedInstitutionalAffiliation;\n+\n+@Mapper(componentModel = \"spring\")\n+public interface VerifiedInstitutionalAffiliationMapper {\n+  @Mapping(target = \"verifiedInstitutionalAffiliationId\", ignore = true)\n+  @Mapping(target = \"institution\", ignore = true) // set by setDbInstitution()\n+  @Mapping(target = \"user\", ignore = true) // set by caller\n+  DbVerifiedInstitutionalAffiliation modelToDbWithoutUser(\n+      VerifiedInstitutionalAffiliation modelObject, @Context InstitutionService institutionService);", "originalCommit": "497db9234d24effffb9f926d3540e9c2137cffa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkxNTg3OQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r379915879", "bodyText": "was not used", "author": "jmthibault79", "createdAt": "2020-02-16T16:34:21Z", "path": "api/src/test/java/org/pmiops/workbench/api/ProfileControllerTest.java", "diffHunk": "@@ -88,14 +91,12 @@\n   private static final String CONTACT_EMAIL = \"bob@example.com\";\n   private static final String INVITATION_KEY = \"secretpassword\";\n   private static final String PRIMARY_EMAIL = \"bob@researchallofus.org\";\n-  private static final String BILLING_PROJECT_PREFIX = \"all-of-us-free-\";\n   private static final String ORGANIZATION = \"Test\";\n   private static final String CURRENT_POSITION = \"Tester\";\n   private static final String RESEARCH_PURPOSE = \"To test things\";\n   private static final int DUA_VERSION = 2;\n \n   @MockBean private FireCloudService fireCloudService;\n-  @MockBean private LeonardoNotebooksClient leonardoNotebooksClient;", "originalCommit": "497db9234d24effffb9f926d3540e9c2137cffa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4NzA1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380787053", "bodyText": "Could just repeat the feature flag check here instead of saving a local boolean", "author": "jmthibault79", "createdAt": "2020-02-18T16:29:09Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -360,8 +375,23 @@ public DbUser createUser(\n             finalDbUserReference.addInstitutionalAffiliation(affiliation);\n           });\n     }\n+    // set via the newer Verified Institutional Affiliation flow\n+    boolean requireInstitutionalVerification =\n+        configProvider.get().featureFlags.requireInstitutionalVerification;\n+    if (requireInstitutionalVerification\n+        && !institutionService.validate(verifiedInstitutionalAffiliation, contactEmail)) {\n+      final String msg =\n+          String.format(\n+              \"Cannot create user %s: invalid Verified Institutional Affiliation\", contactEmail);\n+      throw new BadRequestException(msg);\n+    }\n+\n     try {\n       dbUser = userDao.save(dbUser);\n+      if (requireInstitutionalVerification) {", "originalCommit": "d1ecd06dec7d95ab949bd096622fc4ff72506714", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg4NjI2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380886263", "bodyText": "Is there existing precedent for this type of a pattern (returning an enum value to signal the result of some service-level operation)? It's not a bad pattern necessarily (somewhat unix-like), but it's a little surprising to see in Java. I would argue, by consistency alone, we should probably be throwing exceptions for non-success cases instead.\nMore generally: IMO a service class is like a mini internal-only API. We should probably have much clearer documentation on the interface methods (e.g. in this file) specifying when and why certain potential exceptions may be thrown, similar to what we do in our Swagger.", "author": "gjuggler", "createdAt": "2020-02-18T19:28:12Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionService.java", "diffHunk": "@@ -2,17 +2,38 @@\n \n import java.util.List;\n import java.util.Optional;\n+import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.model.Institution;\n \n public interface InstitutionService {\n   List<Institution> getInstitutions();\n \n   Optional<Institution> getInstitution(final String shortName);\n \n+  Optional<DbInstitution> getDbInstitution(final String shortName);\n+\n   Institution createInstitution(final Institution institutionToCreate);\n \n-  boolean deleteInstitution(final String shortName);\n+  enum DeletionResult {", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4MTIxNw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380981217", "bodyText": "ok, will update.  not following any precedent here, just seems like a good way to do it", "author": "jmthibault79", "createdAt": "2020-02-18T22:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg4NjI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM1NjI4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381356286", "bodyText": "Actually - let's have a discussion on this.", "author": "jmthibault79", "createdAt": "2020-02-19T15:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg4NjI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5MDU2MQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380890561", "bodyText": "Interesting question \u2013\u00a0thanks for the references. I'm pretty sold on 409.", "author": "gjuggler", "createdAt": "2020-02-18T19:36:32Z", "path": "api/src/main/java/org/pmiops/workbench/api/InstitutionController.java", "diffHunk": "@@ -29,10 +30,22 @@\n   @Override\n   @AuthorityRequired({Authority.INSTITUTION_ADMIN})\n   public ResponseEntity<Void> deleteInstitution(final String shortName) {\n-    if (institutionService.deleteInstitution(shortName)) {\n-      return ResponseEntity.noContent().build();\n-    } else {\n-      throw new NotFoundException(String.format(\"Could not delete Institution %s\", shortName));\n+    switch (institutionService.deleteInstitution(shortName)) {\n+      case HAS_VERIFIED_AFFILIATIONS:\n+        // TODO: 405 or 409?", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5MDk2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380890966", "bodyText": "Missing closing single-quotation mark?", "author": "gjuggler", "createdAt": "2020-02-18T19:37:17Z", "path": "api/src/main/java/org/pmiops/workbench/api/InstitutionController.java", "diffHunk": "@@ -44,7 +57,7 @@\n             .orElseThrow(\n                 () ->\n                     new NotFoundException(\n-                        String.format(\"Could not find Institution %s\", shortName)));\n+                        String.format(\"Could not find Institution '%s\", shortName)));", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM1ODUxNw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381358517", "bodyText": "thanks", "author": "jmthibault79", "createdAt": "2020-02-19T15:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5MDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5NTY5OA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380895698", "bodyText": "[non-opt] Almost all of our other dao classes have a \"Dao\" suffix. This one should too. This caught me a handful of times while reading through other code that relies on this class \u2013\u00a0it's a useful suffix IMO.", "author": "gjuggler", "createdAt": "2020-02-18T19:46:19Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/VerifiedInstitutionalAffiliation.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.pmiops.workbench.db.dao;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n+import org.springframework.data.repository.CrudRepository;\n+\n+public interface VerifiedInstitutionalAffiliation", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM4MjY2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381382663", "bodyText": "whoops - not intentional, will fix!", "author": "jmthibault79", "createdAt": "2020-02-19T16:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5NTY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5NzcwMg==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380897702", "bodyText": "Yeah, it shouldn't be necessary to import an actual implementation class from here. I'm digging through our codebase trying to find a direct example of this pattern, but I haven't found anything perfect to point at yet. I'd be happy to sit down and debug some bean loading exceptions, though...\n[Later addition] What I think we generally end up having to do is add impl-class import statements to any test classes which use this service, rather than to the service class itself. That has the disadvantage that if ProfileService is used by multiple tests, you'd have to add this import statement in all places.", "author": "gjuggler", "createdAt": "2020-02-18T19:49:54Z", "path": "api/src/main/java/org/pmiops/workbench/auth/ProfileService.java", "diffHunk": "@@ -8,22 +8,27 @@\n import org.pmiops.workbench.billing.FreeTierBillingService;\n import org.pmiops.workbench.db.dao.UserDao;\n import org.pmiops.workbench.db.dao.UserTermsOfServiceDao;\n+import org.pmiops.workbench.db.dao.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.db.model.DbAddress;\n import org.pmiops.workbench.db.model.DbDemographicSurvey;\n import org.pmiops.workbench.db.model.DbInstitutionalAffiliation;\n import org.pmiops.workbench.db.model.DbPageVisit;\n import org.pmiops.workbench.db.model.DbUser;\n import org.pmiops.workbench.db.model.DbUserTermsOfService;\n+import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapper;\n+import org.pmiops.workbench.institution.VerifiedInstitutionalAffiliationMapperImpl;\n import org.pmiops.workbench.model.Address;\n import org.pmiops.workbench.model.DemographicSurvey;\n import org.pmiops.workbench.model.Disability;\n import org.pmiops.workbench.model.InstitutionalAffiliation;\n import org.pmiops.workbench.model.PageVisit;\n import org.pmiops.workbench.model.Profile;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Import;\n import org.springframework.stereotype.Service;\n \n @Service\n+@Import({VerifiedInstitutionalAffiliationMapperImpl.class})", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM4MjU2OA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381382568", "bodyText": "Thanks.  Made that update and pushed to confirm that tests still pass", "author": "jmthibault79", "createdAt": "2020-02-19T16:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg5NzcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwNDI5Ng==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380904296", "bodyText": "[nitpick] The wording here may be somewhat unclear: the \"invalid\" error here is that the user's email isn't considered a member of the specified institution, right? Maybe slightly improved wording could be \"Cannot create user {username}: contact email {contactEmail} is not a valid member of the {institutionName} institution.\"", "author": "gjuggler", "createdAt": "2020-02-18T20:02:00Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -360,8 +375,23 @@ public DbUser createUser(\n             finalDbUserReference.addInstitutionalAffiliation(affiliation);\n           });\n     }\n+    // set via the newer Verified Institutional Affiliation flow\n+    boolean requireInstitutionalVerification =\n+        configProvider.get().featureFlags.requireInstitutionalVerification;\n+    if (requireInstitutionalVerification\n+        && !institutionService.validate(verifiedInstitutionalAffiliation, contactEmail)) {\n+      final String msg =\n+          String.format(\n+              \"Cannot create user %s: invalid Verified Institutional Affiliation\", contactEmail);", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUwOTUxMg==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381509512", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-19T19:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwNDI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwNTYwNA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380905604", "bodyText": "Was this change to the jetbrains annotation class intentional?", "author": "gjuggler", "createdAt": "2020-02-18T20:04:40Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -1,18 +1,18 @@\n package org.pmiops.workbench.db.model;\n \n import com.google.common.collect.Sets;\n+import java.util.Collection;\n import java.util.Set;\n import java.util.stream.Collectors;\n import javax.persistence.CascadeType;\n import javax.persistence.Column;\n import javax.persistence.Entity;\n-import javax.persistence.FetchType;\n import javax.persistence.GeneratedValue;\n import javax.persistence.GenerationType;\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n-import javax.validation.constraints.NotNull;\n+import org.jetbrains.annotations.NotNull;", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM4NjY4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381386681", "bodyText": "yes - this was originally set accidentally.  Our standard is for jetbrains.", "author": "jmthibault79", "createdAt": "2020-02-19T16:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkwNTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxMjA3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380912075", "bodyText": "Does @NotNull annotation have any functional or compile-time impact on our system?\nSomeday we might consider adding something like https://checkerframework.org/manual/#nullness-checker (probably via https://github.com/kelloggm/checkerframework-gradle-plugin) to our build.", "author": "gjuggler", "createdAt": "2020-02-18T20:18:08Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -96,20 +96,22 @@ public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherTe\n    *\n    * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n    *\n-   * @param emailDomains the new set of domains for this Institution\n+   * @param emailDomains the new collection of domains for this Institution\n    */\n-  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+  public DbInstitution setEmailDomains(\n+      @NotNull final Collection<DbInstitutionEmailDomain> emailDomains) {", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM4NjgyOQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381386829", "bodyText": "No - it's essentially documentation", "author": "jmthibault79", "createdAt": "2020-02-19T16:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxMjA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNTI3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380915275", "bodyText": "[naming nit] I think validateInstitution would make this read a bit more clearly on the usage side.", "author": "gjuggler", "createdAt": "2020-02-18T20:25:14Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionService.java", "diffHunk": "@@ -2,17 +2,38 @@\n \n import java.util.List;\n import java.util.Optional;\n+import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.model.Institution;\n \n public interface InstitutionService {\n   List<Institution> getInstitutions();\n \n   Optional<Institution> getInstitution(final String shortName);\n \n+  Optional<DbInstitution> getDbInstitution(final String shortName);\n+\n   Institution createInstitution(final Institution institutionToCreate);\n \n-  boolean deleteInstitution(final String shortName);\n+  enum DeletionResult {\n+    SUCCESS,\n+    NOT_FOUND,\n+    HAS_VERIFIED_AFFILIATIONS\n+  }\n+\n+  DeletionResult deleteInstitution(final String shortName);\n \n   Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate);\n+\n+  /**\n+   * Validates that the user's institutional affiliation is valid, by pattern-matching the user's\n+   * contact email against the institution's set of whitelisted email domains or addresses.\n+   *\n+   * @param verifiedInstitutionalAffiliation the user's declared affiliation\n+   * @param contactEmail the contact email to verify\n+   * @return boolean - does the affiliation pass validation?\n+   */\n+  boolean validate(", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM4ODExMQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381388111", "bodyText": "agreed, but I think I'll go with validateAffiliation() since that is the most correct", "author": "jmthibault79", "createdAt": "2020-02-19T16:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkxNTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzM2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380937366", "bodyText": "[nitpick, unrelated to this PR] It feels a little redundant to have a shortName parameter, when the institutionToUpdate object has a shortName property as well. What would be the expected behavior if shortName=\"foo\" but institutionToUpdate.getShortName()=\"bar\"? Removing shortName as a param might be clearer, but it's obviously not a blocker for this PR (and I clearly haven't thought too carefully about the ramifications).", "author": "gjuggler", "createdAt": "2020-02-18T21:11:52Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -1,103 +1,113 @@\n package org.pmiops.workbench.institution;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n+import javax.mail.internet.AddressException;\n+import javax.mail.internet.InternetAddress;\n import org.pmiops.workbench.db.dao.InstitutionDao;\n+import org.pmiops.workbench.db.dao.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.db.model.DbInstitution;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.model.Institution;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Import;\n import org.springframework.stereotype.Service;\n \n @Service\n+@Import({InstitutionMapperImpl.class})\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n+  private final InstitutionMapper institutionMapper;\n+  private final VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n   @Autowired\n-  InstitutionServiceImpl(InstitutionDao institutionDao) {\n+  InstitutionServiceImpl(\n+      InstitutionDao institutionDao,\n+      InstitutionMapper institutionMapper,\n+      VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation) {\n     this.institutionDao = institutionDao;\n+    this.institutionMapper = institutionMapper;\n+    this.verifiedInstitutionalAffiliation = verifiedInstitutionalAffiliation;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)\n-        .map(this::toModel)\n+        .map(institutionMapper::dbToModel)\n         .collect(Collectors.toList());\n   }\n \n   @Override\n   public Optional<Institution> getInstitution(final String shortName) {\n-    return getDbInstitution(shortName).map(this::toModel);\n+    return getDbInstitution(shortName).map(institutionMapper::dbToModel);\n+  }\n+\n+  @Override\n+  public Optional<DbInstitution> getDbInstitution(final String shortName) {\n+    return institutionDao.findOneByShortName(shortName);\n   }\n \n   @Override\n   public Institution createInstitution(final Institution institutionToCreate) {\n-    return toModel(institutionDao.save(newDbObject(institutionToCreate)));\n+    return institutionMapper.dbToModel(\n+        institutionDao.save(institutionMapper.modelToDb(institutionToCreate)));\n   }\n \n   @Override\n-  public boolean deleteInstitution(final String shortName) {\n+  public DeletionResult deleteInstitution(final String shortName) {\n     return getDbInstitution(shortName)\n         .map(\n             dbInst -> {\n-              institutionDao.delete(dbInst);\n-              return true;\n+              if (verifiedInstitutionalAffiliation.findAllByInstitution(dbInst).isEmpty()) {\n+                // no verified user affiliations: safe to delete\n+                institutionDao.delete(dbInst);\n+                return DeletionResult.SUCCESS;\n+              } else {\n+                return DeletionResult.HAS_VERIFIED_AFFILIATIONS;\n+              }\n             })\n-        .orElse(false);\n+        .orElse(DeletionResult.NOT_FOUND);\n   }\n \n   @Override\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM5MTAwMg==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381391002", "bodyText": "This enables updating the inst's ShortName if necessary.\nupdate(\"Broad\", inst(\"TheBroadInst\", ...)) would change Broad's shortName to TheBroadInst.  I can add a test to make that more clear.", "author": "jmthibault79", "createdAt": "2020-02-19T16:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzOTEwOQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382239109", "bodyText": "Thanks \u2013\u00a0that clarification helps!\n[Note: everything below is not for this PR, just general discussion and/or potential follow-up]\nI'm still not sold that including the shortName parameter here is necessary or helpful. I feel like it would be simpler & maybe clearer to update the shortName of the object by passing just the Institution object, e.g.\nupdate(inst(shortName=\"TheBroadInst\", id=1234))\nsince the database ID is immutable, that can always be used by the implementation to identify the object to be updated.\nLooking further up the stack, I see that our workbench.yaml API surface includes the institution short-name in some of the API calls. So I can see how that naturally propagated down here to the service level.\nMaybe that's the part that is causing me some unease, that we're using a mutable key as an identifier in one of our CRUD APIs. That's usually a red flag to me \u2014\u00a0especially when we have a database ID to serve as an immutable key \u2014 but maybe there's an important reason we opted for that approach?\nAnyway, there's clearly no action for this PR here. Let's close the loop offline and figure out if there's anything worth doing as follow-up.", "author": "gjuggler", "createdAt": "2020-02-20T20:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5ODIzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382298239", "bodyText": "These were the principles driving this API:\n\nDon't expose your DB key\nAn institute may need to modify its Short Name\n\nMaybe these were the wrong priorities or this could have been implemented a different way.  I'm open to looking at this again as a followup.", "author": "jmthibault79", "createdAt": "2020-02-20T22:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzNzM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzODI5MQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380938291", "bodyText": "[naming nit] the use of \"new\" in the variable name confuses things more than it helps, IMO.\nOther options:\n\ndbInstitution\ndbInstitutionToUpdate (bit of a mouthful, but better parallels the input model object)\ndbObjectToUpdate\ndbObject", "author": "gjuggler", "createdAt": "2020-02-18T21:13:37Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -1,103 +1,113 @@\n package org.pmiops.workbench.institution;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n+import javax.mail.internet.AddressException;\n+import javax.mail.internet.InternetAddress;\n import org.pmiops.workbench.db.dao.InstitutionDao;\n+import org.pmiops.workbench.db.dao.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.db.model.DbInstitution;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.model.Institution;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Import;\n import org.springframework.stereotype.Service;\n \n @Service\n+@Import({InstitutionMapperImpl.class})\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n+  private final InstitutionMapper institutionMapper;\n+  private final VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n   @Autowired\n-  InstitutionServiceImpl(InstitutionDao institutionDao) {\n+  InstitutionServiceImpl(\n+      InstitutionDao institutionDao,\n+      InstitutionMapper institutionMapper,\n+      VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation) {\n     this.institutionDao = institutionDao;\n+    this.institutionMapper = institutionMapper;\n+    this.verifiedInstitutionalAffiliation = verifiedInstitutionalAffiliation;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)\n-        .map(this::toModel)\n+        .map(institutionMapper::dbToModel)\n         .collect(Collectors.toList());\n   }\n \n   @Override\n   public Optional<Institution> getInstitution(final String shortName) {\n-    return getDbInstitution(shortName).map(this::toModel);\n+    return getDbInstitution(shortName).map(institutionMapper::dbToModel);\n+  }\n+\n+  @Override\n+  public Optional<DbInstitution> getDbInstitution(final String shortName) {\n+    return institutionDao.findOneByShortName(shortName);\n   }\n \n   @Override\n   public Institution createInstitution(final Institution institutionToCreate) {\n-    return toModel(institutionDao.save(newDbObject(institutionToCreate)));\n+    return institutionMapper.dbToModel(\n+        institutionDao.save(institutionMapper.modelToDb(institutionToCreate)));\n   }\n \n   @Override\n-  public boolean deleteInstitution(final String shortName) {\n+  public DeletionResult deleteInstitution(final String shortName) {\n     return getDbInstitution(shortName)\n         .map(\n             dbInst -> {\n-              institutionDao.delete(dbInst);\n-              return true;\n+              if (verifiedInstitutionalAffiliation.findAllByInstitution(dbInst).isEmpty()) {\n+                // no verified user affiliations: safe to delete\n+                institutionDao.delete(dbInst);\n+                return DeletionResult.SUCCESS;\n+              } else {\n+                return DeletionResult.HAS_VERIFIED_AFFILIATIONS;\n+              }\n             })\n-        .orElse(false);\n+        .orElse(DeletionResult.NOT_FOUND);\n   }\n \n   @Override\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n+        .map(DbInstitution::getInstitutionId)\n+        .map(\n+            dbId -> {\n+              // create new DB object, but mark it with the original's ID to indicate that this is\n+              // an update\n+              final DbInstitution newDbObj =", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MTE1Nw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381551157", "bodyText": "updated", "author": "jmthibault79", "createdAt": "2020-02-19T21:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzODI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzOTU2MA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380939560", "bodyText": "This might be a nice place to add a @nullable annotation, to clarify that we are explicitly handling the null case within the method.", "author": "gjuggler", "createdAt": "2020-02-18T21:16:24Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -1,103 +1,113 @@\n package org.pmiops.workbench.institution;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n+import javax.mail.internet.AddressException;\n+import javax.mail.internet.InternetAddress;\n import org.pmiops.workbench.db.dao.InstitutionDao;\n+import org.pmiops.workbench.db.dao.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.db.model.DbInstitution;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.model.Institution;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Import;\n import org.springframework.stereotype.Service;\n \n @Service\n+@Import({InstitutionMapperImpl.class})\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n+  private final InstitutionMapper institutionMapper;\n+  private final VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n   @Autowired\n-  InstitutionServiceImpl(InstitutionDao institutionDao) {\n+  InstitutionServiceImpl(\n+      InstitutionDao institutionDao,\n+      InstitutionMapper institutionMapper,\n+      VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation) {\n     this.institutionDao = institutionDao;\n+    this.institutionMapper = institutionMapper;\n+    this.verifiedInstitutionalAffiliation = verifiedInstitutionalAffiliation;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)\n-        .map(this::toModel)\n+        .map(institutionMapper::dbToModel)\n         .collect(Collectors.toList());\n   }\n \n   @Override\n   public Optional<Institution> getInstitution(final String shortName) {\n-    return getDbInstitution(shortName).map(this::toModel);\n+    return getDbInstitution(shortName).map(institutionMapper::dbToModel);\n+  }\n+\n+  @Override\n+  public Optional<DbInstitution> getDbInstitution(final String shortName) {\n+    return institutionDao.findOneByShortName(shortName);\n   }\n \n   @Override\n   public Institution createInstitution(final Institution institutionToCreate) {\n-    return toModel(institutionDao.save(newDbObject(institutionToCreate)));\n+    return institutionMapper.dbToModel(\n+        institutionDao.save(institutionMapper.modelToDb(institutionToCreate)));\n   }\n \n   @Override\n-  public boolean deleteInstitution(final String shortName) {\n+  public DeletionResult deleteInstitution(final String shortName) {\n     return getDbInstitution(shortName)\n         .map(\n             dbInst -> {\n-              institutionDao.delete(dbInst);\n-              return true;\n+              if (verifiedInstitutionalAffiliation.findAllByInstitution(dbInst).isEmpty()) {\n+                // no verified user affiliations: safe to delete\n+                institutionDao.delete(dbInst);\n+                return DeletionResult.SUCCESS;\n+              } else {\n+                return DeletionResult.HAS_VERIFIED_AFFILIATIONS;\n+              }\n             })\n-        .orElse(false);\n+        .orElse(DeletionResult.NOT_FOUND);\n   }\n \n   @Override\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n+        .map(DbInstitution::getInstitutionId)\n+        .map(\n+            dbId -> {\n+              // create new DB object, but mark it with the original's ID to indicate that this is\n+              // an update\n+              final DbInstitution newDbObj =\n+                  institutionMapper.modelToDb(institutionToUpdate).setInstitutionId(dbId);\n+              return institutionMapper.dbToModel(institutionDao.save(newDbObj));\n+            });\n   }\n \n-  private Optional<DbInstitution> getDbInstitution(String shortName) {\n-    return institutionDao.findOneByShortName(shortName);\n-  }\n+  @Override\n+  public boolean validate(\n+      DbVerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation, String contactEmail) {", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2OTY1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382169653", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-20T18:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkzOTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDgwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380940805", "bodyText": "I'm not sure this really belongs here... is it the responsibility of the institution service to validate that the contact email address is valid? I would have expected this logic to live in UserService, since it has nothing to do with institutions. Unless I'm missing some scenario where it does?", "author": "gjuggler", "createdAt": "2020-02-18T21:18:54Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -1,103 +1,113 @@\n package org.pmiops.workbench.institution;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n+import javax.mail.internet.AddressException;\n+import javax.mail.internet.InternetAddress;\n import org.pmiops.workbench.db.dao.InstitutionDao;\n+import org.pmiops.workbench.db.dao.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.db.model.DbInstitution;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.model.Institution;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Import;\n import org.springframework.stereotype.Service;\n \n @Service\n+@Import({InstitutionMapperImpl.class})\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n+  private final InstitutionMapper institutionMapper;\n+  private final VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n   @Autowired\n-  InstitutionServiceImpl(InstitutionDao institutionDao) {\n+  InstitutionServiceImpl(\n+      InstitutionDao institutionDao,\n+      InstitutionMapper institutionMapper,\n+      VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation) {\n     this.institutionDao = institutionDao;\n+    this.institutionMapper = institutionMapper;\n+    this.verifiedInstitutionalAffiliation = verifiedInstitutionalAffiliation;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)\n-        .map(this::toModel)\n+        .map(institutionMapper::dbToModel)\n         .collect(Collectors.toList());\n   }\n \n   @Override\n   public Optional<Institution> getInstitution(final String shortName) {\n-    return getDbInstitution(shortName).map(this::toModel);\n+    return getDbInstitution(shortName).map(institutionMapper::dbToModel);\n+  }\n+\n+  @Override\n+  public Optional<DbInstitution> getDbInstitution(final String shortName) {\n+    return institutionDao.findOneByShortName(shortName);\n   }\n \n   @Override\n   public Institution createInstitution(final Institution institutionToCreate) {\n-    return toModel(institutionDao.save(newDbObject(institutionToCreate)));\n+    return institutionMapper.dbToModel(\n+        institutionDao.save(institutionMapper.modelToDb(institutionToCreate)));\n   }\n \n   @Override\n-  public boolean deleteInstitution(final String shortName) {\n+  public DeletionResult deleteInstitution(final String shortName) {\n     return getDbInstitution(shortName)\n         .map(\n             dbInst -> {\n-              institutionDao.delete(dbInst);\n-              return true;\n+              if (verifiedInstitutionalAffiliation.findAllByInstitution(dbInst).isEmpty()) {\n+                // no verified user affiliations: safe to delete\n+                institutionDao.delete(dbInst);\n+                return DeletionResult.SUCCESS;\n+              } else {\n+                return DeletionResult.HAS_VERIFIED_AFFILIATIONS;\n+              }\n             })\n-        .orElse(false);\n+        .orElse(DeletionResult.NOT_FOUND);\n   }\n \n   @Override\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n+        .map(DbInstitution::getInstitutionId)\n+        .map(\n+            dbId -> {\n+              // create new DB object, but mark it with the original's ID to indicate that this is\n+              // an update\n+              final DbInstitution newDbObj =\n+                  institutionMapper.modelToDb(institutionToUpdate).setInstitutionId(dbId);\n+              return institutionMapper.dbToModel(institutionDao.save(newDbObj));\n+            });\n   }\n \n-  private Optional<DbInstitution> getDbInstitution(String shortName) {\n-    return institutionDao.findOneByShortName(shortName);\n-  }\n+  @Override\n+  public boolean validate(\n+      DbVerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation, String contactEmail) {\n+    if (verifiedInstitutionalAffiliation == null) {\n+      return false;\n+    }\n \n-  private DbInstitution newDbObject(final Institution modelObject) {\n-    return updateDbObject(new DbInstitution(), modelObject);\n-  }\n+    final Institution inst =\n+        institutionMapper.dbToModel(verifiedInstitutionalAffiliation.getInstitution());\n \n-  private DbInstitution updateDbObject(\n-      final DbInstitution dbObject, final Institution modelObject) {\n-    return dbObject\n-        .setShortName(modelObject.getShortName())\n-        .setDisplayName(modelObject.getDisplayName())\n-        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .setEmailDomains(\n-            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n-                .stream()\n-                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n-                .collect(Collectors.toSet()))\n-        .setEmailAddresses(\n-            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n-                .stream()\n-                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))\n-                .collect(Collectors.toSet()));\n-  }\n+    try {\n+      new InternetAddress(contactEmail).validate();", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NDU0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381554546", "bodyText": "AFAICT, it has not been validated at this point - so I think this is necessary.  Agreed that something with Profile or User in the name should do this.  I'll file a ticket and make a comment.", "author": "jmthibault79", "createdAt": "2020-02-19T21:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1ODMzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381558339", "bodyText": "Just a title at this point but it's https://precisionmedicineinitiative.atlassian.net/browse/RW-4489", "author": "jmthibault79", "createdAt": "2020-02-19T21:35:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4ODE4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382288181", "bodyText": "Thanks! Sounds reasonable.", "author": "gjuggler", "createdAt": "2020-02-20T22:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0MDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0Mjk4OA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380942988", "bodyText": "[naming nit] I got a little caught up by the fact that this Db-model parameter was named without a \"db\" prefix. I know we're not super consistent about this (partly because much of the codebase existed before we'd added the db prefix to the class names), so I'll leave it to you to decide whether or not to change, but I would probably find it easier to read if it were \"DbVerifiedInstitutionalAffiliation dbVerifiedInstitutionalAffiliation\", or maybe \"dbAffiliation\" to save on chars since it's becoming a mouthful.", "author": "gjuggler", "createdAt": "2020-02-18T21:23:28Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -1,103 +1,113 @@\n package org.pmiops.workbench.institution;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.Optional;\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n+import javax.mail.internet.AddressException;\n+import javax.mail.internet.InternetAddress;\n import org.pmiops.workbench.db.dao.InstitutionDao;\n+import org.pmiops.workbench.db.dao.VerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.db.model.DbInstitution;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n-import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n import org.pmiops.workbench.model.Institution;\n import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.annotation.Import;\n import org.springframework.stereotype.Service;\n \n @Service\n+@Import({InstitutionMapperImpl.class})\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n+  private final InstitutionMapper institutionMapper;\n+  private final VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n   @Autowired\n-  InstitutionServiceImpl(InstitutionDao institutionDao) {\n+  InstitutionServiceImpl(\n+      InstitutionDao institutionDao,\n+      InstitutionMapper institutionMapper,\n+      VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation) {\n     this.institutionDao = institutionDao;\n+    this.institutionMapper = institutionMapper;\n+    this.verifiedInstitutionalAffiliation = verifiedInstitutionalAffiliation;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)\n-        .map(this::toModel)\n+        .map(institutionMapper::dbToModel)\n         .collect(Collectors.toList());\n   }\n \n   @Override\n   public Optional<Institution> getInstitution(final String shortName) {\n-    return getDbInstitution(shortName).map(this::toModel);\n+    return getDbInstitution(shortName).map(institutionMapper::dbToModel);\n+  }\n+\n+  @Override\n+  public Optional<DbInstitution> getDbInstitution(final String shortName) {\n+    return institutionDao.findOneByShortName(shortName);\n   }\n \n   @Override\n   public Institution createInstitution(final Institution institutionToCreate) {\n-    return toModel(institutionDao.save(newDbObject(institutionToCreate)));\n+    return institutionMapper.dbToModel(\n+        institutionDao.save(institutionMapper.modelToDb(institutionToCreate)));\n   }\n \n   @Override\n-  public boolean deleteInstitution(final String shortName) {\n+  public DeletionResult deleteInstitution(final String shortName) {\n     return getDbInstitution(shortName)\n         .map(\n             dbInst -> {\n-              institutionDao.delete(dbInst);\n-              return true;\n+              if (verifiedInstitutionalAffiliation.findAllByInstitution(dbInst).isEmpty()) {\n+                // no verified user affiliations: safe to delete\n+                institutionDao.delete(dbInst);\n+                return DeletionResult.SUCCESS;\n+              } else {\n+                return DeletionResult.HAS_VERIFIED_AFFILIATIONS;\n+              }\n             })\n-        .orElse(false);\n+        .orElse(DeletionResult.NOT_FOUND);\n   }\n \n   @Override\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n+        .map(DbInstitution::getInstitutionId)\n+        .map(\n+            dbId -> {\n+              // create new DB object, but mark it with the original's ID to indicate that this is\n+              // an update\n+              final DbInstitution newDbObj =\n+                  institutionMapper.modelToDb(institutionToUpdate).setInstitutionId(dbId);\n+              return institutionMapper.dbToModel(institutionDao.save(newDbObj));\n+            });\n   }\n \n-  private Optional<DbInstitution> getDbInstitution(String shortName) {\n-    return institutionDao.findOneByShortName(shortName);\n-  }\n+  @Override\n+  public boolean validate(\n+      DbVerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation, String contactEmail) {", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MTM0NQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381541345", "bodyText": "good call", "author": "jmthibault79", "createdAt": "2020-02-19T21:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0Mjk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0Mzg0NQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380943845", "bodyText": "I have to be honest, I don't really know what I should be looking for when reviewing mapper code. So I haven't left too many comments, or frankly dug too deep into the details of this file.\nOne thing that would help me understand better (and have more confidence) would be some test cases. Should there be a test case for this mapper class? (I see ones for CohortMapper and WorkspaceMapper, but I'm not super clear on whether we're requiring unit tests for mapper classes.).", "author": "gjuggler", "createdAt": "2020-02-18T21:25:24Z", "path": "api/src/main/java/org/pmiops/workbench/institution/VerifiedInstitutionalAffiliationMapper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.pmiops.workbench.institution;\n+\n+import org.mapstruct.AfterMapping;\n+import org.mapstruct.Context;\n+import org.mapstruct.Mapper;\n+import org.mapstruct.Mapping;\n+import org.mapstruct.MappingTarget;\n+import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbVerifiedInstitutionalAffiliation;\n+import org.pmiops.workbench.model.VerifiedInstitutionalAffiliation;\n+\n+@Mapper(componentModel = \"spring\")\n+public interface VerifiedInstitutionalAffiliationMapper {", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1ODQ4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r381558489", "bodyText": "good idea", "author": "jmthibault79", "createdAt": "2020-02-19T21:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk0Mzg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1MzA0Mw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380953043", "bodyText": "[no action] Not saying you should do it here, but one thing I've started doing in PRs is trying to Autowire a service like this when I find myself having to update constructors in random, unrelated places. It does have a fully-expected side effect of blowing up the scope of a PR though... :)", "author": "gjuggler", "createdAt": "2020-02-18T21:44:10Z", "path": "api/src/test/java/org/pmiops/workbench/api/AuthDomainControllerTest.java", "diffHunk": "@@ -88,7 +92,9 @@ public void setUp() {\n             Providers.of(config),\n             complianceService,\n             directoryService,\n-            mockUserServiceAuditAdapter);\n+            mockUserServiceAuditAdapter,\n+            institutionService,", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Mzk3OA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380953978", "bodyText": "I would probably expect to see a test that when the flag is true, and the profile is saved without any valid institution, an exception is thrown.", "author": "gjuggler", "createdAt": "2020-02-18T21:46:11Z", "path": "api/src/test/java/org/pmiops/workbench/api/ProfileControllerTest.java", "diffHunk": "@@ -416,6 +443,29 @@ public void testMe_removeAllInstitutionalAffiliations() throws Exception {\n     assertThat(result.getInstitutionalAffiliations().size()).isEqualTo(0);\n   }\n \n+  @Test\n+  public void testMe_verifiedInstitutionalAffiliation() throws Exception {", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA3NDA3MQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382074071", "bodyText": "right, of course", "author": "jmthibault79", "createdAt": "2020-02-20T15:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Mzk3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NTA4NA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382095084", "bodyText": "new test already caught a bug \ud83d\udcaf", "author": "jmthibault79", "createdAt": "2020-02-20T16:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Mzk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Nzk2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380957962", "bodyText": "I'm not sure whether this assertion and the two verify calls below this are strictly necessary. Is there a particular reason you included them, or was it mostly leftover from copying the existing tests?\nMaybe it's a little too minimal, but I wouldn't argue against just keeping the last check, so this case is really centered on ensuring the verified institution is stored and returned correctly.", "author": "gjuggler", "createdAt": "2020-02-18T21:53:50Z", "path": "api/src/test/java/org/pmiops/workbench/api/ProfileControllerTest.java", "diffHunk": "@@ -416,6 +443,29 @@ public void testMe_removeAllInstitutionalAffiliations() throws Exception {\n     assertThat(result.getInstitutionalAffiliations().size()).isEqualTo(0);\n   }\n \n+  @Test\n+  public void testMe_verifiedInstitutionalAffiliation() throws Exception {\n+    // set feature flag\n+    config.featureFlags.requireInstitutionalVerification = true;\n+\n+    createUser();\n+    Profile profile = profileController.getMe().getBody();\n+    assertProfile(", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA3NTA4Nw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382075087", "bodyText": "yeah this is excess copypaste", "author": "jmthibault79", "createdAt": "2020-02-20T15:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1Nzk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1ODUwOA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380958508", "bodyText": "I'm not immediately getting why this change was necessary. Can you comment?", "author": "gjuggler", "createdAt": "2020-02-18T21:55:01Z", "path": "api/src/test/java/org/pmiops/workbench/auth/ProfileServiceTest.java", "diffHunk": "@@ -35,14 +39,15 @@\n \n   @Test\n   public void testGetProfile_empty() {\n-    assertThat(profileService.getProfile(new DbUser())).isNotNull();\n+    assertThat(profileService.getProfile(userDao.save(new DbUser()))).isNotNull();", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyNTU1Mg==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382125552", "bodyText": "getProfile now needs the user it's referencing to actually exist in the DB.  (Line 223: verifiedInstitutionalAffiliationDao.findFirstByUser(user))\nHibernate throws this exception if not:\norg.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance beforeQuery flushing: org.pmiops.workbench.db.model.DbUser; nested exception is java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance beforeQuery flushing: org.pmiops.workbench.db.model.DbUser\n\nWhat's surprising to me is that other DB calls in getProfile() don't need this, such as userDao.findUserWithAuthoritiesAndPageVisits(user.getUserId()).\nIt seems like a reasonable expectation to me for getProfile() to require a saved DB user object - LMK if you disagree.", "author": "jmthibault79", "createdAt": "2020-02-20T16:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1ODUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4OTQ2MA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382289460", "bodyText": "That makes total sense \u2013 thanks for walking me through.", "author": "gjuggler", "createdAt": "2020-02-20T22:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk1ODUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MDc3NA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380960774", "bodyText": "Interesting \u2013 I didn't expect to see so much test coverage for the DAO object! Not that this is a bad thing, but given that DAOs are mostly implemented via Spring/Hibernate internals, and we have many existing DAO classes without unit tests, I'd sort of built up a mental model that we don't require test coverage for these, since we \"trust\" our frameworks to do their thing, and there's also implicit coverage via the controller tests.\nShould I update my understanding? Where or when would you decide that a DAO is complex enough to warrant test coverage?", "author": "gjuggler", "createdAt": "2020-02-18T21:59:32Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/VerifiedInstitutionalAffiliationTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package org.pmiops.workbench.db.dao;", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODY4NA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382128684", "bodyText": "Maybe it's me but there's a deep mismatch between how I expect Hibernate to work and how it actually does.  This remains true after these last few weeks of trying to bridge this gap.  I don't feel I can trust it at all unless I have very thorough test coverage.  :(", "author": "jmthibault79", "createdAt": "2020-02-20T16:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MDc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyOTYzMw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382129633", "bodyText": "I have found many bugs with these tests.  I'm afraid of what we have lurking ...", "author": "jmthibault79", "createdAt": "2020-02-20T16:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MDc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MjIzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380962239", "bodyText": "[style consistency] I think to use ALL_CAPS, these should be static final variables. At least that's what I'm finding from digging around our codebase for a minute.", "author": "gjuggler", "createdAt": "2020-02-18T22:02:39Z", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -20,71 +27,89 @@\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@Import({InstitutionServiceImpl.class})\n+@Import({InstitutionServiceImpl.class, InstitutionMapperImpl.class})\n public class InstitutionServiceTest {\n   @Autowired private InstitutionService service;\n+  @Autowired private UserDao userDao;\n+  @Autowired private VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n-  private final Institution testInst =\n+  private final Institution TEST_INST =", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2OTg3NA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382169874", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-20T18:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MjIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MjczMA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380962730", "bodyText": "[super nit] personally I'd expand RT to ROUNDTRIP or ROUND_TRIP to save someone the effort of parsing out what this means.", "author": "gjuggler", "createdAt": "2020-02-18T22:03:35Z", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -20,71 +27,89 @@\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@Import({InstitutionServiceImpl.class})\n+@Import({InstitutionServiceImpl.class, InstitutionMapperImpl.class})\n public class InstitutionServiceTest {\n   @Autowired private InstitutionService service;\n+  @Autowired private UserDao userDao;\n+  @Autowired private VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n-  private final Institution testInst =\n+  private final Institution TEST_INST =\n       new Institution().shortName(\"test\").displayName(\"this is a test\");\n \n-  // the DB converts nulls to empty lists\n-  private final Institution testInstAfterRT =\n+  // the mapper converts nulls to empty sets\n+  private final Institution TEST_INST_AFTER_RT =", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2OTkyMA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382169920", "bodyText": "done", "author": "jmthibault79", "createdAt": "2020-02-20T18:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MjczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzYyNQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380963625", "bodyText": "It's not obvious to me what this addition to the test case is checking. It feels like we've actually munged two tests into one here, which can sometimes be a net negative for clarity / maintainability. Either add a comment to clarify why this is part of the \"base\" createInstitution test method, or otherwise split out to a separate method with a name which clarifies the intent.", "author": "gjuggler", "createdAt": "2020-02-18T22:05:31Z", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -20,71 +27,89 @@\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@Import({InstitutionServiceImpl.class})\n+@Import({InstitutionServiceImpl.class, InstitutionMapperImpl.class})\n public class InstitutionServiceTest {\n   @Autowired private InstitutionService service;\n+  @Autowired private UserDao userDao;\n+  @Autowired private VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n-  private final Institution testInst =\n+  private final Institution TEST_INST =\n       new Institution().shortName(\"test\").displayName(\"this is a test\");\n \n-  // the DB converts nulls to empty lists\n-  private final Institution testInstAfterRT =\n+  // the mapper converts nulls to empty sets\n+  private final Institution TEST_INST_AFTER_RT =\n       new Institution()\n-          .shortName(testInst.getShortName())\n-          .displayName(testInst.getDisplayName())\n+          .shortName(TEST_INST.getShortName())\n+          .displayName(TEST_INST.getDisplayName())\n           .emailDomains(Collections.emptyList())\n           .emailAddresses(Collections.emptyList());\n \n   @Before\n   public void setUp() {\n-    service.createInstitution(testInst);\n+    // will be retrieved as TEST_INST_AFTER_RT\n+    service.createInstitution(TEST_INST);\n   }\n \n   @Test\n   public void test_createInstitution() {\n-    assertThat(service.getInstitutions()).hasSize(1);\n+    assertThat(service.getInstitutions()).containsExactly(TEST_INST_AFTER_RT);\n \n-    service.createInstitution(\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\"));\n-    assertThat(service.getInstitutions()).hasSize(2);\n+    final Institution otherInst =", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3MDE0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382170146", "bodyText": "renamed to \"createAnother\" - is that clear?", "author": "jmthibault79", "createdAt": "2020-02-20T18:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzkxOA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380963918", "bodyText": "[nit] This seems like a redundant assertion which is checked in earlier tests. I'd probably remove.", "author": "gjuggler", "createdAt": "2020-02-18T22:06:08Z", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -20,71 +27,89 @@\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@Import({InstitutionServiceImpl.class})\n+@Import({InstitutionServiceImpl.class, InstitutionMapperImpl.class})\n public class InstitutionServiceTest {\n   @Autowired private InstitutionService service;\n+  @Autowired private UserDao userDao;\n+  @Autowired private VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n-  private final Institution testInst =\n+  private final Institution TEST_INST =\n       new Institution().shortName(\"test\").displayName(\"this is a test\");\n \n-  // the DB converts nulls to empty lists\n-  private final Institution testInstAfterRT =\n+  // the mapper converts nulls to empty sets\n+  private final Institution TEST_INST_AFTER_RT =\n       new Institution()\n-          .shortName(testInst.getShortName())\n-          .displayName(testInst.getDisplayName())\n+          .shortName(TEST_INST.getShortName())\n+          .displayName(TEST_INST.getDisplayName())\n           .emailDomains(Collections.emptyList())\n           .emailAddresses(Collections.emptyList());\n \n   @Before\n   public void setUp() {\n-    service.createInstitution(testInst);\n+    // will be retrieved as TEST_INST_AFTER_RT\n+    service.createInstitution(TEST_INST);\n   }\n \n   @Test\n   public void test_createInstitution() {\n-    assertThat(service.getInstitutions()).hasSize(1);\n+    assertThat(service.getInstitutions()).containsExactly(TEST_INST_AFTER_RT);\n \n-    service.createInstitution(\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\"));\n-    assertThat(service.getInstitutions()).hasSize(2);\n+    final Institution otherInst =\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailDomains(Collections.emptyList())\n+            .emailAddresses(Collections.emptyList());\n+    assertThat(service.createInstitution(otherInst)).isEqualTo(otherInst);\n+\n+    assertThat(service.getInstitutions()).containsExactly(TEST_INST_AFTER_RT, otherInst);\n   }\n \n   @Test\n   public void test_deleteInstitution() {\n-    assertThat(service.getInstitutions()).hasSize(1);\n+    assertThat(service.getInstitutions()).containsExactly(TEST_INST_AFTER_RT);", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3MDIxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382170219", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-20T18:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MzkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NDMwMw==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380964303", "bodyText": "Same general point as before \u2013\u00a0this should probably be a new test method, since you're starting fresh again. This will help future readers & maintainers of the code by keeping things simple.\nPlus, when you isolate the \"failure case\" into its own test method, you can use the @test(expected = ExceptionClass.class) annotation to do the heavy lifting of verification for you, which I find really easy to follow.", "author": "gjuggler", "createdAt": "2020-02-18T22:06:55Z", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -20,71 +27,89 @@\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@Import({InstitutionServiceImpl.class})\n+@Import({InstitutionServiceImpl.class, InstitutionMapperImpl.class})\n public class InstitutionServiceTest {\n   @Autowired private InstitutionService service;\n+  @Autowired private UserDao userDao;\n+  @Autowired private VerifiedInstitutionalAffiliation verifiedInstitutionalAffiliation;\n \n-  private final Institution testInst =\n+  private final Institution TEST_INST =\n       new Institution().shortName(\"test\").displayName(\"this is a test\");\n \n-  // the DB converts nulls to empty lists\n-  private final Institution testInstAfterRT =\n+  // the mapper converts nulls to empty sets\n+  private final Institution TEST_INST_AFTER_RT =\n       new Institution()\n-          .shortName(testInst.getShortName())\n-          .displayName(testInst.getDisplayName())\n+          .shortName(TEST_INST.getShortName())\n+          .displayName(TEST_INST.getDisplayName())\n           .emailDomains(Collections.emptyList())\n           .emailAddresses(Collections.emptyList());\n \n   @Before\n   public void setUp() {\n-    service.createInstitution(testInst);\n+    // will be retrieved as TEST_INST_AFTER_RT\n+    service.createInstitution(TEST_INST);\n   }\n \n   @Test\n   public void test_createInstitution() {\n-    assertThat(service.getInstitutions()).hasSize(1);\n+    assertThat(service.getInstitutions()).containsExactly(TEST_INST_AFTER_RT);\n \n-    service.createInstitution(\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\"));\n-    assertThat(service.getInstitutions()).hasSize(2);\n+    final Institution otherInst =\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailDomains(Collections.emptyList())\n+            .emailAddresses(Collections.emptyList());\n+    assertThat(service.createInstitution(otherInst)).isEqualTo(otherInst);\n+\n+    assertThat(service.getInstitutions()).containsExactly(TEST_INST_AFTER_RT, otherInst);\n   }\n \n   @Test\n   public void test_deleteInstitution() {\n-    assertThat(service.getInstitutions()).hasSize(1);\n+    assertThat(service.getInstitutions()).containsExactly(TEST_INST_AFTER_RT);\n+\n+    assertThat(service.deleteInstitution(TEST_INST.getShortName()))\n+        .isEqualTo(DeletionResult.SUCCESS);\n+    assertThat(service.getInstitutions()).isEmpty();\n+\n+    service.createInstitution(TEST_INST);", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3MDM0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382170346", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-20T18:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NjYwOA==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r380966608", "bodyText": "This might be made more realistic / meaningful by having a user with a valid email address which doesn't exist in the institution's list. None of the tests explicitly checks this important negative case yet, while a totally-empty dbUser object is less-likely to exist in our system.", "author": "gjuggler", "createdAt": "2020-02-18T22:12:07Z", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -153,4 +178,84 @@ public void test_nonUniqueIds() {\n         new Institution().shortName(\"test\").displayName(\"We are all individuals\"));\n     service.createInstitution(new Institution().shortName(\"test\").displayName(\"I'm not\"));\n   }\n+\n+  @Test\n+  public void test_emailValidation_domain() {\n+    final Institution inst =\n+        service.createInstitution(\n+            new Institution()\n+                .shortName(\"Broad\")\n+                .displayName(\"The Broad Institute\")\n+                .emailDomains(Lists.newArrayList(\"broad.org\", \"lab.broad.org\")));\n+\n+    final DbUser user = createUser(\"user@broad.org\");\n+    final DbVerifiedInstitutionalAffiliation affiliation =\n+        createAffiliation(user, inst.getShortName());\n+\n+    assertThat(service.validate(affiliation, user.getContactEmail())).isTrue();\n+  }\n+\n+  @Test\n+  public void test_emailValidation_address() {\n+    final Institution inst =\n+        service.createInstitution(\n+            new Institution()\n+                .shortName(\"Broad\")\n+                .displayName(\"The Broad Institute\")\n+                .emailDomains(Lists.newArrayList(\"broad.org\", \"mit.edu\"))\n+                .emailAddresses(\n+                    Lists.newArrayList(\"external-researcher@sanger.uk\", \"science@aol.com\")));\n+\n+    final DbUser user = createUser(\"external-researcher@sanger.uk\");\n+    final DbVerifiedInstitutionalAffiliation affiliation =\n+        createAffiliation(user, inst.getShortName());\n+\n+    assertThat(service.validate(affiliation, user.getContactEmail())).isTrue();\n+  }\n+\n+  @Test\n+  public void test_emailValidation_null() {\n+    final Institution inst =\n+        service.createInstitution(\n+            new Institution().shortName(\"Broad\").displayName(\"The Broad Institute\"));\n+\n+    final DbUser user = userDao.save(new DbUser());", "originalCommit": "b5381fb30a0bc4cda586a060925dca39811b3721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3MDQxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3139#discussion_r382170411", "bodyText": "agreed", "author": "jmthibault79", "createdAt": "2020-02-20T18:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2NjYwOA=="}], "type": "inlineReview"}, {"oid": "cdfe87d1ece45554886de7e885c0a88eb073f9d0", "url": "https://github.com/all-of-us/workbench/commit/cdfe87d1ece45554886de7e885c0a88eb073f9d0", "message": "VerifiedInstitutionalAffiliationMapperTest", "committedDate": "2020-02-20T04:12:54Z", "type": "forcePushed"}, {"oid": "87adf8371653428c147e8a9b54b1c62af62b1b2d", "url": "https://github.com/all-of-us/workbench/commit/87adf8371653428c147e8a9b54b1c62af62b1b2d", "message": "RW-4259 User model updates for Verified Inst Affil", "committedDate": "2020-02-20T18:03:16Z", "type": "commit"}, {"oid": "f41366703ec97a46413d280e3ba88b6615a1fa41", "url": "https://github.com/all-of-us/workbench/commit/f41366703ec97a46413d280e3ba88b6615a1fa41", "message": "PR feedback\n\nadd delete inst 409 description\n\nrm InstitutionalRole subtypes\n\npropagate requireInstitutionalVerification to the UI\n\nfix quote\n\nthrow deleteInstitution() exceptions at Service level\n\nouch - forgot the Dao from the name\n\nmove @Imports from services to tests\n\nbetter error message\n\ninstitutionService.validate() -> validateAffiliation()\n\nbetter update tests\n\nlint and missed one @Import\n\nrename DB table to user_verified_institutional_affiliation\n\nanother @Import\n\nreview comments\n\nrename params/variables to make it clear they're the DB versions\n\nmore\n\nlint\n\nadd RW-4489 comment\n\ntmp need to pause to fix a bug\n\nInstitutionMapperTest\n\nVerifiedInstitutionalAffiliationMapperTest\n\ndescriptions of short name and display name\n\nbetter ProfileControllerTests and some bugfixes\n\nInstitutionServiceTest improvements", "committedDate": "2020-02-20T18:05:11Z", "type": "commit"}, {"oid": "f41366703ec97a46413d280e3ba88b6615a1fa41", "url": "https://github.com/all-of-us/workbench/commit/f41366703ec97a46413d280e3ba88b6615a1fa41", "message": "PR feedback\n\nadd delete inst 409 description\n\nrm InstitutionalRole subtypes\n\npropagate requireInstitutionalVerification to the UI\n\nfix quote\n\nthrow deleteInstitution() exceptions at Service level\n\nouch - forgot the Dao from the name\n\nmove @Imports from services to tests\n\nbetter error message\n\ninstitutionService.validate() -> validateAffiliation()\n\nbetter update tests\n\nlint and missed one @Import\n\nrename DB table to user_verified_institutional_affiliation\n\nanother @Import\n\nreview comments\n\nrename params/variables to make it clear they're the DB versions\n\nmore\n\nlint\n\nadd RW-4489 comment\n\ntmp need to pause to fix a bug\n\nInstitutionMapperTest\n\nVerifiedInstitutionalAffiliationMapperTest\n\ndescriptions of short name and display name\n\nbetter ProfileControllerTests and some bugfixes\n\nInstitutionServiceTest improvements", "committedDate": "2020-02-20T18:05:11Z", "type": "forcePushed"}, {"oid": "2020459543d5403c59abc23d859bc4daeb2c3bbc", "url": "https://github.com/all-of-us/workbench/commit/2020459543d5403c59abc23d859bc4daeb2c3bbc", "message": "comment fix", "committedDate": "2020-02-20T19:59:30Z", "type": "commit"}, {"oid": "087bd09ac1bebf0ae6c3aa6f28d24acb9cf47c4f", "url": "https://github.com/all-of-us/workbench/commit/087bd09ac1bebf0ae6c3aa6f28d24acb9cf47c4f", "message": "Apparently we need to observe the DB to ensure the transaction is complete? hmmmmm", "committedDate": "2020-02-20T20:17:22Z", "type": "commit"}]}