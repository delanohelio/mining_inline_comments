{"pr_number": 3754, "pr_title": "[RW-5013][risk=no] Recycle backfill script for owner fix", "pr_createdAt": "2020-07-08T04:37:11Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3754", "timeline": [{"oid": "b704158b78b45e48a3e3d28bdf988b3fc1753e7f", "url": "https://github.com/all-of-us/workbench/commit/b704158b78b45e48a3e3d28bdf988b3fc1753e7f", "message": "Recycle backfill script for owner fix", "committedDate": "2020-07-08T04:34:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MDMxOA==", "url": "https://github.com/all-of-us/workbench/pull/3754#discussion_r452460318", "bodyText": "wouldn't this always be true if user is in the set of billingProjectOwners - workspaceOwners? user is always an element within billingProjectOwners which is not in workspaceOwners", "author": "ericsong", "createdAt": "2020-07-09T20:06:26Z", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/FixDesynchronizedBillingProjectOwners.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.pmiops.workbench.tools;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.pmiops.workbench.firecloud.ApiException;\n+import org.pmiops.workbench.firecloud.FirecloudTransforms;\n+import org.pmiops.workbench.firecloud.api.BillingApi;\n+import org.pmiops.workbench.firecloud.api.WorkspacesApi;\n+import org.pmiops.workbench.firecloud.model.FirecloudBillingProjectMember;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspace;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspaceResponse;\n+import org.springframework.boot.CommandLineRunner;\n+import org.springframework.boot.builder.SpringApplicationBuilder;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+/**\n+ * Backfill script to adjust users with improper billing project access. Dry run mode can be used to\n+ * audit for inconsistent access. Specifically this aims to revoke access for users who were\n+ * incompletely removed as OWNERs per RW-5013, though this situation can theoretically arise in the\n+ * event of a normal partial sharing failure (sharing and setting of the billing project role cannot\n+ * be done transactionally).\n+ */\n+@Configuration\n+public class FixDesynchronizedBillingProjectOwners {\n+  public static final List<String> FIRECLOUD_LIST_WORKSPACES_REQUIRED_FIELDS =\n+      ImmutableList.of(\n+          \"accessLevel\", \"workspace.namespace\", \"workspace.name\", \"workspace.createdBy\");\n+\n+  private static Option fcBaseUrlOpt =\n+      Option.builder()\n+          .longOpt(\"fc-base-url\")\n+          .desc(\"Firecloud API base URL\")\n+          .required()\n+          .hasArg()\n+          .build();\n+  private static Option billingProjectIdsOpt =\n+      Option.builder()\n+          .longOpt(\"billing-project-ids\")\n+          .desc(\"Billing project IDs to filter by, all projects are considered if empty\")\n+          .hasArg()\n+          .build();\n+  private static Option researcherDomain =\n+      Option.builder()\n+          .longOpt(\"researcher-domain\")\n+          .desc(\"Researcher email domain, e.g. researchallofus.org for prod\")\n+          .hasArg()\n+          .build();\n+  private static Option dryRunOpt =\n+      Option.builder()\n+          .longOpt(\"dry-run\")\n+          .desc(\"If specified, the tool runs in dry run mode; no modifications are made\")\n+          .build();\n+  private static Options options =\n+      new Options()\n+          .addOption(fcBaseUrlOpt)\n+          .addOption(billingProjectIdsOpt)\n+          .addOption(researcherDomain)\n+          .addOption(dryRunOpt);\n+\n+  private static final Logger log =\n+      Logger.getLogger(FixDesynchronizedBillingProjectOwners.class.getName());\n+\n+  private static void dryLog(boolean dryRun, String msg) {\n+    String prefix = \"\";\n+    if (dryRun) {\n+      prefix = \"[DRY RUN] Would have... \";\n+    }\n+    log.info(prefix + msg);\n+  }\n+\n+  private static void clean(\n+      WorkspacesApi workspacesApi,\n+      BillingApi billingApi,\n+      Set<String> billingProjectIds,\n+      String researcherDomain,\n+      boolean dryRun)\n+      throws ApiException {\n+    int ownersRemoved = 0;\n+    int ownersAdded = 0;\n+    for (FirecloudWorkspaceResponse resp :\n+        workspacesApi.listWorkspaces(FIRECLOUD_LIST_WORKSPACES_REQUIRED_FIELDS)) {\n+      FirecloudWorkspace w = resp.getWorkspace();\n+      if (!billingProjectIds.isEmpty() && !billingProjectIds.contains(w.getNamespace())) {\n+        continue;\n+      }\n+\n+      String id = w.getNamespace() + \"/\" + w.getName();\n+      if (!\"PROJECT_OWNER\".equals(resp.getAccessLevel())) {\n+        log.warning(\n+            String.format(\n+                \"service account has '%s' access to workspace '%s'; skipping\",\n+                resp.getAccessLevel(), id));\n+        continue;\n+      }\n+\n+      Map<String, String> billingProjectRoles =\n+          billingApi.listBillingProjectMembers(w.getNamespace()).stream()\n+              .filter(m -> m.getEmail().endsWith(\"@\" + researcherDomain))\n+              .collect(\n+                  Collectors.toMap(\n+                      FirecloudBillingProjectMember::getEmail,\n+                      FirecloudBillingProjectMember::getRole));\n+      Set<String> billingProjectOwners =\n+          billingProjectRoles.entrySet().stream()\n+              .filter(e -> \"Owner\".equals(e.getValue()))\n+              .map(Entry::getKey)\n+              .collect(Collectors.toSet());\n+\n+      Map<String, String> workspaceRoles =\n+          FirecloudTransforms.extractAclResponse(\n+                  workspacesApi.getWorkspaceAcl(w.getNamespace(), w.getName()))\n+              .entrySet().stream()\n+              .filter(e -> e.getKey().endsWith(\"@\" + researcherDomain))\n+              .collect(Collectors.toMap(Entry::getKey, e -> e.getValue().getAccessLevel()));\n+      Set<String> workspaceOwners =\n+          workspaceRoles.entrySet().stream()\n+              .filter(e -> \"OWNER\".equals(e.getValue()))\n+              .map(e -> e.getKey())\n+              .collect(Collectors.toSet());\n+\n+      // ShareWorkspace first updates the Workspace ACL, then the billing project role. For this\n+      // reason, the workspace ACL is the source of truth, as it will have been set properly in the\n+      // event of a partial sharing failure.\n+      for (String user : Sets.difference(billingProjectOwners, workspaceOwners)) {\n+        dryLog(\n+            dryRun,\n+            String.format(\n+                \"'%s': '%s', inconsistency: workspace role '%s', project role '%s'\",\n+                w.getNamespace(), user, workspaceRoles.get(user), billingProjectRoles.get(user)));\n+        if (billingProjectOwners.contains(user)) {", "originalCommit": "b704158b78b45e48a3e3d28bdf988b3fc1753e7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwNTI0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3754#discussion_r452505242", "bodyText": "Great catch - thanks. There were two bugs here:\n\nI accidentally imported from the Elasticsearch client library... that was not intentional. Should have been Guava.\nI'd thought Sets.difference was the symmetric difference. Fixed to actually call the symmetricDifference, which was my intent.", "author": "calbach", "createdAt": "2020-07-09T21:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MTU2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3754#discussion_r452461562", "bodyText": "re: above. I believe this case will never be hit. I think what the logic covers is the set difference of workspaceOwners - billingProjectOwners", "author": "ericsong", "createdAt": "2020-07-09T20:09:07Z", "path": "api/tools/src/main/java/org/pmiops/workbench/tools/FixDesynchronizedBillingProjectOwners.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.pmiops.workbench.tools;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.pmiops.workbench.firecloud.ApiException;\n+import org.pmiops.workbench.firecloud.FirecloudTransforms;\n+import org.pmiops.workbench.firecloud.api.BillingApi;\n+import org.pmiops.workbench.firecloud.api.WorkspacesApi;\n+import org.pmiops.workbench.firecloud.model.FirecloudBillingProjectMember;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspace;\n+import org.pmiops.workbench.firecloud.model.FirecloudWorkspaceResponse;\n+import org.springframework.boot.CommandLineRunner;\n+import org.springframework.boot.builder.SpringApplicationBuilder;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+\n+/**\n+ * Backfill script to adjust users with improper billing project access. Dry run mode can be used to\n+ * audit for inconsistent access. Specifically this aims to revoke access for users who were\n+ * incompletely removed as OWNERs per RW-5013, though this situation can theoretically arise in the\n+ * event of a normal partial sharing failure (sharing and setting of the billing project role cannot\n+ * be done transactionally).\n+ */\n+@Configuration\n+public class FixDesynchronizedBillingProjectOwners {\n+  public static final List<String> FIRECLOUD_LIST_WORKSPACES_REQUIRED_FIELDS =\n+      ImmutableList.of(\n+          \"accessLevel\", \"workspace.namespace\", \"workspace.name\", \"workspace.createdBy\");\n+\n+  private static Option fcBaseUrlOpt =\n+      Option.builder()\n+          .longOpt(\"fc-base-url\")\n+          .desc(\"Firecloud API base URL\")\n+          .required()\n+          .hasArg()\n+          .build();\n+  private static Option billingProjectIdsOpt =\n+      Option.builder()\n+          .longOpt(\"billing-project-ids\")\n+          .desc(\"Billing project IDs to filter by, all projects are considered if empty\")\n+          .hasArg()\n+          .build();\n+  private static Option researcherDomain =\n+      Option.builder()\n+          .longOpt(\"researcher-domain\")\n+          .desc(\"Researcher email domain, e.g. researchallofus.org for prod\")\n+          .hasArg()\n+          .build();\n+  private static Option dryRunOpt =\n+      Option.builder()\n+          .longOpt(\"dry-run\")\n+          .desc(\"If specified, the tool runs in dry run mode; no modifications are made\")\n+          .build();\n+  private static Options options =\n+      new Options()\n+          .addOption(fcBaseUrlOpt)\n+          .addOption(billingProjectIdsOpt)\n+          .addOption(researcherDomain)\n+          .addOption(dryRunOpt);\n+\n+  private static final Logger log =\n+      Logger.getLogger(FixDesynchronizedBillingProjectOwners.class.getName());\n+\n+  private static void dryLog(boolean dryRun, String msg) {\n+    String prefix = \"\";\n+    if (dryRun) {\n+      prefix = \"[DRY RUN] Would have... \";\n+    }\n+    log.info(prefix + msg);\n+  }\n+\n+  private static void clean(\n+      WorkspacesApi workspacesApi,\n+      BillingApi billingApi,\n+      Set<String> billingProjectIds,\n+      String researcherDomain,\n+      boolean dryRun)\n+      throws ApiException {\n+    int ownersRemoved = 0;\n+    int ownersAdded = 0;\n+    for (FirecloudWorkspaceResponse resp :\n+        workspacesApi.listWorkspaces(FIRECLOUD_LIST_WORKSPACES_REQUIRED_FIELDS)) {\n+      FirecloudWorkspace w = resp.getWorkspace();\n+      if (!billingProjectIds.isEmpty() && !billingProjectIds.contains(w.getNamespace())) {\n+        continue;\n+      }\n+\n+      String id = w.getNamespace() + \"/\" + w.getName();\n+      if (!\"PROJECT_OWNER\".equals(resp.getAccessLevel())) {\n+        log.warning(\n+            String.format(\n+                \"service account has '%s' access to workspace '%s'; skipping\",\n+                resp.getAccessLevel(), id));\n+        continue;\n+      }\n+\n+      Map<String, String> billingProjectRoles =\n+          billingApi.listBillingProjectMembers(w.getNamespace()).stream()\n+              .filter(m -> m.getEmail().endsWith(\"@\" + researcherDomain))\n+              .collect(\n+                  Collectors.toMap(\n+                      FirecloudBillingProjectMember::getEmail,\n+                      FirecloudBillingProjectMember::getRole));\n+      Set<String> billingProjectOwners =\n+          billingProjectRoles.entrySet().stream()\n+              .filter(e -> \"Owner\".equals(e.getValue()))\n+              .map(Entry::getKey)\n+              .collect(Collectors.toSet());\n+\n+      Map<String, String> workspaceRoles =\n+          FirecloudTransforms.extractAclResponse(\n+                  workspacesApi.getWorkspaceAcl(w.getNamespace(), w.getName()))\n+              .entrySet().stream()\n+              .filter(e -> e.getKey().endsWith(\"@\" + researcherDomain))\n+              .collect(Collectors.toMap(Entry::getKey, e -> e.getValue().getAccessLevel()));\n+      Set<String> workspaceOwners =\n+          workspaceRoles.entrySet().stream()\n+              .filter(e -> \"OWNER\".equals(e.getValue()))\n+              .map(e -> e.getKey())\n+              .collect(Collectors.toSet());\n+\n+      // ShareWorkspace first updates the Workspace ACL, then the billing project role. For this\n+      // reason, the workspace ACL is the source of truth, as it will have been set properly in the\n+      // event of a partial sharing failure.\n+      for (String user : Sets.difference(billingProjectOwners, workspaceOwners)) {\n+        dryLog(\n+            dryRun,\n+            String.format(\n+                \"'%s': '%s', inconsistency: workspace role '%s', project role '%s'\",\n+                w.getNamespace(), user, workspaceRoles.get(user), billingProjectRoles.get(user)));\n+        if (billingProjectOwners.contains(user)) {\n+          // This covers RW-5013, which caused incomplete owner removal.\n+          if (!dryRun) {\n+            try {\n+              billingApi.removeUserFromBillingProject(w.getNamespace(), \"owner\", user);\n+            } catch (ApiException e) {\n+              log.log(Level.WARNING, \"failed to remove user from project\", e);\n+            }\n+          }\n+          dryLog(\n+              dryRun,\n+              String.format(\"removed user '%s' from billing project '%s'\", user, w.getNamespace()));\n+          ownersRemoved++;\n+        } else {", "originalCommit": "b704158b78b45e48a3e3d28bdf988b3fc1753e7f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e2afdea5fb55d0e8acf1ce90e61fa4e2b79bf4b8", "url": "https://github.com/all-of-us/workbench/commit/e2afdea5fb55d0e8acf1ce90e61fa4e2b79bf4b8", "message": "Use the right library / method...", "committedDate": "2020-07-09T21:36:41Z", "type": "commit"}, {"oid": "61b5dd2b62194dbbba00ee2bc8b693651927846a", "url": "https://github.com/all-of-us/workbench/commit/61b5dd2b62194dbbba00ee2bc8b693651927846a", "message": "Actually support empty billing project list", "committedDate": "2020-07-09T23:07:35Z", "type": "commit"}]}