{"pr_number": 3118, "pr_title": "[risk=no]Institution DB/Model updates on the road toward RW-4259", "pr_createdAt": "2020-02-11T21:41:56Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3118", "timeline": [{"oid": "94e5e2812d455cf581b6ee2295dfe8e3568466b3", "url": "https://github.com/all-of-us/workbench/commit/94e5e2812d455cf581b6ee2295dfe8e3568466b3", "message": "REFACTOR better interface", "committedDate": "2020-02-11T21:39:12Z", "type": "commit"}, {"oid": "f2528ac3643a5d3298fe94ebe3e12234cf9cb1eb", "url": "https://github.com/all-of-us/workbench/commit/f2528ac3643a5d3298fe94ebe3e12234cf9cb1eb", "message": "REFACTOR attempt at better Spring with much help from Brian\n\nnot working\n\ndoes not work - move column notions to accessors\n\nmoving annotations to getter/setters.\n\nbetter tests\n\nemail domains and addrs are NotNull\nremove DB ids from equality checks\n\nattempted fix by reusing collection\n\nfixing persistence of Institution.\n\nfixing tests.\n\nadding cascade to foreign keys, and updating tests.\n\nadding comment\n\nsmall test updates\n\nfun with sets\n\nserviceImpl refactor\n\nmini test update\n\ncredit to Brian", "committedDate": "2020-02-11T21:39:12Z", "type": "commit"}, {"oid": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "url": "https://github.com/all-of-us/workbench/commit/e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "message": "fun with builders", "committedDate": "2020-02-11T21:39:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxNzE1Ng==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377917156", "bodyText": "These are now fully managed by DbInstitution", "author": "jmthibault79", "createdAt": "2020-02-11T21:43:07Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/InstitutionEmailAddressDao.java", "diffHunk": "@@ -1,16 +0,0 @@\n-package org.pmiops.workbench.db.dao;", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377918155", "bodyText": "RW best practices are to annotate the accessors, not the fields.", "author": "jmthibault79", "createdAt": "2020-02-11T21:45:04Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,41 +12,35 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzIzOA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378537238", "bodyText": "Do we have a doc for those practices yet?", "author": "jaycarlton", "createdAt": "2020-02-12T21:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MzA4NA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378553084", "bodyText": "I will start one", "author": "jmthibault79", "createdAt": "2020-02-12T22:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxODE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxOTU0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377919546", "bodyText": "EAGER fetching is key to making this work correctly.", "author": "jmthibault79", "createdAt": "2020-02-11T21:47:59Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzYzNw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377933637", "bodyText": "Huh, you don't have to give it the key column names. Neat.", "author": "jaycarlton", "createdAt": "2020-02-11T22:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkxOTU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377921008", "bodyText": "Need to make the connection in both directions, but we only need to break it in one.  It is NOT necessary to make this null when removing.", "author": "jmthibault79", "createdAt": "2020-02-11T21:50:50Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDIyMw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377934223", "bodyText": "nit: why are you calling the map variable address instead of ed or similar? I didn't think domains were addresses.", "author": "jaycarlton", "createdAt": "2020-02-11T22:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1MDUzOQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378450539", "bodyText": "copypasta.  good catch.", "author": "jmthibault79", "createdAt": "2020-02-12T19:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyMTkyMg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377921922", "bodyText": "API Model <-> DB Model conversions are now fully independent of DB state!\nTODO (not in this PR) move conversions out of here into a MapStruct mapper.", "author": "jmthibault79", "createdAt": "2020-02-11T21:52:46Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377935072", "bodyText": "Can you explain at a higher level what this function is trying to accomplish? That is, why are we doing multiple set intersections? And why do we need a set difference if emailAddresses is a set to begin with? I thought adding an existing item was a no-op.", "author": "jaycarlton", "createdAt": "2020-02-11T22:22:05Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NTkyNg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378465926", "bodyText": "Added a comment.  Effectively it is doing a simple set assignment.\nFor the last step, we could add the difference or the whole set again.  Should be identical.", "author": "jmthibault79", "createdAt": "2020-02-12T19:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjI1Ng==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377936256", "bodyText": "For clarity, I would make a public nested Builder class and put this there? An example is here. Though I guess you still need your no-arg ctor \ud83e\udd14 .\nAnyway, I wouldn't make an alias function (a non-overload with the same body) unless there's a compelling reason.", "author": "jaycarlton", "createdAt": "2020-02-11T22:24:45Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -78,21 +94,69 @@ public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution organizationTypeOtherText(String organizationTypeOtherText) {\n+    this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public void setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n   }\n \n+  /** Builder method to help streamline the building of a DbInstitution. */\n+  public DbInstitution emailDomains(Set<DbInstitutionEmailDomain> emailDomains) {\n+    setEmailDomains(emailDomains);\n+    return this;\n+  }\n+\n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First, call\n+   * retainAll() to subset DB rows to those we wish to keep: the intersection of old and new. Then,\n+   * call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public void setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));\n+  }\n+\n+  /** Builder method to help streamline the building of a DbInstitution. */", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NjA4NA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378466084", "bodyText": "Merged these to avoid confusion", "author": "jmthibault79", "createdAt": "2020-02-12T19:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzE3NA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377937174", "bodyText": "If this is nullable, should we return Optional<Long>?", "author": "jaycarlton", "createdAt": "2020-02-11T22:26:44Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,57 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\")\n+  public long getInstitutionEmailAddressId() {", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NjIxMg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378466212", "bodyText": "It is not nullable.  Thanks for the catch.", "author": "jmthibault79", "createdAt": "2020-02-12T19:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzE3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNTg4MA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378535880", "bodyText": "Oh I thought it was boxed. nvm.", "author": "jaycarlton", "createdAt": "2020-02-12T21:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377937812", "bodyText": "I'd probably put this on the dao itself as a default List<Institution> getAllInstitutions() so all services using it get the benefit.", "author": "jaycarlton", "createdAt": "2020-02-11T22:28:22Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -19,34 +17,27 @@\n public class InstitutionServiceImpl implements InstitutionService {\n \n   private final InstitutionDao institutionDao;\n-  private final InstitutionEmailDomainDao institutionEmailDomainDao;\n-  private final InstitutionEmailAddressDao institutionEmailAddressDao;\n \n   @Autowired\n-  InstitutionServiceImpl(\n-      InstitutionDao institutionDao,\n-      InstitutionEmailDomainDao institutionEmailDomainDao,\n-      InstitutionEmailAddressDao institutionEmailAddressDao) {\n+  InstitutionServiceImpl(InstitutionDao institutionDao) {\n     this.institutionDao = institutionDao;\n-    this.institutionEmailDomainDao = institutionEmailDomainDao;\n-    this.institutionEmailAddressDao = institutionEmailAddressDao;\n   }\n \n   @Override\n   public List<Institution> getInstitutions() {\n     return StreamSupport.stream(institutionDao.findAll().spliterator(), false)", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1NzU4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378457586", "bodyText": "Should our DAO level be aware of our API?", "author": "jmthibault79", "createdAt": "2020-02-12T19:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTYyNQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378545625", "bodyText": "You mean of the type? Good point. In practice there's not much cyclical dependence added but you're right.\nThis is why I think we need a DataManager layer.", "author": "jaycarlton", "createdAt": "2020-02-12T22:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNzgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODc2NQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377938765", "bodyText": "With the db objects, we can (and I think should) avoid returning null for collections. We don't have a choice with the generated classes though.", "author": "jaycarlton", "createdAt": "2020-02-11T22:30:40Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,50 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .shortName(modelObject.getShortName())\n+        .displayName(modelObject.getDisplayName())\n+        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .emailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))\n+                .collect(Collectors.toSet()));\n   }\n \n-  private Institution toModelClass(final DbInstitution dbClass) {\n-    final Institution institution =\n-        new Institution()\n-            .shortName(dbClass.getShortName())\n-            .displayName(dbClass.getDisplayName())\n-            .organizationTypeEnum(\n-                DbStorageEnums.organizationTypeFromStorage(dbClass.getOrganizationTypeEnum()))\n-            .organizationTypeOtherText(dbClass.getOrganizationTypeOtherText());\n-\n-    Optional.ofNullable(dbClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                institution.emailDomains(\n-                    domains.stream()\n-                        .map(DbInstitutionEmailDomain::getEmailDomain)\n-                        .collect(Collectors.toList())));\n-\n-    Optional.ofNullable(dbClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                institution.emailAddresses(\n-                    addresses.stream()\n-                        .map(DbInstitutionEmailAddress::getEmailAddress)\n-                        .collect(Collectors.toList())));\n-\n-    return institution;\n+  private Institution toModel(final DbInstitution dbObject) {\n+    return new Institution()\n+        .shortName(dbObject.getShortName())\n+        .displayName(dbObject.getDisplayName())\n+        .organizationTypeEnum(dbObject.getOrganizationTypeEnum())\n+        .organizationTypeOtherText(dbObject.getOrganizationTypeOtherText())\n+        .emailDomains(\n+            Optional.ofNullable(dbObject.getEmailDomains()).orElse(Collections.emptySet()).stream()\n+                .map(DbInstitutionEmailDomain::getEmailDomain)\n+                .collect(Collectors.toList()))\n+        .emailAddresses(\n+            Optional.ofNullable(dbObject.getEmailAddresses()).orElse(Collections.emptySet())", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMzc5Nw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378003797", "bodyText": "Actually dbObject.getEmailAddresses() should never be null, since emailAddresses is initialized -> https://github.com/all-of-us/workbench/blob/joel/hibernate-institution/api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java#L28-L28 Hibernate also calls the setEmailAddresses(final Set emailAddresses) with an empty collection if no emailAddresses exist. This test verifies this: https://github.com/all-of-us/workbench/blob/joel/hibernate-institution/api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java#L64-L64", "author": "freemabd", "createdAt": "2020-02-12T02:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ2NjQwMQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378466401", "bodyText": "Good point - updated", "author": "jmthibault79", "createdAt": "2020-02-12T19:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzOTcyMA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377939720", "bodyText": "code under test shouldn't really be executed in setup() if we can avoid it. It's just for mocks and fixtures.  You'll still fail your tests if it blows up, but you should ideally have assertions after important steps, especially in a test_save() method.", "author": "jaycarlton", "createdAt": "2020-02-11T22:32:56Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,175 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().shortName(\"Broad\").displayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Stream.of(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    emailDomains =\n+        Stream.of(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"))\n+            .collect(Collectors.toCollection(HashSet::new));\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .shortName(\"Broad1\")\n+                .displayName(\"The Broad Institute\")\n+                .emailAddresses(emailAddresses)\n+                .emailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    // no need to call save since we have a setup method.", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3MTIzMA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378471230", "bodyText": "updated", "author": "jmthibault79", "createdAt": "2020-02-12T19:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzOTcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MTYwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r377941605", "bodyText": "So if you want to use the builder paradigm, you could make a billed() method that fills in missing array values and other defaultable things.", "author": "jaycarlton", "createdAt": "2020-02-11T22:37:16Z", "path": "api/src/test/java/org/pmiops/workbench/institution/InstitutionServiceTest.java", "diffHunk": "@@ -49,25 +59,32 @@ public void test_deleteInstitution() {\n \n   @Test\n   public void test_getInstitutions() {\n-    assertThat(service.getInstitutions()).containsExactlyElementsIn(ImmutableList.of(testInst));\n+    assertThat(service.getInstitutions()).containsExactly(testInstAfterRT);\n \n     final Institution otherInst =\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\");\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailDomains(new ArrayList<>())\n+            .emailAddresses(new ArrayList<>());\n     service.createInstitution(otherInst);\n-    assertThat(service.getInstitutions())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+    assertThat(service.getInstitutions()).containsExactly(testInstAfterRT, otherInst);\n \n     service.deleteInstitution(testInst.getShortName());\n-    assertThat(service.getInstitutions()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+    assertThat(service.getInstitutions()).containsExactly(otherInst);\n   }\n \n   @Test\n   public void test_getInstitution() {\n-    assertThat(service.getInstitution(testInst.getShortName())).hasValue(testInst);\n+    assertThat(service.getInstitution(testInst.getShortName())).hasValue(testInstAfterRT);\n     assertThat(service.getInstitution(\"otherInst\")).isEmpty();\n \n     final Institution otherInst =\n-        new Institution().shortName(\"otherInst\").displayName(\"The Institution of testing\");\n+        new Institution()\n+            .shortName(\"otherInst\")\n+            .displayName(\"The Institution of testing\")\n+            .emailAddresses(new ArrayList<>())\n+            .emailDomains(new ArrayList<>());", "originalCommit": "e4bcf8439b761a0c2d3a84b9de969cd154d9cc33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ca97d6668f3876555913abff738d0e6b85df9f83", "url": "https://github.com/all-of-us/workbench/commit/ca97d6668f3876555913abff738d0e6b85df9f83", "message": "slopypaste", "committedDate": "2020-02-12T19:03:24Z", "type": "commit"}, {"oid": "6f57cc06f9a6d56d1778af71597b437de0126548", "url": "https://github.com/all-of-us/workbench/commit/6f57cc06f9a6d56d1778af71597b437de0126548", "message": "Add comment describing what setEmailAddresses/Domains do conceptually\nMark addr/domain IDs as not nullable", "committedDate": "2020-02-12T19:08:49Z", "type": "commit"}, {"oid": "e4798fc20be7f8105d744fe6ca350e6d3e21358e", "url": "https://github.com/all-of-us/workbench/commit/e4798fc20be7f8105d744fe6ca350e6d3e21358e", "message": "Don't need to check these for nullability", "committedDate": "2020-02-12T19:18:22Z", "type": "commit"}, {"oid": "f3fcee2a6fdce8b8ae16c7560dcfc32792f02051", "url": "https://github.com/all-of-us/workbench/commit/f3fcee2a6fdce8b8ae16c7560dcfc32792f02051", "message": "merge builder/non-builder accessors", "committedDate": "2020-02-12T19:25:27Z", "type": "commit"}, {"oid": "60dc18e11f89fb07ccc38815528dee50fad881ea", "url": "https://github.com/all-of-us/workbench/commit/60dc18e11f89fb07ccc38815528dee50fad881ea", "message": "test_save() does its own saving", "committedDate": "2020-02-12T19:39:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378475433", "bodyText": "This will also not be null but an empty collection.", "author": "freemabd", "createdAt": "2020-02-12T19:48:09Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -69,16 +69,16 @@ private DbInstitution newDbObject(final Institution modelObject) {\n   private DbInstitution updateDbObject(\n       final DbInstitution dbObject, final Institution modelObject) {\n     return dbObject\n-        .shortName(modelObject.getShortName())\n-        .displayName(modelObject.getDisplayName())\n-        .organizationTypeEnum(modelObject.getOrganizationTypeEnum())\n-        .organizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n-        .emailDomains(\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n             Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n                 .stream()\n                 .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n                 .collect(Collectors.toSet()))\n-        .emailAddresses(\n+        .setEmailAddresses(\n             Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MDc2NQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378480765", "bodyText": "I don't think we can guarantee this because it's generated by Swagger with a null default:\n  private List<String> emailAddresses = null;", "author": "jmthibault79", "createdAt": "2020-02-12T19:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MzA3NA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378483074", "bodyText": "gotcha", "author": "freemabd", "createdAt": "2020-02-12T20:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjExMQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378546111", "bodyText": "I had a proposal for API object factories to help with that, but it didn't make it far.", "author": "jaycarlton", "createdAt": "2020-02-12T22:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3NTQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNjY3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378536675", "bodyText": "Do you not need to have a Hibernate annotation for this like @Id?", "author": "jaycarlton", "createdAt": "2020-02-12T21:58:11Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzc1MQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378537751", "bodyText": "So should we assert that the enum value is actually other when setting this? Should we just go ahead and update it if we're setting this? They're a package deal.", "author": "jaycarlton", "createdAt": "2020-02-12T22:00:30Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NDY4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378554689", "bodyText": "We have no real requirement for this, so I'm keeping it loose to avoid added complexity.", "author": "jmthibault79", "createdAt": "2020-02-12T22:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzNzc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODUzODU0NA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378538544", "bodyText": "Yay for fluent methods.", "author": "jaycarlton", "createdAt": "2020-02-12T22:02:11Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MDk0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378540942", "bodyText": "This looks like you're manually doing Hibernate's job. It seems really odd to me for an entity to take in a set of things it owns, then modify them and save them. I'd much rather see immutable email domain objects being pointed to by this set, unless you have a really urgent reason to work with domains but not the institution. Like where in the UI would you even have such an issue?", "author": "jaycarlton", "createdAt": "2020-02-12T22:07:23Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MjAyMA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378542020", "bodyText": "Are these all addresses belonging to the institution's users from anywhere in the system? I wouldn't have thought to look for that here; it's more of a service method thing in our current pattern. Could you equivalently expose a set of DbUser objects? I don't really know when we do one versus the other.", "author": "jaycarlton", "createdAt": "2020-02-12T22:09:43Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NTM2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378555363", "bodyText": "No.  These are the \"allowed\" emails from https://docs.google.com/document/d/1--wtRB14DK1qAMiz1mlEx12nT4HoUfYRjNkwQJwsycA/edit#heading=h.b5vt06vb56bp", "author": "jmthibault79", "createdAt": "2020-02-12T22:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MjAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0Mjg1MA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378542850", "bodyText": "So the intention of this function is to replace all matching email addresses with updated ones (not sure what other fields that would involve). If this isn't bound directly to the table(s), then I'm confused about the use case.", "author": "jaycarlton", "createdAt": "2020-02-12T22:11:40Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MzMwOA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378543308", "bodyText": "does this save new ones to the database?", "author": "jaycarlton", "createdAt": "2020-02-12T22:12:41Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailAddresses.retainAll(attachedAddresses);\n+    this.emailAddresses.addAll(Sets.difference(attachedAddresses, this.emailAddresses));", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NTU0Ng==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378555546", "bodyText": "yes", "author": "jmthibault79", "createdAt": "2020-02-12T22:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0MzMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDQ5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378544495", "bodyText": "I think you should only define entity objects where it makes sense to your application to use as a standalone object. As in something you think of. If it's just a table row (with no more real abstraction), then you may be able to absorb it into the containing entity.", "author": "jaycarlton", "createdAt": "2020-02-12T22:15:30Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NzU2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378557567", "bodyText": "How would we specify which data table to use for that?", "author": "jmthibault79", "createdAt": "2020-02-12T22:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDg2OA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378544868", "bodyText": "So this class allows the same email address to belong to more than one institution?", "author": "jaycarlton", "createdAt": "2020-02-12T22:16:22Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitutionEmailAddress.java", "diffHunk": "@@ -15,51 +15,58 @@\n @Table(name = \"institution_email_address\")\n public class DbInstitutionEmailAddress {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_email_address_id\")\n   private long institutionEmailAddressId;\n-\n-  @ManyToOne(fetch = FetchType.LAZY)\n-  @JoinColumn(name = \"institution_id\")\n   private DbInstitution institution;\n-\n-  @Column(name = \"email_address\", nullable = false)\n   private String emailAddress;\n \n   public DbInstitutionEmailAddress() {}\n \n-  public DbInstitutionEmailAddress(DbInstitution institution, String emailAddress) {\n-    this.institution = institution;\n-    this.emailAddress = emailAddress;\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_email_address_id\", nullable = false)\n+  public long getInstitutionEmailAddressId() {\n+    return institutionEmailAddressId;\n   }\n \n+  public DbInstitutionEmailAddress setInstitutionEmailAddressId(long institutionEmailAddressId) {\n+    this.institutionEmailAddressId = institutionEmailAddressId;\n+    return this;\n+  }\n+\n+  @ManyToOne(cascade = CascadeType.ALL)\n+  @JoinColumn(name = \"institution_id\", nullable = false)\n   public DbInstitution getInstitution() {\n     return institution;\n   }\n \n+  public DbInstitutionEmailAddress setInstitution(DbInstitution institution) {\n+    this.institution = institution;\n+    return this;\n+  }\n+\n+  @Column(name = \"email_address\", nullable = false)\n   public String getEmailAddress() {\n     return emailAddress;\n   }\n \n+  public DbInstitutionEmailAddress setEmailAddress(String emailAddress) {\n+    this.emailAddress = emailAddress;\n+    return this;\n+  }\n+\n   @Override\n   public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof DbInstitutionEmailAddress)) {\n-      return false;\n-    }\n+    if (this == o) return true;\n+    if (o == null || getClass() != o.getClass()) return false;\n \n     DbInstitutionEmailAddress that = (DbInstitutionEmailAddress) o;\n \n-    return institutionEmailAddressId == that.institutionEmailAddressId\n-        && institution.equals(that.institution)\n-        && emailAddress.equals(that.emailAddress);\n+    return Objects.equals(institution, that.institution)\n+        && Objects.equals(emailAddress, that.emailAddress);\n   }\n \n   @Override\n   public int hashCode() {\n-    return Objects.hash(institutionEmailAddressId, institution, emailAddress);\n+    return Objects.hash(institution, emailAddress);", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NTk0NA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378555944", "bodyText": "yes.  We have no requirement to exclude this.", "author": "jmthibault79", "createdAt": "2020-02-12T22:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NDg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTE0MA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378545140", "bodyText": "I think we should validate that the incoming emailAddress doesn't already have a different institution. Otherwise this is destructive to that institution's map of the world.", "author": "jaycarlton", "createdAt": "2020-02-12T22:17:01Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbInstitution.java", "diffHunk": "@@ -11,88 +12,128 @@\n import javax.persistence.Id;\n import javax.persistence.OneToMany;\n import javax.persistence.Table;\n+import javax.validation.constraints.NotNull;\n+import org.pmiops.workbench.model.OrganizationType;\n \n @Entity\n @Table(name = \"institution\")\n public class DbInstitution {\n \n-  @Id\n-  @GeneratedValue(strategy = GenerationType.IDENTITY)\n-  @Column(name = \"institution_id\")\n-  private long dbId; // primary opaque key for DB use only\n-\n-  @Column(name = \"short_name\", nullable = false, unique = true)\n+  private long institutionId; // primary opaque key for DB use only\n   private String shortName; // unique key exposed to API\n-\n-  @Column(name = \"display_name\", nullable = false)\n   private String displayName;\n-\n-  @Column(name = \"organization_type_enum\")\n   private Short organizationTypeEnum;\n-\n-  @Column(name = \"organization_type_other_text\")\n   private String organizationTypeOtherText;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailDomain> emailDomains;\n-\n-  @OneToMany(mappedBy = \"institution\", fetch = FetchType.LAZY)\n-  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  @NotNull private Set<DbInstitutionEmailDomain> emailDomains = Sets.newHashSet();\n+  @NotNull private Set<DbInstitutionEmailAddress> emailAddresses = Sets.newHashSet();\n \n   public DbInstitution() {}\n \n-  public DbInstitution(final String shortName, final String displayName) {\n-    setShortName(shortName);\n-    setDisplayName(displayName);\n+  @Id\n+  @GeneratedValue(strategy = GenerationType.IDENTITY)\n+  @Column(name = \"institution_id\")\n+  public long getInstitutionId() {\n+    return institutionId;\n   }\n \n+  public DbInstitution setInstitutionId(long institutionId) {\n+    this.institutionId = institutionId;\n+    return this;\n+  }\n+\n+  @Column(name = \"short_name\", nullable = false, unique = true)\n   public String getShortName() {\n     return shortName;\n   }\n \n-  public void setShortName(String shortName) {\n+  public DbInstitution setShortName(String shortName) {\n     this.shortName = shortName;\n+    return this;\n   }\n \n+  @Column(name = \"display_name\", nullable = false)\n   public String getDisplayName() {\n     return displayName;\n   }\n \n-  public void setDisplayName(String displayName) {\n+  public DbInstitution setDisplayName(String displayName) {\n     this.displayName = displayName;\n+    return this;\n   }\n \n-  public Short getOrganizationTypeEnum() {\n-    return organizationTypeEnum;\n+  @Column(name = \"organization_type_enum\")\n+  public OrganizationType getOrganizationTypeEnum() {\n+    return DbStorageEnums.organizationTypeFromStorage(organizationTypeEnum);\n   }\n \n-  public void setOrganizationTypeEnum(Short organizationTypeEnum) {\n-    this.organizationTypeEnum = organizationTypeEnum;\n+  public DbInstitution setOrganizationTypeEnum(OrganizationType type) {\n+    this.organizationTypeEnum = DbStorageEnums.organizationTypeToStorage(type);\n+    return this;\n   }\n \n+  @Column(name = \"organization_type_other_text\")\n   public String getOrganizationTypeOtherText() {\n     return organizationTypeOtherText;\n   }\n \n-  public void setOrganizationTypeOtherText(String organizationTypeOtherText) {\n+  public DbInstitution setOrganizationTypeOtherText(String organizationTypeOtherText) {\n     this.organizationTypeOtherText = organizationTypeOtherText;\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailDomain> getEmailDomains() {\n     return emailDomains;\n   }\n \n-  public void setEmailDomains(Iterable<DbInstitutionEmailDomain> emailDomains) {\n-    this.emailDomains =\n-        StreamSupport.stream(emailDomains.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailDomains = emailDomains\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailDomains the new set of domains for this Institution\n+   */\n+  public DbInstitution setEmailDomains(final Set<DbInstitutionEmailDomain> emailDomains) {\n+    final Set<DbInstitutionEmailDomain> attachedDomains =\n+        emailDomains.stream()\n+            .map(domain -> domain.setInstitution(this))\n+            .collect(Collectors.toSet());\n+    // modifies this set so that its value is the intersection of the two sets\n+    this.emailDomains.retainAll(attachedDomains);\n+    this.emailDomains.addAll(Sets.difference(attachedDomains, this.emailDomains));\n+    return this;\n   }\n \n+  @OneToMany(mappedBy = \"institution\", cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n+  @NotNull\n   public Set<DbInstitutionEmailAddress> getEmailAddresses() {\n     return emailAddresses;\n   }\n \n-  public void setEmailAddresses(Iterable<DbInstitutionEmailAddress> emailAddresses) {\n-    this.emailAddresses =\n-        StreamSupport.stream(emailAddresses.spliterator(), false).collect(Collectors.toSet());\n+  /**\n+   * Effectively: do an in-place this.emailAddresses = emailAddresses\n+   *\n+   * <p>Hibernate doesn't like it when you reassign collections. Instead, modify in-place. First,\n+   * call retainAll() to subset DB rows to those we wish to keep: the intersection of old and new.\n+   * Then, call addAll() to add the diff(new - old) rows.\n+   *\n+   * <p>https://stackoverflow.com/questions/5587482/hibernate-a-collection-with-cascade-all-delete-orphan-was-no-longer-referenc\n+   *\n+   * @param emailAddresses the new set of addresses for this Institution\n+   */\n+  public DbInstitution setEmailAddresses(final Set<DbInstitutionEmailAddress> emailAddresses) {\n+    final Set<DbInstitutionEmailAddress> attachedAddresses =\n+        emailAddresses.stream()\n+            .map(address -> address.setInstitution(this))", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NjE4OQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378556189", "bodyText": "That is not how this works.  See the design doc.", "author": "jmthibault79", "createdAt": "2020-02-12T22:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjYyMA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378546620", "bodyText": "I like chained stream statements, but I have trouble reading nested streams. What would you think about making little helper methods to process the email domains and addresses?", "author": "jaycarlton", "createdAt": "2020-02-12T22:20:33Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1NjQyOQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378556429", "bodyText": "That is coming tomorrow when I convert to MapStruct", "author": "jmthibault79", "createdAt": "2020-02-12T22:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NzI3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378547272", "bodyText": "If the dbObject is already known, then why not fill in both the address and institution here? It wold simplify your setEmailAddresses() method as well.", "author": "jaycarlton", "createdAt": "2020-02-12T22:22:04Z", "path": "api/src/main/java/org/pmiops/workbench/institution/InstitutionServiceImpl.java", "diffHunk": "@@ -64,74 +55,49 @@ public boolean deleteInstitution(final String shortName) {\n   public Optional<Institution> updateInstitution(\n       final String shortName, final Institution institutionToUpdate) {\n     return getDbInstitution(shortName)\n-        .map(dbInst -> toModelClass(saveInstitution(institutionToUpdate, dbInst)));\n+        .map(dbInst -> toModel(institutionDao.save(updateDbObject(dbInst, institutionToUpdate))));\n   }\n \n   private Optional<DbInstitution> getDbInstitution(String shortName) {\n     return institutionDao.findOneByShortName(shortName);\n   }\n \n-  private DbInstitution saveInstitution(final Institution modelClass, final DbInstitution dbClass) {\n-    dbClass.setShortName(modelClass.getShortName());\n-    dbClass.setDisplayName(modelClass.getDisplayName());\n-    dbClass.setOrganizationTypeEnum(\n-        DbStorageEnums.organizationTypeToStorage(modelClass.getOrganizationTypeEnum()));\n-    dbClass.setOrganizationTypeOtherText(modelClass.getOrganizationTypeOtherText());\n-\n-    return saveInstitutionEmailPatterns(modelClass, institutionDao.save(dbClass));\n+  private DbInstitution newDbObject(final Institution modelObject) {\n+    return updateDbObject(new DbInstitution(), modelObject);\n   }\n \n-  private DbInstitution saveInstitutionEmailPatterns(\n-      final Institution modelClass, final DbInstitution dbClass) {\n-\n-    institutionEmailDomainDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailDomains())\n-        .ifPresent(\n-            domains ->\n-                dbClass.setEmailDomains(\n-                    institutionEmailDomainDao.save(\n-                        domains.stream()\n-                            .map(domain -> new DbInstitutionEmailDomain(dbClass, domain))\n-                            .collect(Collectors.toSet()))));\n-\n-    institutionEmailAddressDao.deleteAllByInstitution(dbClass);\n-    Optional.ofNullable(modelClass.getEmailAddresses())\n-        .ifPresent(\n-            addresses ->\n-                dbClass.setEmailAddresses(\n-                    institutionEmailAddressDao.save(\n-                        addresses.stream()\n-                            .map(address -> new DbInstitutionEmailAddress(dbClass, address))\n-                            .collect(Collectors.toSet()))));\n-\n-    return institutionDao.save(dbClass);\n+  private DbInstitution updateDbObject(\n+      final DbInstitution dbObject, final Institution modelObject) {\n+    return dbObject\n+        .setShortName(modelObject.getShortName())\n+        .setDisplayName(modelObject.getDisplayName())\n+        .setOrganizationTypeEnum(modelObject.getOrganizationTypeEnum())\n+        .setOrganizationTypeOtherText(modelObject.getOrganizationTypeOtherText())\n+        .setEmailDomains(\n+            Optional.ofNullable(modelObject.getEmailDomains()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(domain -> new DbInstitutionEmailDomain().setEmailDomain(domain))\n+                .collect(Collectors.toSet()))\n+        .setEmailAddresses(\n+            Optional.ofNullable(modelObject.getEmailAddresses()).orElse(Collections.emptyList())\n+                .stream()\n+                .map(address -> new DbInstitutionEmailAddress().setEmailAddress(address))", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1ODAzMg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378558032", "bodyText": "I'm not following", "author": "jmthibault79", "createdAt": "2020-02-12T22:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0NzI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODUxMg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378548512", "bodyText": "nit: maybe savedWithEmail?", "author": "jaycarlton", "createdAt": "2020-02-12T22:25:07Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1ODg4NA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378558884", "bodyText": "ok", "author": "jmthibault79", "createdAt": "2020-02-12T22:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODg1Mw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378548853", "bodyText": "nit: if findOne wold return Optional, that'd be great.", "author": "jaycarlton", "createdAt": "2020-02-12T22:25:51Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MjI3Mw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378562273", "bodyText": "findOne() is built-in to CrudRepository.\nthe main accessor for client code findOneByShortName() does return an optional.", "author": "jmthibault79", "createdAt": "2020-02-12T22:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0ODg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0OTU0Nw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378549547", "bodyText": "these are a mouthful and also very hard to distinguish (b/c the different letters are in the middle). Maybe simpleInstitution and emailPopulatedInstition or something?", "author": "jaycarlton", "createdAt": "2020-02-12T22:27:23Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1ODk3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378558975", "bodyText": "will update", "author": "jmthibault79", "createdAt": "2020-02-12T22:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU0OTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550049", "bodyText": "Why can't this setEmailAddresses simply take in a collection of Strings? It could do the construction and population of the dbInstitution reference in one place so the caller doesn't have to.", "author": "jaycarlton", "createdAt": "2020-02-12T22:28:30Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2Mjk2OQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378562969", "bodyText": "Now that is an interesting idea.  I'll look into it.", "author": "jmthibault79", "createdAt": "2020-02-12T23:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2OTg5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378569895", "bodyText": "This does not appear to be possible with accessor-based Hibernate.", "author": "jmthibault79", "createdAt": "2020-02-12T23:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2OTA1MA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378869050", "bodyText": "\u2639\ufe0f I thought the new hotness was field-based https://pmi-engteam.slack.com/archives/CPC84FQRF/p1580305523002500?thread_ts=1580305523.002500. I guess the jury is still out, but this is one more reason to do it on the properties I would think.", "author": "jaycarlton", "createdAt": "2020-02-13T13:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg4NjAxOA==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378886018", "bodyText": "I also came to that incorrect conclusion based on that conversation.  I have updated the conversation hopefully to avoid further confusion.", "author": "jmthibault79", "createdAt": "2020-02-13T14:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDQzMw==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550433", "bodyText": "please overwrite the arg passed to save().", "author": "jaycarlton", "createdAt": "2020-02-12T22:29:30Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n \n-    DbInstitution otherInst = new DbInstitution(\"Verily\", \"An Alphabet Company\");\n-    otherInst = institutionDao.save(otherInst);\n-    assertThat(institutionDao.findOneByShortName(\"Verily\")).hasValue(otherInst);\n+  @Test\n+  public void test_updateRemoveAllEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses = Sets.newHashSet();\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MjM3Ng==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378562376", "bodyText": "good catch", "author": "jmthibault79", "createdAt": "2020-02-12T22:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MDc0Mg==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378550742", "bodyText": "please make the test data more representative, e.g., auburn.edu.", "author": "jaycarlton", "createdAt": "2020-02-12T22:30:16Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n \n-    DbInstitution otherInst = new DbInstitution(\"Verily\", \"An Alphabet Company\");\n-    otherInst = institutionDao.save(otherInst);\n-    assertThat(institutionDao.findOneByShortName(\"Verily\")).hasValue(otherInst);\n+  @Test\n+  public void test_updateRemoveAllEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses = Sets.newHashSet();\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailDomains() {\n+    Set<DbInstitutionEmailDomain> newEmailDomains =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain1\"),\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailDomains(newEmailDomains);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).containsExactlyElementsIn(newEmailDomains);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailDomains() {\n+    Set<DbInstitutionEmailDomain> newEmailDomains =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"),", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU1MTM2Ng==", "url": "https://github.com/all-of-us/workbench/pull/3118#discussion_r378551366", "bodyText": "nit: make args look like email addresses\nAlso, we need some testing of the sharing (if allowed) of addresses across institutions.", "author": "jaycarlton", "createdAt": "2020-02-12T22:31:41Z", "path": "api/src/test/java/org/pmiops/workbench/db/dao/InstitutionDaoTest.java", "diffHunk": "@@ -3,65 +3,192 @@\n import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.truth.Truth8.assertThat;\n \n-import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import java.util.Set;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.pmiops.workbench.db.model.DbInstitution;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailAddress;\n+import org.pmiops.workbench.db.model.DbInstitutionEmailDomain;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;\n import org.springframework.dao.DataIntegrityViolationException;\n import org.springframework.test.annotation.DirtiesContext;\n+import org.springframework.test.annotation.DirtiesContext.ClassMode;\n import org.springframework.test.context.junit4.SpringRunner;\n \n @RunWith(SpringRunner.class)\n @DataJpaTest\n-@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\n+@DirtiesContext(classMode = ClassMode.BEFORE_EACH_TEST_METHOD)\n public class InstitutionDaoTest {\n+\n   @Autowired InstitutionDao institutionDao;\n \n-  private DbInstitution testInst = new DbInstitution(\"Broad\", \"The Broad Institute\");\n+  private DbInstitution institutionNoEmailAddressesOrDomains;\n+  private DbInstitution institutionWithEmailAddressesAndDomains;\n+  private Set<DbInstitutionEmailAddress> emailAddresses;\n+  private Set<DbInstitutionEmailDomain> emailDomains;\n \n   @Before\n   public void setUp() {\n-    testInst = institutionDao.save(testInst);\n+    institutionNoEmailAddressesOrDomains =\n+        institutionDao.save(\n+            new DbInstitution().setShortName(\"Broad\").setDisplayName(\"The Broad Institute\"));\n+\n+    emailAddresses =\n+        Sets.newHashSet(new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"));\n+    emailDomains = Sets.newHashSet(new DbInstitutionEmailDomain().setEmailDomain(\"emailDomain\"));\n+\n+    institutionWithEmailAddressesAndDomains =\n+        institutionDao.save(\n+            new DbInstitution()\n+                .setShortName(\"Broad1\")\n+                .setDisplayName(\"The Broad Institute\")\n+                .setEmailAddresses(emailAddresses)\n+                .setEmailDomains(emailDomains));\n   }\n \n   @Test\n   public void test_save() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.save(new DbInstitution(\"VUMC\", \"Vanderbilt\"));\n-    assertThat(institutionDao.findAll()).hasSize(2);\n+    final DbInstitution toSaveWith =\n+        new DbInstitution()\n+            .setShortName(\"Vanderbilt\")\n+            .setDisplayName(\"Vanderbilt University\")\n+            .setEmailDomains(emailDomains)\n+            .setEmailAddresses(emailAddresses);\n+    final DbInstitution savedWith = institutionDao.save(toSaveWith);\n+    assertThat(savedWith).isEqualTo(toSaveWith);\n+    assertThat(savedWith.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(savedWith.getEmailAddresses()).isEqualTo(emailAddresses);\n+\n+    final DbInstitution toSaveWithout =\n+        new DbInstitution()\n+            .setShortName(\"VUMC\")\n+            .setDisplayName(\"Vanderbilt University Medical Center\");\n+    final DbInstitution savedWithout = institutionDao.save(toSaveWithout);\n+    assertThat(savedWithout).isEqualTo(toSaveWithout);\n+    assertThat(savedWithout.getEmailDomains()).isEmpty();\n+    assertThat(savedWithout.getEmailAddresses()).isEmpty();\n   }\n \n   @Test\n   public void test_delete() {\n-    assertThat(institutionDao.findAll()).hasSize(1);\n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).hasSize(0);\n+    institutionDao.delete(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isNull();\n+    assertThat(institutionDao.findAll()).containsExactly(institutionWithEmailAddressesAndDomains);\n   }\n \n   @Test\n   public void test_findAll() {\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(testInst));\n-\n-    DbInstitution otherInst = new DbInstitution(\"VUMC\", \"Vanderbilt\");\n-    otherInst = institutionDao.save(otherInst);\n     assertThat(institutionDao.findAll())\n-        .containsExactlyElementsIn(ImmutableList.of(testInst, otherInst));\n+        .containsExactly(\n+            institutionNoEmailAddressesOrDomains, institutionWithEmailAddressesAndDomains);\n+  }\n \n-    institutionDao.delete(institutionDao.findOneByShortName(\"Broad\").get());\n-    assertThat(institutionDao.findAll()).containsExactlyElementsIn(ImmutableList.of(otherInst));\n+  @Test\n+  public void test_findOne() {\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionNoEmailAddressesOrDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionNoEmailAddressesOrDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEmpty();\n+    assertThat(dbInstitution.getEmailAddresses()).isEmpty();\n+\n+    dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailDomains()).isEqualTo(emailDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).isEqualTo(emailAddresses);\n   }\n \n   @Test\n   public void test_findOneByShortName() {\n-    assertThat(institutionDao.findOneByShortName(\"Broad\")).hasValue(testInst);\n+    assertThat(institutionDao.findOneByShortName(\"Broad\"))\n+        .hasValue(institutionNoEmailAddressesOrDomains);\n+    assertThat(institutionDao.findOneByShortName(\"Broad1\"))\n+        .hasValue(institutionWithEmailAddressesAndDomains);\n     assertThat(institutionDao.findOneByShortName(\"Verily\")).isEmpty();\n+  }\n+\n+  @Test\n+  public void test_updateAllNewEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress1\"),\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress2\"));\n+    institutionWithEmailAddressesAndDomains.setEmailAddresses(newEmailAddresses);\n+    institutionDao.save(institutionWithEmailAddressesAndDomains);\n+\n+    DbInstitution dbInstitution =\n+        institutionDao.findOne(institutionWithEmailAddressesAndDomains.getInstitutionId());\n+    assertThat(dbInstitution).isEqualTo(institutionWithEmailAddressesAndDomains);\n+    assertThat(dbInstitution.getEmailAddresses()).containsExactlyElementsIn(newEmailAddresses);\n+  }\n+\n+  @Test\n+  public void test_updateWithExistingEmailAddresses() {\n+    Set<DbInstitutionEmailAddress> newEmailAddresses =\n+        Sets.newHashSet(\n+            new DbInstitutionEmailAddress().setEmailAddress(\"emailAddress\"),", "originalCommit": "60dc18e11f89fb07ccc38815528dee50fad881ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cafc03c11ca9aeb3f980a93e3872e09aa389ff6c", "url": "https://github.com/all-of-us/workbench/commit/cafc03c11ca9aeb3f980a93e3872e09aa389ff6c", "message": "test renaming and data updates", "committedDate": "2020-02-12T22:52:26Z", "type": "commit"}, {"oid": "6cb2b950524c7be2713c9e48707c05bc5c781d19", "url": "https://github.com/all-of-us/workbench/commit/6cb2b950524c7be2713c9e48707c05bc5c781d19", "message": "protect against save() munging and be explicit that dupe emails are OK", "committedDate": "2020-02-12T22:57:03Z", "type": "commit"}, {"oid": "86b684f98a1c19bcfbcce7bfba8fd76e08a0f412", "url": "https://github.com/all-of-us/workbench/commit/86b684f98a1c19bcfbcce7bfba8fd76e08a0f412", "message": "lint", "committedDate": "2020-02-12T23:22:28Z", "type": "commit"}]}