{"pr_number": 3624, "pr_title": "[RW-4921][RISK=NO] User Audit Log API", "pr_createdAt": "2020-05-29T16:14:08Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3624", "timeline": [{"oid": "947b794267e9aee534f26ead45eaea7601ad7ad4", "url": "https://github.com/all-of-us/workbench/commit/947b794267e9aee534f26ead45eaea7601ad7ad4", "message": "most of the types", "committedDate": "2020-05-20T14:51:59Z", "type": "commit"}, {"oid": "7a7dc3fc5696f77e27af01eb5b887a02c8fc7c40", "url": "https://github.com/all-of-us/workbench/commit/7a7dc3fc5696f77e27af01eb5b887a02c8fc7c40", "message": "first cut at querying", "committedDate": "2020-05-20T17:22:05Z", "type": "commit"}, {"oid": "283383d854b2a1def54a53ae54688b4bdf22e3bb", "url": "https://github.com/all-of-us/workbench/commit/283383d854b2a1def54a53ae54688b4bdf22e3bb", "message": "spotless", "committedDate": "2020-05-20T17:22:47Z", "type": "commit"}, {"oid": "7da66e72450e2bb08554323593a4275498f58ccc", "url": "https://github.com/all-of-us/workbench/commit/7da66e72450e2bb08554323593a4275498f58ccc", "message": "first working version", "committedDate": "2020-05-20T22:28:31Z", "type": "commit"}, {"oid": "09ab27c9e19d1635d4324f5d5442077b869ba7b8", "url": "https://github.com/all-of-us/workbench/commit/09ab27c9e19d1635d4324f5d5442077b869ba7b8", "message": "comment out", "committedDate": "2020-05-21T12:43:33Z", "type": "commit"}, {"oid": "8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "url": "https://github.com/all-of-us/workbench/commit/8055fa186cfd307f91a95c3f7c5c601cd4ceb364", "message": "fix path [skip ci]", "committedDate": "2020-05-21T12:46:32Z", "type": "commit"}, {"oid": "9d71b7d0503470fedbbf794a40581942885f5fcb", "url": "https://github.com/all-of-us/workbench/commit/9d71b7d0503470fedbbf794a40581942885f5fcb", "message": "start on unit", "committedDate": "2020-05-21T15:52:15Z", "type": "commit"}, {"oid": "17a9c1f948e7d47b841dc00906a8d3c84f274b52", "url": "https://github.com/all-of-us/workbench/commit/17a9c1f948e7d47b841dc00906a8d3c84f274b52", "message": "cleanup", "committedDate": "2020-05-21T20:59:39Z", "type": "commit"}, {"oid": "991ad868ce4f8c686718fd48e0cd3266af0435d3", "url": "https://github.com/all-of-us/workbench/commit/991ad868ce4f8c686718fd48e0cd3266af0435d3", "message": "fix datetime comparison", "committedDate": "2020-05-21T21:40:38Z", "type": "commit"}, {"oid": "244bf8a82376359e2e7c3a68afc03518f88f6aee", "url": "https://github.com/all-of-us/workbench/commit/244bf8a82376359e2e7c3a68afc03518f88f6aee", "message": "no result test", "committedDate": "2020-05-21T22:32:05Z", "type": "commit"}, {"oid": "2dc97b1d64eb8aef54f926f245debfb2973efc27", "url": "https://github.com/all-of-us/workbench/commit/2dc97b1d64eb8aef54f926f245debfb2973efc27", "message": "add more methods", "committedDate": "2020-05-26T13:59:45Z", "type": "commit"}, {"oid": "e30da7e8e7c53a1c2f1726ec18099067823bf0cf", "url": "https://github.com/all-of-us/workbench/commit/e30da7e8e7c53a1c2f1726ec18099067823bf0cf", "message": "update description", "committedDate": "2020-05-26T14:12:58Z", "type": "commit"}, {"oid": "c1b76260834a181721fc33a502d12c49219d7837", "url": "https://github.com/all-of-us/workbench/commit/c1b76260834a181721fc33a502d12c49219d7837", "message": "test improvements", "committedDate": "2020-05-26T17:50:25Z", "type": "commit"}, {"oid": "179ae60005e7b90d3912ffb88838e0e8bed3538b", "url": "https://github.com/all-of-us/workbench/commit/179ae60005e7b90d3912ffb88838e0e8bed3538b", "message": "make more readable", "committedDate": "2020-05-26T19:32:27Z", "type": "commit"}, {"oid": "76857e11f40671678ead337e36b71453c3b75f11", "url": "https://github.com/all-of-us/workbench/commit/76857e11f40671678ead337e36b71453c3b75f11", "message": "docs and tests", "committedDate": "2020-05-26T19:49:40Z", "type": "commit"}, {"oid": "b1612bd29ab7ecfe4b4190cecc78f27ccb54009b", "url": "https://github.com/all-of-us/workbench/commit/b1612bd29ab7ecfe4b4190cecc78f27ccb54009b", "message": "Merge branch 'master' into jaycarlton/RW-4921", "committedDate": "2020-05-27T18:46:08Z", "type": "commit"}, {"oid": "9c3e6993620f3d334569219163acfa7032985478", "url": "https://github.com/all-of-us/workbench/commit/9c3e6993620f3d334569219163acfa7032985478", "message": "comments", "committedDate": "2020-05-27T21:17:52Z", "type": "commit"}, {"oid": "991043e62ce222bd3ebd5cd70d94a1ed96f16070", "url": "https://github.com/all-of-us/workbench/commit/991043e62ce222bd3ebd5cd70d94a1ed96f16070", "message": "most of the recommendations", "committedDate": "2020-05-28T14:56:14Z", "type": "commit"}, {"oid": "b1188d90284767cfe44d339a0d06318cf9f9b346", "url": "https://github.com/all-of-us/workbench/commit/b1188d90284767cfe44d339a0d06318cf9f9b346", "message": "fixup formats", "committedDate": "2020-05-28T16:08:02Z", "type": "commit"}, {"oid": "085d5d1db8e450d189679e3f881af832a28d2516", "url": "https://github.com/all-of-us/workbench/commit/085d5d1db8e450d189679e3f881af832a28d2516", "message": "spotless", "committedDate": "2020-05-28T17:22:23Z", "type": "commit"}, {"oid": "35691b7d37692adc2e95d2cea33c305b92f57f9f", "url": "https://github.com/all-of-us/workbench/commit/35691b7d37692adc2e95d2cea33c305b92f57f9f", "message": "Merge branch 'master' into jaycarlton/RW-4921", "committedDate": "2020-05-28T20:49:59Z", "type": "commit"}, {"oid": "44aa886bb5d801d873bafc98ba430e27e448ddc8", "url": "https://github.com/all-of-us/workbench/commit/44aa886bb5d801d873bafc98ba430e27e448ddc8", "message": "make room for new new api", "committedDate": "2020-05-28T21:27:01Z", "type": "commit"}, {"oid": "8b39cefc0742832e243489257d358096759d79e1", "url": "https://github.com/all-of-us/workbench/commit/8b39cefc0742832e243489257d358096759d79e1", "message": "test stuff [skip ci]", "committedDate": "2020-05-28T21:35:28Z", "type": "commit"}, {"oid": "f89a5097043108758b6aa9f0828ed2a8ac673793", "url": "https://github.com/all-of-us/workbench/commit/f89a5097043108758b6aa9f0828ed2a8ac673793", "message": "mapper", "committedDate": "2020-05-29T15:55:50Z", "type": "commit"}, {"oid": "8a1f37fddc29c63285484663a5415a5b24792dc7", "url": "https://github.com/all-of-us/workbench/commit/8a1f37fddc29c63285484663a5415a5b24792dc7", "message": "[skip ci]", "committedDate": "2020-05-29T18:02:57Z", "type": "commit"}, {"oid": "50d0a537e381fa752fc22292e827c0a2652d5835", "url": "https://github.com/all-of-us/workbench/commit/50d0a537e381fa752fc22292e827c0a2652d5835", "message": "audit helper snippet", "committedDate": "2020-05-29T19:29:44Z", "type": "commit"}, {"oid": "e874228818ded9b5a4ef66e5024b60f3a4b41365", "url": "https://github.com/all-of-us/workbench/commit/e874228818ded9b5a4ef66e5024b60f3a4b41365", "message": "rename WORKSPACES_VIEW and remove ordinals", "committedDate": "2020-06-01T18:09:07Z", "type": "commit"}, {"oid": "f6c53e2921865aac0198727df221c63a07fa3760", "url": "https://github.com/all-of-us/workbench/commit/f6c53e2921865aac0198727df221c63a07fa3760", "message": "use first part of email address only", "committedDate": "2020-06-01T18:40:41Z", "type": "commit"}, {"oid": "0bd9c6f19a3aba1dad5bc50995e96d94d7596d84", "url": "https://github.com/all-of-us/workbench/commit/0bd9c6f19a3aba1dad5bc50995e96d94d7596d84", "message": "fix capitalization and rename. don't create empty property change objects", "committedDate": "2020-06-01T19:32:10Z", "type": "commit"}, {"oid": "aefa74c949b05cd09e9e2f8fa4b1c45e27a33cfc", "url": "https://github.com/all-of-us/workbench/commit/aefa74c949b05cd09e9e2f8fa4b1c45e27a33cfc", "message": "test for mapper", "committedDate": "2020-06-01T21:00:26Z", "type": "commit"}, {"oid": "fa3e83aa31bdcace7c6956ccad986cae63fc85e4", "url": "https://github.com/all-of-us/workbench/commit/fa3e83aa31bdcace7c6956ccad986cae63fc85e4", "message": "Merge branch 'master' into jaycarlton/userQueryApi", "committedDate": "2020-06-02T14:08:32Z", "type": "commit"}, {"oid": "1c5df815d9f02d5a654a8c9c13cea16190537c50", "url": "https://github.com/all-of-us/workbench/commit/1c5df815d9f02d5a654a8c9c13cea16190537c50", "message": "spotless & test fixes", "committedDate": "2020-06-02T17:40:02Z", "type": "commit"}, {"oid": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "url": "https://github.com/all-of-us/workbench/commit/a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "message": "remove bash snippet", "committedDate": "2020-06-02T17:50:23Z", "type": "commit"}, {"oid": "83168668b74f5f4717f5830bc39e0b4ed00c5e8e", "url": "https://github.com/all-of-us/workbench/commit/83168668b74f5f4717f5830bc39e0b4ed00c5e8e", "message": "description updates", "committedDate": "2020-06-02T18:00:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNDQ5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434204495", "bodyText": "typo: adit", "author": "jmthibault79", "createdAt": "2020-06-02T22:13:47Z", "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Streams;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.elasticsearch.common.Strings;\n+import org.mapstruct.Mapper;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTarget;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.pmiops.workbench.utils.FieldValues;\n+\n+@Mapper(config = MapStructConfig.class)\n+public interface AuditLogEntryMapper {\n+  AuditAgent logEntryToAgent(AuditLogEntry auditLogEntry);\n+\n+  default AuditEventBundleHeader logEntryToEventBundleHeader(AuditLogEntry auditLogEntry) {\n+    return new AuditEventBundleHeader()\n+        .target(logEntryToTarget(auditLogEntry))\n+        .agent(logEntryToAgent(auditLogEntry))\n+        .actionType(auditLogEntry.getActionType());\n+  }\n+\n+  AuditTarget logEntryToTarget(AuditLogEntry auditLogEntry);\n+\n+  /**\n+   * Build an AuditTargetPropertyChange object from the relevant fields in the AuditLogEntry, unless\n+   * all of those are null, in which case return an empty optional\n+   *\n+   * @param auditLogEntry\n+   * @return\n+   */\n+  default Optional<AuditTargetPropertyChange> logEntryToTargetPropertyChange(\n+      AuditLogEntry auditLogEntry) {\n+    if ((Strings.isNullOrEmpty(auditLogEntry.getTargetProperty())\n+            && Strings.isNullOrEmpty(auditLogEntry.getPreviousValue()))\n+        && Strings.isNullOrEmpty(auditLogEntry.getNewValue())) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(\n+          new AuditTargetPropertyChange()\n+              .targetProperty(auditLogEntry.getTargetProperty())\n+              .previousValue(auditLogEntry.getPreviousValue())\n+              .newValue(auditLogEntry.getNewValue()));\n+    }\n+  }\n+\n+  default List<AuditAction> logEntriesToActions(List<AuditLogEntry> logEntries) {\n+    final Multimap<String, AuditLogEntry> actionIdToRows =\n+        Multimaps.index(logEntries, AuditLogEntry::getActionId);\n+    return actionIdToRows.asMap().values().stream()\n+        .map(this::buildAuditAction)\n+        .collect(ImmutableList.toImmutableList());\n+  }\n+\n+  /**\n+   * @param logEntries Collection of AuditLogEntry objectsthat have a common Action ID, which should\n+   *     be the same event time, given the unofficial but surprisingly harshly enforced non-schema\n+   *     schama.\n+   */\n+  default AuditAction buildAuditAction(Collection<AuditLogEntry> logEntries) {\n+    final AuditLogEntry firstEntry =\n+        logEntries.stream()\n+            .findFirst()\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\"logEntries collection must not be empty\"));\n+\n+    final AuditAction result =\n+        new AuditAction().actionId(firstEntry.getActionId()).actionTime(firstEntry.getEventTime());\n+\n+    final Multimap<AuditEventBundleHeader, AuditLogEntry> headerToLogEntries =\n+        Multimaps.index(logEntries, this::logEntryToEventBundleHeader);\n+    final List<AuditEventBundle> eventBundles =\n+        headerToLogEntries.asMap().entrySet().stream()\n+            .map(e -> buildEventBundle(e.getKey(), e.getValue()))\n+            .collect(Collectors.toList());\n+\n+    return result.eventBundles(eventBundles);\n+  }\n+\n+  default AuditEventBundle buildEventBundle(\n+      AuditEventBundleHeader header, Collection<AuditLogEntry> logEntries) {\n+    return new AuditEventBundle()\n+        .header(header)\n+        .propertyChanges(\n+            logEntries.stream()\n+                .map(this::logEntryToTargetPropertyChange)\n+                .flatMap(Streams::stream)\n+                .collect(Collectors.toList()));\n+  }\n+\n+  default AuditLogEntry fieldValueListToAditLogEntry(FieldValueList row) {", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTI3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434205275", "bodyText": "there's a lot of duplication between the two queryStrings.  What can we reuse?", "author": "jmthibault79", "createdAt": "2020-06-02T22:15:52Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/ActionAuditQueryServiceImpl.java", "diffHunk": "@@ -1,137 +1,153 @@\n package org.pmiops.workbench.actionaudit;\n \n-import com.google.cloud.bigquery.FieldValueList;\n import com.google.cloud.bigquery.QueryJobConfiguration;\n import com.google.cloud.bigquery.QueryParameterValue;\n import com.google.cloud.bigquery.StandardSQLTypeName;\n import com.google.cloud.bigquery.TableResult;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.stream.StreamSupport;\n import javax.inject.Provider;\n import org.joda.time.DateTime;\n import org.pmiops.workbench.api.BigQueryService;\n import org.pmiops.workbench.config.WorkbenchConfig;\n import org.pmiops.workbench.config.WorkbenchConfig.ActionAuditConfig;\n import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.UserAuditLogQueryResponse;\n import org.pmiops.workbench.model.WorkspaceAuditLogQueryResponse;\n-import org.pmiops.workbench.utils.FieldValues;\n+import org.pmiops.workbench.utils.mappers.AuditLogEntryMapper;\n import org.springframework.stereotype.Service;\n \n @Service\n public class ActionAuditQueryServiceImpl implements ActionAuditQueryService {\n \n   private static final int MICROSECONDS_IN_MILLISECOND = 1000;\n+  private static final long MAX_QUERY_LIMIT = 1000L;\n \n-  enum Parameters {\n-    LIMIT(\"limit\"),\n-    WORKSPACE_DB_ID(\"workspace_db_id\"),\n-    AFTER_INCLUSIVE(\"after_inclusive\"),\n-    BEFORE_EXCLUSIVE(\"before_exclusive\");\n-\n-    private String name;\n-\n-    Parameters(String name) {\n-      this.name = name;\n-    }\n-\n-    public String getName() {\n-      return name;\n-    }\n-  }\n-\n+  private final AuditLogEntryMapper auditLogEntryMapper;\n   private final BigQueryService bigQueryService;\n   private final Provider<WorkbenchConfig> workbenchConfigProvider;\n \n-  private static final long MAX_QUERY_LIMIT = 1000L;\n-  // The table name can't be in a QueryParameterValue, so we substitute it with String.format()\n-  private static final String WORKSPACE_EVENTS_QUERY_STRING_FORMAT =\n-      \"SELECT\\n\"\n-          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) as event_time,\\n\"\n-          + \"  jsonPayload.agent_type AS agent_type,\\n\"\n-          + \"  CAST(jsonPayload.agent_id AS INT64) AS agent_id,\\n\"\n-          + \"  jsonPayload.agent_email AS agent_username,\\n\"\n-          + \"  jsonPayload.action_id AS action_id,\\n\"\n-          + \"  jsonPayload.action_type AS action_type,\\n\"\n-          + \"  jsonPayload.target_type AS target_type,\\n\"\n-          + \"  CAST(jsonPayload.target_id AS INT64) AS target_id,\\n\"\n-          + \"  jsonPayload.target_property AS target_property,\\n\"\n-          + \"  jsonPayload.prev_value AS prev_value,\\n\"\n-          + \"  jsonPayload.new_value AS new_value\\n\"\n-          + \"FROM %s\\n\"\n-          + \"WHERE jsonPayload.target_id = @workspace_db_id AND\\n\"\n-          + \"  jsonPayload.target_type = 'WORKSPACE' AND\\n\"\n-          + \"  @after_inclusive <= TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) AND\\n\"\n-          + \"  TIMESTAMP_MILLIS(CAST(jsonPayload.timestamp AS INT64)) < @before_exclusive\\n\"\n-          + \"ORDER BY event_time, agent_id, action_id\\n\"\n-          + \"LIMIT @limit\";\n-\n   public ActionAuditQueryServiceImpl(\n-      BigQueryService bigQueryService, Provider<WorkbenchConfig> workbenchConfigProvider) {\n+      AuditLogEntryMapper auditLogEntryMapper,\n+      BigQueryService bigQueryService,\n+      Provider<WorkbenchConfig> workbenchConfigProvider) {\n+    this.auditLogEntryMapper = auditLogEntryMapper;\n     this.bigQueryService = bigQueryService;\n     this.workbenchConfigProvider = workbenchConfigProvider;\n   }\n \n   @Override\n   public WorkspaceAuditLogQueryResponse queryEventsForWorkspace(\n-      long workspaceDatabaseId, long limit, DateTime afterInclusive, DateTime beforeExclusive) {\n-    final ActionAuditConfig actionAuditConfig = workbenchConfigProvider.get().actionAudit;\n-    final String fullyQualifiedTableName =\n-        String.format(\n-            \"`%s.%s.%s`\",\n-            workbenchConfigProvider.get().server.projectId,\n-            actionAuditConfig.bigQueryDataset,\n-            actionAuditConfig.bigQueryTable);\n+      long workspaceDatabaseId, long limit, DateTime after, DateTime before) {\n \n     final String queryString =\n-        String.format(WORKSPACE_EVENTS_QUERY_STRING_FORMAT, fullyQualifiedTableName);\n+        String.format(", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5MzA0NA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434693044", "bodyText": "Yeah...I'm trying not to get too fancy here without using a real DSL for query building. However, it's easy enough to split out the select statement, timestamp checks, and limit.", "author": "jaycarlton", "createdAt": "2020-06-03T16:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTg2Mg==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434205862", "bodyText": "is this the only one that was added?  looks like it", "author": "jmthibault79", "createdAt": "2020-06-02T22:17:26Z", "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -187,60 +190,63 @@ public DbDemographicSurvey apply(DemographicSurvey demographicSurvey) {\n \n   private static final long MAX_BILLING_PROJECT_CREATION_ATTEMPTS = 5;\n \n+  private final ActionAuditQueryService actionAuditQueryService;", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5MzgwMA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434693800", "bodyText": "yes I believe so. When alphabetizing, you exchange a one-time ugly diff for better merge management in the future and easier-to-find items.", "author": "jaycarlton", "createdAt": "2020-06-03T16:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNjEwNA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434206104", "bodyText": "any idea what this comment meant?", "author": "jmthibault79", "createdAt": "2020-06-02T22:18:08Z", "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -871,10 +877,33 @@ private void updateBypass(long userId, AccessBypassRequest request) {\n     log.log(Level.WARNING, \"Deleting profile: user email: \" + user.getUsername());\n     directoryService.deleteUser(user.getUsername().split(\"@\")[0]);\n     userDao.delete(user.getUserId());\n-    profileAuditor.fireDeleteAction(\n-        user.getUserId(),\n-        user.getUsername()); // not sure if user profider will survive the next line", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5NTY4Mg==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434695682", "bodyText": "I originally wrote it, and at the time I was fighting with the user provider and understanding how the scopes work. In particular, you can shoot yourself in the foot if you manage to use a provider outside of its intended scope, and it's also possible to confuse the administrator deleting the user with the user being deleted if you're not careful.\nIt doesn't add any clarity anymore though so I nixed it.", "author": "jaycarlton", "createdAt": "2020-06-03T16:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNjEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwNzQ4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434207486", "bodyText": "The fully constructed username would be better here", "author": "jmthibault79", "createdAt": "2020-06-02T22:22:04Z", "path": "api/src/main/java/org/pmiops/workbench/api/ProfileController.java", "diffHunk": "@@ -871,10 +877,33 @@ private void updateBypass(long userId, AccessBypassRequest request) {\n     log.log(Level.WARNING, \"Deleting profile: user email: \" + user.getUsername());\n     directoryService.deleteUser(user.getUsername().split(\"@\")[0]);\n     userDao.delete(user.getUserId());\n-    profileAuditor.fireDeleteAction(\n-        user.getUserId(),\n-        user.getUsername()); // not sure if user profider will survive the next line\n+    profileAuditor.fireDeleteAction(user.getUserId(), user.getUsername());\n \n     return ResponseEntity.status(HttpStatus.NO_CONTENT).build();\n   }\n+\n+  @Override\n+  public ResponseEntity<UserAuditLogQueryResponse> getAuditLogEntries(\n+      String usernameWithoutGsuiteDomain,\n+      Integer limit,\n+      Long afterMillis,\n+      Long beforeMillisNullable) {\n+    final String username =\n+        String.format(\n+            \"%s@%s\",\n+            usernameWithoutGsuiteDomain,\n+            workbenchConfigProvider.get().googleDirectoryService.gSuiteDomain);\n+    final long userDatabaseId =\n+        Optional.ofNullable(userDao.findUserByUsername(username))\n+            .map(DbUser::getUserId)\n+            .orElseThrow(\n+                () ->\n+                    new NotFoundException(\n+                        String.format(\"User %s not found\", usernameWithoutGsuiteDomain)));", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwODYzMA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434208630", "bodyText": "update the comments in workbench-api.yaml to match the new name", "author": "jmthibault79", "createdAt": "2020-06-02T22:25:18Z", "path": "api/src/main/java/org/pmiops/workbench/workspaceadmin/WorkspaceAdminController.java", "diffHunk": "@@ -70,7 +70,7 @@ public WorkspaceAdminController(\n   }\n \n   @Override\n-  @AuthorityRequired({Authority.WORKSPACES_VIEW})", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwOTEwMQ==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434209101", "bodyText": "Please check our constellation of googledocs for references to this value.", "author": "jmthibault79", "createdAt": "2020-06-02T22:26:33Z", "path": "api/src/main/java/org/pmiops/workbench/db/model/DbStorageEnums.java", "diffHunk": "@@ -97,7 +97,7 @@ public static Short archivalStatusToStorage(ArchivalStatus s) {\n           .put(Authority.COMMUNICATIONS_ADMIN, (short) 4)\n           .put(Authority.SECURITY_ADMIN, (short) 5)\n           .put(Authority.INSTITUTION_ADMIN, (short) 6)\n-          .put(Authority.WORKSPACES_VIEW, (short) 7)", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5NjM4OA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434696388", "bodyText": "yes, that's an immediate post-merge activity.", "author": "jaycarlton", "createdAt": "2020-06-03T16:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIwOTEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyODc2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434228767", "bodyText": "what if these objects don't have a common ID or don't have a common event time?\nIt seems that this is an important assumption/requirement for your use case, so maybe it should be enforced along with the non-empty condition.", "author": "jmthibault79", "createdAt": "2020-06-02T23:27:25Z", "path": "api/src/main/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import com.google.cloud.bigquery.FieldValueList;\n+import com.google.cloud.bigquery.TableResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Streams;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.elasticsearch.common.Strings;\n+import org.mapstruct.Mapper;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTarget;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.pmiops.workbench.utils.FieldValues;\n+\n+@Mapper(config = MapStructConfig.class)\n+public interface AuditLogEntryMapper {\n+  AuditAgent logEntryToAgent(AuditLogEntry auditLogEntry);\n+\n+  default AuditEventBundleHeader logEntryToEventBundleHeader(AuditLogEntry auditLogEntry) {\n+    return new AuditEventBundleHeader()\n+        .target(logEntryToTarget(auditLogEntry))\n+        .agent(logEntryToAgent(auditLogEntry))\n+        .actionType(auditLogEntry.getActionType());\n+  }\n+\n+  AuditTarget logEntryToTarget(AuditLogEntry auditLogEntry);\n+\n+  /**\n+   * Build an AuditTargetPropertyChange object from the relevant fields in the AuditLogEntry, unless\n+   * all of those are null, in which case return an empty optional\n+   *\n+   * @param auditLogEntry\n+   * @return\n+   */\n+  default Optional<AuditTargetPropertyChange> logEntryToTargetPropertyChange(\n+      AuditLogEntry auditLogEntry) {\n+    if ((Strings.isNullOrEmpty(auditLogEntry.getTargetProperty())\n+            && Strings.isNullOrEmpty(auditLogEntry.getPreviousValue()))\n+        && Strings.isNullOrEmpty(auditLogEntry.getNewValue())) {\n+      return Optional.empty();\n+    } else {\n+      return Optional.of(\n+          new AuditTargetPropertyChange()\n+              .targetProperty(auditLogEntry.getTargetProperty())\n+              .previousValue(auditLogEntry.getPreviousValue())\n+              .newValue(auditLogEntry.getNewValue()));\n+    }\n+  }\n+\n+  default List<AuditAction> logEntriesToActions(List<AuditLogEntry> logEntries) {\n+    final Multimap<String, AuditLogEntry> actionIdToRows =\n+        Multimaps.index(logEntries, AuditLogEntry::getActionId);\n+    return actionIdToRows.asMap().values().stream()\n+        .map(this::buildAuditAction)\n+        .collect(ImmutableList.toImmutableList());\n+  }\n+\n+  /**\n+   * @param logEntries Collection of AuditLogEntry objectsthat have a common Action ID, which should", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzODQxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434238411", "bodyText": "oh it's cause you're grouping by action ID.  ok then.", "author": "jmthibault79", "createdAt": "2020-06-03T00:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyODc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY5NzY4MA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434697680", "bodyText": "I thought about doing that. Initially these were private methods, but then everything seemed to fit better on the mapper, but I don't believe it's possible to create a private helper method on a mapper.\nTechnically, they could have different event times due to an upstream bug, but I don't feel like it's appropriate to enforce that here. Maybe a cron to scan the BQ dataset now and then for sanity would suffice there.", "author": "jaycarlton", "createdAt": "2020-06-03T16:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyODc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTk3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434241975", "bodyText": "can also assert for this", "author": "jmthibault79", "createdAt": "2020-06-03T00:15:15Z", "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwMzg5Mg==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434703892", "bodyText": "I couldn't find which one is missing. (Not all fields are set, since some are irrelevant).", "author": "jaycarlton", "createdAt": "2020-06-03T16:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMDI2MA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434730260", "bodyText": "specifically I mean the actionType - the only one that appears to be missing here", "author": "jmthibault79", "createdAt": "2020-06-03T17:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxMTE2Mw==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434811163", "bodyText": "It's below.\nassertThat(header.getActionType()).isEqualTo(ACTION_TYPE_DELETE);\nIt doesn't line up because it's at the top level.", "author": "jaycarlton", "createdAt": "2020-06-03T19:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNzg4MA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434837880", "bodyText": "doh, thanks", "author": "jmthibault79", "createdAt": "2020-06-03T20:35:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MTk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MjU3Mg==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434242572", "bodyText": "could do map(::getPreviousValue).isEmpty() instead", "author": "jmthibault79", "createdAt": "2020-06-03T00:17:31Z", "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)\n+            .targetId(TARGET_ID)\n+            .targetType(TARGET_TYPE_WORKSPACE);\n+    final AuditEventBundleHeader header = auditLogEntryMapper.logEntryToEventBundleHeader(logEntry);\n+    assertThat(header.getActionType()).isEqualTo(ACTION_TYPE_DELETE);\n+    assertThat(header.getAgent().getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+    assertThat(header.getAgent().getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(header.getAgent().getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(header.getTarget().getTargetId()).isEqualTo(TARGET_ID);\n+    assertThat(header.getTarget().getTargetType()).isEqualTo(TARGET_TYPE_WORKSPACE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .targetProperty(TARGET_PROPERTY)\n+            .previousValue(PREVIOUS_VALUE)\n+            .newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getPreviousValue))\n+        .hasValue(PREVIOUS_VALUE);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(NEW_VALUE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_createdValue() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry().targetProperty(TARGET_PROPERTY).previousValue(null).newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.get().getPreviousValue()).isNull();", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwNDkwNA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434704904", "bodyText": "\ud83d\udcaf", "author": "jaycarlton", "createdAt": "2020-06-03T16:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0MjU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0Mjk0NA==", "url": "https://github.com/all-of-us/workbench/pull/3624#discussion_r434242944", "bodyText": "a test with multiple bundles would be good", "author": "jmthibault79", "createdAt": "2020-06-03T00:19:08Z", "path": "api/src/test/java/org/pmiops/workbench/utils/mappers/AuditLogEntryMapperTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package org.pmiops.workbench.utils.mappers;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth8.assertThat;\n+import static org.pmiops.workbench.actionaudit.auditors.ActionAuditTestConfig.ACTION_ID;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.Optional;\n+import org.joda.time.DateTime;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.model.AuditAction;\n+import org.pmiops.workbench.model.AuditAgent;\n+import org.pmiops.workbench.model.AuditEventBundle;\n+import org.pmiops.workbench.model.AuditEventBundleHeader;\n+import org.pmiops.workbench.model.AuditLogEntry;\n+import org.pmiops.workbench.model.AuditTargetPropertyChange;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class AuditLogEntryMapperTest {\n+\n+  public static final long AGENT_ID = 101L;\n+  public static final String USER_AGENT_TYPE = \"USER\";\n+  public static final String AGENT_USERNAME = \"paul@beatles.info\";\n+  public static final long TARGET_ID = 202L;\n+  public static final String ACTION_TYPE_DELETE = \"DELETE\";\n+  public static final String TARGET_TYPE_WORKSPACE = \"WORKSPACE\";\n+  public static final String TARGET_PROPERTY = \"title\";\n+  public static final String PREVIOUS_VALUE = \"District 5\";\n+  public static final String NEW_VALUE = \"The Mighty Ducks\";\n+  public static final String LOGIN_ACTION_TYPE = \"LOGIN\";\n+  public static final DateTime EVENT_TIME = new DateTime(1579013840545L);\n+  public static final String WORKBENCH_TARGET_TYPE = \"WORKBENCH\";\n+  @Autowired private AuditLogEntryMapper auditLogEntryMapper;\n+\n+  @TestConfiguration\n+  @Import({AuditLogEntryMapperImpl.class})\n+  public static class Config {}\n+\n+  @Test\n+  public void testLogEntryToAgent() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .actionType(\"CREATE\")\n+            .agentId(AGENT_ID)\n+            .agentType(USER_AGENT_TYPE)\n+            .agentUsername(AGENT_USERNAME);\n+    final AuditAgent auditAgent = auditLogEntryMapper.logEntryToAgent(logEntry);\n+    assertThat(auditAgent.getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(auditAgent.getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(auditAgent.getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+  }\n+\n+  @Test\n+  public void testLogEntryToEventBundleHeader() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .agentId(AGENT_ID)\n+            .agentUsername(AGENT_USERNAME)\n+            .agentType(USER_AGENT_TYPE)\n+            .actionType(ACTION_TYPE_DELETE)\n+            .targetId(TARGET_ID)\n+            .targetType(TARGET_TYPE_WORKSPACE);\n+    final AuditEventBundleHeader header = auditLogEntryMapper.logEntryToEventBundleHeader(logEntry);\n+    assertThat(header.getActionType()).isEqualTo(ACTION_TYPE_DELETE);\n+    assertThat(header.getAgent().getAgentUsername()).isEqualTo(AGENT_USERNAME);\n+    assertThat(header.getAgent().getAgentType()).isEqualTo(USER_AGENT_TYPE);\n+    assertThat(header.getAgent().getAgentId()).isEqualTo(AGENT_ID);\n+    assertThat(header.getTarget().getTargetId()).isEqualTo(TARGET_ID);\n+    assertThat(header.getTarget().getTargetType()).isEqualTo(TARGET_TYPE_WORKSPACE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry()\n+            .targetProperty(TARGET_PROPERTY)\n+            .previousValue(PREVIOUS_VALUE)\n+            .newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getPreviousValue))\n+        .hasValue(PREVIOUS_VALUE);\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(NEW_VALUE);\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_createdValue() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry().targetProperty(TARGET_PROPERTY).previousValue(null).newValue(NEW_VALUE);\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.get().getPreviousValue()).isNull();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(NEW_VALUE);\n+  }\n+\n+  /**\n+   * At the moment, and historically, we write empty stings to the audit stream for things like\n+   * workspace properties (when empty). Make sure they propagate, unless/until we tighten things\n+   * upstream.\n+   */\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_toleratesEmptyString() {\n+    final AuditLogEntry logEntry =\n+        new AuditLogEntry().targetProperty(TARGET_PROPERTY).previousValue(null).newValue(\"\");\n+    final Optional<AuditTargetPropertyChange> propertyMaybe =\n+        auditLogEntryMapper.logEntryToTargetPropertyChange(logEntry);\n+    assertThat(propertyMaybe).isPresent();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getTargetProperty))\n+        .hasValue(TARGET_PROPERTY);\n+    assertThat(propertyMaybe.get().getPreviousValue()).isNull();\n+    assertThat(propertyMaybe.map(AuditTargetPropertyChange::getNewValue)).hasValue(\"\");\n+  }\n+\n+  @Test\n+  public void testLogEntryToTargetPropertyChange_emptyIfNoProperty() {\n+    assertThat(auditLogEntryMapper.logEntryToTargetPropertyChange(new AuditLogEntry())).isEmpty();\n+  }\n+\n+  @Test\n+  public void testBuildAuditAction_loginAction() {\n+    final AuditAction auditAction =\n+        auditLogEntryMapper.buildAuditAction(\n+            ImmutableList.of(\n+                new AuditLogEntry()\n+                    .actionId(ACTION_ID)\n+                    .actionType(LOGIN_ACTION_TYPE)\n+                    .agentId(AGENT_ID)\n+                    .agentType(USER_AGENT_TYPE)\n+                    .agentUsername(AGENT_USERNAME)\n+                    .eventTime(EVENT_TIME)\n+                    .newValue(null)\n+                    .previousValue(null)\n+                    .targetId(null)\n+                    .targetProperty(null)\n+                    .targetType(WORKBENCH_TARGET_TYPE)));\n+    assertThat(auditAction.getActionId()).isEqualTo(ACTION_ID);\n+    assertThat(auditAction.getActionTime()).isEqualTo(EVENT_TIME);\n+\n+    assertThat(auditAction.getEventBundles()).hasSize(1);", "originalCommit": "a91b0bb22fd4a4a8a722f671a859a7da685ca8dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "084ad619010bc3baf58a1c10db6a65f0f38aea94", "url": "https://github.com/all-of-us/workbench/commit/084ad619010bc3baf58a1c10db6a65f0f38aea94", "message": "Merge branch 'master' into jaycarlton/userQueryApi", "committedDate": "2020-06-03T16:16:02Z", "type": "commit"}, {"oid": "e5ed5f6cba4000a30307b91552af8a6abc4ec6bc", "url": "https://github.com/all-of-us/workbench/commit/e5ed5f6cba4000a30307b91552af8a6abc4ec6bc", "message": "consolidate query strings", "committedDate": "2020-06-03T16:50:52Z", "type": "commit"}, {"oid": "89b75ce6f0f25620ed37cbba6cc6a440fe3ac266", "url": "https://github.com/all-of-us/workbench/commit/89b75ce6f0f25620ed37cbba6cc6a440fe3ac266", "message": "new tests", "committedDate": "2020-06-03T20:30:52Z", "type": "commit"}]}