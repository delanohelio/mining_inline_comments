{"pr_number": 3160, "pr_title": "[RW-4464][risk=low] Plumb proper agent details to audit system", "pr_createdAt": "2020-02-20T02:59:36Z", "pr_url": "https://github.com/all-of-us/workbench/pull/3160", "timeline": [{"oid": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "url": "https://github.com/all-of-us/workbench/commit/2fc92ba2aadb6e277625c2ba6050b74205e880cc", "message": "Try test, verification not working.... Kotlin?", "committedDate": "2020-02-20T03:00:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMzEwNQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382003105", "bodyText": "Maybe pull this preamble into its own helper, unless you're sure none of the other methods need to do this.", "author": "jaycarlton", "createdAt": "2020-02-20T13:39:39Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -39,13 +42,29 @@ public UserServiceAuditAdapterImpl(\n \n   @Override\n   public void fireUpdateDataAccessAction(\n-      DbUser targetUser, DataAccessLevel dataAccessLevel, DataAccessLevel previousDataAccessLevel) {\n+      DbUser targetUser,\n+      DataAccessLevel dataAccessLevel,\n+      DataAccessLevel previousDataAccessLevel,\n+      AgentType agentType) {\n+    // In the event of an offline cronjob, the request may have been made anonymously and there is", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTU4MQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382295581", "bodyText": "They don't currently. I think this is a symptom of this method being too heavily overloaded so I'd rather leave the wart here than bless it in a utility class.", "author": "calbach", "createdAt": "2020-02-20T22:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMzEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDM0MQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382004341", "bodyText": "nit: typically the pattern I use with optionals adn builders is\nagent.ifPresent(eventBuilder::agentEmailMaybe). Downside is you have to declare the builder.", "author": "jaycarlton", "createdAt": "2020-02-20T13:41:52Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -39,13 +42,29 @@ public UserServiceAuditAdapterImpl(\n \n   @Override\n   public void fireUpdateDataAccessAction(\n-      DbUser targetUser, DataAccessLevel dataAccessLevel, DataAccessLevel previousDataAccessLevel) {\n+      DbUser targetUser,\n+      DataAccessLevel dataAccessLevel,\n+      DataAccessLevel previousDataAccessLevel,\n+      AgentType agentType) {\n+    // In the event of an offline cronjob, the request may have been made anonymously and there is\n+    // no user identity. This should only happen for system agent driven audit events.\n+    Optional<DbUser> agent = Optional.ofNullable(dbUserProvider.get());\n+    if (agent.isPresent() && AgentType.SYSTEM == agentType) {\n+      log.warning(\n+          String.format(\n+              \"found unexpected request scope user '%s' for SYSTEM agent audit action\",\n+              agent.get().getUsername()));\n+    } else if (!agent.isPresent() && AgentType.SYSTEM != agentType) {\n+      log.warning(\n+          String.format(\"missing request scope user for audit action agent type of %s\", agentType));\n+    }\n+\n     actionAuditService.send(\n         ActionAuditEvent.builder()\n             .timestamp(clock.millis())\n-            .agentType(AgentType.ADMINISTRATOR)\n-            .agentId(dbUserProvider.get().getUserId())\n-            .agentEmailMaybe(dbUserProvider.get().getUsername())\n+            .agentType(agentType)\n+            .agentId(agent.map(DbUser::getUserId).orElse(0L))\n+            .agentEmailMaybe(agent.map(DbUser::getUsername).orElse(null))", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5MzUyOQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382293529", "bodyText": "That's neat, didn't know about that method. In this case I think I prefer how it's currently written though.", "author": "calbach", "createdAt": "2020-02-20T22:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDk3MA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382004970", "bodyText": "So if we had a cron that happened to set this bypass time for some reason,  we'd. have to fix this one too.", "author": "jaycarlton", "createdAt": "2020-02-20T13:42:55Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -61,12 +80,13 @@ public void fireAdministrativeBypassTime(\n       long userId,\n       BypassTimeTargetProperty bypassTimeTargetProperty,\n       Optional<Instant> bypassTime) {\n+    DbUser adminUser = dbUserProvider.get();", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2OTgzMw==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382169833", "bodyText": "Bypasses are done by an administrator by definition. I don't think it's a valid concern here.", "author": "calbach", "createdAt": "2020-02-20T18:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MzgxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382763815", "bodyText": "Not likely in the short term I guess, but there's nothing baked in to prevent that, right? Like if we needed to do a batch access change because we added or removed an access level.\nNot worth worrying about right now.", "author": "jaycarlton", "createdAt": "2020-02-21T19:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTk5MQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382005991", "bodyText": "Ideally we could keep the footprint smaller, so that callers don't need to know anything about the audit system. Would injecting the class @gjuggler mentioned help here? Could come later.", "author": "jaycarlton", "createdAt": "2020-02-20T13:44:39Z", "path": "api/src/main/java/org/pmiops/workbench/api/OfflineUserController.java", "diffHunk": "@@ -74,9 +75,9 @@ private boolean timestampsEqual(Timestamp a, Timestamp b) {\n \n         DbUser updatedUser;\n         if (workbenchConfigProvider.get().featureFlags.enableMoodleV2Api) {\n-          updatedUser = userService.syncComplianceTrainingStatusV2(user);\n+          updatedUser = userService.syncComplianceTrainingStatusV2(user, AgentType.SYSTEM);", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTE5NQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382295195", "bodyText": "Without a bigger refactoring of UserService, the best I can do here is the following:\nsyncComplianceTrainingStatusV2 ->\nsyncComplianceTrainingStatusAsCurrentUserV2()\nsyncComplianceTrainingStatusAsSystemV2()\n\nI'm not sure this is much better.\nInformation about the actor needs to originate from the callsite, since UserService is currently overloaded with calls from various actors. I think architecturally we need to draw a line where request scoped information is attenuated in order to clean this up.", "author": "calbach", "createdAt": "2020-02-20T22:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYxODQ0MQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382618441", "bodyText": "OK. What would you. think about a small value class with the agent type, agent ID, and (optional) agent email builtin? That might save some lookups later on and ensure we don't accidentally pair a system agent with an email or invalid ID.", "author": "jaycarlton", "createdAt": "2020-02-21T14:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0MDA0Mw==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382640043", "bodyText": "Would you mind going ahead and filing a spike ticket for this question and the design sketch you mentioned about RequestAuthenticationInfo? I agree it's not a short term priority.", "author": "jaycarlton", "createdAt": "2020-02-21T15:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1NDU4Ng==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382754586", "bodyText": "Switched to passing a small value class. This eliminates the need for the Optional stuff entirely.\nSpike is https://precisionmedicineinitiative.atlassian.net/browse/RW-4496", "author": "calbach", "createdAt": "2020-02-21T19:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNTk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzQ3MA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382007470", "bodyText": "I really think null beans are an anti-pattern. I expect them to be there when they're injected, but maybe i've just. been naive. If we do. need this, then I recommend moving to OptionalProvider, so it's. obvious.\nCan we not make UserAuthentication. and Userinfoplus a bit smarter so they don't have to be. null?", "author": "jaycarlton", "createdAt": "2020-02-20T13:47:03Z", "path": "api/src/main/java/org/pmiops/workbench/config/WebMvcConfig.java", "diffHunk": "@@ -48,18 +49,28 @@\n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public UserAuthentication userAuthentication() {\n-    return (UserAuthentication) SecurityContextHolder.getContext().getAuthentication();\n+    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n+    if (auth == null) {\n+      return null;", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3MTI4NA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382171284", "bodyText": "With more fiddling, I determined that Provider<Optional<Foo>> does actually work. If Foo is null, it's treated as not being bound.\nThis pattern also isn't something I think we should encourage, because I could actually get the binding type completely wrong, and Spring wouldn't complain, (e.g. add @Qualifier(\"asdf\") and it still returns an empty optional).\nThe ideal fix here probably warrants a brief design sketch which is why I'm punting on it for now, but a smarter UserAuthentication, something like RequestAuthenticationInfo, with getOptionalUser(), isAuthenticated() etc could potentially work.", "author": "calbach", "createdAt": "2020-02-20T18:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYyMDE3NQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382620175", "bodyText": "I agree. My favorite solution is a class like RequestAuthenticationInfo because\n\nThe injectee itself is never null or empty\nIt's obvious when I declare a Provider<RequestAuthenticationInfo> that more than one request context needs to be supported\nIt can be adopted incrementally instead of as a Big Bang refactoring.\n\nThe point on failed binding is well taken, though I think on balance I much prefer that risk to allowing injected nulls.", "author": "jaycarlton", "createdAt": "2020-02-21T14:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzgzMQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382007831", "bodyText": "Could we make a fake DbUser instance to represent the system?", "author": "jaycarlton", "createdAt": "2020-02-20T13:47:41Z", "path": "api/src/main/java/org/pmiops/workbench/config/WebMvcConfig.java", "diffHunk": "@@ -48,18 +49,28 @@\n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public UserAuthentication userAuthentication() {\n-    return (UserAuthentication) SecurityContextHolder.getContext().getAuthentication();\n+    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n+    if (auth == null) {\n+      return null;\n+    }\n+    return (UserAuthentication) auth;\n   }\n \n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public Userinfoplus userInfo(UserAuthentication userAuthentication) {\n+    if (userAuthentication == null) {\n+      return null;\n+    }\n     return userAuthentication.getPrincipal();\n   }\n \n   @Bean\n   @RequestScope(proxyMode = ScopedProxyMode.DEFAULT)\n   public DbUser user(UserAuthentication userAuthentication) {\n+    if (userAuthentication == null) {\n+      return null;", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4ODgxOQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382088819", "bodyText": "Also, if we go with this approach, it would help to mark both userAuthentication and the method itself with @Nullable.", "author": "jaycarlton", "createdAt": "2020-02-20T15:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MzMyNQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382193325", "bodyText": "Binding a fake DbUser doesn't seem correct to me. Semantically this bean represents \"the user identity associated with the current request\". If the request has been made anonymously, there is no user identity associated with the current request.\nPer other comment, I've updated this to use Optional instead. Unfortunately I cannot make the return type optional as well, just returning null appears to work.", "author": "calbach", "createdAt": "2020-02-20T18:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYzMTA0OA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382631048", "bodyText": "I might make more of a case for it if we were just beginning to define the notion of users and sessions, but in any case I think it's too late in the game to shoehorn one in. It would have the nice property of avoiding refactoring any injection sites, though.", "author": "jaycarlton", "createdAt": "2020-02-21T15:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNzgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwODUxNw==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382008517", "bodyText": "Oh, interesting. So there are up to 3 valid values for agent type.", "author": "jaycarlton", "createdAt": "2020-02-20T13:48:52Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserServiceImpl.java", "diffHunk": "@@ -842,12 +851,12 @@ public DbUser syncEraCommonsStatusUsingImpersonation(DbUser user)\n \n   @Override\n   public void syncTwoFactorAuthStatus() {\n-    syncTwoFactorAuthStatus(userProvider.get());\n+    syncTwoFactorAuthStatus(userProvider.get(), AgentType.USER);", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMDM3MA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382010370", "bodyText": "If this isn't working, it might be due to an incompatibility in some of the Mockito stuff. Things like captors return null when the mockito contract requires non-null. There are some examples in the kotlin test files\n    @Test\n    fun testDeleteUserProfile() {\n        profileAuditAdapter!!.fireDeleteAction(USER_ID, USER_EMAIL)\n        argumentCaptor<ActionAuditEvent>().apply {\n            verify(mockActionAuditService).send(capture())\n            val eventSent = firstValue\n\n            assertThat(eventSent.targetType).isEqualTo(TargetType.PROFILE)\n            assertThat(eventSent.agentType).isEqualTo(AgentType.USER)\n            assertThat(eventSent.agentId).isEqualTo(USER_ID)\n            assertThat(eventSent.targetIdMaybe).isEqualTo(USER_ID)\n            assertThat(eventSent.actionType).isEqualTo(ActionType.DELETE)\n//...\n\nBut this would be the first time we've had this problem in Java AFAIK. Does this work with standard matchers or captors?\n@ericsong thoughts?", "author": "jaycarlton", "createdAt": "2020-02-20T13:52:08Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditorTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.verify;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.model.DataAccessLevel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Primary;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class UserServiceAuditorTest {\n+  static DbUser USER = null;\n+\n+  @TestConfiguration\n+  @Import({UserServiceAuditAdapterImpl.class, ActionAuditTestConfig.class})\n+  @MockBean(ActionAuditService.class)\n+  static class Configuration {\n+    @Primary\n+    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n+    public DbUser getUser() {\n+      return USER;\n+    }\n+  }\n+\n+  @Autowired UserServiceAuditor userServiceAuditor;\n+  @Autowired ActionAuditService mockActionAuditService;\n+\n+  @After\n+  public void tearDown() {\n+    USER = null;\n+  }\n+\n+  private static DbUser createUser() {\n+    final DbUser user = new DbUser();\n+    user.setUserId(3L);\n+    user.setUsername(\"foo@gmail.com\");\n+    return user;\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_userAgent() {\n+    USER = createUser();\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        USER, DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, AgentType.USER);\n+    verify(mockActionAuditService)", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5Nzk2Nw==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382297967", "bodyText": "SOrry for the noise. In reality, my tests were correctly failing - but the error messaging was highly misleading. The arg matchers were working as intended.", "author": "calbach", "createdAt": "2020-02-20T22:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMDM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMTAwMQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382011001", "bodyText": "nit: prefer the tightest match, e.g. any(AgentType.class), anyString(), etc. This helps avoid false positives when overloads come into play.", "author": "jaycarlton", "createdAt": "2020-02-20T13:53:14Z", "path": "api/src/test/java/org/pmiops/workbench/api/OfflineUserControllerTest.java", "diffHunk": "@@ -83,69 +83,73 @@ public void testBulkSyncTrainingStatusV1()\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException {\n     workbenchConfig.featureFlags.enableMoodleV2Api = false;\n     // Mock out the service under test to simply return the passed user argument.\n-    doAnswer(i -> i.getArgument(0)).when(userService).syncComplianceTrainingStatusV1(any());\n+    doAnswer(i -> i.getArgument(0)).when(userService).syncComplianceTrainingStatusV1(any(), any());", "originalCommit": "2fc92ba2aadb6e277625c2ba6050b74205e880cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE3MjEwNA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382172104", "bodyText": "If we decide that's a convention we want to follow, I can make a separate PR but I'm not going to refactor this whole test case (or more correctly - probably the whole codebase) within the scope of this PR.\nI'm also not sure I agree it matters in this case, though I could see an argument for applying this as a codebase convention / consistency rule if I see enough evidence in other cases. For a false positive to happen here, the method overloads would need to have such divergent semantics that it invalidates this test - that probably indicates the service is not well designed - if we take the assumption that the overload has equivalent semantics, by using any() we're just ignoring implementation details (parameter types) that the test doesn't care about - which is a good thing.\nIf you're aware of a style guide which supports \"prefer tightest match\", I'd be curious to read it.", "author": "calbach", "createdAt": "2020-02-20T18:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMTAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYzNjgxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382636811", "bodyText": "I mainly learned it by repeated wrist slaps at my former employer, and I'm perpetuating the cycle of abuse here.\nSeriously, though, my thoughts are\n\nany() works everywhere, so why did they bother adding anyString(), anyLong(), any(MyClass.class)?\nit helps with readability if I can see the type. Frequently that helps me understand the method signature a bit better when I read the test so I don't have to look it up.\na false positive would be rare, but also very difficult to catch. I prefer verifying a tightly scoped & defined method.\n\nHere are a couple of refs that show the strict forms but not the loose ones:\n\nhttps://www.journaldev.com/21876/mockito-argument-matchers-any-eq\nhttps://www.toptal.com/java/a-guide-to-everyday-mockito\nhttps://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/ArgumentMatchers.html", "author": "jaycarlton", "createdAt": "2020-02-21T15:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMTAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1ODI1Ng==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382758256", "bodyText": "In the case of an ambiguous overload, the compiler will actually just fail. I'm not sure it's difficult to catch at all. Certainly there are scenarios where you'd need typed parameters to distinguish these different calls, which is enough of a reason for them to exist.\nThe documentation is maybe nice for some, but that seems subjective and comes at the price of needing to keep those types in sync. I'd say that's a wash or net negative in my mind.\nThe only other argument I can produce right now is that if someone comes along and adds a new method override, that might cause a compilation failure in existing tests which use any().", "author": "calbach", "createdAt": "2020-02-21T19:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAxMTAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjYzNzgxMQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382637811", "bodyText": "Can you please have a block for unhandled agent types? (A switch may be better actually)", "author": "jaycarlton", "createdAt": "2020-02-21T15:17:35Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -20,32 +21,50 @@\n @Service\n public class UserServiceAuditAdapterImpl implements UserServiceAuditor {\n \n+  private static final Logger log = Logger.getLogger(UserServiceAuditAdapterImpl.class.getName());\n+\n   private final ActionAuditService actionAuditService;\n   private final Clock clock;\n-  private Provider<DbUser> dbUserProvider;\n   private Provider<String> actionIdProvider;\n+  private Provider<Optional<DbUser>> dbUserOptionalProvider;\n \n   @Autowired\n   public UserServiceAuditAdapterImpl(\n       ActionAuditService actionAuditService,\n       Clock clock,\n-      Provider<DbUser> dbUserProvider,\n-      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider) {\n+      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider,\n+      Provider<Optional<DbUser>> dbUserOptionalProvider) {\n     this.actionAuditService = actionAuditService;\n     this.clock = clock;\n-    this.dbUserProvider = dbUserProvider;\n     this.actionIdProvider = actionIdProvider;\n+    this.dbUserOptionalProvider = dbUserOptionalProvider;\n   }\n \n   @Override\n   public void fireUpdateDataAccessAction(\n-      DbUser targetUser, DataAccessLevel dataAccessLevel, DataAccessLevel previousDataAccessLevel) {\n+      DbUser targetUser,\n+      DataAccessLevel dataAccessLevel,\n+      DataAccessLevel previousDataAccessLevel,\n+      AgentType agentType) {\n+    // In the event of an offline cronjob, the request may have been made anonymously and there is\n+    // no user identity. This should only happen for system agent driven audit events.\n+    Optional<DbUser> agent = dbUserOptionalProvider.get();\n+    if (agent.isPresent() && AgentType.SYSTEM == agentType) {\n+      log.warning(\n+          String.format(\n+              \"found unexpected request scope user '%s' for SYSTEM agent audit action\",\n+              agent.get().getUsername()));\n+    } else if (!agent.isPresent() && AgentType.SYSTEM != agentType) {\n+      log.warning(\n+          String.format(\"missing request scope user for audit action agent type of %s\", agentType));\n+    }\n+", "originalCommit": "1fe26e6835dc272c67497054e7e20805edd770cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0MzEyMQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382643121", "bodyText": "This is interesting. It's a bit strange at first, but looks a bit cleaner than using an ArgumentCaptor. Though in the latter case you can write separate assertions on the thing passed in, whereas here I suppose it's up to Mockito to format the error information.", "author": "jaycarlton", "createdAt": "2020-02-21T15:26:58Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditorTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Mockito.verify;\n+\n+import java.time.Clock;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.model.DataAccessLevel;\n+import org.pmiops.workbench.test.FakeClock;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.config.ConfigurableBeanFactory;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class UserServiceAuditorTest {\n+  static DbUser USER = null;\n+\n+  @TestConfiguration\n+  @Import({UserServiceAuditAdapterImpl.class})\n+  @MockBean(ActionAuditService.class)\n+  static class Configuration {\n+    @Bean\n+    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n+    public DbUser getUser() {\n+      return USER;\n+    }\n+\n+    @Bean(name = \"ACTION_ID\")\n+    public String getActionId() {\n+      return ActionAuditTestConfig.ACTION_ID;\n+    }\n+\n+    @Bean\n+    public Clock getClock() {\n+      return new FakeClock(ActionAuditTestConfig.INSTANT);\n+    }\n+  }\n+\n+  @Autowired UserServiceAuditor userServiceAuditor;\n+  @Autowired ActionAuditService mockActionAuditService;\n+\n+  @After\n+  public void tearDown() {\n+    USER = null;\n+  }\n+\n+  private static DbUser createUser() {\n+    final DbUser user = new DbUser();\n+    user.setUserId(3L);\n+    user.setUsername(\"foo@gmail.com\");\n+    return user;\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_userAgent() {\n+    USER = createUser();\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        USER, DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, AgentType.USER);\n+    verify(mockActionAuditService)\n+        .send(\n+            argThat(\n+                (ActionAuditEvent a) ->\n+                    a.getAgentId() == USER.getUserId()\n+                        && USER.getUsername().equals(a.getAgentEmailMaybe())\n+                        && a.getAgentType() == AgentType.USER));\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_systemAgent() {\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        createUser(), DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, AgentType.SYSTEM);\n+    verify(mockActionAuditService)\n+        .send(\n+            argThat(", "originalCommit": "1fe26e6835dc272c67497054e7e20805edd770cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1OTMxNg==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382759316", "bodyText": "Agreed, I switched to captor since the failure messaging was so poor here.", "author": "calbach", "createdAt": "2020-02-21T19:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY0MzEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MjE0OQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382762149", "bodyText": "How do you determine the preferred argument order?", "author": "jaycarlton", "createdAt": "2020-02-21T19:23:44Z", "path": "api/src/main/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditAdapterImpl.java", "diffHunk": "@@ -20,32 +22,37 @@\n @Service\n public class UserServiceAuditAdapterImpl implements UserServiceAuditor {\n \n+  private static final Logger log = Logger.getLogger(UserServiceAuditAdapterImpl.class.getName());\n+\n   private final ActionAuditService actionAuditService;\n   private final Clock clock;\n-  private Provider<DbUser> dbUserProvider;\n   private Provider<String> actionIdProvider;\n+  private Provider<DbUser> dbUserProvider;\n \n   @Autowired\n   public UserServiceAuditAdapterImpl(\n       ActionAuditService actionAuditService,\n       Clock clock,\n-      Provider<DbUser> dbUserProvider,\n-      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider) {\n+      @Qualifier(\"ACTION_ID\") Provider<String> actionIdProvider,", "originalCommit": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3Njg5OA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382776898", "bodyText": "Reverted. I changed this when I made userProvider optional. In my view, required arguments should generally come first.", "author": "calbach", "createdAt": "2020-02-21T19:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2MjE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2OTQ5MQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382769491", "bodyText": "This is much cleaner, thanks.\nOnly thing that would be neater would be to inject the agent somehow, but I'm guessing that's not trivial because of threading and auth concerns.", "author": "jaycarlton", "createdAt": "2020-02-21T19:39:36Z", "path": "api/src/main/java/org/pmiops/workbench/db/dao/UserService.java", "diffHunk": "@@ -71,21 +72,21 @@ DbUser syncComplianceTrainingStatusV1()\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException;\n \n   @Deprecated\n-  DbUser syncComplianceTrainingStatusV1(DbUser user)\n+  DbUser syncComplianceTrainingStatusV1(DbUser user, Agent agent)\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException;\n \n   DbUser syncComplianceTrainingStatusV2()\n       throws org.pmiops.workbench.moodle.ApiException, NotFoundException;\n \n-  DbUser syncComplianceTrainingStatusV2(DbUser user)\n+  DbUser syncComplianceTrainingStatusV2(DbUser user, Agent agent)", "originalCommit": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3OTY1MA==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382779650", "bodyText": "It's not trivial because it depends on service-level business logic. There is nothing inherent to a user identity which tells us whether they are acting as an admin or a user. Possibly this is something we could bind in an interceptor, based on what method is being called, but being explicit in controller methods is probably fine for now..", "author": "calbach", "createdAt": "2020-02-21T20:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc2OTQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc3MDQxNQ==", "url": "https://github.com/all-of-us/workbench/pull/3160#discussion_r382770415", "bodyText": "aside: I wonder if it's worth changing agentEmail to agentUsername everywhere (except in what's sent to Stackdriver). For another day.", "author": "jaycarlton", "createdAt": "2020-02-21T19:41:39Z", "path": "api/src/test/java/org/pmiops/workbench/actionaudit/auditors/UserServiceAuditorTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.pmiops.workbench.actionaudit.auditors;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.pmiops.workbench.actionaudit.ActionAuditEvent;\n+import org.pmiops.workbench.actionaudit.ActionAuditService;\n+import org.pmiops.workbench.actionaudit.Agent;\n+import org.pmiops.workbench.actionaudit.AgentType;\n+import org.pmiops.workbench.db.model.DbUser;\n+import org.pmiops.workbench.model.DataAccessLevel;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.context.TestConfiguration;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Import;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+@RunWith(SpringRunner.class)\n+public class UserServiceAuditorTest {\n+  @TestConfiguration\n+  @Import({UserServiceAuditAdapterImpl.class, ActionAuditTestConfig.class})\n+  @MockBean(ActionAuditService.class)\n+  static class Configuration {}\n+\n+  @Captor ArgumentCaptor<ActionAuditEvent> eventArg;\n+\n+  @Autowired UserServiceAuditor userServiceAuditor;\n+  @Autowired ActionAuditService mockActionAuditService;\n+\n+  private static DbUser createUser() {\n+    final DbUser user = new DbUser();\n+    user.setUserId(3L);\n+    user.setUsername(\"foo@gmail.com\");\n+    return user;\n+  }\n+\n+  @Test\n+  public void testFireUpdateDataAccessAction_userAgent() {\n+    DbUser user = createUser();\n+    userServiceAuditor.fireUpdateDataAccessAction(\n+        user, DataAccessLevel.UNREGISTERED, DataAccessLevel.REGISTERED, Agent.asUser(user));\n+    verify(mockActionAuditService).send(eventArg.capture());\n+\n+    ActionAuditEvent event = eventArg.getValue();\n+    assertThat(event.getAgentType()).isEqualTo(AgentType.USER);\n+    assertThat(event.getAgentIdMaybe()).isEqualTo(user.getUserId());\n+    assertThat(event.getAgentEmailMaybe()).isEqualTo(user.getUsername());", "originalCommit": "515a75d02c79ef56e9519ae02e1cc8fa5605cf8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7965f7ec1050bbcb0721784d89720397df162730", "url": "https://github.com/all-of-us/workbench/commit/7965f7ec1050bbcb0721784d89720397df162730", "message": "Plumb proper agent type, nullable user", "committedDate": "2020-02-21T21:58:48Z", "type": "commit"}, {"oid": "8650c6b0656ebc51d29a5646e11d2bd297c0ad4a", "url": "https://github.com/all-of-us/workbench/commit/8650c6b0656ebc51d29a5646e11d2bd297c0ad4a", "message": "Try test, verification not working.... Kotlin?", "committedDate": "2020-02-21T21:58:48Z", "type": "commit"}, {"oid": "a117b67b36207496e56d28afd1964dd1a27abbfe", "url": "https://github.com/all-of-us/workbench/commit/a117b67b36207496e56d28afd1964dd1a27abbfe", "message": "PR fixes", "committedDate": "2020-02-21T21:58:48Z", "type": "commit"}, {"oid": "06d4d9056bc3c61145a44794d4b8277bca6d3b69", "url": "https://github.com/all-of-us/workbench/commit/06d4d9056bc3c61145a44794d4b8277bca6d3b69", "message": "Refactor agent and optional agent id", "committedDate": "2020-02-21T21:58:48Z", "type": "commit"}, {"oid": "386f5dd4e21c55a6ad588c047f8a98feb8061835", "url": "https://github.com/all-of-us/workbench/commit/386f5dd4e21c55a6ad588c047f8a98feb8061835", "message": "PR feedback", "committedDate": "2020-02-21T21:58:48Z", "type": "commit"}, {"oid": "386f5dd4e21c55a6ad588c047f8a98feb8061835", "url": "https://github.com/all-of-us/workbench/commit/386f5dd4e21c55a6ad588c047f8a98feb8061835", "message": "PR feedback", "committedDate": "2020-02-21T21:58:48Z", "type": "forcePushed"}]}