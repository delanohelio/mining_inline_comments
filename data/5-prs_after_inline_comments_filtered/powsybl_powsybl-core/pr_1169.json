{"pr_number": 1169, "pr_title": "SecurityAnalysisImpl multithread fixes alternative implementations", "pr_createdAt": "2020-02-19T17:54:07Z", "pr_url": "https://github.com/powsybl/powsybl-core/pull/1169", "timeline": [{"oid": "0776bc31f3342b9a0f01a14675d503495bdfaeb6", "url": "https://github.com/powsybl/powsybl-core/commit/0776bc31f3342b9a0f01a14675d503495bdfaeb6", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-19T18:29:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTcyMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381839721", "bodyText": "I think sonar cognitive complexity analyzer must be crying :)\nIt was already the case before the PR, but I think we should stick to the rule that lambda should be as much as possible one-liners, in particular for complex, asynchronous code.\nI think we should simply create more functions here.", "author": "sylvlecl", "createdAt": "2020-02-20T08:12:18Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture", "originalCommit": "0776bc31f3342b9a0f01a14675d503495bdfaeb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MTIwNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382151204", "bodyText": "Yes, we should. I didn't refactor to allow to compare to the previous version. If we decide to go this way, we should refactor", "author": "jonenst", "createdAt": "2020-02-20T17:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzOTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NjI1Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381856252", "bodyText": "Might look less weird to have a supplyAsync return the array of future chained with a .thenCompose(CompletableFuture::allOf).whenComplete(... ?", "author": "sylvlecl", "createdAt": "2020-02-20T08:48:23Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {", "originalCommit": "0776bc31f3342b9a0f01a14675d503495bdfaeb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MTg2MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382151860", "bodyText": "yes, I refrained from refactoring as much as I could to keep the code comparable to the previous code", "author": "jonenst", "createdAt": "2020-02-20T17:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NjI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NjYyOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381876628", "bodyText": "Here we should clone the workingStateId used for pre contingency computation.", "author": "sylvlecl", "createdAt": "2020-02-20T09:25:59Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);", "originalCommit": "0776bc31f3342b9a0f01a14675d503495bdfaeb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MjMxMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382152313", "bodyText": "Yes, I didn't change the original behavior in the first proposal because it was not related. It's now included", "author": "jonenst", "createdAt": "2020-02-20T17:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NzQ4Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r381877483", "bodyText": "agreed with @mathbagu : Here we should clone the variant used for pre contingency computation, in order to restore the \"N\" situation before applying the contingency.", "author": "sylvlecl", "createdAt": "2020-02-20T09:27:24Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -88,48 +89,76 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n \n                         List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n \n-                        futures = new CompletableFuture[contingencies.size()];\n-\n                         String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n-\n-                            String postContStateId = hash + \"_\" + contingency.getId();\n-\n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n-\n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n-\n-                                        return null;\n-                                    }, computationManager.getExecutor());\n+                        int workerCount = Math.min(computationManager.getResourcesStatus().getAvailableCores(), contingencies.size());\n+                        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(workerCount);\n+                        for (int i = 0; i < workerCount; i++) {\n+                            String postContStateId = hash + \"_\" + i;\n+                            network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n+                            queue.add(i); //Will always work because we are initializing the queue and the initial capacity is workerCount\n                         }\n+                        // use completedFuture(null).thenCompose so that more of the\n+                        // execution is handled by the whenComplete block removing the\n+                        // variants.\n+                        future = CompletableFuture.completedFuture(null).thenComposeAsync(aVoid -> {\n+                            boolean previousMultiThreadAcces = network.getVariantManager().isVariantMultiThreadAccessAllowed();\n+                            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+                            CompletableFuture<Void>[] futures = new CompletableFuture[contingencies.size()];\n+                            for (int i = 0; i < contingencies.size(); i++) {\n+                                Contingency contingency = contingencies.get(i);\n+\n+                                // run one loadflow per contingency\n+                                futures[i] = CompletableFuture\n+                                        .supplyAsync(() -> {\n+                                            try {\n+                                                return queue.take();\n+                                            } catch (InterruptedException e) {\n+                                                Thread.currentThread().interrupt();\n+                                                throw new UncheckedInterruptedException(e);\n+                                            }\n+                                        }, computationManager.getExecutor())\n+                                        .thenCompose(workerId -> {\n+                                            String postContStateId = hash + \"_\" + workerId;\n+                                            return CompletableFuture\n+                                                    .runAsync(() -> {\n+                                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+                                                        // apply the contingency on the network\n+                                                        contingency.toTask().modify(network, computationManager);", "originalCommit": "0776bc31f3342b9a0f01a14675d503495bdfaeb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE1MjY0MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r382152640", "bodyText": "fixed", "author": "jonenst", "createdAt": "2020-02-20T17:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3NzQ4Mw=="}], "type": "inlineReview"}, {"oid": "7c06ede301fc4787196c39b2a45a1c2335abc021", "url": "https://github.com/powsybl/powsybl-core/commit/7c06ede301fc4787196c39b2a45a1c2335abc021", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-20T10:40:02Z", "type": "forcePushed"}, {"oid": "c5a93a98cc68218b4248204dda974baf0f1dd30a", "url": "https://github.com/powsybl/powsybl-core/commit/c5a93a98cc68218b4248204dda974baf0f1dd30a", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool", "committedDate": "2020-02-21T11:09:48Z", "type": "forcePushed"}, {"oid": "ecba715043900572c45295179e2bee6fea8dc82a", "url": "https://github.com/powsybl/powsybl-core/commit/ecba715043900572c45295179e2bee6fea8dc82a", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-21T12:30:01Z", "type": "forcePushed"}, {"oid": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "url": "https://github.com/powsybl/powsybl-core/commit/4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "message": "SecurityAnalysisImpl: Add a parameter max-variants-per-analysis\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T11:22:29Z", "type": "forcePushed"}, {"oid": "d9b0359916b8c2b8cde0255683c5a736e9321130", "url": "https://github.com/powsybl/powsybl-core/commit/d9b0359916b8c2b8cde0255683c5a736e9321130", "message": "SecurityAnalysisImpl: Clone a batch variants before the loadflows and delete them after\n\ncloneVariant is not thread safe, so it must be done before the computations.\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:21Z", "type": "commit"}, {"oid": "97f8e5e324dac47070953999e734d3751a0459ac", "url": "https://github.com/powsybl/powsybl-core/commit/97f8e5e324dac47070953999e734d3751a0459ac", "message": "SecurityAnalysisImpl: contingencyBuilder is not thread safe, synchronize access\n\nThis is the easy way to fix the problem. It's not great but not so terrible because\nthe code in the synchronzized block is not too slow compared to running the loadflows\n(checkAll scans all branches and voltage levels in the network once; it's not instantaneous\nbut fast than running a loadflow; the postContingencyResult interceptors are also run, are they long ?)\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "05a9527c9851a3106780def9d7c5b14454c340e8", "url": "https://github.com/powsybl/powsybl-core/commit/05a9527c9851a3106780def9d7c5b14454c340e8", "message": "SecurityAnalysisImpl: don't build results twice when initial loadflow fails\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "2c359d9b5e6dfab10f52548b7b78a0c03c817739", "url": "https://github.com/powsybl/powsybl-core/commit/2c359d9b5e6dfab10f52548b7b78a0c03c817739", "message": "SecurityAnalysisImpl: cleanup, these do not need to be async\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "503cbd13772bf4b0ef31fdb4d4fe7e210da6613f", "url": "https://github.com/powsybl/powsybl-core/commit/503cbd13772bf4b0ef31fdb4d4fe7e210da6613f", "message": "SecurityAnalysisImpl: restore VariantMultiThreadAccess after the computation\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "f3070a55fb4afc984dedfc41eb972d2aabac376f", "url": "https://github.com/powsybl/powsybl-core/commit/f3070a55fb4afc984dedfc41eb972d2aabac376f", "message": "SecurityAnalysisImpl: only do multithread access if the initial loadflow worked\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "9e1d40ebb05d96ccffff8c8b5245058fb727d4de", "url": "https://github.com/powsybl/powsybl-core/commit/9e1d40ebb05d96ccffff8c8b5245058fb727d4de", "message": "SecurityAnalysisImpl: cleanup: supplyAsync return null -> runAsync\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "cef42204984e5677a8c1bff239d4cb7227449094", "url": "https://github.com/powsybl/powsybl-core/commit/cef42204984e5677a8c1bff239d4cb7227449094", "message": "SecurityAnalysisImpl: don't swallow exceptions\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "3aac98bb36ebfcb9acea5dd2458a6f56e7874157", "url": "https://github.com/powsybl/powsybl-core/commit/3aac98bb36ebfcb9acea5dd2458a6f56e7874157", "message": "SecurityAnalysisImpl: cover variant cleanup in more cases\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "1f9cefb58088b630237b55f619f787ffd8b64336", "url": "https://github.com/powsybl/powsybl-core/commit/1f9cefb58088b630237b55f619f787ffd8b64336", "message": "SecurityAnalysisImpl: clone from workingStateId instead of INITIAL_VARIANT_ID\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "6913279b7df7174c6746791ae9241d32dbf40b51", "url": "https://github.com/powsybl/powsybl-core/commit/6913279b7df7174c6746791ae9241d32dbf40b51", "message": "SecurityAnalysisImpl: Add TODO to parallelize initial loadflow violation check\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "8f2ccc39fb75371193b42901859d1049cfa84b8d", "url": "https://github.com/powsybl/powsybl-core/commit/8f2ccc39fb75371193b42901859d1049cfa84b8d", "message": "SecurityAnalysisImpl: throttle the thread submitting tasks, run it on a separate thread pool\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-24T19:53:22Z", "type": "commit"}, {"oid": "8eacc480071ce2a06a2fb9397e969321f09f1378", "url": "https://github.com/powsybl/powsybl-core/commit/8eacc480071ce2a06a2fb9397e969321f09f1378", "message": "SecurityAnalysisImpl: check the violations of the initial loadflow in the compute executor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T08:27:26Z", "type": "commit"}, {"oid": "fde441cdede91447fc8cac5f40d71e3a50181719", "url": "https://github.com/powsybl/powsybl-core/commit/fde441cdede91447fc8cac5f40d71e3a50181719", "message": "SecurityAnalysisImpl: improve comments\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T08:27:26Z", "type": "commit"}, {"oid": "9dc09d6bad70d9b398d51139d922552e64000a4b", "url": "https://github.com/powsybl/powsybl-core/commit/9dc09d6bad70d9b398d51139d922552e64000a4b", "message": "SecurityAnalysisImpl: Add a parameter max-variants-per-analysis\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T08:27:26Z", "type": "commit"}, {"oid": "197cbf75b2fd30b9ef3dd80d9e26fc066af3694a", "url": "https://github.com/powsybl/powsybl-core/commit/197cbf75b2fd30b9ef3dd80d9e26fc066af3694a", "message": "SecurityAnalysisImpl: refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T12:10:09Z", "type": "commit"}, {"oid": "4951e2a36ac116e9daec1376ef259cd57713b67a", "url": "https://github.com/powsybl/powsybl-core/commit/4951e2a36ac116e9daec1376ef259cd57713b67a", "message": "SecurityAnalysisImpl: don't run the checkviolations of the base loadflow in parallel\n\nThe network is not in isVariantMultiThreadAccessAllowed(true) yet\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T12:10:09Z", "type": "commit"}, {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78", "url": "https://github.com/powsybl/powsybl-core/commit/02e7da27913fc1d2308e756c584c6982d21afd78", "message": "SecurityAnalysisImpl: more refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T12:10:09Z", "type": "commit"}, {"oid": "02e7da27913fc1d2308e756c584c6982d21afd78", "url": "https://github.com/powsybl/powsybl-core/commit/02e7da27913fc1d2308e756c584c6982d21afd78", "message": "SecurityAnalysisImpl: more refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T12:10:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyNDA1NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383824055", "bodyText": "The name of the module could be default-security-analysis, because \"Default\" will be the name of this implementation (see PR#972)", "author": "mathbagu", "createdAt": "2020-02-25T11:34:28Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -20,14 +21,39 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n \n /**\n  * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n  * @author Teofil Calin BANC <teofil-calin.banc at rte-france.com>\n  */\n public class SecurityAnalysisImpl extends AbstractSecurityAnalysis {\n \n+    /**\n+     * This executor is used to create the variants of the network, submit the tasks\n+     * for computing contingency loadflows and submit the tasks for checking for the\n+     * violations. Submitting tasks itself is blocking because we can only run a\n+     * limited number of loadflows in parallel because we need the memory for the\n+     * variant, and we don't want to submit tasks that would immediately block to\n+     * get an available variant (they hurt the performance of the executor who\n+     * excutes them)\n+     */\n+    private static final ExecutorService SCHEDULER_EXECUTOR = Executors\n+            .newFixedThreadPool(Integer.parseInt(PlatformConfig.defaultConfig()\n+                    .getOptionalModuleConfig(\"security-analysis-impl\")", "originalCommit": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyNDI0Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383824246", "bodyText": "Should we base this on the number of cores?", "author": "mathbagu", "createdAt": "2020-02-25T11:34:55Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -20,14 +21,39 @@\n import java.util.List;\n import java.util.Objects;\n import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n \n /**\n  * @author Geoffroy Jamgotchian <geoffroy.jamgotchian at rte-france.com>\n  * @author Teofil Calin BANC <teofil-calin.banc at rte-france.com>\n  */\n public class SecurityAnalysisImpl extends AbstractSecurityAnalysis {\n \n+    /**\n+     * This executor is used to create the variants of the network, submit the tasks\n+     * for computing contingency loadflows and submit the tasks for checking for the\n+     * violations. Submitting tasks itself is blocking because we can only run a\n+     * limited number of loadflows in parallel because we need the memory for the\n+     * variant, and we don't want to submit tasks that would immediately block to\n+     * get an available variant (they hurt the performance of the executor who\n+     * excutes them)\n+     */\n+    private static final ExecutorService SCHEDULER_EXECUTOR = Executors\n+            .newFixedThreadPool(Integer.parseInt(PlatformConfig.defaultConfig()\n+                    .getOptionalModuleConfig(\"security-analysis-impl\")\n+                    .flatMap(m -> m.getOptionalStringProperty(\"scheduler-pool-size\"))\n+                    .orElse(\"10\")));", "originalCommit": "4df2f6b79d88d4d8301f1ec055d4340fe1957e92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMTIxMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383911211", "bodyText": "I'm not sure this is a really good API design. The contingency method should create a PostContingencyResultBuilder that is thread safe. The endContingency should add the PostContingencyResult to the SAResult.", "author": "mathbagu", "createdAt": "2020-02-25T14:26:55Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -69,70 +97,120 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n         // start post contingency LF from pre-contingency state variables\n         LoadFlowParameters postContParameters = loadFlowParameters.copy().setVoltageInitMode(LoadFlowParameters.VoltageInitMode.PREVIOUS_VALUES);\n \n-        network.getVariantManager().allowVariantMultiThreadAccess(true);\n-\n-        return LoadFlow.runAsync(network, workingStateId, computationManager, loadFlowParameters) // run base load flow\n-                .thenComposeAsync(loadFlowResult -> {\n-                    network.getVariantManager().setWorkingVariant(workingStateId);\n-\n-                    SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n-\n-                    CompletableFuture<Void>[] futures;\n+        SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n \n+        return LoadFlow\n+                .runAsync(network, workingStateId, computationManager, loadFlowParameters)\n+                .thenCompose(loadFlowResult -> {\n                     if (loadFlowResult.isOk()) {\n+                        return CompletableFuture\n+                                .runAsync(() -> {\n+                                    network.getVariantManager().setWorkingVariant(workingStateId);\n+                                    setPreContigencyOkAndCheckViolations(resultBuilder);\n+                                }, computationManager.getExecutor())\n+                                .thenComposeAsync(\n+                                    aVoid -> submitAllLoadFlows(workingStateId, contingenciesProvider, postContParameters, resultBuilder),\n+                                    SCHEDULER_EXECUTOR);\n+                    } else {\n+                        return setPreContingencyKo(resultBuilder);\n+                    }\n+                }).thenApply(aVoid -> resultBuilder.build());\n+    }\n \n-                        resultBuilder.preContingency()\n-                                .setComputationOk(true);\n-                        violationDetector.checkAll(network, resultBuilder::addViolation);\n-                        resultBuilder.endPreContingency();\n-\n-                        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n-\n-                        futures = new CompletableFuture[contingencies.size()];\n-\n-                        String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n+    private void setPreContigencyOkAndCheckViolations(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(true);\n+        violationDetector.checkAll(network, resultBuilder::addViolation);\n+        resultBuilder.endPreContingency();\n+    }\n \n-                            String postContStateId = hash + \"_\" + contingency.getId();\n+    private CompletableFuture<Void> setPreContingencyKo(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(false).endPreContingency();\n+        return CompletableFuture.completedFuture(null);\n+    }\n \n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    private CompletableFuture<Void> submitAllLoadFlows(String workingStateId,\n+            ContingenciesProvider contingenciesProvider,\n+            LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder) {\n+        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n+        List<String> variantIds = makeWorkingVariantsNames(contingencies.size());\n+        BlockingQueue<String> queue = new ArrayBlockingQueue<>(variantIds.size(), false, variantIds);\n+        network.getVariantManager().cloneVariant(workingStateId, variantIds);\n+        return CompletableFuture.completedFuture(null).thenCompose(aaVoid -> {\n+            boolean previousMultiThreadAcces = network.getVariantManager()\n+                    .isVariantMultiThreadAccessAllowed();\n+            network.getVariantManager().allowVariantMultiThreadAccess(true);\n+            return CompletableFuture\n+                    .allOf(contingencies.stream()\n+                            .map(contingency -> submitOneLoadFlow(workingStateId,\n+                                    contingency, postContParameters, resultBuilder,\n+                                    queue))\n+                            .toArray(CompletableFuture[]::new))\n+                    .whenComplete((aVoid, throwable) -> network.getVariantManager()\n+                            .allowVariantMultiThreadAccess(previousMultiThreadAcces));\n+        }).whenComplete((aVoid, throwable) ->\n+            variantIds.stream().forEach(network.getVariantManager()::removeVariant));\n+    }\n \n-                                        // apply the contingency on the network\n-                                        contingency.toTask().modify(network, computationManager);\n+    private List<String> makeWorkingVariantsNames(int contingencySize) {\n+        String hash = UUID.randomUUID().toString();\n+        int workerCount = Math.min(MAX_VARIANTS_PER_ANALYSIS,\n+                Math.min(computationManager.getResourcesStatus().getAvailableCores(),\n+                        contingencySize));\n+        return IntStream.range(0, workerCount)\n+                .mapToObj(i -> hash + \"_\" + i).collect(Collectors.toList());\n+    }\n \n-                                        return null;\n-                                    }, computationManager.getExecutor())\n-                                    .thenComposeAsync(aVoid -> LoadFlow.runAsync(network, postContStateId, computationManager, postContParameters), computationManager.getExecutor())\n-                                    .handleAsync((lfResult, throwable) -> {\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    // Block for an available variant, then submit a loadflow on this variant, then\n+    // make the variant available again\n+    private CompletableFuture<Void> submitOneLoadFlow(String workingStateId,\n+            Contingency contingency, LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder, BlockingQueue<String> queue) {\n+        return CompletableFuture.completedFuture(null).thenCompose(aaVoid -> {\n+            String postContStateId;\n+            try {\n+                postContStateId = queue.take();\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw new UncheckedInterruptedException(e);\n+            }\n+            return runOneLoadFlowAsync(workingStateId, postContStateId, postContParameters, resultBuilder, contingency)\n+                    .whenComplete((aVoid, throwable) -> queue.add(postContStateId));\n+        });\n+    }\n \n-                                        resultBuilder.contingency(contingency)\n-                                                .setComputationOk(lfResult.isOk());\n-                                        violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n-                                        resultBuilder.endContingency();\n-                                        network.getVariantManager().removeVariant(postContStateId);\n+    private CompletableFuture<Void> runOneLoadFlowAsync(String workingStateId,\n+            String postContStateId, LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder, Contingency contingency) {\n+        return CompletableFuture\n+                .runAsync(() -> applyContingency(workingStateId, postContStateId,\n+                        contingency), computationManager.getExecutor())\n+                .thenCompose(aVoid -> LoadFlow.runAsync(network, postContStateId,\n+                        computationManager, postContParameters))\n+                .thenApplyAsync(lfResult -> {\n+                    setContingencyOkAndCheckViolations(postContStateId, resultBuilder,\n+                            contingency, lfResult);\n+                    return null;\n+                }, computationManager.getExecutor());\n+    }\n \n-                                        return null;\n-                                    }, computationManager.getExecutor());\n-                        }\n-                    } else {\n-                        resultBuilder.preContingency()\n-                                .setComputationOk(false)\n-                                .endPreContingency()\n-                                .build();\n-                        futures = new CompletableFuture[0];\n-                    }\n+    private void setContingencyOkAndCheckViolations(String postContStateId,\n+            SecurityAnalysisResultBuilder resultBuilder, Contingency contingency,\n+            LoadFlowResult lfResult) {\n+        network.getVariantManager().setWorkingVariant(postContStateId);\n+        synchronized (resultBuilder) {\n+            resultBuilder.contingency(contingency)\n+                    .setComputationOk(lfResult.isOk());\n+            violationDetector.checkAll(contingency, network, resultBuilder::addViolation);\n+            resultBuilder.endContingency();\n+        }", "originalCommit": "02e7da27913fc1d2308e756c584c6982d21afd78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMzcyNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1169#discussion_r383913725", "bodyText": "You should not create a variant for all variant, but create 1 variant per worker. This is a regression on what you did yesterday?", "author": "mathbagu", "createdAt": "2020-02-25T14:30:58Z", "path": "security-analysis/security-analysis-api/src/main/java/com/powsybl/security/SecurityAnalysisImpl.java", "diffHunk": "@@ -69,70 +97,120 @@ public boolean removeInterceptor(SecurityAnalysisInterceptor interceptor) {\n         // start post contingency LF from pre-contingency state variables\n         LoadFlowParameters postContParameters = loadFlowParameters.copy().setVoltageInitMode(LoadFlowParameters.VoltageInitMode.PREVIOUS_VALUES);\n \n-        network.getVariantManager().allowVariantMultiThreadAccess(true);\n-\n-        return LoadFlow.runAsync(network, workingStateId, computationManager, loadFlowParameters) // run base load flow\n-                .thenComposeAsync(loadFlowResult -> {\n-                    network.getVariantManager().setWorkingVariant(workingStateId);\n-\n-                    SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n-\n-                    CompletableFuture<Void>[] futures;\n+        SecurityAnalysisResultBuilder resultBuilder = createResultBuilder(workingStateId);\n \n+        return LoadFlow\n+                .runAsync(network, workingStateId, computationManager, loadFlowParameters)\n+                .thenCompose(loadFlowResult -> {\n                     if (loadFlowResult.isOk()) {\n+                        return CompletableFuture\n+                                .runAsync(() -> {\n+                                    network.getVariantManager().setWorkingVariant(workingStateId);\n+                                    setPreContigencyOkAndCheckViolations(resultBuilder);\n+                                }, computationManager.getExecutor())\n+                                .thenComposeAsync(\n+                                    aVoid -> submitAllLoadFlows(workingStateId, contingenciesProvider, postContParameters, resultBuilder),\n+                                    SCHEDULER_EXECUTOR);\n+                    } else {\n+                        return setPreContingencyKo(resultBuilder);\n+                    }\n+                }).thenApply(aVoid -> resultBuilder.build());\n+    }\n \n-                        resultBuilder.preContingency()\n-                                .setComputationOk(true);\n-                        violationDetector.checkAll(network, resultBuilder::addViolation);\n-                        resultBuilder.endPreContingency();\n-\n-                        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n-\n-                        futures = new CompletableFuture[contingencies.size()];\n-\n-                        String hash = UUID.randomUUID().toString();\n-                        for (int i = 0; i < contingencies.size(); i++) {\n-                            Contingency contingency = contingencies.get(i);\n+    private void setPreContigencyOkAndCheckViolations(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(true);\n+        violationDetector.checkAll(network, resultBuilder::addViolation);\n+        resultBuilder.endPreContingency();\n+    }\n \n-                            String postContStateId = hash + \"_\" + contingency.getId();\n+    private CompletableFuture<Void> setPreContingencyKo(SecurityAnalysisResultBuilder resultBuilder) {\n+        resultBuilder.preContingency().setComputationOk(false).endPreContingency();\n+        return CompletableFuture.completedFuture(null);\n+    }\n \n-                            // run one loadflow per contingency\n-                            futures[i] = CompletableFuture\n-                                    .supplyAsync(() -> {\n-                                        network.getVariantManager().cloneVariant(VariantManagerConstants.INITIAL_VARIANT_ID, postContStateId);\n-                                        network.getVariantManager().setWorkingVariant(postContStateId);\n+    private CompletableFuture<Void> submitAllLoadFlows(String workingStateId,\n+            ContingenciesProvider contingenciesProvider,\n+            LoadFlowParameters postContParameters,\n+            SecurityAnalysisResultBuilder resultBuilder) {\n+        List<Contingency> contingencies = contingenciesProvider.getContingencies(network);\n+        List<String> variantIds = makeWorkingVariantsNames(contingencies.size());\n+        BlockingQueue<String> queue = new ArrayBlockingQueue<>(variantIds.size(), false, variantIds);\n+        network.getVariantManager().cloneVariant(workingStateId, variantIds);", "originalCommit": "02e7da27913fc1d2308e756c584c6982d21afd78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fab5479d246419d28e21310831c04f90df3d9945", "url": "https://github.com/powsybl/powsybl-core/commit/fab5479d246419d28e21310831c04f90df3d9945", "message": "SecurityAnalysisImpl: refactor\n\nSigned-off-by: Jon Harper <jon.harper87@gmail.com>", "committedDate": "2020-02-25T16:08:48Z", "type": "commit"}, {"oid": "29c00e1837051f454158b2e36c8a62e71adadbd9", "url": "https://github.com/powsybl/powsybl-core/commit/29c00e1837051f454158b2e36c8a62e71adadbd9", "message": "Fix issues with new implementation\n\nSigned-off-by: Mathieu BAGUE <mathieu.bague@rte-france.com>", "committedDate": "2020-02-27T16:03:05Z", "type": "commit"}, {"oid": "7d648aad37f0816089640ee028ad018933b74ea4", "url": "https://github.com/powsybl/powsybl-core/commit/7d648aad37f0816089640ee028ad018933b74ea4", "message": "Merge branch 'master' into securityanalysisparallel", "committedDate": "2020-02-28T11:09:08Z", "type": "commit"}, {"oid": "b42ec8960089fad5da7568e933395a76990d99ac", "url": "https://github.com/powsybl/powsybl-core/commit/b42ec8960089fad5da7568e933395a76990d99ac", "message": "Small fixes\n- Use a fixed thread pool executor with a keep alive timeout close to 0\n- Replace the synchronized by a ReentrantLock\n\nSigned-off-by: Mathieu BAGUE <mathieu.bague@rte-france.com>", "committedDate": "2020-02-28T14:28:29Z", "type": "commit"}, {"oid": "0ed97063e5124d1ecfacdd984d872b47a35af151", "url": "https://github.com/powsybl/powsybl-core/commit/0ed97063e5124d1ecfacdd984d872b47a35af151", "message": "Fix the visibility of the scheduler\n\nSigned-off-by: Mathieu BAGUE <mathieu.bague@rte-france.com>", "committedDate": "2020-02-28T14:30:48Z", "type": "commit"}, {"oid": "15c77a26c91125ea8819378d970b67f929252c6a", "url": "https://github.com/powsybl/powsybl-core/commit/15c77a26c91125ea8819378d970b67f929252c6a", "message": "Merge branch 'master' into securityanalysisparallel", "committedDate": "2020-02-28T14:48:14Z", "type": "commit"}]}