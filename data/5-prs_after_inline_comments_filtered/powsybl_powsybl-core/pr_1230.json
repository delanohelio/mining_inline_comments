{"pr_number": 1230, "pr_title": "Cgmes conversion hvdc", "pr_createdAt": "2020-03-17T15:22:21Z", "pr_url": "https://github.com/powsybl/powsybl-core/pull/1230", "timeline": [{"oid": "8a20f55d51dca5ba3c44ef889a91b69783201f32", "url": "https://github.com/powsybl/powsybl-core/commit/8a20f55d51dca5ba3c44ef889a91b69783201f32", "message": "Calculate DC-Islands\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-01-28T06:42:46Z", "type": "commit"}, {"oid": "25152317fcd7c2056032d3ff04a009fa4ed0e123", "url": "https://github.com/powsybl/powsybl-core/commit/25152317fcd7c2056032d3ff04a009fa4ed0e123", "message": "Hvdc refac\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-01-30T15:44:09Z", "type": "commit"}, {"oid": "945564c8091ba08320134ec9e6fb93cb82c7fe32", "url": "https://github.com/powsybl/powsybl-core/commit/945564c8091ba08320134ec9e6fb93cb82c7fe32", "message": "Rename package\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-01-31T06:42:19Z", "type": "commit"}, {"oid": "2c686792551171be054c773f99b362f42d3aee01", "url": "https://github.com/powsybl/powsybl-core/commit/2c686792551171be054c773f99b362f42d3aee01", "message": "Common topologicalNode version\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-01-31T11:13:24Z", "type": "commit"}, {"oid": "7da7010c20d136cbb329eb11493a571cb5b2127b", "url": "https://github.com/powsybl/powsybl-core/commit/7da7010c20d136cbb329eb11493a571cb5b2127b", "message": "Refac Hvdc\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-02-03T13:33:15Z", "type": "commit"}, {"oid": "2ad1aa62777c4c70a2a1b3cb987d772b2fe18ea1", "url": "https://github.com/powsybl/powsybl-core/commit/2ad1aa62777c4c70a2a1b3cb987d772b2fe18ea1", "message": "Get all DC configurations properly\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-02-12T16:00:22Z", "type": "commit"}, {"oid": "f4a1daace52fd529ab0b59c2f02e9a4708e2d96b", "url": "https://github.com/powsybl/powsybl-core/commit/f4a1daace52fd529ab0b59c2f02e9a4708e2d96b", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-02-17T08:02:27Z", "type": "commit"}, {"oid": "2cbb542e20464496942226dd2fe4520cb8db382e", "url": "https://github.com/powsybl/powsybl-core/commit/2cbb542e20464496942226dd2fe4520cb8db382e", "message": "AcDcConverterConversion and DcLineSegmentConversion\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-02-17T14:23:42Z", "type": "commit"}, {"oid": "2280476b08f2ab07cfcbcc8513f79c8e4f1d70bd", "url": "https://github.com/powsybl/powsybl-core/commit/2280476b08f2ab07cfcbcc8513f79c8e4f1d70bd", "message": "Create IIDM Hvdc converters and links\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-02-20T13:01:36Z", "type": "commit"}, {"oid": "f36e234e4ff33c6e053cc92beec1db48a4a72aac", "url": "https://github.com/powsybl/powsybl-core/commit/f36e234e4ff33c6e053cc92beec1db48a4a72aac", "message": "Fix some errors\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-02-24T06:43:44Z", "type": "commit"}, {"oid": "cceb42f2feac55ee0bbbd0895f17f9e212b6b7e2", "url": "https://github.com/powsybl/powsybl-core/commit/cceb42f2feac55ee0bbbd0895f17f9e212b6b7e2", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-02-27T09:03:17Z", "type": "commit"}, {"oid": "6feff6b20d4bcc11804fe791ae1c99144783f752", "url": "https://github.com/powsybl/powsybl-core/commit/6feff6b20d4bcc11804fe791ae1c99144783f752", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-03T06:53:05Z", "type": "commit"}, {"oid": "514c0fad1a3b2a6d8ac68a2270839aa24b4f366f", "url": "https://github.com/powsybl/powsybl-core/commit/514c0fad1a3b2a6d8ac68a2270839aa24b4f366f", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-13T08:50:28Z", "type": "commit"}, {"oid": "d9bdc8aedb605bb08c84d9a243affa7fc1463338", "url": "https://github.com/powsybl/powsybl-core/commit/d9bdc8aedb605bb08c84d9a243affa7fc1463338", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-16T23:08:54Z", "type": "commit"}, {"oid": "f6ea8ed7024d030400a8e4d6cccc242d6968afac", "url": "https://github.com/powsybl/powsybl-core/commit/f6ea8ed7024d030400a8e4d6cccc242d6968afac", "message": "Delete unnecessary code\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-17T07:23:58Z", "type": "commit"}, {"oid": "e9d074a9bade75204935a958f622e267c6969731", "url": "https://github.com/powsybl/powsybl-core/commit/e9d074a9bade75204935a958f622e267c6969731", "message": "Pretty code\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-17T15:12:25Z", "type": "commit"}, {"oid": "c33171bfa36f00479e972469b7eddb4106c2435d", "url": "https://github.com/powsybl/powsybl-core/commit/c33171bfa36f00479e972469b7eddb4106c2435d", "message": "Merge branch 'master' into cgmes_conversion_HVDC\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-model/src/main/java/com/powsybl/cgmes/model/CgmesModel.java", "committedDate": "2020-03-17T16:19:33Z", "type": "commit"}, {"oid": "136368ee5fab74a78e80ae2ebc690262981214c0", "url": "https://github.com/powsybl/powsybl-core/commit/136368ee5fab74a78e80ae2ebc690262981214c0", "message": "Add a hvdc configuration without transformers.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-19T00:05:35Z", "type": "commit"}, {"oid": "71d726c0239ad06b071624875f25dcece67ae194", "url": "https://github.com/powsybl/powsybl-core/commit/71d726c0239ad06b071624875f25dcece67ae194", "message": "Unitary tests\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-19T00:06:48Z", "type": "commit"}, {"oid": "47e367405e933c518ccff694411b78c3bb947a65", "url": "https://github.com/powsybl/powsybl-core/commit/47e367405e933c518ccff694411b78c3bb947a65", "message": "Log under configuration\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-19T15:03:41Z", "type": "commit"}, {"oid": "d78cbbd032cbb2a4e97709db3cf20ed9b941756c", "url": "https://github.com/powsybl/powsybl-core/commit/d78cbbd032cbb2a4e97709db3cf20ed9b941756c", "message": "Additional tests\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-19T15:05:30Z", "type": "commit"}, {"oid": "35b559c6d3bc715ba44b97bf2db314403be668cc", "url": "https://github.com/powsybl/powsybl-core/commit/35b559c6d3bc715ba44b97bf2db314403be668cc", "message": "Additional tests\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-20T18:34:29Z", "type": "commit"}, {"oid": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "url": "https://github.com/powsybl/powsybl-core/commit/c1c5e45c91fa7f0a00d0ade62110da33225ad268", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-20T18:35:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NTc3MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396485771", "bodyText": "Add Objects.requireNonNull()", "author": "MioRtia", "createdAt": "2020-03-23T14:20:20Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -5,25 +5,34 @@\n  * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n  */\n \n-package com.powsybl.cgmes.conversion.elements;\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n \n import java.util.Objects;\n \n import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractConductingEquipmentConversion;\n import com.powsybl.iidm.network.HvdcConverterStation;\n import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.iidm.network.LccConverterStation;\n import com.powsybl.iidm.network.LccConverterStationAdder;\n import com.powsybl.iidm.network.VscConverterStationAdder;\n import com.powsybl.triplestore.api.PropertyBag;\n \n /**\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n public class AcDcConverterConversion extends AbstractConductingEquipmentConversion {\n \n-    public AcDcConverterConversion(PropertyBag c, Context context) {\n+    enum VscRegulation {\n+        REACTIVE_POWER,\n+        VOLTAGE\n+    }\n+\n+    public AcDcConverterConversion(PropertyBag c, HvdcType converterType, double lossFactor, Context context) {\n         super(\"ACDCConverter\", c, context);\n-        converterType = decodeType(p.getLocal(\"type\"));\n+        this.converterType = converterType;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMjA4NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397122085", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T12:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjE4OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396516188", "bodyText": "can be final\nshould be private with a private-package getter returning an unmodifiable map", "author": "MioRtia", "createdAt": "2020-03-23T15:00:08Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMjI0NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397122244", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T12:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjk2OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396516968", "bodyText": "Method reference can be used instead of lambda:\n        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);", "author": "MioRtia", "createdAt": "2020-03-23T15:01:13Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMjQ5Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397122492", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T12:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODYyNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396518626", "bodyText": "When is this method used?", "author": "MioRtia", "createdAt": "2020-03-23T15:03:22Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDQ4NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397124484", "bodyText": "I kept it for debugging", "author": "marqueslanauja", "createdAt": "2020-03-24T12:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxOTEzMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396519130", "bodyText": "You can directly use forEach on a map:\nconverterNodes.forEach((key, value) -> ....);", "author": "MioRtia", "createdAt": "2020-03-23T15:04:01Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.entrySet()\n+            .forEach(entry -> LOG.info(\" {} {} {} {}\", entry.getKey(), entry.getValue().id,", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDY4OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397124689", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T12:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxOTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDE4OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396520188", "bodyText": "Can be final\nShould be private with a private-package getter returning an unmodifiable map", "author": "MioRtia", "createdAt": "2020-03-23T15:05:31Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NTg4Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397265887", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDgxNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396520815", "bodyText": "Can they be final?", "author": "MioRtia", "createdAt": "2020-03-23T15:06:27Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.entrySet()\n+            .forEach(entry -> LOG.info(\" {} {} {} {}\", entry.getKey(), entry.getValue().id,\n+                entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+    }\n+\n+    static class AcDcConverterNode {\n+        String id;\n+        String acTopologicalNode;\n+        List<String> dcTopologicalNode;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NjIxNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397266214", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMDgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTA1MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396521051", "bodyText": "Maybe check Objects.requireNonNull()?", "author": "MioRtia", "createdAt": "2020-03-23T15:06:47Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(t -> computeDcTerminalToAcDcConverter(t));\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.entrySet()\n+            .forEach(entry -> LOG.info(\" {} {} {} {}\", entry.getKey(), entry.getValue().id,\n+                entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+    }\n+\n+    static class AcDcConverterNode {\n+        String id;\n+        String acTopologicalNode;\n+        List<String> dcTopologicalNode;\n+\n+        AcDcConverterNode(String id, String acTopologicalNode) {\n+            this.id = id;\n+            this.acTopologicalNode = acTopologicalNode;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NjYzNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397266637", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0MjQzNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396542435", "bodyText": "You can directly use forEach on a map:\nacDcConverterNodes.getConverterNodes().forEach((key, value) -> ...);", "author": "MioRtia", "createdAt": "2020-03-23T15:34:27Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzA0MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397267041", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0MjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTQ1OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396545458", "bodyText": "You can simplify:\naddTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode()));", "author": "MioRtia", "createdAt": "2020-03-23T15:38:20Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODgyOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397118829", "bodyText": "Maybe you should change the signature of addTransformerAdajacency to pass a table: addTransformerAdjacency(t1.topologicalNode(), t2.topologicalNode());", "author": "mathbagu", "createdAt": "2020-03-24T12:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzMwMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397267303", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTc4NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396545785", "bodyText": "Same remark", "author": "MioRtia", "createdAt": "2020-03-23T15:38:43Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzQ5OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397267498", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU0NTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1NTkxOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396555918", "bodyText": "Method reference can be used here:\ntopologicalNodes.stream().anyMatch(this::containsAcDcConverter)", "author": "MioRtia", "createdAt": "2020-03-23T15:51:28Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NzcxMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397267711", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1NTkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1Nzg3Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396557877", "bodyText": "Not sure traces should be handled this way... In my opinion, those traces should always show up as DEBUG.", "author": "MioRtia", "createdAt": "2020-03-23T15:53:59Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMDc4Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397120782", "bodyText": "Then change the log level to debug", "author": "mathbagu", "createdAt": "2020-03-24T12:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1Nzg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNDE1OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404424159", "bodyText": "Done. Log level has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1Nzg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTEyMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559120", "bodyText": "Method reference can be used", "author": "MioRtia", "createdAt": "2020-03-23T15:55:34Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.info(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(ad -> ad.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2Nzk3MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397267971", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T15:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTM3OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559378", "bodyText": "forEach can be used directly on map", "author": "MioRtia", "createdAt": "2020-03-23T15:55:54Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2ODI1MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397268251", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTY3Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559677", "bodyText": "Maybe check Objects.requireNonNull()?", "author": "MioRtia", "createdAt": "2020-03-23T15:56:16Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.info(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(ad -> ad.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));\n+    }\n+\n+    private void print(String node) {\n+        LOG.info(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.info(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }\n+\n+    static class Adjacent {\n+        AdjacentType type;\n+        String topologicalNode;\n+\n+        Adjacent(AdjacentType type, String topologicalNode) {\n+            this.type = type;\n+            this.topologicalNode = topologicalNode;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2ODU3Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397268577", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTk0NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396559944", "bodyText": "Use Objects.requireNonNull()", "author": "MioRtia", "createdAt": "2020-03-23T15:56:34Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2ODg1NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397268855", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NjgxNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396566817", "bodyText": "Same remark for logs", "author": "MioRtia", "createdAt": "2020-03-23T16:05:23Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.islandsEndsNodes.forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.topologicalNodes1);\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.topologicalNodes2);\n+\n+            if (config.isHvdcConversionLogOn()) {\n+                adjacency.print(ien.topologicalNodes1);\n+                tpNodeEquipments.print(ien.topologicalNodes1);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes1);\n+\n+                adjacency.print(ien.topologicalNodes2);\n+                tpNodeEquipments.print(ien.topologicalNodes2);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes2);\n+\n+                islandEndHvdc1.print();\n+                islandEndHvdc2.print();\n+            }", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNDYwNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404424605", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NzMzNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396567337", "bodyText": "Same remark for log", "author": "MioRtia", "createdAt": "2020-03-23T16:06:03Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.islandsEndsNodes.forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.topologicalNodes1);\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.topologicalNodes2);\n+\n+            if (config.isHvdcConversionLogOn()) {\n+                adjacency.print(ien.topologicalNodes1);\n+                tpNodeEquipments.print(ien.topologicalNodes1);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes1);\n+\n+                adjacency.print(ien.topologicalNodes2);\n+                tpNodeEquipments.print(ien.topologicalNodes2);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes2);\n+\n+                islandEndHvdc1.print();\n+                islandEndHvdc2.print();\n+            }\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            hvdc.print();\n+        }", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNDc3MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404424770", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NzMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2OTkxMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396569913", "bodyText": "can be final\nshould be private with a getter returning an unmodifiable list", "author": "MioRtia", "createdAt": "2020-03-23T16:09:33Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTIxOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397269218", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2OTkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MDI2Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396570263", "bodyText": "Add a default case throwing an exception", "author": "MioRtia", "createdAt": "2020-03-23T16:09:57Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MzcxNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398763717", "bodyText": "It is an enum variable. It is not necessary.", "author": "marqueslanauja", "createdAt": "2020-03-26T17:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MDI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MDg5Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396570896", "bodyText": "can be final", "author": "MioRtia", "createdAt": "2020-03-23T16:10:46Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_NONE:\n+                break;\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(ls -> hvdcEq.add(ls));\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    void print() {\n+        LOG.info(\"Hvdc\");\n+        hvdcData.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEquipment {\n+        List<HvdcConverter> converters;\n+        List<String> dcLineSegments;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTQ1OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397269458", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MDg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTE0OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396571149", "bodyText": "Maybe use Objects.requireNonNull()", "author": "MioRtia", "createdAt": "2020-03-23T16:11:05Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_NONE:\n+                break;\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(ls -> hvdcEq.add(ls));\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    void print() {\n+        LOG.info(\"Hvdc\");\n+        hvdcData.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEquipment {\n+        List<HvdcConverter> converters;\n+        List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void print() {\n+            LOG.info(\"    Converters:\");\n+            this.converters.forEach(c -> c.print());\n+            LOG.info(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.info(\"    {} \", ls));\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    static class HvdcConverter {\n+        String acDcConvertersEnd1;\n+        String acDcConvertersEnd2;\n+\n+        HvdcConverter(String acDcConvertersEnd1, String acDcConvertersEnd2) {\n+            this.acDcConvertersEnd1 = acDcConvertersEnd1;\n+            this.acDcConvertersEnd2 = acDcConvertersEnd2;\n+        }", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2OTU4OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397269589", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTUzMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396571532", "bodyText": "can be final\nshould be private with a getter returning an unmodifiable set", "author": "MioRtia", "createdAt": "2020-03-23T16:11:38Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MDMzNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397270337", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTk5OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396571999", "bodyText": "Maybe use Objects.requireNonNull()", "author": "MioRtia", "createdAt": "2020-03-23T16:12:19Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.nodeEquipments.get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(ls -> hvdcEnd2.dcLineSegmentsEnd.contains(ls));\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandEndHvdc\");\n+        hvdc.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEnd {\n+        List<String> topologicalNodesEnd;\n+        Set<String> transformersEnd;\n+        Set<String> acDcConvertersEnd;\n+        Set<String> dcLineSegmentsEnd;\n+\n+        HvdcEnd(List<String> topologicalNodesEnd, Set<String> transformersEnd, Set<String> acDcConvertersEnd, Set<String> dcLineSegmentsEnd) {\n+            this.topologicalNodesEnd = topologicalNodesEnd;\n+            this.transformersEnd = transformersEnd;\n+            this.acDcConvertersEnd = acDcConvertersEnd;\n+            this.dcLineSegmentsEnd = dcLineSegmentsEnd;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MDU2MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397270561", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjA4Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572082", "bodyText": "Can be final", "author": "MioRtia", "createdAt": "2020-03-23T16:12:25Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.nodeEquipments.get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(ls -> hvdcEnd2.dcLineSegmentsEnd.contains(ls));\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandEndHvdc\");\n+        hvdc.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEnd {\n+        List<String> topologicalNodesEnd;\n+        Set<String> transformersEnd;\n+        Set<String> acDcConvertersEnd;\n+        Set<String> dcLineSegmentsEnd;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MDgzNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397270836", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjQzOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572439", "bodyText": "can be final\nshould be private with a getter returning an unmodifiable set if necessary", "author": "MioRtia", "createdAt": "2020-03-23T16:12:51Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    Set<List<String>> islandsNodes;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTAxNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397271015", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjU5OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572598", "bodyText": "Same remark", "author": "MioRtia", "createdAt": "2020-03-23T16:13:02Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    Set<IslandEnd> islandsEndsNodes;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTIzOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397271238", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3Mjg0OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396572849", "bodyText": "Same remarks", "author": "MioRtia", "createdAt": "2020-03-23T16:13:22Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    Set<IslandEnd> islandsEndsNodes;\n+\n+    // The island includes dcTopologicalNodes and first acTopologicalNode\n+    IslandsEnds() {\n+        islandsEndsNodes = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, List<String> islandNodes) {\n+        if (islandNodes.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        String topologicalNodeEnd1 = islandNodes.get(0);\n+        List<String> adjacentTopologicalNodeEnd1 = computeAdjacentTopologicalNodes(topologicalNodeEnd1,\n+            adjacency, visitedTopologicalNodes);\n+\n+        String topologicalNodeEnd2 = getTopologicalNodeOtherEnd(islandNodes, visitedTopologicalNodes);\n+        if (topologicalNodeEnd2 == null) {\n+            return;\n+        }\n+        List<String> adjacentTopologicalNodeEnd2 = computeAdjacentTopologicalNodes(topologicalNodeEnd2,\n+            adjacency, visitedTopologicalNodes);\n+\n+        IslandEnd islandEnd = new IslandEnd(adjacentTopologicalNodeEnd1, adjacentTopologicalNodeEnd2);\n+\n+        islandsEndsNodes.add(islandEnd);\n+    }\n+\n+    private static String getTopologicalNodeOtherEnd(List<String> islandNodes, Set<String> visitedTopologicalNodes) {\n+        return islandNodes.stream()\n+            .filter(n -> !visitedTopologicalNodes.contains(n))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (Adjacency.isDcLineSegment(adjacent.type)) {\n+                        return;\n+                    }\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandsEnds\");\n+        islandsEndsNodes.forEach(islandEnd -> islandEnd.print());\n+    }\n+\n+    static class IslandEnd {\n+        List<String> topologicalNodes1;\n+        List<String> topologicalNodes2;\n+\n+        IslandEnd(List<String> topologicalNodes1, List<String> topologicalNodes2) {\n+            this.topologicalNodes1 = topologicalNodes1;\n+            this.topologicalNodes2 = topologicalNodes2;\n+        }", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTUzOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397271538", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3Mjg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MzEzMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396573133", "bodyText": "Use Objects.requireNonNull()", "author": "MioRtia", "createdAt": "2020-03-23T16:13:42Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1, double poleLossP2) {\n+        this.mode = mode;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTY5MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397271690", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MzEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MzQ0OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r396573448", "bodyText": "Same remark", "author": "MioRtia", "createdAt": "2020-03-23T16:14:04Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    Map<String, List<TPnodeEquipment>> nodeEquipments;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MTgzNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397271836", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-24T16:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3MzQ0OA=="}], "type": "inlineReview"}, {"oid": "c6d41ddb0fbe29cb9e63569a7f5866298ad60bcd", "url": "https://github.com/powsybl/powsybl-core/commit/c6d41ddb0fbe29cb9e63569a7f5866298ad60bcd", "message": "Apply reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-24T12:38:44Z", "type": "commit"}, {"oid": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "url": "https://github.com/powsybl/powsybl-core/commit/d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-24T12:38:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNDQwOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397114408", "bodyText": "This modification is strange... You import something without using it. I'm surprised it compiles", "author": "mathbagu", "createdAt": "2020-03-24T12:28:32Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/Context.java", "diffHunk": "@@ -16,6 +16,7 @@\n \n import com.powsybl.cgmes.conversion.Conversion.Config;\n import com.powsybl.cgmes.conversion.elements.ACLineSegmentConversion;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcMapping;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MjQ2NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398762465", "bodyText": "I am using it. You cannot compile with unused imports.", "author": "marqueslanauja", "createdAt": "2020-03-26T17:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNDQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNjEyNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397116124", "bodyText": "Should we change the lossFactor to a double?", "author": "mathbagu", "createdAt": "2020-03-24T12:31:48Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -59,10 +63,10 @@ public void convert() {\n                 reactivePowerSetpoint = -p.asDouble(\"targetQpcc\");\n             }\n             VscConverterStationAdder adder = voltageLevel().newVscConverterStation()\n-                    .setLossFactor(0.0f) // this attribute will be updated when the HVDC line attached to this station is imported\n-                    .setVoltageRegulatorOn(voltageRegulatorOn)\n-                    .setVoltageSetpoint(voltageSetpoint)\n-                    .setReactivePowerSetpoint(reactivePowerSetpoint);\n+                .setLossFactor((float) this.lossFactor)", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MTA1NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398761054", "bodyText": "The IIDM api expects a float. Better to change it in a separated PR.", "author": "marqueslanauja", "createdAt": "2020-03-26T17:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNjEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNzkyNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397117924", "bodyText": "You should throw an exception in the other cases?", "author": "mathbagu", "createdAt": "2020-03-24T12:34:56Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NzY3NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398757675", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-26T17:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExNzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExOTg5MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397119891", "bodyText": "Are you sure about the log level. In the CGMES converter there are a lot of informations printed, and it's hard to find an interesting information. If these logs are for debug, change the log level to debug.", "author": "mathbagu", "createdAt": "2020-03-24T12:38:30Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.converterNodes.entrySet()\n+            .forEach(entry -> computeAcDcConverterAdjacency(entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        addTransformerAdjacency(topologicalNodes);\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(n -> containsAcDcConverter(n))) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Adjacency\");\n+        adjacency.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.info(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(ad -> ad.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));\n+    }\n+\n+    private void print(String node) {\n+        LOG.info(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.info(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }\n+\n+    static class Adjacent {\n+        AdjacentType type;\n+        String topologicalNode;\n+\n+        Adjacent(AdjacentType type, String topologicalNode) {\n+            this.type = type;\n+            this.topologicalNode = topologicalNode;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    {}  {}\", this.type, this.topologicalNode);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Adjacency.class);", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNTA1Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404425053", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExOTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMDI4MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397120280", "bodyText": "This is a bit uggly: why don't you add an isEmpty method to the Adjacency class?", "author": "mathbagu", "createdAt": "2020-03-24T12:39:10Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NzQ0Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398757447", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-26T17:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMDI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMTY4Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397121683", "bodyText": "Is it allowed by the format? Depending on your answer, throw an exception or log a message (warn?)", "author": "mathbagu", "createdAt": "2020-03-24T12:41:44Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.Conversion.Config;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context, Config config) {\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+        this.config = config;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.islandsNodes.forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            adjacency.print();\n+            tpNodeEquipments.print();\n+            islands.print();\n+            islandsEnds.print();\n+        }\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.islandsEndsNodes.forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.topologicalNodes1);\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.topologicalNodes2);\n+\n+            if (config.isHvdcConversionLogOn()) {\n+                adjacency.print(ien.topologicalNodes1);\n+                tpNodeEquipments.print(ien.topologicalNodes1);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes1);\n+\n+                adjacency.print(ien.topologicalNodes2);\n+                tpNodeEquipments.print(ien.topologicalNodes2);\n+                tpNodeEquipments.printDcLs(ien.topologicalNodes2);\n+\n+                islandEndHvdc1.print();\n+                islandEndHvdc2.print();\n+            }\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        if (config.isHvdcConversionLogOn()) {\n+            hvdc.print();\n+        }\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.hvdcData.forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId1, String dcLineSegmentId2) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId1);\n+        if (!ok) {\n+            return;\n+        }\n+        PropertyBag dcLineSegment2 = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId2);\n+        if (dcLineSegment2 == null) {\n+            return;\n+        }\n+        this.r = 1.0 / (1.0 / computeR(this.dcLineSegment) + 1.0 / computeR(dcLineSegment2));\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+            context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId2);\n+        }\n+    }\n+\n+    private void setCommonDataUsed() {\n+        context.dc().setCgmesConverterUsed(converter1Id);\n+        context.dc().setCgmesConverterUsed(converter2Id);\n+        context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId);\n+    }\n+\n+    private boolean convertCommonData(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        this.converter1Id = acDcConverterIdEnd1;\n+        this.cconverter1 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd1);\n+        this.converter2Id = acDcConverterIdEnd2;\n+        this.cconverter2 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd2);\n+        this.dcLineSegmentId = dcLineSegmentId;\n+        this.dcLineSegment = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId);\n+        if (this.cconverter1 == null || this.cconverter2 == null || this.dcLineSegment == null) {\n+            return false;\n+        }\n+        this.converterType = decodeType(this.cconverter1.getLocal(TYPE));\n+        if (this.converterType == null || converterType != decodeType(this.cconverter2.getLocal(TYPE))) {\n+            return false;\n+        }\n+        this.operatingMode = decodeMode(this.converterType, this.cconverter1, this.cconverter2);\n+        this.ratedUdc = computeRatedUdc(this.cconverter1, this.cconverter2);\n+\n+        return true;\n+    }\n+\n+    private static HvdcType decodeType(String stype) {\n+        if (stype.equals(\"VsConverter\")) {\n+            return HvdcType.VSC;\n+        } else if (stype.equals(\"CsConverter\")) {\n+            return HvdcType.LCC;\n+        }\n+        return null;\n+    }\n+\n+    private static HvdcLine.ConvertersMode decodeMode(HvdcType converterType, PropertyBag cconverter1, PropertyBag cconverter2) {\n+        String mode1 = cconverter1.getLocal(OPERATING_MODE);\n+        String mode2 = cconverter2.getLocal(OPERATING_MODE);\n+\n+        if (converterType.equals(HvdcConverterStation.HvdcType.LCC)) {\n+            if (inverter(mode1) && rectifier(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            } else if (rectifier(mode1) && inverter(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER;\n+            } else {\n+                // Default if both ends are rectifier or inverter\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;", "originalCommit": "c1c5e45c91fa7f0a00d0ade62110da33225ad268", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NzE5NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398757194", "bodyText": "Done. It is only needed when target P is zero so I have changed the code to use this configuration only in this case. I have thrown an exception in other cases.", "author": "marqueslanauja", "createdAt": "2020-03-26T17:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyMTY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDIyMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397124221", "bodyText": "You should extract this constant. Where does this constant come from?", "author": "mathbagu", "createdAt": "2020-03-24T12:45:50Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;\n+    }\n+\n+    @Override\n+    public boolean valid() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void convert() {\n+\n+        // arbitrary value because there is no maxP attribute in CGMES\n+        double maxP = getMaxP(converter1.pAC, converter2.pAC, mode);\n+        missing(\"maxP\", maxP);\n+\n+        HvdcLineAdder adder = context.network().newHvdcLine()\n+            .setR(r)\n+            .setNominalV(ratedUdc)\n+            .setActivePowerSetpoint(\n+                getPDc(converter1.pAC, converter2.pAC, converter1.poleLossP, converter2.poleLossP, mode))\n+            .setMaxP(maxP)\n+            .setConvertersMode(mode)\n+            .setConverterStationId1(converter1.converterId)\n+            .setConverterStationId2(converter2.converterId);\n+        identify(adder);\n+        adder.add();\n+    }\n+\n+    private static double getMaxP(double pAC1, double pAC2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) {\n+            if (pAC1 != 0) {\n+                return 1.2 * pAC1;\n+            }\n+            return 1.2 * pAC2;\n+        }\n+        if (pAC2 != 0) {\n+            return 1.2 * pAC2;\n+        }\n+        return 1.2 * pAC1;", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1MDI4NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398750284", "bodyText": "Done. The MaxP attribute is not defined and this is the default value used in the current version. I have kept the same value in the new version. It is reasonable.", "author": "marqueslanauja", "createdAt": "2020-03-26T17:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDM1NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397124355", "bodyText": "Assert for non null values when relevant", "author": "mathbagu", "createdAt": "2020-03-24T12:46:04Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NTk4OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398745989", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-26T17:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNTE0Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397125142", "bodyText": "Same remark about log level", "author": "mathbagu", "createdAt": "2020-03-24T12:47:27Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.hvdc.forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSimetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_NONE:\n+                break;\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(ls -> hvdcEq.add(ls));\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    void print() {\n+        LOG.info(\"Hvdc\");\n+        hvdcData.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEquipment {\n+        List<HvdcConverter> converters;\n+        List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void print() {\n+            LOG.info(\"    Converters:\");\n+            this.converters.forEach(c -> c.print());\n+            LOG.info(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.info(\"    {} \", ls));\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    static class HvdcConverter {\n+        String acDcConvertersEnd1;\n+        String acDcConvertersEnd2;\n+\n+        HvdcConverter(String acDcConvertersEnd1, String acDcConvertersEnd2) {\n+            this.acDcConvertersEnd1 = acDcConvertersEnd1;\n+            this.acDcConvertersEnd2 = acDcConvertersEnd2;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    End1: {} End2: {}\", this.acDcConvertersEnd1, this.acDcConvertersEnd2);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Hvdc.class);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNTM0Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404425346", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNTE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNjg2NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397126864", "bodyText": "Are your sure about the i in simetric (I expect a y)?", "author": "mathbagu", "createdAt": "2020-03-24T12:50:28Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0Mzc0Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398743742", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-26T17:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNjg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNzIzNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397127234", "bodyText": "Same remark about log level", "author": "mathbagu", "createdAt": "2020-03-24T12:51:07Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_NONE, HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    Set<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSimetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(ls -> hvdcEnd2.dcLineSegmentsEnd.contains(ls));\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandEndHvdc\");\n+        hvdc.forEach(h -> h.print());\n+    }\n+\n+    static class HvdcEnd {\n+        List<String> topologicalNodesEnd;\n+        Set<String> transformersEnd;\n+        Set<String> acDcConvertersEnd;\n+        Set<String> dcLineSegmentsEnd;\n+\n+        HvdcEnd(List<String> topologicalNodesEnd, Set<String> transformersEnd, Set<String> acDcConvertersEnd, Set<String> dcLineSegmentsEnd) {\n+            this.topologicalNodesEnd = topologicalNodesEnd;\n+            this.transformersEnd = transformersEnd;\n+            this.acDcConvertersEnd = acDcConvertersEnd;\n+            this.dcLineSegmentsEnd = dcLineSegmentsEnd;\n+        }\n+\n+        HvdcEndType computeType() {\n+            int t = this.transformersEnd.size();\n+            int c = this.acDcConvertersEnd.size();\n+            int ls = this.dcLineSegmentsEnd.size();\n+\n+            if (t == 0 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T0_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T1_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 2) {\n+                return HvdcEndType.HVDC_T1_C1_LS2;\n+            } else if (t == 2 && c == 2 && ls == 1) {\n+                return HvdcEndType.HVDC_T2_C2_LS1;\n+            } else if (t == c && c == ls && t > 1) {\n+                return HvdcEndType.HVDC_TN_CN_LSN;\n+            }\n+            return HvdcEndType.HVDC_NONE;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    topologicalNodesEnd: {}\", this.topologicalNodesEnd);\n+            LOG.info(\"    transformersEnd: {}\", this.transformersEnd);\n+            LOG.info(\"    acDcConvertersEnd: {}\", this.acDcConvertersEnd);\n+            LOG.info(\"    dcLineSegmentsEnd: {}\", this.dcLineSegmentsEnd);\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(IslandEndHvdc.class);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNTUxMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404425511", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNzc2MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397127761", "bodyText": "Are you sure this is working properly? How is computed the hash on a List of String?", "author": "mathbagu", "createdAt": "2020-03-24T12:52:00Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final Set<List<String>> islandsNodes;", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NDIwNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398744207", "bodyText": "Done. Changed to list of list", "author": "marqueslanauja", "createdAt": "2020-03-26T17:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNzc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODA3Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397128076", "bodyText": "Is there a design issue with Adjacency class?", "author": "mathbagu", "createdAt": "2020-03-24T12:52:33Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final Set<List<String>> islandsNodes;\n+\n+    // The island includes dcTopologicalNodes and the acTopologicalNodes at both ends of the transformer\n+    Islands(Adjacency adjacency) {\n+        islandsNodes = new HashSet<>();\n+\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+        adjacency.adjacency.keySet().forEach(topologicalNodeId -> {", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2NTkzMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398765930", "bodyText": "Adjacency class is ok. I add a method to be more readable.", "author": "marqueslanauja", "createdAt": "2020-03-26T17:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODM2Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397128362", "bodyText": "Same remark about the log level", "author": "mathbagu", "createdAt": "2020-03-24T12:53:00Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final Set<List<String>> islandsNodes;\n+\n+    // The island includes dcTopologicalNodes and the acTopologicalNodes at both ends of the transformer\n+    Islands(Adjacency adjacency) {\n+        islandsNodes = new HashSet<>();\n+\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+        adjacency.adjacency.keySet().forEach(topologicalNodeId -> {\n+            if (visitedTopologicalNodes.contains(topologicalNodeId)) {\n+                return;\n+            }\n+            List<String> adjacentTopologicalNodes = computeAdjacentTopologicalNodes(topologicalNodeId,\n+                adjacency, visitedTopologicalNodes);\n+            islandsNodes.add(adjacentTopologicalNodes);\n+        });\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    Set<List<String>> getIslandsNodes() {\n+        return islandsNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"Islands\");\n+        islandsNodes.forEach(island -> LOG.info(\" {} \", island));\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(Islands.class);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNTYwOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404425608", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODc5NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397128794", "bodyText": "Same remark about log level", "author": "mathbagu", "createdAt": "2020-03-24T12:53:42Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    private final Set<IslandEnd> islandsEndsNodes;\n+\n+    // The island includes dcTopologicalNodes and first acTopologicalNode\n+    IslandsEnds() {\n+        islandsEndsNodes = new HashSet<>();\n+    }\n+\n+    void add(Adjacency adjacency, List<String> islandNodes) {\n+        if (islandNodes.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        String topologicalNodeEnd1 = islandNodes.get(0);\n+        List<String> adjacentTopologicalNodeEnd1 = computeAdjacentTopologicalNodes(topologicalNodeEnd1,\n+            adjacency, visitedTopologicalNodes);\n+\n+        String topologicalNodeEnd2 = getTopologicalNodeOtherEnd(islandNodes, visitedTopologicalNodes);\n+        if (topologicalNodeEnd2 == null) {\n+            return;\n+        }\n+        List<String> adjacentTopologicalNodeEnd2 = computeAdjacentTopologicalNodes(topologicalNodeEnd2,\n+            adjacency, visitedTopologicalNodes);\n+\n+        IslandEnd islandEnd = new IslandEnd(adjacentTopologicalNodeEnd1, adjacentTopologicalNodeEnd2);\n+\n+        islandsEndsNodes.add(islandEnd);\n+    }\n+\n+    private static String getTopologicalNodeOtherEnd(List<String> islandNodes, Set<String> visitedTopologicalNodes) {\n+        return islandNodes.stream()\n+            .filter(n -> !visitedTopologicalNodes.contains(n))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.adjacency.containsKey(topologicalNode)) {\n+                adjacency.adjacency.get(topologicalNode).forEach(adjacent -> {\n+                    if (Adjacency.isDcLineSegment(adjacent.type)) {\n+                        return;\n+                    }\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    Set<IslandEnd> getIslandsEndsNodes() {\n+        return islandsEndsNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"IslandsEnds\");\n+        islandsEndsNodes.forEach(islandEnd -> islandEnd.print());\n+    }\n+\n+    static class IslandEnd {\n+        private final List<String> topologicalNodes1;\n+        private final List<String> topologicalNodes2;\n+\n+        IslandEnd(List<String> topologicalNodes1, List<String> topologicalNodes2) {\n+            this.topologicalNodes1 = topologicalNodes1;\n+            this.topologicalNodes2 = topologicalNodes2;\n+        }\n+\n+        List<String> getTopologicalNodes1() {\n+            return topologicalNodes1;\n+        }\n+\n+        List<String> getTopologicalNodes2() {\n+            return topologicalNodes2;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    topologicalNodes1: {}\", this.topologicalNodes1);\n+            LOG.info(\"    topologicalNodes2: {}\", this.topologicalNodes2);\n+            LOG.info(\"---\");\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(IslandsEnds.class);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNTY5Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404425693", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyODc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyOTk1Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397129957", "bodyText": "Same remark about log level", "author": "mathbagu", "createdAt": "2020-03-24T12:55:36Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    private final Map<String, List<TPnodeEquipment>> nodeEquipments;\n+\n+    TPnodeEquipments(CgmesModel cgmesModel, Adjacency adjacency) {\n+        nodeEquipments = new HashMap<>();\n+\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegment(cgmesModel, adjacency, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+\n+        acDcConverterNodes.getConverterNodes().entrySet()\n+            .forEach(entry -> addEquipment(adjacency, entry.getValue().id, entry.getValue().acTopologicalNode,\n+                entry.getValue().dcTopologicalNode, EquipmentType.AC_DC_CONVERTER));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformer(cgmesModel, adjacency, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformer(cgmesModel, adjacency, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegment(CgmesModel cgmesModel, Adjacency adjacency, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+        String id = equipment.getId(\"DCLineSegment\");\n+        addEquipment(adjacency, id, t1.dcTopologicalNode(), t2.dcTopologicalNode(), EquipmentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeTwoWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void computeThreeWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String topologicalNodeId1, String topologicalNodeId2,\n+        EquipmentType type) {\n+        if (!adjacency.adjacency.containsKey(topologicalNodeId1)\n+            || !adjacency.adjacency.containsKey(topologicalNodeId2)) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(eq);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(eq);\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String acTopologicalNodeId,\n+        List<String> dcTopologicalNodeIds, EquipmentType type) {\n+        if (!adjacency.adjacency.containsKey(acTopologicalNodeId)) {\n+            return;\n+        }\n+        if (dcTopologicalNodeIds.stream().anyMatch(n -> !adjacency.adjacency.containsKey(n))) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(acTopologicalNodeId, k -> new ArrayList<>()).add(eq);\n+        dcTopologicalNodeIds.forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    private boolean isValidTransformer(Adjacency adjacency, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(n -> adjacency.containsAcDcConverter(n));\n+    }\n+\n+    private void addTransformer(Adjacency adjacency, String id, List<String> topologicalNodes, EquipmentType type) {\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        topologicalNodes.stream()\n+            .filter(n -> adjacency.adjacency.containsKey(n))\n+            .forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    boolean containsAnyTransformer(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.TRANSFORMER);\n+    }\n+\n+    boolean containsAnyAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.AC_DC_CONVERTER);\n+    }\n+\n+    boolean multiAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.type == EquipmentType.AC_DC_CONVERTER)\n+            .count() >= 2;\n+    }\n+\n+    boolean connectedEquipments(String equipment1, String equipment2, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(n -> connectedEquipment(n, equipment1, equipment2));\n+    }\n+\n+    private boolean connectedEquipment(String topologicalNode, String equipment1, String equipment2) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.equipmentId.equals(equipment1) || eq.equipmentId.equals(equipment2))\n+            .count() == 2;\n+    }\n+\n+    Map<String, List<TPnodeEquipment>> getNodeEquipments() {\n+        return nodeEquipments;\n+    }\n+\n+    void print() {\n+        LOG.info(\"TPnodeEquipments\");\n+        nodeEquipments.entrySet().forEach(k -> print(k.getKey(), k.getValue()));\n+    }\n+\n+    private void print(String tpNodeId, List<TPnodeEquipment> listTPnodeEquipment) {\n+        LOG.info(\"TopologicalNodeId: {}\", tpNodeId);\n+        listTPnodeEquipment.forEach(tpne -> tpne.print());\n+    }\n+\n+    void print(List<String> lnodes) {\n+        lnodes.forEach(n -> print(n));\n+    }\n+\n+    private void print(String node) {\n+        LOG.info(\"EQ. TopologicalNode {}\", node);\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node)\n+                .forEach(eq -> LOG.info(\"    {} {}\", eq.type, eq.equipmentId));\n+        }\n+    }\n+\n+    void printDcLs(List<String> lnodes) {\n+        lnodes.forEach(n -> printDcLs(n));\n+    }\n+\n+    private void printDcLs(String node) {\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node).stream()\n+                .filter(eq -> eq.type == TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT)\n+                .forEach(eq -> LOG.info(\"DcLineSegment {}\", eq.equipmentId));\n+        }\n+    }\n+\n+    static class TPnodeEquipment {\n+        EquipmentType type;\n+        String equipmentId;\n+\n+        TPnodeEquipment(EquipmentType type, String equipmentId) {\n+            this.type = type;\n+            this.equipmentId = equipmentId;\n+        }\n+\n+        void print() {\n+            LOG.info(\"    {} {}\", this.type, this.equipmentId);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TPnodeEquipments.class);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNTc2OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404425768", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyOTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMDU5MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397130590", "bodyText": "Why don't you assert directly the return value of the containsHvdcLine method, instead of storing the value in a variable?\nThis remark is global to this file.", "author": "mathbagu", "createdAt": "2020-03-24T12:56:36Z", "path": "cgmes/cgmes-conversion/src/test/java/com/powsybl/cgmes/conversion/test/HvdcConversionTest.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1Catalog;\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1ModifiedCatalog;\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesModelFactory;\n+import com.powsybl.cgmes.model.test.TestGridModel;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.VscConverterStation;\n+import com.powsybl.triplestore.api.TripleStoreFactory;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class HvdcConversionTest {\n+\n+    @Test\n+    public void smallNodeBreakerHvdc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NDk1Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398744953", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-26T17:12:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMDU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMTAwMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397131002", "bodyText": "Replace by assertEquals.\nThis remark is global to this file.", "author": "mathbagu", "createdAt": "2020-03-24T12:57:17Z", "path": "cgmes/cgmes-conversion/src/test/java/com/powsybl/cgmes/conversion/test/HvdcConversionTest.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1Catalog;\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1ModifiedCatalog;\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesModelFactory;\n+import com.powsybl.cgmes.model.test.TestGridModel;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.VscConverterStation;\n+import com.powsybl.triplestore.api.TripleStoreFactory;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class HvdcConversionTest {\n+\n+    @Test\n+    public void smallNodeBreakerHvdc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NTI1MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r398745251", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-03-26T17:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMjE1OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r397132159", "bodyText": "Are you sure about the log level? not a debug? not a trace?\nThis remark is global to this file", "author": "mathbagu", "createdAt": "2020-03-24T12:59:07Z", "path": "cgmes/cgmes-conversion/src/test/java/com/powsybl/cgmes/conversion/test/HvdcConversionTest.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1Catalog;\n+import com.powsybl.cgmes.conformity.test.CgmesConformity1ModifiedCatalog;\n+import com.powsybl.cgmes.conversion.Conversion;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesModelFactory;\n+import com.powsybl.cgmes.model.test.TestGridModel;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.VscConverterStation;\n+import com.powsybl.triplestore.api.TripleStoreFactory;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class HvdcConversionTest {\n+\n+    @Test\n+    public void smallNodeBreakerHvdc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1inverter2rectifier() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1inverter2rectifier(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.49261084, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.49019608, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 101.50980392156863, 122.39999999999999);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1rectifier2inverter() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcDcLine2BothConvertersTargetPpcc1rectifier2inverter(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.5, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.5025126, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 99.5, 120.0);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcDcLine2Inverter1Rectifier2() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcDcLine2Inverter1Rectifier2(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.49751243, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.4950495, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, -99.50248756218906, -120.0);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcVscReactiveQPcc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBreakerHvdcVscReactiveQPcc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 0.0, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 0.0, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcMissingDCLineSegment() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcMissingDCLineSegment(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 0);\n+        assertTrue(n.getHvdcLineCount() == 0);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcMissingAcDcConverters() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcMissingAcDcConverters(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 0);\n+        assertTrue(n.getHvdcLineCount() == 0);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcNanTargetPpcc() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcNanTargetPpcc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 0.0, 0.0);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.0, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.0, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 0.0, 0.0);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcTwoDcLineSegments() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcTwoDcLineSegments(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 5.60575, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBreakerHvdcLogOn() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        config.setHvdcConversionLogOn(true);\n+        Network n = networkModel(CgmesConformity1Catalog.smallNodeBreakerHvdc(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 4);\n+        assertTrue(n.getHvdcLineCount() == 2);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    @Test\n+    public void smallNodeBrokerHvdcTwoAcDcConvertersOneDcLineSegments() throws IOException {\n+        Conversion.Config config = new Conversion.Config();\n+        config.setHvdcConversionLogOn(true);\n+        Network n = networkModel(CgmesConformity1ModifiedCatalog.smallNodeBrokerHvdcTwoAcDcConvertersOneDcLineSegments(), config);\n+\n+        assertTrue(n.getHvdcConverterStationCount() == 6);\n+        assertTrue(n.getHvdcLineCount() == 3);\n+\n+        boolean ok;\n+        ok = containsLccConverter(n, \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"Conv1\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, 0.8);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_7393a68f-c4e6-48dd-9347-543858363fdb\", \"Conv1b\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0#0\", 0.0, 0.8);\n+        assertTrue(ok);\n+\n+        ok = containsLccConverter(n, \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+        ok = containsLccConverter(n, \"_9793118e-5ba1-4a9c-b2e0-db1d15be5913\", \"Conv2b\", \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0#0\", 0.0, -0.75741);\n+        assertTrue(ok);\n+\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68e-c4e6-48dd-9347-543858363fdb\", \"_9793118d-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_11d10c55-94cc-47e4-8e24-bc5ac4d026c0#0\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine\",\n+            \"_7393a68f-c4e6-48dd-9347-543858363fdb\", \"_9793118e-5ba1-4a9c-b2e0-db1d15be5913\", 12.3, 63.8, -76.55999999999999);\n+        assertTrue(ok);\n+\n+        ok = containsVscConverter(n, \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"VSC2\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32362458, 218.47, 0.0);\n+        assertTrue(ok);\n+        ok = containsVscConverter(n, \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", \"VSC1\", \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", 0.32467532, 213.54, 0.0);\n+        assertTrue(ok);\n+        ok = containsHvdcLine(n, \"_d9a49bc9-f4b8-4bfa-9d0f-d18f12f2575b\", HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER, \"dcLine2\",\n+            \"_b46bfb8e-7af6-459e-acf3-53a42c943a7c\", \"_b48ce7cf-abf5-413f-bc51-9e1d3103c9bd\", 8.3, 153.82467532467533, -184.2);\n+        assertTrue(ok);\n+    }\n+\n+    private Network networkModel(TestGridModel testGridModel, Conversion.Config config) throws IOException {\n+\n+        ReadOnlyDataSource ds = testGridModel.dataSource();\n+        String impl = TripleStoreFactory.defaultImplementation();\n+\n+        CgmesModel cgmes = CgmesModelFactory.create(ds, impl);\n+\n+        config.setConvertSvInjections(true);\n+        config.setProfileUsedForInitialStateValues(Conversion.Config.StateProfile.SSH.name());\n+        Conversion c = new Conversion(cgmes, config);\n+        Network n = c.convert();\n+\n+        return n;\n+    }\n+\n+    private boolean containsLccConverter(Network n, String id, String name,\n+        String hvdcLineId, double lossFactor, double powerFactor) {\n+        ReferenceHvdcConverter referenceHvdcConverter = new ReferenceHvdcConverter(id, HvdcConverterStation.HvdcType.LCC, name,\n+            hvdcLineId, lossFactor, powerFactor);\n+        return containsLccConverter(n, referenceHvdcConverter);\n+    }\n+\n+    private boolean containsLccConverter(Network n, ReferenceHvdcConverter referenceConverter) {\n+        LccConverterStation lccConverter = n.getLccConverterStation(referenceConverter.id);\n+        if (lccConverter == null) {\n+            LOG.info(\"HvdcConverterStation {} not found\", referenceConverter.id);", "originalCommit": "d18bdb6c862ff5b3ace8db62da07bab909c50ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNTg4Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404425887", "bodyText": "Done. It has been changed to debug.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMjE1OQ=="}], "type": "inlineReview"}, {"oid": "f82f0bd257897fefd9bd9acdbf710eaf00a11210", "url": "https://github.com/powsybl/powsybl-core/commit/f82f0bd257897fefd9bd9acdbf710eaf00a11210", "message": "More reviewer comments", "committedDate": "2020-03-24T15:49:59Z", "type": "commit"}, {"oid": "ccec8956e8bd4629539eae200128584187374e8b", "url": "https://github.com/powsybl/powsybl-core/commit/ccec8956e8bd4629539eae200128584187374e8b", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-24T15:50:27Z", "type": "commit"}, {"oid": "65e0b7fbb154ed2db0b5df46726f11ea2a627d01", "url": "https://github.com/powsybl/powsybl-core/commit/65e0b7fbb154ed2db0b5df46726f11ea2a627d01", "message": "Apply more reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-26T11:48:29Z", "type": "commit"}, {"oid": "791f4dbe746fdb3a87537e39c06a26ec945f75ff", "url": "https://github.com/powsybl/powsybl-core/commit/791f4dbe746fdb3a87537e39c06a26ec945f75ff", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-26T16:55:59Z", "type": "commit"}, {"oid": "4533d5e86d608260637946a662e48b291737a8e1", "url": "https://github.com/powsybl/powsybl-core/commit/4533d5e86d608260637946a662e48b291737a8e1", "message": "fix checkstyle\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-03-26T17:07:33Z", "type": "commit"}, {"oid": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "url": "https://github.com/powsybl/powsybl-core/commit/3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-03-27T11:56:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1OTMyOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r399359328", "bodyText": "What happens if only one is not NaN? Should we drop its result in any case?", "author": "MioRtia", "createdAt": "2020-03-27T15:44:30Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1, double poleLossP2) {\n+        Objects.requireNonNull(mode);\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2(double pAC2, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // pAC2 > 0\n+            this.lossFactor2 = (poleLossP2 / pAC2) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && Math.abs(pAC2) + poleLossP2 != 0) { // pAC2 < 0\n+            this.lossFactor2 = (poleLossP2 / (Math.abs(pAC2) + poleLossP2)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor1FromPAC2(double pAC2, double poleLossP1, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && (Math.abs(pAC2) + poleLossP2 + poleLossP1) != 0) { // pAC2 < 0\n+            // lossFactor1 = poleLossP1 / pAC1 * 100\n+            // pAC1 = pDC + poleLossP1 = pAC2 + poleLossP2 + poleLossP1\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC2) + poleLossP2 + poleLossP1)) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && (pAC2 - poleLossP2) != 0) { // pAC2 > 0\n+            // lossFactor1 = poleLossP1 / pDC * 100\n+            // pDC = pAC2 - poleLossP2\n+            this.lossFactor1 = (poleLossP1 / (pAC2 - poleLossP2)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2FromPAC1(double pAC1, double poleLossP1, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && (pAC1 - poleLossP1) != 0) { // pAC1 > 0\n+            // lossFactor2 = poleLossP2 / pDC * 100\n+            // pDC = pAC1 - poleLossP1\n+            this.lossFactor2 = (poleLossP2 / (pAC1 - poleLossP1)) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && (Math.abs(pAC1) + poleLossP1 + poleLossP2) != 0) { // pAC1 < 0\n+            // lossFactor2 = poleLossP2 / (pDC + poleLossP2) * 100\n+            // pDC = pAC1 + poleLossP1\n+            this.lossFactor2 = (poleLossP2 / (Math.abs(pAC1) + poleLossP1 + poleLossP2)) * 100;\n+        }\n+    }\n+\n+    boolean isOk() {\n+        return !Double.isNaN(this.lossFactor1) && !Double.isNaN(this.lossFactor2);", "originalCommit": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNjcxMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404426710", "bodyText": "Deleted. Loss Factor is always calculated. If lossFactor is NaN it is fixed to 0.0", "author": "marqueslanauja", "createdAt": "2020-04-06T22:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1OTMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAzMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r399963031", "bodyText": "Hi Jos\u00e9 Antonio, I have performed some tests on small grid case (with HVDC lines) and it seems that the attributes of the LCC converters are nor correctly set. I understand that the power factor is at its default value. It seems that the loss factor is equal too zero in IIDM in my tests, but the poleLoss in CGMES is not equal to zero. Can you check again ?", "author": "annetill", "createdAt": "2020-03-30T06:54:28Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -71,16 +79,21 @@ public void convert() {\n             // TODO: There are two modes of control: dcVoltage and activePower\n             // For dcVoltage, setpoint is targetUdc,\n             // For activePower, setpoint is targetPpcc\n+\n             LccConverterStationAdder adder = voltageLevel().newLccConverterStation()\n-                    .setLossFactor(0.0f)\n-                    .setPowerFactor(0.8f);\n+                .setLossFactor((float) this.lossFactor)", "originalCommit": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk3NTc1MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r399975750", "bodyText": "It may be linked to the fact that lossFactor is only set when both are not NaN in CGMES but I think it happens that only one side is set (cf. my question above). I think we should retrieve as much information as possible and only set to default values when there is no info.", "author": "miovd", "createdAt": "2020-03-30T07:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNjk2Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404426966", "bodyText": "Solved. Loss Factor is always calculated. If lossFactor is NaN it is fixed to 0.0", "author": "marqueslanauja", "createdAt": "2020-04-06T22:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0ODY1Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r402848656", "bodyText": "@MioRtia can you put your name here as authors ?", "author": "annetill", "createdAt": "2020-04-03T08:49:32Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */", "originalCommit": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNzEyNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404427126", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-06T22:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0ODY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0OTUwMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r402849503", "bodyText": "@MioRtia can you add your name here as authors too ?", "author": "annetill", "createdAt": "2020-04-03T08:50:26Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>", "originalCommit": "3640d8681f2b7c58e46dcb3112cd2593ca0e7429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyNzIyNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404427225", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-06T22:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0OTUwMw=="}], "type": "inlineReview"}, {"oid": "d261466ac7e3129ad2f01dc4b932ee1cbb222428", "url": "https://github.com/powsybl/powsybl-core/commit/d261466ac7e3129ad2f01dc4b932ee1cbb222428", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-04-03T18:23:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NTgzMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r403845833", "bodyText": "@geofjamg and @mathbagu I think that MaxP should be always positive too as the active power set point ? It is not the case here. so we maybe have to fix the computation.", "author": "annetill", "createdAt": "2020-04-06T05:59:37Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    private static final double DEFAULT_MAXP_FACTOR = 1.2;\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        Objects.requireNonNull(converter1);\n+        Objects.requireNonNull(converter2);\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;\n+    }\n+\n+    @Override\n+    public boolean valid() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void convert() {\n+\n+        // arbitrary value because there is no maxP attribute in CGMES\n+        double maxP = getMaxP(converter1.pAC, converter2.pAC, mode);\n+        missing(\"maxP\", maxP);\n+\n+        HvdcLineAdder adder = context.network().newHvdcLine()\n+            .setR(r)\n+            .setNominalV(ratedUdc)\n+            .setActivePowerSetpoint(\n+                getPDc(converter1.pAC, converter2.pAC, converter1.poleLossP, converter2.poleLossP, mode))\n+            .setMaxP(maxP)\n+            .setConvertersMode(mode)\n+            .setConverterStationId1(converter1.converterId)\n+            .setConverterStationId2(converter2.converterId);\n+        identify(adder);\n+        adder.add();\n+    }\n+\n+    private static double getMaxP(double pAC1, double pAC2, HvdcLine.ConvertersMode mode) {", "originalCommit": "d261466ac7e3129ad2f01dc4b932ee1cbb222428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4NzkxMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r403887911", "bodyText": "@geofjamg and @mathbagu I still have a question about PowerFactor and LossFactor that are documented as in percent unit (https://www.powsybl.org/docs/iidm/model/lccConverterStation.html). But it seems to be ratios in other parts of powsybl-core. Is it a ratio or a percentage ?", "author": "annetill", "createdAt": "2020-04-06T07:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NTgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NzA0Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r403847046", "bodyText": "Here have to fix the case SIDE_1_INVERTER_SIDE_2_RECTIFIER (pAC1 negative and PAC2 positive) so:\n\nreturn pAC2 - poleLossP2 ;\nreturn Math.abs(pAC1) + poleLossP1 ;\nWe in fact made the mistake before this PR...", "author": "annetill", "createdAt": "2020-04-06T06:03:54Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcLineSegmentConversion.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2017-2018, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.AbstractIdentifiedObjectConversion;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.HvdcLineAdder;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class DcLineSegmentConversion extends AbstractIdentifiedObjectConversion {\n+\n+    private static final double DEFAULT_MAXP_FACTOR = 1.2;\n+\n+    DcLineSegmentConversion(PropertyBag l, HvdcLine.ConvertersMode mode, double r, double ratedUdc,\n+        DcLineSegmentConverter converter1, DcLineSegmentConverter converter2, Context context) {\n+        super(\"DCLineSegment\", l, context);\n+\n+        Objects.requireNonNull(converter1);\n+        Objects.requireNonNull(converter2);\n+        this.mode = mode;\n+        this.r = r;\n+        this.ratedUdc = ratedUdc;\n+        this.converter1 = converter1;\n+        this.converter2 = converter2;\n+    }\n+\n+    @Override\n+    public boolean valid() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void convert() {\n+\n+        // arbitrary value because there is no maxP attribute in CGMES\n+        double maxP = getMaxP(converter1.pAC, converter2.pAC, mode);\n+        missing(\"maxP\", maxP);\n+\n+        HvdcLineAdder adder = context.network().newHvdcLine()\n+            .setR(r)\n+            .setNominalV(ratedUdc)\n+            .setActivePowerSetpoint(\n+                getPDc(converter1.pAC, converter2.pAC, converter1.poleLossP, converter2.poleLossP, mode))\n+            .setMaxP(maxP)\n+            .setConvertersMode(mode)\n+            .setConverterStationId1(converter1.converterId)\n+            .setConverterStationId2(converter2.converterId);\n+        identify(adder);\n+        adder.add();\n+    }\n+\n+    private static double getMaxP(double pAC1, double pAC2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) {\n+            if (pAC1 != 0) {\n+                return DEFAULT_MAXP_FACTOR * pAC1;\n+            }\n+            return DEFAULT_MAXP_FACTOR * pAC2;\n+        }\n+        if (pAC2 != 0) {\n+            return DEFAULT_MAXP_FACTOR * pAC2;\n+        }\n+        return DEFAULT_MAXP_FACTOR * pAC1;\n+    }\n+\n+    private static double getPDc(double pAC1, double pAC2, double poleLossP1, double poleLossP2,\n+        HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) {\n+            if (pAC1 != 0) {\n+                return pAC1 - poleLossP1;\n+            } else if (pAC2 != 0) {\n+                return Math.abs(pAC2) + poleLossP2;\n+            }\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) {", "originalCommit": "d261466ac7e3129ad2f01dc4b932ee1cbb222428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyODU0Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404428547", "bodyText": "Done. You are right it was a mistake.", "author": "marqueslanauja", "createdAt": "2020-04-06T22:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NzA0Ng=="}], "type": "inlineReview"}, {"oid": "8c48fc9e1126d52ada8d719a05d5413524ed0c70", "url": "https://github.com/powsybl/powsybl-core/commit/8c48fc9e1126d52ada8d719a05d5413524ed0c70", "message": "Change Log to debug\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-04-06T15:13:58Z", "type": "commit"}, {"oid": "5e1f02bc9fd96d3e913a3e0fe75650ecfefc1c68", "url": "https://github.com/powsybl/powsybl-core/commit/5e1f02bc9fd96d3e913a3e0fe75650ecfefc1c68", "message": "Merge branch 'cgmes_conversion_HVDC' of https://github.com/powsybl/powsybl-core into cgmes_conversion_HVDC", "committedDate": "2020-04-06T15:14:33Z", "type": "commit"}, {"oid": "41602d6c75414f4f884d1d8297214218e85d59e7", "url": "https://github.com/powsybl/powsybl-core/commit/41602d6c75414f4f884d1d8297214218e85d59e7", "message": "Active power and maxP always positive.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-04-06T22:21:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODE3OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588178", "bodyText": "You have to remove the multiplying by 100.", "author": "annetill", "createdAt": "2020-04-07T07:19:00Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;", "originalCommit": "41602d6c75414f4f884d1d8297214218e85d59e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNDQxOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404734418", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-07T11:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODY5Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588692", "bodyText": "You have to remove the multiplying by 100. We made a mistake before because the documentation is wrong. LossFactor is a ratio.", "author": "annetill", "createdAt": "2020-04-07T07:19:56Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;", "originalCommit": "41602d6c75414f4f884d1d8297214218e85d59e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNTI1OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404735258", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-07T11:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODgzMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588831", "bodyText": "Same remark.", "author": "annetill", "createdAt": "2020-04-07T07:20:13Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2(double pAC2, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // pAC2 > 0\n+            this.lossFactor2 = (poleLossP2 / pAC2) * 100;", "originalCommit": "41602d6c75414f4f884d1d8297214218e85d59e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNTQ5Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404735496", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-07T11:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODk0Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404588946", "bodyText": "Same remark.", "author": "annetill", "createdAt": "2020-04-07T07:20:27Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/LossFactor.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.iidm.network.HvdcLine;\n+\n+/**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+class LossFactor {\n+\n+    LossFactor(Context context, HvdcLine.ConvertersMode mode, double pAC1, double pAC2, double poleLossP1,\n+        double poleLossP2) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(mode);\n+        this.context = context;\n+        this.mode = mode;\n+        this.pAC1 = pAC1;\n+        this.pAC2 = pAC2;\n+        this.poleLossP1 = poleLossP1;\n+        this.poleLossP2 = poleLossP2;\n+        this.lossFactor1 = Double.NaN;\n+        this.lossFactor2 = Double.NaN;\n+    }\n+\n+    void compute() {\n+        // compute loss factors\n+\n+        if (pAC1 != 0 && pAC2 != 0) {\n+\n+            // we only keep one as we are not sure if pAC1 and pAC2 are consistent\n+            if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // we ignore pAC2\n+                computeLossFactor1(pAC1, poleLossP1, mode);\n+                computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+            } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // we ignore pAC1\n+                computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+                computeLossFactor2(pAC2, poleLossP2, mode);\n+            }\n+        } else if (pAC1 != 0) { // pAC2 == 0\n+\n+            computeLossFactor1(pAC1, poleLossP1, mode);\n+            computeLossFactor2FromPAC1(pAC1, poleLossP1, poleLossP2, mode);\n+        } else if (pAC2 != 0) { // pAC1 == 0\n+\n+            computeLossFactor1FromPAC2(pAC2, poleLossP1, poleLossP2, mode);\n+            computeLossFactor2(pAC2, poleLossP2, mode);\n+        } else {\n+            this.lossFactor1 = 0.0;\n+            this.lossFactor2 = 0.0;\n+        }\n+\n+        if (Double.isNaN(this.lossFactor1)) {\n+            this.lossFactor1 = 0.0;\n+            context.fixed(\"lossFactor1\", \"was NaN\", Double.NaN, this.lossFactor1);\n+        }\n+        if (Double.isNaN(this.lossFactor2)) {\n+            this.lossFactor2 = 0.0;\n+            context.fixed(\"lossFactor2\", \"was NaN\", Double.NaN, this.lossFactor2);\n+        }\n+\n+        // else (i.e. pAC1 == 0 && pAC2 == 0) do nothing: loss factors are null and\n+        // stations are probably disconnected\n+    }\n+\n+    private void computeLossFactor1(double pAC1, double poleLossP1, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER)) { // pAC1 > 0\n+            this.lossFactor1 = (poleLossP1 / pAC1) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER) && Math.abs(pAC1) + poleLossP1 != 0) { // pAC1 < 0\n+            this.lossFactor1 = (poleLossP1 / (Math.abs(pAC1) + poleLossP1)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor2(double pAC2, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER)) { // pAC2 > 0\n+            this.lossFactor2 = (poleLossP2 / pAC2) * 100;\n+        } else if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && Math.abs(pAC2) + poleLossP2 != 0) { // pAC2 < 0\n+            this.lossFactor2 = (poleLossP2 / (Math.abs(pAC2) + poleLossP2)) * 100;\n+        }\n+    }\n+\n+    private void computeLossFactor1FromPAC2(double pAC2, double poleLossP1, double poleLossP2, HvdcLine.ConvertersMode mode) {\n+        if (mode.equals(HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER) && (Math.abs(pAC2) + poleLossP2 + poleLossP1) != 0) { // pAC2 < 0\n+            // lossFactor1 = poleLossP1 / pAC1 * 100", "originalCommit": "41602d6c75414f4f884d1d8297214218e85d59e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNTYwNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r404735604", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-07T11:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4ODk0Ng=="}], "type": "inlineReview"}, {"oid": "a79e8ae46227cd8019579bdb58042c013ae0bc60", "url": "https://github.com/powsybl/powsybl-core/commit/a79e8ae46227cd8019579bdb58042c013ae0bc60", "message": "LossFactor in the closed interval [0,1]. Fix flipflop between lossFactor and poleLoss.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-04-07T11:22:59Z", "type": "commit"}, {"oid": "6a4824e099200b2c0b6798d7bf553c07879f7de2", "url": "https://github.com/powsybl/powsybl-core/commit/6a4824e099200b2c0b6798d7bf553c07879f7de2", "message": "Merge branch 'master' into cgmes_conversion_HVDC\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/DcLineSegmentConversion.java", "committedDate": "2020-04-07T11:37:00Z", "type": "commit"}, {"oid": "763e0ee7668f02cc0de8d93bc282ec7e82ecd854", "url": "https://github.com/powsybl/powsybl-core/commit/763e0ee7668f02cc0de8d93bc282ec7e82ecd854", "message": "Fix code smell\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-04-07T16:54:48Z", "type": "commit"}, {"oid": "a23322a7f7cac942277094313a3b74747d868b25", "url": "https://github.com/powsybl/powsybl-core/commit/a23322a7f7cac942277094313a3b74747d868b25", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-04-07T17:06:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM3MDgyNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405370826", "bodyText": "Is this really INFO or DEBUG or TRACE?", "author": "MioRtia", "createdAt": "2020-04-08T09:04:16Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    Map<String, AcDcConverterNode> getConverterNodes() {\n+        return converterNodes;\n+    }\n+\n+    void print() {\n+        LOG.info(\"AcDcConverterNodes\");\n+        converterNodes.forEach((key, value) -> LOG.info(\" {} {} {} {}\", key, value.id,\n+                value.acTopologicalNode, value.dcTopologicalNode));", "originalCommit": "a23322a7f7cac942277094313a3b74747d868b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwNzI0NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406007244", "bodyText": "should be DEBUG", "author": "zamarrenolm", "createdAt": "2020-04-09T07:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM3MDgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4NTE4MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406085181", "bodyText": "Deleted. It was not used.", "author": "marqueslanauja", "createdAt": "2020-04-09T09:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM3MDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5NTIwNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405395207", "bodyText": "Since this constructor is public:\nthis.context = Objects.requireNonNull(context);", "author": "MioRtia", "createdAt": "2020-04-08T09:42:28Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcMapping.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.*;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+public class DcMapping {\n+\n+    public DcMapping(Context context) {\n+        this.context = context;", "originalCommit": "a23322a7f7cac942277094313a3b74747d868b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4NTI3OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406085279", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-09T09:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5NTIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5NjQ5Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405396492", "bodyText": "maybe simply rename as used()? It is weird to have a set method without parameters.", "author": "MioRtia", "createdAt": "2020-04-08T09:44:28Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/DcMapping.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.*;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+\n+public class DcMapping {\n+\n+    public DcMapping(Context context) {\n+        this.context = context;\n+        this.cgmesConverters = new HashMap<>();\n+        this.cgmesDcLineSegments = new HashMap<>();\n+    }\n+\n+    public void initialize() {\n+        context.cgmes().acDcConverters()\n+            .forEach(pb -> this.cgmesConverters.put(pb.getId(\"ACDCConverter\"), new CgmesConverter(pb)));\n+        context.cgmes().dcLineSegments()\n+            .forEach(pb -> this.cgmesDcLineSegments.put(pb.getId(\"DCLineSegment\"), new CgmesDcLineSegment(pb)));\n+    }\n+\n+    PropertyBag getCgmesConverterPropertyBag(String id) {\n+        CgmesConverter cgmesConverter = this.cgmesConverters.get(id);\n+        if (cgmesConverter != null) {\n+            return cgmesConverter.propertyBag;\n+        }\n+        return null;\n+    }\n+\n+    void setCgmesConverterUsed(String id) {\n+        CgmesConverter cgmesConverter = this.cgmesConverters.get(id);\n+        if (cgmesConverter != null) {\n+            cgmesConverter.setUsed();\n+        }\n+    }\n+\n+    void reportCgmesConvertersNotUsed() {\n+        this.cgmesConverters.entrySet().stream()\n+            .filter(c -> !c.getValue().used)\n+            .forEach(c -> {\n+                String what = String.format(\"AcDcConverter Id: %s\", c.getKey());\n+                context.ignored(what, \"Dc configuration not supported\");\n+            });\n+    }\n+\n+    PropertyBag getCgmesDcLineSegmentPropertyBag(String id) {\n+        CgmesDcLineSegment cgmesDcLineSegment = this.cgmesDcLineSegments.get(id);\n+        if (cgmesDcLineSegment != null) {\n+            return cgmesDcLineSegment.propertyBag;\n+        }\n+        return null;\n+    }\n+\n+    void setCgmesDcLineSegmentUsed(String id) {\n+        CgmesDcLineSegment cgmesDcLineSegment = this.cgmesDcLineSegments.get(id);\n+        if (cgmesDcLineSegment != null) {\n+            cgmesDcLineSegment.setUsed();\n+        }\n+    }\n+\n+    void reportCgmesDcLineSegmentNotUsed() {\n+        this.cgmesDcLineSegments.entrySet().stream()\n+            .filter(c -> !c.getValue().used)\n+            .forEach(c -> {\n+                String what = String.format(\"DcLineSegment Id: %s\", c.getKey());\n+                context.ignored(what, \"Ground DcLineSegment or Dc configuration not supported\");\n+            });\n+    }\n+\n+    private static class CgmesConverter {\n+        private PropertyBag propertyBag;\n+        private boolean used;\n+\n+        CgmesConverter(PropertyBag propertyBag) {\n+            this.propertyBag = propertyBag;\n+            this.used = false;\n+        }\n+\n+        void setUsed() {\n+            this.used = true;\n+        }\n+    }\n+\n+    private static class CgmesDcLineSegment {\n+        private PropertyBag propertyBag;\n+        private boolean used;\n+\n+        CgmesDcLineSegment(PropertyBag propertyBag) {\n+            this.propertyBag = propertyBag;\n+            this.used = false;\n+        }\n+\n+        void setUsed() {", "originalCommit": "a23322a7f7cac942277094313a3b74747d868b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4NTM5NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406085394", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-09T09:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM5NjQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQxOTkyNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r405419927", "bodyText": "You only use the values of entries here, can you just use getConverterNodes().values().forEach(...)?", "author": "MioRtia", "createdAt": "2020-04-08T10:23:55Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    private final Map<String, List<TPnodeEquipment>> nodeEquipments;\n+\n+    TPnodeEquipments(CgmesModel cgmesModel, Adjacency adjacency) {\n+        nodeEquipments = new HashMap<>();\n+\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegment(cgmesModel, adjacency, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+\n+        acDcConverterNodes.getConverterNodes().entrySet()\n+            .forEach(entry -> addEquipment(adjacency, entry.getValue().id, entry.getValue().acTopologicalNode,", "originalCommit": "a23322a7f7cac942277094313a3b74747d868b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4NTU0Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406085542", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-09T09:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQxOTkyNw=="}], "type": "inlineReview"}, {"oid": "cb707bc481d6a66fbb467c9ee824ae22915175f5", "url": "https://github.com/powsybl/powsybl-core/commit/cb707bc481d6a66fbb467c9ee824ae22915175f5", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-04-09T08:48:57Z", "type": "commit"}, {"oid": "febd0943ea8eaa1a78db31084cf8ed798d0956ab", "url": "https://github.com/powsybl/powsybl-core/commit/febd0943ea8eaa1a78db31084cf8ed798d0956ab", "message": "Apply reviewer comments.\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-04-09T09:32:16Z", "type": "commit"}, {"oid": "5724423fce1858f4b4319f14a72a54b2a45125f9", "url": "https://github.com/powsybl/powsybl-core/commit/5724423fce1858f4b4319f14a72a54b2a45125f9", "message": "Merge branch 'cgmes_conversion_HVDC' of https://github.com/powsybl/powsybl-core into cgmes_conversion_HVDC", "committedDate": "2020-04-09T09:32:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NjE2Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406646167", "bodyText": "Write these two lines on a single line.", "author": "mathbagu", "createdAt": "2020-04-10T07:48:00Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -5,25 +5,39 @@\n  * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n  */\n \n-package com.powsybl.cgmes.conversion.elements;\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n \n import java.util.Objects;\n \n import com.powsybl.cgmes.conversion.Context;\n-import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.cgmes.conversion.elements.AbstractConductingEquipmentConversion;\n import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.iidm.network.LccConverterStation;\n import com.powsybl.iidm.network.LccConverterStationAdder;\n+import com.powsybl.iidm.network.VscConverterStation;\n import com.powsybl.iidm.network.VscConverterStationAdder;\n import com.powsybl.triplestore.api.PropertyBag;\n \n /**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n public class AcDcConverterConversion extends AbstractConductingEquipmentConversion {\n \n-    public AcDcConverterConversion(PropertyBag c, Context context) {\n+    private static final double DEFAULT_POWER_FACTOR = 0.8;\n+\n+    enum VscRegulation {\n+        REACTIVE_POWER,\n+        VOLTAGE\n+    }\n+\n+    public AcDcConverterConversion(PropertyBag c, HvdcType converterType, double lossFactor, Context context) {\n         super(\"ACDCConverter\", c, context);\n-        converterType = decodeType(p.getLocal(\"type\"));\n+\n+        Objects.requireNonNull(converterType);\n+        this.converterType = converterType;", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwMjg1Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408002853", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-14T09:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NjE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NjUwMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406646500", "bodyText": "Is this method really private package? If it is used only in subclasses, make it protected. It is used only here, make it private.", "author": "mathbagu", "createdAt": "2020-04-10T07:48:57Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    Map<String, AcDcConverterNode> getConverterNodes() {\n+        return converterNodes;\n+    }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwNDMxOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408004318", "bodyText": "This method is used in the package, I think the default visibility is ok.", "author": "marqueslanauja", "createdAt": "2020-04-14T09:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0Njk1MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406646951", "bodyText": "Refactor using computeIfPresent?", "author": "mathbagu", "createdAt": "2020-04-10T07:50:21Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNDU3NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408014574", "bodyText": "I am not updating converterNodes, I am updating acDcConverter and I only want to update it if it has been previously inserted into the hash table.", "author": "marqueslanauja", "createdAt": "2020-04-14T09:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0Njk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NzA2NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406647064", "bodyText": "Are you sure about the visibility of this class?", "author": "mathbagu", "createdAt": "2020-04-10T07:50:41Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterNodes.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class AcDcConverterNodes {\n+    private final Map<String, AcDcConverterNode> converterNodes;\n+\n+    AcDcConverterNodes(CgmesModel cgmesModel) {\n+        this.converterNodes = new HashMap<>();\n+\n+        cgmesModel.acDcConverters().forEach(c -> computeAcDcConverter(cgmesModel, c));\n+        cgmesModel.dcTerminals().forEach(this::computeDcTerminalToAcDcConverter);\n+    }\n+\n+    private void computeAcDcConverter(CgmesModel cgmesModel, PropertyBag c) {\n+        String id = c.getId(\"ACDCConverter\");\n+        CgmesTerminal t = cgmesModel.terminal(c.getId(\"Terminal\"));\n+        String acTopologicalNode = t.topologicalNode();\n+\n+        converterNodes.computeIfAbsent(id, k -> new AcDcConverterNode(id, acTopologicalNode));\n+    }\n+\n+    private void computeDcTerminalToAcDcConverter(PropertyBag t) {\n+        CgmesDcTerminal dcTerminal = new CgmesDcTerminal(t);\n+        if (dcTerminal.dcConductingEquipmentType().equals(\"CsConverter\") ||\n+            dcTerminal.dcConductingEquipmentType().equals(\"VsConverter\")) {\n+\n+            AcDcConverterNode acDcConverter = converterNodes.get(dcTerminal.dcConductingEquipment());\n+            if (acDcConverter != null) {\n+                acDcConverter.addDcTopologicalNode(dcTerminal.dcTopologicalNode());\n+            }\n+        }\n+    }\n+\n+    Map<String, AcDcConverterNode> getConverterNodes() {\n+        return converterNodes;\n+    }\n+\n+    static class AcDcConverterNode {", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxMDgxMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408010811", "bodyText": "It is used in the package.", "author": "marqueslanauja", "createdAt": "2020-04-14T09:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NzA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0Nzg0NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406647845", "bodyText": "Assert that debug is enabled to avoid performance issue", "author": "mathbagu", "createdAt": "2020-04-10T07:53:08Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    private final Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.getConverterNodes()\n+            .forEach((key, value) -> computeAcDcConverterAdjacency(value.acTopologicalNode,\n+                value.dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else {\n+                throw new PowsyblException(String.format(\"Unexpected TransformerEnds: ends %d\", ends.size()));\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode()));\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode(), t3.topologicalNode()));\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(this::containsAcDcConverter)) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    Map<String, List<Adjacent>> get() {\n+        return adjacency;\n+    }\n+\n+    boolean isEmpty() {\n+        return adjacency.isEmpty();\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Adjacency\");\n+        adjacency.forEach(this::debug);\n+    }\n+\n+    private void debug(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.debug(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(Adjacent::debug);\n+    }\n+\n+    void debug(List<String> lnodes) {\n+        lnodes.forEach(this::debug);\n+    }\n+\n+    private void debug(String node) {\n+        LOG.debug(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.debug(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxOTE2OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408019168", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled. There is not performance issue.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0Nzg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NzkwNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406647906", "bodyText": "Check that log is enabled", "author": "mathbagu", "createdAt": "2020-04-10T07:53:20Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    private final Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.getConverterNodes()\n+            .forEach((key, value) -> computeAcDcConverterAdjacency(value.acTopologicalNode,\n+                value.dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else {\n+                throw new PowsyblException(String.format(\"Unexpected TransformerEnds: ends %d\", ends.size()));\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }\n+    }\n+\n+    private void computeTwoWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode()));\n+    }\n+\n+    private void computeThreeWindingsTransformerAdjacency(CgmesModel cgmesModel, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        addTransformerAdjacency(Arrays.asList(t1.topologicalNode(), t2.topologicalNode(), t3.topologicalNode()));\n+    }\n+\n+    private void addTransformerAdjacency(List<String> topologicalNodes) {\n+        if (topologicalNodes.stream().anyMatch(this::containsAcDcConverter)) {\n+            for (int k = 0; k < topologicalNodes.size() - 1; k++) {\n+                String topologicalNode = topologicalNodes.get(k);\n+                for (int l = k + 1; l < topologicalNodes.size(); l++) {\n+                    addAdjacency(topologicalNode, topologicalNodes.get(l), AdjacentType.AC_TRANSFORMER);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addAdjacency(String topologicalNodeId1, String topologicalNodeId2, AdjacentType type) {\n+        Adjacent ad1 = new Adjacent(type, topologicalNodeId1);\n+        Adjacent ad2 = new Adjacent(type, topologicalNodeId2);\n+        adjacency.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(ad2);\n+        adjacency.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(ad1);\n+    }\n+\n+    boolean containsAcDcConverter(String topologicalNodeId) {\n+        if (adjacency.containsKey(topologicalNodeId)) {\n+            return adjacency.get(topologicalNodeId).stream().anyMatch(ad -> isAcDcConverter(ad.type));\n+        }\n+        return false;\n+    }\n+\n+    static boolean isDcLineSegment(AdjacentType type) {\n+        return type == AdjacentType.DC_LINE_SEGMENT;\n+    }\n+\n+    static boolean isAcDcConverter(AdjacentType type) {\n+        return type == AdjacentType.AC_DC_CONVERTER;\n+    }\n+\n+    Map<String, List<Adjacent>> get() {\n+        return adjacency;\n+    }\n+\n+    boolean isEmpty() {\n+        return adjacency.isEmpty();\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Adjacency\");\n+        adjacency.forEach(this::debug);\n+    }\n+\n+    private void debug(String topologicalNodeId, List<Adjacent> adjacent) {\n+        LOG.debug(\"TopologicalNodeId {}\", topologicalNodeId);\n+        adjacent.forEach(Adjacent::debug);\n+    }\n+\n+    void debug(List<String> lnodes) {\n+        lnodes.forEach(this::debug);\n+    }\n+\n+    private void debug(String node) {\n+        LOG.debug(\"AD TopologicalNode {}\", node);\n+        if (adjacency.containsKey(node)) {\n+            adjacency.get(node).forEach(ad -> LOG.debug(\"    {} {}\", ad.type, ad.topologicalNode));\n+        }\n+    }\n+\n+    static class Adjacent {\n+        AdjacentType type;\n+        String topologicalNode;\n+\n+        Adjacent(AdjacentType type, String topologicalNode) {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(topologicalNode);\n+            this.type = type;\n+            this.topologicalNode = topologicalNode;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    {}  {}\", this.type, this.topologicalNode);\n+        }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMTIzMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408021230", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled. There is not performance issue.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:09:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NzkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODI2NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406648264", "bodyText": "Merge these lines. Objects.requireNonNull() return the parameter value to make it possible to write: this.context = Objects.requireNonNull(context);", "author": "mathbagu", "createdAt": "2020-04-10T07:54:23Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxOTcwMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408019701", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-14T10:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk1NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406648955", "bodyText": "There is no need of the ok variable:\nif (!convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId)) {\n     return\n}\n\nand\nif (createHvdc()) {\n    setCommonDataUsed();\n}", "author": "mathbagu", "createdAt": "2020-04-10T07:56:10Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.getIslandsNodes().forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.getHvdcData().forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+\n+        if (LOG.isDebugEnabled()) {\n+            debugHvdc(adjacency, tpNodeEquipments, islands, islandsEnds, hvdc);\n+        }\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTE1NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406649155", "bodyText": "This remark could be applied globally to this file.", "author": "mathbagu", "createdAt": "2020-04-10T07:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxOTk3Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408019973", "bodyText": "done", "author": "marqueslanauja", "createdAt": "2020-04-14T10:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTQ1Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406649452", "bodyText": "Maybe we should throw an exception in that case", "author": "mathbagu", "createdAt": "2020-04-10T07:57:39Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.getIslandsNodes().forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.getHvdcData().forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+\n+        if (LOG.isDebugEnabled()) {\n+            debugHvdc(adjacency, tpNodeEquipments, islands, islandsEnds, hvdc);\n+        }\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId1, String dcLineSegmentId2) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId1);\n+        if (!ok) {\n+            return;\n+        }\n+        PropertyBag dcLineSegment2 = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId2);\n+        if (dcLineSegment2 == null) {\n+            return;\n+        }\n+        this.r = 1.0 / (1.0 / computeR(this.dcLineSegment) + 1.0 / computeR(dcLineSegment2));\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+            context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId2);\n+        }\n+    }\n+\n+    private void setCommonDataUsed() {\n+        context.dc().setCgmesConverterUsed(converter1Id);\n+        context.dc().setCgmesConverterUsed(converter2Id);\n+        context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId);\n+    }\n+\n+    private boolean convertCommonData(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        this.converter1Id = acDcConverterIdEnd1;\n+        this.cconverter1 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd1);\n+        this.converter2Id = acDcConverterIdEnd2;\n+        this.cconverter2 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd2);\n+        this.dcLineSegmentId = dcLineSegmentId;\n+        this.dcLineSegment = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId);\n+        if (this.cconverter1 == null || this.cconverter2 == null || this.dcLineSegment == null) {\n+            return false;\n+        }\n+        this.converterType = decodeType(this.cconverter1.getLocal(TYPE));\n+        if (this.converterType == null || converterType != decodeType(this.cconverter2.getLocal(TYPE))) {\n+            return false;\n+        }\n+        this.operatingMode = decodeMode(this.converterType, this.cconverter1, this.cconverter2);\n+        this.ratedUdc = computeRatedUdc(this.cconverter1, this.cconverter2);\n+\n+        return true;\n+    }\n+\n+    private static HvdcType decodeType(String stype) {\n+        if (stype.equals(\"VsConverter\")) {\n+            return HvdcType.VSC;\n+        } else if (stype.equals(\"CsConverter\")) {\n+            return HvdcType.LCC;\n+        }\n+        return null;", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMTM4OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408021389", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-14T10:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTg3NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406649874", "bodyText": "See above: maybe test the log level here", "author": "mathbagu", "createdAt": "2020-04-10T07:58:46Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/CgmesDcConversion.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.Context;\n+import com.powsybl.cgmes.conversion.elements.hvdc.DcLineSegmentConversion.DcLineSegmentConverter;\n+import com.powsybl.cgmes.conversion.elements.hvdc.Hvdc.HvdcConverter;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.iidm.network.HvdcLine;\n+import com.powsybl.iidm.network.LccConverterStation;\n+import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.triplestore.api.PropertyBag;\n+\n+/**\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+public class CgmesDcConversion {\n+\n+    private static final String TYPE = \"type\";\n+    private static final String TARGET_PPCC = \"targetPpcc\";\n+    private static final String POLE_LOSS_P = \"poleLossP\";\n+    private static final String OPERATING_MODE = \"operatingMode\";\n+\n+    public CgmesDcConversion(CgmesModel cgmes, Context context) {\n+        Objects.requireNonNull(cgmes);\n+        Objects.requireNonNull(context);\n+        this.cgmesModel = cgmes;\n+        this.context = context;\n+    }\n+\n+    public void convert() {\n+\n+        // Get hvdc configurations\n+        Adjacency adjacency = new Adjacency(cgmesModel);\n+        if (adjacency.isEmpty()) {\n+            return;\n+        }\n+        TPnodeEquipments tpNodeEquipments = new TPnodeEquipments(cgmesModel, adjacency);\n+        Islands islands = new Islands(adjacency);\n+\n+        IslandsEnds islandsEnds = new IslandsEnds();\n+        islands.getIslandsNodes().forEach(listNodes -> islandsEnds.add(adjacency, listNodes));\n+\n+        Hvdc hvdc = new Hvdc();\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            hvdc.add(tpNodeEquipments, islandEndHvdc1, islandEndHvdc2);\n+        });\n+\n+        // Convert to IIDM each converter - dcLineSegment configuration\n+        hvdc.getHvdcData().forEach(h -> convert(h.converters, h.dcLineSegments));\n+\n+        // warnings\n+        context.dc().reportCgmesConvertersNotUsed();\n+        context.dc().reportCgmesDcLineSegmentNotUsed();\n+\n+        if (LOG.isDebugEnabled()) {\n+            debugHvdc(adjacency, tpNodeEquipments, islands, islandsEnds, hvdc);\n+        }\n+    }\n+\n+    private void convert(List<HvdcConverter> converters, List<String> dcLineSegments) {\n+        int converterNum = converters.size();\n+        int dcLineSegmentNum = dcLineSegments.size();\n+\n+        if (converterNum == 1 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 2 && dcLineSegmentNum == 1) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0));\n+            convert(converters.get(1).acDcConvertersEnd1, converters.get(1).acDcConvertersEnd2, dcLineSegments.get(0));\n+        } else if (converterNum == 1 && dcLineSegmentNum == 2) {\n+            convert(converters.get(0).acDcConvertersEnd1, converters.get(0).acDcConvertersEnd2, dcLineSegments.get(0), dcLineSegments.get(1));\n+        } else {\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Converters %d DcLineSegments %d\",\n+                converterNum, dcLineSegmentNum));\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId);\n+        if (!ok) {\n+            return;\n+        }\n+        this.r = computeR(this.dcLineSegment);\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+        }\n+    }\n+\n+    private void convert(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId1, String dcLineSegmentId2) {\n+        boolean ok = convertCommonData(acDcConverterIdEnd1, acDcConverterIdEnd2, dcLineSegmentId1);\n+        if (!ok) {\n+            return;\n+        }\n+        PropertyBag dcLineSegment2 = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId2);\n+        if (dcLineSegment2 == null) {\n+            return;\n+        }\n+        this.r = 1.0 / (1.0 / computeR(this.dcLineSegment) + 1.0 / computeR(dcLineSegment2));\n+\n+        ok = createHvdc();\n+        if (ok) {\n+            setCommonDataUsed();\n+            context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId2);\n+        }\n+    }\n+\n+    private void setCommonDataUsed() {\n+        context.dc().setCgmesConverterUsed(converter1Id);\n+        context.dc().setCgmesConverterUsed(converter2Id);\n+        context.dc().setCgmesDcLineSegmentUsed(dcLineSegmentId);\n+    }\n+\n+    private boolean convertCommonData(String acDcConverterIdEnd1, String acDcConverterIdEnd2, String dcLineSegmentId) {\n+        this.converter1Id = acDcConverterIdEnd1;\n+        this.cconverter1 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd1);\n+        this.converter2Id = acDcConverterIdEnd2;\n+        this.cconverter2 = context.dc().getCgmesConverterPropertyBag(acDcConverterIdEnd2);\n+        this.dcLineSegmentId = dcLineSegmentId;\n+        this.dcLineSegment = context.dc().getCgmesDcLineSegmentPropertyBag(dcLineSegmentId);\n+        if (this.cconverter1 == null || this.cconverter2 == null || this.dcLineSegment == null) {\n+            return false;\n+        }\n+        this.converterType = decodeType(this.cconverter1.getLocal(TYPE));\n+        if (this.converterType == null || converterType != decodeType(this.cconverter2.getLocal(TYPE))) {\n+            return false;\n+        }\n+        this.operatingMode = decodeMode(this.converterType, this.cconverter1, this.cconverter2);\n+        this.ratedUdc = computeRatedUdc(this.cconverter1, this.cconverter2);\n+\n+        return true;\n+    }\n+\n+    private static HvdcType decodeType(String stype) {\n+        if (stype.equals(\"VsConverter\")) {\n+            return HvdcType.VSC;\n+        } else if (stype.equals(\"CsConverter\")) {\n+            return HvdcType.LCC;\n+        }\n+        return null;\n+    }\n+\n+    private static HvdcLine.ConvertersMode decodeMode(HvdcType converterType, PropertyBag cconverter1, PropertyBag cconverter2) {\n+        String mode1 = cconverter1.getLocal(OPERATING_MODE);\n+        String mode2 = cconverter2.getLocal(OPERATING_MODE);\n+\n+        if (converterType.equals(HvdcConverterStation.HvdcType.LCC)) {\n+            if (inverter(mode1) && rectifier(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            } else if (rectifier(mode1) && inverter(mode2)) {\n+                return HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER;\n+            } else if (cconverter1.asDouble(TARGET_PPCC) == 0 && cconverter2.asDouble(TARGET_PPCC) == 0) {\n+                // Both ends are rectifier or inverter\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            }\n+        } else {\n+            if (cconverter1.asDouble(TARGET_PPCC) > 0 || cconverter2.asDouble(TARGET_PPCC) < 0) {\n+                return HvdcLine.ConvertersMode.SIDE_1_RECTIFIER_SIDE_2_INVERTER;\n+            } else {\n+                return HvdcLine.ConvertersMode.SIDE_1_INVERTER_SIDE_2_RECTIFIER;\n+            }\n+        }\n+        throw new PowsyblException(\"Unexpected HVDC type: \" + converterType);\n+    }\n+\n+    private static boolean inverter(String operatingMode) {\n+        return operatingMode.toLowerCase().endsWith(\"inverter\");\n+    }\n+\n+    private static boolean rectifier(String operatingMode) {\n+        return operatingMode.toLowerCase().endsWith(\"rectifier\");\n+    }\n+\n+    private double computeR(PropertyBag dcLs) {\n+        double rDcLink = dcLs.asDouble(\"r\", 0);\n+        if (rDcLink < 0) {\n+            double rDcLink1 = 0.1;\n+            context.fixed(\"resistance\", \"was negative\", rDcLink, rDcLink1);\n+            rDcLink = rDcLink1;\n+        }\n+        return rDcLink;\n+    }\n+\n+    private static double computeRatedUdc(PropertyBag cconverter1, PropertyBag cconverter2) {\n+        double ratedUdc1 = cconverter1.asDouble(CgmesNames.RATED_UDC);\n+        double ratedUdc2 = cconverter2.asDouble(CgmesNames.RATED_UDC);\n+        if (ratedUdc1 != 0) {\n+            return ratedUdc1;\n+        }\n+        return ratedUdc2;\n+    }\n+\n+    private boolean createHvdc() {\n+\n+        // poleLossP is the active power loss at a DC Pole\n+        // for lossless operation: P(DC) = P(AC) => lossFactor = 0\n+        // for rectifier operation (conversion from AC to DC) with losses: P(DC) = P(AC) - poleLossP\n+        // In IIDM, for rectifier operation P(DC) / P(AC) = 1 - lossFactor\n+        // => P(DC) / P(AC) = 1 - poleLossP / P(AC) = 1 - lossFactor\n+        // for inverter operation (conversion from DC to AC) with losses: P(DC) = P(AC) + poleLossP\n+        // In IIDM, for inverter operation P(AC) / P(DC) = 1 - lossFactor\n+        // => P(AC) / P(DC) = 1 - poleLossP / P(DC) = 1 - poleLossP / (P(AC) + poleLossP) = 1 - lossFactor\n+\n+        double poleLossP1 = cconverter1.asDouble(POLE_LOSS_P);\n+        double poleLossP2 = cconverter2.asDouble(POLE_LOSS_P);\n+\n+        // load sign convention is used i.e. positive sign means flow out from a node\n+        // i.e. pACx >= 0 if converterx is rectifier and pACx <= 0 if converterx is\n+        // inverter\n+\n+        double pAC1 = getPAc(cconverter1);\n+        double pAC2 = getPAc(cconverter2);\n+\n+        LossFactor lossFactor = new LossFactor(context, operatingMode, pAC1, pAC2, poleLossP1, poleLossP2);\n+        lossFactor.compute();\n+\n+        AcDcConverterConversion acDcConverterConversion1 = new AcDcConverterConversion(cconverter1, converterType, lossFactor.getLossFactor1(), context);\n+        AcDcConverterConversion acDcConverterConversion2 = new AcDcConverterConversion(cconverter2, converterType, lossFactor.getLossFactor2(), context);\n+        DcLineSegmentConverter converter1 = new DcLineSegmentConverter(converter1Id, poleLossP1, pAC1);\n+        DcLineSegmentConverter converter2 = new DcLineSegmentConverter(converter2Id, poleLossP2, pAC2);\n+        DcLineSegmentConversion dcLineSegmentConversion = new DcLineSegmentConversion(dcLineSegment, operatingMode, r, ratedUdc, converter1, converter2, context);\n+\n+        if (!acDcConverterConversion1.valid() || !acDcConverterConversion2.valid() || !dcLineSegmentConversion.valid()) {\n+            return false;\n+        }\n+\n+        if (converterType == HvdcType.VSC) {\n+            acDcConverterConversion1.convert();\n+            acDcConverterConversion2.convert();\n+            dcLineSegmentConversion.convert();\n+\n+        } else { // LCC\n+            acDcConverterConversion1.convert();\n+            acDcConverterConversion2.convert();\n+            dcLineSegmentConversion.convert();\n+\n+            updatePowerFactor(acDcConverterConversion1);\n+            updatePowerFactor(acDcConverterConversion2);\n+        }\n+        return true;\n+    }\n+\n+    private static double getPAc(PropertyBag p) {\n+        // targetPpcc is the real power injection target in the AC grid in CGMES\n+        return Double.isNaN(p.asDouble(TARGET_PPCC)) ? 0 : p.asDouble(TARGET_PPCC);\n+    }\n+\n+    private static void updatePowerFactor(AcDcConverterConversion acDcConverterConversion) {\n+        if (acDcConverterConversion == null) {\n+            return;\n+        }\n+        LccConverterStation iconverter = acDcConverterConversion.getLccConverter();\n+        double powerFactor = getPowerFactor(iconverter);\n+        if (!Double.isNaN(powerFactor)) {\n+            acDcConverterConversion.setLccPowerFactor(powerFactor);\n+        }\n+    }\n+\n+    private static double getPowerFactor(LccConverterStation iconverter) {\n+        return iconverter.getTerminal().getP()\n+            / Math.hypot(iconverter.getTerminal().getP(), iconverter.getTerminal().getQ());\n+    }\n+\n+    private void debugHvdc(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Islands islands,\n+        IslandsEnds islandsEnds, Hvdc hvdc) {\n+\n+        hvdc.debug();\n+\n+        islandsEnds.getIslandsEndsNodes().forEach(ien -> {\n+            IslandEndHvdc islandEndHvdc1 = new IslandEndHvdc();\n+            islandEndHvdc1.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes1());\n+            IslandEndHvdc islandEndHvdc2 = new IslandEndHvdc();\n+            islandEndHvdc2.add(adjacency, tpNodeEquipments, ien.getTopologicalNodes2());\n+\n+            islandEndHvdc1.debug();\n+            islandEndHvdc2.debug();\n+\n+            adjacency.debug(ien.getTopologicalNodes1());\n+            tpNodeEquipments.debugEq(ien.getTopologicalNodes1());\n+            tpNodeEquipments.debugDcLs(ien.getTopologicalNodes1());\n+\n+            adjacency.debug(ien.getTopologicalNodes2());\n+            tpNodeEquipments.debugEq(ien.getTopologicalNodes2());\n+            tpNodeEquipments.debugDcLs(ien.getTopologicalNodes2());\n+        });\n+\n+        islands.debug();\n+        islandsEnds.debug();\n+        adjacency.debug();\n+        tpNodeEquipments.debug();", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMjczOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408022739", "bodyText": "It is done when this method is called.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4Nzk1NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406687955", "bodyText": "This looks strange to me:\n\nDC_LINE_SEGMENT are used for DC lines -> OK\nAC_DC_CONVERTER are used between AC node and DC node (converter station I guess) -> OK\n\nBut I don't understand why do you connect all DC terminals to each others? And why this kind of links (if they are valid), are AC_DC_CONVERTER instead of DC_LINE_SEGMENT (DC <-> DC)", "author": "mathbagu", "createdAt": "2020-04-10T09:48:05Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Adjacency.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Adjacency {\n+\n+    enum AdjacentType {\n+        DC_LINE_SEGMENT, AC_DC_CONVERTER, AC_TRANSFORMER\n+    }\n+\n+    private final Map<String, List<Adjacent>> adjacency;\n+\n+    Adjacency(CgmesModel cgmesModel) {\n+        adjacency = new HashMap<>();\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegmentAdjacency(cgmesModel, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+        acDcConverterNodes.getConverterNodes()\n+            .forEach((key, value) -> computeAcDcConverterAdjacency(value.acTopologicalNode,\n+                value.dcTopologicalNode));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformerAdjacency(cgmesModel, ends);\n+            } else {\n+                throw new PowsyblException(String.format(\"Unexpected TransformerEnds: ends %d\", ends.size()));\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegmentAdjacency(CgmesModel cgmesModel, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+\n+        addAdjacency(t1.dcTopologicalNode(), t2.dcTopologicalNode(), AdjacentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeAcDcConverterAdjacency(String acTopologicalNode, List<String> dcTopologicalNodes) {\n+        dcTopologicalNodes.forEach(\n+            dcTopologicalNode -> addAdjacency(acTopologicalNode, dcTopologicalNode, AdjacentType.AC_DC_CONVERTER));\n+        for (int k = 0; k < dcTopologicalNodes.size() - 1; k++) {\n+            String dcTopologicalNode = dcTopologicalNodes.get(k);\n+            for (int l = k + 1; l < dcTopologicalNodes.size(); l++) {\n+                addAdjacency(dcTopologicalNode, dcTopologicalNodes.get(l), AdjacentType.AC_DC_CONVERTER);\n+            }\n+        }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMzM1Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408033353", "bodyText": "AC_DC_CONVERTED is able to connect one AC node with at least two DC nodes, so all three nodes are adjacent. These three nodes are connected bye the AC_DC_CONVERTER and not by the DC_LINE_SEGMENT. The DC_LINE_SEGMENT connects one DC node of AC_DC_CONVERTER From to one DC node of the AC_DC_CONVERTER  To. In some configurations there are two DC_LINE_SEGMENTS connected to one AC_DC_CONVERTER.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4Nzk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODU5OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406688598", "bodyText": "Consider log anything only if debug is enabled", "author": "mathbagu", "createdAt": "2020-04-10T09:49:59Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    private final List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.getHvdc().forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSymmetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(hvdcEq::add);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    List<HvdcEquipment> getHvdcData() {\n+        return hvdcData;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Hvdc\");\n+        hvdcData.forEach(HvdcEquipment::debug);\n+    }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMzg1Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408023853", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODY0OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406688649", "bodyText": "Same remark here", "author": "mathbagu", "createdAt": "2020-04-10T09:50:08Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    private final List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.getHvdc().forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSymmetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(hvdcEq::add);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    List<HvdcEquipment> getHvdcData() {\n+        return hvdcData;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Hvdc\");\n+        hvdcData.forEach(HvdcEquipment::debug);\n+    }\n+\n+    static class HvdcEquipment {\n+        final List<HvdcConverter> converters;\n+        final List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    Converters:\");\n+            this.converters.forEach(HvdcConverter::debug);\n+            LOG.debug(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.debug(\"    {} \", ls));\n+            LOG.debug(\"---\");\n+        }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyNDA4Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408024082", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODcwOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406688709", "bodyText": "Same remark here", "author": "mathbagu", "createdAt": "2020-04-10T09:50:19Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Hvdc.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEnd;\n+import com.powsybl.cgmes.conversion.elements.hvdc.IslandEndHvdc.HvdcEndType;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Hvdc {\n+    private final List<HvdcEquipment> hvdcData;\n+\n+    Hvdc() {\n+        this.hvdcData = new ArrayList<>();\n+    }\n+\n+    void add(TPnodeEquipments tpNodeEquipments, IslandEndHvdc islandEndHvdc1, IslandEndHvdc islandEndHvdc2) {\n+        islandEndHvdc1.getHvdc().forEach(h -> add(tpNodeEquipments, h, islandEndHvdc2));\n+    }\n+\n+    private void add(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, IslandEndHvdc islandEndHvdc2) {\n+        HvdcEnd hvdc2 = islandEndHvdc2.selectSymmetricHvdcEnd(hvdc1);\n+        if (hvdc2 == null) {\n+            return;\n+        }\n+        HvdcEndType type = hvdc1.computeType();\n+        switch (type) {\n+            case HVDC_T0_C1_LS1:\n+            case HVDC_T1_C1_LS1:\n+            case HVDC_T1_C1_LS2:\n+                addC1LSn(hvdc1, hvdc2);\n+                break;\n+            case HVDC_T2_C2_LS1:\n+                addC2LS1(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+            case HVDC_TN_CN_LSN:\n+                addCnLSn(tpNodeEquipments, hvdc1, hvdc2);\n+                break;\n+        }\n+    }\n+\n+    private void addC1LSn(HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        HvdcConverter converter = new HvdcConverter(hvdc1.acDcConvertersEnd.iterator().next(),\n+            hvdc2.acDcConvertersEnd.iterator().next());\n+        hvdcEq.add(converter);\n+        hvdc1.dcLineSegmentsEnd.forEach(hvdcEq::add);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addC2LS1(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        String dcLineSegment = hvdc1.dcLineSegmentsEnd.iterator().next();\n+        HvdcConverter hvdcConverter1 = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+        if (hvdcConverter1 == null) {\n+            return;\n+        }\n+        HvdcConverter hvdcConverter2 = computeOtherConverter(hvdcConverter1, hvdc1, hvdc2);\n+        if (hvdcConverter2 == null) {\n+            return;\n+        }\n+        HvdcEquipment hvdcEq = new HvdcEquipment();\n+        hvdcEq.add(hvdcConverter1, dcLineSegment);\n+        hvdcEq.add(hvdcConverter2);\n+        this.hvdcData.add(hvdcEq);\n+    }\n+\n+    private void addCnLSn(TPnodeEquipments tpNodeEquipments, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+\n+        hvdc1.dcLineSegmentsEnd.forEach(dcLineSegment -> {\n+            HvdcConverter hvdcConverter = computeConverter(tpNodeEquipments, dcLineSegment, hvdc1, hvdc2);\n+            if (hvdcConverter == null) {\n+                return;\n+            }\n+            HvdcEquipment hvdcEq = new HvdcEquipment();\n+            hvdcEq.add(hvdcConverter, dcLineSegment);\n+            this.hvdcData.add(hvdcEq);\n+        });\n+    }\n+\n+    private static HvdcConverter computeConverter(TPnodeEquipments tpNodeEquipments, String dcLineSegment, HvdcEnd hvdc1,\n+        HvdcEnd hvdc2) {\n+        String acDcConverter1 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc1.acDcConvertersEnd, hvdc1.topologicalNodesEnd);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = computeEquipmentConnectedToEquipment(tpNodeEquipments, dcLineSegment, hvdc2.acDcConvertersEnd, hvdc2.topologicalNodesEnd);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static HvdcConverter computeOtherConverter(HvdcConverter converter, HvdcEnd hvdc1, HvdcEnd hvdc2) {\n+        String acDcConverter1 = hvdc1.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd1.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter1 == null) {\n+            return null;\n+        }\n+        String acDcConverter2 = hvdc2.acDcConvertersEnd.stream().filter(c -> !converter.acDcConvertersEnd2.contentEquals(c)).findFirst().orElse(null);\n+        if (acDcConverter2 == null) {\n+            return null;\n+        }\n+        return new HvdcConverter(acDcConverter1, acDcConverter2);\n+    }\n+\n+    private static String computeEquipmentConnectedToEquipment(TPnodeEquipments tpNodeEquipments, String equipment,\n+        Set<String> connectedEquipments, List<String> topologicalNodes) {\n+        return connectedEquipments.stream()\n+            .filter(eq -> tpNodeEquipments.connectedEquipments(equipment, eq, topologicalNodes))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    List<HvdcEquipment> getHvdcData() {\n+        return hvdcData;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Hvdc\");\n+        hvdcData.forEach(HvdcEquipment::debug);\n+    }\n+\n+    static class HvdcEquipment {\n+        final List<HvdcConverter> converters;\n+        final List<String> dcLineSegments;\n+\n+        HvdcEquipment() {\n+            this.converters = new ArrayList<>();\n+            this.dcLineSegments = new ArrayList<>();\n+        }\n+\n+        void add(HvdcConverter converter, String dcLineSegment) {\n+            this.converters.add(converter);\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void add(HvdcConverter converter) {\n+            this.converters.add(converter);\n+        }\n+\n+        void add(String dcLineSegment) {\n+            this.dcLineSegments.add(dcLineSegment);\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    Converters:\");\n+            this.converters.forEach(HvdcConverter::debug);\n+            LOG.debug(\"    dcLineSegments\");\n+            this.dcLineSegments.forEach(ls -> LOG.debug(\"    {} \", ls));\n+            LOG.debug(\"---\");\n+        }\n+    }\n+\n+    static class HvdcConverter {\n+        String acDcConvertersEnd1;\n+        String acDcConvertersEnd2;\n+\n+        HvdcConverter(String acDcConvertersEnd1, String acDcConvertersEnd2) {\n+            Objects.requireNonNull(acDcConvertersEnd1);\n+            Objects.requireNonNull(acDcConvertersEnd2);\n+            this.acDcConvertersEnd1 = acDcConvertersEnd1;\n+            this.acDcConvertersEnd2 = acDcConvertersEnd2;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    End1: {} End2: {}\", this.acDcConvertersEnd1, this.acDcConvertersEnd2);\n+        }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyNDI1MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408024251", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTU4Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406689587", "bodyText": "Same remark", "author": "mathbagu", "createdAt": "2020-04-10T09:52:55Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+import com.powsybl.commons.PowsyblException;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    private final List<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new ArrayList<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSymmetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(hvdcEnd2.dcLineSegmentsEnd::contains);\n+    }\n+\n+    List<HvdcEnd> getHvdc() {\n+        return hvdc;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"IslandEndHvdc\");\n+        hvdc.forEach(HvdcEnd::debug);\n+    }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyNDQxMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408024411", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTcwOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406689708", "bodyText": "Same remark", "author": "mathbagu", "createdAt": "2020-04-10T09:53:14Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandEndHvdc.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.conversion.elements.hvdc.Adjacency.AdjacentType;\n+import com.powsybl.cgmes.conversion.elements.hvdc.TPnodeEquipments.TPnodeEquipment;\n+import com.powsybl.commons.PowsyblException;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandEndHvdc {\n+\n+    // T1: no transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T1: one transformer, C1: one acDcConverter, LS1: one dcLineSegment\n+    // T2: two transformers, C2: two acDcConverters, LS2: two dcLineSegments\n+    // TN: n transformers (usually 2), CN: n acDcConverters (usually 2), LSN: n dcLineSegments (usually 2)\n+    enum HvdcEndType {\n+        HVDC_T0_C1_LS1, HVDC_T1_C1_LS1, HVDC_TN_CN_LSN, HVDC_T1_C1_LS2, HVDC_T2_C2_LS1,\n+    }\n+\n+    private final List<HvdcEnd> hvdc;\n+\n+    IslandEndHvdc() {\n+        hvdc = new ArrayList<>();\n+    }\n+\n+    void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, List<String> islandNodesEnd) {\n+        if (islandNodesEnd.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        // Take a non-visited node with transformers\n+        int k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyTransformer(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+\n+        if (!visitedTopologicalNodes.isEmpty()) {\n+            return;\n+        }\n+        // IslandsEnds without transformers\n+        // Take a non-visited node with acDcConverters\n+        k = 0;\n+        while (k < islandNodesEnd.size()) {\n+            String topologicalNodeEnd = islandNodesEnd.get(k);\n+            if (!visitedTopologicalNodes.contains(topologicalNodeEnd)\n+                && tpNodeEquipments.containsAnyAcDcConverter(topologicalNodeEnd)) {\n+                add(adjacency, tpNodeEquipments, visitedTopologicalNodes, topologicalNodeEnd, islandNodesEnd);\n+            }\n+            k++;\n+        }\n+    }\n+\n+    private void add(Adjacency adjacency, TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+\n+        List<String> hvdcNodes = computeHvdcNodes(adjacency, tpNodeEquipments, visitedTopologicalNodes,\n+            topologicalNodeEnd, islandNodesEnd);\n+        Set<String> transformers = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.TRANSFORMER);\n+        Set<String> acDcConverters = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.AC_DC_CONVERTER);\n+        Set<String> dcLineSegment = computeEquipments(tpNodeEquipments, hvdcNodes,\n+            TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT);\n+\n+        HvdcEnd hvdcEnd = new HvdcEnd(hvdcNodes, transformers, acDcConverters, dcLineSegment);\n+        hvdc.add(hvdcEnd);\n+    }\n+\n+    private static List<String> computeHvdcNodes(Adjacency adjacency, TPnodeEquipments tpNodeEquipments,\n+        Set<String> visitedTopologicalNodes,\n+        String topologicalNodeEnd, List<String> islandNodesEnd) {\n+        List<String> listTp = new ArrayList<>();\n+\n+        listTp.add(topologicalNodeEnd);\n+        visitedTopologicalNodes.add(topologicalNodeEnd);\n+\n+        int k = 0;\n+        while (k < listTp.size()) {\n+            String topologicalNode = listTp.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (isAdjacentOk(tpNodeEquipments, visitedTopologicalNodes, islandNodesEnd,\n+                        adjacent.type, adjacent.topologicalNode)) {\n+                        listTp.add(adjacent.topologicalNode);\n+                        visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                    }\n+                });\n+            }\n+            k++;\n+        }\n+        return listTp;\n+    }\n+\n+    private static boolean isAdjacentOk(TPnodeEquipments tpNodeEquipments, Set<String> visitedTopologicalNodes,\n+        List<String> islandNodesEnd, AdjacentType adType, String adTopologicalNode) {\n+        if (Adjacency.isDcLineSegment(adType)) {\n+            return false;\n+        }\n+        if (!islandNodesEnd.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        if (visitedTopologicalNodes.contains(adTopologicalNode)) {\n+            return false;\n+        }\n+        return !tpNodeEquipments.multiAcDcConverter(adTopologicalNode);\n+    }\n+\n+    private static Set<String> computeEquipments(TPnodeEquipments tpNodeEquipments, List<String> hvdcNode,\n+        TPnodeEquipments.EquipmentType type) {\n+        Set<String> listEq = new HashSet<>();\n+\n+        hvdcNode.forEach(n -> addEquipments(tpNodeEquipments, n, type, listEq));\n+        return listEq;\n+    }\n+\n+    private static void addEquipments(TPnodeEquipments tpNodeEquipments, String topologicalNode,\n+        TPnodeEquipments.EquipmentType type, Set<String> listEq) {\n+        List<TPnodeEquipment> listEqNode = tpNodeEquipments.getNodeEquipments().get(topologicalNode);\n+        if (listEqNode == null) {\n+            return;\n+        }\n+        listEqNode.stream()\n+            .filter(eq -> eq.type == type)\n+            .forEachOrdered(eq -> listEq.add(eq.equipmentId));\n+    }\n+\n+    HvdcEnd selectSymmetricHvdcEnd(HvdcEnd hvdcEnd1) {\n+        return hvdc.stream().filter(h -> isCompatible(hvdcEnd1, h)).findFirst().orElse(null);\n+    }\n+\n+    private static boolean isCompatible(HvdcEnd hvdcEnd1, HvdcEnd hvdcEnd2) {\n+        if (hvdcEnd1.transformersEnd.size() != hvdcEnd2.transformersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.acDcConvertersEnd.size() != hvdcEnd2.acDcConvertersEnd.size()) {\n+            return false;\n+        }\n+        if (hvdcEnd1.dcLineSegmentsEnd.size() != hvdcEnd2.dcLineSegmentsEnd.size()) {\n+            return false;\n+        }\n+\n+        return hvdcEnd1.dcLineSegmentsEnd.stream()\n+            .allMatch(hvdcEnd2.dcLineSegmentsEnd::contains);\n+    }\n+\n+    List<HvdcEnd> getHvdc() {\n+        return hvdc;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"IslandEndHvdc\");\n+        hvdc.forEach(HvdcEnd::debug);\n+    }\n+\n+    static class HvdcEnd {\n+        final List<String> topologicalNodesEnd;\n+        final Set<String> transformersEnd;\n+        final Set<String> acDcConvertersEnd;\n+        final Set<String> dcLineSegmentsEnd;\n+\n+        HvdcEnd(List<String> topologicalNodesEnd, Set<String> transformersEnd, Set<String> acDcConvertersEnd, Set<String> dcLineSegmentsEnd) {\n+            Objects.requireNonNull(topologicalNodesEnd);\n+            Objects.requireNonNull(transformersEnd);\n+            Objects.requireNonNull(acDcConvertersEnd);\n+            Objects.requireNonNull(dcLineSegmentsEnd);\n+            this.topologicalNodesEnd = topologicalNodesEnd;\n+            this.transformersEnd = transformersEnd;\n+            this.acDcConvertersEnd = acDcConvertersEnd;\n+            this.dcLineSegmentsEnd = dcLineSegmentsEnd;\n+        }\n+\n+        HvdcEndType computeType() {\n+            int t = this.transformersEnd.size();\n+            int c = this.acDcConvertersEnd.size();\n+            int ls = this.dcLineSegmentsEnd.size();\n+\n+            if (t == 0 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T0_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 1) {\n+                return HvdcEndType.HVDC_T1_C1_LS1;\n+            } else if (t == 1 && c == 1 && ls == 2) {\n+                return HvdcEndType.HVDC_T1_C1_LS2;\n+            } else if (t == 2 && c == 2 && ls == 1) {\n+                return HvdcEndType.HVDC_T2_C2_LS1;\n+            } else if (t == c && c == ls && t > 1) {\n+                return HvdcEndType.HVDC_TN_CN_LSN;\n+            }\n+\n+            throw new PowsyblException(String.format(\"Unexpected HVDC configuration: Transformers %d Converters %d DcLineSegments %d\", t, c, ls));\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    topologicalNodesEnd: {}\", this.topologicalNodesEnd);\n+            LOG.debug(\"    transformersEnd: {}\", this.transformersEnd);\n+            LOG.debug(\"    acDcConvertersEnd: {}\", this.acDcConvertersEnd);\n+            LOG.debug(\"    dcLineSegmentsEnd: {}\", this.dcLineSegmentsEnd);\n+            LOG.debug(\"---\");\n+        }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyNDU1MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408024550", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTkxMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406689911", "bodyText": "Coding style: two spaces are between final and List", "author": "mathbagu", "createdAt": "2020-04-10T09:53:50Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final  List<ArrayList<String>> islandsNodes;", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMDYwMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408020602", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-04-14T10:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4OTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5MDExOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406690118", "bodyText": "Same remark.", "author": "mathbagu", "createdAt": "2020-04-10T09:54:26Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/Islands.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class Islands {\n+    private final  List<ArrayList<String>> islandsNodes;\n+\n+    // The island includes dcTopologicalNodes and the acTopologicalNodes at both ends of the transformer\n+    Islands(Adjacency adjacency) {\n+        islandsNodes = new ArrayList<>();\n+\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+        adjacency.get().keySet().forEach(topologicalNodeId -> {\n+            if (visitedTopologicalNodes.contains(topologicalNodeId)) {\n+                return;\n+            }\n+            ArrayList<String> adjacentTopologicalNodes = computeAdjacentTopologicalNodes(topologicalNodeId,\n+                adjacency, visitedTopologicalNodes);\n+            islandsNodes.add(adjacentTopologicalNodes);\n+        });\n+    }\n+\n+    private static ArrayList<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        ArrayList<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    List<ArrayList<String>> getIslandsNodes() {\n+        return islandsNodes;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"Islands\");\n+        islandsNodes.forEach(island -> LOG.debug(\" {} \", island));\n+    }", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyNDkwNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408024906", "bodyText": "All debug methods are only used inside the method debugHvdc and when this method is called is also checked if debug is enabled.", "author": "marqueslanauja", "createdAt": "2020-04-14T10:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5MDExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODAzMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406698033", "bodyText": "Same global remark about logging", "author": "mathbagu", "createdAt": "2020-04-10T10:19:25Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/TPnodeEquipments.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.powsybl.cgmes.model.CgmesDcTerminal;\n+import com.powsybl.cgmes.model.CgmesModel;\n+import com.powsybl.cgmes.model.CgmesNames;\n+import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.triplestore.api.PropertyBag;\n+import com.powsybl.triplestore.api.PropertyBags;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class TPnodeEquipments {\n+\n+    enum EquipmentType {\n+        TRANSFORMER, AC_DC_CONVERTER, DC_LINE_SEGMENT\n+    }\n+\n+    private final Map<String, List<TPnodeEquipment>> nodeEquipments;\n+\n+    TPnodeEquipments(CgmesModel cgmesModel, Adjacency adjacency) {\n+        nodeEquipments = new HashMap<>();\n+\n+        cgmesModel.dcLineSegments().forEach(dcls -> computeDcLineSegment(cgmesModel, adjacency, dcls));\n+\n+        AcDcConverterNodes acDcConverterNodes = new AcDcConverterNodes(cgmesModel);\n+\n+        acDcConverterNodes.getConverterNodes().values()\n+            .forEach(value -> addEquipment(adjacency, value.id, value.acTopologicalNode,\n+                value.dcTopologicalNode, EquipmentType.AC_DC_CONVERTER));\n+\n+        cgmesModel.groupedTransformerEnds().forEach((t, ends) -> {\n+            if (ends.size() == 2) {\n+                computeTwoWindingsTransformer(cgmesModel, adjacency, ends);\n+            } else if (ends.size() == 3) {\n+                computeThreeWindingsTransformer(cgmesModel, adjacency, ends);\n+            }\n+        });\n+    }\n+\n+    private void computeDcLineSegment(CgmesModel cgmesModel, Adjacency adjacency, PropertyBag equipment) {\n+        CgmesDcTerminal t1 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 1));\n+        CgmesDcTerminal t2 = cgmesModel.dcTerminal(equipment.getId(CgmesNames.DC_TERMINAL + 2));\n+        String id = equipment.getId(\"DCLineSegment\");\n+        addEquipment(adjacency, id, t1.dcTopologicalNode(), t2.dcTopologicalNode(), EquipmentType.DC_LINE_SEGMENT);\n+    }\n+\n+    private void computeTwoWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void computeThreeWindingsTransformer(CgmesModel cgmesModel, Adjacency adjacency, PropertyBags ends) {\n+        PropertyBag end1 = ends.get(0);\n+        CgmesTerminal t1 = cgmesModel.terminal(end1.getId(CgmesNames.TERMINAL));\n+        PropertyBag end2 = ends.get(1);\n+        CgmesTerminal t2 = cgmesModel.terminal(end2.getId(CgmesNames.TERMINAL));\n+        PropertyBag end3 = ends.get(2);\n+        CgmesTerminal t3 = cgmesModel.terminal(end3.getId(CgmesNames.TERMINAL));\n+\n+        String id = end1.getId(CgmesNames.POWER_TRANSFORMER);\n+        List<String> topologicalNodes = new ArrayList<>();\n+        topologicalNodes.add(t1.topologicalNode());\n+        topologicalNodes.add(t2.topologicalNode());\n+        topologicalNodes.add(t3.topologicalNode());\n+        if (isValidTransformer(adjacency, topologicalNodes)) {\n+            addTransformer(adjacency, id, topologicalNodes, EquipmentType.TRANSFORMER);\n+        }\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String topologicalNodeId1, String topologicalNodeId2,\n+        EquipmentType type) {\n+        if (!adjacency.get().containsKey(topologicalNodeId1)\n+            || !adjacency.get().containsKey(topologicalNodeId2)) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId1, k -> new ArrayList<>()).add(eq);\n+        nodeEquipments.computeIfAbsent(topologicalNodeId2, k -> new ArrayList<>()).add(eq);\n+    }\n+\n+    private void addEquipment(Adjacency adjacency, String id, String acTopologicalNodeId,\n+        List<String> dcTopologicalNodeIds, EquipmentType type) {\n+        if (!adjacency.get().containsKey(acTopologicalNodeId)) {\n+            return;\n+        }\n+        if (dcTopologicalNodeIds.stream().anyMatch(n -> !adjacency.get().containsKey(n))) {\n+            return;\n+        }\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        nodeEquipments.computeIfAbsent(acTopologicalNodeId, k -> new ArrayList<>()).add(eq);\n+        dcTopologicalNodeIds.forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    private boolean isValidTransformer(Adjacency adjacency, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(adjacency::containsAcDcConverter);\n+    }\n+\n+    private void addTransformer(Adjacency adjacency, String id, List<String> topologicalNodes, EquipmentType type) {\n+        TPnodeEquipment eq = new TPnodeEquipment(type, id);\n+        topologicalNodes.stream()\n+            .filter(n -> adjacency.get().containsKey(n))\n+            .forEach(n -> nodeEquipments.computeIfAbsent(n, k -> new ArrayList<>()).add(eq));\n+    }\n+\n+    boolean containsAnyTransformer(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.TRANSFORMER);\n+    }\n+\n+    boolean containsAnyAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .anyMatch(eq -> eq.type == EquipmentType.AC_DC_CONVERTER);\n+    }\n+\n+    boolean multiAcDcConverter(String topologicalNode) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.type == EquipmentType.AC_DC_CONVERTER)\n+            .count() >= 2;\n+    }\n+\n+    boolean connectedEquipments(String equipment1, String equipment2, List<String> topologicalNodes) {\n+        return topologicalNodes.stream().anyMatch(n -> connectedEquipment(n, equipment1, equipment2));\n+    }\n+\n+    private boolean connectedEquipment(String topologicalNode, String equipment1, String equipment2) {\n+        List<TPnodeEquipment> listEquipment = nodeEquipments.get(topologicalNode);\n+        if (listEquipment == null) {\n+            return false;\n+        }\n+        return listEquipment.stream()\n+            .filter(eq -> eq.equipmentId.equals(equipment1) || eq.equipmentId.equals(equipment2))\n+            .count() == 2;\n+    }\n+\n+    Map<String, List<TPnodeEquipment>> getNodeEquipments() {\n+        return nodeEquipments;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"TPnodeEquipments\");\n+        nodeEquipments.forEach(this::debug);\n+    }\n+\n+    private void debug(String tpNodeId, List<TPnodeEquipment> listTPnodeEquipment) {\n+        LOG.debug(\"TopologicalNodeId: {}\", tpNodeId);\n+        listTPnodeEquipment.forEach(TPnodeEquipment::debug);\n+    }\n+\n+    void debugEq(List<String> lnodes) {\n+        lnodes.forEach(this::debugEq);\n+    }\n+\n+    private void debugEq(String node) {\n+        LOG.debug(\"EQ. TopologicalNode {}\", node);\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node)\n+                .forEach(eq -> LOG.debug(\"    {} {}\", eq.type, eq.equipmentId));\n+        }\n+    }\n+\n+    void debugDcLs(List<String> lnodes) {\n+        lnodes.forEach(this::debugDcLs);\n+    }\n+\n+    private void debugDcLs(String node) {\n+        if (nodeEquipments.containsKey(node)) {\n+            nodeEquipments.get(node).stream()\n+                .filter(eq -> eq.type == TPnodeEquipments.EquipmentType.DC_LINE_SEGMENT)\n+                .forEach(eq -> LOG.debug(\"DcLineSegment {}\", eq.equipmentId));\n+        }\n+    }\n+\n+    static class TPnodeEquipment {\n+        EquipmentType type;\n+        String equipmentId;\n+\n+        TPnodeEquipment(EquipmentType type, String equipmentId) {\n+            this.type = type;\n+            this.equipmentId = equipmentId;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    {} {}\", this.type, this.equipmentId);\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(TPnodeEquipments.class);\n+}", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5ODE2MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r406698161", "bodyText": "Same global remark about logging", "author": "mathbagu", "createdAt": "2020-04-10T10:19:52Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/IslandsEnds.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n+ */\n+class IslandsEnds {\n+    private final List<IslandEnd> islandsEndsNodes;\n+\n+    // The island includes dcTopologicalNodes and first acTopologicalNode\n+    IslandsEnds() {\n+        islandsEndsNodes = new ArrayList<>();\n+    }\n+\n+    void add(Adjacency adjacency, List<String> islandNodes) {\n+        if (islandNodes.isEmpty()) {\n+            return;\n+        }\n+        Set<String> visitedTopologicalNodes = new HashSet<>();\n+\n+        String topologicalNodeEnd1 = islandNodes.get(0);\n+        List<String> adjacentTopologicalNodeEnd1 = computeAdjacentTopologicalNodes(topologicalNodeEnd1,\n+            adjacency, visitedTopologicalNodes);\n+\n+        String topologicalNodeEnd2 = getTopologicalNodeOtherEnd(islandNodes, visitedTopologicalNodes);\n+        if (topologicalNodeEnd2 == null) {\n+            return;\n+        }\n+        List<String> adjacentTopologicalNodeEnd2 = computeAdjacentTopologicalNodes(topologicalNodeEnd2,\n+            adjacency, visitedTopologicalNodes);\n+\n+        IslandEnd islandEnd = new IslandEnd(adjacentTopologicalNodeEnd1, adjacentTopologicalNodeEnd2);\n+\n+        islandsEndsNodes.add(islandEnd);\n+    }\n+\n+    private static String getTopologicalNodeOtherEnd(List<String> islandNodes, Set<String> visitedTopologicalNodes) {\n+        return islandNodes.stream()\n+            .filter(n -> !visitedTopologicalNodes.contains(n))\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private static List<String> computeAdjacentTopologicalNodes(String topologicalNodeId,\n+        Adjacency adjacency, Set<String> visitedTopologicalNodes) {\n+\n+        List<String> adjacentTopologicalNodes = new ArrayList<>();\n+        adjacentTopologicalNodes.add(topologicalNodeId);\n+        visitedTopologicalNodes.add(topologicalNodeId);\n+\n+        int k = 0;\n+        while (k < adjacentTopologicalNodes.size()) {\n+            String topologicalNode = adjacentTopologicalNodes.get(k);\n+            if (adjacency.get().containsKey(topologicalNode)) {\n+                adjacency.get().get(topologicalNode).forEach(adjacent -> {\n+                    if (Adjacency.isDcLineSegment(adjacent.type)) {\n+                        return;\n+                    }\n+                    if (visitedTopologicalNodes.contains(adjacent.topologicalNode)) {\n+                        return;\n+                    }\n+                    adjacentTopologicalNodes.add(adjacent.topologicalNode);\n+                    visitedTopologicalNodes.add(adjacent.topologicalNode);\n+                });\n+            }\n+            k++;\n+        }\n+        return adjacentTopologicalNodes;\n+    }\n+\n+    List<IslandEnd> getIslandsEndsNodes() {\n+        return islandsEndsNodes;\n+    }\n+\n+    void debug() {\n+        LOG.debug(\"IslandsEnds\");\n+        islandsEndsNodes.forEach(IslandEnd::debug);\n+    }\n+\n+    static class IslandEnd {\n+        private final List<String> topologicalNodes1;\n+        private final List<String> topologicalNodes2;\n+\n+        IslandEnd(List<String> topologicalNodes1, List<String> topologicalNodes2) {\n+            this.topologicalNodes1 = topologicalNodes1;\n+            this.topologicalNodes2 = topologicalNodes2;\n+        }\n+\n+        List<String> getTopologicalNodes1() {\n+            return topologicalNodes1;\n+        }\n+\n+        List<String> getTopologicalNodes2() {\n+            return topologicalNodes2;\n+        }\n+\n+        void debug() {\n+            LOG.debug(\"    topologicalNodes1: {}\", this.topologicalNodes1);\n+            LOG.debug(\"    topologicalNodes2: {}\", this.topologicalNodes2);\n+            LOG.debug(\"---\");\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(IslandsEnds.class);\n+}", "originalCommit": "5724423fce1858f4b4319f14a72a54b2a45125f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c5d71bce1f4ced0e104a20677e82e2355ede84b1", "url": "https://github.com/powsybl/powsybl-core/commit/c5d71bce1f4ced0e104a20677e82e2355ede84b1", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-04-14T06:12:04Z", "type": "commit"}, {"oid": "af92e0ef75a0bceca3c2f0468be26c3514e5a2f4", "url": "https://github.com/powsybl/powsybl-core/commit/af92e0ef75a0bceca3c2f0468be26c3514e5a2f4", "message": "Reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-04-14T09:40:29Z", "type": "commit"}, {"oid": "92b07348f7abc0c0127374c9651d9fbb9b8101ad", "url": "https://github.com/powsybl/powsybl-core/commit/92b07348f7abc0c0127374c9651d9fbb9b8101ad", "message": "Merge branch 'master' into cgmes_conversion_HVDC", "committedDate": "2020-04-15T06:07:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNjM3MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408636371", "bodyText": "Where does this value come from?", "author": "mathbagu", "createdAt": "2020-04-15T07:29:58Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/hvdc/AcDcConverterConversion.java", "diffHunk": "@@ -5,25 +5,38 @@\n  * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n  */\n \n-package com.powsybl.cgmes.conversion.elements;\n+package com.powsybl.cgmes.conversion.elements.hvdc;\n \n import java.util.Objects;\n \n import com.powsybl.cgmes.conversion.Context;\n-import com.powsybl.iidm.network.HvdcConverterStation;\n+import com.powsybl.cgmes.conversion.elements.AbstractConductingEquipmentConversion;\n import com.powsybl.iidm.network.HvdcConverterStation.HvdcType;\n+import com.powsybl.iidm.network.LccConverterStation;\n import com.powsybl.iidm.network.LccConverterStationAdder;\n+import com.powsybl.iidm.network.VscConverterStation;\n import com.powsybl.iidm.network.VscConverterStationAdder;\n import com.powsybl.triplestore.api.PropertyBag;\n \n /**\n+ * @author Miora Ralambotiana <miora.ralambotiana at rte-france.com>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n public class AcDcConverterConversion extends AbstractConductingEquipmentConversion {\n \n-    public AcDcConverterConversion(PropertyBag c, Context context) {\n+    private static final double DEFAULT_POWER_FACTOR = 0.8;", "originalCommit": "92b07348f7abc0c0127374c9651d9fbb9b8101ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NDIxMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1230#discussion_r408654213", "bodyText": "It is a default value that works quite well when the power factor is not explicitly specified (we should document it).", "author": "miovd", "createdAt": "2020-04-15T08:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNjM3MQ=="}], "type": "inlineReview"}]}