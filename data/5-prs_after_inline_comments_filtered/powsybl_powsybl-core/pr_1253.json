{"pr_number": 1253, "pr_title": "Matpower importer", "pr_createdAt": "2020-04-01T11:13:50Z", "pr_url": "https://github.com/powsybl/powsybl-core/pull/1253", "timeline": [{"oid": "2835fd2fa4889a0e893925e8652a5841c3644285", "url": "https://github.com/powsybl/powsybl-core/commit/2835fd2fa4889a0e893925e8652a5841c3644285", "message": "MATPOWER importer\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-03-25T11:48:49Z", "type": "commit"}, {"oid": "22bdf0fbe543284d13e2b052daf6b26371d01710", "url": "https://github.com/powsybl/powsybl-core/commit/22bdf0fbe543284d13e2b052daf6b26371d01710", "message": "Merge branch 'master' into matpower_importer", "committedDate": "2020-03-31T17:39:55Z", "type": "commit"}, {"oid": "04406c91d454b1093e58c9bb56ffeda9dec18d29", "url": "https://github.com/powsybl/powsybl-core/commit/04406c91d454b1093e58c9bb56ffeda9dec18d29", "message": "align tests to the latest changes from master\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-03-31T18:35:24Z", "type": "commit"}, {"oid": "ec0bf74cc7506be00d1bcbbb0fefa60b4d08d313", "url": "https://github.com/powsybl/powsybl-core/commit/ec0bf74cc7506be00d1bcbbb0fefa60b4d08d313", "message": "takes into account the matpower in-service attribute for generators and branches\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-04-03T16:03:21Z", "type": "commit"}, {"oid": "d24bef96a91ddee78d4a5f0652fd77e6f3164144", "url": "https://github.com/powsybl/powsybl-core/commit/d24bef96a91ddee78d4a5f0652fd77e6f3164144", "message": "improves sonar's code issues\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-04-08T19:04:05Z", "type": "commit"}, {"oid": "b068e5f4736742a22bb7ff3545be2666b6d8a58c", "url": "https://github.com/powsybl/powsybl-core/commit/b068e5f4736742a22bb7ff3545be2666b6d8a58c", "message": "Merge branch 'master' into matpower_importer", "committedDate": "2020-04-09T14:50:04Z", "type": "commit"}, {"oid": "20a650fdf8a30fec475eb236bd6f38fdac6928d5", "url": "https://github.com/powsybl/powsybl-core/commit/20a650fdf8a30fec475eb236bd6f38fdac6928d5", "message": "align tests to the latest changes from master\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-04-09T15:17:34Z", "type": "commit"}, {"oid": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "url": "https://github.com/powsybl/powsybl-core/commit/770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "message": "improves sonar's code issues\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-04-09T16:43:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2Mzg2OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410063869", "bodyText": "What is the license of the different cases (i.e. compatible with ours)?", "author": "mathbagu", "createdAt": "2020-04-17T08:13:39Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerNetworkFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.powsybl.commons.datasource.ResourceDataSource;\n+import com.powsybl.commons.datasource.ResourceSet;\n+import com.powsybl.iidm.network.Network;\n+import com.powsybl.iidm.network.NetworkFactory;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public final class MatpowerNetworkFactory {", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwMzU1Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412803557", "bodyText": "test cases are the same tests as the ones used in ieee-cdf module (cdf files converted to the matpower format by a MATLAB tool cdf2mpc), so their licenses should be OK, I suppose ...", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2Mzg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDI2Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410064266", "bodyText": "The default date should be the now()\nCoding style: a general remark about constant. The order we have is public first, then private constant.", "author": "mathbagu", "createdAt": "2020-04-17T08:14:27Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNTgyMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412805822", "bodyText": "thanks for your feedback,\n\nfixed the default date: now it's now()\naligned the constant declarations order to the coding style", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDg5MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410064890", "bodyText": "Is it really interesting to ignore the base voltage? Do you have use cases where these values are inconsistent?\nBy convention, you should prefix this parameter name with a prefix to avoid clash. Have a look to XmlImporter, XmlExporter or UcteExporter: I would propose matpower.import.ignore-base-voltage.", "author": "mathbagu", "createdAt": "2020-04-17T08:15:38Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTA4MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412809081", "bodyText": "again, I used the same test cases as the ieee-cdf importer, I thought it 'd be useful to provide the same options...\nI've changed the prefix for the parameter as you suggested", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NDg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NzAzMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410067032", "bodyText": "Question: is there non impedant branches in MatPower format? In that case, could their ends be in the same substation or not?", "author": "mathbagu", "createdAt": "2020-04-17T08:19:44Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDUwOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420290508", "bodyText": "there are not, apparently. fixed", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2NzAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2ODk4NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410068984", "bodyText": "To be check, regarding my previous comment", "author": "mathbagu", "createdAt": "2020-04-17T08:23:24Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDU2Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420290566", "bodyText": "fixed", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2ODk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2OTIxNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410069216", "bodyText": "Use BUS instead?", "author": "mathbagu", "createdAt": "2020-04-17T08:23:48Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNTUyOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412815528", "bodyText": "my general remark for all the ID convention related feedbacks&suggestions: I tried to be as consistent as I could\nwith respect to the existing cdf importer approach (ref. the iidm in the ieee test resources ) in order to have the same generated IDs\n(and make it possible to directly compare the iidm, for example)", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2OTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTE4MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291181", "bodyText": "fixed: used a prefix, consistently", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA2OTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MDYxNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410070616", "bodyText": "All generators are regulating? Could getVoltageMagnitudeSetpoint() be 0, in that case, maybe we should set voltageRegulatorOn to false.", "author": "mathbagu", "createdAt": "2020-04-17T08:26:19Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTM3Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291372", "bodyText": "done", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MDYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MTEyMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410071122", "bodyText": "Should be move in the else block of the next if statement", "author": "mathbagu", "createdAt": "2020-04-17T08:27:15Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTQ4Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291487", "bodyText": "done", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:42:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MjE0OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410072148", "bodyText": "To be consistent with generators (and maybe the rest of this importer), you should set the name for all the identifiables to the ID, or never set it.", "author": "mathbagu", "createdAt": "2020-04-17T08:29:01Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTU1OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291559", "bodyText": "fixed: used a prefix, consistently", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MjE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzI2Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410073262", "bodyText": "Is it OK regarding the sign convention? (same question for all equipments)", "author": "mathbagu", "createdAt": "2020-04-17T08:31:08Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNzUyMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412817523", "bodyText": "it seems OK (consistent with the ieee-cdf importer)", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzY0NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410073645", "bodyText": "Why don't you use the ensureUniqueId feature of IdentifiableAdder?", "author": "mathbagu", "createdAt": "2020-04-17T08:31:53Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTY4OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291689", "bodyText": "fixed", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3MzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDE5Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410074192", "bodyText": "The naming convention is different for generator: for generator you use a prefix, but for loads and shunts you use a post-fix", "author": "mathbagu", "createdAt": "2020-04-17T08:32:58Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTc0OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291749", "bodyText": "fixed: used a prefix, consistently", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDY1NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410074654", "bodyText": "I'm not sure Math.pow is really efficient to compute a square... use voltageLevel.getNominalV() * voltageLevel.getNominalV() / perUnitContext.getBaseMva())", "author": "mathbagu", "createdAt": "2020-04-17T08:33:48Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxNzk3OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412817978", "bodyText": "you're right! done.", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDk4Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410074982", "bodyText": "Same question about ensureUniqueId", "author": "mathbagu", "createdAt": "2020-04-17T08:34:21Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTkwMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291902", "bodyText": "fixed", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NDk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTI0Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410075243", "bodyText": "For branches (lines and transformers), you use a prefix also. See above, try to be consistent", "author": "mathbagu", "createdAt": "2020-04-17T08:34:49Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MTk5MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420291990", "bodyText": "fixed: used a prefix, consistently", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTM2MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410075360", "bodyText": "Same remark", "author": "mathbagu", "createdAt": "2020-04-17T08:35:01Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);\n+        String bus1Id = getBusId(branch.getFrom());\n+        String bus2Id = getBusId(branch.getTo());\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(branch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(branch.getTo());\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjE1Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420292156", "bodyText": "fixed", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:43:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NjAzOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410076038", "bodyText": "To be consistent, maybe you should also log bus1 and bus2 like for transformers", "author": "mathbagu", "createdAt": "2020-04-17T08:36:11Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxODI5MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412818290", "bodyText": "done.", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NjAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjIwMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r420292200", "bodyText": "fixed: used a prefix, consistently", "author": "CBiasuzzi", "createdAt": "2020-05-05T17:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NjAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NzEwNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410077104", "bodyText": "See above, the default date is now. For round trip, you have to set-up a post-processor maybe to fix the date. I'm pretty sure this is the reason why you fix the date!?", "author": "mathbagu", "createdAt": "2020-04-17T08:38:08Z", "path": "matpower/matpower-converter/src/main/java/com/powsybl/matpower/converter/MatpowerImporter.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.converter;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.io.ByteStreams;\n+import com.powsybl.commons.datasource.DataSource;\n+import com.powsybl.commons.datasource.ReadOnlyDataSource;\n+import com.powsybl.iidm.ConversionParameters;\n+import com.powsybl.iidm.import_.Importer;\n+import com.powsybl.iidm.network.*;\n+import com.powsybl.iidm.parameters.Parameter;\n+import com.powsybl.iidm.parameters.ParameterDefaultValueConfig;\n+import com.powsybl.iidm.parameters.ParameterType;\n+import com.powsybl.matpower.model.*;\n+import org.jgrapht.UndirectedGraph;\n+import org.jgrapht.alg.ConnectivityInspector;\n+import org.jgrapht.graph.Pseudograph;\n+import org.joda.time.DateTime;\n+import org.joda.time.DateTimeZone;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+@AutoService(Importer.class)\n+public class MatpowerImporter implements Importer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerImporter.class);\n+\n+    private static final String FORMAT = \"MATPOWER\";\n+\n+    private static final String[] EXTENSIONS = {\"m\", \"mat\"};\n+\n+    public static final LocalDate DEFAULTDATE = LocalDate.of(2020, Month.JANUARY, 1);\n+\n+    private static final Parameter IGNORE_BASE_VOLTAGE_PARAMETER = new Parameter(\"ignore-base-voltage\",\n+            ParameterType.BOOLEAN,\n+            \"Ignore base voltage specified in the file\",\n+            Boolean.TRUE);\n+\n+    private static final class PerUnitContext {\n+\n+        private final double baseMva; // base apparent power\n+\n+        private final boolean ignoreBaseMva;\n+\n+        private PerUnitContext(double baseMva, boolean ignoreBaseMva) {\n+            this.baseMva = baseMva;\n+            this.ignoreBaseMva = ignoreBaseMva;\n+        }\n+\n+        public boolean isIgnoreBaseMva() {\n+            return ignoreBaseMva;\n+        }\n+\n+        private double getBaseMva() {\n+            return baseMva;\n+        }\n+    }\n+\n+    private static ContainersMapping createContainerMapping(MatpowerModel matpowerModel) {\n+        ContainersMapping containersMapping = new ContainersMapping();\n+\n+        // group buses connected to non impedant lines to voltage levels\n+        createVoltageLevelMapping(matpowerModel, containersMapping);\n+\n+        // group voltage levels connected by transformers to substations\n+        createSubstationMapping(matpowerModel, containersMapping);\n+\n+        return containersMapping;\n+    }\n+\n+    private static boolean isTransformer(MBranch branch) {\n+        return branch.getRatio() != 0;\n+    }\n+\n+    private static void createSubstationMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<String, Object> sGraph = new Pseudograph<>(Object.class);\n+        for (String voltageLevelId : containersMapping.voltageLevelIdToBusNums.keySet()) {\n+            sGraph.addVertex(voltageLevelId);\n+        }\n+        for (MBranch branch : model.getBranches()) {\n+            if (isTransformer(branch)) {\n+                sGraph.addEdge(containersMapping.busNumToVoltageLevelId.get(branch.getFrom()),\n+                        containersMapping.busNumToVoltageLevelId.get(branch.getTo()));\n+            }\n+        }\n+        int substationNum = 1;\n+        for (Set<String> voltageLevelIds : new ConnectivityInspector<>(sGraph).connectedSets()) {\n+            String substationId = \"S\" + substationNum++;\n+            for (String voltageLevelId : voltageLevelIds) {\n+                containersMapping.voltageLevelIdToSubstationId.put(voltageLevelId, substationId);\n+            }\n+        }\n+    }\n+\n+    private static void createVoltageLevelMapping(MatpowerModel model, ContainersMapping containersMapping) {\n+        UndirectedGraph<Integer, Object> vlGraph = new Pseudograph<>(Object.class);\n+        for (MBus mBus : model.getBuses()) {\n+            vlGraph.addVertex(mBus.getNumber());\n+        }\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getR() == 0 && mBranch.getX() == 0) {\n+                vlGraph.addEdge(mBranch.getFrom(), mBranch.getTo());\n+            }\n+        }\n+        for (Set<Integer> busNums : new ConnectivityInspector<>(vlGraph).connectedSets()) {\n+            String voltageLevelId = \"VL\" + busNums.iterator().next();\n+            containersMapping.voltageLevelIdToBusNums.put(voltageLevelId, busNums);\n+            for (int busNum : busNums) {\n+                containersMapping.busNumToVoltageLevelId.put(busNum, voltageLevelId);\n+            }\n+        }\n+    }\n+\n+    private static String getBusId(int busNum) {\n+        return \"B\" + busNum;\n+    }\n+\n+    private static void createBuses(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBus mBus : model.getBuses()) {\n+            String voltageLevelId = containerMapping.busNumToVoltageLevelId.get(mBus.getNumber());\n+            String substationId = containerMapping.voltageLevelIdToSubstationId.get(voltageLevelId);\n+\n+            // create substation\n+            Substation substation = createSubstation(network, substationId);\n+\n+            // create voltage level\n+            VoltageLevel voltageLevel = createVoltageLevel(mBus, voltageLevelId, substation, network, perUnitContext);\n+\n+            // create bus\n+            createBus(mBus, voltageLevel);\n+\n+            // create load\n+            createLoad(mBus, voltageLevel);\n+\n+            // create shunt compensator\n+            createShuntCompensator(mBus, voltageLevel, perUnitContext);\n+\n+            //create generators\n+            createGenerators(model, mBus, voltageLevel);\n+        }\n+    }\n+\n+    private static void createGenerators(MatpowerModel model, MBus mBus, VoltageLevel voltageLevel) {\n+        model.getGenerators().stream().filter(gen -> gen.getNumber() == mBus.getNumber()).forEach(mGen -> {\n+            String busId = getBusId(mGen.getNumber());\n+            String genId = createGenId(mGen, voltageLevel.getNetwork());\n+            Generator generator = voltageLevel.newGenerator()\n+                    .setId(genId)\n+                    .setConnectableBus(busId)\n+                    .setBus(isInService(mGen) ? busId : null)\n+                    .setTargetV(mGen.getVoltageMagnitudeSetpoint() * voltageLevel.getNominalV())\n+                    .setTargetP(mGen.getRealPowerOutput())\n+                    .setTargetQ(mGen.getReactivePowerOutput())\n+                    .setVoltageRegulatorOn(true)\n+                    .setMaxP(mGen.getMaximumRealPowerOutput())\n+                    .setMinP(mGen.getMinimumRealPowerOutput())\n+                    .add();\n+\n+            generator.newMinMaxReactiveLimits()\n+                    .setMinQ(mGen.getMinimumReactivePowerOutput())\n+                    .setMaxQ(mGen.getMaximumReactivePowerOutput())\n+                    .add();\n+\n+            if ((mGen.getPc1() != 0) || (mGen.getPc2() != 0)) {\n+                generator.newReactiveCapabilityCurve()\n+                        .beginPoint()\n+                        .setP(mGen.getPc1())\n+                        .setMaxQ(mGen.getQc1Max())\n+                        .setMinQ(mGen.getQc1Min())\n+                        .endPoint()\n+                        .beginPoint()\n+                        .setP(mGen.getPc2())\n+                        .setMaxQ(mGen.getQc2Max())\n+                        .setMinQ(mGen.getQc2Min())\n+                        .endPoint()\n+                        .add();\n+            }\n+        });\n+    }\n+\n+    private static Bus createBus(MBus mBus, VoltageLevel voltageLevel) {\n+        String busId = getBusId(mBus.getNumber());\n+        LOGGER.debug(\"Creating bus {}\", busId);\n+        Bus bus = voltageLevel.getBusBreakerView().newBus()\n+                .setId(busId)\n+                .setName(busId)\n+                .add();\n+        bus.setV(mBus.getVoltageMagnitude() * voltageLevel.getNominalV())\n+                .setAngle(mBus.getVoltageAngle());\n+        return bus;\n+    }\n+\n+    private static Substation createSubstation(Network network, String substationId) {\n+        LOGGER.debug(\"Creating substation {}\", substationId);\n+        Substation substation = network.getSubstation(substationId);\n+        if (substation == null) {\n+            substation = network.newSubstation()\n+                    .setId(substationId)\n+                    .add();\n+        }\n+        return substation;\n+    }\n+\n+    private static VoltageLevel createVoltageLevel(MBus mBus, String voltageLevelId, Substation substation, Network network, PerUnitContext perUnitContext) {\n+        double nominalV = perUnitContext.isIgnoreBaseMva() || mBus.getBaseVoltage() == 0 ? 1 : mBus.getBaseVoltage();\n+        VoltageLevel voltageLevel = network.getVoltageLevel(voltageLevelId);\n+        if (voltageLevel == null) {\n+            LOGGER.debug(\"Creating voltagelevel {}\", voltageLevelId);\n+            voltageLevel = substation.newVoltageLevel()\n+                    .setId(voltageLevelId)\n+                    .setNominalV(nominalV)\n+                    .setTopologyKind(TopologyKind.BUS_BREAKER)\n+                    .add();\n+        }\n+        return voltageLevel;\n+    }\n+\n+    private static void createLoad(MBus mBus, VoltageLevel voltageLevel) {\n+        if (mBus.getRealPowerDemand() != 0 || mBus.getReactivePowerDemand() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String loadId = busId + \"-L\";\n+            LOGGER.debug(\"Creating load {}\", loadId);\n+            voltageLevel.newLoad()\n+                .setId(loadId)\n+                .setConnectableBus(busId)\n+                .setBus(busId)\n+                .setP0(mBus.getRealPowerDemand())\n+                .setQ0(mBus.getReactivePowerDemand())\n+                .add();\n+        }\n+    }\n+\n+    private static String createGenId(MGen mGen, Network network) {\n+        String genIdPrefix = \"G\" + mGen.getNumber() + \"-\";\n+        int uniqueGenSuffix = 0;\n+        String genId;\n+        do {\n+            genId = genIdPrefix + uniqueGenSuffix++;\n+        } while  (network.getIdentifiable(genId) != null);\n+        return genId;\n+    }\n+\n+    private static void createShuntCompensator(MBus mBus, VoltageLevel voltageLevel, PerUnitContext perUnitContext) {\n+        if (mBus.getShuntSusceptance() != 0) {\n+            String busId = getBusId(mBus.getNumber());\n+            String shuntId = busId + \"-SH\";\n+            LOGGER.debug(\"Creating shunt {}\", shuntId);\n+            double zb = Math.pow(voltageLevel.getNominalV(), 2) / perUnitContext.getBaseMva();\n+            voltageLevel.newShuntCompensator()\n+                    .setId(shuntId)\n+                    .setConnectableBus(busId)\n+                    .setBus(busId)\n+                    .setCurrentSectionCount(1)\n+                    .newLinearModel()\n+                        .setMaximumSectionCount(1)\n+                        .setbPerSection(mBus.getShuntSusceptance() / perUnitContext.getBaseMva() / zb)\n+                        .add()\n+                    .add();\n+        }\n+    }\n+\n+    private static String getBranchId(char type, int from, int to, Network network) {\n+        String id;\n+        int uniqueCircuit = 1;\n+        do {\n+            id = \"\" + type + from + \"-\" + to + \"-\" + uniqueCircuit++;\n+        } while (network.getIdentifiable(id) != null);\n+        return id;\n+    }\n+\n+    private static boolean isInService(MBranch branch) {\n+        return Math.abs(branch.getStatus()) > 0;\n+    }\n+\n+    private static boolean isInService(MGen generator) {\n+        return generator.getStatus() > 0;\n+    }\n+\n+    private static void createLine(MBranch branch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String lineId = getBranchId('L', branch.getFrom(), branch.getTo(), network);\n+        LOGGER.debug(\"Creating line {}\", lineId);\n+        String bus1Id = getBusId(branch.getFrom());\n+        String bus2Id = getBusId(branch.getTo());\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(branch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(branch.getTo());\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();\n+        boolean isInService = isInService(branch);\n+        network.newLine()\n+                .setId(lineId)\n+                .setBus1(isInService ? bus1Id : null)\n+                .setConnectableBus1(bus1Id)\n+                .setVoltageLevel1(voltageLevel1Id)\n+                .setBus2(isInService ? bus2Id : null)\n+                .setConnectableBus2(bus2Id)\n+                .setVoltageLevel2(voltageLevel2Id)\n+                .setR(branch.getR() * zb)\n+                .setX(branch.getX() * zb)\n+                .setG1(0)\n+                .setB1(branch.getB() / zb / 2)\n+                .setG2(0)\n+                .setB2(branch.getB() / zb / 2)\n+                .add();\n+    }\n+\n+    private static TwoWindingsTransformer createTransformer(MBranch mBranch, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        String id = getBranchId('T', mBranch.getFrom(), mBranch.getTo(), network);\n+\n+        String bus1Id = getBusId(mBranch.getFrom());\n+        String bus2Id = getBusId(mBranch.getTo());\n+\n+        LOGGER.debug(\"Creating two winding transformer {} {} {}\", id, bus1Id, bus2Id);\n+\n+        // taps at from bus\n+        String voltageLevel1Id = containerMapping.busNumToVoltageLevelId.get(mBranch.getFrom());\n+        String voltageLevel2Id = containerMapping.busNumToVoltageLevelId.get(mBranch.getTo());\n+        VoltageLevel voltageLevel1 = network.getVoltageLevel(voltageLevel1Id);\n+        VoltageLevel voltageLevel2 = network.getVoltageLevel(voltageLevel2Id);\n+        double zb = Math.pow(voltageLevel2.getNominalV(), 2) / perUnitContext.getBaseMva();\n+        boolean isInService = isInService(mBranch);\n+        return voltageLevel2.getSubstation().newTwoWindingsTransformer()\n+                .setId(id)\n+                .setBus1(isInService ? bus1Id : null)\n+                .setConnectableBus1(bus1Id)\n+                .setVoltageLevel1(voltageLevel1Id)\n+                .setBus2(isInService ? bus2Id : null)\n+                .setConnectableBus2(bus2Id)\n+                .setVoltageLevel2(voltageLevel2Id)\n+                .setRatedU1(voltageLevel1.getNominalV() * mBranch.getRatio())\n+                .setRatedU2(voltageLevel2.getNominalV())\n+                .setR(mBranch.getR() * zb)\n+                .setX(mBranch.getX() * zb)\n+                .setG(0)\n+                .setB(mBranch.getB() / zb)\n+            .add();\n+    }\n+\n+    private static void createBranches(MatpowerModel model, ContainersMapping containerMapping, Network network, PerUnitContext perUnitContext) {\n+        for (MBranch mBranch : model.getBranches()) {\n+            if (mBranch.getRatio() == 0) {\n+                createLine(mBranch, containerMapping, network, perUnitContext);\n+            } else {\n+                createTransformer(mBranch, containerMapping, network, perUnitContext);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String getFormat() {\n+        return FORMAT;\n+    }\n+\n+    @Override\n+    public List<Parameter> getParameters() {\n+        return Collections.singletonList(IGNORE_BASE_VOLTAGE_PARAMETER);\n+    }\n+\n+    @Override\n+    public String getComment() {\n+        return \"MATPOWER Format to IIDM converter\";\n+    }\n+\n+    private String findExtension(ReadOnlyDataSource dataSource, boolean throwException) throws IOException {\n+        for (String ext : EXTENSIONS) {\n+            if (dataSource.exists(null, ext)) {\n+                return ext;\n+            }\n+        }\n+        if (throwException) {\n+            throw new MatpowerException(\"File \" + dataSource.getBaseName()\n+                    + \".\" + String.join(\"|\", EXTENSIONS) + \" not found\");\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean exists(ReadOnlyDataSource dataSource) {\n+        try {\n+            String ext = findExtension(dataSource, false);\n+            return dataSource.exists(null, ext);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void copy(ReadOnlyDataSource fromDataSource, DataSource toDataSource) {\n+        Objects.requireNonNull(fromDataSource);\n+        Objects.requireNonNull(toDataSource);\n+        try {\n+            String extFrom = findExtension(fromDataSource, false);\n+            String extTo = findExtension(toDataSource, false);\n+            try (InputStream is = fromDataSource.newInputStream(null, extFrom);\n+                 OutputStream os = toDataSource.newOutputStream(null, extTo, false)) {\n+                ByteStreams.copy(is, os);\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public Network importData(ReadOnlyDataSource dataSource, NetworkFactory networkFactory, Properties parameters) {\n+        Objects.requireNonNull(dataSource);\n+        Objects.requireNonNull(networkFactory);\n+        Network network = networkFactory.createNetwork(dataSource.getBaseName(), FORMAT);\n+\n+        // no info abount time & date from the matpower file, set a  default\n+        ZonedDateTime caseDateTime = DEFAULTDATE.atStartOfDay(ZoneOffset.UTC.normalized());\n+        network.setCaseDate(new DateTime(caseDateTime.toInstant().toEpochMilli(), DateTimeZone.UTC));", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxOTM3Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412819377", "bodyText": "done: I've fixed the date in the test, before the check takes place.", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3NzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTEzOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410079139", "bodyText": "Why don't you use the fromInt() and getValue() methods? If there are useless, remove them?", "author": "mathbagu", "createdAt": "2020-04-17T08:41:52Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MBusTypeConversion.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.conversions.ObjectConversion;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MBusTypeConversion extends ObjectConversion<MBus.Type> {\n+    @Override\n+    protected MBus.Type fromString(String s) {\n+        return MBus.Type.values()[Integer.parseInt(s.trim()) - 1];\n+    }\n+\n+    @Override\n+    public String revert(MBus.Type type) {\n+        return Integer.toString(type.ordinal() + 1);\n+    }", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyMjY3NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r414822674", "bodyText": "fixed", "author": "CBiasuzzi", "createdAt": "2020-04-24T19:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTY1OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410079659", "bodyText": "See my previous comment about constant order.", "author": "mathbagu", "createdAt": "2020-04-17T08:42:45Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.MatFile;\n+import us.hebi.matlab.mat.types.Matrix;\n+import us.hebi.matlab.mat.types.Sources;\n+import us.hebi.matlab.mat.types.Struct;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.powsybl.matpower.model.MatpowerReader.MATPOWER_SUPPORTED_VERSION;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerBinReader.class);\n+    public static final String MATPOWER_STRUCT_NAME = \"mpc\";", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxOTUzMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412819530", "bodyText": "done.", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3OTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDAyMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410080020", "bodyText": "This is not the proper way to initialize a set from a list of constants. Use Sets.of", "author": "mathbagu", "createdAt": "2020-04-17T08:43:27Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinReader.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.MatFile;\n+import us.hebi.matlab.mat.types.Matrix;\n+import us.hebi.matlab.mat.types.Sources;\n+import us.hebi.matlab.mat.types.Struct;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.powsybl.matpower.model.MatpowerReader.MATPOWER_SUPPORTED_VERSION;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerBinReader.class);\n+    public static final String MATPOWER_STRUCT_NAME = \"mpc\";\n+\n+    public MatpowerModel read(InputStream iStream, String caseName) throws IOException {\n+        MatpowerModel model = null;\n+        try (MatFile mat = Mat5.newReader(Sources.wrapInputStream(iStream)).setEntryFilter(entry -> entry.getName().equals(MATPOWER_STRUCT_NAME)).readMat()) {\n+            if (mat.getNumEntries() == 0) {\n+                throw new IllegalStateException(\"not a MATPOWER stream: a structure named '\" + MATPOWER_STRUCT_NAME + \"' is expected.\");\n+            }\n+            Struct mpcStruct = mat.getStruct(MATPOWER_STRUCT_NAME);\n+            Set<String> mpcNames = new HashSet<>(Arrays.asList(\"version\", \"baseMVA\", \"bus\", \"gen\", \"branch\"));", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTA3Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412821072", "bodyText": "isn't Sets.of java9?  I changed it with a guava method, instead.", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:25:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDY4OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410080688", "bodyText": "It's old school code to use I/O ? Does a version with Path exists?\nWe should have an overload with a Path that call the version with the OutputStream (Files.newOutputStream(path))", "author": "mathbagu", "createdAt": "2020-04-17T08:44:45Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.*;\n+import us.hebi.matlab.mat.util.Casts;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinWriter {\n+\n+    private final MatpowerModel model;\n+\n+    public MatpowerBinWriter(MatpowerModel model) {\n+        this.model = Objects.requireNonNull(model);\n+    }\n+\n+    private Struct fillMatStruct(Struct struct) {\n+        List<MBus> buses = model.getBuses();\n+        Matrix busesM = Mat5.newMatrix(buses.size(), 13);\n+        for (int row = 0; row < buses.size(); row++) {\n+            busesM.setDouble(row, 0, buses.get(row).getNumber());\n+            busesM.setDouble(row, 1, buses.get(row).getType().getValue());\n+            busesM.setDouble(row, 2, buses.get(row).getRealPowerDemand());\n+            busesM.setDouble(row, 3, buses.get(row).getReactivePowerDemand());\n+            busesM.setDouble(row, 4, buses.get(row).getShuntConductance());\n+            busesM.setDouble(row, 5, buses.get(row).getShuntSusceptance());\n+            busesM.setDouble(row, 6, buses.get(row).getAreaNumber());\n+            busesM.setDouble(row, 7, buses.get(row).getVoltageMagnitude());\n+            busesM.setDouble(row, 8, buses.get(row).getVoltageAngle());\n+            busesM.setDouble(row, 9, buses.get(row).getBaseVoltage());\n+            busesM.setDouble(row, 10, buses.get(row).getLossZone());\n+            busesM.setDouble(row, 11, buses.get(row).getMaximumVoltageMagnitude());\n+            busesM.setDouble(row, 12, buses.get(row).getMinimumVoltageMagnitude());\n+        }\n+\n+        List<MGen> gens = model.getGenerators();\n+        Matrix gensM = Mat5.newMatrix(gens.size(), 21);\n+        for (int row = 0; row < gens.size(); row++) {\n+            gensM.setDouble(row, 0, gens.get(row).getNumber());\n+            gensM.setDouble(row, 1, gens.get(row).getRealPowerOutput());\n+            gensM.setDouble(row, 2, gens.get(row).getReactivePowerOutput());\n+            gensM.setDouble(row, 3, gens.get(row).getMaximumReactivePowerOutput());\n+            gensM.setDouble(row, 4, gens.get(row).getMinimumReactivePowerOutput());\n+            gensM.setDouble(row, 5, gens.get(row).getVoltageMagnitudeSetpoint());\n+            gensM.setDouble(row, 6, gens.get(row).getTotalMbase());\n+            gensM.setDouble(row, 7, gens.get(row).getStatus());\n+            gensM.setDouble(row, 8, gens.get(row).getMaximumRealPowerOutput());\n+            gensM.setDouble(row, 9, gens.get(row).getMinimumRealPowerOutput());\n+            gensM.setDouble(row, 10, gens.get(row).getPc1());\n+            gensM.setDouble(row, 11, gens.get(row).getPc2());\n+            gensM.setDouble(row, 12, gens.get(row).getQc1Min());\n+            gensM.setDouble(row, 13, gens.get(row).getQc1Max());\n+            gensM.setDouble(row, 14, gens.get(row).getQc2Min());\n+            gensM.setDouble(row, 15, gens.get(row).getQc2Max());\n+            gensM.setDouble(row, 16, gens.get(row).getRampAgc());\n+            gensM.setDouble(row, 17, gens.get(row).getRampTenMinutes());\n+            gensM.setDouble(row, 18, gens.get(row).getRampThirtyMinutes());\n+            gensM.setDouble(row, 19, gens.get(row).getRampQ());\n+            gensM.setDouble(row, 20, gens.get(row).getApf());\n+        }\n+\n+        List<MBranch> branches = model.getBranches();\n+        Matrix branchesM = Mat5.newMatrix(branches.size(), 13);\n+        for (int row = 0; row < branches.size(); row++) {\n+            branchesM.setDouble(row, 0, branches.get(row).getFrom());\n+            branchesM.setDouble(row, 1, branches.get(row).getTo());\n+            branchesM.setDouble(row, 2, branches.get(row).getR());\n+            branchesM.setDouble(row, 3, branches.get(row).getX());\n+            branchesM.setDouble(row, 4, branches.get(row).getB());\n+            branchesM.setDouble(row, 5, branches.get(row).getRateA());\n+            branchesM.setDouble(row, 6, branches.get(row).getRateB());\n+            branchesM.setDouble(row, 7, branches.get(row).getRateC());\n+            branchesM.setDouble(row, 8, branches.get(row).getRatio());\n+            branchesM.setDouble(row, 9, branches.get(row).getPhaseShiftAngle());\n+            branchesM.setDouble(row, 10, branches.get(row).getStatus());\n+            branchesM.setDouble(row, 11, branches.get(row).getAngMin());\n+            branchesM.setDouble(row, 12, branches.get(row).getAngMax());\n+        }\n+\n+        struct.set(\"version\", Mat5.newString(\"2\"))\n+                .set(\"baseMVA\", Mat5.newScalar(100))\n+                .set(\"bus\", busesM)\n+                .set(\"gen\", gensM)\n+                .set(\"branch\", branchesM);\n+        return struct;\n+    }\n+\n+    public void write(File oFile) throws IOException {\n+        try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+            try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                Mat5.writeToFile(matFile, oFile);\n+            }\n+        }\n+    }", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTQyNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412821427", "bodyText": "done.", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MTc5Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410081796", "bodyText": "Could be static", "author": "mathbagu", "createdAt": "2020-04-17T08:46:41Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerBinWriter.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import us.hebi.matlab.mat.format.Mat5;\n+import us.hebi.matlab.mat.types.*;\n+import us.hebi.matlab.mat.util.Casts;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerBinWriter {\n+\n+    private final MatpowerModel model;\n+\n+    public MatpowerBinWriter(MatpowerModel model) {\n+        this.model = Objects.requireNonNull(model);\n+    }\n+\n+    private Struct fillMatStruct(Struct struct) {\n+        List<MBus> buses = model.getBuses();\n+        Matrix busesM = Mat5.newMatrix(buses.size(), 13);\n+        for (int row = 0; row < buses.size(); row++) {\n+            busesM.setDouble(row, 0, buses.get(row).getNumber());\n+            busesM.setDouble(row, 1, buses.get(row).getType().getValue());\n+            busesM.setDouble(row, 2, buses.get(row).getRealPowerDemand());\n+            busesM.setDouble(row, 3, buses.get(row).getReactivePowerDemand());\n+            busesM.setDouble(row, 4, buses.get(row).getShuntConductance());\n+            busesM.setDouble(row, 5, buses.get(row).getShuntSusceptance());\n+            busesM.setDouble(row, 6, buses.get(row).getAreaNumber());\n+            busesM.setDouble(row, 7, buses.get(row).getVoltageMagnitude());\n+            busesM.setDouble(row, 8, buses.get(row).getVoltageAngle());\n+            busesM.setDouble(row, 9, buses.get(row).getBaseVoltage());\n+            busesM.setDouble(row, 10, buses.get(row).getLossZone());\n+            busesM.setDouble(row, 11, buses.get(row).getMaximumVoltageMagnitude());\n+            busesM.setDouble(row, 12, buses.get(row).getMinimumVoltageMagnitude());\n+        }\n+\n+        List<MGen> gens = model.getGenerators();\n+        Matrix gensM = Mat5.newMatrix(gens.size(), 21);\n+        for (int row = 0; row < gens.size(); row++) {\n+            gensM.setDouble(row, 0, gens.get(row).getNumber());\n+            gensM.setDouble(row, 1, gens.get(row).getRealPowerOutput());\n+            gensM.setDouble(row, 2, gens.get(row).getReactivePowerOutput());\n+            gensM.setDouble(row, 3, gens.get(row).getMaximumReactivePowerOutput());\n+            gensM.setDouble(row, 4, gens.get(row).getMinimumReactivePowerOutput());\n+            gensM.setDouble(row, 5, gens.get(row).getVoltageMagnitudeSetpoint());\n+            gensM.setDouble(row, 6, gens.get(row).getTotalMbase());\n+            gensM.setDouble(row, 7, gens.get(row).getStatus());\n+            gensM.setDouble(row, 8, gens.get(row).getMaximumRealPowerOutput());\n+            gensM.setDouble(row, 9, gens.get(row).getMinimumRealPowerOutput());\n+            gensM.setDouble(row, 10, gens.get(row).getPc1());\n+            gensM.setDouble(row, 11, gens.get(row).getPc2());\n+            gensM.setDouble(row, 12, gens.get(row).getQc1Min());\n+            gensM.setDouble(row, 13, gens.get(row).getQc1Max());\n+            gensM.setDouble(row, 14, gens.get(row).getQc2Min());\n+            gensM.setDouble(row, 15, gens.get(row).getQc2Max());\n+            gensM.setDouble(row, 16, gens.get(row).getRampAgc());\n+            gensM.setDouble(row, 17, gens.get(row).getRampTenMinutes());\n+            gensM.setDouble(row, 18, gens.get(row).getRampThirtyMinutes());\n+            gensM.setDouble(row, 19, gens.get(row).getRampQ());\n+            gensM.setDouble(row, 20, gens.get(row).getApf());\n+        }\n+\n+        List<MBranch> branches = model.getBranches();\n+        Matrix branchesM = Mat5.newMatrix(branches.size(), 13);\n+        for (int row = 0; row < branches.size(); row++) {\n+            branchesM.setDouble(row, 0, branches.get(row).getFrom());\n+            branchesM.setDouble(row, 1, branches.get(row).getTo());\n+            branchesM.setDouble(row, 2, branches.get(row).getR());\n+            branchesM.setDouble(row, 3, branches.get(row).getX());\n+            branchesM.setDouble(row, 4, branches.get(row).getB());\n+            branchesM.setDouble(row, 5, branches.get(row).getRateA());\n+            branchesM.setDouble(row, 6, branches.get(row).getRateB());\n+            branchesM.setDouble(row, 7, branches.get(row).getRateC());\n+            branchesM.setDouble(row, 8, branches.get(row).getRatio());\n+            branchesM.setDouble(row, 9, branches.get(row).getPhaseShiftAngle());\n+            branchesM.setDouble(row, 10, branches.get(row).getStatus());\n+            branchesM.setDouble(row, 11, branches.get(row).getAngMin());\n+            branchesM.setDouble(row, 12, branches.get(row).getAngMax());\n+        }\n+\n+        struct.set(\"version\", Mat5.newString(\"2\"))\n+                .set(\"baseMVA\", Mat5.newScalar(100))\n+                .set(\"bus\", busesM)\n+                .set(\"gen\", gensM)\n+                .set(\"branch\", branchesM);\n+        return struct;\n+    }\n+\n+    public void write(File oFile) throws IOException {\n+        try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+            try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                Mat5.writeToFile(matFile, oFile);\n+            }\n+        }\n+    }\n+\n+    public void write(OutputStream oStream) throws IOException {\n+        try (WritableByteChannel channel = Channels.newChannel(oStream)) {\n+            try (Struct struct = fillMatStruct(Mat5.newStruct())) {\n+                try (MatFile matFile = Mat5.newMatFile().addArray(MatpowerBinReader.MATPOWER_STRUCT_NAME, struct)) {\n+                    ByteBuffer bBuffer = getByteBuffer(matFile);\n+                    channel.write(bBuffer);\n+                }\n+            }\n+        }\n+    }\n+\n+    private ByteBuffer getByteBuffer(MatFile matFile) throws IOException {", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjQ0Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822443", "bodyText": "done:  changed this class' methods to static", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjEzNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082137", "bodyText": "Put these methods after the constructor", "author": "mathbagu", "createdAt": "2020-04-17T08:47:20Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerModel {\n+\n+    private final String caseName;\n+    private Double baseMva;\n+\n+    private List<MBus> buses = new ArrayList<>();\n+\n+    private List<MGen> generators = new ArrayList<>();\n+\n+    private List<MBranch> branches = new ArrayList<>();\n+\n+    public String getVersion() {\n+        return version;\n+    }\n+\n+    public void setVersion(String version) {\n+        this.version = version;\n+    }\n+\n+    private String version;", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjUzMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822531", "bodyText": "done", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:27:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjIzNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082234", "bodyText": "Should be final", "author": "mathbagu", "createdAt": "2020-04-17T08:47:30Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerModel.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerModel {\n+\n+    private final String caseName;\n+    private Double baseMva;\n+\n+    private List<MBus> buses = new ArrayList<>();\n+\n+    private List<MGen> generators = new ArrayList<>();\n+\n+    private List<MBranch> branches = new ArrayList<>();", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjYwMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822601", "bodyText": "done", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjUzMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082530", "bodyText": "See my comment about constants", "author": "mathbagu", "createdAt": "2020-04-17T08:48:03Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjY2Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822666", "bodyText": "done", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MjUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mjg5Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410082897", "bodyText": "To be check if some or all of these functions could be static", "author": "mathbagu", "createdAt": "2020-04-17T08:48:43Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";\n+\n+    private String processCaseName(String str) {", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjczMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822730", "bodyText": "done:  changed this class' methods to static", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mjg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mzc4MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r410083781", "bodyText": "Use a double instead of a Double", "author": "mathbagu", "createdAt": "2020-04-17T08:50:17Z", "path": "matpower/matpower-model/src/main/java/com/powsybl/matpower/model/MatpowerReader.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2020, RTE (http://www.rte-france.com)\n+ * This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n+ */\n+package com.powsybl.matpower.model;\n+\n+import com.univocity.parsers.common.processor.BeanListProcessor;\n+import com.univocity.parsers.tsv.TsvParser;\n+import com.univocity.parsers.tsv.TsvParserSettings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * @author Christian Biasuzzi <christian.biasuzzi@techrain.eu>\n+ */\n+public class MatpowerReader {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(MatpowerReader.class);\n+\n+    enum MatpowerSection {\n+        BUS,\n+        BRANCH,\n+        GENERATOR\n+    }\n+\n+    public static final String MATPOWER_SUPPORTED_VERSION = \"2\";\n+\n+    private String processCaseName(String str) {\n+        String str2 = str.replace(';', ' ');\n+        final StringTokenizer st = new StringTokenizer(str2, \" \");\n+        st.nextToken(); // function\n+        st.nextToken(); // mpc\n+        st.nextToken(); // =\n+        return st.nextToken();\n+    }\n+\n+    private String processMatlabAssignment(String str) {\n+        Objects.requireNonNull(str);\n+        String str2 = str.replace(';', ' ');\n+        final StringTokenizer st = new StringTokenizer(str2, \" \");\n+        st.nextToken(); // mpc.XYZ\n+        st.nextToken(); // =\n+        return st.nextToken();\n+    }\n+\n+    private String processMatlabStringAssignment(String str) {\n+        return processMatlabAssignment(str).replace(\"'\", \"\");\n+    }\n+\n+    public MatpowerModel read(InputStream iStream) throws IOException {\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(iStream))) {\n+            return read(reader);\n+        }\n+    }\n+\n+    private boolean canSkipLine(String line) {\n+        return line.startsWith(\"%\") || (line.trim().length() == 0);\n+    }\n+\n+    public MatpowerModel read(BufferedReader reader) throws IOException {\n+        String line = reader.readLine();\n+\n+        String title = processCaseName(line);\n+        MatpowerModel model = new MatpowerModel(title);\n+\n+        MatpowerSection section = null;\n+        List<String> lines = new ArrayList<>();\n+        while ((line = reader.readLine()) != null) {\n+            if (canSkipLine(line)) {\n+                //skip comments and empty lines\n+            } else if (line.startsWith(\"mpc.version \")) {\n+                processVersion(line, model);\n+            }  else if (line.startsWith(\"mpc.baseMVA \")) {\n+                processBaseMva(line, model);\n+            } else if (line.startsWith(\"mpc.bus \")) {\n+                section = MatpowerSection.BUS;\n+            } else if (line.startsWith(\"mpc.gen \")) {\n+                section = MatpowerSection.GENERATOR;\n+            } else if (line.startsWith(\"mpc.branch \")) {\n+                section = MatpowerSection.BRANCH;\n+            } else if (line.startsWith(\"];\")) {\n+                section = processEndSection(model, section, lines);\n+            } else {\n+                if (section != null) {\n+                    lines.add(line);\n+                }\n+            }\n+        }\n+\n+        return model;\n+    }\n+\n+    private void processBaseMva(String line, MatpowerModel model) {\n+        Double baseMva = Double.parseDouble(processMatlabAssignment(line));", "originalCommit": "770dc291d95dd6db144f2d35a1167b1bf1fd9a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMjgxMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1253#discussion_r412822813", "bodyText": "done", "author": "CBiasuzzi", "createdAt": "2020-04-22T09:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4Mzc4MQ=="}], "type": "inlineReview"}, {"oid": "571587417cd38318edb61b99ded7a53836fe4425", "url": "https://github.com/powsybl/powsybl-core/commit/571587417cd38318edb61b99ded7a53836fe4425", "message": "various fixes (requested in a review feedback)\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-04-22T08:51:52Z", "type": "commit"}, {"oid": "8d7544416310ab7ac0b856b9a8f77524c696d12e", "url": "https://github.com/powsybl/powsybl-core/commit/8d7544416310ab7ac0b856b9a8f77524c696d12e", "message": "fixes, from review feedbacks\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-04-24T19:46:15Z", "type": "commit"}, {"oid": "60a34f70d238e791811405c123026da1a4081953", "url": "https://github.com/powsybl/powsybl-core/commit/60a34f70d238e791811405c123026da1a4081953", "message": "Merge branch 'master' into matpower_importer", "committedDate": "2020-04-30T15:44:07Z", "type": "commit"}, {"oid": "0934b13b4f572aba76752b9bffb74d1e3ddc4ae3", "url": "https://github.com/powsybl/powsybl-core/commit/0934b13b4f572aba76752b9bffb74d1e3ddc4ae3", "message": "align to the latest master\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-04-30T16:42:49Z", "type": "commit"}, {"oid": "af7abb7333b50cae4e60311fb78d8ad3e715eac0", "url": "https://github.com/powsybl/powsybl-core/commit/af7abb7333b50cae4e60311fb78d8ad3e715eac0", "message": "fixes patterns for IDs\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-05-04T17:13:25Z", "type": "commit"}, {"oid": "b49b441ac61d3918d8faf6c22bfe2d718b4ccfdc", "url": "https://github.com/powsybl/powsybl-core/commit/b49b441ac61d3918d8faf6c22bfe2d718b4ccfdc", "message": "fixes patterns for IDs\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-05-05T16:46:40Z", "type": "commit"}, {"oid": "51a767682e4f048866c354fd6860045ebd9e1a7a", "url": "https://github.com/powsybl/powsybl-core/commit/51a767682e4f048866c354fd6860045ebd9e1a7a", "message": "fixes copy test\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-05-05T17:28:39Z", "type": "commit"}, {"oid": "285a60ab43805ad806517fc322ef41aa8fa238ae", "url": "https://github.com/powsybl/powsybl-core/commit/285a60ab43805ad806517fc322ef41aa8fa238ae", "message": "improves sonar\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-05-05T17:57:09Z", "type": "commit"}, {"oid": "15974c335626bf42d8e17dbe89f2b09f6c52431d", "url": "https://github.com/powsybl/powsybl-core/commit/15974c335626bf42d8e17dbe89f2b09f6c52431d", "message": "only .mat files are supported now; .m parser related code and resources moved to tests\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-05-15T13:13:08Z", "type": "commit"}, {"oid": "201af69fb50900919cd608ddee64041f83dec4ce", "url": "https://github.com/powsybl/powsybl-core/commit/201af69fb50900919cd608ddee64041f83dec4ce", "message": "removes .m related code from tests\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-05-29T11:59:23Z", "type": "commit"}, {"oid": "d731348dd3e1cca1939d2eb9e14e2747f787af03", "url": "https://github.com/powsybl/powsybl-core/commit/d731348dd3e1cca1939d2eb9e14e2747f787af03", "message": "aligned to the latest master\n\nSigned-off-by: Christian Biasuzzi <christian.biasuzzi@techrain.eu>", "committedDate": "2020-05-29T12:24:58Z", "type": "commit"}, {"oid": "a531444475d6a228450bdde9893e12b42a3afb44", "url": "https://github.com/powsybl/powsybl-core/commit/a531444475d6a228450bdde9893e12b42a3afb44", "message": "Merge branch 'master' into matpower_importer", "committedDate": "2020-06-07T17:33:44Z", "type": "commit"}, {"oid": "350001a3fc32fc63644b41f2b6d56f25bca26d3e", "url": "https://github.com/powsybl/powsybl-core/commit/350001a3fc32fc63644b41f2b6d56f25bca26d3e", "message": "Share containers mapping with IEEE CDF importer\n\nSigned-off-by: Geoffroy Jamgotchian <geoffroy.jamgotchian@rte-france.com>", "committedDate": "2020-06-07T19:48:59Z", "type": "commit"}]}