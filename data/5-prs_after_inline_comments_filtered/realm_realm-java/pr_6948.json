{"pr_number": 6948, "pr_title": "Distinct for non-indexed and linked properties", "pr_createdAt": "2020-06-15T13:31:46Z", "pr_url": "https://github.com/realm/realm-java/pull/6948", "timeline": [{"oid": "f9f2e16b1b5f00d48eed79cf00a451ea3cf2d8d9", "url": "https://github.com/realm/realm-java/commit/f9f2e16b1b5f00d48eed79cf00a451ea3cf2d8d9", "message": "Fixing assertions on related tests", "committedDate": "2020-06-15T13:07:42Z", "type": "commit"}, {"oid": "5dfac4df44e20a6d4cc76c670dd4ca577ad30980", "url": "https://github.com/realm/realm-java/commit/5dfac4df44e20a6d4cc76c670dd4ca577ad30980", "message": "Lift restriction on distinct on linked fields", "committedDate": "2020-06-15T13:07:42Z", "type": "commit"}, {"oid": "928e0f6b860d778d07acd4f06f8136dec2c9510b", "url": "https://github.com/realm/realm-java/commit/928e0f6b860d778d07acd4f06f8136dec2c9510b", "message": "Fix manual distinct implementation", "committedDate": "2020-06-15T13:30:57Z", "type": "commit"}, {"oid": "1ca16b63fb242eac9d384360698ce724e8c3816b", "url": "https://github.com/realm/realm-java/commit/1ca16b63fb242eac9d384360698ce724e8c3816b", "message": "Extend distinct query tests to all types", "committedDate": "2020-06-17T08:45:53Z", "type": "commit"}, {"oid": "6ce712ba8a7f7498cac1357d4b27def14789d415", "url": "https://github.com/realm/realm-java/commit/6ce712ba8a7f7498cac1357d4b27def14789d415", "message": "Fix typo in LinkingObjects documentaiton", "committedDate": "2020-06-17T08:45:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU0NjE2Nw==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r441546167", "bodyText": "A comment why/where this is needed might be good", "author": "cmelchior", "createdAt": "2020-06-17T13:30:46Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java", "diffHunk": "@@ -59,6 +66,8 @@\n @RunWith(AndroidJUnit4.class)\n public class RealmQueryTests extends QueryTests {\n \n+    private static final Object NULL_PLACEHOLDER = new Object();", "originalCommit": "6ce712ba8a7f7498cac1357d4b27def14789d415", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIxOTc4Mg==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r442219782", "bodyText": "Eliminated after updating manual distinct implementation as new implementation supports adding null values directly.", "author": "rorbech", "createdAt": "2020-06-18T13:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU0NjE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU1MTgyNg==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r441551826", "bodyText": "A bit hard to follow, but does make the following tests really easy \ud83d\udc4d", "author": "cmelchior", "createdAt": "2020-06-17T13:38:47Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java", "diffHunk": "@@ -3120,95 +3151,143 @@ public void distinct_failIfAppliedMultipleTimes() {\n                 .distinct(AnnotationIndexTypes.FIELD_INDEX_DATE);\n     }\n \n-    @Test\n-    public void distinct_notIndexedFields() {\n+    private void distinctAllFields(Realm realm, String prefix) {", "originalCommit": "6ce712ba8a7f7498cac1357d4b27def14789d415", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMDI1NQ==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r442220255", "bodyText": "Added a number of comments to assist in reasoning.", "author": "rorbech", "createdAt": "2020-06-18T13:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU1MTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4OTI2NA==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r441589264", "bodyText": "Not sure I understand this?", "author": "cmelchior", "createdAt": "2020-06-17T14:28:46Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java", "diffHunk": "@@ -3705,5 +3867,80 @@ public void limit_invalidValuesThrows() {\n         }\n     }\n \n+    // FIXME Maybe move to QueryDescriptor or maybe even to RealmFieldType?\n+    private boolean supportDistinct(RealmFieldType type) {\n+        switch (type) {\n+            case INTEGER:\n+            case BOOLEAN:\n+            case STRING:\n+            case BINARY:\n+            case DATE:\n+            case FLOAT:\n+            case DOUBLE:\n+            case OBJECT:\n+            case DECIMAL128:\n+            case OBJECT_ID:\n+            case LINKING_OBJECTS:\n+                return true;\n+            case LIST:\n+            case INTEGER_LIST:\n+            case BOOLEAN_LIST:\n+            case STRING_LIST:\n+            case BINARY_LIST:\n+            case DATE_LIST:\n+            case FLOAT_LIST:\n+            case DOUBLE_LIST:\n+            case DECIMAL128_LIST:\n+            case OBJECT_ID_LIST:\n+                return false;\n+        }\n+        // Should never reach here as the above switch is exhaustive\n+        throw new UnsupportedOperationException(\"Unhandled realm field type \" + type);\n+    }\n+\n+    // Manual distinct method for verification. Uses field value's equals.\n+    @NotNull\n+    private Set<List<? super Object>> distinct(RealmResults<DynamicRealmObject> all, Object... fields) {\n+        Set<List<? super Object>> values = new HashSet();\n+\n+        // Parsed hierarchical field accessors\n+        List<String[]> fieldAccessors = new ArrayList<>();\n+        for (Object field : fields) {\n+            fieldAccessors.add(((String) field).split(\"\\\\.\"));\n+        }\n+\n+        for (DynamicRealmObject object : all) {\n+            List<? super Object> elements = new ArrayList<>(fields.length);\n+            for (String[] split : fieldAccessors) {\n+                int i = 0;\n+                while(i < split.length - 1) {\n+                    object = object.get(split[i]);\n+                    i++;\n+                }\n+                String fieldName = split[i];\n+                if (!object.isNull(fieldName)) {\n+                    Object e = object.get(fieldName);\n+                    // Need to convert byte arrays to list to detect duplicates when inserting to values\n+                    if (e instanceof byte[]) {\n+                        elements.add(convertBytesToList((byte[]) e));\n+                    } else {\n+                        elements.add(e);\n+                    }\n+                } else {\n+                    elements.add(NULL_PLACEHOLDER);", "originalCommit": "6ce712ba8a7f7498cac1357d4b27def14789d415", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyMjA1MQ==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r442222051", "bodyText": "Keeping track of null values as they are still considered distinct. Previous implementation used container not allow null values directly. The current list allows null values, so eliminated the NULL_PLACEHOLDER.", "author": "rorbech", "createdAt": "2020-06-18T13:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4OTI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5MDY5Ng==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r441590696", "bodyText": "Does this indexing distincting still makes sense or should it be combined with the above test case?", "author": "cmelchior", "createdAt": "2020-06-17T14:30:41Z", "path": "realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java", "diffHunk": "@@ -3344,46 +3423,104 @@ public void distinct_async_doesNotExist() {\n         looperThread.testComplete();\n     }\n \n+    // Smoke test of async distinct invalid types. Underlying mechanism is the same as for sync test\n+    // (distinct_allFields), so just verifying async mechanism.\n     @Test\n     @RunTestInLooperThread\n     public void distinct_async_invalidTypes() {\n         populateTestRealm(realm, TEST_DATA_SIZE);\n \n-        for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {\n-            try {\n-                realm.where(AllTypes.class).distinct(field).findAllAsync();\n-            } catch (IllegalArgumentException ignored) {\n+        RealmObjectSchema schema = realm.getSchema().getSchemaForClass(AllTypes.CLASS_NAME);\n+\n+        Set<String> fieldNames = schema.getFieldNames();\n+        for (String fieldName : fieldNames) {\n+            String field = fieldName;\n+            RealmFieldType type = schema.getFieldType(fieldName);\n+            if (!supportDistinct(type)) {\n+                try {\n+                    realm.where(AllTypes.class).distinct(field).findAllAsync();\n+                } catch (IllegalArgumentException ignored) {\n+                }\n             }\n         }\n         looperThread.testComplete();\n     }\n \n+    // Smoke test of async distinct index linked types. Underlying mechanism is the same as for sync test\n+    // (distinct_linkedAllFields), so just verifying async mechanism.\n     @Test\n     @RunTestInLooperThread\n     public void distinct_async_indexedLinkedFields() {\n         final long numberOfBlocks = 3;\n         final long numberOfObjects = 3;\n+        final Realm realm = looperThread.getRealm();\n         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);\n \n+        DynamicRealm dynamicRealm = DynamicRealm.createInstance(realm.sharedRealm);\n+        RealmResults<DynamicRealmObject> all = dynamicRealm.where(AnnotationIndexTypes.CLASS_NAME)\n+                .findAll();\n+\n+        AtomicInteger count = new AtomicInteger(0);\n+\n         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {\n-            try {\n-                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + \".\" + field).findAllAsync();\n-                fail(\"Unsupported \" + field + \" linked field\");\n-            } catch (IllegalArgumentException ignored) {\n-            }\n+            String fieldName = AnnotationIndexTypes.FIELD_OBJECT + \".\" + field;\n+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(fieldName).findAllAsync();\n+            looperThread.keepStrongReference(distinct);\n+            distinct.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {\n+                @Override\n+                public void onChange(RealmResults<AnnotationIndexTypes> annotationIndexTypes) {\n+                    Set<List<? super Object>> values = RealmQueryTests.this.distinct(all, fieldName);\n+                    assertEquals(field, values.size(), distinct.size());\n+                    int i = count.incrementAndGet();\n+                    if (i == AnnotationIndexTypes.INDEX_FIELDS.length) {\n+                        looperThread.testComplete();\n+                    }\n+                }\n+            });\n         }\n-        looperThread.testComplete();\n     }\n \n+    // Smoke test of async distinct index linked types. Underlying mechanism is the same as for sync test\n+    // (distinct_linkedAllFields), so just verifying async mechanism.\n     @Test\n     @RunTestInLooperThread\n     public void distinct_async_notIndexedLinkedFields() {\n+        final long numberOfBlocks = 3;\n+        final long numberOfObjects = 3;\n+        final Realm realm = looperThread.getRealm();\n+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);\n+\n+        DynamicRealm dynamicRealm = DynamicRealm.createInstance(realm.sharedRealm);\n+        RealmResults<DynamicRealmObject> all = dynamicRealm.where(AnnotationIndexTypes.CLASS_NAME)\n+                .findAll();\n+\n+        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {", "originalCommit": "6ce712ba8a7f7498cac1357d4b27def14789d415", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjIyNDkwMA==", "url": "https://github.com/realm/realm-java/pull/6948#discussion_r442224900", "bodyText": "As per discussion I have removed explicit differentiation of testing distinct on both indexed and non-indexed fields. The synchronous tests covers all types for direct, linked and nested linked objects. Async and multi argument distinct are only smoke tested for some types and unsupported types.", "author": "rorbech", "createdAt": "2020-06-18T13:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5MDY5Ng=="}], "type": "inlineReview"}, {"oid": "7119c3a81e6c413f234b01420e8440410c604817", "url": "https://github.com/realm/realm-java/commit/7119c3a81e6c413f234b01420e8440410c604817", "message": "Fix failing tests", "committedDate": "2020-06-17T14:38:38Z", "type": "commit"}, {"oid": "f400240e8b19d32a8806929ba096bdcd016702ce", "url": "https://github.com/realm/realm-java/commit/f400240e8b19d32a8806929ba096bdcd016702ce", "message": "Merge branch 'v10' into cr/distinct-for-link-properties", "committedDate": "2020-06-18T12:02:22Z", "type": "commit"}, {"oid": "fb3cf35dec5ce4abad6a4c54cbc60d14e7f8e3b1", "url": "https://github.com/realm/realm-java/commit/fb3cf35dec5ce4abad6a4c54cbc60d14e7f8e3b1", "message": "Updates according to code review", "committedDate": "2020-06-18T13:11:54Z", "type": "commit"}, {"oid": "09409a9dd8a9cdeba990ed05c168c3e7235dcc5a", "url": "https://github.com/realm/realm-java/commit/09409a9dd8a9cdeba990ed05c168c3e7235dcc5a", "message": "Fix distinct tests to actually test linked and nested linked fields", "committedDate": "2020-06-18T13:47:31Z", "type": "commit"}, {"oid": "d237cdc875e2285823f79f2238807519e4d3b41f", "url": "https://github.com/realm/realm-java/commit/d237cdc875e2285823f79f2238807519e4d3b41f", "message": "Fix QueryDescriptorTests", "committedDate": "2020-06-18T14:58:22Z", "type": "commit"}, {"oid": "1cb1ad8648b4445952c123a5d286a03f83154056", "url": "https://github.com/realm/realm-java/commit/1cb1ad8648b4445952c123a5d286a03f83154056", "message": "Merge branch 'v10' into cr/distinct-for-link-properties", "committedDate": "2020-06-18T15:04:13Z", "type": "commit"}]}