{"pr_number": 6786, "pr_title": "Add support for ApiKeyAuthProvider", "pr_createdAt": "2020-03-27T08:43:16Z", "pr_url": "https://github.com/realm/realm-java/pull/6786", "timeline": [{"oid": "392a6e11b3aa1fc6afc6dd1bbc70186a4d81689f", "url": "https://github.com/realm/realm-java/commit/392a6e11b3aa1fc6afc6dd1bbc70186a4d81689f", "message": "Add support for ApiKeyAuthProvider", "committedDate": "2020-03-27T08:37:08Z", "type": "commit"}, {"oid": "5137c16ae8e151b471790a14a4c499ddc902904c", "url": "https://github.com/realm/realm-java/commit/5137c16ae8e151b471790a14a4c499ddc902904c", "message": "Merge branch 'v10' into cm/app/apikeyauthprovider\n\n# Conflicts:\n#\trealm/realm-library/src/main/cpp/CMakeLists.txt\n#\trealm/realm-library/src/objectServer/java/io/realm/RealmApp.java\n#\trealm/realm-library/src/testUtils/java/io/realm/TestHelper.java", "committedDate": "2020-03-29T21:50:41Z", "type": "commit"}, {"oid": "59a0cd0c111216375910a78209da24f4a34b5007", "url": "https://github.com/realm/realm-java/commit/59a0cd0c111216375910a78209da24f4a34b5007", "message": "Merge branch 'v10' into cm/app/apikeyauthprovider\n\n# Conflicts:\n#\trealm/realm-library/src/objectServer/java/io/realm/RealmUser.java", "committedDate": "2020-04-01T08:03:48Z", "type": "commit"}, {"oid": "2a3951c9c135046ed066e64f8adcc136b67c4b42", "url": "https://github.com/realm/realm-java/commit/2a3951c9c135046ed066e64f8adcc136b67c4b42", "message": "Cleanup", "committedDate": "2020-04-01T11:27:41Z", "type": "commit"}, {"oid": "0f1478fb24493f10fe7f668825a6b70ba5bc9e89", "url": "https://github.com/realm/realm-java/commit/0f1478fb24493f10fe7f668825a6b70ba5bc9e89", "message": "Bump minSdk for kotlin-extensions", "committedDate": "2020-04-01T11:31:31Z", "type": "commit"}, {"oid": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "url": "https://github.com/realm/realm-java/commit/4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "message": "Set minSdk for examples", "committedDate": "2020-04-01T11:48:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4MzMyOQ==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402183329", "bodyText": "It can be", "author": "edualonso", "createdAt": "2020-04-02T09:40:33Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NDgxMA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402184810", "bodyText": "Not sure I understand The keys value. Do you mean the value of the key?", "author": "edualonso", "createdAt": "2020-04-02T09:42:55Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NDkxNw==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402184917", "bodyText": "Same as above.", "author": "edualonso", "createdAt": "2020-04-02T09:43:06Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NTIwOA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402185208", "bodyText": "It can be", "author": "edualonso", "createdAt": "2020-04-02T09:43:31Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE4NTM5OA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402185398", "bodyText": "this this", "author": "edualonso", "createdAt": "2020-04-02T09:43:52Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The keys value must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. I can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this this method is called on.", "originalCommit": "4fc51df9d5727d0da2a7e3bcb2a91108d86e6e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "url": "https://github.com/realm/realm-java/commit/4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "message": "Doc updates", "committedDate": "2020-04-02T12:54:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2ODY2Mg==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402668662", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was fetched or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was fetched or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:19:45Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTI3Mw==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402669273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the keys were fetched or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the keys were fetched or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:22:12Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDQ3MA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402670470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was deleted or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was deleted or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:26:31Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchAllApiKeys(RealmApp.Callback<List<RealmUserApiKey>> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<List<RealmUserApiKey>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public List<RealmUserApiKey> run() throws ObjectServerError {\n+                return fetchAllApiKeys();\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @throws ObjectServer if the server failed to delete the API key.\n+     */\n+    public void deleteApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DELETE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @param callback callback used when the the key was deleted or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTYyMA==", "url": "https://github.com/realm/realm-java/pull/6786#discussion_r402671620", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param callback callback used when the the key was enabled or the call failed. The callback\n          \n          \n            \n                 * @param callback callback used when the key was enabled or the call failed. The callback", "author": "nhachicha", "createdAt": "2020-04-03T00:30:26Z", "path": "realm/realm-library/src/objectServer/java/io/realm/ApiKeyAuthProvider.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.realm;\n+\n+import org.bson.types.ObjectId;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nullable;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+/**\n+ * This class exposes functionality for a user to manage API keys under their control.\n+ */\n+public class ApiKeyAuthProvider {\n+\n+    private static final int TYPE_CREATE = 1;\n+    private static final int TYPE_FETCH_SINGLE = 2;\n+    private static final int TYPE_FETCH_ALL = 3;\n+    private static final int TYPE_DELETE = 4;\n+    private static final int TYPE_DISABLE = 5;\n+    private static final int TYPE_ENABLE = 6;\n+\n+    private final RealmUser user;\n+\n+    /**\n+     * Create an instance of this class for a specific user.\n+     *\n+     * @param user user that is controlling the API keys.\n+     */\n+    public ApiKeyAuthProvider(RealmUser user) {\n+        this.user = user;\n+    }\n+\n+    public RealmUser getUser() {\n+        return user;\n+    }\n+\n+    public RealmApp getApp() {\n+        return user.getApp();\n+    }\n+\n+    /**\n+     * Creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @throws ObjectServer if the server failed to create the API key.\n+     * @return the new API key for the user.\n+     */\n+    public RealmUserApiKey createApiKey(String name) throws ObjectServerError {\n+        Util.checkEmpty(name, \"name\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        RealmApp.OsJNIResultCallback<RealmUserApiKey> callback = new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        };\n+        nativeCallFunction(TYPE_CREATE, user.getApp().nativePtr, user.osUser.getNativePtr(), name, callback);\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Asynchronously creates a user API key that can be used to authenticate as the user.\n+     * <p>\n+     * The value of the key must be persisted at this time as this is the only time it is visible.\n+     * <p>\n+     * The key is enabled when created. It can be disabled by calling {@link #disableApiKey(ObjectId)}.\n+     *\n+     * @param name the name of the key\n+     * @param callback callback when key creation has completed or failed. The callback will always\n+     * happen on the same thread as this method is called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask createApiKeyAsync(String name, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous creation of api keys are only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return createApiKey(name);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @throws ObjectServer if the server failed to fetch the API key.\n+     */\n+    public RealmUserApiKey fetchApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<RealmUserApiKey> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_SINGLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIResultCallback<RealmUserApiKey>(success, error) {\n+            @Override\n+            protected RealmUserApiKey mapSuccess(Object result) {\n+                return createKeyFromNative((Object[]) result);\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+    /**\n+     * Fetches a specific user API key associated with the user.\n+     *\n+     * @param id the id of the key to fetch.\n+     * @param callback callback used when the the key was fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchApiKeyAsync(ObjectId id, RealmApp.Callback<RealmUserApiKey> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<RealmUserApiKey>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public RealmUserApiKey run() throws ObjectServerError {\n+                return fetchApiKey(id);\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @throws ObjectServer if the server failed to fetch the API keys.\n+     */\n+    public List<RealmUserApiKey> fetchAllApiKeys() throws ObjectServerError {\n+        AtomicReference<List<RealmUserApiKey>> success = new AtomicReference<>(null);\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_FETCH_ALL, user.getApp().nativePtr, user.osUser.getNativePtr(), null, new RealmApp.OsJNIResultCallback<List<RealmUserApiKey>>(success, error) {\n+            @Override\n+            protected List<RealmUserApiKey> mapSuccess(Object result) {\n+                Object[] keyData = (Object[]) result;\n+                List<RealmUserApiKey> list = new ArrayList<>();\n+                for (int i = 0; i < keyData.length; i++) {\n+                    list.add(createKeyFromNative((Object[]) keyData[i]));\n+                }\n+                return list;\n+            }\n+        });\n+        return RealmApp.handleResult(success, error);\n+    }\n+\n+\n+    /**\n+     * Fetches all API keys associated with the user.\n+     *\n+     * @param callback callback used when the the keys were fetched or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask fetchAllApiKeys(RealmApp.Callback<List<RealmUserApiKey>> callback) {\n+        Util.checkLooperThread(\"Asynchronous fetching an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<List<RealmUserApiKey>>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public List<RealmUserApiKey> run() throws ObjectServerError {\n+                return fetchAllApiKeys();\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @throws ObjectServer if the server failed to delete the API key.\n+     */\n+    public void deleteApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DELETE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Deletes a specific API key created by the user.\n+     *\n+     * @param id the id of the key to delete.\n+     * @param callback callback used when the the key was deleted or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask deleteApiKeyAsync(ObjectId id, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous deleting an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                deleteApiKey(id);\n+                return null;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Disables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to disable.\n+     * @throws ObjectServer if the server failed to disable the API key.\n+     */\n+    public void disableApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_DISABLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Disables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to disable.\n+     * @param callback callback used when the the key was disabled or the call failed. The callback\n+     * will always happen on the same thread as this method was called on.\n+     * @throws IllegalStateException if called from a non-looper thread.\n+     */\n+    public RealmAsyncTask disableApiKeyAsync(ObjectId id, RealmApp.Callback<Void> callback) {\n+        Util.checkLooperThread(\"Asynchronous disabling an api key is only possible from looper threads.\");\n+        return new RealmApp.Request<Void>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {\n+            @Override\n+            public Void run() throws ObjectServerError {\n+                disableApiKey(id);\n+                return null;\n+            }\n+        }.start();\n+    }\n+\n+    /**\n+     * Enables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to enable.\n+     * @throws ObjectServer if the server failed to enable the API key.\n+     */\n+    public void enableApiKey(ObjectId id) throws ObjectServerError {\n+        Util.checkNull(id, \"id\");\n+        AtomicReference<ObjectServerError> error = new AtomicReference<>(null);\n+        nativeCallFunction(TYPE_ENABLE, user.getApp().nativePtr, user.osUser.getNativePtr(), id.toHexString(), new RealmApp.OsJNIVoidResultCallback(error));\n+        RealmApp.handleResult(null, error);\n+    }\n+\n+    /**\n+     * Enables a specific API key created by the user.\n+     *\n+     * @param id the id of the key to enable.\n+     * @param callback callback used when the the key was enabled or the call failed. The callback", "originalCommit": "4a6036b9ec2df25fe97a9194df8f329d9a5bab43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b941b1817dfe13a62a13f30155f0d14291467789", "url": "https://github.com/realm/realm-java/commit/b941b1817dfe13a62a13f30155f0d14291467789", "message": "PR feedback", "committedDate": "2020-04-03T08:57:17Z", "type": "commit"}, {"oid": "e489725fa9f14496990ccb6d0ec0140bb68ad9ac", "url": "https://github.com/realm/realm-java/commit/e489725fa9f14496990ccb6d0ec0140bb68ad9ac", "message": "Missed using global def", "committedDate": "2020-04-03T08:59:31Z", "type": "commit"}]}