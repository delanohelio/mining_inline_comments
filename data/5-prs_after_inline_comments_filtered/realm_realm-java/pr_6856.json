{"pr_number": 6856, "pr_title": "Migrating and fixing SessionTests", "pr_createdAt": "2020-05-15T09:19:56Z", "pr_url": "https://github.com/realm/realm-java/pull/6856", "timeline": [{"oid": "f34ed31cf74339b5ec1cc2f0b9ea7333d2ab83e3", "url": "https://github.com/realm/realm-java/commit/f34ed31cf74339b5ec1cc2f0b9ea7333d2ab83e3", "message": "Move SessionTests to Kotlin source set", "committedDate": "2020-05-14T12:35:54Z", "type": "commit"}, {"oid": "33685b15278aa5cf762759ce6730f4054ebf6f31", "url": "https://github.com/realm/realm-java/commit/33685b15278aa5cf762759ce6730f4054ebf6f31", "message": "Automatic convertion of SessionTests to Kotlin", "committedDate": "2020-05-14T13:12:13Z", "type": "commit"}, {"oid": "cd530c5b8f5be115221ff3d8f41cae6233b84d95", "url": "https://github.com/realm/realm-java/commit/cd530c5b8f5be115221ff3d8f41cae6233b84d95", "message": "Fix Java to Kotlin conversion", "committedDate": "2020-05-14T14:42:18Z", "type": "commit"}, {"oid": "9a634ab549c82c7469f77e0b8674d540d21dc4b6", "url": "https://github.com/realm/realm-java/commit/9a634ab549c82c7469f77e0b8674d540d21dc4b6", "message": "Fix SessionTests", "committedDate": "2020-05-15T09:11:07Z", "type": "commit"}, {"oid": "ec59608977043ec9a0fb92532f5426edfcc65ab7", "url": "https://github.com/realm/realm-java/commit/ec59608977043ec9a0fb92532f5426edfcc65ab7", "message": "Migrate and reenable SyncedRealmMigrationTests", "committedDate": "2020-05-15T16:21:17Z", "type": "commit"}, {"oid": "37c1ebd2e05e019b2d012946151bc3c29106eecf", "url": "https://github.com/realm/realm-java/commit/37c1ebd2e05e019b2d012946151bc3c29106eecf", "message": "Merge branch 'v10' into cr/sync-test-migration-session", "committedDate": "2020-05-15T16:44:31Z", "type": "commit"}, {"oid": "354e67a11c35403333cd19198a9cfe73260cb72b", "url": "https://github.com/realm/realm-java/commit/354e67a11c35403333cd19198a9cfe73260cb72b", "message": "Review comment updates\n\nIncluding:\n- Imports or Asserts\n- Try-with-resource with `use`\n- Session from realm\n- AssertFailsWith for expected exceptions\n- Clean up", "committedDate": "2020-05-18T19:47:24Z", "type": "commit"}, {"oid": "c1882f11d8f1864c8365b9a99747ae898b334eb4", "url": "https://github.com/realm/realm-java/commit/c1882f11d8f1864c8365b9a99747ae898b334eb4", "message": "Merge branch 'v10' into cr/sync-test-migration-session", "committedDate": "2020-05-18T19:47:29Z", "type": "commit"}, {"oid": "13aa71f2a8ba5b0e07eef39712fc82c54cf0c663", "url": "https://github.com/realm/realm-java/commit/13aa71f2a8ba5b0e07eef39712fc82c54cf0c663", "message": "Review comments updates", "committedDate": "2020-05-18T20:20:58Z", "type": "commit"}, {"oid": "0c08e9b8a946c7ac83f2aeabaf92775c0b6872cf", "url": "https://github.com/realm/realm-java/commit/0c08e9b8a946c7ac83f2aeabaf92775c0b6872cf", "message": "Merge branch 'v10' into cr/sync-test-migration-syncedrealmmigration", "committedDate": "2020-05-18T20:21:29Z", "type": "commit"}, {"oid": "25d0e8253dbb2e886fffb87eb053c4ba08adf953", "url": "https://github.com/realm/realm-java/commit/25d0e8253dbb2e886fffb87eb053c4ba08adf953", "message": "Adjust timeout for test to ensure that we never make it in time", "committedDate": "2020-05-19T14:54:07Z", "type": "commit"}, {"oid": "7e0bc286d66982b4f128fc0cd7502af41d12076a", "url": "https://github.com/realm/realm-java/commit/7e0bc286d66982b4f128fc0cd7502af41d12076a", "message": "Merge branch 'v10' into cr/sync-test-migration-session", "committedDate": "2020-05-19T14:56:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxNTcxNg==", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r427815716", "bodyText": "@cmelchior What should this test do? What is an invalid user, logged out maybe?\nFurther, in the current form it is nondeterministic, due to not awaiting connection state, etc.\nCould you sketch suggested test if it still makes sense", "author": "rorbech", "createdAt": "2020-05-20T08:02:47Z", "path": "realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java", "diffHunk": "@@ -1,583 +0,0 @@\n-/*\n- * Copyright 2016 Realm Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.realm;\n-\n-import androidx.test.annotation.UiThreadTest;\n-import androidx.test.ext.junit.runners.AndroidJUnit4;\n-\n-import org.hamcrest.CoreMatchers;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Ignore;\n-import org.junit.Rule;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import io.realm.entities.StringOnly;\n-import io.realm.exceptions.RealmFileException;\n-import io.realm.exceptions.RealmMigrationNeededException;\n-import io.realm.log.RealmLog;\n-import io.realm.entities.StringOnlyModule;\n-import io.realm.rule.RunInLooperThread;\n-import io.realm.rule.RunTestInLooperThread;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@RunWith(AndroidJUnit4.class)\n-public class SessionTests {\n-\n-    private SyncConfiguration configuration;\n-    private TestRealmApp app;\n-    private RealmUser user;\n-\n-    @Rule\n-    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();\n-\n-    @Rule\n-    public final RunInLooperThread looperThread = new RunInLooperThread();\n-\n-    @Before\n-    public void setUp() {\n-        app = new TestRealmApp();\n-        user = SyncTestUtils.createTestUser(app);\n-        configuration = SyncConfiguration.defaultConfig(user, \"default\");\n-    }\n-\n-    @After\n-    public void tearDown() {\n-        if (app != null) {\n-            RealmAppExtKt.close(app);\n-        }\n-    }\n-\n-    @Test\n-    public void get_syncValues() {\n-        SyncSession session = new SyncSession(configuration);\n-        assertEquals(\"ws://127.0.0.1:9090/\", session.getServerUrl().toString());\n-        assertEquals(user, session.getUser());\n-        assertEquals(configuration, session.getConfiguration());\n-    }\n-\n-    @Test\n-    public void addDownloadProgressListener_nullThrows() {\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, null);\n-            fail();\n-        } catch (IllegalArgumentException ignored) {\n-        }\n-    }\n-\n-    @Test\n-    public void addUploadProgressListener_nullThrows() {\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            session.addUploadProgressListener(ProgressMode.CURRENT_CHANGES, null);\n-            fail();\n-        } catch (IllegalArgumentException ignored) {\n-        }\n-    }\n-\n-    @Test\n-    public void removeProgressListener() {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        ProgressListener[] listeners = new ProgressListener[] {\n-                null,\n-                progress -> {\n-                    // Listener 1, not present\n-                },\n-                progress -> {\n-                    // Listener 2, present\n-                }\n-        };\n-        session.addDownloadProgressListener(ProgressMode.CURRENT_CHANGES, listeners[2]);\n-\n-        // Check that remove works unconditionally for all input\n-        for (ProgressListener listener : listeners) {\n-            session.removeProgressListener(listener);\n-        }\n-        realm.close();\n-    }\n-\n-    // Check that a Client Reset is correctly reported.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_clientResetReported() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        String url = \"realm://objectserver.realm.io/default\";\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    String filePathFromError = handler.getOriginalFile().getAbsolutePath();\n-                    String filePathFromConfig = session.getConfiguration().getPath();\n-                    assertEquals(filePathFromError, filePathFromConfig);\n-                    assertFalse(handler.getBackupFile().exists());\n-                    assertTrue(handler.getOriginalFile().exists());\n-\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        RealmSync syncService = user.getApp().getSync();\n-        syncService.simulateClientReset(syncService.getSession((config)));\n-    }\n-\n-    // Check that we can manually execute the Client Reset.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_manualExecuteClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    try {\n-                        handler.executeClientReset();\n-                        fail(\"All Realms should be closed before executing Client Reset can be allowed\");\n-                    } catch(IllegalStateException ignored) {\n-                    }\n-\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // Check that we can use the backup SyncConfiguration to open the Realm.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useBackupSyncConfigurationForClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .schema(StringOnly.class)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-\n-                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\n-                    assertNotNull(backupRealmConfiguration);\n-                    assertFalse(backupRealmConfiguration.isSyncConfiguration());\n-                    assertTrue(backupRealmConfiguration.isRecoveryConfiguration());\n-\n-                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertFalse(backupRealm.isEmpty());\n-                    assertEquals(1, backupRealm.where(StringOnly.class).count());\n-                    assertEquals(\"Foo\", backupRealm.where(StringOnly.class).findAll().first().getChars());\n-                    backupRealm.close();\n-\n-                    // opening a Dynamic Realm should also work\n-                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);\n-                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME);\n-                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();\n-                    assertEquals(1, all.size());\n-                    assertEquals(\"Foo\", all.first().getString(StringOnly.FIELD_CHARS));\n-                    dynamicRealm.close();\n-                    looperThread.testComplete();\n-                })\n-                .modules(new StringOnlyModule())\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // Check that we can open the backup file without using the provided SyncConfiguration,\n-    // this might be the case if the user decide to act upon the client reset later (providing s/he\n-    // persisted the location of the file)\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useBackupSyncConfigurationAfterClientReset() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    // Validate that files have been moved\n-                    assertFalse(handler.getOriginalFile().exists());\n-                    assertTrue(handler.getBackupFile().exists());\n-\n-                    String backupFile = handler.getBackupFile().getAbsolutePath();\n-\n-                    // this SyncConf doesn't specify any module, it will throw a migration required\n-                    // exception since the backup Realm contain only StringOnly table\n-                    RealmConfiguration backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile);\n-\n-                    try {\n-                        Realm.getInstance(backupRealmConfiguration);\n-                        fail(\"Expected to throw a Migration required\");\n-                    } catch (RealmMigrationNeededException expected) {\n-                    }\n-\n-                    // opening a DynamicRealm will work though\n-                    DynamicRealm dynamicRealm = DynamicRealm.getInstance(backupRealmConfiguration);\n-\n-                    dynamicRealm.getSchema().checkHasTable(StringOnly.CLASS_NAME, \"Dynamic Realm should contains \" + StringOnly.CLASS_NAME);\n-                    RealmResults<DynamicRealmObject> all = dynamicRealm.where(StringOnly.CLASS_NAME).findAll();\n-                    assertEquals(1, all.size());\n-                    assertEquals(\"Foo\", all.first().getString(StringOnly.FIELD_CHARS));\n-\n-                    // make sure we can't write to it (read-only Realm)\n-                    try {\n-                        dynamicRealm.beginTransaction();\n-                        fail(\"Can't perform transactions on read-only Realms\");\n-                    } catch (IllegalStateException expected) {\n-                    }\n-                    dynamicRealm.close();\n-\n-                    try {\n-                        SyncConfiguration.forRecovery(backupFile, null, StringOnly.class);\n-                        fail(\"Expected to throw java.lang.Class is not a RealmModule\");\n-                    } catch (IllegalArgumentException expected) {\n-                    }\n-\n-                    // specifying the module will allow to open the typed Realm\n-                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, null, new StringOnlyModule());\n-                    Realm backupRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertFalse(backupRealm.isEmpty());\n-                    assertEquals(1, backupRealm.where(StringOnly.class).count());\n-                    RealmResults<StringOnly> allSorted = backupRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupRealm.close();\n-\n-                    looperThread.testComplete();\n-                })\n-                .modules(new StringOnlyModule())\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    // make sure the backup file Realm is encrypted with the same key as the original synced Realm.\n-    @Test\n-    @RunTestInLooperThread\n-    @Ignore(\"FIXME: Figure out how to fix this\")\n-    public void errorHandler_useClientResetEncrypted() {\n-        RealmUser user = SyncTestUtils.createTestUser(app);\n-        final byte[] randomKey = TestHelper.getRandomKey();\n-        final SyncConfiguration config = configFactory.createSyncConfigurationBuilder(user)\n-                .clientResyncMode(ClientResyncMode.MANUAL)\n-                .encryptionKey(randomKey)\n-                .modules(new StringOnlyModule())\n-                .errorHandler((session, error) -> {\n-                    if (error.getErrorCode() != ErrorCode.CLIENT_RESET) {\n-                        fail(\"Wrong error \" + error.toString());\n-                        return;\n-                    }\n-\n-                    final ClientResetRequiredError handler = (ClientResetRequiredError) error;\n-                    // Execute Client Reset\n-                    looperThread.closeTestRealms();\n-                    handler.executeClientReset();\n-\n-                    RealmConfiguration backupRealmConfiguration = handler.getBackupRealmConfiguration();\n-\n-                    // can open encrypted backup Realm\n-                    Realm backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\n-                    RealmResults<StringOnly> allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupEncryptedRealm.close();\n-\n-                    String backupFile = handler.getBackupFile().getAbsolutePath();\n-                    // build a conf to open a DynamicRealm\n-                    backupRealmConfiguration = SyncConfiguration.forRecovery(backupFile, randomKey, new StringOnlyModule());\n-                    backupEncryptedRealm = Realm.getInstance(backupRealmConfiguration);\n-                    assertEquals(1, backupEncryptedRealm.where(StringOnly.class).count());\n-                    allSorted = backupEncryptedRealm.where(StringOnly.class).findAll();\n-                    assertEquals(\"Foo\", allSorted.get(0).getChars());\n-                    backupEncryptedRealm.close();\n-\n-                    // using wrong key throw\n-                    try {\n-                        Realm.getInstance(SyncConfiguration.forRecovery(backupFile, TestHelper.getRandomKey(), new StringOnlyModule()));\n-                        fail(\"Expected to throw when using wrong encryption key\");\n-                    } catch (RealmFileException expected) {\n-                    }\n-\n-                    looperThread.testComplete();\n-                })\n-                .build();\n-\n-        Realm realm = Realm.getInstance(config);\n-        realm.beginTransaction();\n-        realm.createObject(StringOnly.class).setChars(\"Foo\");\n-        realm.commitTransaction();\n-\n-        looperThread.addTestRealm(realm);\n-\n-        // Trigger error\n-        user.getApp().getSync().simulateClientReset(app.getSync().getSession(configuration));\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void uploadAllLocalChanges_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getOrCreateSession(configuration).uploadAllLocalChanges();\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void uploadAllLocalChanges_withTimeout_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getOrCreateSession(configuration).uploadAllLocalChanges(30, TimeUnit.SECONDS);\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void uploadAllLocalChanges_withTimeout_invalidParametersThrows() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getOrCreateSession(configuration);\n-        try {\n-            try {\n-                session.uploadAllLocalChanges(-1, TimeUnit.SECONDS);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-\n-            try {\n-                //noinspection ConstantConditions\n-                session.uploadAllLocalChanges(1, null);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void uploadAllLocalChanges_returnFalseWhenTimedOut() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            assertFalse(session.uploadAllLocalChanges(100, TimeUnit.MILLISECONDS));\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void downloadAllServerChanges_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getSession(configuration).downloadAllServerChanges();\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void downloadAllServerChanges_withTimeout_throwsOnUiThread() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        try {\n-            app.getSync().getSession(configuration).downloadAllServerChanges(30, TimeUnit.SECONDS);\n-            fail(\"Should throw an IllegalStateException on Ui Thread\");\n-        } catch (IllegalStateException ignored) {\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-\n-    @Test\n-    public void downloadAllServerChanges_withTimeout_invalidParametersThrows() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            try {\n-                session.downloadAllServerChanges(-1, TimeUnit.SECONDS);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-\n-            try {\n-                //noinspection ConstantConditions\n-                session.downloadAllServerChanges(1, null);\n-                fail();\n-            } catch (IllegalArgumentException ignored) {\n-            }\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    public void downloadAllServerChanges_returnFalseWhenTimedOut() throws InterruptedException {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        try {\n-            assertFalse(session.downloadAllServerChanges(100, TimeUnit.MILLISECONDS));\n-        } finally {\n-            realm.close();\n-        }\n-    }\n-\n-    @Test\n-    @UiThreadTest\n-    public void unrecognizedErrorCode_errorHandler() {\n-        AtomicBoolean errorHandlerCalled = new AtomicBoolean(false);\n-        configuration = configFactory.createSyncConfigurationBuilder(user)\n-                .errorHandler((session, error) -> {\n-                    errorHandlerCalled.set(true);\n-                    assertEquals(ErrorCode.UNKNOWN, error.getErrorCode());\n-                    assertEquals(ErrorCode.Category.FATAL, error.getCategory());\n-\n-                })\n-                .build();\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-\n-        TestHelper.TestLogger testLogger = new TestHelper.TestLogger();\n-        RealmLog.add(testLogger);\n-\n-        session.notifySessionError(\"unknown\", 3, \"Unknown Error\");\n-        RealmLog.remove(testLogger);\n-\n-        assertTrue(errorHandlerCalled.get());\n-        assertEquals(\"Unknown error code: 'unknown:3'\", testLogger.message);\n-\n-        realm.close();\n-    }\n-\n-    @Test\n-    public void getSessionThrowsOnNonExistingSession() {\n-        Realm realm = Realm.getInstance(configuration);\n-        SyncSession session = app.getSync().getSession(configuration);\n-        assertEquals(configuration, session.getConfiguration());\n-\n-        // Closing the Realm should remove the session\n-        realm.close();\n-        try {\n-            app.getSync().getSession(configuration);\n-            fail(\"getSession should throw an ISE\");\n-        } catch (IllegalStateException expected) {\n-            assertThat(expected.getMessage(), CoreMatchers.containsString(\n-                    \"No SyncSession found using the path : \"));\n-        }\n-    }\n-\n-    @Test\n-    public void isConnected_falseForInvalidUser() {", "originalCommit": "7e0bc286d66982b4f128fc0cd7502af41d12076a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzNTU0NA==", "url": "https://github.com/realm/realm-java/pull/6856#discussion_r429835544", "bodyText": "Removed the test as we per discussions cannot create an invalid user here.", "author": "rorbech", "createdAt": "2020-05-25T09:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgxNTcxNg=="}], "type": "inlineReview"}, {"oid": "32ce78ade7a2a853efa77ba4da634830960e99b2", "url": "https://github.com/realm/realm-java/commit/32ce78ade7a2a853efa77ba4da634830960e99b2", "message": "Merge branch 'cr/sync-test-migration-syncedrealmmigration' into cr/sync-test-migration-session", "committedDate": "2020-05-20T08:04:16Z", "type": "commit"}, {"oid": "634904ef7b44e54dc2602ef2cee59dfb219ebad0", "url": "https://github.com/realm/realm-java/commit/634904ef7b44e54dc2602ef2cee59dfb219ebad0", "message": "Update to use assertFailsWithMessage", "committedDate": "2020-05-20T08:12:38Z", "type": "commit"}, {"oid": "bc1ad656284738277877e98bf4e6cfd61987d20d", "url": "https://github.com/realm/realm-java/commit/bc1ad656284738277877e98bf4e6cfd61987d20d", "message": "Removed unclear test case", "committedDate": "2020-05-24T09:25:28Z", "type": "commit"}, {"oid": "08fd3c6b2fa5da353f6c750626c000b5857d5b07", "url": "https://github.com/realm/realm-java/commit/08fd3c6b2fa5da353f6c750626c000b5857d5b07", "message": "Merge branch 'v10' into cr/sync-test-migration-session", "committedDate": "2020-05-25T09:08:50Z", "type": "commit"}, {"oid": "c4a80905ba24e09350f7f30998cce901a5fdd1a7", "url": "https://github.com/realm/realm-java/commit/c4a80905ba24e09350f7f30998cce901a5fdd1a7", "message": "Removed superfluous failures", "committedDate": "2020-05-25T09:18:40Z", "type": "commit"}, {"oid": "e5027cb80840a82c1cd63d8a631c1b5c7229fd38", "url": "https://github.com/realm/realm-java/commit/e5027cb80840a82c1cd63d8a631c1b5c7229fd38", "message": "Merge branch 'v10' into cr/sync-test-migration-session", "committedDate": "2020-05-25T13:49:04Z", "type": "commit"}]}