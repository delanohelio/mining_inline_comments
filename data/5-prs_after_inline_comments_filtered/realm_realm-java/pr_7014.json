{"pr_number": 7014, "pr_title": "Add support for watch collection watch streams", "pr_createdAt": "2020-08-03T08:15:50Z", "pr_url": "https://github.com/realm/realm-java/pull/7014", "timeline": [{"oid": "7f45044fc3c95d5cd92a21517072becf3ab7f110", "url": "https://github.com/realm/realm-java/commit/7f45044fc3c95d5cd92a21517072becf3ab7f110", "message": "Support collection watch synchronously", "committedDate": "2020-07-21T17:09:29Z", "type": "commit"}, {"oid": "fd0efe5b4787c8e8be64a341ad010cb959151184", "url": "https://github.com/realm/realm-java/commit/fd0efe5b4787c8e8be64a341ad010cb959151184", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsWatchStream.java\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>", "committedDate": "2020-07-22T10:36:15Z", "type": "commit"}, {"oid": "c32124417cba73e2dfe2dc5025e9b6219fa2947c", "url": "https://github.com/realm/realm-java/commit/c32124417cba73e2dfe2dc5025e9b6219fa2947c", "message": "Update realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>", "committedDate": "2020-07-22T10:52:58Z", "type": "commit"}, {"oid": "27e72349e9b96f1a2eabd50e2c3b9faab9eba2d4", "url": "https://github.com/realm/realm-java/commit/27e72349e9b96f1a2eabd50e2c3b9faab9eba2d4", "message": "Encapsulate access to stream functions\nAsync streams", "committedDate": "2020-07-24T11:20:19Z", "type": "commit"}, {"oid": "6c9b739364ba33d17e602bad0976fd41ad378d36", "url": "https://github.com/realm/realm-java/commit/6c9b739364ba33d17e602bad0976fd41ad378d36", "message": "Clean up", "committedDate": "2020-07-24T15:43:35Z", "type": "commit"}, {"oid": "fdee813124e25e03b57eee816ab5533955ed37cd", "url": "https://github.com/realm/realm-java/commit/fdee813124e25e03b57eee816ab5533955ed37cd", "message": "Introduce ChangeEvent class to handle events", "committedDate": "2020-07-24T18:56:35Z", "type": "commit"}, {"oid": "69d9a2b112ceb635d3146171c9277c5941fd1151", "url": "https://github.com/realm/realm-java/commit/69d9a2b112ceb635d3146171c9277c5941fd1151", "message": "Fix return type", "committedDate": "2020-07-28T07:44:07Z", "type": "commit"}, {"oid": "4becb098783519afbda7aacac8bf1bb76a417d8f", "url": "https://github.com/realm/realm-java/commit/4becb098783519afbda7aacac8bf1bb76a417d8f", "message": "Fix findbugs issues", "committedDate": "2020-07-28T09:02:22Z", "type": "commit"}, {"oid": "e7058c79084f09b256deba911632065d563a9111", "url": "https://github.com/realm/realm-java/commit/e7058c79084f09b256deba911632065d563a9111", "message": "Fix missing switch case", "committedDate": "2020-07-28T09:55:21Z", "type": "commit"}, {"oid": "b4ad81b51d7b958c7ca11c73fc6c26971530c7fe", "url": "https://github.com/realm/realm-java/commit/b4ad81b51d7b958c7ca11c73fc6c26971530c7fe", "message": "Catch http errors", "committedDate": "2020-07-28T10:42:59Z", "type": "commit"}, {"oid": "d5cdaf85343e37d6eef2dd947f684109bd4a7bd8", "url": "https://github.com/realm/realm-java/commit/d5cdaf85343e37d6eef2dd947f684109bd4a7bd8", "message": "Use busy wait instead of sleep", "committedDate": "2020-07-29T13:05:10Z", "type": "commit"}, {"oid": "f9419f93684c986b0d0f6a8654d1ba2edd5350b6", "url": "https://github.com/realm/realm-java/commit/f9419f93684c986b0d0f6a8654d1ba2edd5350b6", "message": "Rename events package", "committedDate": "2020-07-29T16:04:42Z", "type": "commit"}, {"oid": "f11fd233b53dda14e503e9ca1462e817a93503f2", "url": "https://github.com/realm/realm-java/commit/f11fd233b53dda14e503e9ca1462e817a93503f2", "message": "Fix class visibility", "committedDate": "2020-07-29T22:53:43Z", "type": "commit"}, {"oid": "b6746aec9188603355419d6259d8ef7e9c877cda", "url": "https://github.com/realm/realm-java/commit/b6746aec9188603355419d6259d8ef7e9c877cda", "message": "Improve documentation", "committedDate": "2020-07-30T08:22:08Z", "type": "commit"}, {"oid": "539d864acee367d2263437022e5cedc727c993d3", "url": "https://github.com/realm/realm-java/commit/539d864acee367d2263437022e5cedc727c993d3", "message": "Improve stream task thread naming", "committedDate": "2020-07-30T08:29:42Z", "type": "commit"}, {"oid": "b5f97bd95797d978dd10b7ad0c969ea04aecb00e", "url": "https://github.com/realm/realm-java/commit/b5f97bd95797d978dd10b7ad0c969ea04aecb00e", "message": "PR fixes", "committedDate": "2020-07-30T09:54:45Z", "type": "commit"}, {"oid": "217deac3ec18633a1ee15970c94cabfa35fcdfa8", "url": "https://github.com/realm/realm-java/commit/217deac3ec18633a1ee15970c94cabfa35fcdfa8", "message": "Fix nullpointer when closing okio buffers, as they are not being thread safe \ud83d\ude14", "committedDate": "2020-07-30T16:53:20Z", "type": "commit"}, {"oid": "30ac85113920d4b244c9702212ffdf8b94ca663f", "url": "https://github.com/realm/realm-java/commit/30ac85113920d4b244c9702212ffdf8b94ca663f", "message": "Clean up", "committedDate": "2020-07-31T11:48:37Z", "type": "commit"}, {"oid": "f11d988aac149a5f946d3a87e14c57d89a09856c", "url": "https://github.com/realm/realm-java/commit/f11d988aac149a5f946d3a87e14c57d89a09856c", "message": "Merge branch 'v10' into ct/RJAVA-611", "committedDate": "2020-07-31T13:21:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNjU4Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464916582", "bodyText": "With this implementation, you can still change between Async/Sync execution. I don't know if this was intended?\nE.g ... this would work:\nwatcher.getNext()\nwatcher.getAsync()\n\nIf intended, it should probably be named getNextAsync()? Alternatively, we set a mode boolean when calling either getNext/getAsync() and throw if the wrong get method is called. So you choose a mode when calling the first get method. Thoughts?", "author": "cmelchior", "createdAt": "2020-08-04T09:19:01Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamTaskImpl.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamTaskImpl<T> implements RealmEventStreamTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private final ReentrantLock lock;\n+\n+    public RealmEventStreamTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.lock = new ReentrantLock();\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    synchronized EventStream<T> getEventStream() throws IOException {\n+        if (eventStream == null) {\n+            eventStream = executor.run();\n+        }\n+\n+        return this.eventStream;\n+    }\n+\n+    @Override\n+    public BaseChangeEvent<T> getNext() throws IOException {\n+        if (lock.tryLock()) {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464924915", "bodyText": "There are a lot of magic constants here. Is there a spec or something we can refer to for the source of truth for these?", "author": "cmelchior", "createdAt": "2020-08-04T09:33:33Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2NTM4NA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474465384", "bodyText": "This hasn't been addressed.", "author": "cmelchior", "createdAt": "2020-08-21T07:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU3MDAxNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474570016", "bodyText": "Added a link to the realm change events spec:\nhttps://docs.mongodb.com/realm/triggers/database-triggers/index.html#database-change-events", "author": "clementetb", "createdAt": "2020-08-21T09:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNDkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNjkyNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464926924", "bodyText": "Can we forward the underlying http exception message instead? Sometimes the server sends useful information there. \"Http error code considered fatal\" doesn't really provide anything useful.", "author": "cmelchior", "createdAt": "2020-08-04T09:37:04Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpNetworkTransport.java", "diffHunk": "@@ -31,47 +34,82 @@ public OkHttpNetworkTransport(@Nullable HttpLogObfuscator httpLogObfuscator) {\n         this.httpLogObfuscator = httpLogObfuscator;\n     }\n \n+    private okhttp3.Request makeRequest(String method, String url, Map<String, String> headers, String body){\n+        okhttp3.Request.Builder builder = new okhttp3.Request.Builder().url(url);\n+        switch (method) {\n+            case \"get\":\n+                builder.get();\n+                break;\n+            case \"delete\":\n+                builder.delete(RequestBody.create(JSON, body));\n+                break;\n+            case \"patch\":\n+                builder.patch(RequestBody.create(JSON, body));\n+                break;\n+            case \"post\":\n+                builder.post(RequestBody.create(JSON, body));\n+                break;\n+            case \"put\":\n+                builder.put(RequestBody.create(JSON, body));\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown method type: \" + method);\n+        }\n+\n+        for (Map.Entry<String, String> entry : headers.entrySet()) {\n+            builder.addHeader(entry.getKey(), entry.getValue());\n+        }\n+\n+        return builder.build();\n+    }\n+\n     @Override\n     public Response sendRequest(String method, String url, long timeoutMs, Map<String, String> headers, String body) {\n         try {\n             OkHttpClient client = getClient(timeoutMs);\n+\n             okhttp3.Response response = null;\n             try {\n-                Request.Builder builder = new Request.Builder().url(url);\n-                switch(method) {\n-                    case \"get\": builder.get(); break;\n-                    case \"delete\": builder.delete(RequestBody.create(JSON, body)); break;\n-                    case \"patch\": builder.patch(RequestBody.create(JSON, body)); break;\n-                    case \"post\": builder.post(RequestBody.create(JSON, body)); break;\n-                    case \"put\": builder.put(RequestBody.create(JSON, body)); break;\n-                    default: throw new IllegalArgumentException(\"Unknown method type: \"+ method);\n-                }\n+                okhttp3.Request request = makeRequest(method, url, headers, body);\n \n-                for (Map.Entry<String, String> entry : headers.entrySet()) {\n-                    builder.addHeader(entry.getKey(), entry.getValue());\n-                }\n-                Call call = client.newCall(builder.build());\n+                Call call = client.newCall(request);\n                 response = call.execute();\n                 ResponseBody responseBody = response.body();\n                 String result = \"\";\n                 if (responseBody != null) {\n                     result = responseBody.string();\n                 }\n-                return Response.httpResponse(response.code(), parseHeaders(response.headers()), result);\n+                return OkHttpResponse.httpResponse(response.code(), parseHeaders(response.headers()), result);\n             } catch (IOException ex) {\n-                return Response.ioError(ex.toString());\n+                return OkHttpResponse.ioError(ex.toString());\n             } catch (Exception ex) {\n-                return Response.unknownError(ex.toString());\n+                return OkHttpResponse.unknownError(ex.toString());\n             } finally {\n                 if (response != null) {\n                     response.close();\n                 }\n             }\n         } catch (Exception e) {\n-            return Response.unknownError(e.toString());\n+            return OkHttpResponse.unknownError(e.toString());\n         }\n     }\n \n+    @Override\n+    public Response sendStreamingRequest(Request request) throws IOException, AppException {\n+        OkHttpClient client = getStreamClient();\n+\n+        okhttp3.Request okRequest = makeRequest(request.getMethod(), request.getUrl(), request.getHeaders(), request.getBody());\n+\n+        Call call = client.newCall(okRequest);\n+        okhttp3.Response response = call.execute();\n+\n+        if((response.code() >= 300) || ((response.code() < 200) && (response.code() != 0))) {\n+            throw new AppException(ErrorCode.fromNativeError(ErrorCode.Type.HTTP, response.code()), \"http error code considered fatal\");", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYxNTkyMw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474615923", "bodyText": "I was following the pattern in app_utils.hpp.", "author": "clementetb", "createdAt": "2020-08-21T10:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNzgxNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464927816", "bodyText": "It feels a bit awkward and duplicates meaning to have this class named OkHttpResponse since it is already wrapped inside OkHttpNetworkTransport, so it becomes OkHttpNetworkTransport.OkHttpResponse ... OkHttpNetworkTransport.Response seems more readable.", "author": "cmelchior", "createdAt": "2020-08-04T09:38:34Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpNetworkTransport.java", "diffHunk": "@@ -90,14 +128,87 @@ private synchronized OkHttpClient getClient(long timeoutMs) {\n         return client;\n     }\n \n+    private synchronized OkHttpClient getStreamClient() {\n+        if (streamClient == null) {\n+            streamClient = new OkHttpClient.Builder()\n+                    .readTimeout(0, TimeUnit.MILLISECONDS)\n+                    .followRedirects(true)\n+                    .addInterceptor(new LoggingInterceptor(httpLogObfuscator))\n+                    .build();\n+        }\n+\n+        return streamClient;\n+    }\n+\n     // Parse Headers output from OKHttp to the format expected by ObjectStore\n     private Map<String, String> parseHeaders(Headers headers) {\n-        HashMap<String, String> osHeaders = new HashMap<>(headers.size()/2);\n+        HashMap<String, String> osHeaders = new HashMap<>(headers.size() / 2);\n         for (String key : headers.names()) {\n             osHeaders.put(key, headers.get(key));\n         }\n         return osHeaders;\n     }\n \n+    public static class OkHttpResponse extends OsJavaNetworkTransport.Response {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYxNjcxNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474616714", "bodyText": "much better!", "author": "clementetb", "createdAt": "2020-08-21T10:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyNzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMTM4Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464931386", "bodyText": "Not 100% sure why this is in the App class even when package protected? It feels a bit out of place?", "author": "cmelchior", "createdAt": "2020-08-04T09:44:45Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/App.java", "diffHunk": "@@ -511,16 +514,34 @@ public AppConfiguration getConfiguration() {\n     }\n \n     /**\n-     * Exposed for testing.\n+     * Creates a request for a streaming function\n      *\n+     * @param user         that requests the execution\n+     * @param functionName name of the function\n+     * @param bsonArgs     function arguments as a {@link BsonArray}\n+     * @param serviceName  service that will handle the function\n+     * @return {@link io.realm.internal.objectstore.OsJavaNetworkTransport.Request}\n+     */\n+    OsJavaNetworkTransport.Request makeStreamingRequest(User user,", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMTkyNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465031926", "bodyText": "I placed makeStreamingRequest there because it is an actual method of the obj-store app class. I thought it was the right pattern to reflect native methods on Java.", "author": "clementetb", "createdAt": "2020-08-04T13:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMTM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMjkwOA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464932908", "bodyText": "Having this being public makes it part of the public API, which is probably a mistake?", "author": "cmelchior", "createdAt": "2020-08-04T09:47:26Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/StreamNetworkTransportImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import org.bson.BsonArray;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.network.StreamNetworkTransport;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+\n+public class StreamNetworkTransportImpl extends StreamNetworkTransport {", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzU0NA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933544", "bodyText": "These should probably be wrapped in <a href ... tags to render correctly?", "author": "cmelchior", "createdAt": "2020-08-04T09:48:36Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MDgwMQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r465150801", "bodyText": "Yes, it needs the  tag!", "author": "clementetb", "createdAt": "2020-08-04T15:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzYxMg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933612", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-08-04T09:48:43Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation\n+     * around how to define a match filter.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to defining the match\n+     * expression for triggers: https://docs.mongodb.com/realm/triggers/database-triggers/", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzMzY2OQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r464933669", "bodyText": "Same", "author": "cmelchior", "createdAt": "2020-08-04T09:48:51Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +814,101 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation\n+     * around how to define a match filter.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to defining the match\n+     * expression for triggers: https://docs.mongodb.com/realm/triggers/database-triggers/\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(Document matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided BSON document will be used as a match expression filter on\n+     * the change events coming from the stream.\n+     * <p>\n+     * See https://docs.mongodb.com/manual/reference/operator/aggregation/match/ for documentation", "originalCommit": "f11d988aac149a5f946d3a87e14c57d89a09856c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf9653563af30491ecdeacc1ce04663c627916ac", "url": "https://github.com/realm/realm-java/commit/bf9653563af30491ecdeacc1ce04663c627916ac", "message": "Implement PR requests", "committedDate": "2020-08-10T17:00:57Z", "type": "commit"}, {"oid": "825c53fb171aff79a15bbcbcc5b712d7717df56a", "url": "https://github.com/realm/realm-java/commit/825c53fb171aff79a15bbcbcc5b712d7717df56a", "message": "Remove any stream internal functionality from the public API", "committedDate": "2020-08-11T10:26:56Z", "type": "commit"}, {"oid": "00ce1bc0fd2ee01ab0ccce02e5fa1b8cff8bda4d", "url": "https://github.com/realm/realm-java/commit/00ce1bc0fd2ee01ab0ccce02e5fa1b8cff8bda4d", "message": "Update changelog", "committedDate": "2020-08-11T11:23:52Z", "type": "commit"}, {"oid": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "url": "https://github.com/realm/realm-java/commit/159bcadff210c5d0cc68440e2d5cee9d563173a6", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-11T19:39:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MDY5NA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469050694", "bodyText": "Maybe just Unknown key: %s", "author": "rorbech", "createdAt": "2020-08-12T07:10:21Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.\n+     */\n+    public static void keyPresent(final String key, final Map<String, ?> map) {\n+        if (!map.containsKey(key)) {\n+            throw new IllegalStateException(\n+                    String.format(\"expected %s to be present\", key));", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDMxMA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469134310", "bodyText": "I copied the code directly from stitch and didnt realize the phrasing", "author": "clementetb", "createdAt": "2020-08-12T09:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MTQ1Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469051457", "bodyText": "Funny phrasing.", "author": "rorbech", "createdAt": "2020-08-12T07:11:55Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MTYwOQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469051609", "bodyText": "Does not match exception thrown.", "author": "rorbech", "createdAt": "2020-08-12T07:12:12Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzgwMA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469053800", "bodyText": "Following naming from other check functions would give an immediate impression that this is actually throwing an exception if key is not present.", "author": "rorbech", "createdAt": "2020-08-12T07:16:36Z", "path": "realm/realm-library/src/main/java/io/realm/internal/Util.java", "diffHunk": "@@ -220,4 +221,16 @@ public static synchronized boolean isRxJavaAvailable() {\n         return rxJavaAvailable;\n     }\n \n+    /**\n+     * Throw IllegalStateException if key is not present in map.\n+     * @param key the key to expect.\n+     * @param map the map to search.\n+     * @throws IllegalArgumentException if key is not in map.\n+     */\n+    public static void keyPresent(final String key, final Map<String, ?> map) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMzk4NQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474523985", "bodyText": "Great! Much better", "author": "clementetb", "createdAt": "2020-08-21T08:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1MzgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY0Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469057647", "bodyText": "Is this semantically correct?", "author": "rorbech", "createdAt": "2020-08-12T07:24:08Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmResultTaskImpl.java", "diffHunk": "@@ -122,6 +122,7 @@ private void postError(RealmNotifier handler,\n             public void run() {\n                 if (!isCancelled) {\n                     callback.onResult(App.Result.withError(error));\n+                    isCancelled = true;", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzMjk1Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474532957", "bodyText": "No. I forgot to remove it.", "author": "clementetb", "createdAt": "2020-08-21T08:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTA2OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469059068", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return the serialized document.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @return the serialized document.", "author": "rorbech", "createdAt": "2020-08-12T07:27:01Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDA5MQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469060091", "bodyText": "Use local variables for something that is retrieved multiple times.", "author": "rorbech", "createdAt": "2020-08-12T07:28:58Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ2NDc1Mw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474464753", "bodyText": "This hasn't been addressed", "author": "cmelchior", "createdAt": "2020-08-21T07:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MTMxNQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469061315", "bodyText": "Maybe considering a specific stream related error code when protocol is not met in ErrorCodes.java instead of propagating the InvalidStateException?", "author": "rorbech", "createdAt": "2020-08-12T07:31:16Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NTY3OQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474555679", "bodyText": "much better \ud83d\udc4c\ud83d\udc4c", "author": "clementetb", "createdAt": "2020-08-21T09:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTgwNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469065806", "bodyText": "Only taking CRUD operations into account. Are the invalidate events not to be considered at our level?", "author": "rorbech", "createdAt": "2020-08-12T07:39:48Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {\n+        static final String ID_FIELD = \"_id\";\n+        static final String OPERATION_TYPE_FIELD = \"operationType\";\n+        static final String FULL_DOCUMENT_FIELD = \"fullDocument\";\n+        static final String DOCUMENT_KEY_FIELD = \"documentKey\";\n+\n+        static final String NS_FIELD = \"ns\";\n+        static final String NS_DB_FIELD = \"db\";\n+        static final String NS_COLL_FIELD = \"coll\";\n+\n+        static final String UPDATE_DESCRIPTION_FIELD = \"updateDescription\";\n+        static final String WRITE_PENDING_FIELD = \"writePending\";\n+    }\n+\n+    /**\n+     * Returns the appropriate local operation type enum value based on the remote operation type\n+     * string from a change stream event.\n+     *\n+     * @param type the string description of the operation type.\n+     * @return the operation type.\n+     */\n+    private static OperationType fromRemote(final String type) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NzQyNw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474557427", "bodyText": "They are not: https://docs.mongodb.com/realm/triggers/database-triggers/index.html", "author": "clementetb", "createdAt": "2020-08-21T09:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2NTkzMg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469065932", "bodyText": "Same as above", "author": "rorbech", "createdAt": "2020-08-12T07:39:58Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.events;\n+\n+import org.bson.BsonBoolean;\n+import org.bson.BsonDocument;\n+import org.bson.BsonString;\n+import org.bson.BsonValue;\n+import org.bson.codecs.DecoderContext;\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import io.realm.mongodb.mongo.MongoNamespace;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+import io.realm.mongodb.mongo.events.UpdateDescription;\n+\n+import static io.realm.internal.Util.keyPresent;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.DELETE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.INSERT;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.REPLACE;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UNKNOWN;\n+import static io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType.UPDATE;\n+\n+public class ChangeEvent<DocumentT> extends BaseChangeEvent<DocumentT> {\n+    private final BsonDocument id; // Metadata related to the operation (the resumeToken).\n+    private final MongoNamespace ns;\n+\n+    /**\n+     * Constructs a change event.\n+     *\n+     * @param id The id of the change event.\n+     * @param operationType The operation type represented by the change event.\n+     * @param fullDocument The full document at some point after the change is applied.\n+     * @param ns The namespace (database and collection) of the document.\n+     * @param documentKey The id if the underlying document that changed.\n+     * @param updateDescription The description of what has changed (for updates only).\n+     * @param hasUncommittedWrites Whether this represents a local uncommitted write.\n+     */\n+    private ChangeEvent(\n+            final BsonDocument id,\n+            final OperationType operationType,\n+            final DocumentT fullDocument,\n+            final MongoNamespace ns,\n+            final BsonDocument documentKey,\n+            final UpdateDescription updateDescription,\n+            final boolean hasUncommittedWrites\n+    ) {\n+        super(operationType, fullDocument, documentKey, updateDescription, hasUncommittedWrites);\n+\n+        this.id = id;\n+        this.ns = ns;\n+    }\n+\n+    /**\n+     * Returns the ID of the change event itself.\n+     *\n+     * @return the id of this change event.\n+     */\n+    public BsonDocument getId() {\n+        return id;\n+    }\n+\n+    /**\n+     * The namespace the change relates to.\n+     *\n+     * @return the namespace.\n+     */\n+    public MongoNamespace getNamespace() {\n+        return ns;\n+    }\n+\n+    /**\n+     * Creates a copy of this change event with uncommitted writes flag set to false.\n+     *\n+     * @return new change event without uncommitted writes flag\n+     */\n+    public ChangeEvent<DocumentT> withoutUncommittedWrites() {\n+        return new ChangeEvent<>(this.getId(),\n+                this.getOperationType(),\n+                this.getFullDocument(),\n+                this.getNamespace(),\n+                this.getDocumentKey(),\n+                this.getUpdateDescription(),\n+                false);\n+    }\n+\n+    /**\n+     * Serializes this change event into a {@link BsonDocument}.\n+     * @return the serialized document.\n+     */\n+    @Override\n+    public BsonDocument toBsonDocument() {\n+        final BsonDocument asDoc = new BsonDocument();\n+        asDoc.put(Fields.ID_FIELD, id);\n+\n+        asDoc.put(Fields.OPERATION_TYPE_FIELD, new BsonString(toRemote(getOperationType())));\n+\n+        final BsonDocument nsDoc = new BsonDocument();\n+        nsDoc.put(Fields.NS_DB_FIELD, new BsonString(ns.getDatabaseName()));\n+        nsDoc.put(Fields.NS_COLL_FIELD, new BsonString(getNamespace().getCollectionName()));\n+        asDoc.put(Fields.NS_FIELD, nsDoc);\n+\n+        asDoc.put(Fields.DOCUMENT_KEY_FIELD, getDocumentKey());\n+\n+        if (getFullDocument() != null && (getFullDocument() instanceof BsonValue)\n+                && ((BsonValue) getFullDocument()).isDocument()) {\n+            asDoc.put(Fields.FULL_DOCUMENT_FIELD, (BsonValue) getFullDocument());\n+        }\n+\n+        if (getUpdateDescription() != null) {\n+            asDoc.put(Fields.UPDATE_DESCRIPTION_FIELD, getUpdateDescription().toBsonDocument());\n+        }\n+\n+        asDoc.put(Fields.WRITE_PENDING_FIELD, new BsonBoolean(hasUncommittedWrites()));\n+        return asDoc;\n+    }\n+\n+    /**\n+     * Deserializes a {@link BsonDocument} into an instance of change event.\n+     * @param document the serialized document\n+     * @return the deserialized change event\n+     */\n+    static <T> ChangeEvent<T> fromBsonDocument(final BsonDocument document, final Class<T> documentClass, CodecRegistry codecRegistry) {\n+        keyPresent(Fields.ID_FIELD, document);\n+        keyPresent(Fields.OPERATION_TYPE_FIELD, document);\n+        keyPresent(Fields.NS_FIELD, document);\n+        keyPresent(Fields.DOCUMENT_KEY_FIELD, document);\n+\n+        final BsonDocument nsDoc = document.getDocument(Fields.NS_FIELD);\n+\n+        final UpdateDescription updateDescription;\n+        if (document.containsKey(Fields.UPDATE_DESCRIPTION_FIELD)) {\n+            updateDescription = UpdateDescription.fromBsonDocument(\n+                    document.getDocument(Fields.UPDATE_DESCRIPTION_FIELD)\n+            );\n+        } else {\n+            updateDescription = null;\n+        }\n+\n+        final T fullDocument;\n+\n+        if (document.containsKey(Fields.FULL_DOCUMENT_FIELD)) {\n+            final BsonValue fdVal = document.get(Fields.FULL_DOCUMENT_FIELD);\n+            if (fdVal.isDocument()) {\n+                fullDocument = codecRegistry.get(documentClass).decode(fdVal.asDocument().asBsonReader(), DecoderContext.builder().build());\n+            } else {\n+                fullDocument = null;\n+            }\n+        } else {\n+            fullDocument = null;\n+        }\n+\n+        return new ChangeEvent<>(\n+                document.getDocument(Fields.ID_FIELD),\n+                fromRemote(document.getString(Fields.OPERATION_TYPE_FIELD).getValue()),\n+                fullDocument,\n+                new MongoNamespace(\n+                        nsDoc.getString(Fields.NS_DB_FIELD).getValue(),\n+                        nsDoc.getString(Fields.NS_COLL_FIELD).getValue()),\n+                document.getDocument(Fields.DOCUMENT_KEY_FIELD),\n+                updateDescription,\n+                document.getBoolean(Fields.WRITE_PENDING_FIELD, BsonBoolean.FALSE).getValue());\n+    }\n+\n+    private static final class Fields {\n+        static final String ID_FIELD = \"_id\";\n+        static final String OPERATION_TYPE_FIELD = \"operationType\";\n+        static final String FULL_DOCUMENT_FIELD = \"fullDocument\";\n+        static final String DOCUMENT_KEY_FIELD = \"documentKey\";\n+\n+        static final String NS_FIELD = \"ns\";\n+        static final String NS_DB_FIELD = \"db\";\n+        static final String NS_COLL_FIELD = \"coll\";\n+\n+        static final String UPDATE_DESCRIPTION_FIELD = \"updateDescription\";\n+        static final String WRITE_PENDING_FIELD = \"writePending\";\n+    }\n+\n+    /**\n+     * Returns the appropriate local operation type enum value based on the remote operation type\n+     * string from a change stream event.\n+     *\n+     * @param type the string description of the operation type.\n+     * @return the operation type.\n+     */\n+    private static OperationType fromRemote(final String type) {\n+        switch (type) {\n+            case \"insert\":\n+                return INSERT;\n+            case \"delete\":\n+                return DELETE;\n+            case \"replace\":\n+                return REPLACE;\n+            case \"update\":\n+                return UPDATE;\n+            default:\n+                return UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Converts this operation to the remote string representation of the operation as\n+     * represented in a {@link ChangeEvent} from a remote cluster.\n+     *\n+     * @return the remote representation of the update operation.\n+     */\n+    private String toRemote(OperationType operationType) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2OTY4MA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469069680", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Fetch the next event from a given stream\n          \n          \n            \n                 * Fetch the next event from a given stream.", "author": "rorbech", "createdAt": "2020-08-12T07:46:55Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/EventStream.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.objectserver;\n+\n+import java.io.IOException;\n+\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public interface EventStream<T> {\n+    /**\n+     * Fetch the next event from a given stream", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3MjQyMg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469072422", "bodyText": "Maybe we should consider using the codec registry to allow automatic conversion from all sorts of arguments. This could also collapse the method with the below. See the Functions.callFunction implementation for details.", "author": "rorbech", "createdAt": "2020-08-12T07:51:54Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/objectstore/OsMongoCollection.java", "diffHunk": "@@ -525,34 +550,93 @@ protected ResultT mapSuccess(Object result) {\n         }\n     }\n \n+    private EventStream<DocumentT> watchInternal(int type, @Nullable BsonArray ids, @Nullable BsonDocument matchFilter) throws IOException {\n+        BsonArray args = new BsonArray();\n+        BsonDocument watchArgs = new BsonDocument(\"database\", new BsonString(namespace.getDatabaseName()));\n+        args.add(watchArgs);\n+\n+        watchArgs.put(\"collection\", new BsonString(namespace.getCollectionName()));\n+\n+        switch (type) {\n+            case WATCH:\n+                break;\n+            case WATCH_IDS:\n+                watchArgs.put(\"ids\", ids);\n+                break;\n+            case WATCH_WITH_FILTER:\n+                watchArgs.put(\"filter\", matchFilter);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid watch type: \" + type);\n+        }\n+\n+        OsJavaNetworkTransport.Request request = streamNetworkTransport.makeStreamingRequest(\"watch\", args, serviceName);\n+        OsJavaNetworkTransport.Response response = streamNetworkTransport.sendRequest(request);\n+\n+        return new NetworkEventStream<>(response, codecRegistry, documentClass);\n+    }\n+\n+    public EventStream<DocumentT> watch() throws IOException {\n+        return watchInternal(WATCH, null, null);\n+    }\n+\n+    public EventStream<DocumentT> watch(final BsonValue... ids) throws IOException {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTU2OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469075568", "bodyText": "Seems a bit general!?", "author": "rorbech", "createdAt": "2020-08-12T07:57:35Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/ErrorCode.java", "diffHunk": "@@ -47,6 +47,8 @@\n     BSON_CODEC_NOT_FOUND(Type.JAVA, 1100),\n     BSON_ENCODING(Type.JAVA, 1101),\n     BSON_DECODING(Type.JAVA, 1102),\n+    // Java errors\n+    RUNTIME_EXCEPTION(Type.JAVA, 1200),", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0NTE1Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469145152", "bodyText": "It helps to catch generic errors as in RealmEventStreamAsyncTaskImpl.java", "author": "clementetb", "createdAt": "2020-08-12T09:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1MTY1Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469151656", "bodyText": "As suggested elsewhere it would might be an idea to segment it to indicate a stream protocol error or similar, to make it a bit clearer to reason about", "author": "rorbech", "createdAt": "2020-08-12T10:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3Njc1MQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469076751", "bodyText": "Maybe use codec registry to allow automatic argument conversion as in Functions.callFunction. Would allow collapsing this with the below method.", "author": "rorbech", "createdAt": "2020-08-12T07:59:45Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +816,194 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NzU2Mg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469077562", "bodyText": "Same as previous with automatic argument conversion.", "author": "rorbech", "createdAt": "2020-08-12T08:01:18Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/mongo/MongoCollection.java", "diffHunk": "@@ -805,4 +816,194 @@ public ResultT run() {\n             }\n         });\n     }\n+\n+    /**\n+     * Watches a collection. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch() {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final BsonValue... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection. This convenience overload supports the use case\n+     * of non-{@link BsonValue} instances of {@link ObjectId} by wrapping them in\n+     * {@link BsonObjectId} instances for the user.\n+     *\n+     * @param ids unique object identifiers of the IDs to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watch(final ObjectId... ids) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch(ids);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided document will be used as a match expression filter on\n+     * the change events coming from the stream. This convenience overload supports the use of\n+     * non-{@link BsonDocument} instances for the user.\n+     * <p>\n+     * See <a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/match/\" target=\"_blank\">how to define a match filter</a>.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to\n+     * <a href=\"https://docs.mongodb.com/realm/triggers/database-triggers/\" target=\"_blank\">how to define the match expression for triggers</a>\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(Document matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection. The provided BSON document will be used as a match expression filter on\n+     * the change events coming from the stream.\n+     * <p>\n+     * See <a href=\"https://docs.mongodb.com/manual/reference/operator/aggregation/match/\" target=\"_blank\">how to define a match filter</a>.\n+     * <p>\n+     * Defining the match expression to filter ChangeEvents is similar to\n+     * <a href=\"https://docs.mongodb.com/realm/triggers/database-triggers/\" target=\"_blank\">how to define the match expression for triggers</a>\n+     *\n+     * @param matchFilter the $match filter to apply to incoming change events\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamTask<DocumentT> watchWithFilter(BsonDocument matchFilter) {\n+        return new RealmEventStreamTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watchWithFilter(matchFilter);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches a collection asynchronously. The resulting stream will be notified of all events on this collection\n+     * that the active user is authorized to see based on the configured MongoDB Realm rules.\n+     *\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamAsyncTask<DocumentT> watchAsync() {\n+        return new RealmEventStreamAsyncTaskImpl<>(getNamespace().getFullName(),\n+                new RealmEventStreamAsyncTaskImpl.Executor<DocumentT>() {\n+                    @Override\n+                    public EventStream<DocumentT> run() throws IOException {\n+                        return osMongoCollection.watch();\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Watches specified IDs in a collection asynchronously.\n+     *\n+     * @param ids the ids to watch.\n+     * @return a task that provides access to the stream of change events.\n+     */\n+    public RealmEventStreamAsyncTask<DocumentT> watchAsync(final BsonValue... ids) {", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NjcxMA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469086710", "bodyText": "We should probably guard this catching all non IOExceptions too and emit them as some other error to prevents accidential crashes.", "author": "rorbech", "createdAt": "2020-08-12T08:18:30Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamAsyncTaskImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamAsyncTaskImpl<T> implements RealmEventStreamAsyncTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private Thread thread;\n+\n+    public RealmEventStreamAsyncTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public synchronized void get(App.Callback<BaseChangeEvent<T>> callback) throws IllegalStateException {\n+        Util.checkNull(callback, \"callback\");\n+\n+        if (thread != null) {\n+            throw new IllegalStateException(\"Resource already open\");\n+        } else {\n+            thread = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        eventStream = executor.run();\n+\n+                        while (true) {\n+                            BaseChangeEvent<T> nextEvent = eventStream.getNextEvent();\n+\n+                            callback.onResult(App.Result.withResult(nextEvent));\n+                        }\n+                    } catch (IOException exception) {\n+                        callback.onResult(App.Result.withError(new AppException(ErrorCode.NETWORK_IO_EXCEPTION, exception)));\n+                    }\n+                }", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469088856", "bodyText": "@cmelchior Do we have a convention about logging and swallowing user exceptions? Seen it somewhere, but maybe it is preferable that users gets the attention?", "author": "rorbech", "createdAt": "2020-08-12T08:22:09Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/async/RealmEventStreamAsyncTaskImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.internal.async;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.Util;\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.mongodb.App;\n+import io.realm.mongodb.AppException;\n+import io.realm.mongodb.ErrorCode;\n+import io.realm.mongodb.RealmEventStreamAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class RealmEventStreamAsyncTaskImpl<T> implements RealmEventStreamAsyncTask<T> {\n+    private final String name;\n+    private final Executor<T> executor;\n+    private volatile EventStream<T> eventStream;\n+    private volatile boolean isCancelled;\n+    private Thread thread;\n+\n+    public RealmEventStreamAsyncTaskImpl(final String name, final Executor<T> executor) {\n+        Util.checkNull(executor, \"name\");\n+        Util.checkNull(executor, \"executor\");\n+\n+        this.executor = executor;\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public synchronized void get(App.Callback<BaseChangeEvent<T>> callback) throws IllegalStateException {\n+        Util.checkNull(callback, \"callback\");\n+\n+        if (thread != null) {\n+            throw new IllegalStateException(\"Resource already open\");\n+        } else {\n+            thread = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        eventStream = executor.run();\n+\n+                        while (true) {\n+                            BaseChangeEvent<T> nextEvent = eventStream.getNextEvent();\n+\n+                            callback.onResult(App.Result.withResult(nextEvent));", "originalCommit": "159bcadff210c5d0cc68440e2d5cee9d563173a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE0NDc4Nw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469144787", "bodyText": "I found this one:\nRealmLog.error(exception);\nWhat is the log policy, shall we log all errors? For example, shall we log the IOExceptions in RealmEventStreamAsyncTaskImpl.java too?", "author": "clementetb", "createdAt": "2020-08-12T09:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1NjAxMQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469156011", "bodyText": "Normally we try to surface crashes to users instead of catching them. There is one noticeable, namely callbacks called from JNI and run in Java.\nIf there is a Java exception inside those, they don't necessarily crash the JNI code, that only happens if it touches JNIEnv, and then the stack trace you get can look really strange. So for those cases, we do attempt to catch all Java exceptions and either convert them to something that JNI understands or log them and attempt to stop the event flow as quickly as possible. But is very tricky and I wouldn't be surprised if we forgot to do that in some places.", "author": "cmelchior", "createdAt": "2020-08-12T10:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE1NjYxNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r469156616", "bodyText": "But for the App Request API, we do have a way to roundtrip errors, so in that case we shouldn't log them, since an AppException is thrown as quickly as possible.", "author": "cmelchior", "createdAt": "2020-08-12T10:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUyMTgyNg==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r471521826", "bodyText": "I wasn't using the exception generated by the watch stream. The error handling has makes more sense now that I have included support for such exceptions.", "author": "clementetb", "createdAt": "2020-08-17T14:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4ODg1Ng=="}], "type": "inlineReview"}, {"oid": "35d396751a2ffcb93bf926d79c6b54b53454ff6b", "url": "https://github.com/realm/realm-java/commit/35d396751a2ffcb93bf926d79c6b54b53454ff6b", "message": "Implements PR CR and fixes merge issues", "committedDate": "2020-08-12T10:03:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY0MDI3OQ==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r470640279", "bodyText": "Multiple sequential calls to watchStream.getState(). If it is not changing in between then use a local variable.", "author": "rorbech", "createdAt": "2020-08-14T13:58:16Z", "path": "realm/realm-library/src/objectServer/java/io/realm/internal/events/NetworkEventStream.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.realm.internal.events;\n+\n+import org.bson.codecs.configuration.CodecRegistry;\n+\n+import java.io.IOException;\n+\n+import io.realm.internal.objectserver.EventStream;\n+import io.realm.internal.objectstore.OsJavaNetworkTransport;\n+import io.realm.internal.objectstore.OsWatchStream;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+public class NetworkEventStream<T> implements EventStream<T> {\n+    private final OsJavaNetworkTransport.Response response;\n+    private final OsWatchStream<T> watchStream;\n+    private final CodecRegistry codecRegistry;\n+    private final Class<T> documentClass;\n+\n+    public NetworkEventStream(OsJavaNetworkTransport.Response response, CodecRegistry codecRegistry, Class<T> documentClass) {\n+        this.response = response;\n+        this.watchStream = new OsWatchStream<>(codecRegistry);\n+        this.codecRegistry = codecRegistry;\n+        this.documentClass = documentClass;\n+    }\n+\n+    /**\n+     * Fetch the next event from a given stream\n+     *\n+     * @return the next event\n+     * @throws IOException any io exception that could occur\n+     */\n+    @Override\n+    public BaseChangeEvent<T> getNextEvent() throws IOException {\n+        String line;\n+\n+        while ((((line = response.readBodyLine())) != null)) {\n+            watchStream.feedLine(line);\n+\n+            if (watchStream.getState().equals(OsWatchStream.HAVE_EVENT))", "originalCommit": "35d396751a2ffcb93bf926d79c6b54b53454ff6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c566df1ff134d99ef08fd2ac6964dc6ee01bea7", "url": "https://github.com/realm/realm-java/commit/1c566df1ff134d99ef08fd2ac6964dc6ee01bea7", "message": "Implement PR changes\nBetter error handling\nAutomatic argument conversion", "committedDate": "2020-08-17T14:28:56Z", "type": "commit"}, {"oid": "94ff30d870892a57b434794f30d42d621bccbe88", "url": "https://github.com/realm/realm-java/commit/94ff30d870892a57b434794f30d42d621bccbe88", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-17T14:30:43Z", "type": "commit"}, {"oid": "703c55ef368348544436843b24aad0c382cb501b", "url": "https://github.com/realm/realm-java/commit/703c55ef368348544436843b24aad0c382cb501b", "message": "Split App class following the object store pattern (#7038)", "committedDate": "2020-08-18T13:19:31Z", "type": "commit"}, {"oid": "148da00538fe087a0ec5fa003fde0ac9fcfc792a", "url": "https://github.com/realm/realm-java/commit/148da00538fe087a0ec5fa003fde0ac9fcfc792a", "message": "Update realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/mongodb/MongoClientTest.kt\n\nCo-authored-by: Eduardo L\u00f3pez <1874445+edualonso@users.noreply.github.com>", "committedDate": "2020-08-20T08:59:51Z", "type": "commit"}, {"oid": "d984970150b282c4d4ac676d6ad8a3cd9acf1b27", "url": "https://github.com/realm/realm-java/commit/d984970150b282c4d4ac676d6ad8a3cd9acf1b27", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-20T19:35:11Z", "type": "commit"}, {"oid": "ad1d8e122d297e6ba8a37acbd807b27cbcac76f1", "url": "https://github.com/realm/realm-java/commit/ad1d8e122d297e6ba8a37acbd807b27cbcac76f1", "message": "Update changelog in the right build version", "committedDate": "2020-08-20T19:39:23Z", "type": "commit"}, {"oid": "3ff3de792890950b38dc52a029aa696026a34144", "url": "https://github.com/realm/realm-java/commit/3ff3de792890950b38dc52a029aa696026a34144", "message": "Add missing space", "committedDate": "2020-08-20T19:46:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjIwNA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474476204", "bodyText": "This is no longer true?", "author": "cmelchior", "createdAt": "2020-08-21T07:37:38Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RealmEventStreamTask.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import java.io.IOException;\n+\n+import io.realm.RealmAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+\n+/**\n+ * The RealmStreamTask is a specific version of {@link RealmAsyncTask} that provides a mechanism\n+ * to work with asynchronous operations carried out against MongoDB Realm that yield stream results.\n+ * <p>\n+ * This class offers both blocking ({@code get}) and non-blocking ({@code getAsync}) method calls.", "originalCommit": "3ff3de792890950b38dc52a029aa696026a34144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjQwMw==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474476403", "bodyText": "This is no longer true", "author": "cmelchior", "createdAt": "2020-08-21T07:37:55Z", "path": "realm/realm-library/src/objectServer/java/io/realm/mongodb/RealmEventStreamAsyncTask.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Realm Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.realm.mongodb;\n+\n+import io.realm.RealmAsyncTask;\n+import io.realm.mongodb.mongo.events.BaseChangeEvent;\n+\n+\n+/**\n+ * The RealmStreamAsyncTask is a specific version of {@link RealmAsyncTask} that provides a mechanism\n+ * to work with asynchronous operations carried out against MongoDB Realm that yield stream results.\n+ * <p>\n+ * This class offers both blocking ({@code get}) and non-blocking ({@code getAsync}) method calls.", "originalCommit": "3ff3de792890950b38dc52a029aa696026a34144", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1ODU5OA==", "url": "https://github.com/realm/realm-java/pull/7014#discussion_r474558598", "bodyText": "Forgot to update those descriptions", "author": "clementetb", "createdAt": "2020-08-21T09:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3NjQwMw=="}], "type": "inlineReview"}, {"oid": "e588e87354b6db11ad619b7451af3cbc4f74e952", "url": "https://github.com/realm/realm-java/commit/e588e87354b6db11ad619b7451af3cbc4f74e952", "message": "Update CHANGELOG.md\n\nCo-authored-by: Christian Melchior <christian@ilios.dk>", "committedDate": "2020-08-21T07:59:59Z", "type": "commit"}, {"oid": "87f162f38888966c576b5549e99db4f2ec083053", "url": "https://github.com/realm/realm-java/commit/87f162f38888966c576b5549e99db4f2ec083053", "message": "Update realm/realm-library/src/androidTestObjectServer/kotlin/io/realm/internal/async/RealmStreamTaskImplTest.kt\n\nCo-authored-by: Christian Melchior <christian@ilios.dk>", "committedDate": "2020-08-21T08:14:11Z", "type": "commit"}, {"oid": "59f515355258b32c7a8a32df6c49840d8895251a", "url": "https://github.com/realm/realm-java/commit/59f515355258b32c7a8a32df6c49840d8895251a", "message": "Transform keyPresent function into a check", "committedDate": "2020-08-21T08:38:44Z", "type": "commit"}, {"oid": "7065f993f684b5285aa2320a180aa9200fe43307", "url": "https://github.com/realm/realm-java/commit/7065f993f684b5285aa2320a180aa9200fe43307", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/events/ChangeEvent.java\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>", "committedDate": "2020-08-21T08:43:17Z", "type": "commit"}, {"oid": "9e1f8d3c055ba88c29f813b922639dbc2f646d94", "url": "https://github.com/realm/realm-java/commit/9e1f8d3c055ba88c29f813b922639dbc2f646d94", "message": "Change eventstream tasks description", "committedDate": "2020-08-21T08:45:40Z", "type": "commit"}, {"oid": "10a511c15ac0d092015aef80a5ba4c1066c70779", "url": "https://github.com/realm/realm-java/commit/10a511c15ac0d092015aef80a5ba4c1066c70779", "message": "Update realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/EventStream.java\n\nCo-authored-by: Claus R\u00f8rbech <claus.rorbech@gmail.com>", "committedDate": "2020-08-21T08:51:40Z", "type": "commit"}, {"oid": "8dc5716634f9cbaa64e45d7b44e293b3c6f4275d", "url": "https://github.com/realm/realm-java/commit/8dc5716634f9cbaa64e45d7b44e293b3c6f4275d", "message": "Merge branch 'ct/watch-event-streams' of ssh://github.com/realm/realm-java into ct/watch-event-streams", "committedDate": "2020-08-21T09:06:36Z", "type": "commit"}, {"oid": "0f76b662e588dc0e6b289858ac224f758f5417b3", "url": "https://github.com/realm/realm-java/commit/0f76b662e588dc0e6b289858ac224f758f5417b3", "message": "Claus PR change requests", "committedDate": "2020-08-21T09:10:07Z", "type": "commit"}, {"oid": "3d02f9240afff6c616cfd5bb4d78450033c8a510", "url": "https://github.com/realm/realm-java/commit/3d02f9240afff6c616cfd5bb4d78450033c8a510", "message": "Added link to realm change events spec", "committedDate": "2020-08-21T09:22:54Z", "type": "commit"}, {"oid": "5da5ccc8a213a13fdd39f366310a724071d43368", "url": "https://github.com/realm/realm-java/commit/5da5ccc8a213a13fdd39f366310a724071d43368", "message": "BlockingLooperThread runDetached returns non null values", "committedDate": "2020-08-21T10:16:33Z", "type": "commit"}, {"oid": "7570829040b4600e4ad44e81ce71e2e9a30efa54", "url": "https://github.com/realm/realm-java/commit/7570829040b4600e4ad44e81ce71e2e9a30efa54", "message": "Use static class and method references", "committedDate": "2020-08-21T10:24:28Z", "type": "commit"}, {"oid": "b2afd68a0b65882a7acca8d4a2b19804dec75f4c", "url": "https://github.com/realm/realm-java/commit/b2afd68a0b65882a7acca8d4a2b19804dec75f4c", "message": "Better comment", "committedDate": "2020-08-21T10:27:04Z", "type": "commit"}, {"oid": "319483675412a252c3c931c7ff0604296a0ab7f3", "url": "https://github.com/realm/realm-java/commit/319483675412a252c3c931c7ff0604296a0ab7f3", "message": "Return response message on http stream error", "committedDate": "2020-08-21T10:42:16Z", "type": "commit"}, {"oid": "f3a956e0a663def9edfff370610831bb4137d26e", "url": "https://github.com/realm/realm-java/commit/f3a956e0a663def9edfff370610831bb4137d26e", "message": "Rename OkHttpNetworkTransport response", "committedDate": "2020-08-21T10:43:21Z", "type": "commit"}, {"oid": "b6430333b18f478eefd60b7a6e0a3a9edc81de60", "url": "https://github.com/realm/realm-java/commit/b6430333b18f478eefd60b7a6e0a3a9edc81de60", "message": "Merge branch 'v10' into ct/watch-event-streams", "committedDate": "2020-08-25T08:54:37Z", "type": "commit"}]}