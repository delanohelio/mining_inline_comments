{"pr_number": 7878, "pr_title": "Add mark casualties battle step", "pr_createdAt": "2020-10-11T22:34:18Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7878", "timeline": [{"oid": "f2a101e84a9f07f826b9f073a7c37731bae440df", "url": "https://github.com/triplea-game/triplea/commit/f2a101e84a9f07f826b9f073a7c37731bae440df", "message": "Add mark casualties battle step", "committedDate": "2020-10-11T22:32:42Z", "type": "commit"}, {"oid": "c2d7fa471e4de88490eef88ec92068db08f53a90", "url": "https://github.com/triplea-game/triplea/commit/c2d7fa471e4de88490eef88ec92068db08f53a90", "message": "Add select casualties battle step", "committedDate": "2020-10-11T22:36:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MTMwNw==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r502981307", "bodyText": "side-note, this dependency on WeakAi is something we really would like to get rid of:\n\nallows for all of weak ai to be deleted\nkinda poor design, the core game engine should not depend on AI code", "author": "DanVanAtta", "createdAt": "2020-10-11T23:33:16Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleActions.java", "diffHunk": "@@ -59,4 +64,12 @@ Territory querySubmergeTerritory(\n       GamePlayer retreatingPlayer,\n       Collection<Territory> availableTerritories,\n       String text);\n+\n+  default Player getRemotePlayer(final GamePlayer player, final IDelegateBridge bridge) {\n+    // if its the null player, return a do nothing proxy\n+    if (player.isNull()) {\n+      return new WeakAi(player.getName());", "originalCommit": "f2a101e84a9f07f826b9f073a7c37731bae440df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNDk4MA==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503024980", "bodyText": "I grabbed this code from AbstractBattle#getRemotePlayer.  I'm not exactly sure why it is needed.", "author": "trevan", "createdAt": "2020-10-12T03:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MTMwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5ODI0Ng==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503598246", "bodyText": "I do recognize this code, this is one of the few and biggest dependencies on AI code from core-code IIRC. In essence we do this hack to supply a functioning player object and if my vague memory on this really holds for a default OOL algorithm. Using weakAi is a very ugly hack (which we've had for a long time; we can outright delete all of weak AI once we remove this dependency, which would be a significant simplification and removal of dead code).", "author": "DanVanAtta", "createdAt": "2020-10-13T00:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MTQ5NQ==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r502981495", "bodyText": "nit, I'm not sure the annotation comment string here makes a lot of sense. Would we be just as well off if it were removed? Otherwise, can it be made more direct, is it indicating that we have to do something else beyond upgrading to a non-compatible release to remove this method?", "author": "DanVanAtta", "createdAt": "2020-10-11T23:34:54Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -107,4 +109,8 @@ public boolean isFirstRound() {\n   Collection<Unit> getTransportDependents(Collection<Unit> units);\n \n   Collection<IBattle> getDependentBattles();\n+\n+  @RemoveOnNextMajorRelease(\"Only used to handle step string changes\")", "originalCommit": "f2a101e84a9f07f826b9f073a7c37731bae440df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNTk4MQ==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503025981", "bodyText": "I've removed the annotation comment string.", "author": "trevan", "createdAt": "2020-10-12T03:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MTQ5NQ=="}], "type": "inlineReview"}, {"oid": "ee6d2adad5c4b7cd3e12708c79f790bf05f37f53", "url": "https://github.com/triplea-game/triplea/commit/ee6d2adad5c4b7cd3e12708c79f790bf05f37f53", "message": "Remove unneeded annotation string for removal", "committedDate": "2020-10-12T03:55:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNjE2Nw==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503026167", "bodyText": "This is where the isSuicideOnHit check is being used.  You had wondered about that in the FiringGroup PR.", "author": "trevan", "createdAt": "2020-10-12T03:56:53Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/MarkCasualties.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_WITHOUT_SPACE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_FIRST_STRIKE_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_NAVAL_BOMBARDMENT_CASUALTIES;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import lombok.RequiredArgsConstructor;\n+import org.triplea.java.ChangeOnNextMajorRelease;\n+import org.triplea.java.Interruptibles;\n+import org.triplea.java.RemoveOnNextMajorRelease;\n+\n+/** Step where the casualties are moved from ALIVE to CASUALTY */\n+@RequiredArgsConstructor\n+public class MarkCasualties implements BattleStep {\n+\n+  private static final long serialVersionUID = -3823676731273987167L;\n+\n+  private final BattleState battleState;\n+\n+  private final BattleActions battleActions;\n+\n+  /** The side of the firing player */\n+  private final BattleState.Side side;\n+\n+  private final FiringGroup firingGroup;\n+\n+  private final FireRoundState fireRoundState;\n+\n+  @ChangeOnNextMajorRelease(\n+      \"returnFire is ALL for everything except NavalBombardment and old saves.\"\n+          + \"Rework so that returnFire isn't needed at all.\")\n+  private final MustFightBattle.ReturnFire returnFire;\n+\n+  @Override\n+  public List<String> getNames() {\n+    return List.of(getName());\n+  }\n+\n+  private String getName() {\n+    return battleState.getPlayer(side.getOpposite()).getName()\n+        + REMOVE_PREFIX\n+        // displaying UNITS makes the text feel redundant so hide it if that is the group name\n+        + (firingGroup.getDisplayName().equals(UNITS)\n+            ? CASUALTIES_WITHOUT_SPACE_SUFFIX\n+            : firingGroup.getDisplayName() + CASUALTIES_SUFFIX);\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.REMOVE_FIRE_ROUND_CASUALTIES;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    if (!battleState.getStatus().isHeadless()) {\n+      notifyCasualties(bridge);\n+    }\n+\n+    battleActions.removeCasualties(\n+        fireRoundState.getCasualties().getKilled(),\n+        returnFire,\n+        side.getOpposite() == DEFENSE,\n+        bridge);\n+\n+    if (firingGroup.isSuicideOnHit()) {", "originalCommit": "ee6d2adad5c4b7cd3e12708c79f790bf05f37f53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "82e6d747d4bdce82ff706f10d8b04a1b9ae8098b", "url": "https://github.com/triplea-game/triplea/commit/82e6d747d4bdce82ff706f10d8b04a1b9ae8098b", "message": "Add missing enum", "committedDate": "2020-10-12T03:58:17Z", "type": "commit"}, {"oid": "17528ed2156eeb47c5df554d16b29afcb01c029a", "url": "https://github.com/triplea-game/triplea/commit/17528ed2156eeb47c5df554d16b29afcb01c029a", "message": "Add missing imports", "committedDate": "2020-10-12T04:10:29Z", "type": "commit"}, {"oid": "5b5bc547c1161f29bcd4d61ac6bbacb1a927e3e0", "url": "https://github.com/triplea-game/triplea/commit/5b5bc547c1161f29bcd4d61ac6bbacb1a927e3e0", "message": "Rename SelectNormalCasualties to SelectMainBattleCasualties", "committedDate": "2020-10-12T23:19:57Z", "type": "commit"}, {"oid": "e923c460db988293f1c1085fd066566b0cf8600d", "url": "https://github.com/triplea-game/triplea/commit/e923c460db988293f1c1085fd066566b0cf8600d", "message": "Add tests for SelectMainBattleCasualties", "committedDate": "2020-10-13T01:37:10Z", "type": "commit"}, {"oid": "53eea6b5c2068e05bcad69fc850c038faf1b9351", "url": "https://github.com/triplea-game/triplea/commit/53eea6b5c2068e05bcad69fc850c038faf1b9351", "message": "Merge remote-tracking branch 'upstream/master' into mark-casualties-step", "committedDate": "2020-10-13T01:39:33Z", "type": "commit"}, {"oid": "827e6a23dc355aace3e8c0e7b628016cae949ac4", "url": "https://github.com/triplea-game/triplea/commit/827e6a23dc355aace3e8c0e7b628016cae949ac4", "message": "Run spotless", "committedDate": "2020-10-13T01:39:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyODk2Mw==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503628963", "bodyText": "nit, test method feels to be missing the implication of what happens when edit mode. A @DisplayName perhaps should become routine for any test method over 5 lines and particularly if there is more than one assert (think of it as a way to replace a javadoc on each test method, and each one should have a summary either in a direct title or display name to describe what we are testing).", "author": "DanVanAtta", "createdAt": "2020-10-13T02:20:00Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {", "originalCommit": "e923c460db988293f1c1085fd066566b0cf8600d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NTQ5MA==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503645490", "bodyText": "I've added a display name to all of the tests", "author": "trevan", "createdAt": "2020-10-13T03:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyODk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTEzNg==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629136", "bodyText": "nit, the comment on the assertion is essentially what the string arg for assertions is for : )\nEG:\n  assertThat(\"edit mode sets auto calcuated to true\" , details.getAutoCalculated(), is(true));", "author": "DanVanAtta", "createdAt": "2020-10-13T02:20:42Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));", "originalCommit": "e923c460db988293f1c1085fd066566b0cf8600d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTU2OQ==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629569", "bodyText": "side-note, it does look like we are doing a pretty heavy lift in this test by verifying further implementation calls. If we can have the code under test instead return a result object, then have the caller invoke the select function, it would be more testable, functional, and likely easier to understand when reading the prod code (fewer side effects)", "author": "DanVanAtta", "createdAt": "2020-10-13T02:22:34Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));\n+\n+    verify(selectFunction)\n+        .apply(\n+            eq(delegateBridge),\n+            eq(selectCasualties),\n+            (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+            eq(0));\n+  }\n+\n+  @Nested\n+  class TransportCasualtiesNotRestricted {\n+\n+    @Test\n+    void moreHitPointsThanHits() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+      final FireRoundState fireRoundState = new FireRoundState();\n+      fireRoundState.setDice(givenDiceRollWithHits(3));\n+\n+      final SelectCasualties selectCasualties =\n+          new SelectCasualties(\n+              battleState,\n+              BattleState.Side.OFFENSE,\n+              firingGroup,\n+              fireRoundState,\n+              (arg1, arg2) -> new CasualtyDetails());\n+\n+      final SelectMainBattleCasualties.Select selectFunction =\n+          mock(SelectMainBattleCasualties.Select.class);\n+      final CasualtyDetails expected = new CasualtyDetails();\n+      when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+      final CasualtyDetails details =\n+          new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+      assertThat(details, is(expected));\n+\n+      verify(selectFunction)\n+          .apply(\n+              eq(delegateBridge),\n+              eq(selectCasualties),\n+              (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+              eq(3));", "originalCommit": "e923c460db988293f1c1085fd066566b0cf8600d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTY4OA==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629688", "bodyText": "It looks like there are more hit points here than hits, is the name of the test correct? \"moreHitsThanHitPoints\"", "author": "DanVanAtta", "createdAt": "2020-10-13T02:23:08Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));\n+\n+    verify(selectFunction)\n+        .apply(\n+            eq(delegateBridge),\n+            eq(selectCasualties),\n+            (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+            eq(0));\n+  }\n+\n+  @Nested\n+  class TransportCasualtiesNotRestricted {\n+\n+    @Test\n+    void moreHitPointsThanHits() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+      final FireRoundState fireRoundState = new FireRoundState();\n+      fireRoundState.setDice(givenDiceRollWithHits(3));\n+\n+      final SelectCasualties selectCasualties =\n+          new SelectCasualties(\n+              battleState,\n+              BattleState.Side.OFFENSE,\n+              firingGroup,\n+              fireRoundState,\n+              (arg1, arg2) -> new CasualtyDetails());\n+\n+      final SelectMainBattleCasualties.Select selectFunction =\n+          mock(SelectMainBattleCasualties.Select.class);\n+      final CasualtyDetails expected = new CasualtyDetails();\n+      when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+      final CasualtyDetails details =\n+          new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+      assertThat(details, is(expected));\n+\n+      verify(selectFunction)\n+          .apply(\n+              eq(delegateBridge),\n+              eq(selectCasualties),\n+              (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+              eq(3));\n+    }\n+\n+    @Test\n+    void moreHitsThanHitPoints() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);", "originalCommit": "e923c460db988293f1c1085fd066566b0cf8600d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NTQyMw==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503645423", "bodyText": "The unit has a total of 2 hit points but has already taken one hit.  So the unit has 1 hit point left.  The amount of hits in the test is 3 and there are two units.  So there are more hits than hit points.\nI think this is another terminology problem.  Is \"hit points\" the amount the unit has ignoring any hits they've taken or is it the amount of the user has including the hits they've taken?", "author": "trevan", "createdAt": "2020-10-13T03:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NzI5Mg==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503647292", "bodyText": "Pretty sure - hit points is total hit points regardless of damage. Hit points left or HP remaining is hit points minus damage.", "author": "DanVanAtta", "createdAt": "2020-10-13T03:34:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTgyMw==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503629823", "bodyText": "Any thoughts to create a constructor that removes the no-op arguments? EG:\nnew FiringGroup(targetUnits);", "author": "DanVanAtta", "createdAt": "2020-10-13T02:23:42Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/SelectMainBattleCasualtiesTest.java", "diffHunk": "@@ -0,0 +1,526 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.Constants.EDIT_MODE;\n+import static games.strategy.triplea.Constants.TRANSPORT_CASUALTIES_RESTRICTED;\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitSeaTransport;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyCollection;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class SelectMainBattleCasualtiesTest {\n+\n+  @Mock IDelegateBridge delegateBridge;\n+  @Mock GamePlayer gamePlayer;\n+  BattleState battleState;\n+\n+  @BeforeEach\n+  public void givenBattleState() {\n+    battleState = givenBattleStateBuilder().build();\n+  }\n+\n+  private DiceRoll givenDiceRollWithHits(final int hits) {\n+    final DiceRoll diceRoll = mock(DiceRoll.class);\n+    when(diceRoll.getHits()).thenReturn(hits);\n+    return diceRoll;\n+  }\n+\n+  @Test\n+  void isEditMode() {\n+    final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+    when(battleState.getGameData().getProperties().get(TRANSPORT_CASUALTIES_RESTRICTED, false))\n+        .thenReturn(false);\n+    when(battleState.getGameData().getProperties().get(EDIT_MODE)).thenReturn(true);\n+\n+    final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+    final FireRoundState fireRoundState = new FireRoundState();\n+    fireRoundState.setDice(mock(DiceRoll.class));\n+\n+    final SelectCasualties selectCasualties =\n+        new SelectCasualties(\n+            battleState,\n+            BattleState.Side.OFFENSE,\n+            firingGroup,\n+            fireRoundState,\n+            (arg1, arg2) -> new CasualtyDetails());\n+\n+    final SelectMainBattleCasualties.Select selectFunction =\n+        mock(SelectMainBattleCasualties.Select.class);\n+    final CasualtyDetails expected = new CasualtyDetails(targetUnits, List.of(), false);\n+    when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+    final CasualtyDetails details =\n+        new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+    assertThat(details.getKilled().toArray(), is(targetUnits.toArray()));\n+    // edit mode always sets auto calculated to true\n+    assertThat(details.getAutoCalculated(), is(true));\n+\n+    verify(selectFunction)\n+        .apply(\n+            eq(delegateBridge),\n+            eq(selectCasualties),\n+            (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+            eq(0));\n+  }\n+\n+  @Nested\n+  class TransportCasualtiesNotRestricted {\n+\n+    @Test\n+    void moreHitPointsThanHits() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);\n+\n+      final FireRoundState fireRoundState = new FireRoundState();\n+      fireRoundState.setDice(givenDiceRollWithHits(3));\n+\n+      final SelectCasualties selectCasualties =\n+          new SelectCasualties(\n+              battleState,\n+              BattleState.Side.OFFENSE,\n+              firingGroup,\n+              fireRoundState,\n+              (arg1, arg2) -> new CasualtyDetails());\n+\n+      final SelectMainBattleCasualties.Select selectFunction =\n+          mock(SelectMainBattleCasualties.Select.class);\n+      final CasualtyDetails expected = new CasualtyDetails();\n+      when(selectFunction.apply(any(), any(), anyCollection(), anyInt())).thenReturn(expected);\n+\n+      final CasualtyDetails details =\n+          new SelectMainBattleCasualties(selectFunction).apply(delegateBridge, selectCasualties);\n+\n+      assertThat(details, is(expected));\n+\n+      verify(selectFunction)\n+          .apply(\n+              eq(delegateBridge),\n+              eq(selectCasualties),\n+              (Collection<Unit>) argThat(containsInAnyOrder(targetUnits.toArray())),\n+              eq(3));\n+    }\n+\n+    @Test\n+    void moreHitsThanHitPoints() {\n+      final List<Unit> targetUnits = List.of(givenAnyUnit(), givenAnyUnit());\n+\n+      targetUnits.forEach(\n+          unit -> {\n+            final UnitAttachment unitAttachment =\n+                (UnitAttachment) unit.getType().getAttachment(UNIT_ATTACHMENT_NAME);\n+            when(unitAttachment.getHitPoints()).thenReturn(2);\n+            when(unit.getHits()).thenReturn(1);\n+          });\n+\n+      final FiringGroup firingGroup = new FiringGroup(\"\", \"\", List.of(), targetUnits);", "originalCommit": "e923c460db988293f1c1085fd066566b0cf8600d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NTcxMw==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503645713", "bodyText": "Since this constructor is only for tests, I'd rather not.", "author": "trevan", "createdAt": "2020-10-13T03:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY0NzgwMw==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r503647803", "bodyText": "Fair enough, it's a bit disturbing though that invalid values can be injected. It would seem to put the FiringGroup into an invalid state. It makes one wonder if there is a subset of behavior that could instead be a strategy object and we could test the strategy object directly. Just my 2 cents on seeing this code in test here, I'm not sure if it's practical to fix it or not.", "author": "DanVanAtta", "createdAt": "2020-10-13T03:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA0OTk1OQ==", "url": "https://github.com/triplea-game/triplea/pull/7878#discussion_r504049959", "bodyText": "I've updated the tests to \"correctly\" create a FiringGroup.  The FiringGroup constructor is now private and the only way to create them is through FiringGroup.groupBySuicideOnHit.", "author": "trevan", "createdAt": "2020-10-13T15:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYyOTgyMw=="}], "type": "inlineReview"}, {"oid": "7ff5befd1bdaa567bdee1ba2d41ba39b9217a007", "url": "https://github.com/triplea-game/triplea/commit/7ff5befd1bdaa567bdee1ba2d41ba39b9217a007", "message": "Add test descriptions", "committedDate": "2020-10-13T03:26:23Z", "type": "commit"}, {"oid": "d5b3b44c9bd37e0aaf8c60e427f9f6f3165f7fb4", "url": "https://github.com/triplea-game/triplea/commit/d5b3b44c9bd37e0aaf8c60e427f9f6f3165f7fb4", "message": "Add 'Remaining' to the test name to indicate that it is hit points remaining", "committedDate": "2020-10-13T03:37:04Z", "type": "commit"}, {"oid": "518aa5848759b45dea8357adfc0c217ee730f9a6", "url": "https://github.com/triplea-game/triplea/commit/518aa5848759b45dea8357adfc0c217ee730f9a6", "message": "Make FiringGroup's constructor private", "committedDate": "2020-10-13T15:29:53Z", "type": "commit"}, {"oid": "040408fd03c10c806084a7517b5bce7c930f2919", "url": "https://github.com/triplea-game/triplea/commit/040408fd03c10c806084a7517b5bce7c930f2919", "message": "Fix checkstyle", "committedDate": "2020-10-14T02:57:09Z", "type": "commit"}]}