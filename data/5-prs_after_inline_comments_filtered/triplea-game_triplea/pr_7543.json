{"pr_number": 7543, "pr_title": "Add xml-reader subproject, a StAX based xml-reading library", "pr_createdAt": "2020-09-05T06:36:36Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7543", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxODY2Nw==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483918667", "bodyText": "Consider simplifying this complex logical expression.", "author": "codeclimate", "createdAt": "2020-09-05T06:39:11Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/AnnotatedFields.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package org.triplea.generic.xml.reader;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Getter;\n+import org.triplea.generic.xml.reader.annotations.Attribute;\n+import org.triplea.generic.xml.reader.annotations.BodyText;\n+import org.triplea.generic.xml.reader.annotations.Tag;\n+import org.triplea.generic.xml.reader.annotations.TagList;\n+import org.triplea.generic.xml.reader.exceptions.JavaDataModelException;\n+\n+/**\n+ * Sorts fields, validates fields, and sets fields to accessible. Field validation will check that\n+ * we see the right annotations on the right class types, for example that '@TagList' is on only\n+ * 'java.util.List'.\n+ *\n+ * @param <T> Java model object class type (essentially the tag we are currently creating as a java\n+ *     object).\n+ */\n+@Getter\n+class AnnotatedFields<T> {\n+  private final List<Field> attributeFields = new ArrayList<>();\n+  private final List<Field> tagFields = new ArrayList<>();\n+  private final List<Field> tagListFields = new ArrayList<>();\n+  private final List<Field> bodyTextFields = new ArrayList<>();\n+\n+  AnnotatedFields(final Class<T> pojo) throws JavaDataModelException {\n+    for (final Field field : pojo.getDeclaredFields()) {\n+      validateAnnotations(field);\n+      if (field.getAnnotation(Attribute.class) != null) {\n+        field.setAccessible(true);\n+        attributeFields.add(field);\n+      } else if (field.getAnnotation(Tag.class) != null) {\n+        field.setAccessible(true);\n+        tagFields.add(field);\n+      } else if (field.getAnnotation(TagList.class) != null) {\n+        field.setAccessible(true);\n+        tagListFields.add(field);\n+      } else if (field.getAnnotation(BodyText.class) != null) {\n+        field.setAccessible(true);\n+        bodyTextFields.add(field);\n+      }\n+    }\n+    if (bodyTextFields.size() > 1) {\n+      throw new JavaDataModelException(\n+          \"Too many body text fields, can only have one on any given class\");\n+    }\n+    if (!bodyTextFields.isEmpty() && (!tagFields.isEmpty() && !tagListFields.isEmpty())) {\n+      throw new JavaDataModelException(\n+          \"Illegal combination of annoations, may only have attributes and a body text,\"\n+              + \"or attributes and tags (or taglist), but may not have both body text and tags.\");\n+    }\n+  }\n+\n+  private static <T> void validateAnnotations(final Field field) throws JavaDataModelException {\n+\n+    int annotationCount = 0;\n+\n+    if (field.getAnnotation(Attribute.class) != null) {\n+      if (field.getType() != String.class", "originalCommit": "22fbaabf1a195ae4a87987af3f1f35b5e9efdd79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxODY2OA==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483918668", "bodyText": "Method validateAnnotations has 64 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-05T06:39:11Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/AnnotatedFields.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package org.triplea.generic.xml.reader;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Getter;\n+import org.triplea.generic.xml.reader.annotations.Attribute;\n+import org.triplea.generic.xml.reader.annotations.BodyText;\n+import org.triplea.generic.xml.reader.annotations.Tag;\n+import org.triplea.generic.xml.reader.annotations.TagList;\n+import org.triplea.generic.xml.reader.exceptions.JavaDataModelException;\n+\n+/**\n+ * Sorts fields, validates fields, and sets fields to accessible. Field validation will check that\n+ * we see the right annotations on the right class types, for example that '@TagList' is on only\n+ * 'java.util.List'.\n+ *\n+ * @param <T> Java model object class type (essentially the tag we are currently creating as a java\n+ *     object).\n+ */\n+@Getter\n+class AnnotatedFields<T> {\n+  private final List<Field> attributeFields = new ArrayList<>();\n+  private final List<Field> tagFields = new ArrayList<>();\n+  private final List<Field> tagListFields = new ArrayList<>();\n+  private final List<Field> bodyTextFields = new ArrayList<>();\n+\n+  AnnotatedFields(final Class<T> pojo) throws JavaDataModelException {\n+    for (final Field field : pojo.getDeclaredFields()) {\n+      validateAnnotations(field);\n+      if (field.getAnnotation(Attribute.class) != null) {\n+        field.setAccessible(true);\n+        attributeFields.add(field);\n+      } else if (field.getAnnotation(Tag.class) != null) {\n+        field.setAccessible(true);\n+        tagFields.add(field);\n+      } else if (field.getAnnotation(TagList.class) != null) {\n+        field.setAccessible(true);\n+        tagListFields.add(field);\n+      } else if (field.getAnnotation(BodyText.class) != null) {\n+        field.setAccessible(true);\n+        bodyTextFields.add(field);\n+      }\n+    }\n+    if (bodyTextFields.size() > 1) {\n+      throw new JavaDataModelException(\n+          \"Too many body text fields, can only have one on any given class\");\n+    }\n+    if (!bodyTextFields.isEmpty() && (!tagFields.isEmpty() && !tagListFields.isEmpty())) {\n+      throw new JavaDataModelException(\n+          \"Illegal combination of annoations, may only have attributes and a body text,\"\n+              + \"or attributes and tags (or taglist), but may not have both body text and tags.\");\n+    }\n+  }\n+\n+  private static <T> void validateAnnotations(final Field field) throws JavaDataModelException {", "originalCommit": "22fbaabf1a195ae4a87987af3f1f35b5e9efdd79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxODY2OQ==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483918669", "bodyText": "Method parse has a Cognitive Complexity of 16 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-05T06:39:11Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/XmlParser.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package org.triplea.generic.xml.reader;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import javax.xml.stream.XMLStreamReader;\n+import org.triplea.java.function.ThrowingRunnable;\n+\n+class XmlParser {\n+  private final String tagName;\n+  private final Map<String, ThrowingRunnable<?>> childTagHandlers = new HashMap<>();\n+  private Consumer<String> bodyHandler;\n+\n+  XmlParser(final String tagName) {\n+    this.tagName = tagName.toUpperCase();\n+  }\n+\n+  void childTagHandler(final String childTagName, final ThrowingRunnable<?> tagHandler) {\n+    childTagHandlers.put(childTagName.toUpperCase(), tagHandler);\n+  }\n+\n+  void bodyHandler(final Consumer<String> bodyHandler) {\n+    this.bodyHandler = bodyHandler;\n+  }\n+\n+  void parse(final XMLStreamReader streamReader) throws Throwable {", "originalCommit": "22fbaabf1a195ae4a87987af3f1f35b5e9efdd79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxODY3MA==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483918670", "bodyText": "Method validateAnnotations has a Cognitive Complexity of 25 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-05T06:39:11Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/AnnotatedFields.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package org.triplea.generic.xml.reader;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Getter;\n+import org.triplea.generic.xml.reader.annotations.Attribute;\n+import org.triplea.generic.xml.reader.annotations.BodyText;\n+import org.triplea.generic.xml.reader.annotations.Tag;\n+import org.triplea.generic.xml.reader.annotations.TagList;\n+import org.triplea.generic.xml.reader.exceptions.JavaDataModelException;\n+\n+/**\n+ * Sorts fields, validates fields, and sets fields to accessible. Field validation will check that\n+ * we see the right annotations on the right class types, for example that '@TagList' is on only\n+ * 'java.util.List'.\n+ *\n+ * @param <T> Java model object class type (essentially the tag we are currently creating as a java\n+ *     object).\n+ */\n+@Getter\n+class AnnotatedFields<T> {\n+  private final List<Field> attributeFields = new ArrayList<>();\n+  private final List<Field> tagFields = new ArrayList<>();\n+  private final List<Field> tagListFields = new ArrayList<>();\n+  private final List<Field> bodyTextFields = new ArrayList<>();\n+\n+  AnnotatedFields(final Class<T> pojo) throws JavaDataModelException {\n+    for (final Field field : pojo.getDeclaredFields()) {\n+      validateAnnotations(field);\n+      if (field.getAnnotation(Attribute.class) != null) {\n+        field.setAccessible(true);\n+        attributeFields.add(field);\n+      } else if (field.getAnnotation(Tag.class) != null) {\n+        field.setAccessible(true);\n+        tagFields.add(field);\n+      } else if (field.getAnnotation(TagList.class) != null) {\n+        field.setAccessible(true);\n+        tagListFields.add(field);\n+      } else if (field.getAnnotation(BodyText.class) != null) {\n+        field.setAccessible(true);\n+        bodyTextFields.add(field);\n+      }\n+    }\n+    if (bodyTextFields.size() > 1) {\n+      throw new JavaDataModelException(\n+          \"Too many body text fields, can only have one on any given class\");\n+    }\n+    if (!bodyTextFields.isEmpty() && (!tagFields.isEmpty() && !tagListFields.isEmpty())) {\n+      throw new JavaDataModelException(\n+          \"Illegal combination of annoations, may only have attributes and a body text,\"\n+              + \"or attributes and tags (or taglist), but may not have both body text and tags.\");\n+    }\n+  }\n+\n+  private static <T> void validateAnnotations(final Field field) throws JavaDataModelException {", "originalCommit": "22fbaabf1a195ae4a87987af3f1f35b5e9efdd79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxODY3MQ==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483918671", "bodyText": "Method parse has 31 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-05T06:39:11Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/XmlParser.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package org.triplea.generic.xml.reader;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import javax.xml.stream.XMLStreamReader;\n+import org.triplea.java.function.ThrowingRunnable;\n+\n+class XmlParser {\n+  private final String tagName;\n+  private final Map<String, ThrowingRunnable<?>> childTagHandlers = new HashMap<>();\n+  private Consumer<String> bodyHandler;\n+\n+  XmlParser(final String tagName) {\n+    this.tagName = tagName.toUpperCase();\n+  }\n+\n+  void childTagHandler(final String childTagName, final ThrowingRunnable<?> tagHandler) {\n+    childTagHandlers.put(childTagName.toUpperCase(), tagHandler);\n+  }\n+\n+  void bodyHandler(final Consumer<String> bodyHandler) {\n+    this.bodyHandler = bodyHandler;\n+  }\n+\n+  void parse(final XMLStreamReader streamReader) throws Throwable {", "originalCommit": "22fbaabf1a195ae4a87987af3f1f35b5e9efdd79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxODY3Mg==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483918672", "bodyText": "Method mapXmlToObject has a Cognitive Complexity of 10 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-05T06:39:11Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/XmlMapper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.triplea.generic.xml.reader;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.Closeable;\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import lombok.extern.java.Log;\n+import org.triplea.generic.xml.reader.exceptions.JavaDataModelException;\n+import org.triplea.generic.xml.reader.exceptions.XmlParsingException;\n+\n+@Log\n+public class XmlMapper implements Closeable {\n+  private XMLStreamReader xmlStreamReader;\n+\n+  public XmlMapper(final InputStream inputStream) throws XMLStreamException {\n+    final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+    xmlStreamReader = inputFactory.createXMLStreamReader(inputStream);\n+  }\n+\n+  public <T> T mapXmlToObject(final Class<T> pojo) throws XmlParsingException {", "originalCommit": "22fbaabf1a195ae4a87987af3f1f35b5e9efdd79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkxODY3Mw==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483918673", "bodyText": "Method mapXmlToObject has 46 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-09-05T06:39:12Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/XmlMapper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.triplea.generic.xml.reader;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.Closeable;\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import lombok.extern.java.Log;\n+import org.triplea.generic.xml.reader.exceptions.JavaDataModelException;\n+import org.triplea.generic.xml.reader.exceptions.XmlParsingException;\n+\n+@Log\n+public class XmlMapper implements Closeable {\n+  private XMLStreamReader xmlStreamReader;\n+\n+  public XmlMapper(final InputStream inputStream) throws XMLStreamException {\n+    final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+    xmlStreamReader = inputFactory.createXMLStreamReader(inputStream);\n+  }\n+\n+  public <T> T mapXmlToObject(final Class<T> pojo) throws XmlParsingException {", "originalCommit": "22fbaabf1a195ae4a87987af3f1f35b5e9efdd79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ad43ba85810903b7cb84af3d07cc9270528d22f", "url": "https://github.com/triplea-game/triplea/commit/9ad43ba85810903b7cb84af3d07cc9270528d22f", "message": "Add xml-reader subproject, a StAX based xml-reading library\n\nStAX is a DOM-less XML parser. StAX is essentially a cursor that\ntraverses an XML document and notifies the code of parsing events\nas they happen.\n\nThis update adds a subproject, 'xml-reader' that wraps this library\nand provides an annotation framework (very similar to JaxB) where\nJava objects that model the XML can be annotated and automatically\ncreated by 'XmlMapper'.\n\nThe sub-project README has details and documentation on how to set\nthis up.\n\nAs a feature the mapper can automatically map 'int', 'double'\nand 'boolean' objects.\n\nOf note, the StaX parser does not validate XML against a DTD.\nIf we want that validation we'll have to do so as an auxilary step\n(perhaps something we can wire up for map-makers to validate\ntheir XMLs).\n\nOverall the sub-project is designed to give us a lot of control\nover XML parsing. For example a logical next step will be to\nadd 'Aliases' to the annotations to support different naming of\nequivalent tags and attributes.\n\nThe xml-reader is also designed to be efficient (fast) by using\nStAX and emphasis has been put on yielding good error messages\nwhen things go wrong.\n\nAs a larger fit, the XML-reader will be used to create data\nmodel objects of the Game XMLs. These data model objects\nwill represent the data in XML almost exactly and then\nwill be used in another stage for 'game data assembly' where\nthey are put together to create a game data object.\nThis is different from 'GameParser' of today that parses\nXML and directly creates a GameData object. This extra\nlayer should allow a lot of flexibility for different\nXML formats, notably to support both future and legacy types.", "committedDate": "2020-09-05T07:22:36Z", "type": "commit"}, {"oid": "9ad43ba85810903b7cb84af3d07cc9270528d22f", "url": "https://github.com/triplea-game/triplea/commit/9ad43ba85810903b7cb84af3d07cc9270528d22f", "message": "Add xml-reader subproject, a StAX based xml-reading library\n\nStAX is a DOM-less XML parser. StAX is essentially a cursor that\ntraverses an XML document and notifies the code of parsing events\nas they happen.\n\nThis update adds a subproject, 'xml-reader' that wraps this library\nand provides an annotation framework (very similar to JaxB) where\nJava objects that model the XML can be annotated and automatically\ncreated by 'XmlMapper'.\n\nThe sub-project README has details and documentation on how to set\nthis up.\n\nAs a feature the mapper can automatically map 'int', 'double'\nand 'boolean' objects.\n\nOf note, the StaX parser does not validate XML against a DTD.\nIf we want that validation we'll have to do so as an auxilary step\n(perhaps something we can wire up for map-makers to validate\ntheir XMLs).\n\nOverall the sub-project is designed to give us a lot of control\nover XML parsing. For example a logical next step will be to\nadd 'Aliases' to the annotations to support different naming of\nequivalent tags and attributes.\n\nThe xml-reader is also designed to be efficient (fast) by using\nStAX and emphasis has been put on yielding good error messages\nwhen things go wrong.\n\nAs a larger fit, the XML-reader will be used to create data\nmodel objects of the Game XMLs. These data model objects\nwill represent the data in XML almost exactly and then\nwill be used in another stage for 'game data assembly' where\nthey are put together to create a game data object.\nThis is different from 'GameParser' of today that parses\nXML and directly creates a GameData object. This extra\nlayer should allow a lot of flexibility for different\nXML formats, notably to support both future and legacy types.", "committedDate": "2020-09-05T07:22:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkyMjQ1Nw==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483922457", "bodyText": "Codacy found an issue: The method 'validateAnnotations(Field)' has an NPath complexity of 10206, current threshold is 200", "author": "DanVanAtta", "createdAt": "2020-09-05T07:27:14Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/AnnotatedFields.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package org.triplea.generic.xml.reader;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Getter;\n+import org.triplea.generic.xml.reader.annotations.Attribute;\n+import org.triplea.generic.xml.reader.annotations.BodyText;\n+import org.triplea.generic.xml.reader.annotations.Tag;\n+import org.triplea.generic.xml.reader.annotations.TagList;\n+import org.triplea.generic.xml.reader.exceptions.JavaDataModelException;\n+\n+/**\n+ * Sorts fields, validates fields, and sets fields to accessible. Field validation will check that\n+ * we see the right annotations on the right class types, for example that '@TagList' is on only\n+ * 'java.util.List'.\n+ *\n+ * @param <T> Java model object class type (essentially the tag we are currently creating as a java\n+ *     object).\n+ */\n+@Getter\n+class AnnotatedFields<T> {\n+  private final List<Field> attributeFields = new ArrayList<>();\n+  private final List<Field> tagFields = new ArrayList<>();\n+  private final List<Field> tagListFields = new ArrayList<>();\n+  private final List<Field> bodyTextFields = new ArrayList<>();\n+\n+  AnnotatedFields(final Class<T> pojo) throws JavaDataModelException {\n+    for (final Field field : pojo.getDeclaredFields()) {\n+      validateAnnotations(field);\n+      if (field.getAnnotation(Attribute.class) != null) {\n+        field.setAccessible(true);\n+        attributeFields.add(field);\n+      } else if (field.getAnnotation(Tag.class) != null) {\n+        field.setAccessible(true);\n+        tagFields.add(field);\n+      } else if (field.getAnnotation(TagList.class) != null) {\n+        field.setAccessible(true);\n+        tagListFields.add(field);\n+      } else if (field.getAnnotation(BodyText.class) != null) {\n+        field.setAccessible(true);\n+        bodyTextFields.add(field);\n+      }\n+    }\n+    if (bodyTextFields.size() > 1) {\n+      throw new JavaDataModelException(\n+          \"Too many body text fields, can only have one on any given class\");\n+    }\n+    if (!bodyTextFields.isEmpty() && (!tagFields.isEmpty() && !tagListFields.isEmpty())) {\n+      throw new JavaDataModelException(\n+          \"Illegal combination of annoations, may only have attributes and a body text,\"\n+              + \"or attributes and tags (or taglist), but may not have both body text and tags.\");\n+    }\n+  }\n+\n+  private static <T> void validateAnnotations(final Field field) throws JavaDataModelException {", "originalCommit": "9ad43ba85810903b7cb84af3d07cc9270528d22f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkyMjQ1OA==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483922458", "bodyText": "Codacy found an issue: An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type.", "author": "DanVanAtta", "createdAt": "2020-09-05T07:27:15Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/XmlMapper.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package org.triplea.generic.xml.reader;\n+\n+import com.google.common.base.Preconditions;\n+import java.io.Closeable;\n+import java.io.InputStream;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Level;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import lombok.extern.java.Log;\n+import org.triplea.generic.xml.reader.exceptions.JavaDataModelException;\n+import org.triplea.generic.xml.reader.exceptions.XmlParsingException;\n+\n+@Log\n+public class XmlMapper implements Closeable {\n+  private XMLStreamReader xmlStreamReader;\n+\n+  public XmlMapper(final InputStream inputStream) throws XMLStreamException {\n+    final XMLInputFactory inputFactory = XMLInputFactory.newInstance();\n+    xmlStreamReader = inputFactory.createXMLStreamReader(inputStream);\n+  }\n+\n+  public <T> T mapXmlToObject(final Class<T> pojo) throws XmlParsingException {\n+    // At this point in parsing the XML cursor is just beyond the start tag.\n+    // We can read attributes directly off of the stream at this point.\n+    // If we do nothing more then the cursor will keep moving down and will not\n+    // descend into any child tags or the body text of the current tag.\n+    //\n+    // Beyond mapping attributes, we should scan for any handlers defined\n+    // on the POJO, whether those are handlers for more child tags, tag lists or\n+    // body content. If we see any of those we will set up callbacks on the\n+    // XML parsing such that when the cursor hits tags with matching names\n+    // or finishes reading the body content it will execute the callback.\n+    //\n+    // Each callback will get data from the XML parsing cursor and the callback\n+    // only then needs to set that data on the current object that we are building and will\n+    // be returning.\n+    //\n+    // The callbacks are of two types: tags or body content.\n+    //\n+    // Body content callback is pretty simple, we'll read all of the body content into a buffer\n+    // and when done will execute the body content setter callback.\n+    //\n+    // The tag callbacks are a map of tag name to setter callback method. When the XML\n+    // cursor sees a tag with a matching name it'll call the setter callback.\n+    // The setter callback will invoke this method again to create a fully formed object\n+    // out of that tag (and then set it).\n+\n+    try {\n+      // Create the object to return, it is a java representation of the \"current tag\".\n+      final T instance = ReflectionUtils.newInstance(pojo);\n+      final AnnotatedFields<T> annotatedFields = new AnnotatedFields<>(pojo);\n+\n+      // set attributes on the current object\n+      for (final Field field : annotatedFields.getAttributeFields()) {\n+        final String xmlAttributeValue = xmlStreamReader.getAttributeValue(null, field.getName());\n+        final Object value = new AttributeValueCasting(field).castAttributeValue(xmlAttributeValue);\n+        field.set(instance, value);\n+      }\n+\n+      // Check if we have any more work to do, if only attributes can go ahead and return now.\n+      if (annotatedFields.getTagFields().isEmpty()\n+          && annotatedFields.getTagListFields().isEmpty()\n+          && annotatedFields.getBodyTextFields().isEmpty()) {\n+        return instance;\n+      }\n+\n+      // This parser will do the work of parsing the current tag, it'll look at all\n+      // child tags and the body text and invoke the right callback that we will define below.\n+      final XmlParser tagParser = new XmlParser(pojo.getSimpleName());\n+\n+      // Set up tag parsing, as we scan through more elements when we see a matching\n+      // tag name we'll call the child tag handler. The child tag handler will\n+      // create a java model representing the child tag and set the field instance\n+      // on our current running instance object.\n+      for (final Field field : annotatedFields.getTagFields()) {\n+        final String expectedTagName = field.getType().getSimpleName();\n+        tagParser.childTagHandler(\n+            expectedTagName, () -> field.set(instance, mapXmlToObject(field.getType())));\n+      }\n+\n+      // Set up tag list parsing, similar to tag parsing except we set the field\n+      // value to a list and each time we see a new child tag we'll add it back to that list.\n+      for (final Field field : annotatedFields.getTagListFields()) {\n+        final List<Object> tagList = new ArrayList<>();\n+        field.set(instance, tagList);\n+        final Class<?> listType = ReflectionUtils.getGenericType(field);\n+        tagParser.childTagHandler(\n+            listType.getSimpleName(), () -> tagList.add(mapXmlToObject(listType)));\n+      }\n+\n+      // Set up body text handler. The XML cursor will iterate over each line of body\n+      // content and we will buffer that content, when the full content is read it is trimmed\n+      // and the setter callback below is executed.\n+      for (final Field field : annotatedFields.getBodyTextFields()) {\n+        Preconditions.checkState(annotatedFields.getBodyTextFields().size() == 1);\n+        tagParser.bodyHandler(\n+            textContent -> {\n+              try {\n+                field.set(instance, textContent);\n+              } catch (final IllegalAccessException e) {\n+                throw new JavaDataModelException(field, \"Unexpected illegal access\", e);\n+              }\n+            });\n+      }\n+\n+      tagParser.parse(xmlStreamReader);\n+\n+      return instance;\n+    } catch (final Throwable e) {\n+      if (e instanceof XmlParsingException) {", "originalCommit": "9ad43ba85810903b7cb84af3d07cc9270528d22f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkyMjQ2NA==", "url": "https://github.com/triplea-game/triplea/pull/7543#discussion_r483922464", "bodyText": "Codacy found an issue: New exception is thrown in catch block, original stack trace may be lost", "author": "DanVanAtta", "createdAt": "2020-09-05T07:27:18Z", "path": "xml-reader/src/main/java/org/triplea/generic/xml/reader/AttributeValueCasting.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package org.triplea.generic.xml.reader;\n+\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.Field;\n+import java.util.Optional;\n+import org.triplea.generic.xml.reader.annotations.Attribute;\n+import org.triplea.generic.xml.reader.exceptions.XmlDataException;\n+\n+class AttributeValueCasting {\n+\n+  private final Field field;\n+  private final Attribute attributeAnnotation;\n+\n+  AttributeValueCasting(final Field field) {\n+    this.field = field;\n+    attributeAnnotation = Preconditions.checkNotNull(field.getAnnotation(Attribute.class));\n+  }\n+\n+  Object castAttributeValue(final String attributeValue) throws XmlDataException {\n+    if (field.getType() == Integer.class || field.getType() == Integer.TYPE) {\n+      return castToInt(attributeValue);\n+    } else if (field.getType() == Double.class || field.getType() == Double.TYPE) {\n+      return castToDouble(attributeValue);\n+    } else if (field.getType() == Boolean.class || field.getType() == Boolean.TYPE) {\n+      return castToBoolean(attributeValue);\n+    } else {\n+      // type is a String\n+      return Optional.ofNullable(attributeValue).orElseGet(attributeAnnotation::defaultValue);\n+    }\n+  }\n+\n+  /**\n+   * Cast attribute value to an int. If the value is null we return a default. If the field is a\n+   * \"Integer\" and if the attribute value is null and the default is not set then we return null. If\n+   * the field is an \"int\" and if the attribute value is null then we return 0.\n+   *\n+   * @throws XmlDataException Thrown if attributeValue is present but cannot be cast to an int.\n+   */\n+  private Integer castToInt(final String attributeValue) throws XmlDataException {\n+    if (attributeValue == null\n+        && field.getType() == Integer.class\n+        && field.getAnnotation(Attribute.class).defaultInt() == 0) {\n+      return null;\n+    } else if (attributeValue == null) {\n+      return field.getAnnotation(Attribute.class).defaultInt();\n+    } else {\n+      try {\n+        return Integer.valueOf(attributeValue);\n+      } catch (final NumberFormatException e) {\n+        throw new XmlDataException(", "originalCommit": "9ad43ba85810903b7cb84af3d07cc9270528d22f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}