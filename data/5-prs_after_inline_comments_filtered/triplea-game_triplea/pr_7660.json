{"pr_number": 7660, "pr_title": "Convert attacker retreat steps", "pr_createdAt": "2020-09-15T00:51:31Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7660", "timeline": [{"oid": "22f2a0ba19c81129d303e5551cc3b9f86cd4347e", "url": "https://github.com/triplea-game/triplea/commit/22f2a0ba19c81129d303e5551cc3b9f86cd4347e", "message": "Convert retreat steps", "committedDate": "2020-09-15T00:47:25Z", "type": "commit"}, {"oid": "0d2316af7b8efbf3036fcc79cf0355ab30466a43", "url": "https://github.com/triplea-game/triplea/commit/0d2316af7b8efbf3036fcc79cf0355ab30466a43", "message": "Add a comment about the blank bodies", "committedDate": "2020-09-15T02:09:16Z", "type": "commit"}, {"oid": "522898b8c244b228650027eb86095f8ed708aac4", "url": "https://github.com/triplea-game/triplea/commit/522898b8c244b228650027eb86095f8ed708aac4", "message": "Reduce cognitive complexity of retreatUnits", "committedDate": "2020-09-16T00:36:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTY0OA==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489105648", "bodyText": "Some background on why this is intentional could be useful. Why is this intentionally left blank?", "author": "DanVanAtta", "createdAt": "2020-09-16T01:21:29Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1661,45 +1667,33 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n         }\n       }\n     };\n-    steps.add(\n-        new IExecutable() {\n-          private static final long serialVersionUID = -1150863964807721395L;\n \n-          @Override\n-          public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-            if (!isOver\n-                && RetreatChecks.canAttackerRetreatPlanes(attackingUnits, gameData, isAmphibious)\n-                && !RetreatChecks.canAttackerRetreatPartialAmphib(\n-                    attackingUnits, gameData, isAmphibious)) {\n-              attackerRetreatPlanes(bridge);\n-            }\n-          }\n-        });\n-    steps.add(\n-        new IExecutable() {\n-          private static final long serialVersionUID = -1150863964807721395L;\n+    steps.add(offensiveGeneralRetreat);\n+    new IExecutable() {\n+      private static final long serialVersionUID = -1150863964807721395L;\n \n-          @Override\n-          public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n-            if (!isOver\n-                && RetreatChecks.canAttackerRetreatPartialAmphib(\n-                    attackingUnits, gameData, isAmphibious)) {\n-              attackerRetreatNonAmphibUnits(bridge);\n-            }\n-          }\n-        });\n-    steps.add(\n-        new IExecutable() {\n-          private static final long serialVersionUID = 669349383898975048L;\n+      @Override\n+      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+        // Intentionally left blank", "originalCommit": "522898b8c244b228650027eb86095f8ed708aac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExNDE1Nw==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489114157", "bodyText": "For some reason, the retreat steps were broken up into three separate IExecutables even though only one of them would ever run.  I merged all of them into one step and so two of the old IExecutables no longer have anything to do.", "author": "trevan", "createdAt": "2020-09-16T01:52:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE5MDk4OQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489190989", "bodyText": "Can you update the code with a comment or a 'remove on major release' annotation? This would help us to know what to do with this going forward.", "author": "DanVanAtta", "createdAt": "2020-09-16T06:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc5ODM2Mg==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489798362", "bodyText": "I added the annotation to all of the execute methods of the old IExecutables.  I also add a larger comment to indicate why it is blank.", "author": "trevan", "createdAt": "2020-09-16T22:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwNTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwOTE3OA==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489109178", "bodyText": "It's really odd for retreatUnits to be the implementation of this interface method, and also called externally directly. Can you speak to why that is @trevan ?", "author": "DanVanAtta", "createdAt": "2020-09-16T01:34:12Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.RetreatType;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class OffensiveGeneralRetreat implements BattleStep {\n+\n+  final BattleState battleState;\n+\n+  final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (canAttackerRetreat()\n+        || canAttackerRetreatSeaPlanes()\n+        || (battleState.isAmphibious()\n+            && (canAttackerRetreatPartialAmphib() || canAttackerRetreatAmphibPlanes()))) {\n+      return List.of(battleState.getAttacker().getName() + ATTACKER_WITHDRAW);\n+    }\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.OFFENSIVE_GENERAL_RETREAT;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    retreatUnits(bridge);", "originalCommit": "522898b8c244b228650027eb86095f8ed708aac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExNDg1OQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489114859", "bodyText": "The same logic (retreat) is called in other steps.  I either had the choice of creating a static helper class to store the logic or to allow the other steps to instantiate and call this method directly.\nI would prefer that the other steps didn't need this logic and hope that I might be able to fix it but that will involve changing the logic of the steps and might even change the game play.  I'd like to make that change in a separate PR.", "author": "trevan", "createdAt": "2020-09-16T01:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwOTE3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExNTgxMg==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489115812", "bodyText": "Fair enough. Extracting logic for re-use would seemingly be okay. Passing an instance to a constructor can help avoid static coupling.", "author": "DanVanAtta", "createdAt": "2020-09-16T01:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwOTE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwOTMxMg==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489109312", "bodyText": "Can these variables be made private?", "author": "DanVanAtta", "createdAt": "2020-09-16T01:34:45Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.RetreatType;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class OffensiveGeneralRetreat implements BattleStep {\n+\n+  final BattleState battleState;\n+\n+  final BattleActions battleActions;", "originalCommit": "522898b8c244b228650027eb86095f8ed708aac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEwOTc1NQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489109755", "bodyText": "Nitpicky - Even if a multi-line, I still think this would be cleaner as a ternary. I think with context, it seems easier, but I would suggest that maintaining/reading the code, it's easier to grok as a ternary. Perhaps the boolean can be extracted to a helper method to make it a simple tenary. WDYT?", "author": "DanVanAtta", "createdAt": "2020-09-16T01:36:14Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.RetreatType;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class OffensiveGeneralRetreat implements BattleStep {\n+\n+  final BattleState battleState;\n+\n+  final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (canAttackerRetreat()", "originalCommit": "522898b8c244b228650027eb86095f8ed708aac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMDE2NQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489110165", "bodyText": "Does this condition happen often? TBH, it seems a bit like a bug. If the battle is over, the caller perhaps did not realize that and should not have made this call to begin with.", "author": "DanVanAtta", "createdAt": "2020-09-16T01:37:39Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.RetreatType;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class OffensiveGeneralRetreat implements BattleStep {\n+\n+  final BattleState battleState;\n+\n+  final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (canAttackerRetreat()\n+        || canAttackerRetreatSeaPlanes()\n+        || (battleState.isAmphibious()\n+            && (canAttackerRetreatPartialAmphib() || canAttackerRetreatAmphibPlanes()))) {\n+      return List.of(battleState.getAttacker().getName() + ATTACKER_WITHDRAW);\n+    }\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.OFFENSIVE_GENERAL_RETREAT;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    retreatUnits(bridge);\n+  }\n+\n+  public void retreatUnits(final IDelegateBridge bridge) {\n+    if (battleState.isOver()) {", "originalCommit": "522898b8c244b228650027eb86095f8ed708aac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExNTkzOQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489115939", "bodyText": "Yes.  How the stack work is that at the beginning of the round, all of the IExecutables/BattleSteps are created and added to the stack.  Then, it goes through each of the items in the stack.  There isn't currently a way to short circuit the stack when the battle is over.  So, this step already is in the stack and will execute even if the battle finished in a previous step.", "author": "trevan", "createdAt": "2020-09-16T01:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE5MDc1Mg==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489190752", "bodyText": "Thanks for the context. I don't find that terribly satisfying, but I would accept that wiring a 'Predicate' for battle is over to the execution stack at this juncture is potentially not easy and out of scope of this update.", "author": "DanVanAtta", "createdAt": "2020-09-16T06:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMDE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMTUwMA==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489111500", "bodyText": "Have you consider pushing this conditional to the callers? I think in both cases it would be the calling code easier to understand, it avoids having to jump around the class file to understand those locations. Furthermore, without this if statement the method body would be a simple stream & any match statement. Not that it matters too much, there would be a small performance boost as you wouldn't need to compute the full set of land units but could halt on the first match.", "author": "DanVanAtta", "createdAt": "2020-09-16T01:42:59Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.ATTACKER_WITHDRAW;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle.RetreatType;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.battle.steps.RetreatChecks;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+@AllArgsConstructor\n+public class OffensiveGeneralRetreat implements BattleStep {\n+\n+  final BattleState battleState;\n+\n+  final BattleActions battleActions;\n+\n+  @Override\n+  public List<String> getNames() {\n+    if (canAttackerRetreat()\n+        || canAttackerRetreatSeaPlanes()\n+        || (battleState.isAmphibious()\n+            && (canAttackerRetreatPartialAmphib() || canAttackerRetreatAmphibPlanes()))) {\n+      return List.of(battleState.getAttacker().getName() + ATTACKER_WITHDRAW);\n+    }\n+    return List.of();\n+  }\n+\n+  @Override\n+  public Order getOrder() {\n+    return Order.OFFENSIVE_GENERAL_RETREAT;\n+  }\n+\n+  @Override\n+  public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n+    retreatUnits(bridge);\n+  }\n+\n+  public void retreatUnits(final IDelegateBridge bridge) {\n+    if (battleState.isOver()) {\n+      return;\n+    }\n+    final RetreatData retreatData;\n+\n+    if (battleState.isAmphibious()) {\n+      retreatData = getAmphibiousRetreatData();\n+      if (retreatData == null) {\n+        return;\n+      }\n+\n+    } else if (canAttackerRetreat()) {\n+      retreatData =\n+          RetreatData.of(RetreatType.DEFAULT, battleState.getAttackerRetreatTerritories());\n+    } else {\n+      return;\n+    }\n+\n+    battleActions.queryRetreat(false, retreatData.retreatType, bridge, retreatData.retreatSites);\n+  }\n+\n+  private @Nullable RetreatData getAmphibiousRetreatData() {\n+    if (canAttackerRetreatPartialAmphib()) {\n+      return RetreatData.of(\n+          RetreatType.PARTIAL_AMPHIB, battleState.getAttackerRetreatTerritories());\n+\n+    } else if (canAttackerRetreatAmphibPlanes()) {\n+      return RetreatData.of(RetreatType.PLANES, Set.of(battleState.getBattleSite()));\n+\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Value(staticConstructor = \"of\")\n+  private static class RetreatData {\n+    RetreatType retreatType;\n+    Collection<Territory> retreatSites;\n+  }\n+\n+  private boolean canAttackerRetreat() {\n+    return RetreatChecks.canAttackerRetreat(\n+        battleState.getUnits(BattleState.Side.DEFENSE),\n+        battleState.getGameData(),\n+        battleState::getAttackerRetreatTerritories,\n+        battleState.isAmphibious());\n+  }\n+\n+  private boolean canAttackerRetreatSeaPlanes() {\n+    return battleState.getBattleSite().isWater()\n+        && battleState.getUnits(BattleState.Side.OFFENSE).stream().anyMatch(Matches.unitIsAir());\n+  }\n+\n+  private boolean canAttackerRetreatPartialAmphib() {\n+    if (Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {", "originalCommit": "522898b8c244b228650027eb86095f8ed708aac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExOTU1Ng==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489119556", "bodyText": "I think it is better if the caller doesn't have to know what properties enable/disable partial amphibious retreat.\nI've made the stream/anyMatch change, though.", "author": "trevan", "createdAt": "2020-09-16T02:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4ODYxNQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489188615", "bodyText": "Hmm, it's a private method though.\nGenerally it's better to get the conditional logic done at a higher layer. So you have something that looks like this:\npublic void method() {\n  if(a || b) {\n        doFoo();\n         if(a1) {\n               doBar()\n          }\n  } else if(c) {\n      doZed();\n  }\n}\n\nvs:\npublic void method() {\n   doFoo();\n   doBar();\n   doZed();\n}\n\nprivate void doFoo() {    \n    if(!a && !b && c) {\n        doZed();\n    } else if(!a && !b) {\n        return;\n    }\n    doBar();\n}\n\nprivate void doBar() {\n    if(!a1) {\n        return;\n    }\n}\n\nNotice that above the control flow is pushed down and it's very hard to follow what the logic is.\nThe idea is 3 part:\n\nAvoid lists of void method calls\nChoose where the control flow will be, have the method with control flow just do mainly that and the things it invokes should be relatively functional.\nPush control flow to higher layers, avoid doing control flow in private methods That indicates you perhaps want a strategy object to handle the behavior.", "author": "DanVanAtta", "createdAt": "2020-09-16T06:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4OTEwMg==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489189102", "bodyText": "I'm not insisting any changes be made here, but I don't agree that having control flow at a lower layer like this makes it easier. A reader of the code needs to jump to this method anyways and it's cognitively complex to keep track of control flow throughout  'n' layers of code.", "author": "DanVanAtta", "createdAt": "2020-09-16T06:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE5MDA0NQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489190045", "bodyText": "Expouding on \"needs to jump to this method anyways\"\nLet's say the reader knows that only \"a\" is true. In this case the following method:\npublic void method() {\n  if(a || b) {\n        doFoo();\n         if(a1) {\n               doBar()\n          }\n  } else if(c) {\n      doZed();\n  }\n}\n\nRequires a reader to only read doFoo. On the other hand, with the series of void call, a reader needs to go through each method, hence why I suggest often they may as well be inlined, as you have to read it all anyways. The fact you can't skip code (as in this example where you can skip 'doBar' and 'doZed'), is a break-down of information hiding. My 2 cents.", "author": "DanVanAtta", "createdAt": "2020-09-16T06:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc5NzYzNQ==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489797635", "bodyText": "I think I understand what you are saying but this entire method is control flow.  So it is like:\npublic void method() {\n  if (isAllowed()) {\n    doFoo();\n  }\n}\n\nprivate boolean isAllowed() {\n  return a || (b && c) || d;\n}\n\nvs\npublic void method() {\n  if (a || (b && c) || d) {\n    doFoo();\n  }\n}\n\nYou just recommended that I do the former in getNames() (with the the new isRetreatPossible() method).  How is canAttackerRetreatPartialAmphib() any different?\nOr is it because both canAttackerRetreatPartialAmphib() and canAttackerRetreatAmphibPlanes() checks for Properties.getPartialAmphibiousRetreat and so you want to move that call out of them?", "author": "trevan", "createdAt": "2020-09-16T22:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExMTUwMA=="}], "type": "inlineReview"}, {"oid": "86a1401431261ba9a1421c66a0fa4b7e9cb2c9da", "url": "https://github.com/triplea-game/triplea/commit/86a1401431261ba9a1421c66a0fa4b7e9cb2c9da", "message": "Review changes", "committedDate": "2020-09-16T02:13:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE5MTI2Nw==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489191267", "bodyText": "\ud83d\udc4d\nThis looks good, thanks!", "author": "DanVanAtta", "createdAt": "2020-09-16T06:24:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -20,24 +19,26 @@\n import javax.annotation.Nullable;\n import lombok.AllArgsConstructor;\n import lombok.Value;\n-import org.triplea.java.collections.CollectionUtils;\n \n @AllArgsConstructor\n public class OffensiveGeneralRetreat implements BattleStep {\n \n-  final BattleState battleState;\n+  private final BattleState battleState;\n \n-  final BattleActions battleActions;\n+  private final BattleActions battleActions;\n \n   @Override\n   public List<String> getNames() {\n-    if (canAttackerRetreat()\n+    return isRetreatPossible()", "originalCommit": "86a1401431261ba9a1421c66a0fa4b7e9cb2c9da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE5MTg4Mw==", "url": "https://github.com/triplea-game/triplea/pull/7660#discussion_r489191883", "bodyText": "nitpicky, note - you can use Predicates here to write this as a method references:\n.anyMatch(Predicates.not(Unit::getWasAmphibious));", "author": "DanVanAtta", "createdAt": "2020-09-16T06:25:52Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/OffensiveGeneralRetreat.java", "diffHunk": "@@ -105,18 +106,13 @@ private boolean canAttackerRetreatSeaPlanes() {\n   }\n \n   private boolean canAttackerRetreatPartialAmphib() {\n-    if (Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n-      // Only include land units when checking for allow amphibious retreat\n-      final List<Unit> landUnits =\n-          CollectionUtils.getMatches(\n-              battleState.getUnits(BattleState.Side.OFFENSE), Matches.unitIsLand());\n-      for (final Unit unit : landUnits) {\n-        if (!unit.getWasAmphibious()) {\n-          return true;\n-        }\n-      }\n+    if (!Properties.getPartialAmphibiousRetreat(battleState.getGameData())) {\n+      return false;\n     }\n-    return false;\n+    // Only include land units when checking for allow amphibious retreat\n+    return battleState.getUnits(BattleState.Side.OFFENSE).stream()\n+        .filter(Matches.unitIsLand())\n+        .anyMatch(unit -> !unit.getWasAmphibious());", "originalCommit": "86a1401431261ba9a1421c66a0fa4b7e9cb2c9da", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a866bc5bedcba6cf681bc75837c23ea1cc7ce4ca", "url": "https://github.com/triplea-game/triplea/commit/a866bc5bedcba6cf681bc75837c23ea1cc7ce4ca", "message": "Mark old classes with RemoveOnNextMajorRelease annotation", "committedDate": "2020-09-16T22:55:28Z", "type": "commit"}, {"oid": "428152b406245f3eee00150f42fa124904acbbab", "url": "https://github.com/triplea-game/triplea/commit/428152b406245f3eee00150f42fa124904acbbab", "message": "Use Predicate.not", "committedDate": "2020-09-16T22:55:37Z", "type": "commit"}]}