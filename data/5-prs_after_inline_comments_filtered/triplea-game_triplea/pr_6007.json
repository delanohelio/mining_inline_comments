{"pr_number": 6007, "pr_title": "Expire games", "pr_createdAt": "2020-03-05T07:32:29Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6007", "timeline": [{"oid": "25f3750245cac32841dabda58e1646e67195bf97", "url": "https://github.com/triplea-game/triplea/commit/25f3750245cac32841dabda58e1646e67195bf97", "message": "Notify game client when lobby listings are expired from cache.\n\nGames are expired from cache if they are not renewed via keep-alive.\nCurrently nothing notifies clients when such a game is removed and\nthe client will think the game is still available. We previously\nwould have polled for all available games and the client would\ndetermine when games have been removed. Then after switching to\nwebsockets and an expiring cache, there was nothing done to replace\nthis notification mechanism.\n\nGetting a listener to be notified on cache expiry is a bit tricky and\nrequires a cleanup job to be run. To extract these details, we\ncreate a 'Cache' interface and consolidate CacheUtils to this interface.\nThen we create an implementation that will invoke a removed item listener.\nThis is done by creating a scheduled thread that periodically calls\n'cleanup' on the cache.", "committedDate": "2020-03-05T07:38:08Z", "type": "commit"}, {"oid": "1d2c34c25db927ec4a5ed45165a4cc33f3418923", "url": "https://github.com/triplea-game/triplea/commit/1d2c34c25db927ec4a5ed45165a4cc33f3418923", "message": "Add a number of contract tests for cache", "committedDate": "2020-03-05T07:38:08Z", "type": "commit"}, {"oid": "c62312b1c8dfaa9524dedbd49bfffd5a0991aeb6", "url": "https://github.com/triplea-game/triplea/commit/c62312b1c8dfaa9524dedbd49bfffd5a0991aeb6", "message": "Rename \"stopTimer\" method to \"close\"", "committedDate": "2020-03-05T07:38:08Z", "type": "commit"}, {"oid": "1777ff9ebf5a697b3475b9877c5684d7ce712569", "url": "https://github.com/triplea-game/triplea/commit/1777ff9ebf5a697b3475b9877c5684d7ce712569", "message": "Remove mock cache from test", "committedDate": "2020-03-05T07:38:08Z", "type": "commit"}, {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "url": "https://github.com/triplea-game/triplea/commit/738891c5a0e78879dfea1dd192a97f9f6c26510c", "message": "Notify removal listener explicitly on 'invalidate' calls\n\nThis makes tests more deterministic and avoids delays for the callback\nwhen waiting for 'cleanup'", "committedDate": "2020-03-05T07:38:08Z", "type": "commit"}, {"oid": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "url": "https://github.com/triplea-game/triplea/commit/738891c5a0e78879dfea1dd192a97f9f6c26510c", "message": "Notify removal listener explicitly on 'invalidate' calls\n\nThis makes tests more deterministic and avoids delays for the callback\nwhen waiting for 'cleanup'", "committedDate": "2020-03-05T07:38:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388504522", "bodyText": "What about using BiConsumer instead?", "author": "RoiEXLab", "createdAt": "2020-03-05T19:13:07Z", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));", "originalCommit": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMTk5NA==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388511994", "bodyText": "Just had a look at the caffeine documentation because I thought the explicit casting was weird.\nYou can avoid (I'm 99% sure) the unchecked warning by using\n.<IdT, ValueT>removalListener((key, value, cause) -> {});\nInstead", "author": "RoiEXLab", "createdAt": "2020-03-05T19:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyNzY3Mg==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388527672", "bodyText": "You could declare the types on the lambda parameters instead,\n.removalListener((IdT key, ValueT value, RemovalCause cause) -> {});", "author": "ben-manes", "createdAt": "2020-03-05T19:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczMzA2NQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388733065", "bodyText": "Good suggestions, thank you - both work. I was struggling to find the right variant. Slightly leaning towards types on the lambda parameters, updated: 1de5679", "author": "DanVanAtta", "createdAt": "2020-03-06T06:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388505647", "bodyText": "Maybe I'm missing something, but why is removalListener called explicitly here?\nShouldn't invalidate trigger the listener by itself already?", "author": "RoiEXLab", "createdAt": "2020-03-05T19:15:09Z", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));", "originalCommit": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyODI5Mw==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388528293", "bodyText": "yes. Even if not, you can use asMap().remove(id) to remove the entry and obtain the old value atomically.", "author": "ben-manes", "createdAt": "2020-03-05T19:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczODAxOQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388738019", "bodyText": "For better or worse, the explicit removal is to avoid any timing issues or non-determinism in test. If we do not have the explicit remove, then this test:\nhttps://github.com/triplea-game/triplea/pull/6007/files#diff-9e70eb2aee6299a62f6edd3626506959R148, updated to be repeated 1000 times will consistently have some failures, eg:\n    @RepeatedTest(1000)\n    void removalListenerIsInvokedWhenItemsAreInvalidated() {\n      realCache.put(\"id10\", 0);\n      realCache.invalidate(\"id10\");\n\n      verify(cacheRemovalListener, atLeastOnce()).accept(new CacheEntry<>(\"id10\", 0));\n    }\n\nWrapping an external API behind an interface can often be good to insulate our code from 3rd party, as a general practice, in large part it is done here with implementation so we can have a \"native\" API and reliable calls to 'removal listener'. That was what kinda kicked this whole thing off, the naive addition of removal listener to the guava cache simply did not work..\nGrant it, with a reliable scheduler, which I think we have, we should get reliable calls to removal listener. With that being said, having no delay for removed item notification and perfectly deterministic testing is IMO worth the cost of potentially having multiple calls to a removal listener.", "author": "DanVanAtta", "createdAt": "2020-03-06T06:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczODEyMg==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388738122", "bodyText": "@ben-manes good suggestion, I did not realize 'asMap' would modify the underlying cache. Updated: fa933b3", "author": "DanVanAtta", "createdAt": "2020-03-06T06:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyMjMzNA==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388922334", "bodyText": "@DanVanAtta If it's only the tests, then we could make the test wait until ForkJoinPool.commonPool() processed all events (I had a look at the source code), or alternatively just pass a custom executor for the test cases which simply runs the specified Runnable", "author": "RoiEXLab", "createdAt": "2020-03-06T14:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5NDc2Ng==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389094766", "bodyText": "Reasonable suggestions, though I think sticking with the explicit notification is okay:\n\nin our context we handle duplicate calls already (at least we should be!). Having a contract that allows for duplicate callbacks seems okay in general as well (and if not then there is room for other implementations to change that).\nthe test is already a bit slow at 700ms. Doing a join could mean we wait for the scheduled cleanup job which could add a second\na join in the test would turn the test from mostly if not entirely a black box test into a white box test. Tests that do not rely on internal implementations tend to be easier to understand and maintain\n\nA custom executor would also fall under the category of test scaffolding, it's better minimized. At the end of the day we also get benefit from an immediate callback, which does make the UI seem more responsive as games are removed nearly immediately and not after a small delay.", "author": "DanVanAtta", "createdAt": "2020-03-06T19:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNTY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388514057", "bodyText": "what's the reason this task has a random id attached to it?", "author": "RoiEXLab", "createdAt": "2020-03-05T19:29:22Z", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())", "originalCommit": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMDU3Mw==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388530573", "bodyText": "You can use Caffeine.scheduler to do this for you, too! If you are on JDK9+ then it can leverage the JVM-wide thread (internal to CompletableFuture), or else you can either supply a ScheduledExecutorService or your own implementation.\nCaffeine.newBuilder()\n    .expireAfterWrite(duration, timeUnit)\n    .scheduler(Scheduler.systemScheduler())\n...", "author": "ben-manes", "createdAt": "2020-03-05T19:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczNTI3NA==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388735274", "bodyText": "@RoiEXLab the random id was so that in case we had multiple caches, the cleanup threads would be given different names. Admittedly, probably over-engineering on my part.\n@ben-manes, thank you for the suggestion, works like a charm \ud83d\udc4d\nI particularly like how we no longer have to clean up the timer thread that was scheduled here, it simplifies a good bit. Updated in: 5eeb317", "author": "DanVanAtta", "createdAt": "2020-03-06T06:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTI0MQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388531241", "bodyText": "Atomically,\nreturn Optional.ofNullable(cache.asMap().replace(id, newValue));", "author": "ben-manes", "createdAt": "2020-03-05T20:01:03Z", "path": "java-extras/src/main/java/org/triplea/java/cache/TtlCache.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.triplea.java.cache;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import lombok.Value;\n+\n+public interface TtlCache<IdT, ValueT> {\n+\n+  /**\n+   * Extends the 'life' of a given entry and prevents cache expiration for another TTL. Returns true\n+   * if an element existed and was refreshed, returns false if no such element existed.\n+   */\n+  boolean refresh(IdT id);\n+\n+  /** Retrieves a value from the cache, if any. */\n+  Optional<ValueT> get(IdT id);\n+\n+  /** Places a new item in the cache, overwriting any values with the existing ID. */\n+  void put(IdT id, ValueT value);\n+\n+  /** Explicitly removes an item from cache, returns any such value that was removed. */\n+  Optional<ValueT> invalidate(IdT id);\n+\n+  /**\n+   * Places a new item in the cache if one existed with the same ID and replaces the existing value.\n+   * The replaced item is returned, otherwise returns an empty.\n+   */\n+  default Optional<ValueT> replace(IdT id, ValueT newValue) {\n+    final Optional<ValueT> value = get(id);\n+    if (value.isPresent()) {\n+      put(id, newValue);\n+    }\n+    return value;", "originalCommit": "738891c5a0e78879dfea1dd192a97f9f6c26510c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTIyOQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388741229", "bodyText": "Seems simpler, atomic is better - thank you for the suggestion! Updated: 08d724e", "author": "DanVanAtta", "createdAt": "2020-03-06T07:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMTI0MQ=="}], "type": "inlineReview"}, {"oid": "f79804af90eaa1af9128d1daaff4072cb344b827", "url": "https://github.com/triplea-game/triplea/commit/f79804af90eaa1af9128d1daaff4072cb344b827", "message": "Test fix, game removed listener can be called multiple times.", "committedDate": "2020-03-06T05:34:08Z", "type": "commit"}, {"oid": "5435f8a184db3486a1cfd6ea83b1ab7672483c90", "url": "https://github.com/triplea-game/triplea/commit/5435f8a184db3486a1cfd6ea83b1ab7672483c90", "message": "Update dependency syntax and put version number in main build.gradle and reference through a variable", "committedDate": "2020-03-06T06:25:53Z", "type": "commit"}, {"oid": "1de5679fe9319f32fccce74aa4d81193c7207cd2", "url": "https://github.com/triplea-game/triplea/commit/1de5679fe9319f32fccce74aa4d81193c7207cd2", "message": "Remove explicit casting by adding types to lambda parameters", "committedDate": "2020-03-06T06:29:51Z", "type": "commit"}, {"oid": "5eeb317b5d4c0300e7fc009009d94b7a98fe5f25", "url": "https://github.com/triplea-game/triplea/commit/5eeb317b5d4c0300e7fc009009d94b7a98fe5f25", "message": "Use built-in Caffeine cache scheduler for maintenance operation scheduling\n\nMaintenance operations, the things that trigger removals and removal listeners\nto be notified are not reliably run all the time. The scheduler fixes this\nso that maintenance happens more frequently and we get a dependendable call\nto removal listeners.", "committedDate": "2020-03-06T06:37:29Z", "type": "commit"}, {"oid": "fa933b3ed5d6363701c39b6248d4acaa7468870d", "url": "https://github.com/triplea-game/triplea/commit/fa933b3ed5d6363701c39b6248d4acaa7468870d", "message": "Update invalidate to have atomic removal and get of teh value being removed", "committedDate": "2020-03-06T06:49:38Z", "type": "commit"}, {"oid": "08d724ea050e005ad56165aa99105ba719d956f5", "url": "https://github.com/triplea-game/triplea/commit/08d724ea050e005ad56165aa99105ba719d956f5", "message": "Simplify replace and make replace atomic", "committedDate": "2020-03-06T07:03:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388739599", "bodyText": "@RoiEXLab FWIW, this is one place where guava kinda seemed to fall short, eg (below is demonstrate the explicit cast):\n  public Map<IdT, ValueT> asMap() {\n    Map<IdT, ValueT> map = (ConcurrentMap<IdT, ValueT>) CacheBuilder.newBuilder()\n        .expireAfterWrite(1, TimeUnit.MILLISECONDS)\n        .build()\n        .asMap();", "author": "DanVanAtta", "createdAt": "2020-03-06T06:57:29Z", "path": "java-extras/src/main/java/org/triplea/java/cache/ExpiringAfterWriteCache.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.triplea.java.cache;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.RemovalCause;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.triplea.java.timer.ScheduledTimer;\n+import org.triplea.java.timer.Timers;\n+\n+/**\n+ * Cache that expires values when a TTL (time to live) expires. TTL timer starts when the value is\n+ * written and is renewed if the value is 'refreshed'. The cache will reliably invoke a\n+ * 'removeListener' at least once when cache items are removed or expired.\n+ *\n+ * @param <IdT> Type that identifies the keys of the map.\n+ * @param <ValueT> Type that is placed as a value in the map.\n+ */\n+public class ExpiringAfterWriteCache<IdT, ValueT> implements TtlCache<IdT, ValueT> {\n+\n+  private final Cache<IdT, ValueT> cache;\n+  private final ScheduledTimer cleanupTimer;\n+  private final Consumer<CacheEntry<IdT, ValueT>> removalListener;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public ExpiringAfterWriteCache(\n+      final long duration,\n+      final TimeUnit timeUnit,\n+      final Consumer<CacheEntry<IdT, ValueT>> removalListener) {\n+    cache =\n+        Caffeine.newBuilder()\n+            .expireAfterWrite(duration, timeUnit)\n+            .removalListener(\n+                (key, value, cause) -> {\n+                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n+                    removalListener.accept(new CacheEntry<>((IdT) key, (ValueT) value));\n+                  }\n+                })\n+            .build();\n+\n+    this.removalListener = removalListener;\n+\n+    cleanupTimer =\n+        Timers.fixedRateTimer(\"cache-cleanup-\" + Math.random())\n+            .period(1000, TimeUnit.MILLISECONDS)\n+            .task(cache::cleanUp)\n+            .start();\n+  }\n+\n+  public void close() {\n+    cleanupTimer.cancel();\n+  }\n+\n+  @Override\n+  public boolean refresh(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+\n+    if (value.isPresent()) {\n+      put(id, value.get());\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public Optional<ValueT> get(final IdT id) {\n+    return Optional.ofNullable(cache.getIfPresent(id));\n+  }\n+\n+  @Override\n+  public void put(final IdT id, final ValueT value) {\n+    cache.put(id, value);\n+  }\n+\n+  @Override\n+  public Optional<ValueT> invalidate(final IdT id) {\n+    final Optional<ValueT> value = get(id);\n+    cache.invalidate(id);\n+    value.ifPresent(valueT -> removalListener.accept(new CacheEntry<>(id, valueT)));\n+    return value;\n+  }\n+\n+  @Override\n+  public Map<IdT, ValueT> asMap() {\n+    return Map.copyOf(cache.asMap());", "originalCommit": "f79804af90eaa1af9128d1daaff4072cb344b827", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyMzE0Nw==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388923147", "bodyText": "I think the way it's supposed to be done is by doing something like:\nMap<IdT, ValueT> map = CacheBuilder.<IdT, ValueT>newBuilder()\n        .expireAfterWrite(1, TimeUnit.MILLISECONDS)\n        .build()\n        .asMap();\ninstead, but ok", "author": "RoiEXLab", "createdAt": "2020-03-06T14:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5NjQxMQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389096411", "bodyText": "Even that variant does not work, you get a type cast exception where ConcurrentMap<Object,Object> is not compatible. \ud83d\ude01", "author": "DanVanAtta", "createdAt": "2020-03-06T19:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEwMTgxOQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389101819", "bodyText": "Yes, the builder inference in both APIs is meant for the cache type. You have two options,\nMap<IdT, ValueT> map = CacheBuilder.newBuilder().<IdT, ValueT>build().asMap();\n\nCache<IdT, ValueT> cache = CacheBuilder.newBuilder().build();\nMap<IdT, ValueT> map = cache.asMap();", "author": "ben-manes", "createdAt": "2020-03-06T19:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODczOTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r388924681", "bodyText": "Thinking about my suggestion that passes a custom executor for the tests: This particular tests would gain some extra safety, because in case the removalListener is executed asynchronously, the tests might check too early missing this critical error.", "author": "RoiEXLab", "createdAt": "2020-03-06T14:14:19Z", "path": "java-extras/src/test/java/org/triplea/java/cache/ExpiringAfterWriteCacheTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.triplea.java.cache;\n+\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\n+import static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.triplea.java.cache.TtlCache.CacheEntry;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ExpiringAfterWriteCacheTest {\n+\n+  private static final String KEY = \"key-value\";\n+  private static final int VALUE = 100;\n+  private ExpiringAfterWriteCache<String, Integer> realCache;\n+\n+  @Mock private Consumer<CacheEntry<String, Integer>> cacheRemovalListener;\n+\n+  @BeforeEach\n+  void setup() {\n+    realCache = new ExpiringAfterWriteCache<>(1, TimeUnit.MINUTES, cacheRemovalListener);\n+  }\n+\n+  @Nested\n+  class GetAndPut {\n+    @Test\n+    void getWillReturnValuesThatHaveBeenPutIntoCache() {\n+      realCache.put(\"id\", 0);\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(0));\n+    }\n+\n+    @Test\n+    void getReturnsEmptyIfValueDoesNotExist() {\n+      assertThat(realCache.get(\"DNE\"), isEmpty());\n+    }\n+\n+    @Test\n+    void putCanBeUsedToReplace() {\n+      realCache.put(\"id\", 0);\n+\n+      realCache.put(\"id\", 1);\n+\n+      assertThat(realCache.get(\"id\"), isPresentAndIs(1));\n+      verify(cacheRemovalListener, never()).accept(any());", "originalCommit": "de60ba28b330df6290f88db7101ba28ee229abfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODA4Mw==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389098083", "bodyText": "Agree the test could miss the timing. In practice this won't be a problem, there is a trade-off here between a slow test and more thorough test. Adding a second long delay would be the thing to do, and/or making the cache scheduler really aggressive.\nI double checked with a timeout and many repeated tests, as expected the test stays solid which is the most important thing. At this point I'm happy leaving the test to be more behavior documentation/spec than full-proof.", "author": "DanVanAtta", "createdAt": "2020-03-06T19:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEwMzUyNg==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389103526", "bodyText": "Another approach than specifying a direct executor is to use a testing library like Awaitility.", "author": "ben-manes", "createdAt": "2020-03-06T19:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NTY5NA==", "url": "https://github.com/triplea-game/triplea/pull/6007#discussion_r389175694", "bodyText": "Really what we are testing is the if condition here: https://github.com/triplea-game/triplea/pull/6007/files#diff-bd3a571488048aa02a100236fc5d8a77R33\n            .removalListener(\n                (IdT key, ValueT value, RemovalCause cause) -> {\n                  if (cause == RemovalCause.EXPIRED || cause == RemovalCause.EXPLICIT) {\n                    removalListener.accept(key, value);\n                  }\n\nMockito 'verify' has a timeout function, so it would be straightforward to add the delay. The issue is that we are testing the absence of a call, so we'd always hit the timeout making this a very slow test.\nIMO the best way to test probably would be to inject the filter logic, test the filter, and then trust that the library code does call the filter on remove listener.\nI'm leaning towards keeping this test as is:\n\ninjecting modules is at danger of over-engineering\nthe ROI of a slow but more thorough test is not favorable. We're already close to testing pure library code", "author": "DanVanAtta", "createdAt": "2020-03-06T22:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY4MQ=="}], "type": "inlineReview"}, {"oid": "fdc8b2402708f7683a058b4ab11fe44289535e10", "url": "https://github.com/triplea-game/triplea/commit/fdc8b2402708f7683a058b4ab11fe44289535e10", "message": "Use a bi-consumer for removal listener instead of consumer<entry>", "committedDate": "2020-03-06T19:32:39Z", "type": "commit"}, {"oid": "fdc8b2402708f7683a058b4ab11fe44289535e10", "url": "https://github.com/triplea-game/triplea/commit/fdc8b2402708f7683a058b4ab11fe44289535e10", "message": "Use a bi-consumer for removal listener instead of consumer<entry>", "committedDate": "2020-03-06T19:32:39Z", "type": "forcePushed"}, {"oid": "0c96a3d18d5070f17902589f233a294f28c10bd0", "url": "https://github.com/triplea-game/triplea/commit/0c96a3d18d5070f17902589f233a294f28c10bd0", "message": "Update test case", "committedDate": "2020-03-06T20:06:29Z", "type": "commit"}, {"oid": "ff49e3184b6c846deced52ceedf666402edab561", "url": "https://github.com/triplea-game/triplea/commit/ff49e3184b6c846deced52ceedf666402edab561", "message": "Auto-Formatting", "committedDate": "2020-03-06T20:08:47Z", "type": "commit"}, {"oid": "d3c1255de0c9f6ce7d3ff32795c7a9762accadc2", "url": "https://github.com/triplea-game/triplea/commit/d3c1255de0c9f6ce7d3ff32795c7a9762accadc2", "message": "Update tests", "committedDate": "2020-03-06T20:20:28Z", "type": "commit"}, {"oid": "fa4457b30a058a330731714ee870b8b23ef65332", "url": "https://github.com/triplea-game/triplea/commit/fa4457b30a058a330731714ee870b8b23ef65332", "message": "Exclude conflicting caffeine dependency brought in by errorprone", "committedDate": "2020-03-06T20:45:57Z", "type": "commit"}, {"oid": "7d4b98c96c1925a4a803d121ddcae89c529112ca", "url": "https://github.com/triplea-game/triplea/commit/7d4b98c96c1925a4a803d121ddcae89c529112ca", "message": "Instead of excluding errorpone caffeine dep, define it explicitly to pick up the right version", "committedDate": "2020-03-06T22:32:32Z", "type": "commit"}]}