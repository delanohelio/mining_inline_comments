{"pr_number": 6423, "pr_title": "DiceRoll - Support sort extracted", "pr_createdAt": "2020-05-07T04:51:54Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6423", "timeline": [{"oid": "97b634ab6e828246705c1e0523c574c882d05881", "url": "https://github.com/triplea-game/triplea/commit/97b634ab6e828246705c1e0523c574c882d05881", "message": "Extract support attachment sort to its own class and inline usages\n\n1. Create a new class 'SupportRuleSort' implementing comparator to be the new\n   home for unit attachment support sorting logic (in DiceRoll.java)\n2. Move sorting logic from DiceRoll.java 'SupportRuleSort'\n3. Inline calls to 'SupportRuleSort'", "committedDate": "2020-05-07T04:45:07Z", "type": "commit"}, {"oid": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "url": "https://github.com/triplea-game/triplea/commit/5a6dee7b2af954bfd2128d84084a2c748d94284a", "message": "Combine duplicated getSortedSupport logic\n\nBy accepting a list of rules to 'getSortedSupport', we can nearly\ncombine 'getSortedAASupport' with 'getSortedSupport'.", "committedDate": "2020-05-07T04:49:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODExMg==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238112", "bodyText": "Of note' support' here is not extracted to the new calls as the sort was applied to this. Instead we'll have the callers do the sort and extract the rest of this function and variables to the new class (see first commit).", "author": "DanVanAtta", "createdAt": "2020-05-07T04:52:44Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/DiceRoll.java", "diffHunk": "@@ -1182,149 +1190,6 @@ public static void sortByStrength(final List<Unit> units, final boolean defendin\n     units.sort(comp);\n   }\n \n-  private static void sortAaSupportRules(\n-      final Set<List<UnitSupportAttachment>> support,\n-      final boolean defense,\n-      final boolean friendly) {\n-    sortSupportRules(\n-        support,\n-        defense,\n-        friendly,\n-        UnitSupportAttachment::getAaRoll,\n-        UnitSupportAttachment::getAaStrength);\n-  }\n-\n-  private static void sortSupportRules(\n-      final Set<List<UnitSupportAttachment>> support,\n-      final boolean defense,\n-      final boolean friendly) {\n-    sortSupportRules(\n-        support,\n-        defense,\n-        friendly,\n-        UnitSupportAttachment::getRoll,\n-        UnitSupportAttachment::getStrength);\n-  }\n-\n-  private static void sortSupportRules(\n-      final Set<List<UnitSupportAttachment>> support,", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI4OA==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238288", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:32Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to\n+    // less than zero.\n+    // We should actually apply enemy negative support in order from worst to least bad, on a\n+    // unit list that is\n+    // ordered from strongest to weakest.\n+    final boolean u1CanBonus = defense ? u1.getDefence() : u1.getOffence();\n+    final boolean u2CanBonus = defense ? u2.getDefence() : u2.getOffence();\n+    if (friendly) {", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI4OQ==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238289", "bodyText": "Method compare has 64 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:32Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI5MA==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238290", "bodyText": "Avoid too many return statements within this method.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:32Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to\n+    // less than zero.\n+    // We should actually apply enemy negative support in order from worst to least bad, on a\n+    // unit list that is\n+    // ordered from strongest to weakest.\n+    final boolean u1CanBonus = defense ? u1.getDefence() : u1.getOffence();\n+    final boolean u2CanBonus = defense ? u2.getDefence() : u2.getOffence();\n+    if (friendly) {\n+      // favor rolls over strength\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    } else {\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    }\n+\n+    // If the bonuses are the same, we want to make sure any support which only supports 1\n+    // single unit type goes\n+    // first because there could be Support1 which supports both infantry and mech infantry,\n+    // and Support2\n+    // which only supports mech infantry. If the Support1 goes first, and the mech infantry is\n+    // first in the unit list\n+    // (highly probable), then Support1 will end up using all of itself up on the mech\n+    // infantry then when the Support2\n+    // comes up, all the mech infantry are used up, and it does nothing. Instead, we want\n+    // Support2 to come first,\n+    // support all mech infantry that it can, then have Support1 come in and support whatever\n+    // is left, that way no\n+    // support is wasted.\n+    // TODO: this breaks down completely if we have Support1 having a higher bonus than\n+    // Support2, because it will\n+    // come first. It should come first, unless we would have support wasted otherwise. This\n+    // ends up being a pretty\n+    // tricky math puzzle.\n+    final Set<UnitType> types1 = u1.getUnitType();\n+    final Set<UnitType> types2 = u2.getUnitType();\n+    final int s1 = types1 == null ? 0 : types1.size();\n+    final int s2 = types2 == null ? 0 : types2.size();\n+    compareTo = Integer.compare(s1, s2);\n+    if (compareTo != 0) {\n+      return compareTo;", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI5MQ==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238291", "bodyText": "Avoid too many return statements within this method.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to\n+    // less than zero.\n+    // We should actually apply enemy negative support in order from worst to least bad, on a\n+    // unit list that is\n+    // ordered from strongest to weakest.\n+    final boolean u1CanBonus = defense ? u1.getDefence() : u1.getOffence();\n+    final boolean u2CanBonus = defense ? u2.getDefence() : u2.getOffence();\n+    if (friendly) {\n+      // favor rolls over strength\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    } else {\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    }\n+\n+    // If the bonuses are the same, we want to make sure any support which only supports 1\n+    // single unit type goes\n+    // first because there could be Support1 which supports both infantry and mech infantry,\n+    // and Support2\n+    // which only supports mech infantry. If the Support1 goes first, and the mech infantry is\n+    // first in the unit list\n+    // (highly probable), then Support1 will end up using all of itself up on the mech\n+    // infantry then when the Support2\n+    // comes up, all the mech infantry are used up, and it does nothing. Instead, we want\n+    // Support2 to come first,\n+    // support all mech infantry that it can, then have Support1 come in and support whatever\n+    // is left, that way no\n+    // support is wasted.\n+    // TODO: this breaks down completely if we have Support1 having a higher bonus than\n+    // Support2, because it will\n+    // come first. It should come first, unless we would have support wasted otherwise. This\n+    // ends up being a pretty\n+    // tricky math puzzle.\n+    final Set<UnitType> types1 = u1.getUnitType();\n+    final Set<UnitType> types2 = u2.getUnitType();\n+    final int s1 = types1 == null ? 0 : types1.size();\n+    final int s2 = types2 == null ? 0 : types2.size();\n+    compareTo = Integer.compare(s1, s2);\n+    if (compareTo != 0) {\n+      return compareTo;\n+    }\n+\n+    // Now we need to sort so that the supporters who are the most powerful go before the less\n+    // powerful. This is not\n+    // necessary for the providing of support, but is necessary for our default casualty\n+    // selection method.\n+    final UnitType unitType1 = (UnitType) u1.getAttachedTo();\n+    final UnitType unitType2 = (UnitType) u2.getAttachedTo();\n+    final UnitAttachment ua1 = UnitAttachment.get(unitType1);\n+    final UnitAttachment ua2 = UnitAttachment.get(unitType2);\n+    final int unitPower1;\n+    final int unitPower2;\n+    if (u1.getDefence()) {\n+      unitPower1 =\n+          ua1.getDefenseRolls(GamePlayer.NULL_PLAYERID) * ua1.getDefense(GamePlayer.NULL_PLAYERID);\n+      unitPower2 =\n+          ua2.getDefenseRolls(GamePlayer.NULL_PLAYERID) * ua2.getDefense(GamePlayer.NULL_PLAYERID);\n+    } else {\n+      unitPower1 =\n+          ua1.getAttackRolls(GamePlayer.NULL_PLAYERID) * ua1.getAttack(GamePlayer.NULL_PLAYERID);\n+      unitPower2 =\n+          ua2.getAttackRolls(GamePlayer.NULL_PLAYERID) * ua2.getAttack(GamePlayer.NULL_PLAYERID);\n+    }\n+\n+    return Integer.compare(unitPower2, unitPower1);", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI5Mw==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238293", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to\n+    // less than zero.\n+    // We should actually apply enemy negative support in order from worst to least bad, on a\n+    // unit list that is\n+    // ordered from strongest to weakest.\n+    final boolean u1CanBonus = defense ? u1.getDefence() : u1.getOffence();\n+    final boolean u2CanBonus = defense ? u2.getDefence() : u2.getOffence();\n+    if (friendly) {\n+      // favor rolls over strength\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    } else {", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI5NA==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238294", "bodyText": "Method compare has a Cognitive Complexity of 71 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI5NQ==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238295", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to\n+    // less than zero.\n+    // We should actually apply enemy negative support in order from worst to least bad, on a\n+    // unit list that is\n+    // ordered from strongest to weakest.\n+    final boolean u1CanBonus = defense ? u1.getDefence() : u1.getOffence();\n+    final boolean u2CanBonus = defense ? u2.getDefence() : u2.getOffence();\n+    if (friendly) {\n+      // favor rolls over strength\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    } else {\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    }\n+\n+    // If the bonuses are the same, we want to make sure any support which only supports 1\n+    // single unit type goes\n+    // first because there could be Support1 which supports both infantry and mech infantry,\n+    // and Support2\n+    // which only supports mech infantry. If the Support1 goes first, and the mech infantry is\n+    // first in the unit list\n+    // (highly probable), then Support1 will end up using all of itself up on the mech\n+    // infantry then when the Support2\n+    // comes up, all the mech infantry are used up, and it does nothing. Instead, we want\n+    // Support2 to come first,\n+    // support all mech infantry that it can, then have Support1 come in and support whatever\n+    // is left, that way no\n+    // support is wasted.\n+    // TODO: this breaks down completely if we have Support1 having a higher bonus than\n+    // Support2, because it will\n+    // come first. It should come first, unless we would have support wasted otherwise. This\n+    // ends up being a pretty\n+    // tricky math puzzle.\n+    final Set<UnitType> types1 = u1.getUnitType();\n+    final Set<UnitType> types2 = u2.getUnitType();\n+    final int s1 = types1 == null ? 0 : types1.size();\n+    final int s2 = types2 == null ? 0 : types2.size();\n+    compareTo = Integer.compare(s1, s2);\n+    if (compareTo != 0) {\n+      return compareTo;\n+    }\n+\n+    // Now we need to sort so that the supporters who are the most powerful go before the less\n+    // powerful. This is not\n+    // necessary for the providing of support, but is necessary for our default casualty\n+    // selection method.\n+    final UnitType unitType1 = (UnitType) u1.getAttachedTo();\n+    final UnitType unitType2 = (UnitType) u2.getAttachedTo();\n+    final UnitAttachment ua1 = UnitAttachment.get(unitType1);\n+    final UnitAttachment ua2 = UnitAttachment.get(unitType2);\n+    final int unitPower1;\n+    final int unitPower2;\n+    if (u1.getDefence()) {\n+      unitPower1 =\n+          ua1.getDefenseRolls(GamePlayer.NULL_PLAYERID) * ua1.getDefense(GamePlayer.NULL_PLAYERID);\n+      unitPower2 =\n+          ua2.getDefenseRolls(GamePlayer.NULL_PLAYERID) * ua2.getDefense(GamePlayer.NULL_PLAYERID);\n+    } else {", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI5Nw==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238297", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-07T04:53:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to\n+    // less than zero.\n+    // We should actually apply enemy negative support in order from worst to least bad, on a\n+    // unit list that is\n+    // ordered from strongest to weakest.\n+    final boolean u1CanBonus = defense ? u1.getDefence() : u1.getOffence();\n+    final boolean u2CanBonus = defense ? u2.getDefence() : u2.getOffence();\n+    if (friendly) {\n+      // favor rolls over strength\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    } else {\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    }\n+\n+    // If the bonuses are the same, we want to make sure any support which only supports 1\n+    // single unit type goes\n+    // first because there could be Support1 which supports both infantry and mech infantry,\n+    // and Support2\n+    // which only supports mech infantry. If the Support1 goes first, and the mech infantry is\n+    // first in the unit list\n+    // (highly probable), then Support1 will end up using all of itself up on the mech\n+    // infantry then when the Support2\n+    // comes up, all the mech infantry are used up, and it does nothing. Instead, we want\n+    // Support2 to come first,\n+    // support all mech infantry that it can, then have Support1 come in and support whatever\n+    // is left, that way no\n+    // support is wasted.\n+    // TODO: this breaks down completely if we have Support1 having a higher bonus than\n+    // Support2, because it will\n+    // come first. It should come first, unless we would have support wasted otherwise. This\n+    // ends up being a pretty\n+    // tricky math puzzle.\n+    final Set<UnitType> types1 = u1.getUnitType();\n+    final Set<UnitType> types2 = u2.getUnitType();\n+    final int s1 = types1 == null ? 0 : types1.size();\n+    final int s2 = types2 == null ? 0 : types2.size();\n+    compareTo = Integer.compare(s1, s2);\n+    if (compareTo != 0) {\n+      return compareTo;\n+    }\n+\n+    // Now we need to sort so that the supporters who are the most powerful go before the less\n+    // powerful. This is not\n+    // necessary for the providing of support, but is necessary for our default casualty\n+    // selection method.\n+    final UnitType unitType1 = (UnitType) u1.getAttachedTo();\n+    final UnitType unitType2 = (UnitType) u2.getAttachedTo();\n+    final UnitAttachment ua1 = UnitAttachment.get(unitType1);\n+    final UnitAttachment ua2 = UnitAttachment.get(unitType2);\n+    final int unitPower1;\n+    final int unitPower2;\n+    if (u1.getDefence()) {", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODI5OQ==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238299", "bodyText": "TODO found", "author": "codeclimate", "createdAt": "2020-05-07T04:53:34Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIzODMwMA==", "url": "https://github.com/triplea-game/triplea/pull/6423#discussion_r421238300", "bodyText": "TODO found", "author": "codeclimate", "createdAt": "2020-05-07T04:53:34Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/power/calculator/SupportRuleSort.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package games.strategy.triplea.delegate.power.calculator;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.attachments.UnitSupportAttachment;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import javax.annotation.Nonnull;\n+import lombok.Builder;\n+\n+@Builder\n+public class SupportRuleSort implements Comparator<UnitSupportAttachment> {\n+  @Nonnull private final Boolean defense;\n+  @Nonnull private final Boolean friendly;\n+  @Nonnull private final Predicate<UnitSupportAttachment> roll;\n+  @Nonnull private final Predicate<UnitSupportAttachment> strength;\n+\n+  @Override\n+  public int compare(final UnitSupportAttachment u1, final UnitSupportAttachment u2) {\n+    int compareTo;\n+\n+    // Make sure stronger supports are ordered first if friendly, and worst are ordered first\n+    // if enemy\n+    // TODO: it is possible that we will waste negative support if we reduce a units power to\n+    // less than zero.\n+    // We should actually apply enemy negative support in order from worst to least bad, on a\n+    // unit list that is\n+    // ordered from strongest to weakest.\n+    final boolean u1CanBonus = defense ? u1.getDefence() : u1.getOffence();\n+    final boolean u2CanBonus = defense ? u2.getDefence() : u2.getOffence();\n+    if (friendly) {\n+      // favor rolls over strength\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u2Bonus, u1Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    } else {\n+      if (roll.test(u1) || roll.test(u2)) {\n+        final int u1Bonus = roll.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = roll.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+      if (strength.test(u1) || strength.test(u2)) {\n+        final int u1Bonus = strength.test(u1) && u1CanBonus ? u1.getBonus() : 0;\n+        final int u2Bonus = strength.test(u2) && u2CanBonus ? u2.getBonus() : 0;\n+        compareTo = Integer.compare(u1Bonus, u2Bonus);\n+        if (compareTo != 0) {\n+          return compareTo;\n+        }\n+      }\n+    }\n+\n+    // If the bonuses are the same, we want to make sure any support which only supports 1\n+    // single unit type goes\n+    // first because there could be Support1 which supports both infantry and mech infantry,\n+    // and Support2\n+    // which only supports mech infantry. If the Support1 goes first, and the mech infantry is\n+    // first in the unit list\n+    // (highly probable), then Support1 will end up using all of itself up on the mech\n+    // infantry then when the Support2\n+    // comes up, all the mech infantry are used up, and it does nothing. Instead, we want\n+    // Support2 to come first,\n+    // support all mech infantry that it can, then have Support1 come in and support whatever\n+    // is left, that way no\n+    // support is wasted.\n+    // TODO: this breaks down completely if we have Support1 having a higher bonus than", "originalCommit": "5a6dee7b2af954bfd2128d84084a2c748d94284a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}