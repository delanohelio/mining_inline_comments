{"pr_number": 6351, "pr_title": "Partial revert of battle calc simplifications", "pr_createdAt": "2020-04-29T16:24:15Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6351", "timeline": [{"oid": "5ce49b03af01281daade32b11d680ab59e92e17c", "url": "https://github.com/triplea-game/triplea/commit/5ce49b03af01281daade32b11d680ab59e92e17c", "message": "Add back original code and adjust it to the new interface structure", "committedDate": "2020-04-29T16:20:17Z", "type": "commit"}, {"oid": "a4c014e985b893de3b526cac7f74537c6bea1dda", "url": "https://github.com/triplea-game/triplea/commit/a4c014e985b893de3b526cac7f74537c6bea1dda", "message": "Formatting", "committedDate": "2020-04-29T16:20:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0NzUxMg==", "url": "https://github.com/triplea-game/triplea/pull/6351#discussion_r417447512", "bodyText": "Method createWorkers has a Cognitive Complexity of 16 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-29T16:26:36Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -63,24 +70,156 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n             MAX_THREADS,\n             new ThreadFactoryBuilder()\n                 .setDaemon(true)\n-                .setNameFormat(threadNamePrefix + \" ConcurrentBattleCalculator Worker-%d\")\n+                .setNameFormat(threadNamePrefix + \" ConcurrentOddsCalculator Worker-%d\")\n                 .build());\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n   public void setGameData(final GameData data) {\n-    synchronized (mutex) {\n-      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+    // increment so that a new calc doesn't take place (since they all wait on this latch)\n+    latchSetData.increment();\n+    // cancel any current setting of data\n+    cancelCurrentOperation.decrementAndGet();\n+    // cancel any existing calcing (it won't stop immediately, just quicker)\n+    cancel();\n+    synchronized (mutexSetGameData) {\n+      try {\n+        // since setting data takes place on a different thread, this is our token. wait on it since\n+        latchWorkerThreadsCreation.await();\n+        // we could have exited the synchronized block already.\n+      } catch (final InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+      cancel();\n+      isDataSet = false;\n+      isCalcSet = false;\n+      if (data == null || isShutDown) {\n+        workers.clear();\n+        cancelCurrentOperation.incrementAndGet();\n+        // allow calcing and other stuff to go ahead\n+        latchSetData.countDown();\n+      } else {\n+        cancelCurrentOperation.incrementAndGet();\n+        // increment our token, so that we can set the data in a different thread and return from\n+        // this one\n+        latchWorkerThreadsCreation.increment();\n+        executor.execute(() -> createWorkers(data));\n+      }\n+    }\n+  }\n+\n+  // use both time and memory left to determine how many copies to make\n+  private static int getThreadsToUse(\n+      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n+    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n+      // just use 1 thread if we took more than 20 seconds to copy\n+      return 1;\n+    }\n+    final Runtime runtime = Runtime.getRuntime();\n+    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n+    // we cannot predict how the gc works\n+    final long memoryLeftBeforeMax =\n+        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n+    // make sure it is a decent size\n+    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n+    // regardless of how stupid the gc is we leave some memory left over just in case\n+    final int numberOfTimesWeCanCopyMax =\n+        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n+\n+    if (timeToCopyInMillis > 3000) {\n+      // use half the number of threads available if we took more than 3 seconds to copy\n+      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n+    }\n+    // use all threads\n+    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n+  }\n+\n+  private void createWorkers(final GameData data) {", "originalCommit": "a4c014e985b893de3b526cac7f74537c6bea1dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ0NzUxNQ==", "url": "https://github.com/triplea-game/triplea/pull/6351#discussion_r417447515", "bodyText": "Method createWorkers has 48 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-29T16:26:36Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -63,24 +70,156 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n             MAX_THREADS,\n             new ThreadFactoryBuilder()\n                 .setDaemon(true)\n-                .setNameFormat(threadNamePrefix + \" ConcurrentBattleCalculator Worker-%d\")\n+                .setNameFormat(threadNamePrefix + \" ConcurrentOddsCalculator Worker-%d\")\n                 .build());\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n   public void setGameData(final GameData data) {\n-    synchronized (mutex) {\n-      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+    // increment so that a new calc doesn't take place (since they all wait on this latch)\n+    latchSetData.increment();\n+    // cancel any current setting of data\n+    cancelCurrentOperation.decrementAndGet();\n+    // cancel any existing calcing (it won't stop immediately, just quicker)\n+    cancel();\n+    synchronized (mutexSetGameData) {\n+      try {\n+        // since setting data takes place on a different thread, this is our token. wait on it since\n+        latchWorkerThreadsCreation.await();\n+        // we could have exited the synchronized block already.\n+      } catch (final InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+      cancel();\n+      isDataSet = false;\n+      isCalcSet = false;\n+      if (data == null || isShutDown) {\n+        workers.clear();\n+        cancelCurrentOperation.incrementAndGet();\n+        // allow calcing and other stuff to go ahead\n+        latchSetData.countDown();\n+      } else {\n+        cancelCurrentOperation.incrementAndGet();\n+        // increment our token, so that we can set the data in a different thread and return from\n+        // this one\n+        latchWorkerThreadsCreation.increment();\n+        executor.execute(() -> createWorkers(data));\n+      }\n+    }\n+  }\n+\n+  // use both time and memory left to determine how many copies to make\n+  private static int getThreadsToUse(\n+      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n+    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n+      // just use 1 thread if we took more than 20 seconds to copy\n+      return 1;\n+    }\n+    final Runtime runtime = Runtime.getRuntime();\n+    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n+    // we cannot predict how the gc works\n+    final long memoryLeftBeforeMax =\n+        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n+    // make sure it is a decent size\n+    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n+    // regardless of how stupid the gc is we leave some memory left over just in case\n+    final int numberOfTimesWeCanCopyMax =\n+        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n+\n+    if (timeToCopyInMillis > 3000) {\n+      // use half the number of threads available if we took more than 3 seconds to copy\n+      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n+    }\n+    // use all threads\n+    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n+  }\n+\n+  private void createWorkers(final GameData data) {", "originalCommit": "a4c014e985b893de3b526cac7f74537c6bea1dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fc54307c41e0c6e520a4885ec2c23f4791736eb", "url": "https://github.com/triplea-game/triplea/commit/7fc54307c41e0c6e520a4885ec2c23f4791736eb", "message": "Fix compile error", "committedDate": "2020-04-29T16:27:09Z", "type": "commit"}, {"oid": "43fff2f28781cbb052e8b9933097c1bb4d78a2c7", "url": "https://github.com/triplea-game/triplea/commit/43fff2f28781cbb052e8b9933097c1bb4d78a2c7", "message": "Inline field", "committedDate": "2020-04-29T16:27:49Z", "type": "commit"}, {"oid": "15b29284a042b6f89cf6f5e08f2b9e3cca763d91", "url": "https://github.com/triplea-game/triplea/commit/15b29284a042b6f89cf6f5e08f2b9e3cca763d91", "message": "Formatting", "committedDate": "2020-04-29T16:28:11Z", "type": "commit"}, {"oid": "98b1e911a76f43bee6dd4efb8bc7cba1e6fe0890", "url": "https://github.com/triplea-game/triplea/commit/98b1e911a76f43bee6dd4efb8bc7cba1e6fe0890", "message": "Rename Threads", "committedDate": "2020-04-29T16:28:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MDEzOA==", "url": "https://github.com/triplea-game/triplea/pull/6351#discussion_r417450138", "bodyText": "Method createWorkers has 49 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-29T16:30:38Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -69,18 +75,151 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n   }\n \n   public void setGameData(final GameData data) {\n-    synchronized (mutex) {\n-      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+    // increment so that a new calc doesn't take place (since they all wait on this latch)\n+    latchSetData.increment();\n+    // cancel any current setting of data\n+    cancelCurrentOperation.decrementAndGet();\n+    // cancel any existing calcing (it won't stop immediately, just quicker)\n+    cancel();\n+    synchronized (mutexSetGameData) {\n+      try {\n+        // since setting data takes place on a different thread, this is our token. wait on it since\n+        latchWorkerThreadsCreation.await();\n+        // we could have exited the synchronized block already.\n+      } catch (final InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+      cancel();\n+      isDataSet = false;\n+      isCalcSet = false;\n+      if (data == null || isShutDown) {\n+        workers.clear();\n+        cancelCurrentOperation.incrementAndGet();\n+        // allow calcing and other stuff to go ahead\n+        latchSetData.countDown();\n+      } else {\n+        cancelCurrentOperation.incrementAndGet();\n+        // increment our token, so that we can set the data in a different thread and return from\n+        // this one\n+        latchWorkerThreadsCreation.increment();\n+        executor.execute(() -> createWorkers(data));\n+      }\n+    }\n+  }\n+\n+  // use both time and memory left to determine how many copies to make\n+  private static int getThreadsToUse(\n+      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n+    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n+      // just use 1 thread if we took more than 20 seconds to copy\n+      return 1;\n+    }\n+    final Runtime runtime = Runtime.getRuntime();\n+    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n+    // we cannot predict how the gc works\n+    final long memoryLeftBeforeMax =\n+        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n+    // make sure it is a decent size\n+    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n+    // regardless of how stupid the gc is we leave some memory left over just in case\n+    final int numberOfTimesWeCanCopyMax =\n+        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n+\n+    if (timeToCopyInMillis > 3000) {\n+      // use half the number of threads available if we took more than 3 seconds to copy\n+      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n+    }\n+    // use all threads\n+    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n+  }\n+\n+  private void createWorkers(final GameData data) {", "originalCommit": "98b1e911a76f43bee6dd4efb8bc7cba1e6fe0890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ1MDc2Ng==", "url": "https://github.com/triplea-game/triplea/pull/6351#discussion_r417450766", "bodyText": "This code here changed slightly from the original implementation, basically we compute all of the run counts here now.\nBasically it does the same as my IntStream implementation to the left with some added exit conditions", "author": "RoiEXLab", "createdAt": "2020-04-29T16:31:32Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -95,21 +234,34 @@ public AggregateResults calculate(\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n       final boolean retreatWhenOnlyAirLeft,\n-      final int runCount)\n+      final int initialRunCount)\n       throws IllegalStateException {\n-    Preconditions.checkState(!isShutDown, \"ConcurrentBattleCalculator is already shut down\");\n-    Preconditions.checkState(bytes.length != 0, \"Data has not been set yet.\");\n-    final long start = System.currentTimeMillis();\n-    final int runsPerWorker = runCount / MAX_THREADS;\n-    final List<Future<AggregateResults>> results;\n-    synchronized (mutex) {\n-      results =\n-          IntStream.range(0, MAX_THREADS)\n-              .map(index -> index == 0 ? runCount % MAX_THREADS : 0)\n-              .map(runs -> runs + runsPerWorker)\n-              .mapToObj(\n-                  individualRemaining ->\n-                      createBattleCalcWorker(\n+    synchronized (mutexCalcIsRunning) {\n+      awaitLatch();\n+      final long start = System.currentTimeMillis();\n+      // Create worker thread pool and start all workers\n+      int totalRunCount = 0;\n+      int runCount = initialRunCount;\n+      final int workerNum = workers.size();\n+      final int workerRunCount = Math.max(1, (runCount / Math.max(1, workerNum)));", "originalCommit": "a4c014e985b893de3b526cac7f74537c6bea1dda", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "38ba69069d697883e205bb81a7ff10e888c62c8d", "url": "https://github.com/triplea-game/triplea/commit/38ba69069d697883e205bb81a7ff10e888c62c8d", "message": "Add default constructor", "committedDate": "2020-04-29T16:37:19Z", "type": "commit"}, {"oid": "85d71e6843ef239bb18f596525c96607c28a0bd5", "url": "https://github.com/triplea-game/triplea/commit/85d71e6843ef239bb18f596525c96607c28a0bd5", "message": "Remove redundant setter and use constructor", "committedDate": "2020-04-29T16:40:19Z", "type": "commit"}, {"oid": "72332a22feed8435d76b6fe1834f5816a512a83f", "url": "https://github.com/triplea-game/triplea/commit/72332a22feed8435d76b6fe1834f5816a512a83f", "message": "Remove redundant isSet field", "committedDate": "2020-04-29T16:42:49Z", "type": "commit"}, {"oid": "7da47b693504a99a0e292129bcd5e492b8c6de59", "url": "https://github.com/triplea-game/triplea/commit/7da47b693504a99a0e292129bcd5e492b8c6de59", "message": "Introduce pre-condition", "committedDate": "2020-04-29T16:46:18Z", "type": "commit"}, {"oid": "d82c4b3034ad37097e2946438e54f8cbe3603742", "url": "https://github.com/triplea-game/triplea/commit/d82c4b3034ad37097e2946438e54f8cbe3603742", "message": "Remove isCalcSet field", "committedDate": "2020-04-29T23:20:51Z", "type": "commit"}, {"oid": "9ea325ba9eccbad31c290c4f547ca61cefa4db9c", "url": "https://github.com/triplea-game/triplea/commit/9ea325ba9eccbad31c290c4f547ca61cefa4db9c", "message": "Remove redundant worker check", "committedDate": "2020-04-29T23:29:06Z", "type": "commit"}, {"oid": "330947d022bd50e5c87a4601ada0d1c419d25f19", "url": "https://github.com/triplea-game/triplea/commit/330947d022bd50e5c87a4601ada0d1c419d25f19", "message": "Remove now redundant field from BattleCalculator", "committedDate": "2020-04-29T23:32:44Z", "type": "commit"}]}