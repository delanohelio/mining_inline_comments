{"pr_number": 6054, "pr_title": "Avoid tile mutex", "pr_createdAt": "2020-03-16T01:21:33Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6054", "timeline": [{"oid": "752e37fdd25588ef0f24fcab386fc1be6293a584", "url": "https://github.com/triplea-game/triplea/commit/752e37fdd25588ef0f24fcab386fc1be6293a584", "message": "Avoid external mutex", "committedDate": "2020-03-16T01:17:07Z", "type": "commit"}, {"oid": "e739b350a81cd8224a254564b489da7da9ca54b1", "url": "https://github.com/triplea-game/triplea/commit/e739b350a81cd8224a254564b489da7da9ca54b1", "message": "Simplify substraction", "committedDate": "2020-03-16T01:17:14Z", "type": "commit"}, {"oid": "45b0ffb7bce0d8e956587ff108c3da0a1db5f4b6", "url": "https://github.com/triplea-game/triplea/commit/45b0ffb7bce0d8e956587ff108c3da0a1db5f4b6", "message": "Move TILE_SIZE constant to Tile class", "committedDate": "2020-03-16T01:17:20Z", "type": "commit"}, {"oid": "c614cfa5ce6c8fa232b1dedee6ab7f8a2d3608ff", "url": "https://github.com/triplea-game/triplea/commit/c614cfa5ce6c8fa232b1dedee6ab7f8a2d3608ff", "message": "Don't keep unecessary copies of Images around", "committedDate": "2020-03-16T01:17:26Z", "type": "commit"}, {"oid": "47afdedce4d48f9143b8d92075150ff83315712e", "url": "https://github.com/triplea-game/triplea/commit/47afdedce4d48f9143b8d92075150ff83315712e", "message": "Auto-Formatting", "committedDate": "2020-03-16T01:17:32Z", "type": "commit"}, {"oid": "bb1b31c884d9877eba6c0a0095b06f376419abce", "url": "https://github.com/triplea-game/triplea/commit/bb1b31c884d9877eba6c0a0095b06f376419abce", "message": "Fix potential race condition", "committedDate": "2020-03-16T01:17:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjczOTk3Nw==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r392739977", "bodyText": "I just noticed \"hardcoding\" the bounds to TILE_SIZE is no longer neccessary in the final form of this PR \ud83e\udd14", "author": "RoiEXLab", "createdAt": "2020-03-16T01:23:11Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -15,80 +15,66 @@\n import java.util.List;\n import java.util.PriorityQueue;\n import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /** Responsible for rendering a single map tile. */\n public class Tile {\n+  public static final int TILE_SIZE = 256;\n+\n   private volatile boolean isDirty = true;\n-  private volatile boolean isDrawing = false;\n+  private AtomicBoolean isDrawing = new AtomicBoolean(false);\n \n-  private final Image image;\n+  private Image image = Util.newImage(TILE_SIZE, TILE_SIZE, true);\n   private final Rectangle bounds;\n   private final Object mutex = new Object();\n   private final Queue<IDrawable> contents = new PriorityQueue<>();\n \n   Tile(final Rectangle bounds) {\n     this.bounds = bounds;\n-    image = Util.newImage((int) bounds.getWidth(), (int) bounds.getHeight(), true);", "originalCommit": "bb1b31c884d9877eba6c0a0095b06f376419abce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc0MTc2MA==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r392741760", "bodyText": "As you can see the only thing that \"mutex\" does now is synchronize the access to contents and isDirty as a single operation.\nNot sure if it would work without any unintended problems if we made contents a concurrent collection of some sort and removed the mutex. Currently calling new PriorityQueue<>(contents) is a constant time operation, changing the type of contents would make it O(n * log n).\nWe could however use a concurrent set where the draw level is compared, and if even we compare the hashCodes or something in order not to \"remove\" \"duplicate\" tiles with the same draw level as others.", "author": "RoiEXLab", "createdAt": "2020-03-16T01:28:35Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -15,80 +15,66 @@\n import java.util.List;\n import java.util.PriorityQueue;\n import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /** Responsible for rendering a single map tile. */\n public class Tile {\n+  public static final int TILE_SIZE = 256;\n+\n   private volatile boolean isDirty = true;\n-  private volatile boolean isDrawing = false;\n+  private AtomicBoolean isDrawing = new AtomicBoolean(false);\n \n-  private final Image image;\n+  private Image image = Util.newImage(TILE_SIZE, TILE_SIZE, true);\n   private final Rectangle bounds;\n   private final Object mutex = new Object();\n   private final Queue<IDrawable> contents = new PriorityQueue<>();\n \n   Tile(final Rectangle bounds) {\n     this.bounds = bounds;\n-    image = Util.newImage((int) bounds.getWidth(), (int) bounds.getHeight(), true);\n   }\n \n   public boolean needsRedraw() {\n-    return isDirty && !isDrawing;\n-  }\n-\n-  /**\n-   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level\n-   * (the swing components support it internally, but we don't draw in batch) we expose this\n-   * internal mutex to prevent tiles being drawn mid-refresh.\n-   */\n-  public Object getMutex() {\n-    return mutex;\n+    return isDirty && !isDrawing.get();\n   }\n \n   /** Returns the image representing this tile, re-rendering it first if the tile is dirty. */\n-  public Image getImage(final GameData data, final MapData mapData) {\n-    if (isDirty) {\n-      synchronized (mutex) {\n-        isDrawing = true;\n-        final Graphics2D g = (Graphics2D) image.getGraphics();\n-        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n-        g.setRenderingHint(\n-            RenderingHints.KEY_ALPHA_INTERPOLATION,\n-            RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\n-        g.setRenderingHint(\n-            RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n-        g.setRenderingHint(\n-            RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n-        draw(g, data, mapData);\n-        g.dispose();\n-        isDrawing = false;\n-      }\n+  public void drawImage(final GameData data, final MapData mapData) {\n+    if (isDirty && !isDrawing.getAndSet(true)) {\n+      final Image backImage = Util.newImage(TILE_SIZE, TILE_SIZE, true);\n+      final Graphics2D g = (Graphics2D) backImage.getGraphics();\n+      g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n+      g.setRenderingHint(\n+          RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\n+      g.setRenderingHint(\n+          RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n+      g.setRenderingHint(\n+          RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+      draw(g, data, mapData);\n+      g.dispose();\n+      image = backImage;\n+      isDrawing.set(false);\n     }\n-    return image;\n   }\n \n-  /**\n-   * This image may not reflect our current drawables. Use getImage() to get a correct image\n-   *\n-   * @return the image we currently have.\n-   */\n-  public Image getRawImage() {\n-    synchronized (mutex) {\n-      return image;\n-    }\n+  /** This image may not reflect our current drawables. */\n+  public Image getImage() {\n+    return image;\n   }\n \n   private void draw(final Graphics2D g, final GameData data, final MapData mapData) {\n     final AffineTransform original = g.getTransform();\n     // clear\n     g.setColor(Color.BLACK);\n-    g.fill(new Rectangle(0, 0, TileManager.TILE_SIZE, TileManager.TILE_SIZE));\n-    final Queue<IDrawable> queue = new PriorityQueue<>(contents);\n-    while (!queue.isEmpty()) {\n-      queue.remove().draw(bounds, data, g, mapData);\n-      // Make sure we don't mess up other draws\n-      g.setTransform(original);\n+    g.fill(new Rectangle(0, 0, TILE_SIZE, TILE_SIZE));\n+    synchronized (mutex) {\n+      final Queue<IDrawable> queue = new PriorityQueue<>(contents);", "originalCommit": "bb1b31c884d9877eba6c0a0095b06f376419abce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a10e2988dea87b55c948e2300ba834aaecf1b17", "url": "https://github.com/triplea-game/triplea/commit/1a10e2988dea87b55c948e2300ba834aaecf1b17", "message": "Remove unused parameter", "committedDate": "2020-03-16T01:43:15Z", "type": "commit"}, {"oid": "1a10e2988dea87b55c948e2300ba834aaecf1b17", "url": "https://github.com/triplea-game/triplea/commit/1a10e2988dea87b55c948e2300ba834aaecf1b17", "message": "Remove unused parameter", "committedDate": "2020-03-16T01:43:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3ODQzNQ==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r394078435", "bodyText": "Does it make sense to have drawImage to also return the rendered image?\nEG:\nfinal var image = tile.drawImage(gameData, uiContext.getMapData())", "author": "DanVanAtta", "createdAt": "2020-03-18T02:49:48Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/panels/map/MapPanel.java", "diffHunk": "@@ -631,16 +631,12 @@ public void drawMapImage(final Graphics g) {\n           new Rectangle2D.Double(0, 0, getImageWidth(), getImageHeight());\n       final Collection<Tile> tileList = tileManager.getTiles(bounds);\n       for (final Tile tile : tileList) {\n-        synchronized (tile.getMutex()) {\n-          final Image img = tile.getImage(gameData, uiContext.getMapData());\n-          if (img != null) {\n-            g2d.drawImage(\n-                img,\n-                AffineTransform.getTranslateInstance(\n-                    tile.getBounds().x - bounds.getX(), tile.getBounds().y - bounds.getY()),\n-                this);\n-          }\n-        }\n+        tile.drawImage(gameData, uiContext.getMapData());\n+        final Image img = tile.getImage();", "originalCommit": "1a10e2988dea87b55c948e2300ba834aaecf1b17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxMDE1Mg==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r395010152", "bodyText": "I thought about that, but by returning void it becomes obvious that this method is not just creating a new Image object, but rather altering the state of the Tile", "author": "RoiEXLab", "createdAt": "2020-03-19T13:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3ODQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3ODgwNg==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r394078806", "bodyText": "Kinda odd as GameData is quite mutable. I wonder if this would be more easily communicated if we extracted the logic that needs GameData to a method. Thoughts?", "author": "DanVanAtta", "createdAt": "2020-03-18T02:51:18Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/panels/map/MapPanel.java", "diffHunk": "@@ -746,13 +740,15 @@ public void paint(final Graphics g) {\n     updateUndrawnTiles(undrawnTiles, 513);\n     updateUndrawnTiles(undrawnTiles, 767);\n     clearPendingDrawOperations();\n+    // make sure we use the same data for the entire paint\n+    final GameData data = gameData;", "originalCommit": "1a10e2988dea87b55c948e2300ba834aaecf1b17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk3OTg3Mw==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r394979873", "bodyText": "IIRC the reason this variable was introduced is because we got NPEs on shutdown, when the gameData field was set to null mid-render.\nThis prevents this issue.", "author": "RoiEXLab", "createdAt": "2020-03-19T12:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3ODgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxNDg5MQ==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r395414891", "bodyText": "If we sent the gameData reference as a method parameter, there would be no way for anything outside of the method to mutate that reference (value). We would surely guard against that scenario. Given this is also a long method, breaking up the dependencies on gameData could be good as well.\nIMO that is a good option. If not, then we probably need more commentary/documentation to state we are defending against the gameData reference from not only being changed, but also potentially nulled out as part of a shutdown event.", "author": "DanVanAtta", "createdAt": "2020-03-20T02:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3ODgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3OTAzNQ==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r394079035", "bodyText": "Thoughts to replace this with @Getter and move and consolidate the comment to the image variable?", "author": "DanVanAtta", "createdAt": "2020-03-18T02:52:14Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -15,80 +15,66 @@\n import java.util.List;\n import java.util.PriorityQueue;\n import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n /** Responsible for rendering a single map tile. */\n public class Tile {\n+  public static final int TILE_SIZE = 256;\n+\n   private volatile boolean isDirty = true;\n-  private volatile boolean isDrawing = false;\n+  private AtomicBoolean isDrawing = new AtomicBoolean(false);\n \n-  private final Image image;\n+  private Image image = Util.newImage(TILE_SIZE, TILE_SIZE, true);\n   private final Rectangle bounds;\n   private final Object mutex = new Object();\n   private final Queue<IDrawable> contents = new PriorityQueue<>();\n \n   Tile(final Rectangle bounds) {\n     this.bounds = bounds;\n-    image = Util.newImage((int) bounds.getWidth(), (int) bounds.getHeight(), true);\n   }\n \n   public boolean needsRedraw() {\n-    return isDirty && !isDrawing;\n-  }\n-\n-  /**\n-   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level\n-   * (the swing components support it internally, but we don't draw in batch) we expose this\n-   * internal mutex to prevent tiles being drawn mid-refresh.\n-   */\n-  public Object getMutex() {\n-    return mutex;\n+    return isDirty && !isDrawing.get();\n   }\n \n   /** Returns the image representing this tile, re-rendering it first if the tile is dirty. */\n-  public Image getImage(final GameData data, final MapData mapData) {\n-    if (isDirty) {\n-      synchronized (mutex) {\n-        isDrawing = true;\n-        final Graphics2D g = (Graphics2D) image.getGraphics();\n-        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n-        g.setRenderingHint(\n-            RenderingHints.KEY_ALPHA_INTERPOLATION,\n-            RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\n-        g.setRenderingHint(\n-            RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n-        g.setRenderingHint(\n-            RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n-        draw(g, data, mapData);\n-        g.dispose();\n-        isDrawing = false;\n-      }\n+  public void drawImage(final GameData data, final MapData mapData) {\n+    if (isDirty && !isDrawing.getAndSet(true)) {\n+      final Image backImage = Util.newImage(TILE_SIZE, TILE_SIZE, true);\n+      final Graphics2D g = (Graphics2D) backImage.getGraphics();\n+      g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n+      g.setRenderingHint(\n+          RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\n+      g.setRenderingHint(\n+          RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n+      g.setRenderingHint(\n+          RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+      draw(g, data, mapData);\n+      g.dispose();\n+      image = backImage;\n+      isDrawing.set(false);\n     }\n-    return image;\n   }\n \n-  /**\n-   * This image may not reflect our current drawables. Use getImage() to get a correct image\n-   *\n-   * @return the image we currently have.\n-   */\n-  public Image getRawImage() {\n-    synchronized (mutex) {\n-      return image;\n-    }\n+  /** This image may not reflect our current drawables. */\n+  public Image getImage() {\n+    return image;", "originalCommit": "1a10e2988dea87b55c948e2300ba834aaecf1b17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk4MDAwOA==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r394980008", "bodyText": "I'm not even sure if this method needs a comment tbh", "author": "RoiEXLab", "createdAt": "2020-03-19T12:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3OTAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxNTA4Ng==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r395415086", "bodyText": "If the comment is dropped or not, still holds that we could avoid the boiler plate getter as well. Any thoughts?", "author": "DanVanAtta", "createdAt": "2020-03-20T02:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3OTAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQxNTI4Nw==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r395415287", "bodyText": "I see now that was done: 147182a", "author": "DanVanAtta", "createdAt": "2020-03-20T02:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3OTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3OTMyOA==", "url": "https://github.com/triplea-game/triplea/pull/6054#discussion_r394079328", "bodyText": "Minor, Tile.TILE_SIZE is a candidate for a static import, used quite a bit.", "author": "DanVanAtta", "createdAt": "2020-03-18T02:53:13Z", "path": "game-core/src/main/java/tools/image/TileImageBreaker.java", "diffHunk": "@@ -107,33 +107,29 @@ private void createMaps() throws IOException {\n     }\n \n     textOptionPane.show();\n-    for (int x = 0; x * TileManager.TILE_SIZE < map.getWidth(null); x++) {\n-      for (int y = 0; y * TileManager.TILE_SIZE < map.getHeight(null); y++) {\n+    for (int x = 0; x * Tile.TILE_SIZE < map.getWidth(null); x++) {\n+      for (int y = 0; y * Tile.TILE_SIZE < map.getHeight(null); y++) {\n         final Rectangle bounds =\n-            new Rectangle(\n-                x * TileManager.TILE_SIZE,\n-                y * TileManager.TILE_SIZE,\n-                TileManager.TILE_SIZE,\n-                TileManager.TILE_SIZE);\n+            new Rectangle(x * Tile.TILE_SIZE, y * Tile.TILE_SIZE, Tile.TILE_SIZE, Tile.TILE_SIZE);", "originalCommit": "1a10e2988dea87b55c948e2300ba834aaecf1b17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d0a294c72bf9f0f9f8e164f5d93a8d51461f30d", "url": "https://github.com/triplea-game/triplea/commit/5d0a294c72bf9f0f9f8e164f5d93a8d51461f30d", "message": "Statically import TILE_SIZE", "committedDate": "2020-03-19T13:11:40Z", "type": "commit"}, {"oid": "147182a50908b93429f4abee6b0c635b58a4f86f", "url": "https://github.com/triplea-game/triplea/commit/147182a50908b93429f4abee6b0c635b58a4f86f", "message": "Use lombok for the getter", "committedDate": "2020-03-19T13:11:59Z", "type": "commit"}, {"oid": "10d32f519d3cab9f595ec25875d437c772605b4e", "url": "https://github.com/triplea-game/triplea/commit/10d32f519d3cab9f595ec25875d437c772605b4e", "message": "Inline getter call", "committedDate": "2020-03-19T13:12:12Z", "type": "commit"}]}