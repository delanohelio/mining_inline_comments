{"pr_number": 6575, "pr_title": "Simplify: Combine if statements", "pr_createdAt": "2020-06-02T04:14:28Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6575", "timeline": [{"oid": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd", "url": "https://github.com/triplea-game/triplea/commit/60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd", "message": "Simplify: Combine if statements", "committedDate": "2020-06-02T04:12:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDYyOQ==", "url": "https://github.com/triplea-game/triplea/pull/6575#discussion_r433610629", "bodyText": "Avoid deeply nested control flow statements.", "author": "codeclimate", "createdAt": "2020-06-02T04:16:36Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleDelegate.java", "diffHunk": "@@ -1298,43 +1295,39 @@ private void doKamikazeSuicideAttacks() {\n         if (t.getUnits().stream().noneMatch(Matches.unitIsOwnedBy(player))) {\n           continue;\n         }\n-        if (onlyWhereThereAreBattlesOrAmphibious) {\n-          // if no battle or amphibious from here, ignore it\n-          if (!pendingBattles.contains(t)) {\n-            if (!Matches.territoryIsWater().test(t)) {\n-              continue;\n-            }\n-            boolean amphib = false;\n-            final Collection<Territory> landNeighbors =\n-                data.getMap().getNeighbors(t, Matches.territoryIsLand());\n-            for (final Territory neighbor : landNeighbors) {\n-              final IBattle battle =\n-                  battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n-              if (battle == null) {\n-                final Map<Territory, Collection<Unit>> whereFrom =\n-                    battleTracker.getFinishedBattlesUnitAttackFromMap().get(neighbor);\n-                if (whereFrom != null && whereFrom.containsKey(t)) {\n-                  amphib = true;\n-                  break;\n-                }\n-                continue;\n-              }\n-              if (battle.isAmphibious()\n-                  && ((battle instanceof MustFightBattle\n-                          && ((MustFightBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t))\n-                      || (battle instanceof NonFightingBattle\n-                          && ((NonFightingBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t)))) {\n+        // if no battle or amphibious from here, ignore it\n+        if (onlyWhereThereAreBattlesOrAmphibious && !pendingBattles.contains(t)) {\n+          if (!Matches.territoryIsWater().test(t)) {\n+            continue;\n+          }\n+          boolean amphib = false;\n+          final Collection<Territory> landNeighbors =\n+              data.getMap().getNeighbors(t, Matches.territoryIsLand());\n+          for (final Territory neighbor : landNeighbors) {\n+            final IBattle battle =\n+                battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n+            if (battle == null) {", "originalCommit": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDYzMA==", "url": "https://github.com/triplea-game/triplea/pull/6575#discussion_r433610630", "bodyText": "Avoid deeply nested control flow statements.", "author": "codeclimate", "createdAt": "2020-06-02T04:16:36Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleDelegate.java", "diffHunk": "@@ -1298,43 +1295,39 @@ private void doKamikazeSuicideAttacks() {\n         if (t.getUnits().stream().noneMatch(Matches.unitIsOwnedBy(player))) {\n           continue;\n         }\n-        if (onlyWhereThereAreBattlesOrAmphibious) {\n-          // if no battle or amphibious from here, ignore it\n-          if (!pendingBattles.contains(t)) {\n-            if (!Matches.territoryIsWater().test(t)) {\n-              continue;\n-            }\n-            boolean amphib = false;\n-            final Collection<Territory> landNeighbors =\n-                data.getMap().getNeighbors(t, Matches.territoryIsLand());\n-            for (final Territory neighbor : landNeighbors) {\n-              final IBattle battle =\n-                  battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n-              if (battle == null) {\n-                final Map<Territory, Collection<Unit>> whereFrom =\n-                    battleTracker.getFinishedBattlesUnitAttackFromMap().get(neighbor);\n-                if (whereFrom != null && whereFrom.containsKey(t)) {\n-                  amphib = true;\n-                  break;\n-                }\n-                continue;\n-              }\n-              if (battle.isAmphibious()\n-                  && ((battle instanceof MustFightBattle\n-                          && ((MustFightBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t))\n-                      || (battle instanceof NonFightingBattle\n-                          && ((NonFightingBattle) battle)\n-                              .getAmphibiousAttackTerritories()\n-                              .contains(t)))) {\n+        // if no battle or amphibious from here, ignore it\n+        if (onlyWhereThereAreBattlesOrAmphibious && !pendingBattles.contains(t)) {\n+          if (!Matches.territoryIsWater().test(t)) {\n+            continue;\n+          }\n+          boolean amphib = false;\n+          final Collection<Territory> landNeighbors =\n+              data.getMap().getNeighbors(t, Matches.territoryIsLand());\n+          for (final Territory neighbor : landNeighbors) {\n+            final IBattle battle =\n+                battleTracker.getPendingBattle(neighbor, false, BattleType.NORMAL);\n+            if (battle == null) {\n+              final Map<Territory, Collection<Unit>> whereFrom =\n+                  battleTracker.getFinishedBattlesUnitAttackFromMap().get(neighbor);\n+              if (whereFrom != null && whereFrom.containsKey(t)) {\n                 amphib = true;\n                 break;\n               }\n-            }\n-            if (!amphib) {\n               continue;\n             }\n+            if (battle.isAmphibious()", "originalCommit": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDYzMw==", "url": "https://github.com/triplea-game/triplea/pull/6575#discussion_r433610633", "bodyText": "Avoid deeply nested control flow statements.", "author": "codeclimate", "createdAt": "2020-06-02T04:16:36Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/ProCombatMoveAi.java", "diffHunk": "@@ -370,20 +370,18 @@ private void determineTerritoriesToAttack(final List<ProTerritory> prioritizedTe\n         }\n \n         // If already used all transports then remove any remaining amphib territories\n-        if (!haveRemovedAllAmphibTerritories) {\n-          if (territoryManager.haveUsedAllAttackTransports()) {\n-            final List<ProTerritory> amphibTerritoriesToRemove = new ArrayList<>();\n-            for (int i = numToAttack; i < prioritizedTerritories.size(); i++) {\n-              if (prioritizedTerritories.get(i).isNeedAmphibUnits()) {\n-                amphibTerritoriesToRemove.add(prioritizedTerritories.get(i));\n-                ProLogger.debug(\n-                    \"Removing amphib territory since already used all transports: \"\n-                        + prioritizedTerritories.get(i).getTerritory().getName());\n-              }\n+        if (!haveRemovedAllAmphibTerritories && territoryManager.haveUsedAllAttackTransports()) {\n+          final List<ProTerritory> amphibTerritoriesToRemove = new ArrayList<>();\n+          for (int i = numToAttack; i < prioritizedTerritories.size(); i++) {\n+            if (prioritizedTerritories.get(i).isNeedAmphibUnits()) {", "originalCommit": "60e2eeebab3cae1f93ccd5f33e6ddff7ace97afd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}