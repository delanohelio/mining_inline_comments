{"pr_number": 8309, "pr_title": "Add tests for AaCasualtySelector random and individually rolled", "pr_createdAt": "2020-11-28T23:25:02Z", "pr_url": "https://github.com/triplea-game/triplea/pull/8309", "timeline": [{"oid": "712e6b8080bf63868c47ef94e5bf8d94f050e6cf", "url": "https://github.com/triplea-game/triplea/commit/712e6b8080bf63868c47ef94e5bf8d94f050e6cf", "message": "Add tests for AaCasualtySelector random and individually rolled", "committedDate": "2020-11-28T23:58:16Z", "type": "forcePushed"}, {"oid": "312f8fdcf3f453e06de265670ff79491022e78c7", "url": "https://github.com/triplea-game/triplea/commit/312f8fdcf3f453e06de265670ff79491022e78c7", "message": "Add tests for AaCasualtySelector random and individually rolled", "committedDate": "2020-11-29T00:04:08Z", "type": "commit"}, {"oid": "312f8fdcf3f453e06de265670ff79491022e78c7", "url": "https://github.com/triplea-game/triplea/commit/312f8fdcf3f453e06de265670ff79491022e78c7", "message": "Add tests for AaCasualtySelector random and individually rolled", "committedDate": "2020-11-29T00:04:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNTc5OA==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532125798", "bodyText": "Why is 1 plane killed? The assertion here is not really checking that it's a plane that is killed either.\nI ask that question as that is the question a maintainer would have after reading \"1 plane is killed\". IMO it paraphrases the asserted state rather than describing why we expect to be in that state. Perhaps if we said something like \"Rolling a '0' on the random bridge is a hit\"\nThat could probably be made even more clear as well by assigning the dice rolls to variables, eg:\nint aaHit = 0;\nint aaMiss = 2\n\nwhenGetRandom(bridge).thenAnswer(withValues(aaHit, aaMiss, aaMiss));", "author": "DanVanAtta", "createdAt": "2020-11-29T01:00:06Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -0,0 +1,432 @@\n+package games.strategy.triplea.delegate.battle.casualty;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.whenGetRandom;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.withValues;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.description;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.power.calculator.CombatValue;\n+import games.strategy.triplea.delegate.power.calculator.CombatValueBuilder;\n+import java.util.List;\n+import java.util.UUID;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AaCasualtySelectorTest {\n+\n+  @Mock GamePlayer hitPlayer;\n+  @Mock GamePlayer aaPlayer;\n+  private UnitType aaUnitType;\n+  private UnitType damageableAaUnitType;\n+  private UnitType planeUnitType;\n+  private UnitType planeMultiHpUnitType;\n+  private GameData gameData;\n+\n+  private List<Unit> givenAaUnits(final int quantity) {\n+    return aaUnitType.create(quantity, aaPlayer, true);\n+  }\n+\n+  private List<Unit> givenDamageableAaUnits(final int quantity) {\n+    return damageableAaUnitType.create(quantity, aaPlayer, true);\n+  }\n+\n+  private List<Unit> givenPlaneUnits(final int quantity) {\n+    return planeUnitType.create(quantity, hitPlayer, true);\n+  }\n+\n+  private List<Unit> givenMultiHpPlaneUnits(final int quantity) {\n+    return planeMultiHpUnitType.create(quantity, hitPlayer, true);\n+  }\n+\n+  private DiceRoll givenDiceRoll(final boolean... shots) {\n+    final int[] diceRolls = new int[shots.length];\n+    int hits = 0;\n+    for (int i = 0; i < shots.length; i++) {\n+      diceRolls[i] = shots[i] ? 0 : 2;\n+      hits += (shots[i] ? 1 : 0);\n+    }\n+\n+    return new DiceRoll(diceRolls, hits, 1, false);\n+  }\n+\n+  private CombatValue givenAaCombatValue() {\n+    return CombatValueBuilder.aaCombatValue()\n+        .friendlyUnits(List.of())\n+        .enemyUnits(List.of())\n+        .side(BattleState.Side.DEFENSE)\n+        .supportAttachments(List.of())\n+        .build();\n+  }\n+\n+  @Nested\n+  class RandomCasualties {\n+    private IDelegateBridge bridge;\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(false)\n+              .withLowLuckAaOnly(false)\n+              .withRollAaIndividually(false)\n+              .withRandomAaCasualties(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment aaUnitAttachment =\n+          new UnitAttachment(\"aaUnitAttachment\", aaUnitType, gameData);\n+      aaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, aaUnitAttachment);\n+\n+      damageableAaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment damageableAaUnitAttachment =\n+          new UnitAttachment(\"damageableAaUnitAttachment\", aaUnitType, gameData);\n+      damageableAaUnitAttachment.setDamageableAa(true);\n+      damageableAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, damageableAaUnitAttachment);\n+\n+      planeUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeUnitAttachment =\n+          new UnitAttachment(\"planeUnitAttachment\", aaUnitType, gameData);\n+      planeUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeUnitAttachment);\n+\n+      planeMultiHpUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeMultiHpUnitAttachment =\n+          new UnitAttachment(\"planeMultiHpUnitAttachment\", aaUnitType, gameData);\n+      planeMultiHpUnitAttachment.setHitPoints(2);\n+      planeMultiHpUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeMultiHpUnitAttachment);\n+    }\n+\n+    @Test\n+    void noHitsReturnEmptyCasualties() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              List.of(mock(Unit.class)),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"No hits so no kills or damaged\", details.size(), is(0));\n+    }\n+\n+    @Test\n+    void hitsEqualToPlanesKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenPlaneUnits(1),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"One plane was hit and killed\", details.getKilled(), hasSize(1));\n+      assertThat(details.getDamaged(), is(empty()));\n+    }\n+\n+    @Test\n+    void hitsMoreThanPlanesKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenPlaneUnits(1),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"The plane was hit and killed\", details.getKilled(), hasSize(1));\n+      assertThat(\"Planes only have 1 hit point so no damages\", details.getDamaged(), is(empty()));\n+    }\n+\n+    @Test\n+    void oneHitAgainstTwoPlanesOnlyKillsOne() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(0));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenPlaneUnits(2),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"One of the two planes are killed\", details.getKilled(), hasSize(1));\n+      assertThat(details.getDamaged(), is(empty()));\n+      verify(bridge, description(\"2 planes with only 1 hit\"))\n+          .getRandom(eq(2), eq(1), any(), any(), anyString());\n+    }\n+\n+    @Test\n+    void identicalDieRollsShouldStillKillPlanesEqualToHits() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(9, 9, 9, 9, 9));\n+\n+      final List<Unit> planes = givenPlaneUnits(10);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              givenAaUnits(3),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true, true, true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\n+          \"5 planes are killed even though the dice were all 9s\", details.getKilled(), hasSize(5));\n+      assertThat(details.getDamaged(), is(empty()));\n+      verify(bridge, description(\"10 planes with only 5 hits\"))\n+          .getRandom(eq(10), eq(5), any(), any(), anyString());\n+    }\n+\n+    @Test\n+    void hitsEqualToPlanesMultiHpDamagesAndKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(1),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"Plane was killed\", details.getKilled(), hasSize(1));\n+      assertThat(\"Plane was also damaged\", details.getDamaged(), hasSize(1));\n+    }\n+\n+    @Test\n+    void hitsGreaterThanPlanesMultiHpDamagesAndKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(1),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true, true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"Plane was killed\", details.getKilled(), hasSize(1));\n+      assertThat(\"Plane was also damaged\", details.getDamaged(), hasSize(1));\n+    }\n+\n+    @Test\n+    void oneHitAgainstMultiHpPlaneOnlyDamagesIt() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(0));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(1),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"Plane is not killed\", details.getKilled(), is(empty()));\n+      assertThat(\"Plane is damaged\", details.getDamaged(), hasSize(1));\n+    }\n+\n+    @Test\n+    void threeHitsAgainstTwoMultiHpPlanesKillsOneAndDamagesTheOther() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(0, 1, 2));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(2),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"1 Plane is killed\", details.getKilled(), hasSize(1));", "originalCommit": "312f8fdcf3f453e06de265670ff79491022e78c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1MDQ2NQ==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532150465", "bodyText": "The method name explains why exactly one of the planes are hit.  But I can move that to this message as well.\nAs for the dice rolls, they aren't related to hits.  They are used to randomly select the units that get the hits.", "author": "trevan", "createdAt": "2020-11-29T03:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNTc5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1MzA5Nw==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532153097", "bodyText": "An assert message and the test method should not be redundant to each other. If so, then the assert message is not needed. Generally the method name is what you are testing, what aspect of a feature, the assert method message is why the condition is expected to be true. Often when there is one assert in a method the reasoning is clear. Again, the goal is to help other developers know why the test is supposed to pass (not to check a box or to pass a style guide, but if someone is developing, breaks this test, they need to know why the test was correct to begin with and why the assertions were expected to pass)", "author": "DanVanAtta", "createdAt": "2020-11-29T04:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNTkzNQ==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532125935", "bodyText": "This 'given' method is not easy to understand. A javadoc on the given method would help avoid having to reverse engineer the code. The name of the method probably ought to describe what kind of dice roll is being returned. EG: givenDiceRollsWithHitSequence, or something like that.", "author": "DanVanAtta", "createdAt": "2020-11-29T01:01:58Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -0,0 +1,432 @@\n+package games.strategy.triplea.delegate.battle.casualty;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.whenGetRandom;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.withValues;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.description;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.power.calculator.CombatValue;\n+import games.strategy.triplea.delegate.power.calculator.CombatValueBuilder;\n+import java.util.List;\n+import java.util.UUID;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AaCasualtySelectorTest {\n+\n+  @Mock GamePlayer hitPlayer;\n+  @Mock GamePlayer aaPlayer;\n+  private UnitType aaUnitType;\n+  private UnitType damageableAaUnitType;\n+  private UnitType planeUnitType;\n+  private UnitType planeMultiHpUnitType;\n+  private GameData gameData;\n+\n+  private List<Unit> givenAaUnits(final int quantity) {\n+    return aaUnitType.create(quantity, aaPlayer, true);\n+  }\n+\n+  private List<Unit> givenDamageableAaUnits(final int quantity) {\n+    return damageableAaUnitType.create(quantity, aaPlayer, true);\n+  }\n+\n+  private List<Unit> givenPlaneUnits(final int quantity) {\n+    return planeUnitType.create(quantity, hitPlayer, true);\n+  }\n+\n+  private List<Unit> givenMultiHpPlaneUnits(final int quantity) {\n+    return planeMultiHpUnitType.create(quantity, hitPlayer, true);\n+  }\n+\n+  private DiceRoll givenDiceRoll(final boolean... shots) {\n+    final int[] diceRolls = new int[shots.length];\n+    int hits = 0;\n+    for (int i = 0; i < shots.length; i++) {\n+      diceRolls[i] = shots[i] ? 0 : 2;\n+      hits += (shots[i] ? 1 : 0);\n+    }\n+\n+    return new DiceRoll(diceRolls, hits, 1, false);\n+  }\n+\n+  private CombatValue givenAaCombatValue() {\n+    return CombatValueBuilder.aaCombatValue()\n+        .friendlyUnits(List.of())\n+        .enemyUnits(List.of())\n+        .side(BattleState.Side.DEFENSE)\n+        .supportAttachments(List.of())\n+        .build();\n+  }\n+\n+  @Nested\n+  class RandomCasualties {\n+    private IDelegateBridge bridge;\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(false)\n+              .withLowLuckAaOnly(false)\n+              .withRollAaIndividually(false)\n+              .withRandomAaCasualties(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment aaUnitAttachment =\n+          new UnitAttachment(\"aaUnitAttachment\", aaUnitType, gameData);\n+      aaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, aaUnitAttachment);\n+\n+      damageableAaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment damageableAaUnitAttachment =\n+          new UnitAttachment(\"damageableAaUnitAttachment\", aaUnitType, gameData);\n+      damageableAaUnitAttachment.setDamageableAa(true);\n+      damageableAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, damageableAaUnitAttachment);\n+\n+      planeUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeUnitAttachment =\n+          new UnitAttachment(\"planeUnitAttachment\", aaUnitType, gameData);\n+      planeUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeUnitAttachment);\n+\n+      planeMultiHpUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeMultiHpUnitAttachment =\n+          new UnitAttachment(\"planeMultiHpUnitAttachment\", aaUnitType, gameData);\n+      planeMultiHpUnitAttachment.setHitPoints(2);\n+      planeMultiHpUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeMultiHpUnitAttachment);\n+    }\n+\n+    @Test\n+    void noHitsReturnEmptyCasualties() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              List.of(mock(Unit.class)),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"No hits so no kills or damaged\", details.size(), is(0));\n+    }\n+\n+    @Test\n+    void hitsEqualToPlanesKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenPlaneUnits(1),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"One plane was hit and killed\", details.getKilled(), hasSize(1));\n+      assertThat(details.getDamaged(), is(empty()));\n+    }\n+\n+    @Test\n+    void hitsMoreThanPlanesKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenPlaneUnits(1),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"The plane was hit and killed\", details.getKilled(), hasSize(1));\n+      assertThat(\"Planes only have 1 hit point so no damages\", details.getDamaged(), is(empty()));\n+    }\n+\n+    @Test\n+    void oneHitAgainstTwoPlanesOnlyKillsOne() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(0));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenPlaneUnits(2),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"One of the two planes are killed\", details.getKilled(), hasSize(1));\n+      assertThat(details.getDamaged(), is(empty()));\n+      verify(bridge, description(\"2 planes with only 1 hit\"))\n+          .getRandom(eq(2), eq(1), any(), any(), anyString());\n+    }\n+\n+    @Test\n+    void identicalDieRollsShouldStillKillPlanesEqualToHits() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(9, 9, 9, 9, 9));\n+\n+      final List<Unit> planes = givenPlaneUnits(10);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              givenAaUnits(3),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true, true, true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\n+          \"5 planes are killed even though the dice were all 9s\", details.getKilled(), hasSize(5));\n+      assertThat(details.getDamaged(), is(empty()));\n+      verify(bridge, description(\"10 planes with only 5 hits\"))\n+          .getRandom(eq(10), eq(5), any(), any(), anyString());\n+    }\n+\n+    @Test\n+    void hitsEqualToPlanesMultiHpDamagesAndKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(1),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"Plane was killed\", details.getKilled(), hasSize(1));\n+      assertThat(\"Plane was also damaged\", details.getDamaged(), hasSize(1));\n+    }\n+\n+    @Test\n+    void hitsGreaterThanPlanesMultiHpDamagesAndKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(1),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true, true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"Plane was killed\", details.getKilled(), hasSize(1));\n+      assertThat(\"Plane was also damaged\", details.getDamaged(), hasSize(1));\n+    }\n+\n+    @Test\n+    void oneHitAgainstMultiHpPlaneOnlyDamagesIt() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(0));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(1),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"Plane is not killed\", details.getKilled(), is(empty()));\n+      assertThat(\"Plane is damaged\", details.getDamaged(), hasSize(1));\n+    }\n+\n+    @Test\n+    void threeHitsAgainstTwoMultiHpPlanesKillsOneAndDamagesTheOther() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(0, 1, 2));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(2),\n+              givenDamageableAaUnits(1),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"1 Plane is killed\", details.getKilled(), hasSize(1));\n+      assertThat(\n+          \"The killed plane is also damaged and the other plane takes 1 damage\",\n+          details.getDamaged(),\n+          hasSize(2));\n+    }\n+\n+    @Test\n+    void identicalDieRollsShouldStillKillAndDamagePlanesEqualToHits() {\n+\n+      whenGetRandom(bridge).thenAnswer(withValues(6, 6, 6, 6, 6));\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenMultiHpPlaneUnits(7),\n+              givenDamageableAaUnits(3),\n+              mock(CombatValue.class),\n+              mock(CombatValue.class),\n+              \"text\",\n+              givenDiceRoll(true, true, true, true, true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"5 planes should be killed or damaged\", details.size(), is(5));\n+    }\n+  }\n+\n+  @Nested\n+  class IndividualRollCasualties {\n+    private IDelegateBridge bridge;\n+\n+    @BeforeEach\n+    void initializeGameData() {\n+      gameData =\n+          givenGameData()\n+              .withDiceSides(6)\n+              .withEditMode(false)\n+              .withChooseAaCasualties(false)\n+              .withLowLuck(false)\n+              .withLowLuckAaOnly(false)\n+              .withRollAaIndividually(true)\n+              .build();\n+      bridge = mock(IDelegateBridge.class);\n+      when(bridge.getData()).thenReturn(gameData);\n+\n+      aaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment aaUnitAttachment =\n+          new UnitAttachment(\"aaUnitAttachment\", aaUnitType, gameData);\n+      aaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, aaUnitAttachment);\n+\n+      damageableAaUnitType = new UnitType(\"aaUnitType\", gameData);\n+      final UnitAttachment damageableAaUnitAttachment =\n+          new UnitAttachment(\"damageableAaUnitAttachment\", aaUnitType, gameData);\n+      damageableAaUnitAttachment.setDamageableAa(true);\n+      damageableAaUnitType.addAttachment(UNIT_ATTACHMENT_NAME, damageableAaUnitAttachment);\n+\n+      planeUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeUnitAttachment =\n+          new UnitAttachment(\"planeUnitAttachment\", aaUnitType, gameData);\n+      planeUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeUnitAttachment);\n+\n+      planeMultiHpUnitType = new UnitType(\"planeUnitType\", gameData);\n+      final UnitAttachment planeMultiHpUnitAttachment =\n+          new UnitAttachment(\"planeMultiHpUnitAttachment\", aaUnitType, gameData);\n+      planeMultiHpUnitAttachment.setHitPoints(2);\n+      planeMultiHpUnitType.addAttachment(UNIT_ATTACHMENT_NAME, planeMultiHpUnitAttachment);\n+    }\n+\n+    @Test\n+    void hitsEqualToPlanesKillsAll() {\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              givenPlaneUnits(1),\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              givenDiceRoll(true),\n+              bridge,\n+              hitPlayer,\n+              UUID.randomUUID(),\n+              mock(Territory.class));\n+\n+      assertThat(\"One plane was hit and killed\", details.getKilled(), hasSize(1));\n+      assertThat(details.getDamaged(), is(empty()));\n+    }\n+\n+    @Test\n+    void hitsLessThanPlanesKillsAccordingToTheRolledDice() {\n+\n+      final List<Unit> planes = givenPlaneUnits(5);\n+\n+      final CasualtyDetails details =\n+          AaCasualtySelector.getAaCasualties(\n+              planes,\n+              givenAaUnits(1),\n+              mock(CombatValue.class),\n+              givenAaCombatValue(),\n+              \"text\",\n+              givenDiceRoll(true, false, true, false, true),", "originalCommit": "312f8fdcf3f453e06de265670ff79491022e78c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjAzOQ==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532126039", "bodyText": "Consider inlining this method, potentially needless indirection. The one liner is more self explanatory than the method name. Seeing givenPlaneUnits(10), it's not clear what the 10 is. The boolean parameter on the create API is needless and we should create an overload on the create method that has a default 'true' on it so the API can then make a lot of sense and be just \"create units, count, player\".", "author": "DanVanAtta", "createdAt": "2020-11-29T01:03:43Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/AaCasualtySelectorTest.java", "diffHunk": "@@ -0,0 +1,432 @@\n+package games.strategy.triplea.delegate.battle.casualty;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.whenGetRandom;\n+import static games.strategy.triplea.delegate.MockDelegateBridge.withValues;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.description;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.power.calculator.CombatValue;\n+import games.strategy.triplea.delegate.power.calculator.CombatValueBuilder;\n+import java.util.List;\n+import java.util.UUID;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AaCasualtySelectorTest {\n+\n+  @Mock GamePlayer hitPlayer;\n+  @Mock GamePlayer aaPlayer;\n+  private UnitType aaUnitType;\n+  private UnitType damageableAaUnitType;\n+  private UnitType planeUnitType;\n+  private UnitType planeMultiHpUnitType;\n+  private GameData gameData;\n+\n+  private List<Unit> givenAaUnits(final int quantity) {\n+    return aaUnitType.create(quantity, aaPlayer, true);\n+  }\n+\n+  private List<Unit> givenDamageableAaUnits(final int quantity) {\n+    return damageableAaUnitType.create(quantity, aaPlayer, true);\n+  }\n+\n+  private List<Unit> givenPlaneUnits(final int quantity) {", "originalCommit": "312f8fdcf3f453e06de265670ff79491022e78c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNzAwMQ==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532127001", "bodyText": "There is already an overloaded create method.  But it defaults to false.", "author": "trevan", "createdAt": "2020-11-29T01:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1Mjk3NQ==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532152975", "bodyText": "Then perhaps:\n  public List<Unit> createTemp(final int quantity, final GamePlayer owner) {\n    return create(quantity, owner);\n  }\n\nWith that it's clear you are creating a 'temp' unit. (What a temp unit is, is another question altogether, but at least the magic boolean is removed).", "author": "DanVanAtta", "createdAt": "2020-11-29T04:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1MzYyNQ==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532153625", "bodyText": "Let me do that in another PR.  There's a lot of places that use the temp = true and it would be nice to keep them all unified.", "author": "trevan", "createdAt": "2020-11-29T04:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjEyNjI0MA==", "url": "https://github.com/triplea-game/triplea/pull/8309#discussion_r532126240", "bodyText": "Side-note, I don't know if this pattern will scale well. Ideally we'd just use a real object here. To do that, extracting the game properties to it's own class and then passing that properties class around would perhaps be the thing to do. To that extent, we could have the battle logic take in that properties object and not a full game data as well for further benefits.\nThe reason I don't think this will scale is because eventually with more test coverage we'll have re-implemented the full game properties object and have a near duplicate dummy implementation.", "author": "DanVanAtta", "createdAt": "2020-11-29T01:06:17Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/MockGameData.java", "diffHunk": "@@ -155,4 +161,34 @@ public MockGameData withCaptureUnitsOnEnteringTerritory(final boolean value) {\n     when(gameProperties.get(CAPTURE_UNITS_ON_ENTERING_TERRITORY, false)).thenReturn(value);\n     return this;\n   }\n+\n+  public MockGameData withEditMode(final boolean value) {", "originalCommit": "312f8fdcf3f453e06de265670ff79491022e78c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dd1ffa375067e9b950a2d656fba8479aedfb6449", "url": "https://github.com/triplea-game/triplea/commit/dd1ffa375067e9b950a2d656fba8479aedfb6449", "message": "Improve test descriptions and names", "committedDate": "2020-11-29T03:58:39Z", "type": "commit"}]}