{"pr_number": 6293, "pr_title": "Merge TripleAUnit into Unit", "pr_createdAt": "2020-04-18T21:57:24Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6293", "timeline": [{"oid": "3fbf352c68453569fcb87e4cc3e2c1f739073252", "url": "https://github.com/triplea-game/triplea/commit/3fbf352c68453569fcb87e4cc3e2c1f739073252", "message": "Move stateful variables and methods from TripleAUnit into Unit", "committedDate": "2020-04-18T21:12:05Z", "type": "commit"}, {"oid": "48f3abcfd56cb5990b98af68439af9321d74df6b", "url": "https://github.com/triplea-game/triplea/commit/48f3abcfd56cb5990b98af68439af9321d74df6b", "message": "Inline usages of TripleAUnit with Unit or methods on Unit", "committedDate": "2020-04-18T21:12:05Z", "type": "commit"}, {"oid": "89181bcd29f017b600a8311dd1651ea605f57fe2", "url": "https://github.com/triplea-game/triplea/commit/89181bcd29f017b600a8311dd1651ea605f57fe2", "message": "Replace TripleAUnit usages with Unit", "committedDate": "2020-04-18T21:12:05Z", "type": "commit"}, {"oid": "9a488662a540b9400b7fc62c235bece30cffab4c", "url": "https://github.com/triplea-game/triplea/commit/9a488662a540b9400b7fc62c235bece30cffab4c", "message": "Move static method from TripleAUnit to class that uses it", "committedDate": "2020-04-18T21:12:05Z", "type": "commit"}, {"oid": "70c267ee5b4f0e985786885c910594a0a06614e9", "url": "https://github.com/triplea-game/triplea/commit/70c267ee5b4f0e985786885c910594a0a06614e9", "message": "Rename TripleAUnit -> UnitUtils", "committedDate": "2020-04-18T21:12:05Z", "type": "commit"}, {"oid": "e0e2b5bac75c472d80f0d26f8b746743fbe3ee57", "url": "https://github.com/triplea-game/triplea/commit/e0e2b5bac75c472d80f0d26f8b746743fbe3ee57", "message": "Update to use Unit directly instead of previous TripleaUnit#get method", "committedDate": "2020-04-18T21:12:26Z", "type": "commit"}, {"oid": "01b13675901b4bfe65ca930cc4454b2ecc403568", "url": "https://github.com/triplea-game/triplea/commit/01b13675901b4bfe65ca930cc4454b2ecc403568", "message": "Simplify: Use new Unit constructor directly", "committedDate": "2020-04-18T21:12:05Z", "type": "commit"}, {"oid": "0d10315914d013b5aa92fd382417ce84816ab933", "url": "https://github.com/triplea-game/triplea/commit/0d10315914d013b5aa92fd382417ce84816ab933", "message": "Update TripleAUnit to no longer extend Unit", "committedDate": "2020-04-18T21:12:30Z", "type": "commit"}, {"oid": "ac55c0e708fcf2eaee0a365c241633962553409d", "url": "https://github.com/triplea-game/triplea/commit/ac55c0e708fcf2eaee0a365c241633962553409d", "message": "Fix static method to use  local state", "committedDate": "2020-04-18T21:12:05Z", "type": "commit"}, {"oid": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "url": "https://github.com/triplea-game/triplea/commit/50827bc846a7fc385248929cd1c78635b3fcc8ff", "message": "Update test to remove TripleAUnit cast", "committedDate": "2020-04-18T21:16:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg0Mg==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756842", "bodyText": "Avoid too many return statements within this method.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:15Z", "path": "game-core/src/main/java/games/strategy/engine/data/Unit.java", "diffHunk": "@@ -61,6 +128,55 @@ public boolean isEquivalent(final Unit unit) {\n         && hits == unit.getHits();\n   }\n \n+  public int getHowMuchCanThisUnitBeRepaired(final Territory t) {\n+    return Math.max(\n+        0, (getHowMuchDamageCanThisUnitTakeTotal(t) - getHowMuchMoreDamageCanThisUnitTake(t)));\n+  }\n+\n+  /**\n+   * How much more damage can this unit take? Will return 0 if the unit cannot be damaged, or is at\n+   * max damage.\n+   */\n+  public int getHowMuchMoreDamageCanThisUnitTake(final Territory t) {\n+    if (!Matches.unitCanBeDamaged().test(this)) {\n+      return 0;\n+    }\n+    return Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(getData())\n+        ? Math.max(0, getHowMuchDamageCanThisUnitTakeTotal(t) - getUnitDamage())\n+        : Integer.MAX_VALUE;\n+  }\n+\n+  /**\n+   * How much damage is the max this unit can take, accounting for territory, etc. Will return -1 if\n+   * the unit is of the type that cannot be damaged\n+   */\n+  public int getHowMuchDamageCanThisUnitTakeTotal(final Territory t) {\n+    if (!Matches.unitCanBeDamaged().test(this)) {\n+      return -1;\n+    }\n+    final UnitAttachment ua = UnitAttachment.get(getType());\n+    final int territoryUnitProduction = TerritoryAttachment.getUnitProduction(t);\n+    if (Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(getData())) {\n+      if (ua.getMaxDamage() <= 0) {\n+        // factories may or may not have max damage set, so we must still determine here\n+        // assume that if maxDamage <= 0, then the max damage must be based on the territory value\n+        // can use \"production\" or \"unitProduction\"\n+        return territoryUnitProduction * 2;\n+      }\n+\n+      if (Matches.unitCanProduceUnits().test(this)) {\n+        // can use \"production\" or \"unitProduction\"\n+        return (ua.getCanProduceXUnits() < 0)\n+            ? territoryUnitProduction * ua.getMaxDamage()\n+            : ua.getMaxDamage();\n+      }\n+\n+      return ua.getMaxDamage();\n+    }\n+\n+    return Integer.MAX_VALUE;", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg0Mw==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756843", "bodyText": "Avoid deeply nested control flow statements.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:15Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/AirMovementValidator.java", "diffHunk": "@@ -795,10 +794,9 @@ public static int carrierCapacity(final Unit unit, final Territory territoryUnit\n                   .getUnitCollection()\n                   .getMatches(Matches.unitIsAir().and(Matches.unitCanLandOnCarrier()));\n           for (final Unit airUnit : airCargo) {\n-            final TripleAUnit taUnit = (TripleAUnit) airUnit;\n-            if (taUnit.getTransportedBy() != null && taUnit.getTransportedBy().equals(unit)) {\n+            if (airUnit.getTransportedBy() != null && airUnit.getTransportedBy().equals(unit)) {", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg0NA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756844", "bodyText": "Method getHowMuchCanUnitProduce has a Cognitive Complexity of 35 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:15Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    return getHowMuchCanUnitProduce(\n+        getBiggestProducer(unitsAtStartOfStepInTerritory, producer, player, data, accountForDamage),\n+        producer,\n+        player,\n+        data,\n+        accountForDamage,\n+        mathMaxZero);\n+  }\n+\n+  /**\n+   * Returns the unit from the specified collection that has the largest production capacity within\n+   * the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   */\n+  public static Unit getBiggestProducer(\n+      final Collection<Unit> units,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage) {\n+    final Predicate<Unit> factoryMatch =\n+        Matches.unitIsOwnedAndIsFactoryOrCanProduceUnits(player)\n+            .and(Matches.unitIsBeingTransported().negate())\n+            .and(producer.isWater() ? Matches.unitIsLand().negate() : Matches.unitIsSea().negate());\n+    final Collection<Unit> factories = CollectionUtils.getMatches(units, factoryMatch);\n+    if (factories.isEmpty()) {\n+      return null;\n+    }\n+    final IntegerMap<Unit> productionPotential = new IntegerMap<>();\n+    Unit highestUnit = factories.iterator().next();\n+    int highestCapacity = Integer.MIN_VALUE;\n+    for (final Unit u : factories) {\n+      final int capacity =\n+          getHowMuchCanUnitProduce(u, producer, player, data, accountForDamage, false);\n+      productionPotential.put(u, capacity);\n+      if (capacity > highestCapacity) {\n+        highestCapacity = capacity;\n+        highestUnit = u;\n+      }\n+    }\n+    return highestUnit;\n+  }\n+\n+  /**\n+   * Returns the production capacity for the specified unit within the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   * @param mathMaxZero {@code true} if a negative production capacity should be rounded to zero;\n+   *     {@code false} to allow a negative production capacity.\n+   */\n+  public static int getHowMuchCanUnitProduce(", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg0Ng==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756846", "bodyText": "Method getProductionPotentialOfTerritory has 6 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:16Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg0Nw==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756847", "bodyText": "Method getBiggestProducer has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:16Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    return getHowMuchCanUnitProduce(\n+        getBiggestProducer(unitsAtStartOfStepInTerritory, producer, player, data, accountForDamage),\n+        producer,\n+        player,\n+        data,\n+        accountForDamage,\n+        mathMaxZero);\n+  }\n+\n+  /**\n+   * Returns the unit from the specified collection that has the largest production capacity within\n+   * the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   */\n+  public static Unit getBiggestProducer(\n+      final Collection<Unit> units,", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg0OQ==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756849", "bodyText": "Method getHowMuchCanUnitProduce has 6 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:16Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    return getHowMuchCanUnitProduce(\n+        getBiggestProducer(unitsAtStartOfStepInTerritory, producer, player, data, accountForDamage),\n+        producer,\n+        player,\n+        data,\n+        accountForDamage,\n+        mathMaxZero);\n+  }\n+\n+  /**\n+   * Returns the unit from the specified collection that has the largest production capacity within\n+   * the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   */\n+  public static Unit getBiggestProducer(\n+      final Collection<Unit> units,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage) {\n+    final Predicate<Unit> factoryMatch =\n+        Matches.unitIsOwnedAndIsFactoryOrCanProduceUnits(player)\n+            .and(Matches.unitIsBeingTransported().negate())\n+            .and(producer.isWater() ? Matches.unitIsLand().negate() : Matches.unitIsSea().negate());\n+    final Collection<Unit> factories = CollectionUtils.getMatches(units, factoryMatch);\n+    if (factories.isEmpty()) {\n+      return null;\n+    }\n+    final IntegerMap<Unit> productionPotential = new IntegerMap<>();\n+    Unit highestUnit = factories.iterator().next();\n+    int highestCapacity = Integer.MIN_VALUE;\n+    for (final Unit u : factories) {\n+      final int capacity =\n+          getHowMuchCanUnitProduce(u, producer, player, data, accountForDamage, false);\n+      productionPotential.put(u, capacity);\n+      if (capacity > highestCapacity) {\n+        highestCapacity = capacity;\n+        highestUnit = u;\n+      }\n+    }\n+    return highestUnit;\n+  }\n+\n+  /**\n+   * Returns the production capacity for the specified unit within the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   * @param mathMaxZero {@code true} if a negative production capacity should be rounded to zero;\n+   *     {@code false} to allow a negative production capacity.\n+   */\n+  public static int getHowMuchCanUnitProduce(\n+      final Unit unit,", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg1Mg==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756852", "bodyText": "Method getHowMuchDamageCanThisUnitTakeTotal has a Cognitive Complexity of 9 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:16Z", "path": "game-core/src/main/java/games/strategy/engine/data/Unit.java", "diffHunk": "@@ -61,6 +128,55 @@ public boolean isEquivalent(final Unit unit) {\n         && hits == unit.getHits();\n   }\n \n+  public int getHowMuchCanThisUnitBeRepaired(final Territory t) {\n+    return Math.max(\n+        0, (getHowMuchDamageCanThisUnitTakeTotal(t) - getHowMuchMoreDamageCanThisUnitTake(t)));\n+  }\n+\n+  /**\n+   * How much more damage can this unit take? Will return 0 if the unit cannot be damaged, or is at\n+   * max damage.\n+   */\n+  public int getHowMuchMoreDamageCanThisUnitTake(final Territory t) {\n+    if (!Matches.unitCanBeDamaged().test(this)) {\n+      return 0;\n+    }\n+    return Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(getData())\n+        ? Math.max(0, getHowMuchDamageCanThisUnitTakeTotal(t) - getUnitDamage())\n+        : Integer.MAX_VALUE;\n+  }\n+\n+  /**\n+   * How much damage is the max this unit can take, accounting for territory, etc. Will return -1 if\n+   * the unit is of the type that cannot be damaged\n+   */\n+  public int getHowMuchDamageCanThisUnitTakeTotal(final Territory t) {", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg1NA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756854", "bodyText": "Method translateAttributesToOtherUnits has a Cognitive Complexity of 14 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:16Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    return getHowMuchCanUnitProduce(\n+        getBiggestProducer(unitsAtStartOfStepInTerritory, producer, player, data, accountForDamage),\n+        producer,\n+        player,\n+        data,\n+        accountForDamage,\n+        mathMaxZero);\n+  }\n+\n+  /**\n+   * Returns the unit from the specified collection that has the largest production capacity within\n+   * the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   */\n+  public static Unit getBiggestProducer(\n+      final Collection<Unit> units,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage) {\n+    final Predicate<Unit> factoryMatch =\n+        Matches.unitIsOwnedAndIsFactoryOrCanProduceUnits(player)\n+            .and(Matches.unitIsBeingTransported().negate())\n+            .and(producer.isWater() ? Matches.unitIsLand().negate() : Matches.unitIsSea().negate());\n+    final Collection<Unit> factories = CollectionUtils.getMatches(units, factoryMatch);\n+    if (factories.isEmpty()) {\n+      return null;\n+    }\n+    final IntegerMap<Unit> productionPotential = new IntegerMap<>();\n+    Unit highestUnit = factories.iterator().next();\n+    int highestCapacity = Integer.MIN_VALUE;\n+    for (final Unit u : factories) {\n+      final int capacity =\n+          getHowMuchCanUnitProduce(u, producer, player, data, accountForDamage, false);\n+      productionPotential.put(u, capacity);\n+      if (capacity > highestCapacity) {\n+        highestCapacity = capacity;\n+        highestUnit = u;\n+      }\n+    }\n+    return highestUnit;\n+  }\n+\n+  /**\n+   * Returns the production capacity for the specified unit within the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   * @param mathMaxZero {@code true} if a negative production capacity should be rounded to zero;\n+   *     {@code false} to allow a negative production capacity.\n+   */\n+  public static int getHowMuchCanUnitProduce(\n+      final Unit unit,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    if (unit == null) {\n+      return 0;\n+    }\n+    if (!Matches.unitCanProduceUnits().test(unit)) {\n+      return 0;\n+    }\n+    final UnitAttachment ua = UnitAttachment.get(unit.getType());\n+    final TerritoryAttachment ta = TerritoryAttachment.get(producer);\n+    int territoryProduction = 0;\n+    int territoryUnitProduction = 0;\n+    if (ta != null) {\n+      territoryProduction = ta.getProduction();\n+      territoryUnitProduction = ta.getUnitProduction();\n+    }\n+    int productionCapacity;\n+    if (accountForDamage) {\n+      if (Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        if (ua.getCanProduceXUnits() < 0) {\n+          // we could use territoryUnitProduction OR\n+          // territoryProduction if we wanted to, however we should\n+          // change damage to be based on whichever we choose.\n+          productionCapacity = territoryUnitProduction - unit.getUnitDamage();\n+        } else {\n+          productionCapacity = ua.getCanProduceXUnits() - unit.getUnitDamage();\n+        }\n+      } else {\n+        productionCapacity = territoryProduction;\n+        if (productionCapacity < 1) {\n+          productionCapacity = (Properties.getWW2V2(data) || Properties.getWW2V3(data)) ? 0 : 1;\n+        }\n+      }\n+    } else {\n+      if (ua.getCanProduceXUnits() < 0\n+          && !Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        productionCapacity = territoryProduction;\n+      } else if (ua.getCanProduceXUnits() < 0\n+          && Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        productionCapacity = territoryUnitProduction;\n+      } else {\n+        productionCapacity = ua.getCanProduceXUnits();\n+      }\n+      if (productionCapacity < 1\n+          && !Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        productionCapacity = (Properties.getWW2V2(data) || Properties.getWW2V3(data)) ? 0 : 1;\n+      }\n+    }\n+    // Increase production if have industrial technology\n+    if (territoryProduction\n+        >= TechAbilityAttachment.getMinimumTerritoryValueForProductionBonus(player, data)) {\n+      productionCapacity += TechAbilityAttachment.getProductionBonus(unit.getType(), player, data);\n+    }\n+    return mathMaxZero ? Math.max(0, productionCapacity) : productionCapacity;\n+  }\n+\n+  /**\n+   * Currently made for translating unit damage from one unit to another unit. Will adjust damage to\n+   * be within max damage for the new units.\n+   *\n+   * @return change for unit's properties\n+   */\n+  public static Change translateAttributesToOtherUnits(", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg1Ng==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756856", "bodyText": "Method getHowMuchCanUnitProduce has 48 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:16Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    return getHowMuchCanUnitProduce(\n+        getBiggestProducer(unitsAtStartOfStepInTerritory, producer, player, data, accountForDamage),\n+        producer,\n+        player,\n+        data,\n+        accountForDamage,\n+        mathMaxZero);\n+  }\n+\n+  /**\n+   * Returns the unit from the specified collection that has the largest production capacity within\n+   * the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   */\n+  public static Unit getBiggestProducer(\n+      final Collection<Unit> units,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage) {\n+    final Predicate<Unit> factoryMatch =\n+        Matches.unitIsOwnedAndIsFactoryOrCanProduceUnits(player)\n+            .and(Matches.unitIsBeingTransported().negate())\n+            .and(producer.isWater() ? Matches.unitIsLand().negate() : Matches.unitIsSea().negate());\n+    final Collection<Unit> factories = CollectionUtils.getMatches(units, factoryMatch);\n+    if (factories.isEmpty()) {\n+      return null;\n+    }\n+    final IntegerMap<Unit> productionPotential = new IntegerMap<>();\n+    Unit highestUnit = factories.iterator().next();\n+    int highestCapacity = Integer.MIN_VALUE;\n+    for (final Unit u : factories) {\n+      final int capacity =\n+          getHowMuchCanUnitProduce(u, producer, player, data, accountForDamage, false);\n+      productionPotential.put(u, capacity);\n+      if (capacity > highestCapacity) {\n+        highestCapacity = capacity;\n+        highestUnit = u;\n+      }\n+    }\n+    return highestUnit;\n+  }\n+\n+  /**\n+   * Returns the production capacity for the specified unit within the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   * @param mathMaxZero {@code true} if a negative production capacity should be rounded to zero;\n+   *     {@code false} to allow a negative production capacity.\n+   */\n+  public static int getHowMuchCanUnitProduce(", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg1OA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756858", "bodyText": "Method translateAttributesToOtherUnits has 32 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:17Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    return getHowMuchCanUnitProduce(\n+        getBiggestProducer(unitsAtStartOfStepInTerritory, producer, player, data, accountForDamage),\n+        producer,\n+        player,\n+        data,\n+        accountForDamage,\n+        mathMaxZero);\n+  }\n+\n+  /**\n+   * Returns the unit from the specified collection that has the largest production capacity within\n+   * the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   */\n+  public static Unit getBiggestProducer(\n+      final Collection<Unit> units,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage) {\n+    final Predicate<Unit> factoryMatch =\n+        Matches.unitIsOwnedAndIsFactoryOrCanProduceUnits(player)\n+            .and(Matches.unitIsBeingTransported().negate())\n+            .and(producer.isWater() ? Matches.unitIsLand().negate() : Matches.unitIsSea().negate());\n+    final Collection<Unit> factories = CollectionUtils.getMatches(units, factoryMatch);\n+    if (factories.isEmpty()) {\n+      return null;\n+    }\n+    final IntegerMap<Unit> productionPotential = new IntegerMap<>();\n+    Unit highestUnit = factories.iterator().next();\n+    int highestCapacity = Integer.MIN_VALUE;\n+    for (final Unit u : factories) {\n+      final int capacity =\n+          getHowMuchCanUnitProduce(u, producer, player, data, accountForDamage, false);\n+      productionPotential.put(u, capacity);\n+      if (capacity > highestCapacity) {\n+        highestCapacity = capacity;\n+        highestUnit = u;\n+      }\n+    }\n+    return highestUnit;\n+  }\n+\n+  /**\n+   * Returns the production capacity for the specified unit within the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   * @param mathMaxZero {@code true} if a negative production capacity should be rounded to zero;\n+   *     {@code false} to allow a negative production capacity.\n+   */\n+  public static int getHowMuchCanUnitProduce(\n+      final Unit unit,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    if (unit == null) {\n+      return 0;\n+    }\n+    if (!Matches.unitCanProduceUnits().test(unit)) {\n+      return 0;\n+    }\n+    final UnitAttachment ua = UnitAttachment.get(unit.getType());\n+    final TerritoryAttachment ta = TerritoryAttachment.get(producer);\n+    int territoryProduction = 0;\n+    int territoryUnitProduction = 0;\n+    if (ta != null) {\n+      territoryProduction = ta.getProduction();\n+      territoryUnitProduction = ta.getUnitProduction();\n+    }\n+    int productionCapacity;\n+    if (accountForDamage) {\n+      if (Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        if (ua.getCanProduceXUnits() < 0) {\n+          // we could use territoryUnitProduction OR\n+          // territoryProduction if we wanted to, however we should\n+          // change damage to be based on whichever we choose.\n+          productionCapacity = territoryUnitProduction - unit.getUnitDamage();\n+        } else {\n+          productionCapacity = ua.getCanProduceXUnits() - unit.getUnitDamage();\n+        }\n+      } else {\n+        productionCapacity = territoryProduction;\n+        if (productionCapacity < 1) {\n+          productionCapacity = (Properties.getWW2V2(data) || Properties.getWW2V3(data)) ? 0 : 1;\n+        }\n+      }\n+    } else {\n+      if (ua.getCanProduceXUnits() < 0\n+          && !Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        productionCapacity = territoryProduction;\n+      } else if (ua.getCanProduceXUnits() < 0\n+          && Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        productionCapacity = territoryUnitProduction;\n+      } else {\n+        productionCapacity = ua.getCanProduceXUnits();\n+      }\n+      if (productionCapacity < 1\n+          && !Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(data)) {\n+        productionCapacity = (Properties.getWW2V2(data) || Properties.getWW2V3(data)) ? 0 : 1;\n+      }\n+    }\n+    // Increase production if have industrial technology\n+    if (territoryProduction\n+        >= TechAbilityAttachment.getMinimumTerritoryValueForProductionBonus(player, data)) {\n+      productionCapacity += TechAbilityAttachment.getProductionBonus(unit.getType(), player, data);\n+    }\n+    return mathMaxZero ? Math.max(0, productionCapacity) : productionCapacity;\n+  }\n+\n+  /**\n+   * Currently made for translating unit damage from one unit to another unit. Will adjust damage to\n+   * be within max damage for the new units.\n+   *\n+   * @return change for unit's properties\n+   */\n+  public static Change translateAttributesToOtherUnits(", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg2MA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756860", "bodyText": "Method getTransporting has a Cognitive Complexity of 8 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:17Z", "path": "game-core/src/main/java/games/strategy/engine/data/Unit.java", "diffHunk": "@@ -107,6 +223,281 @@ private static void printError(final String errorMessage) {\n         .put(\"uid\", MutableProperty.ofReadOnlySimple(this::getId))\n         .put(\"hits\", MutableProperty.ofSimple(this::setHits, this::getHits))\n         .put(\"type\", MutableProperty.ofReadOnlySimple(this::getType))\n+        .put(\n+            \"transportedBy\",\n+            MutableProperty.ofSimple(this::setTransportedBy, this::getTransportedBy))\n+        .put(\"unloaded\", MutableProperty.ofSimple(this::setUnloaded, this::getUnloaded))\n+        .put(\n+            \"wasLoadedThisTurn\",\n+            MutableProperty.ofSimple(this::setWasLoadedThisTurn, this::getWasLoadedThisTurn))\n+        .put(\"unloadedTo\", MutableProperty.ofSimple(this::setUnloadedTo, this::getUnloadedTo))\n+        .put(\n+            \"wasUnloadedInCombatPhase\",\n+            MutableProperty.ofSimple(\n+                this::setWasUnloadedInCombatPhase, this::getWasUnloadedInCombatPhase))\n+        .put(\"alreadyMoved\", MutableProperty.ofSimple(this::setAlreadyMoved, this::getAlreadyMoved))\n+        .put(\n+            \"bonusMovement\",\n+            MutableProperty.ofSimple(this::setBonusMovement, this::getBonusMovement))\n+        .put(\"unitDamage\", MutableProperty.ofSimple(this::setUnitDamage, this::getUnitDamage))\n+        .put(\"submerged\", MutableProperty.ofSimple(this::setSubmerged, this::getSubmerged))\n+        .put(\n+            \"originalOwner\",\n+            MutableProperty.ofSimple(this::setOriginalOwner, this::getOriginalOwner))\n+        .put(\"wasInCombat\", MutableProperty.ofSimple(this::setWasInCombat, this::getWasInCombat))\n+        .put(\n+            \"wasLoadedAfterCombat\",\n+            MutableProperty.ofSimple(this::setWasLoadedAfterCombat, this::getWasLoadedAfterCombat))\n+        .put(\n+            \"wasAmphibious\",\n+            MutableProperty.ofSimple(this::setWasAmphibious, this::getWasAmphibious))\n+        .put(\n+            \"originatedFrom\",\n+            MutableProperty.ofSimple(this::setOriginatedFrom, this::getOriginatedFrom))\n+        .put(\"wasScrambled\", MutableProperty.ofSimple(this::setWasScrambled, this::getWasScrambled))\n+        .put(\n+            \"maxScrambleCount\",\n+            MutableProperty.ofSimple(this::setMaxScrambleCount, this::getMaxScrambleCount))\n+        .put(\n+            \"wasInAirBattle\",\n+            MutableProperty.ofSimple(this::setWasInAirBattle, this::getWasInAirBattle))\n+        .put(\"disabled\", MutableProperty.ofSimple(this::setDisabled, this::getDisabled))\n+        .put(\"launched\", MutableProperty.ofSimple(this::setLaunched, this::getLaunched))\n+        .put(\"airborne\", MutableProperty.ofSimple(this::setAirborne, this::getAirborne))\n+        .put(\n+            \"chargedFlatFuelCost\",\n+            MutableProperty.ofSimple(this::setChargedFlatFuelCost, this::getChargedFlatFuelCost))\n         .build();\n   }\n+\n+  public int getUnitDamage() {\n+    return unitDamage;\n+  }\n+\n+  public void setUnitDamage(final int unitDamage) {\n+    this.unitDamage = unitDamage;\n+  }\n+\n+  public boolean getSubmerged() {\n+    return submerged;\n+  }\n+\n+  public void setSubmerged(final boolean submerged) {\n+    this.submerged = submerged;\n+  }\n+\n+  public GamePlayer getOriginalOwner() {\n+    return originalOwner;\n+  }\n+\n+  private void setOriginalOwner(final GamePlayer originalOwner) {\n+    this.originalOwner = originalOwner;\n+  }\n+\n+  public boolean getWasInCombat() {\n+    return wasInCombat;\n+  }\n+\n+  private void setWasInCombat(final boolean value) {\n+    wasInCombat = value;\n+  }\n+\n+  public boolean getWasScrambled() {\n+    return wasScrambled;\n+  }\n+\n+  private void setWasScrambled(final boolean value) {\n+    wasScrambled = value;\n+  }\n+\n+  public int getMaxScrambleCount() {\n+    return maxScrambleCount;\n+  }\n+\n+  private void setMaxScrambleCount(final int value) {\n+    maxScrambleCount = value;\n+  }\n+\n+  public int getLaunched() {\n+    return launched;\n+  }\n+\n+  private void setLaunched(final int value) {\n+    launched = value;\n+  }\n+\n+  public boolean getAirborne() {\n+    return airborne;\n+  }\n+\n+  private void setAirborne(final boolean value) {\n+    airborne = value;\n+  }\n+\n+  public boolean getChargedFlatFuelCost() {\n+    return chargedFlatFuelCost;\n+  }\n+\n+  private void setChargedFlatFuelCost(final boolean value) {\n+    chargedFlatFuelCost = value;\n+  }\n+\n+  private void setWasInAirBattle(final boolean value) {\n+    wasInAirBattle = value;\n+  }\n+\n+  public boolean getWasInAirBattle() {\n+    return wasInAirBattle;\n+  }\n+\n+  public boolean getWasLoadedAfterCombat() {\n+    return wasLoadedAfterCombat;\n+  }\n+\n+  private void setWasLoadedAfterCombat(final boolean value) {\n+    wasLoadedAfterCombat = value;\n+  }\n+\n+  public boolean getWasAmphibious() {\n+    return wasAmphibious;\n+  }\n+\n+  private void setWasAmphibious(final boolean value) {\n+    wasAmphibious = value;\n+  }\n+\n+  public boolean getDisabled() {\n+    return disabled;\n+  }\n+\n+  private void setDisabled(final boolean value) {\n+    disabled = value;\n+  }\n+\n+  private void setTransportedBy(final Unit transportedBy) {\n+    this.transportedBy = transportedBy;\n+  }\n+\n+  /**\n+   * This is a very slow method because it checks all territories on the map. Try not to use this\n+   * method if possible.\n+   *\n+   * @return Unmodifiable collection of units that the given transport is transporting.\n+   */\n+  public List<Unit> getTransporting() {", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1Njg2Mg==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410756862", "bodyText": "Identical blocks of code found in 3 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-18T21:59:17Z", "path": "game-core/src/main/java/games/strategy/triplea/UnitUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package games.strategy.triplea;\n+\n+import games.strategy.engine.data.Change;\n+import games.strategy.engine.data.CompositeChange;\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.changefactory.ChangeFactory;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import lombok.experimental.UtilityClass;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.java.collections.IntegerMap;\n+\n+/**\n+ * Utility class providing static operations to Unit objects.\n+ *\n+ * <p>Note: avoid adding methods to this class, instead favor placing utils into topic specific\n+ * utility classes.\n+ */\n+@UtilityClass\n+public class UnitUtils {\n+\n+  public static int getProductionPotentialOfTerritory(\n+      final Collection<Unit> unitsAtStartOfStepInTerritory,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage,\n+      final boolean mathMaxZero) {\n+    return getHowMuchCanUnitProduce(\n+        getBiggestProducer(unitsAtStartOfStepInTerritory, producer, player, data, accountForDamage),\n+        producer,\n+        player,\n+        data,\n+        accountForDamage,\n+        mathMaxZero);\n+  }\n+\n+  /**\n+   * Returns the unit from the specified collection that has the largest production capacity within\n+   * the specified territory.\n+   *\n+   * @param accountForDamage {@code true} if the production capacity should account for unit damage;\n+   *     otherwise {@code false}.\n+   */\n+  public static Unit getBiggestProducer(\n+      final Collection<Unit> units,\n+      final Territory producer,\n+      final GamePlayer player,\n+      final GameData data,\n+      final boolean accountForDamage) {\n+    final Predicate<Unit> factoryMatch =", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MDY5MA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410960690", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return unit -> {\n          \n          \n            \n                  if (!unitHasWhenCombatDamagedEffect().test(unit)) {\n          \n          \n            \n                    return false;\n          \n          \n            \n                  }\n          \n          \n            \n                return unitHasWhenCombatDamagedEffect().and(unit -> {\n          \n      \n    \n    \n  \n\nFor style points", "author": "RoiEXLab", "createdAt": "2020-04-19T18:16:52Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -2033,14 +2026,13 @@ private Matches() {}\n   }\n \n   static Predicate<Unit> unitHasWhenCombatDamagedEffect(final String filterForEffect) {\n-    return u -> {\n-      if (!unitHasWhenCombatDamagedEffect().test(u)) {\n+    return unit -> {\n+      if (!unitHasWhenCombatDamagedEffect().test(unit)) {\n         return false;\n       }", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3MDMxNA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410970314", "bodyText": "A number of these I noticed. Tried to keep the scope as limited as possible to avoid getting too deep and mixing too many different kinds of changes in.", "author": "DanVanAtta", "createdAt": "2020-04-19T19:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MDY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3MjA2MA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410972060", "bodyText": "This update resulted in:\nStep 'google-java-format' found problem in 'game-core/src/main/java/games/strategy/triplea/delegate/Matches.java':\n\nThe inline suggestion is nice, though I think we probably should reserve it for quick typos. This PR is really risky for scope creep, there are tons of follow on simplifications that should be done.", "author": "DanVanAtta", "createdAt": "2020-04-19T19:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MDY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3NTQ2MA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410975460", "bodyText": "Needed a missing close paren.\nI like the change, but it's not for this PR. I don't like how the indentation is updated and increases the diff pretty drastically. Collapsing methods from Matches into TripleAPlayer was arguably too far of an update as well. With that the focus is really just on the one change at a time.", "author": "DanVanAtta", "createdAt": "2020-04-19T19:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MDY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MTAzMw==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410961033", "bodyText": "Off-Topic:\nI really don't quite get why we're using BigDecimal for movement.\nI'm pretty sure double would be precise enough for TripleA", "author": "RoiEXLab", "createdAt": "2020-04-19T18:18:43Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/MoveValidator.java", "diffHunk": "@@ -1100,7 +1098,7 @@ public static BigDecimal getMaxMovement(final Collection<Unit> units) {\n     }\n     BigDecimal max = BigDecimal.ZERO;\n     for (final Unit unit : units) {\n-      final BigDecimal left = TripleAUnit.get(unit).getMovementLeft();\n+      final BigDecimal left = unit.getMovementLeft();", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MjA5Mg==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410962092", "bodyText": "Well in this case there's no point to use the surrounding Comparator.comparing, just return the lambda directly I'd say", "author": "RoiEXLab", "createdAt": "2020-04-19T18:24:18Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/EditPanel.java", "diffHunk": "@@ -953,19 +953,19 @@ private static void sortUnitsToRemove(final List<Unit> units) {\n \n   private static Comparator<Unit> getRemovableUnitsOrder() {\n     return Comparator.comparing(\n-        TripleAUnit::get,\n+        Function.identity(),", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3NjEzMg==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410976132", "bodyText": "Agree, updated in: a82b983", "author": "DanVanAtta", "createdAt": "2020-04-19T19:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MjU5Nw==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410962597", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ((Unit) objs[0]).setAlreadyMoved(BigDecimal.ONE);\n          \n          \n            \n                collection.iterator().next().setAlreadyMoved(BigDecimal.ONE);\n          \n      \n    \n    \n  \n\nAnd remove the line above", "author": "RoiEXLab", "createdAt": "2020-04-19T18:27:20Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/MoveValidatorTest.java", "diffHunk": "@@ -58,7 +57,7 @@ void testGetLeastMovement() {\n     final Collection<Unit> collection = bomber.create(1, british);\n     assertEquals(new BigDecimal(6), MoveValidator.getLeastMovement(collection));\n     final Object[] objs = collection.toArray();\n-    ((TripleAUnit) objs[0]).setAlreadyMoved(BigDecimal.ONE);\n+    ((Unit) objs[0]).setAlreadyMoved(BigDecimal.ONE);", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3MDY3OA==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410970678", "bodyText": "Going to shy away from this update, there are many more updates we can do. This line is only swapping the casted type, I do not want to do more than just that (it opens up the flood gates, in which case such a giant update is unlikely to be accurate, let alone complete or reviewable)", "author": "DanVanAtta", "createdAt": "2020-04-19T19:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MjU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MzE2Ng==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410963166", "bodyText": "@ron-murhammer You might have any insight here.\nIs it important that movement left is rounded to an  int before comparing units?\nOtherwise it would be simpler writing something like\nComparator.comparing(Unit::getMovementLeft)", "author": "RoiEXLab", "createdAt": "2020-04-19T18:30:21Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProTransportUtils.java", "diffHunk": "@@ -244,12 +243,12 @@ public static int findUnitsTransportCost(final List<Unit> units) {\n     results.add(unit);\n     if (Matches.unitIsLandTransportWithoutCapacity().test(unit)) {\n       units.sort(\n-          Comparator.<Unit>comparingInt(u -> TripleAUnit.get(u).getMovementLeft().intValue())\n+          Comparator.<Unit>comparingInt(u -> u.getMovementLeft().intValue())\n               .thenComparing(getDecreasingAttackComparator(player)));\n       results.add(units.get(0));\n     } else {\n       units.sort(\n-          Comparator.<Unit>comparingInt(u -> TripleAUnit.get(u).getMovementLeft().intValue())\n+          Comparator.<Unit>comparingInt(u -> u.getMovementLeft().intValue())", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MzI5OQ==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410963299", "bodyText": "I think this change was unintended", "author": "RoiEXLab", "createdAt": "2020-04-19T18:31:02Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProMatches.java", "diffHunk": "@@ -561,14 +560,14 @@ private ProMatches() {}\n       final GamePlayer player, final UnitType unitType) {\n     return Matches.unitIsOwnedBy(player)\n         .and(Matches.unitIsOfType(unitType))\n-        .and(Matches.unitIsTransporting());\n+        .and(Unit::isTransporting);\n   }\n \n   public static Predicate<Unit> unitIsOwnedAndMatchesTypeAndNotTransporting(\n       final GamePlayer player, final UnitType unitType) {\n     return Matches.unitIsOwnedBy(player)\n         .and(Matches.unitIsOfType(unitType))\n-        .and(Matches.unitIsTransporting().negate());\n+        .and(Unit::isTransporting);", "originalCommit": "50827bc846a7fc385248929cd1c78635b3fcc8ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3MDkyNg==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410970926", "bodyText": "This is a good catch @RoiEXLab \ud83d\udc4d\nAn example of me going slightly too far in simplifications.", "author": "DanVanAtta", "createdAt": "2020-04-19T19:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MzI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3NTczMg==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410975732", "bodyText": "Fixed in: 278da46", "author": "DanVanAtta", "createdAt": "2020-04-19T19:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MzI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk3NjQ4Nw==", "url": "https://github.com/triplea-game/triplea/pull/6293#discussion_r410976487", "bodyText": "Actually fixed in: 7d7174d", "author": "DanVanAtta", "createdAt": "2020-04-19T19:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2MzI5OQ=="}], "type": "inlineReview"}, {"oid": "b1f4015157def564df9746fa2d24e5050a05985f", "url": "https://github.com/triplea-game/triplea/commit/b1f4015157def564df9746fa2d24e5050a05985f", "message": "Update game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\n\nCo-Authored-By: RoiEX <8350879+RoiEXLab@users.noreply.github.com>", "committedDate": "2020-04-19T19:11:03Z", "type": "commit"}, {"oid": "9fab31e9bf2bef1f97b691218f44fc68f383f1dd", "url": "https://github.com/triplea-game/triplea/commit/9fab31e9bf2bef1f97b691218f44fc68f383f1dd", "message": "Revert \"Update game-core/src/main/java/games/strategy/triplea/delegate/Matches.java\"\n\nThis reverts commit b1f4015157def564df9746fa2d24e5050a05985f.", "committedDate": "2020-04-19T19:36:31Z", "type": "commit"}, {"oid": "278da46b9ea0473e86121db558a5156740fb5336", "url": "https://github.com/triplea-game/triplea/commit/278da46b9ea0473e86121db558a5156740fb5336", "message": "Fix predicate negation", "committedDate": "2020-04-19T19:39:00Z", "type": "commit"}, {"oid": "a82b9830a95e6e1b4f6ec84485e49703d6076992", "url": "https://github.com/triplea-game/triplea/commit/a82b9830a95e6e1b4f6ec84485e49703d6076992", "message": "Remove unnecessary comparator wrapper", "committedDate": "2020-04-19T19:41:19Z", "type": "commit"}, {"oid": "7d7174db12592d50de5ef4c907f66edd4f47d139", "url": "https://github.com/triplea-game/triplea/commit/7d7174db12592d50de5ef4c907f66edd4f47d139", "message": "Fix correct negation", "committedDate": "2020-04-19T19:43:12Z", "type": "commit"}]}