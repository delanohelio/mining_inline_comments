{"pr_number": 6046, "pr_title": "Simplify Locking Mechanisms", "pr_createdAt": "2020-03-13T22:17:57Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6046", "timeline": [{"oid": "24992a647829fc6df09628fc96a9da9a48c19d07", "url": "https://github.com/triplea-game/triplea/commit/24992a647829fc6df09628fc96a9da9a48c19d07", "message": "Use synchronized keyword over custom logic", "committedDate": "2020-03-13T21:29:15Z", "type": "commit"}, {"oid": "ba091e96ed2c7fd9a3efd2006b80255fa91663aa", "url": "https://github.com/triplea-game/triplea/commit/ba091e96ed2c7fd9a3efd2006b80255fa91663aa", "message": "Use mutex for Tile class", "committedDate": "2020-03-13T21:49:41Z", "type": "commit"}, {"oid": "a6a32905bb1ba7681bdf1d0bf69c105f07d3721e", "url": "https://github.com/triplea-game/triplea/commit/a6a32905bb1ba7681bdf1d0bf69c105f07d3721e", "message": "Avoid using LockUtil", "committedDate": "2020-03-13T21:58:02Z", "type": "commit"}, {"oid": "0ea20345128059c2e14ceb39b6a72a131e0deae7", "url": "https://github.com/triplea-game/triplea/commit/0ea20345128059c2e14ceb39b6a72a131e0deae7", "message": "Remove now unused LockUtil class", "committedDate": "2020-03-13T21:58:19Z", "type": "commit"}, {"oid": "4692b1dda01ed2d190008fb83c681ba3dd583e3b", "url": "https://github.com/triplea-game/triplea/commit/4692b1dda01ed2d190008fb83c681ba3dd583e3b", "message": "Remove ReadWriteLock missing check", "committedDate": "2020-03-13T22:04:36Z", "type": "commit"}, {"oid": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "url": "https://github.com/triplea-game/triplea/commit/604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "message": "Fix NPE", "committedDate": "2020-03-13T22:17:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMTUzMQ==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392511531", "bodyText": "Serialization is stupid -_-\nWe can't use the final keyword anymore, but I think this is better than performing a null-check that's impossible to fail if it wasn't for (de)serialization", "author": "RoiEXLab", "createdAt": "2020-03-13T22:21:31Z", "path": "game-core/src/main/java/games/strategy/engine/data/GameData.java", "diffHunk": "@@ -97,8 +95,10 @@\n   private transient GameDataEventListeners gameDataEventListeners = new GameDataEventListeners();\n \n   private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    // The process of deserializing makes use of this lock,\n+    // we'll get an NPE if we don't set this field here already.\n+    readWriteLock = new ReentrantReadWriteLock();", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjMxMw==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392512313", "bodyText": "Here and in Line 634 I wasn't sure if this was the best move to expose the mutex like this.\nIt should be pretty safe to do that, it only ensures that the image isn't changed somehow while we perform drawing operations", "author": "RoiEXLab", "createdAt": "2020-03-13T22:24:23Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/panels/map/MapPanel.java", "diffHunk": "@@ -813,8 +810,7 @@ private void drawTiles(\n       final List<Tile> undrawn) {\n     g.translate(-bounds.getX(), -bounds.getY());\n     for (final Tile tile : tileManager.getTiles(bounds)) {\n-      tile.acquireLock();\n-      try {\n+      synchronized (tile.getMutex()) {", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNDkzMg==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392524932", "bodyText": "Actually I found a pretty good solution that avoids having a mutex here entirely.\nWill create a follow-up PR once this branch is merged.", "author": "RoiEXLab", "createdAt": "2020-03-13T23:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzA2Ng==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563066", "bodyText": "Do you understand why we need locks at all when rendering Tiles?\nThe thing I don't understand why there is just not a data copy done and that is rendered. I don't think locking actually really helps.\nThe scenarios I see:\nCase A)\n-> Tile grabs game lock\n-> Game update blocks waiting for lock\n-> Tile finishes rendering release lock\n-> Game  update happens. The tile rendering is now wrong and out of date\n-> (hopefully) Game update triggers a new rendering\n-> tile grabs an uncontested lock and does its rendering job.\nIf the tile blocks on a game update, then the tile is going to get correct data and just render once, but if the tile is locking first then it seems like the output will become wrong unless a new rendering occurs. I think a lot of TripleA locking is incorrect in this way, locks are grabbed to prevent contention during rendering, but we wind up with a stale result rendered and it's wrong anyways in the end, which means that just simply grabbing locks is not enough to get correctness. I think there are two problems: 1) concurrent changes and idempotent results, but also 2) result freshness and not rendering stale (and incorrect) data.\nTL:DR, I've long wondered why Tile doesn't just create an immutable copy and render that, it would be just as correct as if it had grabbed a lock.", "author": "DanVanAtta", "createdAt": "2020-03-14T06:52:35Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -15,9 +15,6 @@\n import java.util.List;", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2NTQyOA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392565428", "bodyText": "We can agree that the way it currently works is definitely weird.\nIf I understand it correctly, the lock is currently used for 2 separate things:\n\nAcquire a lock while rendering in order to \"batch\" all the rendering so the image is never drawn mid-render.\nSynchronize access to the underlying collection that stores all the IDrawables.\n\nMy planned follow-up PR gets rid of the first usage. I'm not sure what you mean by \"immutable copy\", but I believe my PR goes in a similar direction", "author": "RoiEXLab", "createdAt": "2020-03-14T07:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzEyMA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563120", "bodyText": "This comment assumes it is known what is meant by a 'double buffer'. With humbleness, I'm not sure I know what it means! Perhaps this comment should be more direct about stating what we are solving/avoiding.", "author": "DanVanAtta", "createdAt": "2020-03-14T06:53:49Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -38,19 +35,19 @@ public boolean needsRedraw() {\n     return isDirty && !isDrawing;\n   }\n \n-  public void acquireLock() {\n-    LockUtil.INSTANCE.acquireLock(lock);\n-  }\n-\n-  public void releaseLock() {\n-    LockUtil.INSTANCE.releaseLock(lock);\n+  /**\n+   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2NDg4Mg==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392564882", "bodyText": "I'm not happy with the description either, but I have a follow-up PR planned and ready which removes this method anyways and with it this Javadoc.", "author": "RoiEXLab", "createdAt": "2020-03-14T07:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2Nzk5NA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392567994", "bodyText": "Gotchya, I suppose our latest process is just to commit-stack and append to this PR, or wait very patiently and resolve merge conflicts that come up after merge. (I'll note that resolving those merge conflicts was not very fun on my side as they did happen frequently in response to feedback for stacked changes).", "author": "DanVanAtta", "createdAt": "2020-03-14T08:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzEzNw==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563137", "bodyText": "Minor: Did you consider using lombok for the getter?", "author": "DanVanAtta", "createdAt": "2020-03-14T06:54:11Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -38,19 +35,19 @@ public boolean needsRedraw() {\n     return isDirty && !isDrawing;\n   }\n \n-  public void acquireLock() {\n-    LockUtil.INSTANCE.acquireLock(lock);\n-  }\n-\n-  public void releaseLock() {\n-    LockUtil.INSTANCE.releaseLock(lock);\n+  /**\n+   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level\n+   * (the swing components support it internally, but we don't draw in batch) we expose this\n+   * internal mutex to prevent tiles being drawn mid-refresh.\n+   */\n+  public Object getMutex() {\n+    return mutex;", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2NTQ2NA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392565464", "bodyText": "Did consider it, but wanted to add the documentation", "author": "RoiEXLab", "createdAt": "2020-03-14T07:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzIzMg==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563232", "bodyText": "Before we had a very fancy 'read/writer' lock where readers did not block each other. This mutex on the other hand is just a re-entrant lock but would block other readers? AFAIK this lock is grabbed many times in fast succession (kinda scary from many perspective, but it is how it works), can you speculate if there would be a performance impact and/or have you checked it?", "author": "DanVanAtta", "createdAt": "2020-03-14T06:55:55Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/screen/Tile.java", "diffHunk": "@@ -38,19 +35,19 @@ public boolean needsRedraw() {\n     return isDirty && !isDrawing;\n   }\n \n-  public void acquireLock() {\n-    LockUtil.INSTANCE.acquireLock(lock);\n-  }\n-\n-  public void releaseLock() {\n-    LockUtil.INSTANCE.releaseLock(lock);\n+  /**\n+   * Because our Tile-rendering system doesn't use something like \"double buffers\" on a higher level\n+   * (the swing components support it internally, but we don't draw in batch) we expose this\n+   * internal mutex to prevent tiles being drawn mid-refresh.\n+   */\n+  public Object getMutex() {\n+    return mutex;\n   }\n \n   /** Returns the image representing this tile, re-rendering it first if the tile is dirty. */\n   public Image getImage(final GameData data, final MapData mapData) {\n     if (isDirty) {\n-      acquireLock();\n-      try {\n+      synchronized (mutex) {", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2NTYxNA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392565614", "bodyText": "Not in this case, on a semantic level the code here should be equivalent,  so no reason to check performance.", "author": "RoiEXLab", "createdAt": "2020-03-14T07:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2ODA2OA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392568068", "bodyText": "Are you sure? The read locks were global before, in this case the mutex is specific to just Tile.java. For example, if there is a read lock on game data from a different class, before that would not have blocked this lock. Now that we are have a single-class mutex, presumably it would.", "author": "DanVanAtta", "createdAt": "2020-03-14T08:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2OTYzMg==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392569632", "bodyText": "Hmm I could be missing something, but previously we used a re-entrant lock in this class, and now we use the synchronised keyword so it should be the same.", "author": "RoiEXLab", "createdAt": "2020-03-14T08:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392563385", "bodyText": "What a surprise to see this class deleted \ud83e\udd42 \ud83d\udcaf \ud83c\udf86  \ud83c\udf7e  \ud83c\udf89\nIs this class deleted because anywhere we used the lock util is not replaced with just standard java synchronization?", "author": "DanVanAtta", "createdAt": "2020-03-14T06:58:45Z", "path": "game-core/src/main/java/org/triplea/thread/LockUtil.java", "diffHunk": "@@ -1,154 +0,0 @@\n-package org.triplea.thread;", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2NjIzMg==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392566232", "bodyText": "I assume you mean \"is replaced\" instead of \"is not replaced\".\nAlmost. The only usage that remained after using standard synchronisation as a replacement is the 4 usages in GameData, where I just called lock and unlock directly. Because we're never really dealing with multiple GameDatas at the same time the read and write locks essentially become the only locks that are used via the LockUtil class, which defeats its purpose a little bit. After all it's supposed to keep track of the locks acquired and released by itself.\nNot quite that satisfying, but I guess it's a start.", "author": "RoiEXLab", "createdAt": "2020-03-14T07:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2ODEwOA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392568108", "bodyText": "Because we're never really dealing with multiple GameDatas at the same time the read and write locks essentially\n\nHow do you mean? There are many copies of game data taken at several different points, some notable examples: battle-calc, history, and I presume even network.", "author": "DanVanAtta", "createdAt": "2020-03-14T08:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2OTE2Mw==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392569163", "bodyText": "True, but I don't think there's any moment where we're holding write/read locks of 2 different instances at the same time.\nI might be wrong though, so feel free to correct me", "author": "RoiEXLab", "createdAt": "2020-03-14T08:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU3MDMwOQ==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392570309", "bodyText": "My impression from surveying the locks, there are only a few write locks, but many read locks. Read locks are grabbed hundreds of times per second from all over the place. For example, I did some debugging in lock util and added a 20ms - 200ms wait when acquiring a read lock, and the game never launched it was so busy doing busy waits. I would first assume there is concurrency between read locks unless able to prove otherwise.", "author": "DanVanAtta", "createdAt": "2020-03-14T09:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NTg5Nw==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392585897", "bodyText": "Yeah, but this particular class only had a single non-static re-entrant lock and now it has a single non-static object everything is synchronised on.\nThe only class working with readwrite locks here is GameData and the Tile class has nothing to do with that.", "author": "RoiEXLab", "createdAt": "2020-03-14T12:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNzUyNA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392727524", "bodyText": "AFAIK, the locks that are shared are through game data, which in turn is where all the locking is done for the rest of the system (back to game data).\nI suspect the perf is probably better now actually. LockUtil had a couple methods where if you repeated the 1000 times (I was trying to simulate a deadlock on them not too long ago), the test starts to get really slow and each iteration slows down to be a second and more. The weakref mechanism seemed to have been the culprit in that case, large set copies were happening. Having that removed, we've a simpler system which is more likely to be fast and/or easily made fast.", "author": "DanVanAtta", "createdAt": "2020-03-15T23:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MzM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NjkzNQ==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392586935", "bodyText": "My experience with this class was that it was some sort of primitive deadlock detector for cases where multiple locks were acquired on different, but concurrent, code paths.  That is, it was an attempt to enforce consistent lock ordering by preventing constructs like the following:\nThread A                   Thread B\n--------                   --------\nsynchronized(lock1) {      synchronized(lock2) {\n  . . .                      . . .\n  synchronized(lock2) {      synchronized(lock1) {\n    . . .                      . . .\n  }                          }\n}                          }\n\nWhere the lock acquisitions may happen in totally different methods, and thus not be obvious to a developer that they are introducing an inconsistent lock ordering.\nI don't know if there are still such cases where the same set of locks are acquired on concurrent code paths.  If so, that would be the only reason I could see keeping this class around.", "author": "ssoloff", "createdAt": "2020-03-14T13:03:07Z", "path": "game-core/src/main/java/org/triplea/thread/LockUtil.java", "diffHunk": "@@ -1,154 +0,0 @@\n-package org.triplea.thread;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import java.lang.ref.WeakReference;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.WeakHashMap;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.locks.Lock;\n-import lombok.extern.java.Log;\n-\n-/**\n- * Utility class for ensuring that locks are acquired in a consistent order.\n- *\n- * <p>Simply use this class and call acquireLock(aLock) releaseLock(aLock) instead of lock.lock(),\n- * lock.release(). If locks are acquired in an inconsistent order, an error message will be printed.", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5MTkwMg==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392591902", "bodyText": "I agree but looking at TileManager and Tile I believe the synchronised blocks are pretty safe: Tile operations are only called from newly created threads AFAIK, so the lock order is consistent there, at least for the Tile class, TileManager is similar where the operations are encapsulated well from my point of view.\nThe only thing I'd agree where this class might help is for the whole GameData thing. However it only really works if all places are using LockUtil.\nIf we want to be absolutely sure we could also implement a background thread that regularly runs a real deadlock check every couple of minutes, which would result in less code and be a more sophisticated approach to deadlock detection.", "author": "RoiEXLab", "createdAt": "2020-03-14T14:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NjkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5Mzg2MQ==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392593861", "bodyText": "The only thing I'd agree where this class might help is for the whole GameData thing. However it only really works if all places are using LockUtil.\n\nAgreed.  I suspect, at some point, the intent of using LockUtil consistently was simply neglected.\n\nIf we want to be absolutely sure we could also implement a background thread that regularly runs a real deadlock check every couple of minutes, which would result in less code and be a more sophisticated approach to deadlock detection.\n\nMy guess is LockUtil was created in response to a scenario whereby inconsistent lock ordering was being introduced by a developer, but it didn't result in a deadlock on the dev's machine due to choice timing.  Then, upon deployment to a user's machine, the timing changed such that the deadlock potential was realized, and that caused all sorts of headaches for the devs to debug.  This class then would have been introduced as an attempt to detect a potential deadlock rather than simply a tool to debug a realized deadlock (which modern JVM toolsets now provide anyway).", "author": "ssoloff", "createdAt": "2020-03-14T14:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NjkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwMTAxOA==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392601018", "bodyText": "Haven't thought of that, good consideration", "author": "RoiEXLab", "createdAt": "2020-03-14T16:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NjkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NzE1Ng==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392587156", "bodyText": "Since you are always setting this field in readObject(), can it be marked transient?", "author": "ssoloff", "createdAt": "2020-03-14T13:06:42Z", "path": "game-core/src/main/java/games/strategy/engine/data/GameData.java", "diffHunk": "@@ -59,8 +58,7 @@\n  */\n public class GameData implements Serializable {\n   private static final long serialVersionUID = -2612710634080125728L;\n-  private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n-  private transient LockUtil lockUtil = LockUtil.INSTANCE;\n+  private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();", "originalCommit": "604a2f4da781ca08465f56bca0a92ec2b3eb3e9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5MDY5NQ==", "url": "https://github.com/triplea-game/triplea/pull/6046#discussion_r392590695", "bodyText": "Good point, will do", "author": "RoiEXLab", "createdAt": "2020-03-14T14:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU4NzE1Ng=="}], "type": "inlineReview"}, {"oid": "f8e9251bc652a300a1703e3e39c7a02cc982e10f", "url": "https://github.com/triplea-game/triplea/commit/f8e9251bc652a300a1703e3e39c7a02cc982e10f", "message": "Use transient keyword", "committedDate": "2020-03-14T23:56:28Z", "type": "commit"}]}