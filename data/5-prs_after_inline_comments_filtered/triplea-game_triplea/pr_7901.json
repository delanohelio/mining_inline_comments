{"pr_number": 7901, "pr_title": "Add builder for the fire round steps", "pr_createdAt": "2020-10-14T05:32:55Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7901", "timeline": [{"oid": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "url": "https://github.com/triplea-game/triplea/commit/08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "message": "Add builder for the fire round steps", "committedDate": "2020-10-14T05:29:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MTk5OA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506991998", "bodyText": "I think you could fit the builder pattern more exactly by removing the parameter object, adding @Builder to FireRoundStepsBuilder, and then convert this 'buildSteps' method to be a no-arg.\nEven doing that, I think this class would still be more of a factory. The following flow is a bit odd:\n*Builder.builder()\n     .\n     .\n     .build()\n     .buildSteps(...)\n\nIf we call this a factory though, I think it works out better and is arguably a better fit to the pattern (a builder tends to return the thing that is prefixed on the builder, EG: a stringBuilder returns a string, a \"gameBuilder' returns a 'game')\nCalling this a factory, we get something like:\nFireRoundStepsFactory.builder()\n             .\n             .\n             .build()\n             .createSteps();", "author": "DanVanAtta", "createdAt": "2020-10-17T22:47:22Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilder.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@UtilityClass\n+public class FireRoundStepsBuilder {\n+\n+  @Builder\n+  public static class Parameters {\n+    @NonNull final BattleState battleState;\n+    @NonNull final BattleActions battleActions;\n+    @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+    @NonNull final BattleState.Side side;\n+    @NonNull final MustFightBattle.ReturnFire returnFire;\n+    @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> roll;\n+    @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> selectCasualties;\n+  }\n+\n+  public static List<BattleStep> buildSteps(final Parameters parameters) {", "originalCommit": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjEwNQ==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992105", "bodyText": "nit, as a function name, what do you think of chaning 'selectCasualties' to 'casualtySelector'. As a verb I think it fits a bit better, eg:\nCasualtyDetails casualtyDetails = selectCasualties.apply(...)\n// vs\nasualtyDetails casualtyDetails =  casualtySelector.apply( ...)", "author": "DanVanAtta", "createdAt": "2020-10-17T22:48:56Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilder.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@UtilityClass\n+public class FireRoundStepsBuilder {\n+\n+  @Builder\n+  public static class Parameters {\n+    @NonNull final BattleState battleState;\n+    @NonNull final BattleActions battleActions;\n+    @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+    @NonNull final BattleState.Side side;\n+    @NonNull final MustFightBattle.ReturnFire returnFire;\n+    @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> roll;\n+    @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> selectCasualties;", "originalCommit": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjE1Mw==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992153", "bodyText": "Ditto for 'roll', perhaps better as 'diceRoller'?\nfiringGroupSplitter already has a verb kind of name, updating these last two bi-functions I think would make that naming more consistent in this class overall.", "author": "DanVanAtta", "createdAt": "2020-10-17T22:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjM0NA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992344", "bodyText": "Maybe worth considering using the streaming API here? Seeing an array list copy raises flags for me, but that could just be me.\nAs a stream, we'd have soemthing like:\n final List<FiringGroup> firingGroups =\n   parameters.firingGroupSplitter.apply(parameters.battleState).stream().sorted(...).collect(Collectors.toList());", "author": "DanVanAtta", "createdAt": "2020-10-17T22:52:01Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilder.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import lombok.Builder;\n+import lombok.NonNull;\n+import lombok.experimental.UtilityClass;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@UtilityClass\n+public class FireRoundStepsBuilder {\n+\n+  @Builder\n+  public static class Parameters {\n+    @NonNull final BattleState battleState;\n+    @NonNull final BattleActions battleActions;\n+    @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+    @NonNull final BattleState.Side side;\n+    @NonNull final MustFightBattle.ReturnFire returnFire;\n+    @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> roll;\n+    @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> selectCasualties;\n+  }\n+\n+  public static List<BattleStep> buildSteps(final Parameters parameters) {\n+    final List<BattleStep> steps = new ArrayList<>();\n+\n+    final List<FiringGroup> firingGroups =\n+        new ArrayList<>(parameters.firingGroupSplitter.apply(parameters.battleState));", "originalCommit": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjQ4MQ==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992481", "bodyText": "Thoughts to use the iterable matcher here? You could avoid created the intermediate list and hopefully the failure message would be more user-friendly and tell you exactly how the lists mismatched, EG:\nassertThat(names, IsIterableContainingInOrder.contains(\n    \"attacker\" + FIRE_SUFFIX,\n            \"defender\" + SELECT_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX,\n            \"defender\" + REMOVE_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX));", "author": "DanVanAtta", "createdAt": "2020-10-17T22:54:08Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilderTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_WITHOUT_SPACE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.FIRE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsBuilderTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            FiringGroup.groupBySuicideOnHit(\n+                                \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker army\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"army\" + CASUALTIES_SUFFIX);\n+    assertThat(names, is(expected));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            List.of(\n+                                FiringGroup.groupBySuicideOnHit(\n+                                        \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                    .get(0),\n+                                FiringGroup.groupBySuicideOnHit(\n+                                        \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                    .get(0)))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker army\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"attacker spies\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"spies\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"spies\" + CASUALTIES_SUFFIX);\n+    assertThat(names, is(expected));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should be readable\")\n+  void getNamesWithDefaultUnitName() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            FiringGroup.groupBySuicideOnHit(\n+                                UNITS, List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + CASUALTIES_WITHOUT_SPACE_SUFFIX);\n+    assertThat(names, is(expected));", "originalCommit": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg3MzE0OQ==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r508873149", "bodyText": "I tried the IsIterableContainingInOrder and I think the failure message from is is actually better.  With is, it shows the entire expected and actual array.  But with IsIterableContainingInOrder, it only shows the complete expected array and the first failure item in the actual array.  I think seeing both complete arrays is useful.", "author": "trevan", "createdAt": "2020-10-20T22:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjk5MjUxMw==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r506992513", "bodyText": "Good use of @DisplayName  \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-10-17T22:54:28Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsBuilderTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.CASUALTIES_WITHOUT_SPACE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.FIRE_SUFFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.REMOVE_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SELECT_PREFIX;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsBuilderTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsBuilder.buildSteps(\n+                FireRoundStepsBuilder.Parameters.builder()\n+                    .battleActions(mock(BattleActions.class))\n+                    .returnFire(MustFightBattle.ReturnFire.ALL)\n+                    .roll((arg1, arg2) -> new DiceRoll())\n+                    .firingGroupSplitter(\n+                        (arg1) ->\n+                            FiringGroup.groupBySuicideOnHit(\n+                                \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                    .selectCasualties((arg1, arg2) -> new CasualtyDetails())\n+                    .side(OFFENSE)\n+                    .battleState(\n+                        FakeBattleState.givenBattleStateBuilder()\n+                            .attacker(attacker)\n+                            .defender(defender)\n+                            .build())\n+                    .build()));\n+\n+    final List<String> expected =\n+        List.of(\n+            \"attacker army\" + FIRE_SUFFIX,\n+            \"defender\" + SELECT_PREFIX + \"army\" + CASUALTIES_SUFFIX,\n+            \"defender\" + REMOVE_PREFIX + \"army\" + CASUALTIES_SUFFIX);\n+    assertThat(names, is(expected));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")", "originalCommit": "08d07e64ff5eb6bbad9029c6f0b2f82c747fa104", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d97c0de4f8be4506f30d317e5b711b7462e3f81f", "url": "https://github.com/triplea-game/triplea/commit/d97c0de4f8be4506f30d317e5b711b7462e3f81f", "message": "Rename FireRoundStepsBuilder -> FireRoundStepsFactory and make it a builder", "committedDate": "2020-10-20T21:54:33Z", "type": "commit"}, {"oid": "c0b114402433ce516454bb40c7d1e50dcc7f61b5", "url": "https://github.com/triplea-game/triplea/commit/c0b114402433ce516454bb40c7d1e50dcc7f61b5", "message": "Merge remote-tracking branch 'upstream/master' into fire-steps-builder", "committedDate": "2020-10-20T22:01:53Z", "type": "commit"}, {"oid": "ce8ca5dc387a04f9d9e938c383a8917da32837a8", "url": "https://github.com/triplea-game/triplea/commit/ce8ca5dc387a04f9d9e938c383a8917da32837a8", "message": "Use helper test methods in BattleStepsTest for step string matching", "committedDate": "2020-10-20T22:10:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NzQwNQ==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512967405", "bodyText": "What is the implied ordering of the output list from firingGroupSplitter? What contract would instances of this local variable need to satisfy to be consistent with the expected usages within this class?", "author": "DanVanAtta", "createdAt": "2020-10-27T19:25:20Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactory.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@Builder\n+public class FireRoundStepsFactory {\n+\n+  @NonNull final BattleState battleState;\n+  @NonNull final BattleActions battleActions;\n+  @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;", "originalCommit": "ce8ca5dc387a04f9d9e938c383a8917da32837a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1Mjk0MA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513052940", "bodyText": "I'll change it to Collection.  This class doesn't care about the order.", "author": "trevan", "createdAt": "2020-10-27T21:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NzQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2ODQzMA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512968430", "bodyText": "Side note, we may want to rename 'RollDice'. 'RollDice' and 'diceRoll' being inverses of each other is somewhat confusing, the distinction seems to be very weak, another maintainer might see no real difference between the two terms.", "author": "DanVanAtta", "createdAt": "2020-10-27T19:26:27Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactory.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@Builder\n+public class FireRoundStepsFactory {\n+\n+  @NonNull final BattleState battleState;\n+  @NonNull final BattleActions battleActions;\n+  @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+  @NonNull final BattleState.Side side;\n+  @NonNull final MustFightBattle.ReturnFire returnFire;\n+  @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> diceRoller;", "originalCommit": "ce8ca5dc387a04f9d9e938c383a8917da32837a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NTk4Mw==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513055983", "bodyText": "Any ideas on renaming it?  RollDice is a battle step that sets up the call to DiceRoll.  The 2 implementations of diceRoller are called RollAaDice and RollNormalDice.  RollNormalDice just calls DiceRoll while RollAaDice will play a sound and call DiceRoll.\nOne thought is that the other two steps are called SelectCasualties and MarkCasualties so maybe this should be similar?  Something like HitCasualties or CalculateCasualties?  Since in LL, dice isn't guaranteed to be rolled.", "author": "trevan", "createdAt": "2020-10-27T21:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2ODQzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMzIxNA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513103214", "bodyText": "Maybe call it  RollDiceStep? or  RollDiceBattleStep\n\n\"Since in LL, dice isn't guaranteed to be rolled.\"\n\nI suppose it's a pedantic argument whether rolling 0 dice is rolling dice. If you took that view, then having a LL roll dice step would still make sense.", "author": "DanVanAtta", "createdAt": "2020-10-28T00:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2ODQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MDEwMA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512970100", "bodyText": "nit, this seemingly could be simpler as a map + flatmap operation.\nEG:\nreturn   firingGroupSplitter.apply(battleState).stream()\n            .sorted(\n                Comparator.comparing(FiringGroup::getDisplayName)\n                    .thenComparing(FiringGroup::isSuicideOnHit))\n             .map(firingGroup -> List.of(new RollDice(battleState, side, firingGroup, fireRoundState, diceRoller),\n                           new SelectCasualties(battleState, side, firingGroup, fireRoundState, casualtySelector),\n                           new MarkCasualties(\n              battleState, battleActions, side, firingGroup, fireRoundState, returnFire))\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());", "author": "DanVanAtta", "createdAt": "2020-10-27T19:29:05Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactory.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/** Build the steps for the fire round (roll dice, select casualties, and mark casualties) */\n+@Builder\n+public class FireRoundStepsFactory {\n+\n+  @NonNull final BattleState battleState;\n+  @NonNull final BattleActions battleActions;\n+  @NonNull final Function<BattleState, List<FiringGroup>> firingGroupSplitter;\n+  @NonNull final BattleState.Side side;\n+  @NonNull final MustFightBattle.ReturnFire returnFire;\n+  @NonNull final BiFunction<IDelegateBridge, RollDice, DiceRoll> diceRoller;\n+  @NonNull final BiFunction<IDelegateBridge, SelectCasualties, CasualtyDetails> casualtySelector;\n+\n+  public List<BattleStep> createSteps() {\n+    final List<BattleStep> steps = new ArrayList<>();\n+\n+    final List<FiringGroup> firingGroups =\n+        firingGroupSplitter.apply(battleState).stream()\n+            .sorted(\n+                Comparator.comparing(FiringGroup::getDisplayName)\n+                    .thenComparing(FiringGroup::isSuicideOnHit))\n+            .collect(Collectors.toList());", "originalCommit": "ce8ca5dc387a04f9d9e938c383a8917da32837a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MDg5Mw==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512970893", "bodyText": "What is meant by 'readable'?", "author": "DanVanAtta", "createdAt": "2020-10-27T19:30:26Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactoryTest.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.generalFightStepStrings;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.mergeSteps;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsFactoryTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(names, is(generalFightStepStrings(attacker, defender, \"army\")));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        List.of(\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0),\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0)))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        names,\n+        is(\n+            mergeSteps(\n+                generalFightStepStrings(attacker, defender, \"army\"),\n+                generalFightStepStrings(attacker, defender, \"spies\"))));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should be readable\")", "originalCommit": "ce8ca5dc387a04f9d9e938c383a8917da32837a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1NzU0MQ==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513057541", "bodyText": "The \"step names\" is shown to the user in the Battle UI.  So \"readable\" would be understandable to the user.  When I first looked at the resulting strings in the UI, it sounded odd to me so I worked it a little to make it more \"readable\".  But it is very subjective.", "author": "trevan", "createdAt": "2020-10-27T21:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMTIzMw==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513101233", "bodyText": "Ah, qualifying 'readable' as 'human readable' should make that clear. 'readable' can be understood in different ways.", "author": "DanVanAtta", "createdAt": "2020-10-27T23:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MDg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MTkxMA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r512971910", "bodyText": "nit, I notice there is no new line between the test setup and the invocation of the unit under test. Having the setup, invocation of the test unit, and the assertions be separated by a new line helps delimit them and helps the reader easily see what is being tested vs the setup. (Arrange, Act, Assert (AAA) testing pattern). Any objection to inserting such new lines?\nFor example,\ntestMethod() {\n    setupVar = setup...\n    player = ... setup\n    otherState = ... setup\n\n    resultValue = methodUnderTest.invoke(player, otherState ...)\n\n    assertions(....) \n}\n\nSide note on AAA\nI've even some styles where developers use boiler plate templates with comment blocks to delimit these sections, eg:\ntestMethod() {\n   // arrange\n\n   // act\n\n   // assert\n}\n\nI\"ve also seen those comments be called \"given, when, then\". IMO the comment blocks add clutter and the test method should be simple enough that simple new lines are delimiter enough to mark the different parts of a test. The latter should be possible almost all of the time, particularly if any complicated arrangements are extracted to helper methods that give a high level overview of what we are setting up with parameters for the key values that would control the result value of the unit under test.", "author": "DanVanAtta", "createdAt": "2020-10-27T19:32:03Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactoryTest.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.generalFightStepStrings;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.mergeSteps;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsFactoryTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(names, is(generalFightStepStrings(attacker, defender, \"army\")));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        List.of(\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0),\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0)))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        names,\n+        is(\n+            mergeSteps(\n+                generalFightStepStrings(attacker, defender, \"army\"),\n+                generalFightStepStrings(attacker, defender, \"spies\"))));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should be readable\")\n+  void getNamesWithDefaultUnitName() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+    final List<String> names =", "originalCommit": "ce8ca5dc387a04f9d9e938c383a8917da32837a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b74ad007a4e6e18c604a25ae03d2583af0ec89b8", "url": "https://github.com/triplea-game/triplea/commit/b74ad007a4e6e18c604a25ae03d2583af0ec89b8", "message": "Review feedback", "committedDate": "2020-10-27T22:00:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMjY1Nw==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r513102657", "bodyText": "Why should units not be in the name?\nI think this would be a stronger statement if it were something like:\n\"A battle with offense and all suicide units should be labelled as 'XYZ'\"\nWith the above, I wonder why are we not checking for an exact name?\nI suspect that would be more obvious if the checked values were not behind a method. I also notice there is logic for a magic value of emptry string in generalFightStepStrings. I think it might make for stronger tests to inline the function everywhere in tests to make the assertions explicit and clear.", "author": "DanVanAtta", "createdAt": "2020-10-28T00:04:34Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/FireRoundStepsFactoryTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.generalFightStepStrings;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.mergeSteps;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.FakeBattleState;\n+import games.strategy.triplea.delegate.battle.MustFightBattle;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+\n+class FireRoundStepsFactoryTest {\n+\n+  @Test\n+  @DisplayName(\"The display names for an entire fire round is fire, select, remove\")\n+  void getNamesWithOneFiringGroup() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(names, is(generalFightStepStrings(attacker, defender, \"army\")));\n+  }\n+\n+  private List<String> getStepNames(final List<BattleStep> steps) {\n+    return steps.stream().flatMap(step -> step.getNames().stream()).collect(Collectors.toList());\n+  }\n+\n+  @Test\n+  @DisplayName(\"With two groups, there should be two sets of fire round strings\")\n+  void getNamesWithTwoFiringGroups() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        List.of(\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"army\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0),\n+                            FiringGroup.groupBySuicideOnHit(\n+                                    \"spies\", List.of(givenAnyUnit()), List.of(mock(Unit.class)))\n+                                .get(0)))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        names,\n+        is(\n+            mergeSteps(\n+                generalFightStepStrings(attacker, defender, \"army\"),\n+                generalFightStepStrings(attacker, defender, \"spies\"))));\n+  }\n+\n+  @Test\n+  @DisplayName(\"With the default name UNITS, the step names should not include UNITS\")\n+  void getNamesWithDefaultUnitName() {\n+    final GamePlayer attacker = mock(GamePlayer.class);\n+    when(attacker.getName()).thenReturn(\"attacker\");\n+    final GamePlayer defender = mock(GamePlayer.class);\n+    when(defender.getName()).thenReturn(\"defender\");\n+\n+    final List<String> names =\n+        getStepNames(\n+            FireRoundStepsFactory.builder()\n+                .battleActions(mock(BattleActions.class))\n+                .returnFire(MustFightBattle.ReturnFire.ALL)\n+                .diceRoller((arg1, arg2) -> new DiceRoll())\n+                .firingGroupSplitter(\n+                    (arg1) ->\n+                        FiringGroup.groupBySuicideOnHit(\n+                            UNITS, List.of(givenAnyUnit()), List.of(mock(Unit.class))))\n+                .casualtySelector((arg1, arg2) -> new CasualtyDetails())\n+                .side(OFFENSE)\n+                .battleState(\n+                    FakeBattleState.givenBattleStateBuilder()\n+                        .attacker(attacker)\n+                        .defender(defender)\n+                        .build())\n+                .build()\n+                .createSteps());\n+\n+    assertThat(\n+        \"units should not be in the name\",", "originalCommit": "b74ad007a4e6e18c604a25ae03d2583af0ec89b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1NDU3MA==", "url": "https://github.com/triplea-game/triplea/pull/7901#discussion_r514554570", "bodyText": "I had created the method in a separate PR for the purpose to reduce the size of the final PR.  It changes all of these step names in the same way and would make that PR very large.  Once that is in, I can inline the method in a later PR.\nAs for why \"units\" should not be in the name, that is the \"human readable\" subjective view.  The step name is either:\nAttacker fires\nDefender selects casualties\nDefender removes casualties\n\nvs\nAttacker units fire\nDefender selects units casualties\nDefender removes units casualties\n\nI find the former looks better in this case.\nBut the map designer can give the group a name in the XML.  An example would be \"AA\", \"Boomstick\", or \"AntiTankGun\".  In that case, the name needs to be in the string:\nAttacker AntiTankGun fire\nDefender selects AntiTankGun casualties\nDefender removes AntiTankGun casualties", "author": "trevan", "createdAt": "2020-10-29T20:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwMjY1Nw=="}], "type": "inlineReview"}, {"oid": "d198f856c289d2387716b2fed270d58324902279", "url": "https://github.com/triplea-game/triplea/commit/d198f856c289d2387716b2fed270d58324902279", "message": "Rename RollDice as RollDiceStep and rename the Rollers", "committedDate": "2020-10-29T20:37:27Z", "type": "commit"}]}