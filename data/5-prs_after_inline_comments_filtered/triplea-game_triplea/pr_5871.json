{"pr_number": 5871, "pr_title": "Enhance suicide functionality and deprecate old suicide options", "pr_createdAt": "2020-01-23T17:00:00Z", "pr_url": "https://github.com/triplea-game/triplea/pull/5871", "timeline": [{"oid": "035a2e77e1973b33253b3b5ac9e7c4007dce9259", "url": "https://github.com/triplea-game/triplea/commit/035a2e77e1973b33253b3b5ac9e7c4007dce9259", "message": "Add new suicide options and replace the old options", "committedDate": "2020-01-23T16:53:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370241711", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-23T17:01:47Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AirBattle.java", "diffHunk": "@@ -198,20 +198,20 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n               defendingWaitingToDie.clear();\n               // kill any suicide attackers (veqryn)\n               final Predicate<Unit> attackerSuicide =\n-                  PredicateBuilder.of(Matches.unitIsSuicide())\n+                  PredicateBuilder.of(Matches.unitIsSuicideOnAttack())\n                       .andIf(isBombingRun, Matches.unitIsNotStrategicBomber())\n                       .build();\n               if (attackingUnits.stream().anyMatch(attackerSuicide)) {\n                 final List<Unit> suicideUnits =\n-                    CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicide());\n+                    CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicideOnAttack());\n                 attackingUnits.removeAll(suicideUnits);\n                 remove(suicideUnits, bridge, battleSite);\n                 tuvLostAttacker = TuvUtils.getTuv(suicideUnits, attacker, attackerCosts, gameData);\n                 attackerLostTuv += tuvLostAttacker;\n               }\n-              if (defendingUnits.stream().anyMatch(Matches.unitIsSuicide())) {\n+              if (defendingUnits.stream().anyMatch(Matches.unitIsSuicideOnDefense())) {", "originalCommit": "035a2e77e1973b33253b3b5ac9e7c4007dce9259", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370241712", "bodyText": "TODO found", "author": "codeclimate", "createdAt": "2020-01-23T17:01:47Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1380,17 +1379,18 @@ private void fireNavalBombardment(final IDelegateBridge bridge) {\n   }\n \n   private void fireSuicideUnitsAttack() {\n+    // TODO: Remove isSuicideOnAttack check and update to use canNotTarget/canNotBeTargetedBy", "originalCommit": "035a2e77e1973b33253b3b5ac9e7c4007dce9259", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTY3Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370451677", "bodyText": "Kinda agree with the TODO climate warning unless we have a reference to who or what owns this task.", "author": "DanVanAtta", "createdAt": "2020-01-24T02:32:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MzUzOQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373743539", "bodyText": "Why is this TODO not being done now?", "author": "DanVanAtta", "createdAt": "2020-02-01T00:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1OTU2Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373759563", "bodyText": "This was a temporary TODO that has already been removed...", "author": "ron-murhammer", "createdAt": "2020-02-01T05:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MzE1Mg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763152", "bodyText": "Cool, thanks for taking care of, did not properly notice the 'outdated' tag.", "author": "DanVanAtta", "createdAt": "2020-02-01T06:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI0MTcxNw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370241717", "bodyText": "TODO found", "author": "codeclimate", "createdAt": "2020-01-23T17:01:47Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1419,20 +1419,18 @@ private void fireSuicideUnitsAttack() {\n   }\n \n   private void fireSuicideUnitsDefend() {\n-    if (isDefendingSuicideAndMunitionUnitsDoNotFire()) {\n-      return;\n-    }\n+    // TODO: Remove isSuicideOnDefense check and update to use canNotTarget/canNotBeTargetedBy", "originalCommit": "035a2e77e1973b33253b3b5ac9e7c4007dce9259", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f96e481ef5c85697685cee00961a918b125aa5a", "url": "https://github.com/triplea-game/triplea/commit/1f96e481ef5c85697685cee00961a918b125aa5a", "message": "Fix bug where all allied supporting units not being properly considered", "committedDate": "2020-01-23T18:44:39Z", "type": "commit"}, {"oid": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "url": "https://github.com/triplea-game/triplea/commit/7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "message": "Remove unnecessary parameter", "committedDate": "2020-01-23T18:55:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDIwMg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450202", "bodyText": "Why is this the condition for suicide on defense?\n!Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));", "author": "DanVanAtta", "createdAt": "2020-01-24T02:24:25Z", "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc2NTg3Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372765873", "bodyText": "Because this is a hack property that was added to make it so all suicide units in a map wouldn't suicide on defense. This is essentially deprecated now and just used for backwards compatibility.", "author": "ron-murhammer", "createdAt": "2020-01-30T05:32:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3NzE3Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372777177", "bodyText": "Would you mind adding a comment to the code to clarify point? I'm pretty sure others would have the same question casually reading this and they would not have the benefit of this PR review conversation for reference.", "author": "DanVanAtta", "createdAt": "2020-01-30T06:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTczOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372779738", "bodyText": "Added. Also marked these as deprecated.", "author": "ron-murhammer", "createdAt": "2020-01-30T06:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDMzNg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450336", "bodyText": "Should first strike truly be a side effect of is suicide? Does this limit our options in case we want a unit that is just 'isSuicide'? Say someone has a non-attacking unit, or an attacking unit that is suicide, but not first strike, how could that be handled?", "author": "DanVanAtta", "createdAt": "2020-01-24T02:25:18Z", "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc2NTY3Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372765673", "bodyText": "In theory no but this is for backwards compatibility because that is how suicide units work currently. Moving forward maps shouldn't use isSuicide and set either or both of the 2 new options.", "author": "ron-murhammer", "createdAt": "2020-01-30T05:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDMzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3NjkyOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372776928", "bodyText": "I think this is where map versions would be incredibly useful. We could decouple this based on specified map version.\nHave you considered making isSuicde have attribute values? eg: 'suicideOn=attack', 'suicideOn=all'", "author": "DanVanAtta", "createdAt": "2020-01-30T06:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450480", "bodyText": "Should the 's' convention be carried forward? Would it be more clear if the parameter were simply spelled out?", "author": "DanVanAtta", "createdAt": "2020-01-24T02:26:03Z", "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);\n+  }\n+\n+  private void setIsSuicideOnAttack(final String s) {", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc2NTQ1OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372765459", "bodyText": "I'd rather keep consistency for now. Easier to just update them all at once. Though honestly most of these are so simple that the parameter name isn't a huge deal.", "author": "ron-murhammer", "createdAt": "2020-01-30T05:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3NjM0Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372776346", "bodyText": "I'm not entirely sure it's consistent, I think there is argument for it being copy/pasta. Otherwise, we're left with just a single letter variable name representing the type, 'String'. Or does the 's' represent 'suicide', or 'isSuicide'? Having to decode what a variable single character represents is a small burden, but a burden nonetheless, that makes it harder to grok/read code.", "author": "DanVanAtta", "createdAt": "2020-01-30T06:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MDA1OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372780059", "bodyText": "\"Easier to just update them all at once.\"\n\nI have trouble agreeing as there are many more instances 'to fix' now. It's not clear they would all get the same fix.", "author": "DanVanAtta", "createdAt": "2020-01-30T06:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MDY3Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372780673", "bodyText": "Actually, backing up a bit, the private setter is really odd. Perhaps would it be easier if we just inlined this? Then when invoked via method reference, it would imply that we have more going on then a simple setter. Someone reading the code would be no worse off seeing any of the inconsistent cases, either they'd see the simple setter inline, or they would see a method reference that is either more complex or is a simple setter (which we could later come back to clean up).", "author": "DanVanAtta", "createdAt": "2020-01-30T06:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MjI5Mg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372782292", "bodyText": "I believe the double setters (1 string, 1 actual type) has to do with the XML parsing for attachments. The attachment classes in general are very rough and primarily there for to hold the values from the map XML parsing.", "author": "ron-murhammer", "createdAt": "2020-01-30T06:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MTMwMg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373741302", "bodyText": "I believe the double setters (1 string, 1 actual type) has to do with the XML parsing for attachments. The attachment classes in general are very rough and primarily there for to hold the values from the map XML parsing.\n\nI believe I understood that; My point is the indirection here does not seem useful, inlining these methods would reduce the indirection.\nRe: variable name, most of the examples have been touched/added here and the new setter methods could have different variable names altogether. I don't really trust that we ever will come back and fix them.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1OTk1MQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373759951", "bodyText": "I think you're missing the big picture here. This entire class and really all the attachment classes follow this pattern of methods. Now whether that is an ideal pattern or not we can discuss but that is really a much larger issue than this PR and I would prefer to have a separate issue for it.", "author": "ron-murhammer", "createdAt": "2020-02-01T05:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MzQwOQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763409", "bodyText": "I don't think I am necessarily:\n\nAt 4300+ lines, this class is a monster. At such scale, it's arguable there are any patterns, it's a task just to grok it to see if anything is consistent or what it even contains.\n\nThis is a counter-example to the 'pattern':\n        .put(\n            \"transportCost\",\n            MutableProperty.ofMapper(\n                DefaultAttachment::getInt,\n                this::setTransportCost,\n                this::getTransportCost,\n                () -> -1))\n\nTo help avoid unnecessary indirection I'm suggesting to follow the example of the counter-example and inline the setter/getters if they are simple.\nSecond, the class violates our preferred method ordering with arbitrarily located getter/setters that ought to be below where they are used.\nThird, if not explicitly listed, we have a preference to spell out variables and not use single letter variables. I'm not positive if the 's' makes sense or is the right prefix, and seeing s && ... is not as easy to understand as it could be.\nI can understand pushback on the first and second points, though I don't think either of us should make that the hill we choose to die on, the third point seems far less reasonable to ignore as it's more about the care of this update as it is adding new code that should really not be adding at least that element of technical debt.", "author": "DanVanAtta", "createdAt": "2020-02-01T07:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc4OTQxNQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373789415", "bodyText": "I'd actually argue the larger the class the more consistency matters as its harder to understand if you see something being done multiple different ways.\nThat being said, I misunderstood what you were suggesting about in lining. I'm open to using one of the helper mappers to reduce which setter/getter/reseter are needed. Updated this.", "author": "ron-murhammer", "createdAt": "2020-02-01T16:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDgwNg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370450806", "bodyText": "Side-note, do you recall the rationale to not attach this method as a property of Unit? I suspect it would be pretty clearly better encapsulation.", "author": "DanVanAtta", "createdAt": "2020-01-24T02:27:54Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/Matches.java", "diffHunk": "@@ -493,8 +493,12 @@ private Matches() {}\n             && !unitCanBeCapturedOnEnteringToInThisTerritory(player, terr, data).test(unit);\n   }\n \n-  public static Predicate<Unit> unitIsSuicide() {\n-    return unit -> UnitAttachment.get(unit.getType()).getIsSuicide();\n+  public static Predicate<Unit> unitIsSuicideOnAttack() {\n+    return unit -> UnitAttachment.get(unit.getType()).getIsSuicideOnAttack();\n+  }\n+\n+  public static Predicate<Unit> unitIsSuicideOnDefense() {\n+    return unit -> UnitAttachment.get(unit.getType()).getIsSuicideOnDefense();", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc2NTMzNQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372765335", "bodyText": "All the unit properties are part of UnitAttachment. This is really just the overall structure of the XML and code base.", "author": "ron-murhammer", "createdAt": "2020-01-30T05:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MDgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTQ0Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370451447", "bodyText": "Would it maybe be more clear and direct to have a 'isSucicideOnAttack' property? It seems to get at that property, one has to be pretty clever to set a combination of values.\nI wonder as well if simply adding those two properties would make it easier for this update to be backward compatible. I'm very concerned that the property is not directly from the XML but is instead derived, it seems like it is quite complex compared to other properties that are usually 1:1.", "author": "DanVanAtta", "createdAt": "2020-01-24T02:31:38Z", "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1752,19 +1753,45 @@ private void resetCanDieFromReachingMaxDamage() {\n   }\n \n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n   private void setIsSuicide(final Boolean s) {", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ2NjYyMQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370466621", "bodyText": "Second, if 'isFirstStrike' is set, would this conflict and/or introduce a race condition for which property is actually set?\nEG: isSuicide = true & isFirstStrike = false (or vice versa)\nIf this also gets reset, will that turn off firstStrike for units that have it? Are we guaranteed to have it be turned back on?\nI'm feeling pretty convinced this property should be more independent of others, and allow 'isSuicide' to be more legacy and/or operate mostly as it used to.", "author": "DanVanAtta", "createdAt": "2020-01-24T04:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc2NTE0Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372765146", "bodyText": "Not really following you here. So essentially what this does is add 2 new unit options isSuicideOnAttack and isSuicideOnDefense as often you don't want units to suicide in both cases (think I don't want missiles to suicide on defense, etc). This then deprecates isSuicide which for backwards compatibility now just sets these new properties. Eventually after this release and if all maps using isSuicide are updated then we could remove it all together.", "author": "ron-murhammer", "createdAt": "2020-01-30T05:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3Nzg4MA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372777880", "bodyText": "Essentially I was suggesting to leave the 'isSuicide' property unchanged and instead just add the new properties. It's more clear to me now that you're removing the now old 'isSuicide' property.", "author": "DanVanAtta", "createdAt": "2020-01-30T06:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTc0Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370451747", "bodyText": "Should canReturnFire be a method of Properties? Would that be more direct and re-usable? Any concern that we might duplicate or confuse this check somewhere else?", "author": "DanVanAtta", "createdAt": "2020-01-24T02:33:20Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1404,35 +1404,33 @@ private void fireSuicideUnitsAttack() {\n     if (suicideAttackers.isEmpty() || attackedDefenders.isEmpty()) {\n       return;\n     }\n-    final boolean canReturnFire = (!isSuicideAndMunitionCasualtiesRestricted());\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>();\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingUnits);\n+    final boolean canReturnFire = (!Properties.getSuicideAndMunitionCasualtiesRestricted(gameData));", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MzcxMw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373743713", "bodyText": "Having a method Properties.canReturnFire(gameData) seems like it would much simpler to understand here and would be much better encapsulation. Currently MustFightBattle is bloated and knows about far too much, it should not necessarily be in change of interpretting game rules like this.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0Mzg0NQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373743845", "bodyText": "Noticing now as well we have the logic repeated: https://github.com/triplea-game/triplea/pull/5871/files/7e244f4d9c1c60f021bacdaf21c2606c914d4dbd#diff-009c223dfe7c716d07dc90f27899c933R1446, seems like an actual DRY violation where the idea of 'canReturnFire' is computed in multiple places, moving this logic would help with that problem.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MDA5NQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373760095", "bodyText": "Uh, I think this was all removed. Are you looking at the latest diff and commits?", "author": "ron-murhammer", "createdAt": "2020-02-01T05:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MzQ3Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763477", "bodyText": "Not sure, seems to indicate I need to start over on the entire review  \ud83d\ude1e", "author": "DanVanAtta", "createdAt": "2020-02-01T07:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MjA2NA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r370452064", "bodyText": "Would a method overload be cleaner to avoid passing null parameter when the last parameter is unused?", "author": "DanVanAtta", "createdAt": "2020-01-24T02:35:19Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/DiceRollTest.java", "diffHunk": "@@ -63,19 +63,23 @@ void testSimple() {\n         .thenAnswer(withValues(1)); // infantry attack does not hit at 1 (0 based)\n     // infantry defends\n     final DiceRoll roll =\n-        DiceRoll.rollDice(infantry, true, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(\n+            infantry, true, russians, bridge, battle, \"\", territoryEffects, null, infantry);\n     assertThat(roll.getHits(), is(1));\n     // infantry\n     final DiceRoll roll2 =\n-        DiceRoll.rollDice(infantry, true, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(\n+            infantry, true, russians, bridge, battle, \"\", territoryEffects, null, infantry);\n     assertThat(roll2.getHits(), is(0));\n     // infantry attacks\n     final DiceRoll roll3 =\n-        DiceRoll.rollDice(infantry, false, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(\n+            infantry, false, russians, bridge, battle, \"\", territoryEffects, null, infantry);\n     assertThat(roll3.getHits(), is(1));\n     // infantry attack\n     final DiceRoll roll4 =\n-        DiceRoll.rollDice(infantry, false, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc2NDU2NQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372764565", "bodyText": "Possibly. I may add some overloads to this but wanted to ensure I updated all the necessary places that needed updated first and not miss any.", "author": "ron-murhammer", "createdAt": "2020-01-30T05:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MjA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMzMjA2OA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373332068", "bodyText": "Updated.", "author": "ron-murhammer", "createdAt": "2020-01-31T06:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ1MjA2NA=="}], "type": "inlineReview"}, {"oid": "96f92925f5fb2af58d9f48ccb516e409c83fb1fc", "url": "https://github.com/triplea-game/triplea/commit/96f92925f5fb2af58d9f48ccb516e409c83fb1fc", "message": "Remove old suicide steps and begin refactoring other steps", "committedDate": "2020-01-28T19:39:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTcxMQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372015711", "bodyText": "Method firstStrikeFire has 7 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-28T19:40:35Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,59 +1912,63 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units defend, \",\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n+        returnFire,\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units attack, \",\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void firstStrikeFire(\n+      final ReturnFire returnFire,", "originalCommit": "96f92925f5fb2af58d9f48ccb516e409c83fb1fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxNTcxMw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372015713", "bodyText": "Method standardFire has 7 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-28T19:40:35Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -2014,102 +1981,98 @@ private void attackAirOnNonSubs() {\n           CollectionUtils.getMatches(defendingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n       final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n       allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+      final List<Unit> allFriendlyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n+      allFriendlyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n       fire(\n           defender.getName() + SELECT_CASUALTIES,\n           units,\n           enemyUnitsNotSubs,\n           allEnemyUnitsAliveOrWaitingToDie,\n+          allFriendlyUnitsAliveOrWaitingToDie,\n           false,\n           ReturnFire.ALL,\n           \"Attacker's aircraft fire,\");\n     }\n   }\n \n-  /**\n-   * If there are no attacking DDs, but defending SUBs, remove attacking AIR as they've already\n-   * fired, otherwise fire all attackers.\n-   */\n-  private void attackNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike().negate());\n-    units.addAll(\n-        CollectionUtils.getMatches(attackingWaitingToDie, Matches.unitIsFirstStrike().negate()));\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    // if restricted, remove aircraft from attackers\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units.removeAll(CollectionUtils.getMatches(units, Matches.unitIsAir()));\n-    }\n-    if (units.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n-        defender.getName() + SELECT_CASUALTIES,\n-        units,\n-        defendingUnits,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        false,\n-        ReturnFire.ALL,\n-        \"Attackers fire,\");\n-  }\n-\n   private void defendAirOnNonSubs() {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n     Collection<Unit> units = new ArrayList<>(defendingUnits);\n     units.addAll(defendingWaitingToDie);\n     if (!canAirAttackSubs(attackingUnits, units)) {\n       units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n       final Collection<Unit> enemyUnitsNotSubs =\n           CollectionUtils.getMatches(attackingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      if (enemyUnitsNotSubs.isEmpty()) {\n-        return;\n-      }\n       final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n       allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n+      final List<Unit> allFriendlyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n+      allFriendlyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n       fire(\n           attacker.getName() + SELECT_CASUALTIES,\n           units,\n           enemyUnitsNotSubs,\n           allEnemyUnitsAliveOrWaitingToDie,\n+          allFriendlyUnitsAliveOrWaitingToDie,\n           true,\n           ReturnFire.ALL,\n           \"Defender's aircraft fire,\");\n     }\n   }\n \n-  private void defendNonSubs() {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n+  private void standardAttackersFire() {\n+    standardFire(\n+        defender.getName() + SELECT_CASUALTIES,\n+        \"Attackers fire, \",\n+        false,\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void standardDefendersFire() {\n+    standardFire(\n+        attacker.getName() + SELECT_CASUALTIES,\n+        \"Defenders fire, \",\n+        true,\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n+  }\n+\n+  private void standardFire(\n+      final String stepName,", "originalCommit": "96f92925f5fb2af58d9f48ccb516e409c83fb1fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fcdca58493bef0d78eb52570178c9d85eec117b", "url": "https://github.com/triplea-game/triplea/commit/6fcdca58493bef0d78eb52570178c9d85eec117b", "message": "Auto-Formatting", "committedDate": "2020-01-28T19:41:10Z", "type": "commit"}, {"oid": "97d2e060eb55787acc011ea8323359023b9eb495", "url": "https://github.com/triplea-game/triplea/commit/97d2e060eb55787acc011ea8323359023b9eb495", "message": "Refactor firing air units on non-subs", "committedDate": "2020-01-29T21:35:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MzcyMQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372643721", "bodyText": "Method fireAirOnNonSubs has 7 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-29T21:37:06Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,167 +1913,174 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units defend, \",\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n+        returnFire,\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        \"First strike units attack, \",\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void firstStrikeFire(\n+      final ReturnFire returnFire,\n+      final String stepName,\n+      final String message,\n+      final Collection<Unit> firingUnits,\n+      final Collection<Unit> firingUnitsWaitingToDie,\n+      final Collection<Unit> enemyUnits,\n+      final Collection<Unit> enemyUnitsWaitingToDie) {\n+\n+    Collection<Unit> firing = new ArrayList<>(firingUnits);\n+    firing.addAll(firingUnitsWaitingToDie);\n+    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n+    final Set<UnitType> canNotTarget =\n+        firing.stream()\n+            .map(unit -> UnitAttachment.get(unit.getType()).getCanNotTarget())\n+            .flatMap(unitTypes -> unitTypes.stream())\n+            .collect(Collectors.toSet());\n+    final Collection<Unit> attackableUnits =\n+        CollectionUtils.getMatches(enemyUnits, Matches.unitIsOfTypes(canNotTarget).negate());\n+    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(enemyUnits);\n+    allEnemyUnitsAliveOrWaitingToDie.addAll(enemyUnitsWaitingToDie);\n+    final List<Unit> allFriendlyUnitsAliveOrWaitingToDie = new ArrayList<>(firingUnits);\n+    allFriendlyUnitsAliveOrWaitingToDie.addAll(firingUnitsWaitingToDie);\n     fire(\n-        defender.getName() + SELECT_SUB_CASUALTIES,\n+        stepName,\n         firing,\n-        attacked,\n+        attackableUnits,\n         allEnemyUnitsAliveOrWaitingToDie,\n+        allFriendlyUnitsAliveOrWaitingToDie,\n         false,\n         returnFire,\n-        \"Subs fire,\");\n+        message);\n   }\n \n-  /** If there are no attacking DDs but defending SUBs, fire AIR at non-SUB forces ONLY. */\n   private void attackAirOnNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(attackingUnits);\n-    units.addAll(attackingWaitingToDie);\n+    fireAirOnNonSubs(\n+        defender.getName() + SELECT_CASUALTIES,\n+        \"Attacker's aircraft fire,\",\n+        false,\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void defendAirOnNonSubs() {\n+    fireAirOnNonSubs(\n+        attacker.getName() + SELECT_CASUALTIES,\n+        \"Defender's aircraft fire,\",\n+        true,\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n+  }\n+\n+  private void fireAirOnNonSubs(\n+      final String stepName,", "originalCommit": "97d2e060eb55787acc011ea8323359023b9eb495", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b", "url": "https://github.com/triplea-game/triplea/commit/e8d1c2d0370a3ace2cfa208888a790b043cfe96b", "message": "Add target groups to generize limited targets (air vs subs, subs vs air)", "committedDate": "2020-01-30T00:09:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4MQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372699981", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-30T00:11:27Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "originalCommit": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0Mjk0Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742943", "bodyText": "A test of this method would help review and add confidence this is completely working as expected. Such a test would give design feedback as well and potentially help drive further break down in responsibility to make it easier to test and understand.\nFor example, extracting 'findTargets' to its own module would be a first simplification that would help decompose the problem, ie: a targetFinder that is perhaps injected into this class.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5MzgzMg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373793832", "bodyText": "Refactored this a bit to break it up and rename some variables. I would eventually like to add unit tests to this since it is a pretty isolated functionality that should be easy to test. Not sure I'll have the time to do that in the next few days though so might be a better follow up.", "author": "ron-murhammer", "createdAt": "2020-02-01T18:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5OTkwMw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373799903", "bodyText": "Added unit tests.", "author": "ron-murhammer", "createdAt": "2020-02-01T20:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5OTk4Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372699983", "bodyText": "Method findTargets has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-30T00:11:27Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> firingGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      boolean isAdded = false;\n+      for (final TargetGroup firingGroup : firingGroups) {\n+        if (firingGroup.getTargetUnitTypes().equals(targets)) {\n+          firingGroup.getFiringUnitTypes().add(unitType);\n+          isAdded = true;\n+          break;\n+        }\n+      }\n+      if (!isAdded) {\n+        firingGroups.add(new TargetGroup(unitType, targets));\n+      }\n+    }\n+    return sortFiringGroups(firingGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(", "originalCommit": "e8d1c2d0370a3ace2cfa208888a790b043cfe96b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b79b9a94f95c88b799b75fedb085227983e4e152", "url": "https://github.com/triplea-game/triplea/commit/b79b9a94f95c88b799b75fedb085227983e4e152", "message": "Update first strike to use target groups", "committedDate": "2020-01-30T00:17:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwMjE4Mg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372702182", "bodyText": "Method firstStrikeFire has 8 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-30T00:19:08Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,169 +1893,115 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        true,\n+        defender,\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n-        defender.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        false,\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    firstStrikeFire(\n         returnFire,\n-        \"Subs fire,\");\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        false,\n+        attacker,\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n   }\n \n-  /** If there are no attacking DDs but defending SUBs, fire AIR at non-SUB forces ONLY. */\n-  private void attackAirOnNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(attackingUnits);\n-    units.addAll(attackingWaitingToDie);\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n-      final Collection<Unit> enemyUnitsNotSubs =\n-          CollectionUtils.getMatches(defendingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-      allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n+  private void firstStrikeFire(\n+      final ReturnFire returnFire,", "originalCommit": "b79b9a94f95c88b799b75fedb085227983e4e152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "948bbce0dc7233ca147927e39b0072699ba7fac8", "url": "https://github.com/triplea-game/triplea/commit/948bbce0dc7233ca147927e39b0072699ba7fac8", "message": "Merge first strike and standard fire methods", "committedDate": "2020-01-30T02:10:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcyOTIxNQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372729215", "bodyText": "Method findTargetGroupsAndFire has 9 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-30T02:12:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1949,167 +1893,91 @@ private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {\n     }\n   }\n \n-  private void defendSubs(final ReturnFire returnFire) {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> firing = new ArrayList<>(defendingUnits);\n-    firing.addAll(defendingWaitingToDie);\n-    firing = CollectionUtils.getMatches(firing, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsNotAir());\n-    if (attacked.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n-    fire(\n-        attacker.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        true,\n+  private void firstStrikeDefendersFire(final ReturnFire returnFire) {\n+    findTargetGroupsAndFire(\n         returnFire,\n-        \"Subs defend, \");\n+        attacker.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        true,\n+        defender,\n+        Matches.unitIsFirstStrike(),\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void attackSubs(final ReturnFire returnFire) {\n-    final Collection<Unit> firing =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike());\n-    if (firing.isEmpty()) {\n-      return;\n-    }\n-    final Collection<Unit> attacked =\n-        CollectionUtils.getMatches(defendingUnits, Matches.unitIsNotAir());\n-    // if there are destroyers in the attacked units, we can return fire.\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n-        defender.getName() + SELECT_SUB_CASUALTIES,\n-        firing,\n-        attacked,\n-        allEnemyUnitsAliveOrWaitingToDie,\n-        false,\n+  private void firstStrikeAttackersFire(final ReturnFire returnFire) {\n+    findTargetGroupsAndFire(\n         returnFire,\n-        \"Subs fire,\");\n-  }\n-\n-  /** If there are no attacking DDs but defending SUBs, fire AIR at non-SUB forces ONLY. */\n-  private void attackAirOnNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(attackingUnits);\n-    units.addAll(attackingWaitingToDie);\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n-      final Collection<Unit> enemyUnitsNotSubs =\n-          CollectionUtils.getMatches(defendingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-      allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-      fire(\n-          defender.getName() + SELECT_CASUALTIES,\n-          units,\n-          enemyUnitsNotSubs,\n-          allEnemyUnitsAliveOrWaitingToDie,\n-          false,\n-          ReturnFire.ALL,\n-          \"Attacker's aircraft fire,\");\n-    }\n+        defender.getName() + SELECT_FIRST_STRIKE_CASUALTIES,\n+        false,\n+        attacker,\n+        Matches.unitIsFirstStrike(),\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n   }\n \n-  /**\n-   * If there are no attacking DDs, but defending SUBs, remove attacking AIR as they've already\n-   * fired, otherwise fire all attackers.\n-   */\n-  private void attackNonSubs() {\n-    if (defendingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units =\n-        CollectionUtils.getMatches(attackingUnits, Matches.unitIsFirstStrike().negate());\n-    units.addAll(\n-        CollectionUtils.getMatches(attackingWaitingToDie, Matches.unitIsFirstStrike().negate()));\n-    // See if allied air can participate in combat\n-    if (!isAlliedAirIndependent()) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsOwnedBy(attacker));\n-    }\n-    // if restricted, remove aircraft from attackers\n-    if (!canAirAttackSubs(defendingUnits, units)) {\n-      units.removeAll(CollectionUtils.getMatches(units, Matches.unitIsAir()));\n-    }\n-    if (units.isEmpty()) {\n-      return;\n-    }\n-    final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(defendingUnits);\n-    allEnemyUnitsAliveOrWaitingToDie.addAll(defendingWaitingToDie);\n-    fire(\n+  private void standardAttackersFire() {\n+    findTargetGroupsAndFire(\n+        ReturnFire.ALL,\n         defender.getName() + SELECT_CASUALTIES,\n-        units,\n-        defendingUnits,\n-        allEnemyUnitsAliveOrWaitingToDie,\n         false,\n+        attacker,\n+        Matches.unitIsFirstStrike().negate(),\n+        attackingUnits,\n+        attackingWaitingToDie,\n+        defendingUnits,\n+        defendingWaitingToDie);\n+  }\n+\n+  private void standardDefendersFire() {\n+    findTargetGroupsAndFire(\n         ReturnFire.ALL,\n-        \"Attackers fire,\");\n+        attacker.getName() + SELECT_CASUALTIES,\n+        true,\n+        defender,\n+        Matches.unitIsFirstStrike().negate(),\n+        defendingUnits,\n+        defendingWaitingToDie,\n+        attackingUnits,\n+        attackingWaitingToDie);\n   }\n \n-  private void defendAirOnNonSubs() {\n-    if (attackingUnits.isEmpty()) {\n-      return;\n-    }\n-    Collection<Unit> units = new ArrayList<>(defendingUnits);\n-    units.addAll(defendingWaitingToDie);\n-    if (!canAirAttackSubs(attackingUnits, units)) {\n-      units = CollectionUtils.getMatches(units, Matches.unitIsAir());\n-      final Collection<Unit> enemyUnitsNotSubs =\n-          CollectionUtils.getMatches(attackingUnits, Matches.unitCanNotBeTargetedByAll().negate());\n-      if (enemyUnitsNotSubs.isEmpty()) {\n-        return;\n-      }\n-      final List<Unit> allEnemyUnitsAliveOrWaitingToDie = new ArrayList<>(attackingUnits);\n-      allEnemyUnitsAliveOrWaitingToDie.addAll(attackingWaitingToDie);\n+  private void findTargetGroupsAndFire(\n+      final ReturnFire returnFire,", "originalCommit": "948bbce0dc7233ca147927e39b0072699ba7fac8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f4779445748cf45fc367d1bb62c150aef62aba2b", "url": "https://github.com/triplea-game/triplea/commit/f4779445748cf45fc367d1bb62c150aef62aba2b", "message": "Remove old suicide methods and reorder", "committedDate": "2020-01-30T03:53:05Z", "type": "commit"}, {"oid": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d", "url": "https://github.com/triplea-game/triplea/commit/0ee6bc5eb27f7a2185ff13329d4df99f4059be5d", "message": "Fix bug with filtering out suicide units as targets", "committedDate": "2020-01-30T05:22:12Z", "type": "commit"}, {"oid": "acd8a4264a7ab567beb9a0a40f90985a17cdb031", "url": "https://github.com/triplea-game/triplea/commit/acd8a4264a7ab567beb9a0a40f90985a17cdb031", "message": "Add comment and deprecated", "committedDate": "2020-01-30T06:43:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTAwNQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372779005", "bodyText": "nit, not sure a casual reader will understand the comment to 'support isSuicide \"shortcut\"', they may wonder how it is a shortcut, and what 'isSuicide' is necessarily even referring to.", "author": "DanVanAtta", "createdAt": "2020-01-30T06:34:59Z", "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -689,10 +690,18 @@ private void setCanNotTarget(final Set<UnitType> value) {\n \n   public Set<UnitType> getCanNotTarget() {\n     if (canNotTarget == null) {\n-      canNotTarget =\n-          new HashSet<>(\n-              CollectionUtils.getMatches(\n-                  getData().getUnitTypeList().getAllUnitTypes(), Matches.unitTypeIsAir()));\n+      if (isSuicideOnAttack && isFirstStrike) { // Support isSuicide shortcut", "originalCommit": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MjU2Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372782567", "bodyText": "Ok. Do you have an alternative suggestion?", "author": "ron-murhammer", "createdAt": "2020-01-30T06:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MDc2Mg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373740762", "bodyText": "Some options:\n\nremove the comment\nexpound on the comment and provide links/references for context\nbake the 'isSuicide' into matches.\nMake 'CanTarget' a property of \"UnitType\", add explanations there\n\nThe last is probably my preferred approach followed by adding a specific matcher. I like the last approach as it has the best encapsulation and is the most easily tested (this section of code would be great to have tests for, it would make review easier and would lend more confidence this is working as intended).\nIs there a legit timeline of when we can retrofit all maps to not have 'isSuicide'? IMHO the bulk map update experiences we have had caused far more pain than they are worth, and we do not even have ownership of all maps, and there was a lot of pain there. Removing map features I don't think is feasible and is part of why I think it's important we add versioning to map syntax/formats. Regardless of your viewpoint there, having a 'Matches.isSuicide' is independent of it is an actual unit property and the matches is, like here, a composite property.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MDQ4Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373760486", "bodyText": "So the issue with that direction is that we really want to isolate and reduce where isSuicide is used as otherwise its confusing as whether the property is still being used throughout the delegates (which it isn't as its now just setting other properties). If I saw a matches isSuicide then I'm going to think its reading that property unless I go and specifically read that method. The idea here is to keep all the isSuicide functionality in the unit attachment so that it isn't leaked to the other classes.", "author": "ron-murhammer", "createdAt": "2020-02-01T05:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MDc2Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373760766", "bodyText": "Updated to remove comment.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTU4Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372779586", "bodyText": "nit, it's just the matches type that varies depending on the if condition, seems though the if/else could be simplified.\nBeyond the code low-level cleanup, why is the 'isSub' and 'isSuicide' properties opposites of one another? IE: why is if 'isSuicide' is false, then 'isSub' is true?", "author": "DanVanAtta", "createdAt": "2020-01-30T06:37:27Z", "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -689,10 +690,18 @@ private void setCanNotTarget(final Set<UnitType> value) {\n \n   public Set<UnitType> getCanNotTarget() {\n     if (canNotTarget == null) {\n-      canNotTarget =\n-          new HashSet<>(\n-              CollectionUtils.getMatches(\n-                  getData().getUnitTypeList().getAllUnitTypes(), Matches.unitTypeIsAir()));\n+      if (isSuicideOnAttack && isFirstStrike) { // Support isSuicide shortcut\n+        canNotTarget =\n+            new HashSet<>(\n+                CollectionUtils.getMatches(\n+                    getData().getUnitTypeList().getAllUnitTypes(),\n+                    Matches.unitTypeIsSuicideOnAttack().or(Matches.unitTypeIsSuicideOnDefense())));", "originalCommit": "0ee6bc5eb27f7a2185ff13329d4df99f4059be5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MzQwOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r372783408", "bodyText": "Possibly though I was concerned with it being harder to read if too much of it was inlined.\nThey aren't true opposites but because this is for supporting the deprecated properties, current maps never have isSub and isSuicide on the same unit as they didn't work together and isSuicide would override isSub as it would fire before.", "author": "ron-murhammer", "createdAt": "2020-01-30T06:53:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MDE5NQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373740195", "bodyText": "I don't think that would qualify as too much inlining, it helps a lot as it makes clear what is different between the two cases. You can assign to an intermediary variable if the inline syntax feels awkward.\n\nThey aren't true opposites...\n\nPoint taken, a casual reader would be very confused why we can assume with one condition being false that we fall into this other (seemingly very unrelated) case.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MDc1OA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373760758", "bodyText": "Updated.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3OTU4Ng=="}], "type": "inlineReview"}, {"oid": "e1229bdbb613fd471e150e8040858bbda8ac91b8", "url": "https://github.com/triplea-game/triplea/commit/e1229bdbb613fd471e150e8040858bbda8ac91b8", "message": "Fix isSuicide target setting", "committedDate": "2020-01-30T18:49:56Z", "type": "commit"}, {"oid": "e45366947243005208ef3c06e474eb0744ce5847", "url": "https://github.com/triplea-game/triplea/commit/e45366947243005208ef3c06e474eb0744ce5847", "message": "Fix battle window suicide unit casualty display", "committedDate": "2020-01-31T01:16:47Z", "type": "commit"}, {"oid": "87261f56df749663d812b6fe8cd2d1fd388456a3", "url": "https://github.com/triplea-game/triplea/commit/87261f56df749663d812b6fe8cd2d1fd388456a3", "message": "Improve removing suicide units from battle window earlier", "committedDate": "2020-01-31T05:09:12Z", "type": "commit"}, {"oid": "618906a97c18387623f1050f6c7d7cccaf0409a2", "url": "https://github.com/triplea-game/triplea/commit/618906a97c18387623f1050f6c7d7cccaf0409a2", "message": "Add overload diceRoll method and refactor", "committedDate": "2020-01-31T06:24:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjAzMA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742030", "bodyText": "It does not look like this setter is used. Can it be removed? Is this class actually immutable? If not, it looks like it would not take too much to make it so, is that feasible? Is there a reason for mutability?", "author": "DanVanAtta", "createdAt": "2020-02-01T00:44:34Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter", "originalCommit": "618906a97c18387623f1050f6c7d7cccaf0409a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MDg4NA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373760884", "bodyText": "Ah yes. Good catch. Originally I was using the setters but had reworked to avoid that.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:03:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjUzOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742538", "bodyText": "It looks like the getter here is used only internally. Unless I missed a usage, do you have any thoughts on removing the getter or restricting the visibility of the get method?\nLooking at the class, and the class properties, it raises a code smell if we return the internal data, it makes it seem as if the class were incompletely providing operations on the data members. IE: if this class provides operations on two internal sets, then what's the point to return the internal data unless this class is incomplete in doing so.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:48:27Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter", "originalCommit": "618906a97c18387623f1050f6c7d7cccaf0409a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MDkyNg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373760926", "bodyText": "The getters are used in MustFightBattle to pull the information out.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzc3OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763779", "bodyText": "I see that getFiringUnits and getTargetUnits are used in MustFightBattle, though the only usages of the generated getters are in TargetGroup. Can you point me to where they are in MustFightBattle, am I looking at the wrong diff or something?", "author": "DanVanAtta", "createdAt": "2020-02-01T07:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5MTYyOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373791628", "bodyText": "Ah I see. Yeah, I reduced the visibility of the getters.", "author": "ron-murhammer", "createdAt": "2020-02-01T17:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwMjQ1Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373802456", "bodyText": "Personally I would skip the generated getters altogether for more directness. It also makes it clear at the call site what we are doing and a reader would not have to verify where the getter is and if it could be overloaded.\nGood enough though marking the getter private to reduce its scope. \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-02-01T21:07:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjY1OA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742658", "bodyText": "It looks like this is always a singleton set, do I see that correctly? Why store this as a set if it always has size == 1?", "author": "DanVanAtta", "createdAt": "2020-02-01T00:49:20Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;", "originalCommit": "618906a97c18387623f1050f6c7d7cccaf0409a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MDk1Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373760953", "bodyText": "Nope. This holds all the unit types that have the same list of targets. They are added 1 by 1 as targets are checked.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjgwOQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373742809", "bodyText": "Nit, this method can be marked as static. It also seems to not really belong to this class as well (knowing it's static helps highlight that). Any thoughts to simply inline this to its single usage and avoid the indirection?", "author": "DanVanAtta", "createdAt": "2020-02-01T00:50:42Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+@Setter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {", "originalCommit": "618906a97c18387623f1050f6c7d7cccaf0409a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MTAyNA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373761024", "bodyText": "This is a bit of a forward looking method as the message ideally would be more detailed to include which unit types are firing or being targeted which that information lives in this class. For now it just says which player but you can imagine if you have different groups of targets so multiple TargetGroups that having more info on which of the units are firing or being targeted would be helpful.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MzY2OA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763668", "bodyText": "A TODO tagged with the forum discussion would have been ideal to have communicated that. Do you have an expectation when that would land (near-future, far-future?)", "author": "DanVanAtta", "createdAt": "2020-02-01T07:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5MTc0OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373791749", "bodyText": "Pushed it in line out of this class for now.", "author": "ron-murhammer", "createdAt": "2020-02-01T17:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MjgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MzEwMg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373743102", "bodyText": "\ud83d\udc4d   Good to see unused/placeholder args falling away.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:53:21Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/DiceRollTest.java", "diffHunk": "@@ -63,19 +63,19 @@ void testSimple() {\n         .thenAnswer(withValues(1)); // infantry attack does not hit at 1 (0 based)\n     // infantry defends\n     final DiceRoll roll =\n-        DiceRoll.rollDice(infantry, true, russians, bridge, battle, \"\", territoryEffects, null);\n+        DiceRoll.rollDice(infantry, true, russians, bridge, battle, territoryEffects);", "originalCommit": "618906a97c18387623f1050f6c7d7cccaf0409a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0MzI1MA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373743250", "bodyText": "\ud83d\udc4d   I like quite a bit we are making the ordering more generic and list 'first strike units' rather than assuming any/all first strike units are subs.", "author": "DanVanAtta", "createdAt": "2020-02-01T00:54:32Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/WW2V3Year41Test.java", "diffHunk": "@@ -1143,12 +1129,12 @@ void testAttackDestroyerAndSubsAgainstSubAndDestroyer() {\n     final List<String> steps = battle.determineStepStrings(true);\n     assertEquals(\n         List.of(\n-                attacker + SUBS_FIRE,\n-                defender + SELECT_SUB_CASUALTIES,\n+                attacker + FIRST_STRIKE_UNITS_FIRE,", "originalCommit": "618906a97c18387623f1050f6c7d7cccaf0409a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0NDA5Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373744093", "bodyText": "This deadUnit notification only appears in one branch of the unmodified code, for a case of isDefendingSuicideAndMunitionUnitsDoNotFire, why should this be shown now for all cases? Is this a no-op perhaps, is there something subtle that is not obvious?", "author": "DanVanAtta", "createdAt": "2020-02-01T01:01:02Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1805,25 +1805,16 @@ private void defenderRetreatSubs(final IDelegateBridge bridge) {\n    * Check for suicide units and kill them immediately (they get to shoot back, which is the point).\n    */\n   private void checkSuicideUnits(final IDelegateBridge bridge) {\n-    if (isDefendingSuicideAndMunitionUnitsDoNotFire()) {\n-      final List<Unit> deadUnits =\n-          CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicide());\n-      bridge\n-          .getDisplayChannelBroadcaster()\n-          .deadUnitNotification(battleId, attacker, deadUnits, dependentUnits);\n-      remove(deadUnits, bridge, battleSite, false);\n-    } else {\n-      final List<Unit> deadUnits = new ArrayList<>();\n-      deadUnits.addAll(CollectionUtils.getMatches(defendingUnits, Matches.unitIsSuicide()));\n-      deadUnits.addAll(CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicide()));\n-      bridge\n-          .getDisplayChannelBroadcaster()\n-          .deadUnitNotification(battleId, attacker, deadUnits, dependentUnits);\n-      bridge\n-          .getDisplayChannelBroadcaster()\n-          .deadUnitNotification(battleId, defender, deadUnits, dependentUnits);\n-      remove(deadUnits, bridge, battleSite, null);\n-    }\n+    final List<Unit> deadUnits = new ArrayList<>();\n+    deadUnits.addAll(CollectionUtils.getMatches(attackingUnits, Matches.unitIsSuicideOnAttack()));\n+    deadUnits.addAll(CollectionUtils.getMatches(defendingUnits, Matches.unitIsSuicideOnDefense()));\n+    bridge", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MTA2Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373761067", "bodyText": "I think you are looking at outdated code here.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0NDA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0NDU5OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373744599", "bodyText": "It's striking we have the same parameter passed in twice to a method. IMHO it is a pretty significant API code smell. Perhaps an extract parameter object refactor would fix that?\nIMO the existing API already has significant technical debt, I don't think that is fair reason to add more potential debt for someone else to attempt to fix. It's also very notable that a number of other parameters are already useless, seems like this API is already stretched.", "author": "DanVanAtta", "createdAt": "2020-02-01T01:05:12Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/PacificTest.java", "diffHunk": "@@ -108,20 +108,44 @@ void testNonJapanAttack() {\n     // Defending US infantry\n     DiceRoll roll =\n         DiceRoll.rollDice(\n-            infantryUs, true, americans, bridge, mock(IBattle.class), \"\", territoryEffects, null);\n+            infantryUs,\n+            true,\n+            americans,\n+            bridge,\n+            mock(IBattle.class),\n+            \"\",\n+            territoryEffects,\n+            null,\n+            infantryUs);", "originalCommit": "7e244f4d9c1c60f021bacdaf21c2606c914d4dbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MTA4Mg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373761082", "bodyText": "I think you are looking at outdated code here as well.", "author": "ron-murhammer", "createdAt": "2020-02-01T06:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0NDU5OQ=="}], "type": "inlineReview"}, {"oid": "f20102ef3e8ff6c07b4b2fceb8cd48f0ae208019", "url": "https://github.com/triplea-game/triplea/commit/f20102ef3e8ff6c07b4b2fceb8cd48f0ae208019", "message": "Refactor canNotTarget method", "committedDate": "2020-02-01T06:00:59Z", "type": "commit"}, {"oid": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "url": "https://github.com/triplea-game/triplea/commit/a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "message": "Remove unused setters", "committedDate": "2020-02-01T06:03:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzg4MA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763880", "bodyText": "Could you clarify or define 'restrictive' in this context? It's not clear to me from this context what that would exactly mean.", "author": "DanVanAtta", "createdAt": "2020-02-01T07:20:07Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.", "originalCommit": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5MTc4MA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373791780", "bodyText": "Updated.", "author": "ron-murhammer", "createdAt": "2020-02-01T17:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzk2MA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373763960", "bodyText": "Have you considered re-writing this with a stream+map+collect to remove the intermediary variables and the 'added' local tracking variable? Any thoughts to adding an explanatory comment to help indicate what operation we are doing here?", "author": "DanVanAtta", "createdAt": "2020-02-01T07:22:16Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> firingGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      boolean isAdded = false;\n+      for (final TargetGroup firingGroup : firingGroups) {\n+        if (firingGroup.getTargetUnitTypes().equals(targets)) {\n+          firingGroup.getFiringUnitTypes().add(unitType);\n+          isAdded = true;\n+          break;\n+        }\n+      }\n+      if (!isAdded) {\n+        firingGroups.add(new TargetGroup(unitType, targets));\n+      }\n+    }", "originalCommit": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5MTg5NA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373791894", "bodyText": "Open to it. If you want to suggest how you'd do it with streams then I'm glad to take a look. I didn't see an easy way to do it that was easy to understand.", "author": "ron-murhammer", "createdAt": "2020-02-01T17:37:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwMjM0Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373802347", "bodyText": "This should be equivalent:\n  private static void addToTargetGroups(\n      final UnitType unitType, final Set<UnitType> targets, final List<TargetGroup> targetGroups) {\n    targetGroups.stream()\n        .filter(targetGroup -> targetGroup.getTargetUnitTypes().equals(targets))\n        .findAny()\n        .ifPresentOrElse(\n            targetGroup -> targetGroup.getFiringUnitTypes().add(unitType),\n            () -> targetGroups.add(new TargetGroup(unitType, targets)));\n  }", "author": "DanVanAtta", "createdAt": "2020-02-01T21:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwMjQ5OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373802499", "bodyText": "Actually.. maybe not, taking another look..", "author": "DanVanAtta", "createdAt": "2020-02-01T21:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwMjUxNg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373802516", "bodyText": "Okay, didn't take long, yeah, I think the above should be equivalent.", "author": "DanVanAtta", "createdAt": "2020-02-01T21:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxMDQ5OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373810499", "bodyText": "Yep that works. Updated.", "author": "ron-murhammer", "createdAt": "2020-02-02T00:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NDA0NA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373764044", "bodyText": "nit, noneMatch should be able to replace the !...anyMatch() and help avoid the negation", "author": "DanVanAtta", "createdAt": "2020-02-01T07:24:04Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  public String getMessage(final GamePlayer player) {\n+    return player.getName() + \" fire, \";\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so most restrictive appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> firingGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      boolean isAdded = false;\n+      for (final TargetGroup firingGroup : firingGroups) {\n+        if (firingGroup.getTargetUnitTypes().equals(targets)) {\n+          firingGroup.getFiringUnitTypes().add(unitType);\n+          isAdded = true;\n+          break;\n+        }\n+      }\n+      if (!isAdded) {\n+        firingGroups.add(new TargetGroup(unitType, targets));\n+      }\n+    }\n+    return sortFiringGroups(firingGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(\n+      final UnitType unitType, final Set<UnitType> unitTypes, final Set<UnitType> enemyUnitTypes) {\n+    final Set<UnitType> targets = new HashSet<>(enemyUnitTypes);\n+    targets.removeAll(UnitAttachment.get(unitType).getCanNotTarget());\n+    if (!unitTypes.stream().anyMatch(Matches.unitTypeIsDestroyer())) {", "originalCommit": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5MjAwMg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373792002", "bodyText": "Good catch. Updated.", "author": "ron-murhammer", "createdAt": "2020-02-01T17:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2NDA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373767959", "bodyText": "The set to null might be potentially dangerous / NPE if setCanNotTarget is invoked after setIsSuicide, noting on line 683:\n  private void setCanNotTarget(final String value) throws GameParseException {\n    final String[] s = splitOnColon(value);\n    for (final String u : s) {\n      final UnitType ut = getData().getUnitTypeList().getUnitType(u);\n      if (ut == null) {\n        throw new GameParseException(\"canNotTarget: no such unit type: \" + u + thisErrorMsg());\n      }\n683:      canNotTarget.add(ut);\n    }\n  }\n\nWould that be a potential problem?", "author": "DanVanAtta", "createdAt": "2020-02-01T09:03:18Z", "path": "game-core/src/main/java/games/strategy/triplea/attachments/UnitAttachment.java", "diffHunk": "@@ -1751,20 +1756,54 @@ private void resetCanDieFromReachingMaxDamage() {\n     canDieFromReachingMaxDamage = false;\n   }\n \n+  @Deprecated\n   private void setIsSuicide(final String s) {\n-    isSuicide = getBool(s);\n+    setIsSuicide(getBool(s));\n   }\n \n+  @Deprecated\n   private void setIsSuicide(final Boolean s) {\n-    isSuicide = s;\n+    setIsSuicideOnAttack(s);\n+    // Global property controlled whether isSuicide units would suicide on defense\n+    setIsSuicideOnDefense(s && !Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(getData()));\n+    setIsFirstStrike(s);\n+    if (s) {\n+      canNotTarget = null;", "originalCommit": "a2bf05f3dee478ba4c4a2cb6c375d384ccafae74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2ODAxMg==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373768012", "bodyText": "Second, the set to null seems to rely that any access to canNotTarget will go through a get method which has the side effect of also setting canNotTarget if null. Could this be fixed and/or be made more explicit by doing an assignment here of that value? (this seems kinda hacky, but it perhaps it makes things explicit at least):\nif(s) {\n  canNotTarget = getCanNotTarget();\n}", "author": "DanVanAtta", "createdAt": "2020-02-01T09:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc5MjUxMA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373792510", "bodyText": "setCanNotTarget and setIsSuicide should never be used in the same map and definitely not on the same unit. setIsSuicide is just for existing map compatibility.\nThat's correct. The reason for this is you can't set the canNotTarget until all the XML unit attachments are parsed (as you need to read some of the unit properties) so has to happen essentially after all unit parsing is done. This was the easiest way I could think to do it and the only way to access it is through the getter (null is essentially being used as a place holder to flag that canNotTarget needs to still be calculated). This is a bit hacky but without adding some sort of placeholder state or extra parsing steps, I couldn't think of a better way to do it.", "author": "ron-murhammer", "createdAt": "2020-02-01T17:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwMTgxNw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373801817", "bodyText": "I understand that setCanNotTarget and setIsSuicide are now being considered incompatible settings. Will the failure mode when that is done be a NPE? I suspect eventually, on some map, we'll see the two settings be combined and the NPE would be an unhelpful error message.\nIf we could get it so that the system fails with an exact error message (EG: unsupported option combination) and tells the user what/where, that would be quite valuable and we would handling this situation well enough.\nCould we possibly achieve that by adding a null-guard in the 'setCanNotTarget' method and then adding a post-processing check if the two settings have been used together? Second question, do we really need to set canNotTarget to null? If we can avoid the null, then it may simplify the need for null-checks and perhaps we could have the two options exist with each other, but perhaps the behavior would be non-deterministic.", "author": "DanVanAtta", "createdAt": "2020-02-01T20:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwMjI5OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373802299", "bodyText": "Yeah, you'll get a NPE pointing to that method which will make it pretty obvious what the issue is. I don't expect it to ever happen and it would only be a map maker which would see it and probably just post on the forum. We can add checks to try to check for the null and return a better message just wondering if we are over engineering something that I don't think will ever happen.\nYou could avoid setting the null by setting some other say boolean field that then is checked instead of checking for the null in the getter though you are then adding additional temporary fields into a class that already has a lot of members variables. Not sure if that is really better or worse but was the other option I considered.", "author": "ron-murhammer", "createdAt": "2020-02-01T21:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwMzMxMQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373803311", "bodyText": "It's always surprising the data combinations/states that eventually wind up happening. Realistically we could maybe see it if a map were being retrofitted, or an existing map copied and then updated to be something else and the map maker missed an occurrence of the extra option.\nHere's perhaps an idea:\n\ncheck for a null value of canNotTarget in the setter, rather than NPE, throw an illegal state at the beginning of the setter. That would provide a way to give a direct message to indicate that an incompatible setting option was used.", "author": "DanVanAtta", "createdAt": "2020-02-01T21:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgxMDgwNw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373810807", "bodyText": "Added null check and custom exception message.", "author": "ron-murhammer", "createdAt": "2020-02-02T00:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Nzk1OQ=="}], "type": "inlineReview"}, {"oid": "825fab6207cdb9c40240924cf97a3825c8a09783", "url": "https://github.com/triplea-game/triplea/commit/825fab6207cdb9c40240924cf97a3825c8a09783", "message": "Use mapper helper method to reduce needed methods", "committedDate": "2020-02-01T16:49:30Z", "type": "commit"}, {"oid": "ef7cb2eebcf41feee7e9d83d61fef4d4f3e35397", "url": "https://github.com/triplea-game/triplea/commit/ef7cb2eebcf41feee7e9d83d61fef4d4f3e35397", "message": "Reduce getter visibility", "committedDate": "2020-02-01T17:31:06Z", "type": "commit"}, {"oid": "c10e900d63431f02c394e910d1fb50491e659a2a", "url": "https://github.com/triplea-game/triplea/commit/c10e900d63431f02c394e910d1fb50491e659a2a", "message": "Move message functionality in line", "committedDate": "2020-02-01T17:33:46Z", "type": "commit"}, {"oid": "86fef31414b37cd8ed56d6c575c1908d46e5c817", "url": "https://github.com/triplea-game/triplea/commit/86fef31414b37cd8ed56d6c575c1908d46e5c817", "message": "Update comment", "committedDate": "2020-02-01T17:34:48Z", "type": "commit"}, {"oid": "e43cc9151b6191d214dbe2dcd95cc8b7bc2f18eb", "url": "https://github.com/triplea-game/triplea/commit/e43cc9151b6191d214dbe2dcd95cc8b7bc2f18eb", "message": "Replace negated anyMatch with noneMatch", "committedDate": "2020-02-01T17:38:54Z", "type": "commit"}, {"oid": "b132dee1943b2cee302c1105387cfa8af3cfa6e3", "url": "https://github.com/triplea-game/triplea/commit/b132dee1943b2cee302c1105387cfa8af3cfa6e3", "message": "Refactor TargetGroup", "committedDate": "2020-02-01T18:13:07Z", "type": "commit"}, {"oid": "cd88b5adab4bb79e5a59ccf71cbaf336d1bcd2c6", "url": "https://github.com/triplea-game/triplea/commit/cd88b5adab4bb79e5a59ccf71cbaf336d1bcd2c6", "message": "Rename variable", "committedDate": "2020-02-01T18:15:41Z", "type": "commit"}, {"oid": "70ce42ef5472fabf34777b054200f721696dc57c", "url": "https://github.com/triplea-game/triplea/commit/70ce42ef5472fabf34777b054200f721696dc57c", "message": "Add unit tests for TargetGroup", "committedDate": "2020-02-01T20:14:46Z", "type": "commit"}, {"oid": "7bb504fa3c49f996059abcedc47859808a087b2b", "url": "https://github.com/triplea-game/triplea/commit/7bb504fa3c49f996059abcedc47859808a087b2b", "message": "Refactor to use streams", "committedDate": "2020-02-02T00:32:16Z", "type": "commit"}, {"oid": "4720f7a8962bbcc430de07a7e10161e755ed6008", "url": "https://github.com/triplea-game/triplea/commit/4720f7a8962bbcc430de07a7e10161e755ed6008", "message": "Add null check", "committedDate": "2020-02-02T00:40:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDY3MQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373890671", "bodyText": "nit: https://github.com/triplea-game/triplea/wiki/Java-Test-Code-Conventions#favor-hamcrest-assertthat-for-new-tests--5526\nassertEquals(0, results.size()) -> assertThat(results, is(emptyCollection())", "author": "DanVanAtta", "createdAt": "2020-02-03T00:53:11Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/TargetGroupTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.AbstractDelegateTestCase;\n+import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.xml.TestMapGameData;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class TargetGroupTest extends AbstractDelegateTestCase {\n+\n+  final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnitsAndEnemyUnits() {\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), List.of());\n+    assertEquals(0, result.size());", "originalCommit": "4720f7a8962bbcc430de07a7e10161e755ed6008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ1MDczOQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374450739", "bodyText": "Done.", "author": "ron-murhammer", "createdAt": "2020-02-04T02:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDg4OQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373890889", "bodyText": "https://github.com/triplea-game/triplea/wiki/Java-Test-Code-Conventions#favor-adding-displayname-to-each-test-case-5525\nIt's not 100% clear why the result should be empty. A @DisplayName would help this potentially.\nIt looks like the empty result is because the first List.of() parameter is empty. A comment in the assertThat method can also be used to help clarify why we expect the test to be true. (a convention for this is nearly finalized: #5527)\nSide-note, it's a very important aspect of test maintainability that it's obvious why they should pass. The combination of @DisplayName and assertion comments is intended to make it obvious on each test case.", "author": "DanVanAtta", "createdAt": "2020-02-03T00:56:12Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/TargetGroupTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.AbstractDelegateTestCase;\n+import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.xml.TestMapGameData;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class TargetGroupTest extends AbstractDelegateTestCase {\n+\n+  final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnitsAndEnemyUnits() {\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test", "originalCommit": "4720f7a8962bbcc430de07a7e10161e755ed6008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ1MDcwNw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374450707", "bodyText": "Done.", "author": "ron-murhammer", "createdAt": "2020-02-04T02:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwOTIyOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374509228", "bodyText": "Cool, thanks, this comment:\n   \"Verify 2 target groups if sub and fighters attack sub and fighters as subs can only \"\n          + \"target subs\")\n\n\nwas actually really key to understanding the rest of them, IMHO it helped quite a bit.  \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-02-04T07:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDk3Nw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373890977", "bodyText": "nit: assertEquals(1, results.size()) -> assertThat(result, hasSize(1))", "author": "DanVanAtta", "createdAt": "2020-02-03T00:57:17Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/TargetGroupTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.AbstractDelegateTestCase;\n+import games.strategy.triplea.delegate.GameDataTestUtil;\n+import games.strategy.triplea.xml.TestMapGameData;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+\n+class TargetGroupTest extends AbstractDelegateTestCase {\n+\n+  final GameData twwGameData = TestMapGameData.TWW.getGameData();\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnitsAndEnemyUnits() {\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyUnits() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> enemyUnits = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(List.of(), enemyUnits);\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsWithEmptyEnemyUnits() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> units = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(units, List.of());\n+    assertEquals(0, result.size());\n+  }\n+\n+  @Test\n+  void testNewTargetGroupsForOneUnitAndOneEnemyUnit() {\n+    final GamePlayer germany = GameDataTestUtil.germany(twwGameData);\n+    final List<Unit> units = GameDataTestUtil.germanInfantry(twwGameData).create(1, germany);\n+    final GamePlayer britain = GameDataTestUtil.britain(twwGameData);\n+    final List<Unit> enemyUnits = GameDataTestUtil.britishInfantry(twwGameData).create(1, britain);\n+    final List<TargetGroup> result = TargetGroup.newTargetGroups(units, enemyUnits);\n+    assertEquals(1, result.size());", "originalCommit": "4720f7a8962bbcc430de07a7e10161e755ed6008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MTEzNA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373891134", "bodyText": "As noted once, but ditto and for the rest of the tests, an assertion comment and/or displayname to explicitly state why we expect the various assertion conditions to be true would go a long way to making it trivial to understand these tests - in that case if any should break it would be much easier to fix them and skips the preliminary step of investigating why the test was correct to begin with.", "author": "DanVanAtta", "createdAt": "2020-02-03T00:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MzMxMA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373893310", "bodyText": "FWIW, if it makes the static imports any easier, I keep a file around with the imports below, then use clean-up imports to remove any that I do not use when done writing a test:\nimport static org.hamcrest.collection.IsCollectionWithSize.hasSize;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static com.github.npathai.hamcrestopt.OptionalMatchers.isEmpty;\nimport static com.github.npathai.hamcrestopt.OptionalMatchers.isPresent;\nimport static com.github.npathai.hamcrestopt.OptionalMatchers.isPresentAndIs;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.nullValue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;", "author": "DanVanAtta", "createdAt": "2020-02-03T01:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ1MDY5Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374450693", "bodyText": "Done.", "author": "ron-murhammer", "createdAt": "2020-02-04T02:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg5MDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373916134", "bodyText": "This looks strange, could you check this @ron-murhammer ? It looks like targetGroups is always empty.  Was the iteration supposed to be on targets?", "author": "DanVanAtta", "createdAt": "2020-02-03T04:14:54Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> targetGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      addToTargetGroups(unitType, targets, targetGroups);\n+    }\n+    return sortTargetGroups(targetGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(\n+      final UnitType unitType, final Set<UnitType> unitTypes, final Set<UnitType> enemyUnitTypes) {\n+    final Set<UnitType> targets = new HashSet<>(enemyUnitTypes);\n+    targets.removeAll(UnitAttachment.get(unitType).getCanNotTarget());\n+    return unitTypes.stream().anyMatch(Matches.unitTypeIsDestroyer())\n+        ? targets\n+        : targets.stream()\n+            .filter(\n+                target -> !UnitAttachment.get(target).getCanNotBeTargetedBy().contains(unitType))\n+            .collect(Collectors.toSet());\n+  }\n+\n+  private static void addToTargetGroups(\n+      final UnitType unitType, final Set<UnitType> targets, final List<TargetGroup> targetGroups) {\n+    if (targets.isEmpty()) {\n+      return;\n+    }\n+    targetGroups.stream()", "originalCommit": "4720f7a8962bbcc430de07a7e10161e755ed6008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTA0NA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374445044", "bodyText": "Its correct. It will be empty on the first call to this method but then future calls will be looking at existing TargetGroup in the list to see whether to add to that group or add a new TargetGroup.", "author": "ron-murhammer", "createdAt": "2020-02-04T02:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMjk3MQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374502971", "bodyText": "Ah, I see it now. It's a bit counter-intuitive for a loop or a stream to have an effect when the iterated item is empty.\nIt could be worthwhile IMO then, for explicitness/clarity, to special case this situation. IE:\nif(targetGroups.isEmpty()) {\n  targetGroiups.add(new TargetGroup(unitType, targets);\n  return;\n}\n\n\nThough, I think it's now more clear to me how we could avoid the mutable 'in/out' parameter, IMHO it would be even better if we returned a value (and also the name of this method becomes a bit easier to refine), eg:\n\n private static Optional<TargetGroup>  findTargetInTargetGroups( final UnitType unitType, final Set<UnitType> targets, final List<TargetGroup> targetGroups) {\n     return targetGroups.stream()\n              .filter(targetGroup -> targetGroup.getTargetUnitTypes().equals(targets))\n              .findAny()\n}\n\nThen the for loop where this is used becomes a bit more clear and the overall control-flow IMO I think is more evident:\n    for (final UnitType unitType : unitTypes) {\n      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n     targetGroups.add(\n           findTargetInTargetGroups(unitType, targets, targetGroups).orElseGet(() -> new TargetGroup(unitType, targets)));\n    }\n\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-02-04T07:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY0MTk3NA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r375641974", "bodyText": "I'm fairly certain that isn't equivalent as it would add the same TargetGroup to the list multiple times. Now you could probably change to an ordered set instead of a list and I think that would then work.\nSo I generally agree with trying to avoid mutable parameters but this alternative seems harder to understand as you really shouldn't be adding to targetGroups if you find identical targets and instead add to an existing TargetGroup.\nSo probably if you want mutable parameters then you could do something like:\nOptional<TargetGroup> targetGroup = findTargetInTargetGroups(unitType, targets, targetGroups);\nif (targetGroup.isPresent()) {\n// add unit type to existing target group\n} else {\n// create and add new target group to list\n}\n\nThoughts? I'm fairly neutral on that vs the existing method as it avoids the mutable parameter but ends up being a lot more verbose.", "author": "ron-murhammer", "createdAt": "2020-02-06T05:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NDAyOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376184028", "bodyText": "Perhaps being more verbose is okay. I do think we need a change here as this was not easy to grok. Let me please clarify what I think are the problems so that we can be on the same page:\n\n\n(biggest): The pattern of streaming on an empty list to then append to that list is a bit novel and surprising. I had to double check that it even worked. This perhaps could be solved by special casing the empty list scenario and appending, otherwise do the find.\n\n\nThe break up of:\n\n\nfor loop\n   do something\n   do more stuff\ndone\n\nIs not necessarily helpful. The 'do more stuff' piece does not take all of the logic or even a complete step out of the for loop. To understand the for loop, you really have to jump down two methods to see what side-effects occur. Having the 'do more stuff' function be functional could fix this as you would have different levels of abstraction, rather than part of the for loop simply moved elsewhere (indirection as opposed to abstraction). This could also be solved by simply inlining, but I think we want an abstraction, ie: a method call to calculate a result that is then used in the for loop.\n\nThe mutable in parameter, this I think is probably more a symptom of the second problem.\n\nWith that stated, I think we'll at least be on the same page. Also for consideration, I've been wondering if we want a multimap instead of a list. The multimap would take care for us of the adding a new element if none is there, otherwise we append to an existing list. That perhaps could simplify/remove some of the helper methods.", "author": "DanVanAtta", "createdAt": "2020-02-07T02:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE5NjA3Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376196076", "bodyText": "Updated. Not sure where else to take it. I think we generally agree on the drawbacks but they aren't necessarily easy to solve without adding in other drawbacks as the logic here is fairly complex (we aren't just making a CRUD app). We are also getting to the point of essentially debating the design of a few methods which while important, we've already taken a few passes on and this PR is pretty large and been open for a while. I think at some point we have to push forward and consider follow on PRs if there are some ideas on how to further improve it.", "author": "ron-murhammer", "createdAt": "2020-02-07T03:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIwMzYwNw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376203607", "bodyText": "Generally agree, some quick comments:\n\ntactical design should be reasonable and not add debt unless there is a really strong trade-off to be made. Quick follow-ups for cleanup are not really a good thing.\nlarge PRs will tend to be open for a long time as they cannot be reviewed quickly. The size of a PR will also lead to more areas of feedback and it's less efficient to come back and re-review. Consider it to another extent, if someone wanted to game the review system, then to get less review, just open larger PRs. I think the rule of thumb is about 30 minutes per 200 lines of code (https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/). Hence, at 600 lines, you're requiring a dedicated 90 minutes. Given our time limitations, that means at least multiple days for a first pass only.\n\nI think perhaps the better way to go would be more iterations, smaller changes, and decoupling updates. If for example the TargetGroup were all on its own, it probably could have been more efficiently reviewed and would not have blocked anything else. It is water under the bridge at this point though, and I also appreciate how much effort it takes to break up larger changes as I certainly have, multiple times, spent literally days breaking up 600-1000 lines PRs", "author": "DanVanAtta", "createdAt": "2020-02-07T03:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjQ3NQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373916475", "bodyText": "nit, addToTargetGroups could be a bit more descriptive. Notably, I'm curious/not sure what exactly we are adding to target groups. I'm not honestly 100% sure how to describe what we're adding to target groups here, sorry to not have good suggestions for you on-hand.\nSecond, bit of a side note, if you're able to see a way, would be nice as well to be able to return a result rather than modifying the input param targetGroups.  In which case up on line 55 we could have something like:\ntargetGroups.addEligibleTargets(unitType, targets);", "author": "DanVanAtta", "createdAt": "2020-02-03T04:17:18Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {\n+\n+    final Set<UnitType> unitTypes =\n+        units.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final Set<UnitType> enemyUnitTypes =\n+        enemyUnits.stream().map(unit -> unit.getType()).collect(Collectors.toSet());\n+    final List<TargetGroup> targetGroups = new ArrayList<TargetGroup>();\n+    for (final UnitType unitType : unitTypes) {\n+      final Set<UnitType> targets = findTargets(unitType, unitTypes, enemyUnitTypes);\n+      addToTargetGroups(unitType, targets, targetGroups);\n+    }\n+    return sortTargetGroups(targetGroups);\n+  }\n+\n+  private static Set<UnitType> findTargets(\n+      final UnitType unitType, final Set<UnitType> unitTypes, final Set<UnitType> enemyUnitTypes) {\n+    final Set<UnitType> targets = new HashSet<>(enemyUnitTypes);\n+    targets.removeAll(UnitAttachment.get(unitType).getCanNotTarget());\n+    return unitTypes.stream().anyMatch(Matches.unitTypeIsDestroyer())\n+        ? targets\n+        : targets.stream()\n+            .filter(\n+                target -> !UnitAttachment.get(target).getCanNotBeTargetedBy().contains(unitType))\n+            .collect(Collectors.toSet());\n+  }\n+\n+  private static void addToTargetGroups(", "originalCommit": "4720f7a8962bbcc430de07a7e10161e755ed6008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDU0OA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374444548", "bodyText": "I can't think of any better name. Essentially its adding the unit type and targets to either an exist target group or adding a new target group.\nA method call like that wouldn't be possible unless you made TargetGroups a separate class instead of a list.", "author": "ron-murhammer", "createdAt": "2020-02-04T02:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNjQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxOTQ4MQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r373919481", "bodyText": "I see AI is tearing through this method quite frequently while simulating battles. Would it make sense to early return an empty list here if either of the input parameters are empty? I'm wondering if that might help performance a bit, particularly if unit stacks get to be very large, and secondly it might help a code maintainer grok this method to quickly know this method is effectively a no-op if either parameter is empty.", "author": "DanVanAtta", "createdAt": "2020-02-03T04:36:50Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(\n+      final Collection<Unit> units, final Collection<Unit> enemyUnits) {", "originalCommit": "4720f7a8962bbcc430de07a7e10161e755ed6008", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0Mzg3Mw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374443873", "bodyText": "Uh we could though I don't expect it to have much performance impact (probably <1%). If you did some tests and saw differently then I'd definitely look to add that in.", "author": "ron-murhammer", "createdAt": "2020-02-04T02:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxOTQ4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMzMxOA==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r374503318", "bodyText": "Yeah, I don't think there would be a huge performance win, maybe if the stack sizes were very large. It's more an early termination to make it easier for a reader to see when the method is a no-op, similar to the if-guard you have in another method (line 74)\n    if (targets.isEmpty()) {\n      return;\n    }", "author": "DanVanAtta", "createdAt": "2020-02-04T07:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxOTQ4MQ=="}], "type": "inlineReview"}, {"oid": "a0ed40f5e41b0a4cd71bd94f3cf76d5916c2ae7c", "url": "https://github.com/triplea-game/triplea/commit/a0ed40f5e41b0a4cd71bd94f3cf76d5916c2ae7c", "message": "Refactor unit tests", "committedDate": "2020-02-04T02:50:02Z", "type": "commit"}, {"oid": "de213100360178d0859e9aa35f8317ebb81956c9", "url": "https://github.com/triplea-game/triplea/commit/de213100360178d0859e9aa35f8317ebb81956c9", "message": "Fix formatting issue", "committedDate": "2020-02-04T03:02:43Z", "type": "commit"}, {"oid": "506169c46c2520e9892f623cea27d7a9ff1b65d4", "url": "https://github.com/triplea-game/triplea/commit/506169c46c2520e9892f623cea27d7a9ff1b65d4", "message": "Update unit test to check can not target property is set", "committedDate": "2020-02-06T05:21:54Z", "type": "commit"}, {"oid": "9bda17c03b303952f37419a1df26de5d4670514a", "url": "https://github.com/triplea-game/triplea/commit/9bda17c03b303952f37419a1df26de5d4670514a", "message": "Refactor to avoid mutable parameters", "committedDate": "2020-02-07T03:09:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE5NTQ3Ng==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376195476", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-02-07T03:11:17Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "originalCommit": "9bda17c03b303952f37419a1df26de5d4670514a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e34ed1cf5c838b7cf400c587d79a899915d7ada3", "url": "https://github.com/triplea-game/triplea/commit/e34ed1cf5c838b7cf400c587d79a899915d7ada3", "message": "Remove unused parameter", "committedDate": "2020-02-07T03:27:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE5OTMzMw==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376199333", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-02-07T03:29:30Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "originalCommit": "e34ed1cf5c838b7cf400c587d79a899915d7ada3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c38ef18f8e4d4a1f3822bd157e94d88595fb08d", "url": "https://github.com/triplea-game/triplea/commit/4c38ef18f8e4d4a1f3822bd157e94d88595fb08d", "message": "Merge remote-tracking branch 'origin' into Enhance_Suicide_Options", "committedDate": "2020-02-07T03:53:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIwNDA0MQ==", "url": "https://github.com/triplea-game/triplea/pull/5871#discussion_r376204041", "bodyText": "Method newTargetGroups has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-02-07T03:54:32Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/TargetGroup.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import com.google.common.collect.Sets;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Group of firing units and their targets. */\n+@Getter(AccessLevel.PRIVATE)\n+public class TargetGroup {\n+\n+  private final Set<UnitType> firingUnitTypes;\n+  private final Set<UnitType> targetUnitTypes;\n+\n+  public TargetGroup(final UnitType firingUnitType, final Set<UnitType> targetUnitTypes) {\n+    firingUnitTypes = Sets.newHashSet(firingUnitType);\n+    this.targetUnitTypes = targetUnitTypes;\n+  }\n+\n+  public Collection<Unit> getFiringUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(firingUnitTypes));\n+  }\n+\n+  public Collection<Unit> getTargetUnits(final Collection<Unit> units) {\n+    return CollectionUtils.getMatches(units, Matches.unitIsOfTypes(targetUnitTypes));\n+  }\n+\n+  /**\n+   * Find all target groupings for firing units and enemy units based on canNotTarget and\n+   * canNotBeTargetedBy attributes. Also takes into account if any destroyers are present which\n+   * cancel canNotBeTargetedBy. Sort all the target groups so those with the least number of targets\n+   * appear first.\n+   */\n+  public static List<TargetGroup> newTargetGroups(", "originalCommit": "4c38ef18f8e4d4a1f3822bd157e94d88595fb08d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}