{"pr_number": 6187, "pr_title": "Optimize findMaxLandMassSize() which can take 10% of AI time.", "pr_createdAt": "2020-04-11T14:02:33Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6187", "timeline": [{"oid": "bb1b3abf78c7c98accfcf520d5bc8fe7ee67863c", "url": "https://github.com/triplea-game/triplea/commit/bb1b3abf78c7c98accfcf520d5bc8fe7ee67863c", "message": "Optimize findMaxLandMassSize() which can take 10% of AI time.\n\nThis change optimized findMaxLandMassSize() by reducing the amount\nof work needed to do. The main difference is we now keep track of\nland territories already processed so that we don't need to start\nnew search from them.\n\nThis creates a new BreadthFirstSearch class that takes out the\nBFS implementation I implemented earlier for finding capitals, so\nthat it can be re-used here.\n\nIt also fixes a correctness issue with finding the max land size -\nthe previous search would only search up to a distance of 6. The\nnew implementation does not have this limitation.\n\nOn Domination 1914 map, which has a lot of territories, this saves\nabout 50 seconds of CPU time over a turn of an all-AI game.", "committedDate": "2020-04-11T13:48:57Z", "type": "commit"}, {"oid": "9f771929c77c96d9c3fce9930dfdff12a5e47063", "url": "https://github.com/triplea-game/triplea/commit/9f771929c77c96d9c3fce9930dfdff12a5e47063", "message": "Optimize findMaxLandMassSize() which can take 10% of AI time.\n\nThis change optimized findMaxLandMassSize() by reducing the amount\nof work needed to do. The main difference is we now keep track of\nland territories already processed so that we don't need to start\nnew search from them.\n\nThis creates a new BreadthFirstSearch class that takes out the\nBFS implementation I implemented earlier for finding capitals, so\nthat it can be re-used here.\n\nIt also fixes a correctness issue with finding the max land size -\nthe previous search would only search up to a distance of 6. The\nnew implementation does not have this limitation.\n\nOn Domination 1914 map, which has a lot of territories, this saves\nabout 50 seconds of CPU time over a turn of an all-AI game.", "committedDate": "2020-04-11T13:58:47Z", "type": "commit"}, {"oid": "0868bb8ea82ddc52417abccc5264b3ac71beaec4", "url": "https://github.com/triplea-game/triplea/commit/0868bb8ea82ddc52417abccc5264b3ac71beaec4", "message": ".", "committedDate": "2020-04-11T14:00:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA2Nzg2MA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407067860", "bodyText": "Method search has a Cognitive Complexity of 12 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-11T14:04:05Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import lombok.Getter;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  private final GameMap map;\n+  @Getter private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<Territory>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));\n+    this.cond = cond;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Called when a new territory is encountered. Can be overridden to provide custom search\n+   * behavior.\n+   *\n+   * @param territory The new territory.\n+   */\n+  public void visit(final Territory territory) {}\n+\n+  /**\n+   * Called after all territories within the specified distance have been searched. Can be\n+   * overridden to terminate the search.\n+   *\n+   * @param distanceSearched The current distance searched\n+   * @return Whether the search should continue.\n+   */\n+  public boolean shouldContinueSearch(final int distanceSearched) {\n+    return true;\n+  }\n+\n+  /**\n+   * Performs the search. It will end when either all territories have been visited or\n+   * shouldContinueSearch() returns false.\n+   */\n+  public void search() {", "originalCommit": "0868bb8ea82ddc52417abccc5264b3ac71beaec4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "13808f1e9d2070362f30af3cc25caa04fd294b04", "url": "https://github.com/triplea-game/triplea/commit/13808f1e9d2070362f30af3cc25caa04fd294b04", "message": "Add a unit test.", "committedDate": "2020-04-11T14:48:30Z", "type": "commit"}, {"oid": "733070c1a7715c9e0e78103128a4e46bc1efac49", "url": "https://github.com/triplea-game/triplea/commit/733070c1a7715c9e0e78103128a4e46bc1efac49", "message": "Make a helper function to reduce complexity.", "committedDate": "2020-04-11T15:06:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3NDQ3Mw==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407074473", "bodyText": "Method search has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-11T15:08:09Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import lombok.Getter;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  private final GameMap map;\n+  @Getter private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<Territory>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));\n+    this.cond = cond;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Called when a new territory is encountered. Can be overridden to provide custom search\n+   * behavior.\n+   *\n+   * @param territory The new territory.\n+   */\n+  public void visit(final Territory territory) {}\n+\n+  /**\n+   * Called after all territories within the specified distance have been searched. Can be\n+   * overridden to terminate the search.\n+   *\n+   * @param distanceSearched The current distance searched\n+   * @return Whether the search should continue.\n+   */\n+  public boolean shouldContinueSearch(final int distanceSearched) {\n+    return true;\n+  }\n+\n+  /**\n+   * Performs the search. It will end when either all territories have been visited or\n+   * shouldContinueSearch() returns false.\n+   */\n+  public void search() {", "originalCommit": "733070c1a7715c9e0e78103128a4e46bc1efac49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODU4Mg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407078582", "bodyText": "Don't see a good way of reducing further. Note: Overall it's still a reduction since the function where this code was originally had higher complexity.", "author": "asvitkine", "createdAt": "2020-04-11T15:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3NDQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzExMDkzNA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407110934", "bodyText": "FWIW, this one was fixed:\n\nMethod findNearbyEnemyCapitalsAndFactories has a Cognitive Complexity of 16 (exceeds 5 allowed). Consider refactoring.\nFixed\n\nGoing from 16 -> 6 is certainly the right direction \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-04-11T21:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3NDQ3Mw=="}], "type": "inlineReview"}, {"oid": "f73524b0410aa2108ea233c12c6565e711ea69f4", "url": "https://github.com/triplea-game/triplea/commit/f73524b0410aa2108ea233c12c6565e711ea69f4", "message": "Try to reduce complexity to appease codeclimate", "committedDate": "2020-04-11T15:21:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5MjIzNg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407092236", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.visited = new HashSet<Territory>(List.of(startTerritory));\n          \n          \n            \n                this.visited = new HashSet<>(List.of(startTerritory));", "author": "RoiEXLab", "createdAt": "2020-04-11T17:58:16Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import lombok.Getter;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  private final GameMap map;\n+  @Getter private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<Territory>(List.of(startTerritory));", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5MjI2MQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407092261", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));\n          \n          \n            \n                this.territoriesToCheck = new ArrayDeque<>(List.of(startTerritory));", "author": "RoiEXLab", "createdAt": "2020-04-11T17:58:23Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import lombok.Getter;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  private final GameMap map;\n+  @Getter private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<Territory>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE0Ng==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407094146", "bodyText": "Perhaps worth clarifying:\nThe reason the implementation is slower is because it tries to parallelize checking neighbours, which adds too much overhead for the ususally small amount of neighbours + it actually copies the collection instead of just returning it.\nI'd suggest to clarify that a bit why it is much slower in this comment.\nMaybe you can even drop the parallelism entirely, I'm not really convinced it actually provides a speed boost elsewhere.\nI introduced this change in #4077 (apparently) because it yielded some performance gains for route-drawing, but I haven't really tested anything else as far as I can remember.\nThe GameMap class is a mess (I'm currently looking at it) and uses way too much recursion in combination with code constructs that aren't really supposed to be run recursively like this (Streams that are collected and then re-streamed in another layer add way too much overhead)", "author": "RoiEXLab", "createdAt": "2020-04-11T18:16:13Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import lombok.Getter;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  private final GameMap map;\n+  @Getter private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<Territory>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));\n+    this.cond = cond;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Called when a new territory is encountered. Can be overridden to provide custom search\n+   * behavior.\n+   *\n+   * @param territory The new territory.\n+   */\n+  public void visit(final Territory territory) {}\n+\n+  /**\n+   * Called after all territories within the specified distance have been searched. Can be\n+   * overridden to terminate the search.\n+   *\n+   * @param distanceSearched The current distance searched\n+   * @return Whether the search should continue.\n+   */\n+  public boolean shouldContinueSearch(final int distanceSearched) {\n+    return true;\n+  }\n+\n+  /**\n+   * Performs the search. It will end when either all territories have been visited or\n+   * shouldContinueSearch() returns false.\n+   */\n+  public void search() {\n+    // Since we process territories in order of distance, we can keep track of the last territory\n+    // at the current distance that's in the territoriesToCheck queue. When we encounter it, we\n+    // increment the distance and update lastTerritoryAtCurrentDistance.\n+    int currentDistance = 0;\n+    Territory lastTerritoryAtCurrentDistance = territoriesToCheck.peekLast();\n+    while (!territoriesToCheck.isEmpty()) {\n+      final Territory territory = checkNextTerritory();\n+\n+      // If we just processed the last territory at the current distance, increment the distance\n+      // and set the territory at which we need to update it again to be the last one added.\n+      if (ObjectUtils.referenceEquals(territory, lastTerritoryAtCurrentDistance)) {\n+        currentDistance++;\n+        if (!shouldContinueSearch(currentDistance)) {\n+          return;\n+        }\n+        lastTerritoryAtCurrentDistance = territoriesToCheck.peekLast();\n+      }\n+    }\n+  }\n+\n+  private Territory checkNextTerritory() {\n+    final Territory territory = territoriesToCheck.removeFirst();\n+    // Note: We don't pass cond to getNeighbors() because that implementation is much slower.", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5ODg4NQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407098885", "bodyText": "I haven't dug into why it's slower. I just measured things after my initial refactoring that did this and it was slower. I think we can rewrite that later, but didn't want to expand the scope of this change.", "author": "asvitkine", "createdAt": "2020-04-11T19:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5MzgyMw==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407193823", "bodyText": "No worries, just wanted to provide some extra information for documentation purposes.", "author": "RoiEXLab", "createdAt": "2020-04-12T12:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407094191", "bodyText": "Ok, I didn't know you could nest classes inside methods \ud83d\ude2e", "author": "RoiEXLab", "createdAt": "2020-04-11T18:16:43Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProTerritoryValueUtils.java", "diffHunk": "@@ -177,19 +176,31 @@ public static double findTerritoryAttackValue(\n     return territoryValueMap;\n   }\n \n-  private static int findMaxLandMassSize(final GamePlayer player) {\n-    int maxLandMassSize = 1;\n+  protected static int findMaxLandMassSize(final GamePlayer player) {\n     final GameData data = player.getData();\n+    final Predicate<Territory> cond = ProMatches.territoryCanPotentiallyMoveLandUnits(player, data);\n+    class LandMassFinder extends BreadthFirstSearch {\n+      int landMassSize = 0;\n+\n+      LandMassFinder(final Territory startTerritory) {\n+        super(startTerritory, cond);\n+      }\n+\n+      @Override\n+      public void visit(final Territory territory) {\n+        landMassSize++;\n+      }\n+    }", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwMDE4Ng==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407200186", "bodyText": "Yeah, not really sure how I feel about classes nested in a method either...", "author": "ron-murhammer", "createdAt": "2020-04-12T13:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxOTUxMA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407519510", "bodyText": "It was to support tracking of landMassSize while keeping the logic self contained to the method. The other option is an anon class and have:\nfinal int maxLandMassSize[] = new int[1];\nin the method scope so that the inner class can write to maxLandMassSize[0] (since you can't write to an int. This seemed cleaner than that.", "author": "asvitkine", "createdAt": "2020-04-13T14:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNjU3OQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407626579", "bodyText": "Would AtomicReference perhaps help? I think that can be templated to an integer, eg: AtomicReference<Integer>", "author": "DanVanAtta", "createdAt": "2020-04-13T18:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNzk5Mg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407627992", "bodyText": "It would work, but the atomicity is not needed (and would be slower) and may be confusing to readers.", "author": "asvitkine", "createdAt": "2020-04-13T18:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzOTU0OQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407639549", "bodyText": "AtomicReference AFAIK is preferred way to avoid the array of size 1:\nfinal int maxLandMassSize[] = new int[1];\nThere might be other solutions to be had too..", "author": "DanVanAtta", "createdAt": "2020-04-13T18:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNjQ1OQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407836459", "bodyText": "Do you have a reference for why it's preferred?\nIt seems an antipattern to me. We're using something that was not meant for the purpose and has a semantic meaning (i.e. for use with multithreading) for something else. This both confuses the semantic meaning (a reader may think the code is multithreaded when it's not) and also can have performance implications.\nImho, the named inner class is the cleanest way to do without a dedicated MutableInt class (like exists in apache commons).\nI searched a few sources to see if there's a reason to prefer AtomicInteger, but haven't found anything convincing:\nhttps://www.techiedelight.com/pass-integer-reference-java/\nhttps://stackoverflow.com/questions/319765/accessing-inner-anonymous-class-members", "author": "asvitkine", "createdAt": "2020-04-14T02:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0NjI4Nw==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407846287", "bodyText": "Either way, int[] or AtomicReference<Integer> or AtomicInteger, for the sake of using a final value that is mutable, it's not the intended usage of any of those.\nI know I've seen AtomicReference used for that before, don't have any examples stating it's a best practice (AFAIK none of it is necessarily a best practice though as we are hacking around a variable that needs to be final).", "author": "DanVanAtta", "createdAt": "2020-04-14T03:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0Njk5OA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407846998", "bodyText": "Well, the other approach was to have an inner class with a member int variable, which is what my original change did. I would argue that is less hacky than the others, but then people didn't like a non-anomymous inner class inside a method.  \u00af\\_(\u30c4)_/\u00af\nI went with int[] now.", "author": "asvitkine", "createdAt": "2020-04-14T03:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0ODI2OA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407848268", "bodyText": "Apologies as you're suffering from too many reviewers \ud83d\ude01\nWe've different tastes.\nI would probably look for perhaps a 3rd option.\nI respect avoiding code churn, int[] or AtomicReference are not that much different, not a big deal for me.", "author": "DanVanAtta", "createdAt": "2020-04-14T03:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDY3MA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407094670", "bodyText": "In java getters and setters are the preffered way of modifying fields, even on this small scale.\nYou can use lomboks @Getter and @Setter annotations if you want", "author": "RoiEXLab", "createdAt": "2020-04-11T18:21:09Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProTerritoryValueUtils.java", "diffHunk": "@@ -177,19 +176,31 @@ public static double findTerritoryAttackValue(\n     return territoryValueMap;\n   }\n \n-  private static int findMaxLandMassSize(final GamePlayer player) {\n-    int maxLandMassSize = 1;\n+  protected static int findMaxLandMassSize(final GamePlayer player) {\n     final GameData data = player.getData();\n+    final Predicate<Territory> cond = ProMatches.territoryCanPotentiallyMoveLandUnits(player, data);\n+    class LandMassFinder extends BreadthFirstSearch {\n+      int landMassSize = 0;\n+\n+      LandMassFinder(final Territory startTerritory) {\n+        super(startTerritory, cond);\n+      }\n+\n+      @Override\n+      public void visit(final Territory territory) {\n+        landMassSize++;\n+      }\n+    }\n+\n+    int maxLandMassSize = 1;\n+    final var fullVisited = new HashSet<Territory>();\n     for (final Territory t : data.getMap().getTerritories()) {\n-      if (!t.isWater()) {\n-        final int landMassSize =\n-            1\n-                + data.getMap()\n-                    .getNeighbors(\n-                        t, 6, ProMatches.territoryCanPotentiallyMoveLandUnits(player, data))\n-                    .size();\n-        if (landMassSize > maxLandMassSize) {\n-          maxLandMassSize = landMassSize;\n+      if (!t.isWater() && !fullVisited.contains(t)) {\n+        final LandMassFinder finder = new LandMassFinder(t);\n+        finder.search();\n+        fullVisited.addAll(finder.getVisited());\n+        if (finder.landMassSize > maxLandMassSize) {\n+          maxLandMassSize = finder.landMassSize;", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNjYwNw==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407106607", "bodyText": "@RoiEXLab I'm not positive that is always the case. Within a class for example using getter/setter can be brittle as any child overrides can unintentionally change many methods. Essentially java was designed to expect inheritance as a default, then effective java came along and basically said to disallow it by default or else explicitly design for it (complex).", "author": "DanVanAtta", "createdAt": "2020-04-11T20:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxNDY2OQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407514669", "bodyText": "In this case, it's accessing a what's essential a local variable. It can't be local to the method because anon or inner classes can't set primitives (i.e. can't have non-final variables). So in this case it's declared as a member of the inner class.\nAnother option is to declare an array or some other wrapper in the method itself as a local, e.g.\nint maxLandMassSize[] = new int[1];\nAnd have the inner class access maxLandMassSize[0], then it wouldn't need to be in the inner class (and the inner class could become anonymous).\nBut that seemed uglier, so I went with this.\nBy the way, if we structured the API without inheritance (e.g. the BFS class could take another interface instance to receive the new call backs), this doesn't solve this problem as the same problem exists. The extra object still needs to keep track of maxLandMassSize which is effectively something that's local to to the method and doesn't need a getter.", "author": "asvitkine", "createdAt": "2020-04-13T14:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA5NDY3MA=="}], "type": "inlineReview"}, {"oid": "c21581e7f4208405d982895109537d874f6dece4", "url": "https://github.com/triplea-game/triplea/commit/c21581e7f4208405d982895109537d874f6dece4", "message": "Update game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java\n\nCo-Authored-By: RoiEX <8350879+RoiEXLab@users.noreply.github.com>", "committedDate": "2020-04-11T20:02:13Z", "type": "commit"}, {"oid": "cc97a2898bdb60c05b3f31e4d6d797f187c29375", "url": "https://github.com/triplea-game/triplea/commit/cc97a2898bdb60c05b3f31e4d6d797f187c29375", "message": "Update game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java\n\nCo-Authored-By: RoiEX <8350879+RoiEXLab@users.noreply.github.com>", "committedDate": "2020-04-11T20:02:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNjg0MQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407106841", "bodyText": "What do you think of using a var here in order to spell out the variable name instead? eg:\nvar breadthFirstSearch =  new BreadthFirstSearch(startTerritory) {", "author": "DanVanAtta", "createdAt": "2020-04-11T20:22:06Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProTerritoryValueUtils.java", "diffHunk": "@@ -448,39 +459,26 @@ private static double findWaterValue(\n    */\n   protected static Collection<Territory> findNearbyEnemyCapitalsAndFactories(\n       final Territory startTerritory, final Set<Territory> enemyCapitalsAndFactories) {\n-    final GameMap map = startTerritory.getData().getMap();\n-    // Use breadth first search to traverse territories, keeping track of which have already been\n-    // visited and which territories from the target list have  been found.\n     final var found = new HashSet<Territory>();\n-    final var visited = new HashSet<Territory>(List.of(startTerritory));\n-    final var territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));\n-\n-    // Since we process territories in order of distance, we can keep track of the last territory\n-    // at the current distance that's in the territoriesToCheck queue. When we encounter it, we\n-    // increment the distance and update lastTerritoryAtCurrentDistance.\n-    int distance = 0;\n-    Territory lastTerritoryAtCurrentDistance = startTerritory;\n-    while (!territoriesToCheck.isEmpty()) {\n-      final Territory node = territoriesToCheck.removeFirst();\n-      for (final Territory neighbor : map.getNeighbors(node)) {\n-        if (visited.add(neighbor)) {\n-          territoriesToCheck.add(neighbor);\n-          if (enemyCapitalsAndFactories.contains(neighbor)) {\n-            found.add(neighbor);\n+    final BreadthFirstSearch bfs =", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0NjA3MA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407846070", "bodyText": "Done.", "author": "asvitkine", "createdAt": "2020-04-14T03:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNjg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNjg4NA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407106884", "bodyText": "Good to see the test case, can we increase the number of tests and thoroughness? Are the edge cases tested?", "author": "DanVanAtta", "createdAt": "2020-04-11T20:22:36Z", "path": "game-core/src/test/java/games/strategy/triplea/ai/pro/util/ProTerritoryValueUtilsTest.java", "diffHunk": "@@ -62,4 +64,14 @@ void testFindNearbyEnemyCapitalsAndFactoriesNoneWithinDistance9() {\n         result,\n         containsInAnyOrder(northJapan));\n   }\n+\n+  @Test", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MjczMA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407852730", "bodyText": "@asvitkine thoughts on if there are additional test cases to make sure the testing is thorough?\nPerhaps the not found case, or the find at the zero distance, or cases where we should find but it's past max distance?", "author": "DanVanAtta", "createdAt": "2020-04-14T04:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNjg4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxMjAyNQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409212025", "bodyText": "findMaxLandMassSize() doesn't really have parameters, so the only way to try different cases is with different maps.\nI added cases for Revised and Minimap (which is a single small continent). For the latter, I added its XML file to test data. Let me know if you think this is OK.", "author": "asvitkine", "createdAt": "2020-04-16T00:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNjg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNzQ1NA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407107454", "bodyText": "Can we make this method abstract? Overriding concrete methods can get pretty complex in a hurry. Another strategy that would avoid inheritance completely would be to pass in a constructor object that defines this behavior. EG:\nprivate final Consumer<Territory> visitor;\n\n  public void visit(final Territory territory) {\n      visitor.accept(terrritory);\n}\n\nLooking at the other methods, it looks like we might be providing a lot of default behavior but any/all of it can be overriden. If this behavior were injected it could be more deterministic and easier to follow.  Essentially you would know have to know about instance types and the states of objects to know how they would function, WDYT?", "author": "DanVanAtta", "createdAt": "2020-04-11T20:28:56Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import lombok.Getter;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  private final GameMap map;\n+  @Getter private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<Territory>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));\n+    this.cond = cond;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Called when a new territory is encountered. Can be overridden to provide custom search\n+   * behavior.\n+   *\n+   * @param territory The new territory.\n+   */\n+  public void visit(final Territory territory) {}", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyODI0Ng==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407228246", "bodyText": "Apologies @asvitkine if this is getting pedantic for you, just want to be sure the suggestion for how to avoid overriding concrete methods is somewhat clear so that you can respond or incorporate it.\nExample of concrete method override:\nclass Parent {\n  int computeSomething() {\n       return 1;\n   }\n}\n\n@Override\nclass Child extends Parent{\n  int computeSomething() {\n       return 10;\n   }\n}\n\nIn the above, there are really two behaviors, we can expand the inheritance tree to flatten the structure, ie instead of:\n  P\n    \\\n     C(1)\n\nWe get a graph that looks like this:\n       P\n     /   \\\n C(1)   C(2)\n\nThat would look like this:\nabsract class Parent {\n  abstract int computeSomething();\n}\n\n@Override\nclass Child1 extends Parent{\n  int computeSomething() {\n       return 1;\n   }\n}\n\n@Override\nclass Child2 extends Parent{\n  int computeSomething() {\n       return 10;\n   }\n}\n\nThe other recommendation is to inject behavior via configuration, in which case there is no inheritance at all, eg:\n\n@AllArgsBuilder\nclass Parent {\n  private final Supplier<Integer> computation;\n  int computeSomething() {\n     return computation.get();\n  }\n}\n\n\nclass SomeClass {\n   Parent child1 = new Parent(() -> 1);\n   Parent child2 = new Parent(() -> 10);\n}", "author": "DanVanAtta", "createdAt": "2020-04-12T17:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxODE4NQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407518185", "bodyText": "We could go with an interface or abstract class that has the two methods to override - an instance of which is passed to BFS from the caller.  I agree that it tightens things up a bit more (i.e. the subclasses of that abstract can't do as much), so I can look at doing that if you prefer.\nThough it doesn't change things too much - the caller now just declares an anonymous class that extends the new abstract class/interface that has just the visit() and shouldContinueSearch() methods rather than extending BFS. Let me know if you prefer that approach.\nMy original thought was to keep it simpler to start with, so that as we apply this to more cases (like getNeighbours(distance) suggestion and possibly getRoute()), we can figure out what the API surface would need to be like to support them and evolve as necessary.", "author": "asvitkine", "createdAt": "2020-04-13T14:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyOTIwMA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407629200", "bodyText": "Though it doesn't change things too much - the caller now just declares an anonymous class that extends the new abstract class/interface that has just the visit() and shouldContinueSearch() methods rather than extending BFS. Let me know if you prefer that approach.\n\nAssuming it can be done cleanly, I think that sounds good/preferable \ud83d\udc4d\nIt sounds like that would avoid a concrete implementation from having an override. Such scenarios, concrete implementations having an override is usually where inheritance starts to become quite bad.", "author": "DanVanAtta", "createdAt": "2020-04-13T18:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0NTg0MQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407845841", "bodyText": "Done.", "author": "asvitkine", "createdAt": "2020-04-14T03:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNzQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwODA3MQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407108071", "bodyText": "What do you think of having finder.seach() returning the visited list? This would avoid the void method call, and avoid the user of finder from knowing about the implementation detail that finder.search sets a value that can be returned by getVisited (arguably better/encapsulation)", "author": "DanVanAtta", "createdAt": "2020-04-11T20:34:23Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProTerritoryValueUtils.java", "diffHunk": "@@ -177,19 +176,31 @@ public static double findTerritoryAttackValue(\n     return territoryValueMap;\n   }\n \n-  private static int findMaxLandMassSize(final GamePlayer player) {\n-    int maxLandMassSize = 1;\n+  protected static int findMaxLandMassSize(final GamePlayer player) {\n     final GameData data = player.getData();\n+    final Predicate<Territory> cond = ProMatches.territoryCanPotentiallyMoveLandUnits(player, data);\n+    class LandMassFinder extends BreadthFirstSearch {\n+      int landMassSize = 0;\n+\n+      LandMassFinder(final Territory startTerritory) {\n+        super(startTerritory, cond);\n+      }\n+\n+      @Override\n+      public void visit(final Territory territory) {\n+        landMassSize++;\n+      }\n+    }\n+\n+    int maxLandMassSize = 1;\n+    final var fullVisited = new HashSet<Territory>();\n     for (final Territory t : data.getMap().getTerritories()) {\n-      if (!t.isWater()) {\n-        final int landMassSize =\n-            1\n-                + data.getMap()\n-                    .getNeighbors(\n-                        t, 6, ProMatches.territoryCanPotentiallyMoveLandUnits(player, data))\n-                    .size();\n-        if (landMassSize > maxLandMassSize) {\n-          maxLandMassSize = landMassSize;\n+      if (!t.isWater() && !fullVisited.contains(t)) {\n+        final LandMassFinder finder = new LandMassFinder(t);\n+        finder.search();\n+        fullVisited.addAll(finder.getVisited());", "originalCommit": "f73524b0410aa2108ea233c12c6565e711ea69f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxNTE2Mg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407515162", "bodyText": "Another option is to not expose visited() at all and have the caller's visit() method override keep track of this case.", "author": "asvitkine", "createdAt": "2020-04-13T14:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwODA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyOTg2Mg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407629862", "bodyText": "That also sounds like a reasonably alternative.\nIf I understand right, there would be no side-effects as the data state would be self-contained to the BFS implementation, do I have that right? If that can be done cleanly, it sounds good.", "author": "DanVanAtta", "createdAt": "2020-04-13T18:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwODA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0NTc3MA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407845770", "bodyText": "Done.", "author": "asvitkine", "createdAt": "2020-04-14T03:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwODA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5NDI1MQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407194251", "bodyText": "Just a random thought I had.\nThis class would be super usefule to optimize GameMap#getNeighbors(Set, Set, int, Predicate), which basically does the same thing here, just with less than optimal recursion.", "author": "RoiEXLab", "createdAt": "2020-04-12T12:53:32Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import lombok.Getter;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {", "originalCommit": "cc97a2898bdb60c05b3f31e4d6d797f187c29375", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUxNTk2NA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407515964", "bodyText": "Yes, it's on my radar. I actually wrote the code for that, but it didn't help much with this optimization since the underlying algorithm was still bad (it was calling getNeighbors(, distance=6) on each territory). So I abandoned that to focus on the actual speed improvement which is an algorithm change.\nHowever, when we have the new class in place, we can use it in more places like there. :)", "author": "asvitkine", "createdAt": "2020-04-13T14:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE5NDI1MQ=="}], "type": "inlineReview"}, {"oid": "365570c50b99dec6e4e446f76392c04d605ec026", "url": "https://github.com/triplea-game/triplea/commit/365570c50b99dec6e4e446f76392c04d605ec026", "message": "Refactors:\n  - Use a visitor object instead of subclassing.\n  - Use an int array to access the int from anon class.\n  - Don't expose visited map.", "committedDate": "2020-04-14T03:30:18Z", "type": "commit"}, {"oid": "f027f2a8efd438944dee84fb36a838b9606498be", "url": "https://github.com/triplea-game/triplea/commit/f027f2a8efd438944dee84fb36a838b9606498be", "message": "Merge branch 'opt_it' of https://github.com/asvitkine/triplea into opt_it", "committedDate": "2020-04-14T03:31:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0NTk4OA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407845988", "bodyText": "Method traverse has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-14T03:33:15Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  public abstract static class Visitor {\n+    /**\n+     * Called when a new territory is encountered. Can be overridden to provide custom search\n+     * behavior.\n+     *\n+     * @param territory The new territory.\n+     */\n+    public abstract void visit(final Territory territory);\n+\n+    /**\n+     * Called after all territories within the specified distance have been searched. Can be\n+     * overridden to terminate the search.\n+     *\n+     * @param distanceSearched The current distance searched\n+     * @return Whether the search should continue.\n+     */\n+    public boolean shouldContinueSearch(final int distanceSearched) {\n+      return true;\n+    }\n+  }\n+\n+  private final GameMap map;\n+  private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<>(List.of(startTerritory));\n+    this.cond = cond;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Performs the search. It will end when either all territories have been visited or\n+   * shouldContinueSearch() returns false.\n+   *\n+   * @param visitor The visitor object to customize the search.\n+   */\n+  public void traverse(final Visitor visitor) {", "originalCommit": "f027f2a8efd438944dee84fb36a838b9606498be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6d76d0338bf70ba8e58459be16f2bb58350b83b", "url": "https://github.com/triplea-game/triplea/commit/b6d76d0338bf70ba8e58459be16f2bb58350b83b", "message": "Fix style", "committedDate": "2020-04-14T03:50:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MDYyNQ==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407850625", "bodyText": "Method traverse has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-14T03:52:06Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  public abstract static class Visitor {\n+    /**\n+     * Called when a new territory is encountered. Can be overridden to provide custom search\n+     * behavior.\n+     *\n+     * @param territory The new territory.\n+     */\n+    public abstract void visit(Territory territory);\n+\n+    /**\n+     * Called after all territories within the specified distance have been searched. Can be\n+     * overridden to terminate the search.\n+     *\n+     * @param distanceSearched The current distance searched\n+     * @return Whether the search should continue.\n+     */\n+    public boolean shouldContinueSearch(final int distanceSearched) {\n+      return true;\n+    }\n+  }\n+\n+  private final GameMap map;\n+  private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;\n+\n+  public BreadthFirstSearch(final Territory startTerritory, final Predicate<Territory> cond) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<>(List.of(startTerritory));\n+    this.cond = cond;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Performs the search. It will end when either all territories have been visited or\n+   * shouldContinueSearch() returns false.\n+   *\n+   * @param visitor The visitor object to customize the search.\n+   */\n+  public void traverse(final Visitor visitor) {", "originalCommit": "b6d76d0338bf70ba8e58459be16f2bb58350b83b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MDg1Mg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407850852", "bodyText": "nit 'can be overridden' -> 'must be overriden'\nThe javadoc might be slightly out of date since moving.", "author": "DanVanAtta", "createdAt": "2020-04-14T03:52:59Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  public abstract static class Visitor {\n+    /**\n+     * Called when a new territory is encountered. Can be overridden to provide custom search", "originalCommit": "b6d76d0338bf70ba8e58459be16f2bb58350b83b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNjY1Mw==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409206653", "bodyText": "Done.", "author": "asvitkine", "createdAt": "2020-04-16T00:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MDg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI1Nzk4Mw==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409257983", "bodyText": "@asvitkine I'm not seeing the latest updates, do they need to be pushed perhaps?", "author": "DanVanAtta", "createdAt": "2020-04-16T03:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MTU2OA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407851568", "bodyText": "cond is the same as continueSearchCondition?  The variable strikes me as a bit cryptic, any thoughts if it could be more descriptive?", "author": "DanVanAtta", "createdAt": "2020-04-14T03:55:41Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to be sub-classed, with methods visit()\n+ * and shouldContinueSearch() that can be overridden to customize the behavior.\n+ */\n+public class BreadthFirstSearch {\n+  public abstract static class Visitor {\n+    /**\n+     * Called when a new territory is encountered. Can be overridden to provide custom search\n+     * behavior.\n+     *\n+     * @param territory The new territory.\n+     */\n+    public abstract void visit(Territory territory);\n+\n+    /**\n+     * Called after all territories within the specified distance have been searched. Can be\n+     * overridden to terminate the search.\n+     *\n+     * @param distanceSearched The current distance searched\n+     * @return Whether the search should continue.\n+     */\n+    public boolean shouldContinueSearch(final int distanceSearched) {\n+      return true;\n+    }\n+  }\n+\n+  private final GameMap map;\n+  private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> cond;", "originalCommit": "b6d76d0338bf70ba8e58459be16f2bb58350b83b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwODM0OA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409208348", "bodyText": "Changed to neighborCondition and added Javadoc for the constructor param.", "author": "asvitkine", "createdAt": "2020-04-16T00:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MjM5NA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r407852394", "bodyText": "What do you think of directly returning here?\nie:\nreturn distanceSearched < MIN_FACTORY_CHECK_DISTANCE || found.isEmpty()", "author": "DanVanAtta", "createdAt": "2020-04-14T03:58:45Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProTerritoryValueUtils.java", "diffHunk": "@@ -448,39 +456,25 @@ private static double findWaterValue(\n    */\n   protected static Collection<Territory> findNearbyEnemyCapitalsAndFactories(\n       final Territory startTerritory, final Set<Territory> enemyCapitalsAndFactories) {\n-    final GameMap map = startTerritory.getData().getMap();\n-    // Use breadth first search to traverse territories, keeping track of which have already been\n-    // visited and which territories from the target list have  been found.\n     final var found = new HashSet<Territory>();\n-    final var visited = new HashSet<Territory>(List.of(startTerritory));\n-    final var territoriesToCheck = new ArrayDeque<Territory>(List.of(startTerritory));\n-\n-    // Since we process territories in order of distance, we can keep track of the last territory\n-    // at the current distance that's in the territoriesToCheck queue. When we encounter it, we\n-    // increment the distance and update lastTerritoryAtCurrentDistance.\n-    int distance = 0;\n-    Territory lastTerritoryAtCurrentDistance = startTerritory;\n-    while (!territoriesToCheck.isEmpty()) {\n-      final Territory node = territoriesToCheck.removeFirst();\n-      for (final Territory neighbor : map.getNeighbors(node)) {\n-        if (visited.add(neighbor)) {\n-          territoriesToCheck.add(neighbor);\n-          if (enemyCapitalsAndFactories.contains(neighbor)) {\n-            found.add(neighbor);\n-          }\n-        }\n-      }\n-\n-      // If we just processed the last territory at the current distance, increment the distance\n-      // and set the territory at which we need to update it again to be the last one added.\n-      if (ObjectUtils.referenceEquals(node, lastTerritoryAtCurrentDistance)) {\n-        distance++;\n-        if (distance >= MIN_FACTORY_CHECK_DISTANCE && !found.isEmpty()) {\n-          break;\n-        }\n-        lastTerritoryAtCurrentDistance = territoriesToCheck.peekLast();\n-      }\n-    }\n+    new BreadthFirstSearch(startTerritory)\n+        .traverse(\n+            new BreadthFirstSearch.Visitor() {\n+              @Override\n+              public void visit(final Territory territory) {\n+                if (enemyCapitalsAndFactories.contains(territory)) {\n+                  found.add(territory);\n+                }\n+              }\n+\n+              @Override\n+              public boolean shouldContinueSearch(final int distanceSearched) {\n+                if (distanceSearched >= MIN_FACTORY_CHECK_DISTANCE && !found.isEmpty()) {", "originalCommit": "b6d76d0338bf70ba8e58459be16f2bb58350b83b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNjU1Mg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409206552", "bodyText": "Done.", "author": "asvitkine", "createdAt": "2020-04-16T00:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg1MjM5NA=="}], "type": "inlineReview"}, {"oid": "57b2218e4d5d835bc31474d4fbe3331c16391dc1", "url": "https://github.com/triplea-game/triplea/commit/57b2218e4d5d835bc31474d4fbe3331c16391dc1", "message": "Add a couple more tests and address comments.", "committedDate": "2020-04-16T00:32:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTU2NA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409271564", "bodyText": "Method traverse has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-16T04:17:18Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to take a Visitor object with methods\n+ * visit() and shouldContinueSearch() for customizing the behavior.\n+ */\n+public final class BreadthFirstSearch {\n+  public abstract static class Visitor {\n+    /**\n+     * Called when a new territory is encountered.\n+     *\n+     * @param territory The new territory.\n+     */\n+    public abstract void visit(Territory territory);\n+\n+    /**\n+     * Called after all territories within the specified distance have been searched. Can be\n+     * overridden to terminate the search.\n+     *\n+     * @param distanceSearched The current distance searched\n+     * @return Whether the search should continue.\n+     */\n+    public boolean shouldContinueSearch(final int distanceSearched) {\n+      return true;\n+    }\n+  }\n+\n+  private final GameMap map;\n+  private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> neighborCondition;\n+\n+  /**\n+   * @param startTerritory The territory from where to start the search.\n+   * @param neighborCondition Condition that neighboring territories must match to be considered\n+   *     neighbors.\n+   */\n+  public BreadthFirstSearch(\n+      final Territory startTerritory, final Predicate<Territory> neighborCondition) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<>(List.of(startTerritory));\n+    this.neighborCondition = neighborCondition;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Performs the search. It will end when either all territories have been visited or\n+   * shouldContinueSearch() returns false.\n+   *\n+   * @param visitor The visitor object to customize the search.\n+   */\n+  public void traverse(final Visitor visitor) {", "originalCommit": "57b2218e4d5d835bc31474d4fbe3331c16391dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MjkyNg==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409272926", "bodyText": "side-note, I'm thinking to propose a convention that we end enums with a trailing comma and semi on the next line. This way adding elements adds just a new line.\nIn this case this would be:\nMINIMAP(\"minimap.xml\"),\n;\n\nAnother side-comment, the tests that require full map data are not necessarily ideal. They involve lots of moving pieces, it's not a proper unit test if we use them. There are some additional drawbacks. Long story short, we want to in the short term see if we consolidate how many test XMLs are in use, use as few as possible, eventually get to a place where game rules can be tested ad-infinitum without an actual XML", "author": "DanVanAtta", "createdAt": "2020-04-16T04:22:38Z", "path": "game-core/src/test/java/games/strategy/triplea/xml/TestMapGameData.java", "diffHunk": "@@ -38,7 +38,9 @@\n \n   GAME_EXAMPLE(\"GameExample.xml\"),\n \n-  TWW(\"Total_World_War_Dec1941.xml\");\n+  TWW(\"Total_World_War_Dec1941.xml\"),\n+\n+  MINIMAP(\"minimap.xml\");", "originalCommit": "57b2218e4d5d835bc31474d4fbe3331c16391dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cadd29278795a501284c3a7157dde2d8049db583", "url": "https://github.com/triplea-game/triplea/commit/cadd29278795a501284c3a7157dde2d8049db583", "message": "Remove tab chars.", "committedDate": "2020-04-16T12:51:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUzMTczOA==", "url": "https://github.com/triplea-game/triplea/pull/6187#discussion_r409531738", "bodyText": "Method traverse has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-16T12:53:57Z", "path": "game-core/src/main/java/games/strategy/engine/data/util/BreadthFirstSearch.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package games.strategy.engine.data.util;\n+\n+import games.strategy.engine.data.GameMap;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayDeque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import org.triplea.java.ObjectUtils;\n+\n+/**\n+ * Implements Breadth First Search (BFS) to traverse / find territories. Since the search criteria\n+ * varies depending on the use case, the class is designed to take a Visitor object with methods\n+ * visit() and shouldContinueSearch() for customizing the behavior.\n+ */\n+public final class BreadthFirstSearch {\n+  public abstract static class Visitor {\n+    /**\n+     * Called when a new territory is encountered.\n+     *\n+     * @param territory The new territory.\n+     */\n+    public abstract void visit(Territory territory);\n+\n+    /**\n+     * Called after all territories within the specified distance have been searched. Can be\n+     * overridden to terminate the search.\n+     *\n+     * @param distanceSearched The current distance searched\n+     * @return Whether the search should continue.\n+     */\n+    public boolean shouldContinueSearch(final int distanceSearched) {\n+      return true;\n+    }\n+  }\n+\n+  private final GameMap map;\n+  private final Set<Territory> visited;\n+  private final ArrayDeque<Territory> territoriesToCheck;\n+  private final Predicate<Territory> neighborCondition;\n+\n+  /**\n+   * @param startTerritory The territory from where to start the search.\n+   * @param neighborCondition Condition that neighboring territories must match to be considered\n+   *     neighbors.\n+   */\n+  public BreadthFirstSearch(\n+      final Territory startTerritory, final Predicate<Territory> neighborCondition) {\n+    this.map = startTerritory.getData().getMap();\n+    this.visited = new HashSet<>(List.of(startTerritory));\n+    this.territoriesToCheck = new ArrayDeque<>(List.of(startTerritory));\n+    this.neighborCondition = neighborCondition;\n+  }\n+\n+  public BreadthFirstSearch(final Territory startTerritory) {\n+    this(startTerritory, Matches.always());\n+  }\n+\n+  /**\n+   * Performs the search. It will end when either all territories have been visited or\n+   * shouldContinueSearch() returns false.\n+   *\n+   * @param visitor The visitor object to customize the search.\n+   */\n+  public void traverse(final Visitor visitor) {", "originalCommit": "cadd29278795a501284c3a7157dde2d8049db583", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}