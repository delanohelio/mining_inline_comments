{"pr_number": 6329, "pr_title": "Simplify IBattleCalculator interface", "pr_createdAt": "2020-04-25T14:27:56Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6329", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3Mzc5NA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073794", "bodyText": "Method purchase has 89 lines of code (exceeds 25 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:12Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3Mzc5Ng==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073796", "bodyText": "Method selectCasualties has 59 lines of code (exceeds 25 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:12Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()\n+            + \" checking retreat from territory \"\n+            + battleTerritory\n+            + \", attackers=\"\n+            + attackers.size()\n+            + \", defenders=\"\n+            + defenders.size()\n+            + \", submerge=\"\n+            + submerge\n+            + \", attacker=\"\n+            + isAttacker\n+            + \", isStrafing=\"\n+            + isStrafing);\n+    if ((isStrafing || (isAttacker && strengthDifference > 50))\n+        && (battleTerritory.isWater() || attackers.stream().anyMatch(Matches.unitIsLand()))) {\n+      return null;\n+    }\n+    prepareData(getGameData());\n+    return retreatAi.retreatQuery(battleId, battleTerritory, possibleTerritories);\n+  }\n+\n+  @Override\n+  public boolean shouldBomberBomb(final Territory territory) {\n+    return combatMoveAi.isBombing();\n+  }\n+\n+  // TODO: Consider supporting this functionality\n+  @Override\n+  public Collection<Unit> getNumberOfFightersToMoveToNewCarrier(\n+      final Collection<Unit> fightersThatCanBeMoved, final Territory from) {\n+    return new ArrayList<>();\n+  }\n+\n+  @Override", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3Mzc5Nw==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073797", "bodyText": "Method selectCasualties has 14 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:13Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()\n+            + \" checking retreat from territory \"\n+            + battleTerritory\n+            + \", attackers=\"\n+            + attackers.size()\n+            + \", defenders=\"\n+            + defenders.size()\n+            + \", submerge=\"\n+            + submerge\n+            + \", attacker=\"\n+            + isAttacker\n+            + \", isStrafing=\"\n+            + isStrafing);\n+    if ((isStrafing || (isAttacker && strengthDifference > 50))\n+        && (battleTerritory.isWater() || attackers.stream().anyMatch(Matches.unitIsLand()))) {\n+      return null;\n+    }\n+    prepareData(getGameData());\n+    return retreatAi.retreatQuery(battleId, battleTerritory, possibleTerritories);\n+  }\n+\n+  @Override\n+  public boolean shouldBomberBomb(final Territory territory) {\n+    return combatMoveAi.isBombing();\n+  }\n+\n+  // TODO: Consider supporting this functionality\n+  @Override\n+  public Collection<Unit> getNumberOfFightersToMoveToNewCarrier(\n+      final Collection<Unit> fightersThatCanBeMoved, final Territory from) {\n+    return new ArrayList<>();\n+  }\n+\n+  @Override\n+  public CasualtyDetails selectCasualties(\n+      final Collection<Unit> selectFrom,", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3Mzc5OQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073799", "bodyText": "Method createBattleCalcWorker has 28 lines of code (exceeds 25 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:13Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -70,393 +63,169 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n             MAX_THREADS,\n             new ThreadFactoryBuilder()\n                 .setDaemon(true)\n-                .setNameFormat(threadNamePrefix + \" ConcurrentOddsCalculator Worker-%d\")\n+                .setNameFormat(threadNamePrefix + \" ConcurrentBattleCalculator Worker-%d\")\n                 .build());\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n-  @Override\n   public void setGameData(final GameData data) {\n-    // increment so that a new calc doesn't take place (since they all wait on this latch)\n-    latchSetData.increment();\n-    // cancel any current setting of data\n-    cancelCurrentOperation.decrementAndGet();\n-    // cancel any existing calcing (it won't stop immediately, just quicker)\n-    cancel();\n-    synchronized (mutexSetGameData) {\n-      try {\n-        // since setting data takes place on a different thread, this is our token. wait on it since\n-        latchWorkerThreadsCreation.await();\n-        // we could have exited the synchronized block already.\n-      } catch (final InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-      }\n-      cancel();\n-      isDataSet = false;\n-      isCalcSet = false;\n-      if (data == null || isShutDown) {\n-        workers.clear();\n-        cancelCurrentOperation.incrementAndGet();\n-        // allow calcing and other stuff to go ahead\n-        latchSetData.countDown();\n-      } else {\n-        cancelCurrentOperation.incrementAndGet();\n-        // increment our token, so that we can set the data in a different thread and return from\n-        // this one\n-        latchWorkerThreadsCreation.increment();\n-        executor.execute(() -> createWorkers(data));\n-      }\n+    synchronized (mutex) {\n+      bytes = data == null ? new byte[0] : GameDataUtils.serializeGameDataWithoutHistory(data);\n+      dataLoadedAction.run();\n     }\n   }\n \n   @Override\n   public int getThreadCount() {\n-    return currentThreads;\n-  }\n-\n-  // use both time and memory left to determine how many copies to make\n-  private static int getThreadsToUse(\n-      final long timeToCopyInMillis, final long memoryUsedBeforeCopy) {\n-    if (timeToCopyInMillis > 20000 || MAX_THREADS == 1) {\n-      // just use 1 thread if we took more than 20 seconds to copy\n-      return 1;\n-    }\n-    final Runtime runtime = Runtime.getRuntime();\n-    final long usedMemoryAfterCopy = runtime.totalMemory() - runtime.freeMemory();\n-    // we cannot predict how the gc works\n-    final long memoryLeftBeforeMax =\n-        runtime.maxMemory() - Math.max(usedMemoryAfterCopy, memoryUsedBeforeCopy);\n-    // make sure it is a decent size\n-    final long memoryUsedByCopy = Math.max(100000, (usedMemoryAfterCopy - memoryUsedBeforeCopy));\n-    // regardless of how stupid the gc is we leave some memory left over just in case\n-    final int numberOfTimesWeCanCopyMax =\n-        Math.max(1, (int) Math.min(Integer.MAX_VALUE, (memoryLeftBeforeMax / memoryUsedByCopy)));\n-\n-    if (timeToCopyInMillis > 3000) {\n-      // use half the number of threads available if we took more than 3 seconds to copy\n-      return Math.min(numberOfTimesWeCanCopyMax, Math.max(1, (MAX_THREADS / 2)));\n-    }\n-    // use all threads\n-    return Math.min(numberOfTimesWeCanCopyMax, MAX_THREADS);\n-  }\n-\n-  private void createWorkers(final GameData data) {\n-    workers.clear();\n-    if (data != null && cancelCurrentOperation.get() >= 0) {\n-      // see how long 1 copy takes (some games can get REALLY big)\n-      final long startTime = System.currentTimeMillis();\n-      final long startMemory =\n-          Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n-      final GameData newData;\n-      try {\n-        // make first copy, then release lock on it so game can continue (ie: we don't want to lock\n-        // on it while we copy\n-        // it 16 times, when once is enough) don't let the data change while we make the first copy\n-        data.acquireWriteLock();\n-        newData = GameDataUtils.cloneGameDataWithoutHistory(data, false);\n-      } finally {\n-        data.releaseWriteLock();\n-      }\n-      currentThreads = getThreadsToUse((System.currentTimeMillis() - startTime), startMemory);\n-      try {\n-        // make sure all workers are using the same data\n-        newData.acquireReadLock();\n-        int i = 0;\n-        // we are already in 1 executor thread, so we have MAX_THREADS-1 threads left to use\n-        if (currentThreads <= 2 || MAX_THREADS <= 2) {\n-          // if 2 or fewer threads, do not multi-thread the copying (we have already copied it once\n-          // above, so at most\n-          // only 1 more copy to make)\n-          while (cancelCurrentOperation.get() >= 0 && i < currentThreads) {\n-            // the last one will use our already copied data from above, without copying it again\n-            workers.add(new BattleCalculator(newData, (currentThreads == ++i)));\n-          }\n-        } else { // multi-thread our copying, cus why the heck not (it increases the speed of\n-          // copying by about double)\n-          final CountDownLatch workerLatch = new CountDownLatch(currentThreads - 1);\n-          while (i < (currentThreads - 1)) {\n-            ++i;\n-            executor.execute(\n-                () -> {\n-                  if (cancelCurrentOperation.get() >= 0) {\n-                    workers.add(new BattleCalculator(newData, false));\n-                  }\n-                  workerLatch.countDown();\n-                });\n-          }\n-          // the last one will use our already copied data from above, without copying it again\n-          workers.add(new BattleCalculator(newData, true));\n-          Interruptibles.await(workerLatch);\n-        }\n-      } finally {\n-        newData.releaseReadLock();\n-      }\n-    }\n-    if (cancelCurrentOperation.get() < 0 || data == null) {\n-      // we could have cancelled while setting data, so clear the workers again if so\n-      workers.clear();\n-      isDataSet = false;\n-    } else {\n-      // should make sure that all workers have their game data set before we can call calculate and\n-      // other things\n-      isDataSet = true;\n-      dataLoadedAction.run();\n-    }\n-    // allow setting new data to take place if it is waiting on us\n-    latchWorkerThreadsCreation.countDown();\n-    // allow calcing and other stuff to go ahead\n-    latchSetData.countDown();\n+    return MAX_THREADS;\n   }\n \n-  @Override\n   public void shutdown() {\n     isShutDown = true;\n-    cancelCurrentOperation.set(Integer.MIN_VALUE / 2);\n     cancel();\n     executor.shutdown();\n   }\n \n-  private void awaitLatch() {\n-    try {\n-      // there is a small chance calculate or setCalculateData or something could be called in\n-      // between calls to\n-      // setGameData\n-      latchSetData.await();\n-    } catch (final InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-    }\n-  }\n-\n+  /**\n+   * Concurrently calculates odds using the OddsCalculatorWorker. It uses Executor to process the\n+   * results. Then waits for all the future results and combines them together.\n+   */\n   @Override\n-  public void setCalculateData(\n+  public AggregateResults calculate(\n       final GamePlayer attacker,\n       final GamePlayer defender,\n       final Territory location,\n       final Collection<Unit> attacking,\n       final Collection<Unit> defending,\n       final Collection<Unit> bombarding,\n       final Collection<TerritoryEffect> territoryEffects,\n-      final int initialRunCount) {\n-    synchronized (mutexCalcIsRunning) {\n-      awaitLatch();\n-      isCalcSet = false;\n-      int runCount = initialRunCount;\n-      final int workerNum = workers.size();\n-      final int workerRunCount = Math.max(1, (runCount / Math.max(1, workerNum)));\n-      for (final BattleCalculator worker : workers) {\n-        if (!isDataSet || isShutDown) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort\n-          // with null data\n-          return;\n-        }\n-        worker.setCalculateData(\n-            attacker,\n-            defender,\n-            location,\n-            attacking,\n-            defending,\n-            bombarding,\n-            territoryEffects,\n-            (runCount <= 0 ? 0 : workerRunCount));\n-        runCount -= workerRunCount;\n-      }\n-      if (!isDataSet || isShutDown || workerNum <= 0) {\n-        return;\n-      }\n-      isCalcSet = true;\n-    }\n-  }\n-\n-  /**\n-   * Concurrently calculates odds using the OddsCalculatorWorker. It uses Executor to process the\n-   * results. Then waits for all the future results and combines them together.\n-   */\n-  @Override\n-  public AggregateResults calculate() throws IllegalStateException {\n-    synchronized (mutexCalcIsRunning) {\n-      awaitLatch();\n-      final long start = System.currentTimeMillis();\n-      // Create worker thread pool and start all workers\n-      int totalRunCount = 0;\n-      final List<Future<AggregateResults>> list = new ArrayList<>();\n-      for (final BattleCalculator worker : workers) {\n-        if (!getIsReady()) {\n-          // we could have attempted to set a new game data, while the old one was still being set,\n-          // causing it to abort\n-          // with null data\n-          return new AggregateResults(0);\n-        }\n-        if (!worker.getIsReady()) {\n-          throw new IllegalStateException(\"Called calculate before setting calculate data!\");\n-        }\n-        if (worker.getRunCount() > 0) {\n-          totalRunCount += worker.getRunCount();\n-          final Future<AggregateResults> workerResult = executor.submit(worker);\n-          list.add(workerResult);\n-        }\n-      }\n-      // Wait for all worker futures to complete and combine results\n-      final AggregateResults results = new AggregateResults(totalRunCount);\n-      final Set<InterruptedException> interruptExceptions = new HashSet<>();\n-      final Map<String, Set<ExecutionException>> executionExceptions = new HashMap<>();\n-      for (final Future<AggregateResults> future : list) {\n-        try {\n-          final AggregateResults result = future.get();\n-          results.addResults(result.getResults());\n-        } catch (final InterruptedException e) {\n-          Thread.currentThread().interrupt();\n-          interruptExceptions.add(e);\n-        } catch (final ExecutionException e) {\n-          final String cause = e.getCause().getLocalizedMessage();\n-          Set<ExecutionException> exceptions = executionExceptions.get(cause);\n-          if (exceptions == null) {\n-            exceptions = new HashSet<>();\n-          }\n-          exceptions.add(e);\n-          executionExceptions.put(cause, exceptions);\n-        }\n-      }\n-      // we don't want to scare the user with 8+ errors all for the same thing\n-      if (!interruptExceptions.isEmpty()) {\n-        log.log(\n-            Level.SEVERE,\n-            interruptExceptions.size() + \" Battle results workers interrupted\",\n-            interruptExceptions.iterator().next());\n-      }\n-      if (!executionExceptions.isEmpty()) {\n-        Exception e = null;\n-        for (final Set<ExecutionException> entry : executionExceptions.values()) {\n-          if (!entry.isEmpty()) {\n-            e = entry.iterator().next();\n-            log.log(\n-                Level.SEVERE,\n-                entry.size() + \" Battle results workers aborted by exception\",\n-                e.getCause());\n-          }\n-        }\n-        if (e != null) {\n-          throw new IllegalStateException(e.getCause());\n-        }\n-      }\n-      results.setTime(System.currentTimeMillis() - start);\n-      return results;\n-    }\n-  }\n-\n-  @Override\n-  public AggregateResults setCalculateDataAndCalculate(\n+      final boolean retreatWhenOnlyAirLeft,\n+      final int runCount)\n+      throws IllegalStateException {\n+    Preconditions.checkState(!isShutDown, \"ConcurrentBattleCalculator is already shut down\");\n+    Preconditions.checkState(bytes.length != 0, \"Data has not been set yet.\");\n+    final long start = System.currentTimeMillis();\n+    final int runsPerWorker = runCount / MAX_THREADS;\n+    final List<Future<AggregateResults>> results;\n+    synchronized (mutex) {\n+      results =\n+          IntStream.range(0, MAX_THREADS)\n+              .map(index -> index == 0 ? runCount % MAX_THREADS : 0)\n+              .map(runs -> runs + runsPerWorker)\n+              .mapToObj(\n+                  individualRemaining ->\n+                      createBattleCalcWorker(\n+                          attacker,\n+                          defender,\n+                          location,\n+                          attacking,\n+                          defending,\n+                          bombarding,\n+                          territoryEffects,\n+                          retreatWhenOnlyAirLeft,\n+                          individualRemaining))\n+              .collect(Collectors.toList());\n+    }\n+    final AggregateResults result = aggregateResults(results, runsPerWorker);\n+    result.setTime(System.currentTimeMillis() - start);\n+    return result;\n+  }\n+\n+  private Future<AggregateResults> createBattleCalcWorker(", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwMA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073800", "bodyText": "File AbstractProAi.java has 443 lines of code (exceeds 250 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:13Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwMQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073801", "bodyText": "Method purchase has a Cognitive Complexity of 43 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:13Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwMw==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073803", "bodyText": "Method retreatQuery has a Cognitive Complexity of 9 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:14Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwNA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073804", "bodyText": "Method selectCasualties has a Cognitive Complexity of 23 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:14Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()\n+            + \" checking retreat from territory \"\n+            + battleTerritory\n+            + \", attackers=\"\n+            + attackers.size()\n+            + \", defenders=\"\n+            + defenders.size()\n+            + \", submerge=\"\n+            + submerge\n+            + \", attacker=\"\n+            + isAttacker\n+            + \", isStrafing=\"\n+            + isStrafing);\n+    if ((isStrafing || (isAttacker && strengthDifference > 50))\n+        && (battleTerritory.isWater() || attackers.stream().anyMatch(Matches.unitIsLand()))) {\n+      return null;\n+    }\n+    prepareData(getGameData());\n+    return retreatAi.retreatQuery(battleId, battleTerritory, possibleTerritories);\n+  }\n+\n+  @Override\n+  public boolean shouldBomberBomb(final Territory territory) {\n+    return combatMoveAi.isBombing();\n+  }\n+\n+  // TODO: Consider supporting this functionality\n+  @Override\n+  public Collection<Unit> getNumberOfFightersToMoveToNewCarrier(\n+      final Collection<Unit> fightersThatCanBeMoved, final Territory from) {\n+    return new ArrayList<>();\n+  }\n+\n+  @Override", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwNg==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073806", "bodyText": "Method retreatQuery has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:14Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwNw==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073807", "bodyText": "Method retreatQuery has 34 lines of code (exceeds 25 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:14Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwOA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073808", "bodyText": "Method purchase has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:14Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgwOQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073809", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:14Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgxMQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073811", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:15Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgxMg==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073812", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:15Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgxNA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073814", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-25T14:29:15Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()\n+            + \" checking retreat from territory \"\n+            + battleTerritory\n+            + \", attackers=\"\n+            + attackers.size()\n+            + \", defenders=\"\n+            + defenders.size()\n+            + \", submerge=\"\n+            + submerge\n+            + \", attacker=\"\n+            + isAttacker\n+            + \", isStrafing=\"\n+            + isStrafing);\n+    if ((isStrafing || (isAttacker && strengthDifference > 50))\n+        && (battleTerritory.isWater() || attackers.stream().anyMatch(Matches.unitIsLand()))) {\n+      return null;\n+    }\n+    prepareData(getGameData());\n+    return retreatAi.retreatQuery(battleId, battleTerritory, possibleTerritories);\n+  }\n+\n+  @Override\n+  public boolean shouldBomberBomb(final Territory territory) {\n+    return combatMoveAi.isBombing();\n+  }\n+\n+  // TODO: Consider supporting this functionality\n+  @Override\n+  public Collection<Unit> getNumberOfFightersToMoveToNewCarrier(\n+      final Collection<Unit> fightersThatCanBeMoved, final Territory from) {\n+    return new ArrayList<>();\n+  }\n+\n+  @Override\n+  public CasualtyDetails selectCasualties(\n+      final Collection<Unit> selectFrom,\n+      final Map<Unit, Collection<Unit>> dependents,\n+      final int count,\n+      final String message,\n+      final DiceRoll dice,\n+      final GamePlayer hit,\n+      final Collection<Unit> friendlyUnits,\n+      final Collection<Unit> enemyUnits,\n+      final boolean amphibious,\n+      final Collection<Unit> amphibiousLandAttackers,\n+      final CasualtyList defaultCasualties,\n+      final UUID battleId,\n+      final Territory battleSite,\n+      final boolean allowMultipleHitsPerUnit) {\n+    initializeData();\n+\n+    if (defaultCasualties.size() != count) {\n+      throw new IllegalStateException(\n+          \"Select Casualties showing different numbers for number of hits to take vs total \"\n+              + \"size of default casualty selections\");\n+    }\n+    if (defaultCasualties.getKilled().isEmpty()) {\n+      return new CasualtyDetails(defaultCasualties, false);\n+    }\n+\n+    // Consider unit cost\n+    final CasualtyDetails myCasualties = new CasualtyDetails(false);\n+    myCasualties.addToDamaged(defaultCasualties.getDamaged());\n+    final List<Unit> selectFromSorted = new ArrayList<>(selectFrom);\n+    if (enemyUnits.isEmpty()) {\n+      selectFromSorted.sort(ProPurchaseUtils.getCostComparator(proData));\n+    } else {\n+\n+      // Get battle data\n+      final GameData data = getGameData();\n+      final GamePlayer player = this.getGamePlayer();\n+      final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+      final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+      // If defender and could lose battle then don't consider unit cost as just trying to survive\n+      boolean needToCheck = true;\n+      final boolean isAttacker = player.equals(battle.getAttacker());\n+      if (!isAttacker) {\n+        final Collection<Unit> attackers = battle.getAttackingUnits();\n+        final Collection<Unit> defenders = new ArrayList<>(battle.getDefendingUnits());\n+        defenders.removeAll(defaultCasualties.getKilled());\n+        final double strengthDifference =\n+            ProBattleUtils.estimateStrengthDifference(proData, battleSite, attackers, defenders);\n+        int minStrengthDifference = 60;\n+        if (!Properties.getLowLuck(data)) {\n+          minStrengthDifference = 55;\n+        }\n+        if (strengthDifference > minStrengthDifference) {\n+          needToCheck = false;\n+        }\n+      }\n+\n+      // Use bubble sort to save expensive units\n+      while (needToCheck) {\n+        needToCheck = false;\n+        for (int i = 0; i < selectFromSorted.size() - 1; i++) {\n+          final Unit unit1 = selectFromSorted.get(i);\n+          final Unit unit2 = selectFromSorted.get(i + 1);\n+          final double unitCost1 = ProPurchaseUtils.getCost(proData, unit1);\n+          final double unitCost2 = ProPurchaseUtils.getCost(proData, unit2);\n+          if (unitCost1 > 1.5 * unitCost2) {\n+            selectFromSorted.set(i, unit2);\n+            selectFromSorted.set(i + 1, unit1);\n+            needToCheck = true;\n+          }\n+        }\n+      }\n+    }\n+\n+    // Interleave carriers and planes\n+    final List<Unit> interleavedTargetList =\n+        new ArrayList<>(ProTransportUtils.interleaveUnitsCarriersAndPlanes(selectFromSorted, 0));\n+    for (int i = 0; i < defaultCasualties.getKilled().size(); ++i) {\n+      myCasualties.addToKilled(interleavedTargetList.get(i));\n+    }\n+    if (count != myCasualties.size()) {\n+      throw new IllegalStateException(\"AI chose wrong number of casualties\");\n+    }\n+    return myCasualties;\n+  }\n+\n+  @Override\n+  public Map<Territory, Collection<Unit>> scrambleUnitsQuery(\n+      final Territory scrambleTo,\n+      final Map<Territory, Tuple<Collection<Unit>, Collection<Unit>>> possibleScramblers) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle =\n+        delegate.getBattleTracker().getPendingBattle(scrambleTo, false, BattleType.NORMAL);\n+\n+    // If battle is null then don't scramble\n+    if (battle == null) {\n+      return null;\n+    }\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    ProLogger.info(\n+        player.getName()", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MzgxNg==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073816", "bodyText": "TODO found", "author": "codeclimate", "createdAt": "2020-04-25T14:29:15Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(final GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()\n+            + \" checking retreat from territory \"\n+            + battleTerritory\n+            + \", attackers=\"\n+            + attackers.size()\n+            + \", defenders=\"\n+            + defenders.size()\n+            + \", submerge=\"\n+            + submerge\n+            + \", attacker=\"\n+            + isAttacker\n+            + \", isStrafing=\"\n+            + isStrafing);\n+    if ((isStrafing || (isAttacker && strengthDifference > 50))\n+        && (battleTerritory.isWater() || attackers.stream().anyMatch(Matches.unitIsLand()))) {\n+      return null;\n+    }\n+    prepareData(getGameData());\n+    return retreatAi.retreatQuery(battleId, battleTerritory, possibleTerritories);\n+  }\n+\n+  @Override\n+  public boolean shouldBomberBomb(final Territory territory) {\n+    return combatMoveAi.isBombing();\n+  }\n+\n+  // TODO: Consider supporting this functionality", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3Mzk5Mg==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415073992", "bodyText": "Note to future self:\nThis change was unintended", "author": "RoiEXLab", "createdAt": "2020-04-25T14:30:36Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/logging/ProLogSettings.java", "diffHunk": "@@ -57,7 +57,7 @@ static void saveSettings(final ProLogSettings settings) {\n                   outputStream.writeObject(settings);\n                 }\n               });\n-      final Preferences prefs = Preferences.userNodeForPackage(ProAi.class);", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3NDQ5NQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415074495", "bodyText": "Interesting observation.\n\"Fast AI\" is a subclass of the new AbstractProAi, previously just ProAi.\nSo it would fall under the same category. Is this intended?", "author": "RoiEXLab", "createdAt": "2020-04-25T14:33:12Z", "path": "game-core/src/main/java/games/strategy/triplea/ui/menubar/DebugMenu.java", "diffHunk": "@@ -18,10 +18,10 @@\n     setMnemonic(KeyEvent.VK_D);\n \n     final Set<Player> players = frame.getLocalPlayers().getLocalPlayers();\n-    final boolean areThereProAIs = players.stream().anyMatch(ProAi.class::isInstance);\n+    final boolean areThereProAIs = players.stream().anyMatch(AbstractProAi.class::isInstance);\n     if (areThereProAIs) {\n-      ProAi.initialize(frame);\n-      add(SwingAction.of(\"Show Hard AI Logs\", ProAi::showSettingsWindow))\n+      AbstractProAi.initialize(frame);\n+      add(SwingAction.of(\"Show Hard AI Logs\", AbstractProAi::showSettingsWindow))", "originalCommit": "de30a9571be0df800d667b9bfa274317cc851890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4MDA5OA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415180098", "bodyText": "I would suspect so. It would kinda seem Fast AI is not really a true AI but a variant of ProAI. Given that, I would personally look to see if we can inject behavior to a ProAI class.\nEG:\nFastAI extends ProAi{\n   FastAI() {\n      super(ProAiConfig.builder()\n             .battleCalcImplementation(new FastAiBattleCalc())\n             .build());\n   }\n}\n\nLaboriousAi extends ProAi{\n   LaboriousAiI() {\n      super(ProAiConfig.builder()\n             .battleCalcImplementation(new LaboriousBattleCalc())\n             .build());\n   }\n}\n\nOr even better, do the above as constructor args.", "author": "DanVanAtta", "createdAt": "2020-04-26T00:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3NDQ5NQ=="}], "type": "inlineReview"}, {"oid": "ad20362fe401398a15daeba89088d5c9c4654cca", "url": "https://github.com/triplea-game/triplea/commit/ad20362fe401398a15daeba89088d5c9c4654cca", "message": "Simplify interface", "committedDate": "2020-04-26T00:17:23Z", "type": "commit"}, {"oid": "1fa9fb333b9b3314073ae2867f18afd3709d5373", "url": "https://github.com/triplea-game/triplea/commit/1fa9fb333b9b3314073ae2867f18afd3709d5373", "message": "Auto-Formatting", "committedDate": "2020-04-26T00:17:41Z", "type": "commit"}, {"oid": "311429d9d06e07651729dabc260138b63fad0936", "url": "https://github.com/triplea-game/triplea/commit/311429d9d06e07651729dabc260138b63fad0936", "message": "Rewire ProAi hierarchy", "committedDate": "2020-04-26T00:17:47Z", "type": "commit"}, {"oid": "f2d103eea20935030ae53ef46696d88a02d9e064", "url": "https://github.com/triplea-game/triplea/commit/f2d103eea20935030ae53ef46696d88a02d9e064", "message": "Remove isAlive from interface declaration", "committedDate": "2020-04-26T00:17:55Z", "type": "commit"}, {"oid": "953824c95bbdc06c623a16320e36db6abf853ec9", "url": "https://github.com/triplea-game/triplea/commit/953824c95bbdc06c623a16320e36db6abf853ec9", "message": "Remove setGameData from IBattleCalculator interface", "committedDate": "2020-04-26T00:18:06Z", "type": "commit"}, {"oid": "b891d124f2e39ac5b13ed82420256e716c02ecd8", "url": "https://github.com/triplea-game/triplea/commit/b891d124f2e39ac5b13ed82420256e716c02ecd8", "message": "Remove configurable parameters from interface", "committedDate": "2020-04-26T00:18:12Z", "type": "commit"}, {"oid": "0fbf6bd955f5aae88c34a5ef976852eef9ba068e", "url": "https://github.com/triplea-game/triplea/commit/0fbf6bd955f5aae88c34a5ef976852eef9ba068e", "message": "Re-add retreatWhenOnlyAirLeft to interface", "committedDate": "2020-04-26T00:18:21Z", "type": "commit"}, {"oid": "627a8a35aaa8e1637b267595a2a28c8f5c883af1", "url": "https://github.com/triplea-game/triplea/commit/627a8a35aaa8e1637b267595a2a28c8f5c883af1", "message": "Move retreatWhenOnlyAirLeft to calculate signature", "committedDate": "2020-04-26T00:18:34Z", "type": "commit"}, {"oid": "2017ef0a3db0179390dd452907be49c38da9a7fa", "url": "https://github.com/triplea-game/triplea/commit/2017ef0a3db0179390dd452907be49c38da9a7fa", "message": "Fix inverted boolean", "committedDate": "2020-04-26T00:18:42Z", "type": "commit"}, {"oid": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "url": "https://github.com/triplea-game/triplea/commit/9876a6603a28666ce9a64b5fb893d5832a3ad002", "message": "Remove final keyword", "committedDate": "2020-04-26T00:18:50Z", "type": "commit"}, {"oid": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "url": "https://github.com/triplea-game/triplea/commit/9876a6603a28666ce9a64b5fb893d5832a3ad002", "message": "Remove final keyword", "committedDate": "2020-04-26T00:18:50Z", "type": "forcePushed"}, {"oid": "6f36af3fe9272a1ffa004a22e13040c7fffb8866", "url": "https://github.com/triplea-game/triplea/commit/6f36af3fe9272a1ffa004a22e13040c7fffb8866", "message": "Use ProAi preference store", "committedDate": "2020-04-26T00:22:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTY3NQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415175675", "bodyText": "Method selectCasualties has 59 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-26T00:25:12Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()\n+            + \" checking retreat from territory \"\n+            + battleTerritory\n+            + \", attackers=\"\n+            + attackers.size()\n+            + \", defenders=\"\n+            + defenders.size()\n+            + \", submerge=\"\n+            + submerge\n+            + \", attacker=\"\n+            + isAttacker\n+            + \", isStrafing=\"\n+            + isStrafing);\n+    if ((isStrafing || (isAttacker && strengthDifference > 50))\n+        && (battleTerritory.isWater() || attackers.stream().anyMatch(Matches.unitIsLand()))) {\n+      return null;\n+    }\n+    prepareData(getGameData());\n+    return retreatAi.retreatQuery(battleId, battleTerritory, possibleTerritories);\n+  }\n+\n+  @Override\n+  public boolean shouldBomberBomb(final Territory territory) {\n+    return combatMoveAi.isBombing();\n+  }\n+\n+  // TODO: Consider supporting this functionality\n+  @Override\n+  public Collection<Unit> getNumberOfFightersToMoveToNewCarrier(\n+      final Collection<Unit> fightersThatCanBeMoved, final Territory from) {\n+    return new ArrayList<>();\n+  }\n+\n+  @Override", "originalCommit": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTY3Ng==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415175676", "bodyText": "Method purchase has 89 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-26T00:25:12Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override", "originalCommit": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTY3Nw==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415175677", "bodyText": "Method selectCasualties has a Cognitive Complexity of 23 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-26T00:25:13Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override\n+  public Territory retreatQuery(\n+      final UUID battleId,\n+      final boolean submerge,\n+      final Territory battleTerritory,\n+      final Collection<Territory> possibleTerritories,\n+      final String message) {\n+    initializeData();\n+\n+    // Get battle data\n+    final GameData data = getGameData();\n+    final GamePlayer player = this.getGamePlayer();\n+    final BattleDelegate delegate = DelegateFinder.battleDelegate(data);\n+    final IBattle battle = delegate.getBattleTracker().getPendingBattle(battleId);\n+\n+    // If battle is null or amphibious then don't retreat\n+    if (battle == null || battleTerritory == null || battle.isAmphibious()) {\n+      return null;\n+    }\n+\n+    // If attacker with more unit strength or strafing and isn't land battle with only air left then\n+    // don't retreat\n+    final boolean isAttacker = player.equals(battle.getAttacker());\n+    final Collection<Unit> attackers = battle.getAttackingUnits();\n+    final Collection<Unit> defenders = battle.getDefendingUnits();\n+    final double strengthDifference =\n+        ProBattleUtils.estimateStrengthDifference(proData, battleTerritory, attackers, defenders);\n+    final boolean isStrafing = isAttacker && storedStrafingTerritories.contains(battleTerritory);\n+    ProLogger.info(\n+        player.getName()\n+            + \" checking retreat from territory \"\n+            + battleTerritory\n+            + \", attackers=\"\n+            + attackers.size()\n+            + \", defenders=\"\n+            + defenders.size()\n+            + \", submerge=\"\n+            + submerge\n+            + \", attacker=\"\n+            + isAttacker\n+            + \", isStrafing=\"\n+            + isStrafing);\n+    if ((isStrafing || (isAttacker && strengthDifference > 50))\n+        && (battleTerritory.isWater() || attackers.stream().anyMatch(Matches.unitIsLand()))) {\n+      return null;\n+    }\n+    prepareData(getGameData());\n+    return retreatAi.retreatQuery(battleId, battleTerritory, possibleTerritories);\n+  }\n+\n+  @Override\n+  public boolean shouldBomberBomb(final Territory territory) {\n+    return combatMoveAi.isBombing();\n+  }\n+\n+  // TODO: Consider supporting this functionality\n+  @Override\n+  public Collection<Unit> getNumberOfFightersToMoveToNewCarrier(\n+      final Collection<Unit> fightersThatCanBeMoved, final Territory from) {\n+    return new ArrayList<>();\n+  }\n+\n+  @Override", "originalCommit": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTY3OA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415175678", "bodyText": "Method retreatQuery has a Cognitive Complexity of 9 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-26T00:25:13Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override", "originalCommit": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTY4Mg==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415175682", "bodyText": "Method retreatQuery has 34 lines of code (exceeds 30 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-26T00:25:13Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void purchase(\n+      final boolean purchaseForBid,\n+      final int pusToSpend,\n+      final IPurchaseDelegate purchaseDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    if (pusToSpend <= 0) {\n+      return;\n+    }\n+    if (purchaseForBid) {\n+      prepareData(data);\n+      storedPurchaseTerritories = purchaseAi.bid(pusToSpend, purchaseDelegate, data);\n+    } else {\n+\n+      // Repair factories\n+      purchaseAi.repair(pusToSpend, purchaseDelegate, data, player);\n+\n+      // Check if any place territories exist\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories =\n+          ProPurchaseUtils.findPurchaseTerritories(proData, player);\n+      final List<Territory> possibleFactoryTerritories =\n+          CollectionUtils.getMatches(\n+              data.getMap().getTerritories(),\n+              ProMatches.territoryHasNoInfraFactoryAndIsNotConqueredOwnedLand(player, data));\n+      if (purchaseTerritories.isEmpty() && possibleFactoryTerritories.isEmpty()) {\n+        ProLogger.info(\"No possible place or factory territories owned so exiting purchase logic\");\n+        return;\n+      }\n+      ProLogger.info(\"Starting simulation for purchase phase\");\n+\n+      // Setup data copy and delegates\n+      final GameData dataCopy;\n+      try {\n+        data.acquireWriteLock();\n+        dataCopy = GameDataUtils.cloneGameDataWithoutHistory(data, true);\n+      } catch (final Throwable t) {\n+        ProLogger.log(Level.WARNING, \"Error trying to clone game data for simulating phases\", t);\n+        return;\n+      } finally {\n+        data.releaseWriteLock();\n+      }\n+      prepareData(dataCopy);\n+      final GamePlayer playerCopy = dataCopy.getPlayerList().getPlayerId(player.getName());\n+      final IMoveDelegate moveDel = DelegateFinder.moveDelegate(dataCopy);\n+      final IDelegateBridge bridge = new ProDummyDelegateBridge(this, playerCopy, dataCopy);\n+      moveDel.setDelegateBridgeAndPlayer(bridge);\n+\n+      // Determine turn sequence\n+      final List<GameStep> gameSteps = new ArrayList<>();\n+      for (final GameStep gameStep : dataCopy.getSequence()) {\n+        gameSteps.add(gameStep);\n+      }\n+\n+      // Simulate the next phases until place/end of turn is reached then use simulated data for\n+      // purchase\n+      final int nextStepIndex = dataCopy.getSequence().getStepIndex() + 1;\n+      for (int i = nextStepIndex; i < gameSteps.size(); i++) {\n+        final GameStep step = gameSteps.get(i);\n+        if (!playerCopy.equals(step.getPlayerId())) {\n+          continue;\n+        }\n+        dataCopy\n+            .getSequence()\n+            .setRoundAndStep(\n+                dataCopy.getSequence().getRound(), step.getDisplayName(), step.getPlayerId());\n+        final String stepName = step.getName();\n+        ProLogger.info(\"Simulating phase: \" + stepName);\n+        if (stepName.endsWith(\"NonCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> factoryMoveMap =\n+              nonCombatMoveAi.simulateNonCombatMove(moveDel);\n+          if (storedFactoryMoveMap == null) {\n+            storedFactoryMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, factoryMoveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"CombatMove\") && !stepName.endsWith(\"AirborneCombatMove\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          final Map<Territory, ProTerritory> moveMap = combatMoveAi.doCombatMove(moveDel);\n+          if (storedCombatMoveMap == null) {\n+            storedCombatMoveMap =\n+                ProSimulateTurnUtils.transferMoveMap(proData, moveMap, data, player);\n+          }\n+        } else if (stepName.endsWith(\"Battle\")) {\n+          proData.initializeSimulation(this, dataCopy, playerCopy);\n+          ProSimulateTurnUtils.simulateBattles(proData, dataCopy, playerCopy, bridge, calc);\n+        } else if (stepName.endsWith(\"Place\") || stepName.endsWith(\"EndTurn\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          storedPurchaseTerritories = purchaseAi.purchase(purchaseDelegate, data);\n+          break;\n+        } else if (stepName.endsWith(\"Politics\")) {\n+          proData.initializeSimulation(this, dataCopy, player);\n+          // Can only do politics if this player still owns its capital.\n+          if (proData.getMyCapital() == null || proData.getMyCapital().getOwner().equals(player)) {\n+            final PoliticsDelegate politicsDelegate = DelegateFinder.politicsDelegate(dataCopy);\n+            politicsDelegate.setDelegateBridgeAndPlayer(bridge);\n+            final List<PoliticalActionAttachment> actions = politicsAi.politicalActions();\n+            if (storedPoliticalActions == null) {\n+              storedPoliticalActions = actions;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    ProLogger.info(player.getName() + \" time for purchase=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void place(\n+      final boolean bid,\n+      final IAbstractPlaceDelegate placeDelegate,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    purchaseAi.place(storedPurchaseTerritories, placeDelegate);\n+    storedPurchaseTerritories = null;\n+    ProLogger.info(player.getName() + \" time for place=\" + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override\n+  protected void tech(\n+      final ITechDelegate techDelegate, final GameData data, final GamePlayer player) {\n+    ProTechAi.tech(techDelegate, data, player);\n+  }\n+\n+  @Override", "originalCommit": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTY4Ng==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415175686", "bodyText": "Method purchase has a Cognitive Complexity of 43 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-26T00:25:13Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(GameData data);\n+\n+  @Override\n+  protected void move(\n+      final boolean nonCombat,\n+      final IMoveDelegate moveDel,\n+      final GameData data,\n+      final GamePlayer player) {\n+    final long start = System.currentTimeMillis();\n+    ProLogUi.notifyStartOfRound(data.getSequence().getRound(), player.getName());\n+    initializeData();\n+    prepareData(data);\n+    if (nonCombat) {\n+      nonCombatMoveAi.doNonCombatMove(storedFactoryMoveMap, storedPurchaseTerritories, moveDel);\n+      storedFactoryMoveMap = null;\n+    } else {\n+      if (storedCombatMoveMap == null) {\n+        combatMoveAi.doCombatMove(moveDel);\n+      } else {\n+        combatMoveAi.doMove(storedCombatMoveMap, moveDel, data, player);\n+        storedCombatMoveMap = null;\n+      }\n+    }\n+    ProLogger.info(\n+        player.getName()\n+            + \" time for nonCombat=\"\n+            + nonCombat\n+            + \" time=\"\n+            + (System.currentTimeMillis() - start));\n+  }\n+\n+  @Override", "originalCommit": "9876a6603a28666ce9a64b5fb893d5832a3ad002", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1d08567966c99a225b63fb49c861ce7d2230586e", "url": "https://github.com/triplea-game/triplea/commit/1d08567966c99a225b63fb49c861ce7d2230586e", "message": "Remove IBattleCalculator#getThreadCount\n\nThis method is only used for display purposes, a detail that might not even be accurate.", "committedDate": "2020-04-26T00:27:42Z", "type": "commit"}, {"oid": "0be48096b9d8ef13cf068e4fc9d9d7f073fa2860", "url": "https://github.com/triplea-game/triplea/commit/0be48096b9d8ef13cf068e4fc9d9d7f073fa2860", "message": "Auto-Formatting", "committedDate": "2020-04-26T00:31:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3Nzk0Ng==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415177946", "bodyText": "Should this remain as an abstract method?\nAt first glance it seems like Fast AI would want to return its own player type.", "author": "DanVanAtta", "createdAt": "2020-04-26T00:41:04Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;", "originalCommit": "0be48096b9d8ef13cf068e4fc9d9d7f073fa2860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4MTQ0MQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415181441", "bodyText": "Right, wanted to make this change, but forgot to do so", "author": "RoiEXLab", "createdAt": "2020-04-26T01:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3Nzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3ODEwNQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415178105", "bodyText": "Side-note, ProLogXX should probably be specific to the ProAI; it seems we have a more generic tool and it should instead be the AiLogUi and/or AiLogger", "author": "DanVanAtta", "createdAt": "2020-04-26T00:41:57Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);", "originalCommit": "0be48096b9d8ef13cf068e4fc9d9d7f073fa2860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4MTUwOQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415181509", "bodyText": "Maybe @ron-murhammer has any insight?", "author": "RoiEXLab", "createdAt": "2020-04-26T01:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3ODEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4NzY2MQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415187661", "bodyText": "I believe the log UI initialize is used for both the pro and fast ai.", "author": "ron-murhammer", "createdAt": "2020-04-26T01:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3ODEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3ODE3MQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415178171", "bodyText": "This method could perhaps use a javadoc to explain what we would expect implementations to do, and to define prepareData", "author": "DanVanAtta", "createdAt": "2020-04-26T00:42:37Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,513 @@\n+package games.strategy.triplea.ai.pro;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.GameStep;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.engine.framework.GameDataUtils;\n+import games.strategy.engine.framework.startup.ui.PlayerType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.AbstractAi;\n+import games.strategy.triplea.ai.pro.data.ProBattleResult;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProTerritory;\n+import games.strategy.triplea.ai.pro.logging.ProLogUi;\n+import games.strategy.triplea.ai.pro.logging.ProLogger;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.ai.pro.simulate.ProSimulateTurnUtils;\n+import games.strategy.triplea.ai.pro.util.ProBattleUtils;\n+import games.strategy.triplea.ai.pro.util.ProMatches;\n+import games.strategy.triplea.ai.pro.util.ProOddsCalculator;\n+import games.strategy.triplea.ai.pro.util.ProPurchaseUtils;\n+import games.strategy.triplea.ai.pro.util.ProTransportUtils;\n+import games.strategy.triplea.attachments.PoliticalActionAttachment;\n+import games.strategy.triplea.delegate.DelegateFinder;\n+import games.strategy.triplea.delegate.DiceRoll;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.PoliticsDelegate;\n+import games.strategy.triplea.delegate.battle.BattleDelegate;\n+import games.strategy.triplea.delegate.battle.IBattle;\n+import games.strategy.triplea.delegate.battle.IBattle.BattleType;\n+import games.strategy.triplea.delegate.data.CasualtyDetails;\n+import games.strategy.triplea.delegate.data.CasualtyList;\n+import games.strategy.triplea.delegate.remote.IAbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.remote.IMoveDelegate;\n+import games.strategy.triplea.delegate.remote.IPurchaseDelegate;\n+import games.strategy.triplea.delegate.remote.ITechDelegate;\n+import games.strategy.triplea.odds.calculator.IBattleCalculator;\n+import games.strategy.triplea.ui.TripleAFrame;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.logging.Level;\n+import lombok.Getter;\n+import org.triplea.java.collections.CollectionUtils;\n+import org.triplea.util.Tuple;\n+\n+/** Pro AI. */\n+public abstract class AbstractProAi extends AbstractAi {\n+\n+  private final ProOddsCalculator calc;\n+  @Getter private final ProData proData;\n+\n+  // Phases\n+  private final ProCombatMoveAi combatMoveAi;\n+  private final ProNonCombatMoveAi nonCombatMoveAi;\n+  private final ProPurchaseAi purchaseAi;\n+  private final ProRetreatAi retreatAi;\n+  private final ProScrambleAi scrambleAi;\n+  private final ProPoliticsAi politicsAi;\n+\n+  // Data shared across phases\n+  private Map<Territory, ProTerritory> storedCombatMoveMap;\n+  private Map<Territory, ProTerritory> storedFactoryMoveMap;\n+  private Map<Territory, ProPurchaseTerritory> storedPurchaseTerritories;\n+  private List<PoliticalActionAttachment> storedPoliticalActions;\n+  private List<Territory> storedStrafingTerritories;\n+\n+  public AbstractProAi(\n+      final String name, final IBattleCalculator battleCalculator, final ProData proData) {\n+    super(name);\n+    this.proData = proData;\n+    calc = new ProOddsCalculator(battleCalculator);\n+    combatMoveAi = new ProCombatMoveAi(this);\n+    nonCombatMoveAi = new ProNonCombatMoveAi(this);\n+    purchaseAi = new ProPurchaseAi(this);\n+    retreatAi = new ProRetreatAi(this);\n+    scrambleAi = new ProScrambleAi(this);\n+    politicsAi = new ProPoliticsAi(this);\n+    storedCombatMoveMap = null;\n+    storedFactoryMoveMap = null;\n+    storedPurchaseTerritories = null;\n+    storedPoliticalActions = null;\n+    storedStrafingTerritories = new ArrayList<>();\n+  }\n+\n+  @Override\n+  public void stopGame() {\n+    super.stopGame(); // absolutely MUST call super.stopGame() first\n+    calc.stop();\n+  }\n+\n+  @Override\n+  public PlayerType getPlayerType() {\n+    return PlayerType.PRO_AI;\n+  }\n+\n+  public ProOddsCalculator getCalc() {\n+    return calc;\n+  }\n+\n+  public static void initialize(final TripleAFrame frame) {\n+    ProLogUi.initialize(frame);\n+    ProLogger.info(\"Initialized Hard AI\");\n+  }\n+\n+  public static void showSettingsWindow() {\n+    ProLogger.info(\"Showing Hard AI settings window\");\n+    ProLogUi.showSettingsWindow();\n+  }\n+\n+  private void initializeData() {\n+    proData.initialize(this);\n+  }\n+\n+  public void setStoredStrafingTerritories(final List<Territory> strafingTerritories) {\n+    storedStrafingTerritories = strafingTerritories;\n+  }\n+\n+  protected abstract void prepareData(GameData data);", "originalCommit": "0be48096b9d8ef13cf068e4fc9d9d7f073fa2860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3ODk5NA==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415178994", "bodyText": "nit, we probably should be shooting for the dependency to be on an interface where it so happens that AbstractProAi implements that interface. To get there we may have to think a bit more about the modelling of this one AI and which interfaces it makes sense to have.\nTo another extent, we should perhaps also consider 'interface segregation principal' and how many interfaces we would need so that a dependency like this is only given an interface where it actually uses everything that is passed to it.", "author": "DanVanAtta", "createdAt": "2020-04-26T00:48:09Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/ProCombatMoveAi.java", "diffHunk": "@@ -54,7 +54,7 @@\n   private boolean isDefensive;\n   private boolean isBombing;\n \n-  ProCombatMoveAi(final ProAi ai) {\n+  ProCombatMoveAi(final AbstractProAi ai) {", "originalCommit": "0be48096b9d8ef13cf068e4fc9d9d7f073fa2860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3OTYzNg==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415179636", "bodyText": "Question/side-comment: if we are making a copy of GameData for the battle calculator, do you know why we need to lock it?", "author": "DanVanAtta", "createdAt": "2020-04-26T00:52:38Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/ConcurrentBattleCalculator.java", "diffHunk": "@@ -69,20 +68,13 @@ public ConcurrentBattleCalculator(final String threadNamePrefix) {\n     this.dataLoadedAction = dataLoadedAction;\n   }\n \n-  @Override\n   public void setGameData(final GameData data) {\n     synchronized (mutex) {", "originalCommit": "0be48096b9d8ef13cf068e4fc9d9d7f073fa2860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4MjA1NQ==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r415182055", "bodyText": "I added a javadoc to the mutex field that should clarify this question.\nBasically the mutex is not for thread safety, but rather for thread consistency.\nWithout this mutex it could happen that the gamedata is changed when we're actively deserializing the gamedata to create BattleCalculator workers, so the first x workers have the old data and the last y workers use the newer data which would screw up the results", "author": "RoiEXLab", "createdAt": "2020-04-26T01:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3OTYzNg=="}], "type": "inlineReview"}, {"oid": "67e7aebe567676327724bb2860260999d9613559", "url": "https://github.com/triplea-game/triplea/commit/67e7aebe567676327724bb2860260999d9613559", "message": "Move method up one layer to enforce overriding", "committedDate": "2020-04-28T09:24:04Z", "type": "commit"}, {"oid": "c16944fc1e39b3279fb550e6e6688a63705e4f0f", "url": "https://github.com/triplea-game/triplea/commit/c16944fc1e39b3279fb550e6e6688a63705e4f0f", "message": "Add javadoc to abstract method", "committedDate": "2020-04-28T09:24:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ2NjAwNw==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r416466007", "bodyText": "File AbstractProAi.java has 438 lines of code (exceeds 250 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-28T09:26:07Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,512 @@\n+package games.strategy.triplea.ai.pro;", "originalCommit": "c16944fc1e39b3279fb550e6e6688a63705e4f0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3778bacc0f1830e07703b72b50d4578218457da6", "url": "https://github.com/triplea-game/triplea/commit/3778bacc0f1830e07703b72b50d4578218457da6", "message": "Auto-Formatting", "committedDate": "2020-04-28T09:26:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ2NzU4Nw==", "url": "https://github.com/triplea-game/triplea/pull/6329#discussion_r416467587", "bodyText": "File AbstractProAi.java has 438 lines of code (exceeds 250 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-04-28T09:28:36Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/AbstractProAi.java", "diffHunk": "@@ -0,0 +1,511 @@\n+package games.strategy.triplea.ai.pro;", "originalCommit": "3778bacc0f1830e07703b72b50d4578218457da6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}