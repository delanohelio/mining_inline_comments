{"pr_number": 7740, "pr_title": "Replace amphibiousLandAttackers list with checks for wasAmphibious", "pr_createdAt": "2020-09-23T04:30:43Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7740", "timeline": [{"oid": "6929f876be901378eac37f44994a0c6e13b031bf", "url": "https://github.com/triplea-game/triplea/commit/6929f876be901378eac37f44994a0c6e13b031bf", "message": "Replace amphibiousLandAttackers list with checks for wasAmphibious", "committedDate": "2020-09-23T01:48:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MDc5MA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493190790", "bodyText": "I have this code duplicated several times.  If you have any suggestions on how to shrink it, I'd love to know.", "author": "trevan", "createdAt": "2020-09-23T04:31:34Z", "path": "game-core/src/main/java/games/strategy/triplea/odds/calculator/BattleCalculator.java", "diffHunk": "@@ -103,11 +103,25 @@ public AggregateResults calculate(\n         final MustFightBattle battle =\n             new MustFightBattle(location2, attacker2, gameData, battleTracker);\n         battle.setHeadless(true);\n+        if (amphibious) {\n+          attackingUnits.forEach(\n+              unit -> {\n+                unit.getProperty(Unit.UNLOADED_AMPHIBIOUS)", "originalCommit": "6929f876be901378eac37f44994a0c6e13b031bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MTUyNw==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494681527", "bodyText": "I suspect attackingUnits would need to become a datatype. In this case you could put this logic behind a method. I don't think I'd advise to do that just yet, the amount of data copying could actually become significant. BattleCalculator is regrettably a giant mess AND performance sensitive, a horrible combination and place to be..", "author": "DanVanAtta", "createdAt": "2020-09-25T00:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MDc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTEyMQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494719121", "bodyText": "Another thought, the API of the 'setProperty' is wonky with the exception type. If there were type safe overloads of the method without a throws, then the repetition would not be much of a problem at all.", "author": "DanVanAtta", "createdAt": "2020-09-25T02:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NzQzNA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493197434", "bodyText": "Are game clients getting all of the battle parameters from their local state? Is it this method that feeds the parameters to the remote clients?\nLooking at this param list, it looks like this is what is used for calculating supports. The supports are used when calculating order of loss.", "author": "DanVanAtta", "createdAt": "2020-09-23T04:58:03Z", "path": "game-core/src/main/java/games/strategy/engine/display/IDisplay.java", "diffHunk": "@@ -54,6 +55,8 @@ void reportMessageToPlayers(\n    * @param attacker - PlayerId of attacker\n    * @param defender - PlayerId of defender\n    */\n+  @RemoveOnNextMajorRelease(\n+      \"Remove isAmphibious, amphibiousLandAttackers, dependentUnits, and battleTitle\")\n   @RemoteActionCode(12)\n   void showBattle(", "originalCommit": "6929f876be901378eac37f44994a0c6e13b031bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTIxMA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493659210", "bodyText": "This is only for showing the battle display.  It actually makes a copy of all of these parameters (see BattlePanel#showBatle).\nIt looks like the actual battle takes place on the client that is attacking.  The other clients have the battle display and this is initially populated with the data from the attacking client and then updated through calls from the attacking client.\nThis method looks like it could use the BattleState instead of the individual items.", "author": "trevan", "createdAt": "2020-09-23T14:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5NzQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODY2Ng==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493198666", "bodyText": "Have you tested if marines are being given an amphib assault bonus on standard land battles? I'd double check that looking at this update. Have you run across where 'getWasAmphibious' is set to true (could you point me there)?", "author": "DanVanAtta", "createdAt": "2020-09-23T05:02:41Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/DiceRoll.java", "diffHunk": "@@ -803,7 +797,7 @@ public static DiceRoll rollNDice(\n                 UnitSupportAttachment::getStrength);\n       } else {\n         strength = ua.getAttack(unit.getOwner());\n-        if (ua.getIsMarine() != 0 && isAmphibiousBattle && amphibiousLandAttackers.contains(unit)) {", "originalCommit": "6929f876be901378eac37f44994a0c6e13b031bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYzMzgwMA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493633800", "bodyText": "getWasAmphibious is only set in TransportTracker#unloadTransportChange and that is when a transport is unloaded.  I just ran a game where I did an amphibious assault and then in the next turn used the same units to attack a standard land battle.  wasAmphibious was true for the first battle but false for the second battle.  I've also tested battles that don't have any amphibious assault and wasAmphibious is false there as well.", "author": "trevan", "createdAt": "2020-09-23T14:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc2MjE1Mg==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493762152", "bodyText": "Interesting, that implies/confirms at one point a new way to track amphibious units was simply built without regard to the existing mechanism. This is then a very good example of SRP / DRY being violated.\nIt might be worthwhile to walk through this code execution in a debugger to make sure it all looks good at that level. It sounds like the test cases you've ran through have been pretty comprehensive.", "author": "DanVanAtta", "createdAt": "2020-09-23T17:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg5ODM1NQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493898355", "bodyText": "Yeah, I went through it with a debugger to make sure the value was what I expected.  If you have two units attacking and one was amphibious but the other goes by land, only the amphibious unit has wasAmphibious.\nLooking at the history, it appears that amphibiousLandAttackers was first created to track if a battle was amphibious.  Then, when marine bonuses were added, the wasAmphibious was added but it was used oddly (it kind of determined if a battle was amphibious but wasn't used to check if the unit should get a marine bonus).  Then that code had concurrent issues because it talked to the battle tracker.  It was finally removed and replaced by plumbing amphibiousLandAttackers through.\nI think this new way (using wasAmphibious) should work correctly and it should be simpler.", "author": "trevan", "createdAt": "2020-09-23T21:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkwMDgzMQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493900831", "bodyText": "\ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-09-23T21:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTAxMA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493199010", "bodyText": "This is a suspect I believe for save game compatibility issues. Have you double checked that this field is not serialized?", "author": "DanVanAtta", "createdAt": "2020-09-23T05:04:01Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AbstractBattle.java", "diffHunk": "@@ -57,7 +57,6 @@\n \n   List<Unit> attackingUnits = new ArrayList<>();\n   List<Unit> defendingUnits = new ArrayList<>();\n-  List<Unit> amphibiousLandAttackers = new ArrayList<>();", "originalCommit": "6929f876be901378eac37f44994a0c6e13b031bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYzNDI0Ng==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493634246", "bodyText": "Oddly enough, it didn't prevent loading an old save game.  But I'm adding them back in.", "author": "trevan", "createdAt": "2020-09-23T14:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTE1Nw==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493199157", "bodyText": "Does the list need to be modifiable? If not, List.of() is the conventional preference for empty lists.", "author": "DanVanAtta", "createdAt": "2020-09-23T05:04:34Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/AirBattle.java", "diffHunk": "@@ -705,7 +705,6 @@ public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n                       defendingUnits,\n                       attackingUnits,\n                       false,\n-                      new ArrayList<>(),", "originalCommit": "6929f876be901378eac37f44994a0c6e13b031bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYzNTAzNA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493635034", "bodyText": "This list was removed.", "author": "trevan", "createdAt": "2020-09-23T14:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTQxMA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493199410", "bodyText": "WDYT of using an enum here to represent the different battle states? It would be purely for a more descriptive API", "author": "DanVanAtta", "createdAt": "2020-09-23T05:05:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -145,14 +145,13 @@ public void setUnits(\n       final Collection<Unit> defending,\n       final Collection<Unit> attacking,\n       final Collection<Unit> bombarding,\n-      final Collection<Unit> amphibious,\n+      final boolean amphibious,", "originalCommit": "6929f876be901378eac37f44994a0c6e13b031bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYzNzM0MQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493637341", "bodyText": "Such as BattleType?  You recently modified it for the different air battles.  Maybe add AMPHIBIOUS there as well?", "author": "trevan", "createdAt": "2020-09-23T14:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1OTI5Ng==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493759296", "bodyText": "That is not a bad idea. I think there are two options:\n\na new enum with AMPHIBIOUS and NON_AMPHIBIOUS\nadd an entry for battle type\n\nThere are pros & cons to either approach.", "author": "DanVanAtta", "createdAt": "2020-09-23T17:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTQxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MDIwMw==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493950203", "bodyText": "I looked into what the amphibious was used for and after tracking down its usage, I don't think it is actually needed.  I think that 'amphibious' can be determined by looping through the units and seeing if one of them has a wasAmphibious.\nI wasn't completely certain because of a few uses of AbstractBattle#isAmphibious but I felt that the use here could be removed.  So, I didn't do any enum.", "author": "trevan", "createdAt": "2020-09-23T23:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5OTQxMA=="}], "type": "inlineReview"}, {"oid": "38356cc9eb6ca1f079605742365bafb51fa569ea", "url": "https://github.com/triplea-game/triplea/commit/38356cc9eb6ca1f079605742365bafb51fa569ea", "message": "Re-add class fields that might affect serialization", "committedDate": "2020-09-23T14:27:21Z", "type": "commit"}, {"oid": "a694383eb8354a4f03a96fb11f016bed20ac02ac", "url": "https://github.com/triplea-game/triplea/commit/a694383eb8354a4f03a96fb11f016bed20ac02ac", "message": "Deprecate most usage of amphibious member of AbstractBattle", "committedDate": "2020-09-23T23:15:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MDkzNA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493950934", "bodyText": "I can't figure out why these sorts (sortPreBattle and sortAmphib) happen here.  I tested battles with them removed and things seemed to work the same.  I think that these methods probably existed before the more complex casualty sorter was built and no one got around to removing them.  I worried about removing them as part of this PR but I think they can be removed.", "author": "trevan", "createdAt": "2020-09-23T23:23:57Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -718,17 +709,13 @@ public void fight(final IDelegateBridge bridge) {\n         dependentUnits,\n         attacker,\n         defender,\n-        isAmphibious(),\n+        false,\n         getBattleType(),\n-        amphibiousLandAttackers);\n+        List.of());\n     display.listBattleSteps(battleId, stepStrings);\n     if (!headless) {\n       // take the casualties with least movement first\n-      if (isAmphibious()) {\n-        CasualtySortingUtil.sortAmphib(attackingUnits, amphibiousLandAttackers);\n-      } else {\n-        CasualtySortingUtil.sortPreBattle(attackingUnits);\n-      }\n+      CasualtySortingUtil.sortPreBattle(attackingUnits);", "originalCommit": "a694383eb8354a4f03a96fb11f016bed20ac02ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2Nzk0Mw==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493967943", "bodyText": "The casualty sorter I believe assumes units are provided in an already sorted ordering.", "author": "DanVanAtta", "createdAt": "2020-09-24T00:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MDkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MTg4MQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493951881", "bodyText": "I first looked at not checking for amphibious here and instead doing the getWasAmphibious check inside of the sorter.  But the sorter only looks at one unit of each type so if a battle had an amphibious marine and a non-amphibious marine, the results could be different depending on which unit was seen first.\nI think the sorter needs to be looked at because, right now, if you have a partial amphibious attack (some marines are amphibious and others aren't), it sorts them as if all of the marines are amphibious.", "author": "trevan", "createdAt": "2020-09-23T23:26:51Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/CasualtySelector.java", "diffHunk": "@@ -308,11 +298,9 @@ private static void killAmphibiousFirst(final List<Unit> killed, final Collectio\n                 .combatModifiers(\n                     CombatModifiers.builder()\n                         .territoryEffects(territoryEffects)\n-                        .amphibious(amphibious)\n+                        .amphibious(targetsToPickFrom.stream().anyMatch(Unit::getWasAmphibious))", "originalCommit": "a694383eb8354a4f03a96fb11f016bed20ac02ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MTIwNA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494681204", "bodyText": "That would lead to an over-evaluation of those units powers, likely an outright defect.", "author": "DanVanAtta", "createdAt": "2020-09-25T00:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MTg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4OTczOQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494689739", "bodyText": "Do you want me to try to fix this as part of this PR?  It isn't a new issue so this change isn't making it any worse.", "author": "trevan", "createdAt": "2020-09-25T01:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MTg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxODY0NA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494718644", "bodyText": "new PR, bug fixes are best done as focused PRs. Ideally a test created to demonstrate the problem and then fix is relatively surgical.\nOne should also consider the blast radius of a roll-back. If something is wrong and there is a rollback, it's a shame to have other helpful changes also be rolled bakc.", "author": "DanVanAtta", "createdAt": "2020-09-25T02:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MTg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk1MjM0OQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r493952349", "bodyText": "Before I changed this class, I wrote some unit tests to make sure I understood the logic.  And I got unexpected results.  So, I \"fixed\" the class to match the tests.  Take a look at the tests to see if maybe I have an incorrect assumption on how this is supposed to sort units.\nAlso, as I mentioned earlier, I'm not sure this sort code is even needed.", "author": "trevan", "createdAt": "2020-09-23T23:28:26Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/casualty/CasualtySortingUtil.java", "diffHunk": "@@ -10,46 +10,24 @@\n \n @UtilityClass\n public class CasualtySortingUtil {\n-  /**\n-   * In an amphibious assault, sort on who is unloading from transports first as this will allow the\n-   * marines with higher scores to get killed last.\n-   */\n-  public static void sortAmphib(final List<Unit> units, final List<Unit> amphibiousLandAttackers) {\n-    final Comparator<Unit> decreasingMovement =\n-        UnitComparator.getLowestToHighestMovementComparator();\n+  /** In an amphibious assault, sort marines with higher scores last */\n+  public static void sortPreBattle(final List<Unit> units) {\n     units.sort(\n         Comparator.comparing(Unit::getType, Comparator.comparing(UnitType::getName))\n-            .thenComparing(\n-                (u1, u2) -> {\n-                  final UnitAttachment ua = UnitAttachment.get(u1.getType());\n-                  final UnitAttachment ua2 = UnitAttachment.get(u2.getType());\n-                  if (ua.getIsMarine() != 0 && ua2.getIsMarine() != 0) {\n-                    return compareAccordingToAmphibious(u1, u2, amphibiousLandAttackers);\n-                  }\n-                  return 0;\n-                })\n-            .thenComparing(decreasingMovement));\n+            .thenComparing(compareMarines())\n+            .thenComparing(UnitComparator.getLowestToHighestMovementComparator()));\n   }\n \n-  private static int compareAccordingToAmphibious(\n-      final Unit u1, final Unit u2, final List<Unit> amphibiousLandAttackers) {\n-    if (amphibiousLandAttackers.contains(u1) && !amphibiousLandAttackers.contains(u2)) {\n-      return -1;\n-    } else if (amphibiousLandAttackers.contains(u2) && !amphibiousLandAttackers.contains(u1)) {\n-      return 1;\n-    }\n-    final int m1 = UnitAttachment.get(u1.getType()).getIsMarine();\n-    final int m2 = UnitAttachment.get(u2.getType()).getIsMarine();\n-    return m2 - m1;\n-  }\n+  public static Comparator<Unit> compareMarines() {", "originalCommit": "a694383eb8354a4f03a96fb11f016bed20ac02ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "82d77e2b92ac0fcf4885773be5850d9bb6fab72a", "url": "https://github.com/triplea-game/triplea/commit/82d77e2b92ac0fcf4885773be5850d9bb6fab72a", "message": "Supress unused warnings", "committedDate": "2020-09-24T01:33:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTM3MQ==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494719371", "bodyText": "nit, have you considered using the collection matcher? IE: IsCollectionContaining", "author": "DanVanAtta", "createdAt": "2020-09-25T02:58:18Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtySortingUtilTest.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package games.strategy.triplea.delegate.battle.casualty;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class CasualtySortingUtilTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GamePlayer player;\n+\n+  @Test\n+  void sortByUnitTypeName() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"B\");\n+    final Unit unitB = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final Unit unitA = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitB, unitA);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitA, unitB)));\n+  }\n+\n+  @Test\n+  void sortByMovement() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    when(unitAttachment1.getMovement(player)).thenReturn(2);\n+    final Unit unitWith2Movement = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Movement = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Movement, unitWith1Movement);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWith1Movement, unitWith2Movement)));\n+  }\n+\n+  @Test\n+  void sortByMarine() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    lenient().when(unitAttachment1.getMovement(player)).thenReturn(1);\n+    when(unitAttachment1.getIsMarine()).thenReturn(0);\n+    final Unit unitWithNoMarine = spy(new Unit(unitType1, player, gameData));\n+    lenient().when(unitWithNoMarine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitAttachment2.getIsMarine()).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Marine = spy(new Unit(unitType2, player, gameData));\n+    when(unitWith1Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType3 = mock(UnitType.class);\n+    when(unitType3.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment3 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment3.getMovement(player)).thenReturn(1);\n+    when(unitAttachment3.getIsMarine()).thenReturn(2);\n+    when(unitType3.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment3);\n+    final Unit unitWith2Marine = spy(new Unit(unitType3, player, gameData));\n+    when(unitWith2Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Marine, unitWith1Marine, unitWithNoMarine);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWithNoMarine, unitWith1Marine, unitWith2Marine)));", "originalCommit": "82d77e2b92ac0fcf4885773be5850d9bb6fab72a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTY2NA==", "url": "https://github.com/triplea-game/triplea/pull/7740#discussion_r494719664", "bodyText": "nit, a message on the assertion is desirably for most assertions to explain why we expect an exact condition to be true. Spelling out why we expect a test to be correct is important for maintenance", "author": "DanVanAtta", "createdAt": "2020-09-25T02:59:30Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/casualty/CasualtySortingUtilTest.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package games.strategy.triplea.delegate.battle.casualty;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class CasualtySortingUtilTest {\n+\n+  @Mock GameData gameData;\n+  @Mock GamePlayer player;\n+\n+  @Test\n+  void sortByUnitTypeName() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"B\");\n+    final Unit unitB = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final Unit unitA = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitB, unitA);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitA, unitB)));\n+  }\n+\n+  @Test\n+  void sortByMovement() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    when(unitAttachment1.getMovement(player)).thenReturn(2);\n+    final Unit unitWith2Movement = new Unit(unitType1, player, gameData);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Movement = new Unit(unitType2, player, gameData);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Movement, unitWith1Movement);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWith1Movement, unitWith2Movement)));\n+  }\n+\n+  @Test\n+  void sortByMarine() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    lenient().when(unitAttachment1.getMovement(player)).thenReturn(1);\n+    when(unitAttachment1.getIsMarine()).thenReturn(0);\n+    final Unit unitWithNoMarine = spy(new Unit(unitType1, player, gameData));\n+    lenient().when(unitWithNoMarine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitAttachment2.getIsMarine()).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Marine = spy(new Unit(unitType2, player, gameData));\n+    when(unitWith1Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType3 = mock(UnitType.class);\n+    when(unitType3.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment3 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment3.getMovement(player)).thenReturn(1);\n+    when(unitAttachment3.getIsMarine()).thenReturn(2);\n+    when(unitType3.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment3);\n+    final Unit unitWith2Marine = spy(new Unit(unitType3, player, gameData));\n+    when(unitWith2Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final List<Unit> units = Arrays.asList(unitWith2Marine, unitWith1Marine, unitWithNoMarine);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(units, is(List.of(unitWithNoMarine, unitWith1Marine, unitWith2Marine)));\n+  }\n+\n+  @Test\n+  void sortByMarineWithNonAmphibiousMarine() {\n+    final UnitType unitType1 = mock(UnitType.class);\n+    when(unitType1.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment1 = mock(UnitAttachment.class);\n+    when(unitType1.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment1);\n+    lenient().when(unitAttachment1.getMovement(player)).thenReturn(1);\n+    when(unitAttachment1.getIsMarine()).thenReturn(0);\n+    final Unit unitWithNoMarine = spy(new Unit(unitType1, player, gameData));\n+    when(unitWithNoMarine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType2 = mock(UnitType.class);\n+    when(unitType2.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment2 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment2.getMovement(player)).thenReturn(1);\n+    when(unitAttachment2.getIsMarine()).thenReturn(1);\n+    when(unitType2.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment2);\n+    final Unit unitWith1Marine = spy(new Unit(unitType2, player, gameData));\n+    when(unitWith1Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType3 = mock(UnitType.class);\n+    when(unitType3.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment3 = mock(UnitAttachment.class);\n+    lenient().when(unitAttachment3.getMovement(player)).thenReturn(1);\n+    when(unitAttachment3.getIsMarine()).thenReturn(2);\n+    when(unitType3.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment3);\n+    final Unit unitWith2Marine = spy(new Unit(unitType3, player, gameData));\n+    when(unitWith2Marine.getWasAmphibious()).thenReturn(true);\n+\n+    final UnitType unitType4 = mock(UnitType.class);\n+    when(unitType4.getName()).thenReturn(\"A\");\n+    final UnitAttachment unitAttachment4 = mock(UnitAttachment.class);\n+    // add a little more movement than unitWithNoMarine so it sorts stably.\n+    lenient().when(unitAttachment4.getMovement(player)).thenReturn(2);\n+    lenient().when(unitAttachment4.getIsMarine()).thenReturn(1);\n+    lenient().when(unitType4.getAttachment(UNIT_ATTACHMENT_NAME)).thenReturn(unitAttachment4);\n+    final Unit unitWith3MarineButNotAmphibious = spy(new Unit(unitType4, player, gameData));\n+    when(unitWith3MarineButNotAmphibious.getWasAmphibious()).thenReturn(false);\n+\n+    final List<Unit> units =\n+        Arrays.asList(\n+            unitWith2Marine, unitWith1Marine, unitWithNoMarine, unitWith3MarineButNotAmphibious);\n+\n+    CasualtySortingUtil.sortPreBattle(units);\n+\n+    assertThat(", "originalCommit": "82d77e2b92ac0fcf4885773be5850d9bb6fab72a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}