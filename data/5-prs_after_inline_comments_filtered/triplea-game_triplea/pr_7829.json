{"pr_number": 7829, "pr_title": "Create FiringGroup classes to rework how battles determine firing and targeted units", "pr_createdAt": "2020-10-03T15:00:30Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7829", "timeline": [{"oid": "765cadb1f56bc31735dff13b932aea955470e3cb", "url": "https://github.com/triplea-game/triplea/commit/765cadb1f56bc31735dff13b932aea955470e3cb", "message": "Create FiringGroup classes to rework how battles determine firing and targeted units", "committedDate": "2020-10-03T15:16:05Z", "type": "commit"}, {"oid": "765cadb1f56bc31735dff13b932aea955470e3cb", "url": "https://github.com/triplea-game/triplea/commit/765cadb1f56bc31735dff13b932aea955470e3cb", "message": "Create FiringGroup classes to rework how battles determine firing and targeted units", "committedDate": "2020-10-03T15:16:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDE1OA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499174158", "bodyText": "This seems to imply a different object semantic, perhaps even a different object. WDYT of something like SuicideOnHitFiringGroup? Would it simplify the eventual usages?", "author": "DanVanAtta", "createdAt": "2020-10-03T19:13:14Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type", "originalCommit": "765cadb1f56bc31735dff13b932aea955470e3cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NDYyMw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499184623", "bodyText": "No, it wouldn't simplify any eventual usage.  This flag is only used to determine whether to kill the units after they fire.  We have to have a separate group so that we can easily detect which units hit and so which ones can be removed.", "author": "trevan", "createdAt": "2020-10-03T21:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDI3Ng==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499174276", "bodyText": "Where is the prefix added? It's an interesting comment, though scanning down it's not immediately obvious where/what this is refererring to exactly.", "author": "DanVanAtta", "createdAt": "2020-10-03T19:14:50Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);\n+  }\n+\n+  public Collection<Unit> getFiringUnits() {\n+    return Collections.unmodifiableCollection(firingUnits);\n+  }\n+\n+  /**\n+   * Keeps alive units around\n+   *\n+   * <p>Units unfortunately don't track their own status so the list of targets needs to be updated\n+   * as the battle progresses.\n+   *\n+   * @param aliveUnits Units that are still alive\n+   */\n+  public void retainAliveTargets(final Collection<Unit> aliveUnits) {\n+    targetUnits.retainAll(aliveUnits);\n+  }\n+\n+  /**\n+   * Splits up the firingUnits by suicideOnHit status and groups them by unit type\n+   *\n+   * @param name Name of the firing units\n+   * @param firingUnits Collection of units that are firing\n+   * @param targetUnits Collection of units that are being hit\n+   * @return List of FiringGroup\n+   */\n+  public static List<FiringGroup> groupBySuicideOnHit(\n+      final String name, final Collection<Unit> firingUnits, final Collection<Unit> targetUnits) {\n+    final List<FiringGroup> groups = new ArrayList<>();\n+    final List<Collection<Unit>> separatedBySuicide = separateSuicideOnHit(firingUnits);\n+\n+    // ensure each firing group has a unique name by adding prefixes", "originalCommit": "765cadb1f56bc31735dff13b932aea955470e3cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NDI0Mw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499184243", "bodyText": "The prefixes are added inside of the callees generateFiringGroupsWithOneSuicideAndOneNonSuicide and generateFiringGroups.", "author": "trevan", "createdAt": "2020-10-03T21:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NTQ2Ng==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499185466", "bodyText": "Cool, though that seems to be a detail of those methods. At this level, it's not obvious that is happening, therefore this comment seems out of place. One rule of thumb, any method should be understandable by simply reading it and not having to also read the methods that it invokes. One can see if that rule is violated then there is a scaling problem to understand a given method if you have to read all of the called methods, and all of the methods that are in turn called to the n'th degree.", "author": "DanVanAtta", "createdAt": "2020-10-03T22:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NjIzNQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499186235", "bodyText": "It was there to explain why the if/else if/else.  The only reason for them is to generate suffices.  If I didn't care about having unique suffices, I would just do a simple\nreturn separatedBySuicide.stream()\n        .map(newFiringUnits -> new FiringGroup(name, newFiringUnits, targetUnits))\n        .collect(Collectors.toList());\n\nBut I've been thinking about your comments here and I think if I instead change the above to:\nreturn separatedBySuicide.stream()\n        .map(newFiringUnits -> new FiringGroup(generateName(name, newFiringUnits, separatedBySuicide), newFiringUnits, targetUnits))\n        .collect(Collectors.toList());\n\nThen the logic for the unique names is more obviously contained to just dealing with the string instead of generating firing groups.", "author": "trevan", "createdAt": "2020-10-03T22:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDgyNg==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499174826", "bodyText": "WDYT of having a constructor do the work for the isSuidideOnHit check?\nIn such a case this method would be reduced to:\n    return separatedBySuicide.stream()\n        .map(newFiringUnits -> new FiringGroup(name, newFiringUnits, targetUnits))\n        .collect(Collectors.toList());\n\nThat makes it short enough it perhaps is worth inlining.", "author": "DanVanAtta", "createdAt": "2020-10-03T19:22:35Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);\n+  }\n+\n+  public Collection<Unit> getFiringUnits() {\n+    return Collections.unmodifiableCollection(firingUnits);\n+  }\n+\n+  /**\n+   * Keeps alive units around\n+   *\n+   * <p>Units unfortunately don't track their own status so the list of targets needs to be updated\n+   * as the battle progresses.\n+   *\n+   * @param aliveUnits Units that are still alive\n+   */\n+  public void retainAliveTargets(final Collection<Unit> aliveUnits) {\n+    targetUnits.retainAll(aliveUnits);\n+  }\n+\n+  /**\n+   * Splits up the firingUnits by suicideOnHit status and groups them by unit type\n+   *\n+   * @param name Name of the firing units\n+   * @param firingUnits Collection of units that are firing\n+   * @param targetUnits Collection of units that are being hit\n+   * @return List of FiringGroup\n+   */\n+  public static List<FiringGroup> groupBySuicideOnHit(\n+      final String name, final Collection<Unit> firingUnits, final Collection<Unit> targetUnits) {\n+    final List<FiringGroup> groups = new ArrayList<>();\n+    final List<Collection<Unit>> separatedBySuicide = separateSuicideOnHit(firingUnits);\n+\n+    // ensure each firing group has a unique name by adding prefixes\n+    // if the firing groups have different types of suicide units\n+    if (separatedBySuicide.size() == 1) {\n+      groups.add(\n+          new FiringGroup(\n+              name,\n+              name,\n+              separatedBySuicide.get(0),\n+              targetUnits,\n+              Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(0).iterator().next())));\n+\n+    } else if (separatedBySuicide.size() == 2\n+        && Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(0).iterator().next())\n+            != Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(1).iterator().next())) {\n+      groups.addAll(\n+          generateFiringGroupsWithOneSuicideAndOneNonSuicide(\n+              name, targetUnits, separatedBySuicide));\n+\n+    } else {\n+      groups.addAll(generateFiringGroups(name, targetUnits, separatedBySuicide));\n+    }\n+    return groups;\n+  }\n+\n+  /**\n+   * Separate the suicide on hit units from the others and group them by their type. The suicide on\n+   * hit units need to fire separately so that they can be removed if they hit.\n+   */\n+  private static List<Collection<Unit>> separateSuicideOnHit(final Collection<Unit> units) {\n+\n+    final Map<UnitType, Collection<Unit>> map = new HashMap<>();\n+    for (final Unit unit : CollectionUtils.getMatches(units, Matches.unitIsSuicideOnHit())) {\n+      final UnitType type = unit.getType();\n+      if (map.containsKey(type)) {\n+        map.get(type).add(unit);\n+      } else {\n+        final Collection<Unit> unitList = new ArrayList<>();\n+        unitList.add(unit);\n+        map.put(type, unitList);\n+      }\n+    }\n+\n+    final List<Collection<Unit>> result = new ArrayList<>(map.values());\n+    final Collection<Unit> remainingUnits =\n+        CollectionUtils.getMatches(units, Matches.unitIsSuicideOnHit().negate());\n+    if (!remainingUnits.isEmpty()) {\n+      result.add(remainingUnits);\n+    }\n+    return result;\n+  }\n+\n+  /** Handle the case where there are only two groups and one is suicide and the other is not */\n+  private static List<FiringGroup> generateFiringGroupsWithOneSuicideAndOneNonSuicide(\n+      final String name,\n+      final Collection<Unit> targetUnits,\n+      final List<Collection<Unit>> separatedBySuicide) {\n+    final List<FiringGroup> groups = new ArrayList<>();", "originalCommit": "765cadb1f56bc31735dff13b932aea955470e3cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NTA4MA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499185080", "bodyText": "You'll notice that the isSuicideOnHit is used to determine the suffix.  And just because it is a suicideOnHit doesn't mean it will have the same suffix.  If you look at the next method generateFiringGroups, it also checks the suicideOnHit but it uses a different suffix.\nHere's some examples of firing unit groups and what their suffices would be:\nOne (doesn't matter if it is suicide or not) firing group -> No suffix\nOne suicide firing group and one non suicide firing group -> The suicide group has \" suicide\" suffix and the non suicide firing group has no suffix\nTwo suicide firing groups -> They will both have \" suicide <unitType.name>\" suffix.\nTwo suicide firing groups and one non suicide firing group -> The two suicide groups will have the suffix \" suicide <unitType.name>\" and the non suicide firing group will not have a suffix.", "author": "trevan", "createdAt": "2020-10-03T21:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDk1Nw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499174957", "bodyText": "This param is interesting List<Collection<Unit>>. I wonder a bit what the ordering of the list is. If not ordered, then should it be just a Collection? That makes me wonder further if this would be better as a Map<?, Collection<Unit>>\nFor map key, if an enum would perhaps do well, something like FiringGroupType { SUICIDE_ON_HIT, STANDARD }\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-10-03T19:24:38Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);\n+  }\n+\n+  public Collection<Unit> getFiringUnits() {\n+    return Collections.unmodifiableCollection(firingUnits);\n+  }\n+\n+  /**\n+   * Keeps alive units around\n+   *\n+   * <p>Units unfortunately don't track their own status so the list of targets needs to be updated\n+   * as the battle progresses.\n+   *\n+   * @param aliveUnits Units that are still alive\n+   */\n+  public void retainAliveTargets(final Collection<Unit> aliveUnits) {\n+    targetUnits.retainAll(aliveUnits);\n+  }\n+\n+  /**\n+   * Splits up the firingUnits by suicideOnHit status and groups them by unit type\n+   *\n+   * @param name Name of the firing units\n+   * @param firingUnits Collection of units that are firing\n+   * @param targetUnits Collection of units that are being hit\n+   * @return List of FiringGroup\n+   */\n+  public static List<FiringGroup> groupBySuicideOnHit(\n+      final String name, final Collection<Unit> firingUnits, final Collection<Unit> targetUnits) {\n+    final List<FiringGroup> groups = new ArrayList<>();\n+    final List<Collection<Unit>> separatedBySuicide = separateSuicideOnHit(firingUnits);\n+\n+    // ensure each firing group has a unique name by adding prefixes\n+    // if the firing groups have different types of suicide units\n+    if (separatedBySuicide.size() == 1) {\n+      groups.add(\n+          new FiringGroup(\n+              name,\n+              name,\n+              separatedBySuicide.get(0),\n+              targetUnits,\n+              Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(0).iterator().next())));\n+\n+    } else if (separatedBySuicide.size() == 2\n+        && Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(0).iterator().next())\n+            != Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(1).iterator().next())) {\n+      groups.addAll(\n+          generateFiringGroupsWithOneSuicideAndOneNonSuicide(\n+              name, targetUnits, separatedBySuicide));\n+\n+    } else {\n+      groups.addAll(generateFiringGroups(name, targetUnits, separatedBySuicide));\n+    }\n+    return groups;\n+  }\n+\n+  /**\n+   * Separate the suicide on hit units from the others and group them by their type. The suicide on\n+   * hit units need to fire separately so that they can be removed if they hit.\n+   */\n+  private static List<Collection<Unit>> separateSuicideOnHit(final Collection<Unit> units) {\n+\n+    final Map<UnitType, Collection<Unit>> map = new HashMap<>();\n+    for (final Unit unit : CollectionUtils.getMatches(units, Matches.unitIsSuicideOnHit())) {\n+      final UnitType type = unit.getType();\n+      if (map.containsKey(type)) {\n+        map.get(type).add(unit);\n+      } else {\n+        final Collection<Unit> unitList = new ArrayList<>();\n+        unitList.add(unit);\n+        map.put(type, unitList);\n+      }\n+    }\n+\n+    final List<Collection<Unit>> result = new ArrayList<>(map.values());\n+    final Collection<Unit> remainingUnits =\n+        CollectionUtils.getMatches(units, Matches.unitIsSuicideOnHit().negate());\n+    if (!remainingUnits.isEmpty()) {\n+      result.add(remainingUnits);\n+    }\n+    return result;\n+  }\n+\n+  /** Handle the case where there are only two groups and one is suicide and the other is not */\n+  private static List<FiringGroup> generateFiringGroupsWithOneSuicideAndOneNonSuicide(\n+      final String name,\n+      final Collection<Unit> targetUnits,\n+      final List<Collection<Unit>> separatedBySuicide) {", "originalCommit": "765cadb1f56bc31735dff13b932aea955470e3cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NjA4MA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499176080", "bodyText": "If there were a map of firing group by type, then FiringGroup would not need the suicideOnHit boolean.", "author": "DanVanAtta", "createdAt": "2020-10-03T19:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4NDQ5MA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499184490", "bodyText": "Collection is fine.  The order doesn't matter.\nA map won't work because there can be more than one suicideOnHit collection.  This specific method adds a simplified prefix for the special case where there is only one suicideOnHit collection and one non suicideOnHit collection (I tried to express that in the method name).  The logic to figure out which one is the suicideOnHit and which one is not the suicideOnHit is inside of this method.  If I move that logic out of this method, then this method becomes basically nothing and would be inlined.  But doing that will increase the complexity of the caller and codeclimate will complain.", "author": "trevan", "createdAt": "2020-10-03T21:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQyNzc2OA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r501427768", "bodyText": "But doing that will increase the complexity of the caller and codeclimate will complain.\n\ncodeclimate is not perfect. There are times when the actual victory is from a fundamental change rather than a surface level. In other words, sometimes right right fix to codeclimate issues are not simple, surface level fixes. If a codeclimate warning is in the way of what is actually simpler, then codeclimate should be ignored in that instance.", "author": "DanVanAtta", "createdAt": "2020-10-08T03:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQyODQ3OQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r501428479", "bodyText": "The encoding of the 'prefix' does strike me as complicated.\nWhat are the different types of suicideOnHit collection? Perhaps we are talking instead a more complicated data structure, something like: Map<UnitType, Map<SuicideOnHitFlag, Collection<Unit>>. Generally, such a data structure is a candidate to be converted to a first class object. One would init it by passing a collection of units, perhaps calling a factory method, and the methods on the object would be queries to return units of a given type.\nI think there could be some advantages to that:\n\nreadily tested\nextracts a good bit of detail\nreadily mocked, could be useful for testing other logic that relies on units with certain characteristics", "author": "DanVanAtta", "createdAt": "2020-10-08T03:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQzMDAzOA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r501430038", "bodyText": "I've made changes to how this works.  Take a look at the new code.", "author": "trevan", "createdAt": "2020-10-08T03:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NDk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NTE2Mg==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499175162", "bodyText": "Will we always be guaranteed to have a first unit in: newFiringUnits.iterator().next()?\nI do not know, maybe there is some code earlier that guarantees this, however it seems like a pretty strong precondition that is not necessarily documented (hopefully enforced). If we convert the incoming list to a map, that would resolve this problem as you would not need to check any of the unit elements to determine if they are 'suicide on hit', you could retrieve them directly from the input map.", "author": "DanVanAtta", "createdAt": "2020-10-03T19:26:50Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,143 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);\n+  }\n+\n+  public Collection<Unit> getFiringUnits() {\n+    return Collections.unmodifiableCollection(firingUnits);\n+  }\n+\n+  /**\n+   * Keeps alive units around\n+   *\n+   * <p>Units unfortunately don't track their own status so the list of targets needs to be updated\n+   * as the battle progresses.\n+   *\n+   * @param aliveUnits Units that are still alive\n+   */\n+  public void retainAliveTargets(final Collection<Unit> aliveUnits) {\n+    targetUnits.retainAll(aliveUnits);\n+  }\n+\n+  /**\n+   * Splits up the firingUnits by suicideOnHit status and groups them by unit type\n+   *\n+   * @param name Name of the firing units\n+   * @param firingUnits Collection of units that are firing\n+   * @param targetUnits Collection of units that are being hit\n+   * @return List of FiringGroup\n+   */\n+  public static List<FiringGroup> groupBySuicideOnHit(\n+      final String name, final Collection<Unit> firingUnits, final Collection<Unit> targetUnits) {\n+    final List<FiringGroup> groups = new ArrayList<>();\n+    final List<Collection<Unit>> separatedBySuicide = separateSuicideOnHit(firingUnits);\n+\n+    // ensure each firing group has a unique name by adding prefixes\n+    // if the firing groups have different types of suicide units\n+    if (separatedBySuicide.size() == 1) {\n+      groups.add(\n+          new FiringGroup(\n+              name,\n+              name,\n+              separatedBySuicide.get(0),\n+              targetUnits,\n+              Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(0).iterator().next())));\n+\n+    } else if (separatedBySuicide.size() == 2\n+        && Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(0).iterator().next())\n+            != Matches.unitIsSuicideOnHit().test(separatedBySuicide.get(1).iterator().next())) {\n+      groups.addAll(\n+          generateFiringGroupsWithOneSuicideAndOneNonSuicide(\n+              name, targetUnits, separatedBySuicide));\n+\n+    } else {\n+      groups.addAll(generateFiringGroups(name, targetUnits, separatedBySuicide));\n+    }\n+    return groups;\n+  }\n+\n+  /**\n+   * Separate the suicide on hit units from the others and group them by their type. The suicide on\n+   * hit units need to fire separately so that they can be removed if they hit.\n+   */\n+  private static List<Collection<Unit>> separateSuicideOnHit(final Collection<Unit> units) {\n+\n+    final Map<UnitType, Collection<Unit>> map = new HashMap<>();\n+    for (final Unit unit : CollectionUtils.getMatches(units, Matches.unitIsSuicideOnHit())) {\n+      final UnitType type = unit.getType();\n+      if (map.containsKey(type)) {\n+        map.get(type).add(unit);\n+      } else {\n+        final Collection<Unit> unitList = new ArrayList<>();\n+        unitList.add(unit);\n+        map.put(type, unitList);\n+      }\n+    }\n+\n+    final List<Collection<Unit>> result = new ArrayList<>(map.values());\n+    final Collection<Unit> remainingUnits =\n+        CollectionUtils.getMatches(units, Matches.unitIsSuicideOnHit().negate());\n+    if (!remainingUnits.isEmpty()) {\n+      result.add(remainingUnits);\n+    }\n+    return result;\n+  }\n+\n+  /** Handle the case where there are only two groups and one is suicide and the other is not */\n+  private static List<FiringGroup> generateFiringGroupsWithOneSuicideAndOneNonSuicide(\n+      final String name,\n+      final Collection<Unit> targetUnits,\n+      final List<Collection<Unit>> separatedBySuicide) {\n+    final List<FiringGroup> groups = new ArrayList<>();\n+    for (final Collection<Unit> newFiringUnits : separatedBySuicide) {\n+      final boolean isSuicideOnHit =\n+          Matches.unitIsSuicideOnHit().test(newFiringUnits.iterator().next());", "originalCommit": "765cadb1f56bc31735dff13b932aea955470e3cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NTQ3Mw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499175473", "bodyText": "Couple questions:\n\nCould you explain why an interface \"alias\" is helpful?\nIs the output list ordered?\n\nA filter will typically exclude or include items. My presumption is that this is more of a sieve, that we are not losing any elements but instead are grouping them. Is that correct? If so, perhaps this would be better named as a Splitter, or as a Sorter.  OTOH - If we do not need an interface alias, then the naming problem would drop away.", "author": "DanVanAtta", "createdAt": "2020-10-03T19:30:37Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroupFilter.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/** Converts the BattleState into a list of FiringGroups */\n+public interface FiringGroupFilter extends Function<BattleState, List<FiringGroup>> {}", "originalCommit": "765cadb1f56bc31735dff13b932aea955470e3cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NTkwMw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499175903", "bodyText": "For consideration, Effective Java 3, page 200:", "author": "DanVanAtta", "createdAt": "2020-10-03T19:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE3NTQ3Mw=="}], "type": "inlineReview"}, {"oid": "49eed1269ca5993cb8ac2e343c5b4cf83db3b11d", "url": "https://github.com/triplea-game/triplea/commit/49eed1269ca5993cb8ac2e343c5b4cf83db3b11d", "message": "Rework FiringGroup and rename Filter -> Splitter per review feedback", "committedDate": "2020-10-03T23:01:49Z", "type": "commit"}, {"oid": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "url": "https://github.com/triplea-game/triplea/commit/e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "message": "Reduce cognitive complexity in FiringGroup#generateName", "committedDate": "2020-10-04T00:54:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5NDg1MQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499194851", "bodyText": "The original logic that this is based off can be found at MustFightBattle#fireNavalBombardment (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1462\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           public void fireNavalBombardment(final IDelegateBridge bridge) { \n        \n    \n  \n\n) and MustFightBattle#fire (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1497\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           protected void fire( \n        \n    \n  \n\n).", "author": "trevan", "createdAt": "2020-10-04T01:01:08Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroupSplitterBombard.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.NAVAL_BOMBARD;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Function;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Create naval bombardment firing groups\n+ *\n+ * <p>The firing groups are separated by isSuicideOnHit\n+ */\n+@Value(staticConstructor = \"of\")\n+public class FiringGroupSplitterBombard implements Function<BattleState, List<FiringGroup>> {\n+\n+  @Override\n+  public List<FiringGroup> apply(final BattleState battleState) {", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5NDk2Mg==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499194962", "bodyText": "The original logic that this is based off of is in MustFightBattle#updateOffensiveAaUnits (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 928\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           private void updateOffensiveAaUnits() { \n        \n    \n  \n\n), MustFightBattle#updateDefensiveAaUnits (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 949\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           private void updateDefendingAaUnits() { \n        \n    \n  \n\n), FireAa#FireAa (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/FireAa.java\n    \n    \n         Line 66\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           FireAa( \n        \n    \n  \n\n), and FireAa#execute (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/FireAa.java\n    \n    \n         Line 100\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           public void execute(final ExecutionStack stack, final IDelegateBridge bridge) { \n        \n    \n  \n\n).", "author": "trevan", "createdAt": "2020-10-04T01:03:17Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/FiringGroupSplitterAa.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ACTIVE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.fire.FiringGroup;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Creates AA and Targeted Hit firing groups\n+ *\n+ * <p>The firing groups are separated by typeAa and isSuicideOnHit\n+ */\n+@Value(staticConstructor = \"of\")\n+public class FiringGroupSplitterAa implements Function<BattleState, List<FiringGroup>> {\n+\n+  BattleState.Side side;\n+\n+  @Override\n+  public List<FiringGroup> apply(final BattleState battleState) {", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5NTAxMQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499195011", "bodyText": "The original logic that this is based off of is in MustFightBattle#findTargetGroupsAndFire (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1638\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           public void findTargetGroupsAndFire( \n        \n    \n  \n\n) and MustFightBattle#fire (\n  \n    \n      triplea/game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java\n    \n    \n         Line 1497\n      in\n      e160d34\n    \n    \n    \n    \n\n        \n          \n           protected void fire( \n        \n    \n  \n\n)", "author": "trevan", "createdAt": "2020-10-04T01:04:38Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/general/FiringGroupSplitterGeneral.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.general;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ACTIVE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_FIRE_NON_SUBS;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.fire.FiringGroup;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.PredicateBuilder;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Create firing groups with units that match {@link #firingUnitPredicate}\n+ *\n+ * <p>The firing groups are separated by canNotTarget, canNotBeTargetedBy, and isSuicideOnHit\n+ */\n+@Value(staticConstructor = \"of\")\n+public class FiringGroupSplitterGeneral implements Function<BattleState, List<FiringGroup>> {\n+\n+  BattleState.Side side;\n+\n+  Predicate<Unit> firingUnitPredicate;\n+\n+  /** Name displayed in the Battle UI */\n+  String groupName;\n+\n+  @Override\n+  public List<FiringGroup> apply(final BattleState battleState) {", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE5NTI0NQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r499195245", "bodyText": "This special named group will replace the \"Air defend non subs\" or \"Air attack non subs\" battle steps.  I mentioned this and posted images of what it will look like in the original PR #7823", "author": "trevan", "createdAt": "2020-10-04T01:09:09Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/general/FiringGroupSplitterGeneral.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.general;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ACTIVE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_FIRE_NON_SUBS;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.fire.FiringGroup;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.PredicateBuilder;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Create firing groups with units that match {@link #firingUnitPredicate}\n+ *\n+ * <p>The firing groups are separated by canNotTarget, canNotBeTargetedBy, and isSuicideOnHit\n+ */\n+@Value(staticConstructor = \"of\")\n+public class FiringGroupSplitterGeneral implements Function<BattleState, List<FiringGroup>> {\n+\n+  BattleState.Side side;\n+\n+  Predicate<Unit> firingUnitPredicate;\n+\n+  /** Name displayed in the Battle UI */\n+  String groupName;\n+\n+  @Override\n+  public List<FiringGroup> apply(final BattleState battleState) {\n+    final Collection<Unit> canFire =\n+        CollectionUtils.getMatches(\n+            battleState.filterUnits(ACTIVE, side),\n+            PredicateBuilder.of(firingUnitPredicate)\n+                // Remove offense allied units if allied air can not participate\n+                .andIf(\n+                    side == OFFENSE\n+                        && !Properties.getAlliedAirIndependent(battleState.getGameData()),\n+                    Matches.unitIsOwnedBy(battleState.getPlayer(side)))\n+                .build());\n+\n+    final Collection<Unit> enemyUnits =\n+        CollectionUtils.getMatches(\n+            battleState.filterUnits(ALIVE, side.getOpposite()),\n+            PredicateBuilder.of(Matches.unitIsNotInfrastructure())\n+                .andIf(side == DEFENSE, Matches.unitIsSuicideOnAttack().negate())\n+                .andIf(side == OFFENSE, Matches.unitIsSuicideOnDefense().negate())\n+                .build());\n+\n+    final List<FiringGroup> firingGroups = new ArrayList<>();\n+\n+    final List<TargetGroup> targetGroups = TargetGroup.newTargetGroups(canFire, enemyUnits);\n+\n+    if (targetGroups.size() == 1) {\n+      firingGroups.addAll(buildFiringGroups(groupName, canFire, enemyUnits, targetGroups.get(0)));\n+    } else {\n+      // General firing groups don't have individual names so find commonly used groups and\n+      // give them unique names\n+      final List<TargetGroup> airVsSubGroups =\n+          targetGroups.stream()\n+              .filter(this.filterAirVsSubTargetGroups(enemyUnits))\n+              .collect(Collectors.toList());\n+      generateNamedGroups(AIR_FIRE_NON_SUBS, firingGroups, airVsSubGroups, canFire, enemyUnits);", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NDUyMQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502174521", "bodyText": "This appears only used in test, can it be moved to a test utility or otherwise removed from the prod code?", "author": "DanVanAtta", "createdAt": "2020-10-09T03:53:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleStepStrings.java", "diffHunk": "@@ -9,11 +9,15 @@\n   String CASUALTIES_SUFFIX = \" casualties\";\n   String LAND_PARATROOPS = \"Land Paratroopers\";\n   String NAVAL_BOMBARDMENT = \"Naval bombardment\";\n+  String NAVAL_BOMBARD = \"naval bombardment\";\n   String SELECT_NAVAL_BOMBARDMENT_CASUALTIES = \"Select naval bombardment casualties\";\n   String REMOVE_UNESCORTED_TRANSPORTS = \"Remove unescorted transports\";\n   String SUBMERGE_SUBS_VS_AIR_ONLY = \"Submerge subs against only air units\";\n   String AIR_ATTACK_NON_SUBS = \"Air attack non subs\";\n   String AIR_DEFEND_NON_SUBS = \"Air defend non subs\";\n+  String AIR_FIRE_NON_SUBS = \"air vs non subs\";\n+  String UNITS = \"units\";", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NTkwMA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502185900", "bodyText": "UNITS and AIR_FIRE_NON_SUBS will be used in prod code.", "author": "trevan", "createdAt": "2020-10-09T04:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NDUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NTUzNw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502175537", "bodyText": "Is the casing supposed to be inconsistent or just never displayed to users and so it does not matter? I notice that most of the step strings are capitalized.", "author": "DanVanAtta", "createdAt": "2020-10-09T03:55:15Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleStepStrings.java", "diffHunk": "@@ -9,11 +9,15 @@\n   String CASUALTIES_SUFFIX = \" casualties\";\n   String LAND_PARATROOPS = \"Land Paratroopers\";\n   String NAVAL_BOMBARDMENT = \"Naval bombardment\";\n+  String NAVAL_BOMBARD = \"naval bombardment\";", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NTgyMQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502185821", "bodyText": "This new string is going to show up in the Battle Display UI as \"Germans naval bombard fire\", \"British select naval bombard casualties\", and \"British remove naval bombard casualties\".  The old string is used in a different place and needs to be capitalized since it is the beginning of the sentence.", "author": "trevan", "createdAt": "2020-10-09T04:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NTUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNjcwMg==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502816702", "bodyText": "Hmm, okay. Though that seems to be overly context dependent. I wonder if it would be better to do these with built-in patterns and use them with string format. Alternatively maybe as method invocations even rather than contexts. The problem I see is that the usage is very specific, while this class is independent, it turns out to have a level of coupling to where it is used.", "author": "DanVanAtta", "createdAt": "2020-10-10T18:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NTUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODQ3NQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502838475", "bodyText": "All of these strings are only used for the Battle UI in the step list on the left hand side.  I think a probably better thing would be to use some sort of localization library and have these strings put in the language files.  I don't know if that is in any future plans.", "author": "trevan", "createdAt": "2020-10-10T22:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NjQ0Mg==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502176442", "bodyText": "suicideOnHit appears to only used in test, is there a plan for it to be used in upcoming PRs?", "author": "DanVanAtta", "createdAt": "2020-10-09T03:58:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+\n+  private static final UnitType NON_SUICIDE_MULTIMAP_KEY = new UnitType(\"nonsuicide\", null);\n+\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NTk5OQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502185999", "bodyText": "suicideOnHit will be used later.", "author": "trevan", "createdAt": "2020-10-09T04:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3Njg2NA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502176864", "bodyText": "It's not obvious  offhand why every unit should be 'unitIsSuicideOnHit' for the whole group to be marked as such. I'm just wondering why it's not any unit, or why it's not tracked at a per-unit level even. Perhaps a comment on the variable could explain it's role in the class.", "author": "DanVanAtta", "createdAt": "2020-10-09T04:00:10Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+\n+  private static final UnitType NON_SUICIDE_MULTIMAP_KEY = new UnitType(\"nonsuicide\", null);\n+\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  private FiringGroup(\n+      final String displayName,\n+      final String groupName,\n+      final Collection<Unit> firingUnits,\n+      final Collection<Unit> targetUnits) {\n+    this.displayName = displayName;\n+    this.groupName = groupName;\n+    this.firingUnits = firingUnits;\n+    this.targetUnits = targetUnits;\n+    this.suicideOnHit = this.firingUnits.stream().allMatch(Matches.unitIsSuicideOnHit());", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODI3MQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502838271", "bodyText": "I've added comments about the suicideOnHit.  See if that works.", "author": "trevan", "createdAt": "2020-10-10T22:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3Njg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NzMzMg==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502177332", "bodyText": "I wonder if callers could just avoid mutating the return value and/or copy as needed. If we can skip the defensive copy, we can have a performance improvement and simpler code in this class as a simpler getter would do.", "author": "DanVanAtta", "createdAt": "2020-10-09T04:02:26Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+\n+  private static final UnitType NON_SUICIDE_MULTIMAP_KEY = new UnitType(\"nonsuicide\", null);\n+\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  private FiringGroup(\n+      final String displayName,\n+      final String groupName,\n+      final Collection<Unit> firingUnits,\n+      final Collection<Unit> targetUnits) {\n+    this.displayName = displayName;\n+    this.groupName = groupName;\n+    this.firingUnits = firingUnits;\n+    this.targetUnits = targetUnits;\n+    this.suicideOnHit = this.firingUnits.stream().allMatch(Matches.unitIsSuicideOnHit());\n+  }\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE5MTkxMw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502191913", "bodyText": "Something to hope for :)", "author": "trevan", "createdAt": "2020-10-09T05:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NzMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNjg0NQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502816845", "bodyText": "The copies can add up to be significant. Can we do better than hoping? The java8 streaming API is particularly helpful for operating on returned collections as the collection is not mutated.", "author": "DanVanAtta", "createdAt": "2020-10-10T18:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NzMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxODg4OA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502818888", "bodyText": "The return value of this method is passed off to other methods and those pass off to other methods.  So the code path isn't easy to follow.\nBut I can't remember why exactly I added unmodifiableCollection.  I thought it was because that is how the original code was but I can't find any evidence of that now.  So, I've removed the unmodifiableCollection part.", "author": "trevan", "createdAt": "2020-10-10T18:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NzMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NzQ3Ng==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502177476", "bodyText": "The concept of being kept around is not very well defined. Would you mind making this comment more specific, more defined?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:03:12Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+\n+  private static final UnitType NON_SUICIDE_MULTIMAP_KEY = new UnitType(\"nonsuicide\", null);\n+\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  private FiringGroup(\n+      final String displayName,\n+      final String groupName,\n+      final Collection<Unit> firingUnits,\n+      final Collection<Unit> targetUnits) {\n+    this.displayName = displayName;\n+    this.groupName = groupName;\n+    this.firingUnits = firingUnits;\n+    this.targetUnits = targetUnits;\n+    this.suicideOnHit = this.firingUnits.stream().allMatch(Matches.unitIsSuicideOnHit());\n+  }\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);\n+  }\n+\n+  public Collection<Unit> getFiringUnits() {\n+    return Collections.unmodifiableCollection(firingUnits);\n+  }\n+\n+  /**\n+   * Keeps alive units around", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3ODE4Mw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502178183", "bodyText": "I think this comment is more of an implementation note. Ideally this class is designed so that it is generic and has a role, a function, and is not aware of limitations around it. IF this class is responsible for tracking units that are still alive, perhaps that can just be cleanly documented in the class javadoc? AS-is, it's a bit odd to see this note, I'm not sure if it really answers questions, seems like if you have context then it makes more sense but otherwise is a bit confusing.", "author": "DanVanAtta", "createdAt": "2020-10-09T04:06:28Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+\n+  private static final UnitType NON_SUICIDE_MULTIMAP_KEY = new UnitType(\"nonsuicide\", null);\n+\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  private FiringGroup(\n+      final String displayName,\n+      final String groupName,\n+      final Collection<Unit> firingUnits,\n+      final Collection<Unit> targetUnits) {\n+    this.displayName = displayName;\n+    this.groupName = groupName;\n+    this.firingUnits = firingUnits;\n+    this.targetUnits = targetUnits;\n+    this.suicideOnHit = this.firingUnits.stream().allMatch(Matches.unitIsSuicideOnHit());\n+  }\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);\n+  }\n+\n+  public Collection<Unit> getFiringUnits() {\n+    return Collections.unmodifiableCollection(firingUnits);\n+  }\n+\n+  /**\n+   * Keeps alive units around\n+   *\n+   * <p>Units unfortunately don't track their own status so the list of targets needs to be updated", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NjcwNQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502186705", "bodyText": "It is an implementation note.  I'd rather not have this method here.  But because of how status is tracked, the method is required.  Maybe at some point we'll track status in the units and then this method will not be needed.", "author": "trevan", "createdAt": "2020-10-09T04:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3ODE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3OTIwMQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502179201", "bodyText": "nit, not sure this @return javadoc adds much, restates the code. We are not publishing library code, anyone reading the javadoc will likely be reading the javadoc in the class file at the same time. I think this @return can perhaps be removed or otherwise should describe any invariants that would be true of the return value. For example, it is a list, what is the ordering of the list? Are there constraints on the size of the list. Also, will the firigin group be a collection of the firing units, or the target units, or both?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:10:58Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+\n+  private static final UnitType NON_SUICIDE_MULTIMAP_KEY = new UnitType(\"nonsuicide\", null);\n+\n+  String displayName;\n+  String groupName;\n+  Collection<Unit> firingUnits;\n+  Collection<Unit> targetUnits;\n+  boolean suicideOnHit;\n+\n+  private FiringGroup(\n+      final String displayName,\n+      final String groupName,\n+      final Collection<Unit> firingUnits,\n+      final Collection<Unit> targetUnits) {\n+    this.displayName = displayName;\n+    this.groupName = groupName;\n+    this.firingUnits = firingUnits;\n+    this.targetUnits = targetUnits;\n+    this.suicideOnHit = this.firingUnits.stream().allMatch(Matches.unitIsSuicideOnHit());\n+  }\n+\n+  public Collection<Unit> getTargetUnits() {\n+    return Collections.unmodifiableCollection(targetUnits);\n+  }\n+\n+  public Collection<Unit> getFiringUnits() {\n+    return Collections.unmodifiableCollection(firingUnits);\n+  }\n+\n+  /**\n+   * Keeps alive units around\n+   *\n+   * <p>Units unfortunately don't track their own status so the list of targets needs to be updated\n+   * as the battle progresses.\n+   *\n+   * @param aliveUnits Units that are still alive\n+   */\n+  public void retainAliveTargets(final Collection<Unit> aliveUnits) {\n+    targetUnits.retainAll(aliveUnits);\n+  }\n+\n+  /**\n+   * Splits up the firingUnits by suicideOnHit status and groups them by unit type\n+   *\n+   * @param name Name of the firing units\n+   * @param firingUnits Collection of units that are firing\n+   * @param targetUnits Collection of units that are being hit\n+   * @return List of FiringGroup", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3OTM4Nw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502179387", "bodyText": "I am a bit confused though, suicideOnHit already implies a specific unit type, right? If we are grouping by unit type, then don't we automatically also group by suicideOnHit too?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3OTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NzA0NA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502187044", "bodyText": "The doc \"groups them by unit type\" is talking about grouping the suicideOnHit by unit type.  The other units are not grouped by unit type.  I'll try and reword the doc.", "author": "trevan", "createdAt": "2020-10-09T04:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3OTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MTExNA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502181114", "bodyText": "Creating a fake unit type seems to contradict the unit type datatype (SRP violation). The method that uses this I think probably would do better to return a first class data structure, something like:\n\nclass SuicideOnHitSortedFiringGroups {\n     Map<UnitType, FiringGroup> suicideOnHitFiringGroups;\n     Collection<Unit> nonSuicideOnHitFiringGroups;;\n}\n\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:19:59Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroup.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.Multimap;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Group of units that are firing on targets\n+ *\n+ * <p>If the group is suicideOnHit, then all of the units should have the same unit type\n+ */\n+@Value\n+public class FiringGroup {\n+\n+  private static final UnitType NON_SUICIDE_MULTIMAP_KEY = new UnitType(\"nonsuicide\", null);", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MTYwMw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502181603", "bodyText": "nit, would 'bombarindUnits' be a more descriptive name here? Perhaps even consider inlining it to avoid the intermediate variable?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:22:04Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/FiringGroupSplitterBombard.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package games.strategy.triplea.delegate.battle.steps.fire;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.NAVAL_BOMBARD;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Function;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Create naval bombardment firing groups\n+ *\n+ * <p>The firing groups are separated by isSuicideOnHit\n+ */\n+@Value(staticConstructor = \"of\")\n+public class FiringGroupSplitterBombard implements Function<BattleState, List<FiringGroup>> {\n+\n+  @Override\n+  public List<FiringGroup> apply(final BattleState battleState) {\n+    final Collection<Unit> canFire = battleState.getBombardingUnits();", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MTk2NQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502181965", "bodyText": "For the splitter class, it would be nice to see some more detail in the javadoc to explain what characteristics would be true of the output List<FiringGroup>. I'm not really sure what \"Targeted Hit firing groups\" are.\nPerhaps we can/should add 'targeted hit' to the glossary?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:23:57Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/FiringGroupSplitterAa.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ACTIVE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.fire.FiringGroup;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Creates AA and Targeted Hit firing groups", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NzI4MA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502187280", "bodyText": "I thought the term for the AA hits is also called \"targeted hits\", especially when the unit firing isn't anything like an aa gun.  Is there a different term that I should be using?", "author": "trevan", "createdAt": "2020-10-09T04:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MTk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNzQ4OQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502817489", "bodyText": "The terms are broadly not well defined. TripleA was created before the concept of Domain-Driven-Design was more mainstream, as such instead of defining and using domain terminology, brand new terminology was invented (EG: \"Node\").", "author": "DanVanAtta", "createdAt": "2020-10-10T18:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MjMwMQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502182301", "bodyText": "The logic in here is really heavy. Do you have enough context where you could readily add some comments to guide a reader in understanding what this code is doing?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:25:27Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/aa/FiringGroupSplitterAa.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.aa;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ACTIVE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.TechAbilityAttachment;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.fire.FiringGroup;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import lombok.Value;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Creates AA and Targeted Hit firing groups\n+ *\n+ * <p>The firing groups are separated by typeAa and isSuicideOnHit\n+ */\n+@Value(staticConstructor = \"of\")\n+public class FiringGroupSplitterAa implements Function<BattleState, List<FiringGroup>> {\n+\n+  BattleState.Side side;\n+\n+  @Override\n+  public List<FiringGroup> apply(final BattleState battleState) {\n+    final Map<String, Set<UnitType>> airborneTechTargetsAllowed =\n+        side == DEFENSE\n+            ? TechAbilityAttachment.getAirborneTargettedByAa(\n+                battleState.getPlayer(side.getOpposite()), battleState.getGameData())\n+            : Map.of();\n+\n+    final Collection<Unit> aaUnits =\n+        CollectionUtils.getMatches(\n+            battleState.filterUnits(ACTIVE, side),\n+            Matches.unitIsAaThatCanFire(\n+                battleState.filterUnits(ALIVE, side.getOpposite()),\n+                airborneTechTargetsAllowed,\n+                battleState.getPlayer(side.getOpposite()),\n+                Matches.unitIsAaForCombatOnly(),\n+                battleState.getStatus().getRound(),\n+                side == DEFENSE,\n+                battleState.getGameData()));\n+\n+    final List<String> aaTypes = UnitAttachment.getAllOfTypeAas(aaUnits);\n+\n+    final Collection<Unit> validTargetUnits =\n+        CollectionUtils.getMatches(\n+            battleState.filterUnits(ALIVE, side.getOpposite()),\n+            Matches.unitIsNotInfrastructure().and(Matches.unitIsBeingTransported().negate()));\n+\n+    final List<FiringGroup> firingGroups = new ArrayList<>();", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NzcyNA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502187724", "bodyText": "I can try and add comments but I'm not sure if they'll be any better than the code.  You need to know all the aa attributes and how they interact with each other.", "author": "trevan", "createdAt": "2020-10-09T04:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxNzU0NQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502817545", "bodyText": "Perhaps add a comment about the high level operations that are happening, what the code is roughly going to do.", "author": "DanVanAtta", "createdAt": "2020-10-10T18:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODE5MA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502838190", "bodyText": "Check out the comments that I added to the code.", "author": "trevan", "createdAt": "2020-10-10T22:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MjMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzE2Mw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502183163", "bodyText": "It's a bit odd to have a generic predicate and for this class to know how the firing groups are going to be split.\nIs the predicate acting as a filter to remove units from the firing groups, or is the predicate more acting at the firing group level?\nThe firing predicate is a bit concerning as I wonder if we are too abstract here, too complex. Could the caller apply the predicate rather than passing it in? I'm wondering if a caller would have to know a great deal about this implementation to be able to reasonably pass a good predicate to this class.", "author": "DanVanAtta", "createdAt": "2020-10-09T04:29:40Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/general/FiringGroupSplitterGeneral.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.general;\n+\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ACTIVE;\n+import static games.strategy.triplea.delegate.battle.BattleState.UnitBattleFilter.ALIVE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_FIRE_NON_SUBS;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.fire.FiringGroup;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import lombok.Value;\n+import org.triplea.java.PredicateBuilder;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/**\n+ * Create firing groups with units that match {@link #firingUnitPredicate}\n+ *\n+ * <p>The firing groups are separated by canNotTarget, canNotBeTargetedBy, and isSuicideOnHit", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4OTYzOQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502189639", "bodyText": "The predicate isn't the splitter.  It filters what units are available to be split.  By storing the predicate with the splitter, I can make the caller more generic.\nThe currently only use for the predicate is to separate FirstStrike from non-FirstStrike.  I could make three separate splitters: Normal, OffensiveFirstStrike, and DefensiveFirstStrike.  But the only difference between the three is the predicate or pre-filter.\nThe thing that does the splitting are the canNotTarget, canNotBeTargetedBy, and isSuicideOnHit attributes of the UnitType.", "author": "trevan", "createdAt": "2020-10-09T04:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzMDI4Ng==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502830286", "bodyText": "Here is one thought, the list of split predicates is pretty well defined. What if we passed an enum value to specify the split type? This would I think be pretty beneficial as it would push complexity into this module, simplifying the callers. The cohesion of this class would be stronger, to understand what it's doing you would not have to look at the predicates being passed in, which is fundamentally a better and more useful module. Furthermore, by passing the right enum value, you get the right behavior, this really abstracts away implementation details from the callers. Otherwise, with a predicate a caller (or a maintainer, or someone looking to use or understand this code) has to have pretty deep knowledge of how the predicate is used.", "author": "DanVanAtta", "createdAt": "2020-10-10T20:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODU4NQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502838585", "bodyText": "Do you mean the \"filter type\"?  Because the predicate is for filtering the units, it isn't for splitting the units.  But having an enum for the three different filters sounds like an ok idea.", "author": "trevan", "createdAt": "2020-10-10T22:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzOTc2OQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502839769", "bodyText": "I've changed the predicate to enums that determine the predicate.", "author": "trevan", "createdAt": "2020-10-10T22:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzgzOA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502183838", "bodyText": "It seems we are testing multiple behaviors at the same time here. Is the expected display name of units simply because that is the splitter parameter? Have you considered adding a set of tests to only test display name behavior?", "author": "DanVanAtta", "createdAt": "2020-10-09T04:32:49Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/general/FiringGroupSplitterGeneralTest.java", "diffHunk": "@@ -0,0 +1,357 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.general;\n+\n+import static games.strategy.triplea.Constants.UNIT_ATTACHMENT_NAME;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.DEFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleState.Side.OFFENSE;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_FIRE_NON_SUBS;\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.UNITS;\n+import static games.strategy.triplea.delegate.battle.FakeBattleState.givenBattleStateBuilder;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenAnyUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsSea;\n+import static games.strategy.triplea.delegate.battle.steps.MockGameData.givenGameData;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.attachments.UnitAttachment;\n+import games.strategy.triplea.delegate.battle.steps.fire.FiringGroup;\n+import java.util.List;\n+import java.util.Set;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class FiringGroupSplitterGeneralTest {\n+\n+  @Mock GamePlayer attacker;\n+  @Mock GamePlayer defender;\n+\n+  @Test\n+  void oneFiringUnitVsOneTargetableUnitMakesOneFiringGroup() {\n+    final Unit targetUnit = givenAnyUnit();\n+    final Unit fireUnit = givenAnyUnit();\n+\n+    final List<FiringGroup> firingGroups =\n+        FiringGroupSplitterGeneral.of(OFFENSE, unit -> true, UNITS)\n+            .apply(\n+                givenBattleStateBuilder()\n+                    .gameData(givenGameData().withAlliedAirIndependent(true).build())\n+                    .attacker(attacker)\n+                    .defender(defender)\n+                    .attackingUnits(List.of(fireUnit))\n+                    .defendingUnits(List.of(targetUnit))\n+                    .build());\n+\n+    assertThat(firingGroups, hasSize(1));\n+    assertThat(firingGroups.get(0).getDisplayName(), is(UNITS));", "originalCommit": "e160d341f6c60ecf5297aad9ab26ac5a524dc2dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE5MDQ1Mw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502190453", "bodyText": "No, the expected display name will change.  The last two tests in this file test for changed display names: twoFiringGroupsWithCanNotTarget and twoGroupsWhenAirAndSeaVsSub.", "author": "trevan", "createdAt": "2020-10-09T05:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxODc1Ng==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502818756", "bodyText": "I see, what I'm more pointing to is that we are testing multiple/all aspects of firingGroups per test rather than testing on behavior at a time. For example, it's considered a best practice for tests to have only one reason for why they would fail. If for example the firing group size were to change or if the displayName were to change, then this test would fail. At a more concrete level, isolating the behaviors makes it easier to see which parameters control which outputs.\nHence I'm suggesting to pivot the tests to group and isolate the tests that verify display name, size, etc.. and do so independently.", "author": "DanVanAtta", "createdAt": "2020-10-10T18:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgxOTMwMw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502819303", "bodyText": "You'll notice that the majority of the tests don't check for the display name.  Only this one and the other two I mentioned.  I understand that the test should generally only have one reason why they should fail.  And I believe this test is structured that way.", "author": "trevan", "createdAt": "2020-10-10T18:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgyMjU4NQ==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502822585", "bodyText": "Can you clarify \"test should generally only have one reason why they should fail. And I believe this test is structured that way.\"\nFrom an initial look, it seems like if the firing group size changes this test would fail, or if the display name changes it would fail. The size of the firing group and display name are independent of one another, which makes me think that if one of two independent things were to either change, then this test method would fail for either reason. Are the two values, the firing group size and the display name actually linked?", "author": "DanVanAtta", "createdAt": "2020-10-10T19:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzgzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgzODE0OA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502838148", "bodyText": "This test is validating what a one firing group result should look like.  And a single firing group result will always have the same name.  This is a display name and the only reason to change the display name that is passed in is if there are multiple groups that need to be differentiated.", "author": "trevan", "createdAt": "2020-10-10T22:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4MzgzOA=="}], "type": "inlineReview"}, {"oid": "de3b1c5093d490a789cb605b50483fc9de902e70", "url": "https://github.com/triplea-game/triplea/commit/de3b1c5093d490a789cb605b50483fc9de902e70", "message": "Improve the documentation", "committedDate": "2020-10-09T05:47:52Z", "type": "commit"}, {"oid": "edd6a33af445e7170cc01a37bf932249d5b040dc", "url": "https://github.com/triplea-game/triplea/commit/edd6a33af445e7170cc01a37bf932249d5b040dc", "message": "Remove intermediate variable", "committedDate": "2020-10-09T05:49:50Z", "type": "commit"}, {"oid": "0bfd533c16b0cdf6d917bf3d93a7d8d936609157", "url": "https://github.com/triplea-game/triplea/commit/0bfd533c16b0cdf6d917bf3d93a7d8d936609157", "message": "Remove creating an unmodifiableCollection", "committedDate": "2020-10-10T18:33:25Z", "type": "commit"}, {"oid": "270442c7c9889c336f90c0bd7a1a209148555ec3", "url": "https://github.com/triplea-game/triplea/commit/270442c7c9889c336f90c0bd7a1a209148555ec3", "message": "Move members to top of class", "committedDate": "2020-10-10T18:40:51Z", "type": "commit"}, {"oid": "8f388871ab07f443bb05168d8c4b9557c3b603f5", "url": "https://github.com/triplea-game/triplea/commit/8f388871ab07f443bb05168d8c4b9557c3b603f5", "message": "Move the predicate into the SplitterGeneral based on a type", "committedDate": "2020-10-10T22:37:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1MDgxNw==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502950817", "bodyText": "The empty string arg seems very similar to a 'null' arg or a boolean parameter. IN general those kinds of a args are not self-explanatory and make it difficult for someone to read and use an API. Notably, you can't just use the API, you have to look up which values are allowed to then realize empty string is the way to go. One would wonder, \"can I use null here\"? In any case, it makes you look up the implementation which is a heuristic for a difficult to use API. Similar for those reading, they'll be unsure why an empty string is needed.\nGenerally the fix is to have method overloads and have an API that omits the unnecessary parameter.", "author": "DanVanAtta", "createdAt": "2020-10-11T18:39:51Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/general/FiringGroupSplitterGeneralTest.java", "diffHunk": "@@ -86,13 +88,60 @@ void oneWaitingToDieFiringUnitVsOneTargetableUnitMakesOneFiringGroup() {\n   }\n \n   @Test\n-  void firingUnitsAreExcludedAccordingToThePredicate() {\n+  void offensiveNormalTypeExcludesFirstStrike() {\n     final Unit targetUnit = givenAnyUnit();\n     final Unit fireUnit = givenAnyUnit();\n+    final Unit fireUnit2 = givenUnitFirstStrike();\n+\n+    final List<FiringGroup> firingGroups =\n+        FiringGroupSplitterGeneral.of(OFFENSE, FiringGroupSplitterGeneral.Type.OFFENSIVE_NORMAL, \"\")\n+            .apply(\n+                givenBattleStateBuilder()\n+                    .gameData(givenGameData().withAlliedAirIndependent(true).build())\n+                    .attacker(attacker)\n+                    .defender(defender)\n+                    .attackingUnits(List.of(fireUnit, fireUnit2))\n+                    .defendingUnits(List.of(targetUnit))\n+                    .build());\n+\n+    assertThat(firingGroups, hasSize(1));\n+    assertThat(firingGroups.get(0).getFiringUnits(), contains(fireUnit));\n+  }\n+\n+  @Test\n+  void defensiveNormalTypeExcludesFirstStrike() {\n+    final Unit targetUnit = givenAnyUnit();\n+    final Unit fireUnit = givenAnyUnit();\n+    final Unit fireUnit2 = givenUnitFirstStrike();\n+\n+    final List<FiringGroup> firingGroups =\n+        FiringGroupSplitterGeneral.of(OFFENSE, FiringGroupSplitterGeneral.Type.DEFENSIVE_NORMAL, \"\")", "originalCommit": "8f388871ab07f443bb05168d8c4b9557c3b603f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1MDkwOA==", "url": "https://github.com/triplea-game/triplea/pull/7829#discussion_r502950908", "bodyText": "Looking at these usage examples, and in the prod code, it looks like the update to a flag instead of passing a predicate was a strong update, it is a much nicer looking API now \ud83d\udc4d", "author": "DanVanAtta", "createdAt": "2020-10-11T18:40:29Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/general/FiringGroupSplitterGeneralTest.java", "diffHunk": "@@ -210,7 +283,7 @@ void excludeSuicideOnAttackTargetsIfDefense() {\n     final Unit fireUnit = givenAnyUnit();\n \n     final List<FiringGroup> firingGroups =\n-        FiringGroupSplitterGeneral.of(DEFENSE, unit -> true, \"\")", "originalCommit": "8f388871ab07f443bb05168d8c4b9557c3b603f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}