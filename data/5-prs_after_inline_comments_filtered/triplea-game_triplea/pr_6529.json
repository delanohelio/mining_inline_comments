{"pr_number": 6529, "pr_title": "Improve some battle history logging code.", "pr_createdAt": "2020-05-26T04:25:51Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6529", "timeline": [{"oid": "df5b962b236ca7bd88a2396d68be98be5b9d77a7", "url": "https://github.com/triplea-game/triplea/commit/df5b962b236ca7bd88a2396d68be98be5b9d77a7", "message": "Improve some battle history logging code.", "committedDate": "2020-05-26T04:24:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE0OTI2MQ==", "url": "https://github.com/triplea-game/triplea/pull/6529#discussion_r430149261", "bodyText": "Method addPlayerCombatHistoryText has a Cognitive Complexity of 11 (exceeds 7 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-05-26T04:27:23Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -668,92 +669,71 @@ private void removeAirNoLongerInTerritory() {\n     attackingUnits.removeAll(CollectionUtils.getMatches(attackingUnits, airNotInTerritory));\n   }\n \n-  private void writeUnitsToHistory(final IDelegateBridge bridge) {\n+  private void markAttackingTransports(final IDelegateBridge bridge) {\n     if (headless) {\n       return;\n     }\n-    final Set<GamePlayer> playerSet = battleSite.getUnitCollection().getPlayersWithUnits();\n-    // find all attacking players (unsorted)\n-    final Collection<GamePlayer> attackers = new ArrayList<>();\n-    for (final GamePlayer current : playerSet) {\n-      if (gameData.getRelationshipTracker().isAllied(attacker, current)\n-          || current.equals(attacker)) {\n-        attackers.add(current);\n-      }\n-    }\n-    final StringBuilder transcriptText = new StringBuilder();\n-    // find all attacking units (unsorted)\n-    final Collection<Unit> allAttackingUnits = new ArrayList<>();\n-    for (final Iterator<GamePlayer> attackersIter = attackers.iterator();\n-        attackersIter.hasNext(); ) {\n-      final GamePlayer current = attackersIter.next();\n-      final String delim;\n-      if (attackersIter.hasNext()) {\n-        delim = \"; \";\n-      } else {\n-        delim = \"\";\n-      }\n-      final Collection<Unit> attackingUnits =\n-          CollectionUtils.getMatches(this.attackingUnits, Matches.unitIsOwnedBy(current));\n-      final String verb = current.equals(attacker) ? \"attack\" : \"loiter and taunt\";\n-      transcriptText\n-          .append(current.getName())\n-          .append(\" \")\n-          .append(verb)\n-          .append(\n-              attackingUnits.isEmpty()\n-                  ? \"\"\n-                  : \" with \" + MyFormatter.unitsToTextNoOwner(attackingUnits))\n-          .append(delim);\n-      allAttackingUnits.addAll(attackingUnits);\n-      // If any attacking transports are in the battle, set their status to later restrict\n-      // load/unload\n-      if (current.equals(attacker)) {\n-        final CompositeChange change = new CompositeChange();\n-        final Collection<Unit> transports =\n-            CollectionUtils.getMatches(attackingUnits, Matches.unitCanTransport());\n-        for (final Unit unit : transports) {\n-          change.add(ChangeFactory.unitPropertyChange(unit, true, Unit.WAS_IN_COMBAT));\n-        }\n-        bridge.addChange(change);\n+    // If any attacking transports are in the battle, set their status to later restrict\n+    // load/unload\n+    final Collection<Unit> transports =\n+        CollectionUtils.getMatches(\n+            attackingUnits, Matches.unitCanTransport().and(Matches.unitIsOwnedBy(attacker)));\n+    if (!transports.isEmpty()) {\n+      final CompositeChange change = new CompositeChange();\n+      for (final Unit unit : transports) {\n+        change.add(ChangeFactory.unitPropertyChange(unit, true, Unit.WAS_IN_COMBAT));\n       }\n+      bridge.addChange(change);\n     }\n-    // write attacking units to history\n-    if (!attackingUnits.isEmpty()) {\n-      bridge.getHistoryWriter().addChildToEvent(transcriptText.toString(), allAttackingUnits);\n+  }\n+\n+  private void writeUnitsToHistory(final IDelegateBridge bridge) {\n+    if (headless) {\n+      return;\n     }\n-    // find all defending players (unsorted)\n-    final Collection<GamePlayer> defenders = new ArrayList<>();\n-    for (final GamePlayer current : playerSet) {\n-      if (gameData.getRelationshipTracker().isAllied(defender, current)\n-          || current.equals(defender)) {\n-        defenders.add(current);\n+    final Set<GamePlayer> playersWithUnits = battleSite.getUnitCollection().getPlayersWithUnits();\n+\n+    final Collection<GamePlayer> attackers = findAllies(playersWithUnits, attacker);\n+    addPlayerCombatHistoryText(attackers, attackingUnits, true, bridge.getHistoryWriter());\n+    final Collection<GamePlayer> defenders = findAllies(playersWithUnits, defender);\n+    addPlayerCombatHistoryText(defenders, defendingUnits, false, bridge.getHistoryWriter());\n+  }\n+\n+  private static Collection<GamePlayer> findAllies(\n+      final Collection<GamePlayer> candidatePlayers, final GamePlayer player) {\n+    final var relationshipTracker = player.getData().getRelationshipTracker();\n+    final Collection<GamePlayer> allies = new ArrayList<>();\n+    for (final GamePlayer current : candidatePlayers) {\n+      if (current.equals(player) || relationshipTracker.isAllied(player, current)) {\n+        allies.add(current);\n       }\n     }\n-    final StringBuilder transcriptBuilder = new StringBuilder();\n-    // find all defending units (unsorted)\n-    final Collection<Unit> allDefendingUnits = new ArrayList<>();\n-    for (final Iterator<GamePlayer> defendersIter = defenders.iterator();\n-        defendersIter.hasNext(); ) {\n-      final GamePlayer current = defendersIter.next();\n-      final String delim;\n-      if (defendersIter.hasNext()) {\n-        delim = \"; \";\n-      } else {\n-        delim = \"\";\n+    return allies;\n+  }\n+\n+  private void addPlayerCombatHistoryText(", "originalCommit": "df5b962b236ca7bd88a2396d68be98be5b9d77a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE1MDYwMQ==", "url": "https://github.com/triplea-game/triplea/pull/6529#discussion_r430150601", "bodyText": "This is OK because the following two existing findings are fixed:\nMethod writeUnitsToHistory has a Cognitive Complexity of 26 (exceeds 7 allowed). Consider refactoring.\nMethod writeUnitsToHistory has 78 lines of code (exceeds 30 allowed). Consider refactoring.\n\nhttps://codeclimate.com/github/triplea-game/triplea/pull/6529", "author": "asvitkine", "createdAt": "2020-05-26T04:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE0OTI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNTIxNg==", "url": "https://github.com/triplea-game/triplea/pull/6529#discussion_r432235216", "bodyText": "FWIW, this block could be re-written as follows:\nreturn candidatePlayers.stream()\n    .filter(current -> current.equals(player) || relationshipTracker.isAllied(player, current)\n    .collect(Collectors.toList());\n\nI somewhat feel like relationship tracker probably should own this logic though. EG:\nrelationshipTracker.getAllies(player, candidatePlayers);", "author": "DanVanAtta", "createdAt": "2020-05-29T03:23:03Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -668,92 +669,71 @@ private void removeAirNoLongerInTerritory() {\n     attackingUnits.removeAll(CollectionUtils.getMatches(attackingUnits, airNotInTerritory));\n   }\n \n-  private void writeUnitsToHistory(final IDelegateBridge bridge) {\n+  private void markAttackingTransports(final IDelegateBridge bridge) {\n     if (headless) {\n       return;\n     }\n-    final Set<GamePlayer> playerSet = battleSite.getUnitCollection().getPlayersWithUnits();\n-    // find all attacking players (unsorted)\n-    final Collection<GamePlayer> attackers = new ArrayList<>();\n-    for (final GamePlayer current : playerSet) {\n-      if (gameData.getRelationshipTracker().isAllied(attacker, current)\n-          || current.equals(attacker)) {\n-        attackers.add(current);\n-      }\n-    }\n-    final StringBuilder transcriptText = new StringBuilder();\n-    // find all attacking units (unsorted)\n-    final Collection<Unit> allAttackingUnits = new ArrayList<>();\n-    for (final Iterator<GamePlayer> attackersIter = attackers.iterator();\n-        attackersIter.hasNext(); ) {\n-      final GamePlayer current = attackersIter.next();\n-      final String delim;\n-      if (attackersIter.hasNext()) {\n-        delim = \"; \";\n-      } else {\n-        delim = \"\";\n-      }\n-      final Collection<Unit> attackingUnits =\n-          CollectionUtils.getMatches(this.attackingUnits, Matches.unitIsOwnedBy(current));\n-      final String verb = current.equals(attacker) ? \"attack\" : \"loiter and taunt\";\n-      transcriptText\n-          .append(current.getName())\n-          .append(\" \")\n-          .append(verb)\n-          .append(\n-              attackingUnits.isEmpty()\n-                  ? \"\"\n-                  : \" with \" + MyFormatter.unitsToTextNoOwner(attackingUnits))\n-          .append(delim);\n-      allAttackingUnits.addAll(attackingUnits);\n-      // If any attacking transports are in the battle, set their status to later restrict\n-      // load/unload\n-      if (current.equals(attacker)) {\n-        final CompositeChange change = new CompositeChange();\n-        final Collection<Unit> transports =\n-            CollectionUtils.getMatches(attackingUnits, Matches.unitCanTransport());\n-        for (final Unit unit : transports) {\n-          change.add(ChangeFactory.unitPropertyChange(unit, true, Unit.WAS_IN_COMBAT));\n-        }\n-        bridge.addChange(change);\n+    // If any attacking transports are in the battle, set their status to later restrict\n+    // load/unload\n+    final Collection<Unit> transports =\n+        CollectionUtils.getMatches(\n+            attackingUnits, Matches.unitCanTransport().and(Matches.unitIsOwnedBy(attacker)));\n+    if (!transports.isEmpty()) {\n+      final CompositeChange change = new CompositeChange();\n+      for (final Unit unit : transports) {\n+        change.add(ChangeFactory.unitPropertyChange(unit, true, Unit.WAS_IN_COMBAT));\n       }\n+      bridge.addChange(change);\n     }\n-    // write attacking units to history\n-    if (!attackingUnits.isEmpty()) {\n-      bridge.getHistoryWriter().addChildToEvent(transcriptText.toString(), allAttackingUnits);\n+  }\n+\n+  private void writeUnitsToHistory(final IDelegateBridge bridge) {\n+    if (headless) {\n+      return;\n     }\n-    // find all defending players (unsorted)\n-    final Collection<GamePlayer> defenders = new ArrayList<>();\n-    for (final GamePlayer current : playerSet) {\n-      if (gameData.getRelationshipTracker().isAllied(defender, current)\n-          || current.equals(defender)) {\n-        defenders.add(current);\n+    final Set<GamePlayer> playersWithUnits = battleSite.getUnitCollection().getPlayersWithUnits();\n+\n+    final Collection<GamePlayer> attackers = findAllies(playersWithUnits, attacker);\n+    addPlayerCombatHistoryText(attackers, attackingUnits, true, bridge.getHistoryWriter());\n+    final Collection<GamePlayer> defenders = findAllies(playersWithUnits, defender);\n+    addPlayerCombatHistoryText(defenders, defendingUnits, false, bridge.getHistoryWriter());\n+  }\n+\n+  private static Collection<GamePlayer> findAllies(\n+      final Collection<GamePlayer> candidatePlayers, final GamePlayer player) {\n+    final var relationshipTracker = player.getData().getRelationshipTracker();\n+    final Collection<GamePlayer> allies = new ArrayList<>();", "originalCommit": "df5b962b236ca7bd88a2396d68be98be5b9d77a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNTM5Mg==", "url": "https://github.com/triplea-game/triplea/pull/6529#discussion_r432235392", "bodyText": "There's certainly more places where we can simplify or 'fix' responsibilities and change logic ownership, but I recognize we are mostly moving code here.", "author": "DanVanAtta", "createdAt": "2020-05-29T03:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNjM2Ng==", "url": "https://github.com/triplea-game/triplea/pull/6529#discussion_r432236366", "bodyText": "This could potentially be slightly simpler written as:\n    if (!headless) {\n      markAttackingTransports(bridge);\n      writeUnitsToHistory(bridge);\n    }\n\nEssentially we're bringing the no-op method check to the point of the caller instead of in the method. This way if you are looking at the higher level flow, you can more easily follow the branching logic. As-is, with a series of void methods, to some extent they almost may as well be inlined with demarcating comments, a reader has to jump through each one to understand what is happening. Hence, bringing the logic flow out of the lower level methods allows a reader to see the code flow at a higher level without jumping to each method.", "author": "DanVanAtta", "createdAt": "2020-05-29T03:28:31Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -601,6 +601,7 @@ public void fight(final IDelegateBridge bridge) {\n     }\n     bridge.getHistoryWriter().startEvent(\"Battle in \" + battleSite, battleSite);\n     removeAirNoLongerInTerritory();\n+    markAttackingTransports(bridge);", "originalCommit": "df5b962b236ca7bd88a2396d68be98be5b9d77a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}